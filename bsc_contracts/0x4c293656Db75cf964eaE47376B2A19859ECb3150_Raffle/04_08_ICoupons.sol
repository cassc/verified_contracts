// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

interface ICoupons{

    struct Coupon {
        bytes32 couponHash;
        uint8 minPct;
        uint8 maxPct;
        uint16 multiplierPct;
        bool isPaid;
    }

    struct CouponRule {
        uint16 minRndPct;
        uint16 maxRndPct;
        uint16 step;
        bool allowExtMultiplier;    // Allow external multiplier
    }

    struct CouponPrice {
        address tokenAddress;       // if address 0x0 - this is base currency
        uint couponFee;
    }

    struct CouponTicket {
        address playerAddress;
        uint16 multiplierPct;
        bool used;
    }

    function getCoupon(
        bytes32 couponHash,
        address playerAddress,
        address contractAddress,
        uint32 raffleId
    ) external view returns (Coupon memory);

    /*
     * @notice Buy a coupon for tokens with predefined multiplier percentage.
     * @dev If the sale is for erc20 tokens, then the payment amount in the transaction
     * 'msg.value' must be set to zero.
     *
     * @param contractAddress The address of the drop game contract.
     * @param raffleId The draw Id.
     * @param tokenAddress The address of the payment token. Use address(0) for native token payments.
     * @param amount `amount` of tokens to pay. For the native token must be 0
     * @param multiplierPct Multiplier percentage.
     *        If set to 0, the value will be generated by the contract based on the rule.
     * @return void
     */
    function buyCoupon(
        address contractAddress,
        uint32 raffleId,
        address tokenAddress,
        uint256 amount,
        uint16 multiplierPct
    ) external payable;

    function useCoupon(
        bytes32 couponHash,
        address playerAddress,
        uint32 raffleId
    ) external returns (Coupon memory);

    function getCouponTicket(
        address contractAddress,
        uint32 raffleId,
        bytes32 couponHash
    ) external returns (CouponTicket memory);
}