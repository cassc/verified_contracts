{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PairLauncher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {IButtonswapFactory} from\\n    \\\"buttonswap-periphery_buttonswap-core/interfaces/IButtonswapFactory/IButtonswapFactory.sol\\\";\\nimport {IButtonswapPair} from \\\"buttonswap-periphery_buttonswap-core/interfaces/IButtonswapPair/IButtonswapPair.sol\\\";\\nimport {TransferHelper} from \\\"./libraries/TransferHelper.sol\\\";\\n\\ncontract PairLauncher {\\n    struct PairData {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountA;\\n        uint256 amountB;\\n    }\\n\\n    IButtonswapFactory public immutable factory;\\n    address public immutable launcher;\\n    address public immutable originalIsCreationRestrictedSetter;\\n    PairData[] public pairStack;\\n\\n    modifier onlyLauncher() {\\n        if (msg.sender != launcher) {\\n            revert();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyLauncherOrOriginalSetter() {\\n        if (msg.sender != launcher && msg.sender != originalIsCreationRestrictedSetter) {\\n            revert();\\n        }\\n        _;\\n    }\\n\\n    constructor(address _launcher, address _originalIsCreationRestrictedSetter, address _factory) {\\n        launcher = _launcher;\\n        originalIsCreationRestrictedSetter = _originalIsCreationRestrictedSetter;\\n        factory = IButtonswapFactory(_factory);\\n    }\\n\\n    // Only callable by the launcher\\n    function returnPermissions() external onlyLauncherOrOriginalSetter {\\n        factory.setIsCreationRestrictedSetter(originalIsCreationRestrictedSetter);\\n    }\\n\\n    // Only callable by the launcher\\n    function enqueuePair(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external onlyLauncher {\\n        pairStack.push(PairData(tokenA, tokenB, amountA, amountB));\\n    }\\n\\n    function _createTopPair() internal {\\n        // Pop the top of the stack\\n        PairData memory pairData = pairStack[pairStack.length - 1];\\n        pairStack.pop();\\n\\n        address pair = factory.createPair(pairData.tokenA, pairData.tokenB);\\n        address tokenA = pairData.tokenA;\\n        address tokenB = pairData.tokenB;\\n        uint256 amountA = pairData.amountA;\\n        uint256 amountB = pairData.amountB;\\n\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountA);\\n        TransferHelper.safeApprove(tokenA, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountB);\\n        TransferHelper.safeApprove(tokenB, pair, amountB);\\n\\n        if (tokenA < tokenB) {\\n            IButtonswapPair(pair).mint(amountA, amountB, launcher);\\n        } else {\\n            IButtonswapPair(pair).mint(amountB, amountA, launcher);\\n        }\\n    }\\n\\n    function batchCreate5() external onlyLauncher {\\n        for (uint256 i = 0; i < 5; i++) {\\n            if (pairStack.length == 0) {\\n                return;\\n            }\\n            _createTopPair();\\n        }\\n    }\\n\\n    function destroy() external onlyLauncherOrOriginalSetter {\\n        if (factory.isCreationRestrictedSetter() != originalIsCreationRestrictedSetter) {\\n            revert();\\n        }\\n        selfdestruct(payable(launcher));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapFactory/IButtonswapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IButtonswapFactoryErrors} from \\\"./IButtonswapFactoryErrors.sol\\\";\\nimport {IButtonswapFactoryEvents} from \\\"./IButtonswapFactoryEvents.sol\\\";\\n\\ninterface IButtonswapFactory is IButtonswapFactoryErrors, IButtonswapFactoryEvents {\\n    /**\\n     * @notice Returns the current address for `feeTo`.\\n     * The owner of this address receives the protocol fee as it is collected over time.\\n     * @return _feeTo The `feeTo` address\\n     */\\n    function feeTo() external view returns (address _feeTo);\\n\\n    /**\\n     * @notice Returns the current address for `feeToSetter`.\\n     * The owner of this address has the power to update both `feeToSetter` and `feeTo`.\\n     * @return _feeToSetter The `feeToSetter` address\\n     */\\n    function feeToSetter() external view returns (address _feeToSetter);\\n\\n    /**\\n     * @notice The name of the ERC20 liquidity token.\\n     * @return _tokenName The `tokenName`\\n     */\\n    function tokenName() external view returns (string memory _tokenName);\\n\\n    /**\\n     * @notice The symbol of the ERC20 liquidity token.\\n     * @return _tokenSymbol The `tokenSymbol`\\n     */\\n    function tokenSymbol() external view returns (string memory _tokenSymbol);\\n\\n    /**\\n     * @notice Returns the current state of restricted creation.\\n     * If true, then no new pairs, only feeToSetter can create new pairs\\n     * @return _isCreationRestricted The `isCreationRestricted` state\\n     */\\n    function isCreationRestricted() external view returns (bool _isCreationRestricted);\\n\\n    /**\\n     * @notice Returns the current address for `isCreationRestrictedSetter`.\\n     * The owner of this address has the power to update both `isCreationRestrictedSetter` and `isCreationRestricted`.\\n     * @return _isCreationRestrictedSetter The `isCreationRestrictedSetter` address\\n     */\\n    function isCreationRestrictedSetter() external view returns (address _isCreationRestrictedSetter);\\n\\n    /**\\n     * @notice Get the (unique) Pair address created for the given combination of `tokenA` and `tokenB`.\\n     * If the Pair does not exist then zero address is returned.\\n     * @param tokenA The first unsorted token\\n     * @param tokenB The second unsorted token\\n     * @return pair The address of the Pair instance\\n     */\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    /**\\n     * @notice Get the Pair address at the given `index`, ordered chronologically.\\n     * @param index The index to query\\n     * @return pair The address of the Pair created at the given `index`\\n     */\\n    function allPairs(uint256 index) external view returns (address pair);\\n\\n    /**\\n     * @notice Get the current total number of Pairs created\\n     * @return count The total number of Pairs created\\n     */\\n    function allPairsLength() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Creates a new {ButtonswapPair} instance for the given unsorted tokens `tokenA` and `tokenB`.\\n     * @dev The tokens are sorted later, but can be provided to this method in either order.\\n     * @param tokenA The first unsorted token address\\n     * @param tokenB The second unsorted token address\\n     * @return pair The address of the new {ButtonswapPair} instance\\n     */\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    /**\\n     * @notice Updates the address that receives the protocol fee.\\n     * This can only be called by the `feeToSetter` address.\\n     * @param _feeTo The new address\\n     */\\n    function setFeeTo(address _feeTo) external;\\n\\n    /**\\n     * @notice Updates the address that has the power to set the `feeToSetter` and `feeTo` addresses.\\n     * This can only be called by the `feeToSetter` address.\\n     * @param _feeToSetter The new address\\n     */\\n    function setFeeToSetter(address _feeToSetter) external;\\n\\n    /**\\n     * @notice Updates the state of restricted creation.\\n     * This can only be called by the `feeToSetter` address.\\n     * @param _isCreationRestricted The new state\\n     */\\n    function setIsCreationRestricted(bool _isCreationRestricted) external;\\n\\n    /**\\n     * @notice Updates the address that has the power to set the `isCreationRestrictedSetter` and `isCreationRestricted`.\\n     * This can only be called by the `isCreationRestrictedSetter` address.\\n     * @param _isCreationRestrictedSetter The new address\\n     */\\n    function setIsCreationRestrictedSetter(address _isCreationRestrictedSetter) external;\\n\\n    /**\\n     * @notice Returns the current address for `isPausedSetter`.\\n     * The owner of this address has the power to update both `isPausedSetter` and call `setIsPaused`.\\n     * @return _isPausedSetter The `isPausedSetter` address\\n     */\\n    function isPausedSetter() external view returns (address _isPausedSetter);\\n\\n    /**\\n     * @notice Updates the address that has the power to set the `isPausedSetter` and call `setIsPaused`.\\n     * This can only be called by the `isPausedSetter` address.\\n     * @param _isPausedSetter The new address\\n     */\\n    function setIsPausedSetter(address _isPausedSetter) external;\\n\\n    /**\\n     * @notice Updates the pause state of given Pairs.\\n     * This can only be called by the `feeToSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param isPausedNew The new pause state\\n     */\\n    function setIsPaused(address[] calldata pairs, bool isPausedNew) external;\\n\\n    /**\\n     * @notice Returns the current address for `paramSetter`.\\n     * The owner of this address has the power to update `paramSetter`, default parameters, and current parameters on existing pairs\\n     * @return _paramSetter The `paramSetter` address\\n     */\\n    function paramSetter() external view returns (address _paramSetter);\\n\\n    /**\\n     * @notice Updates the address that has the power to set the `paramSetter` and update the default params.\\n     * This can only be called by the `paramSetter` address.\\n     * @param _paramSetter The new address\\n     */\\n    function setParamSetter(address _paramSetter) external;\\n\\n    /**\\n     * @notice Returns the default value of `movingAverageWindow` used for new pairs.\\n     * @return _defaultMovingAverageWindow The `defaultMovingAverageWindow` value\\n     */\\n    function defaultMovingAverageWindow() external view returns (uint32 _defaultMovingAverageWindow);\\n\\n    /**\\n     * @notice Returns the default value of `maxVolatilityBps` used for new pairs.\\n     * @return _defaultMaxVolatilityBps The `defaultMaxVolatilityBps` value\\n     */\\n    function defaultMaxVolatilityBps() external view returns (uint16 _defaultMaxVolatilityBps);\\n\\n    /**\\n     * @notice Returns the default value of `minTimelockDuration` used for new pairs.\\n     * @return _defaultMinTimelockDuration The `defaultMinTimelockDuration` value\\n     */\\n    function defaultMinTimelockDuration() external view returns (uint32 _defaultMinTimelockDuration);\\n\\n    /**\\n     * @notice Returns the default value of `maxTimelockDuration` used for new pairs.\\n     * @return _defaultMaxTimelockDuration The `defaultMaxTimelockDuration` value\\n     */\\n    function defaultMaxTimelockDuration() external view returns (uint32 _defaultMaxTimelockDuration);\\n\\n    /**\\n     * @notice Returns the default value of `maxSwappableReservoirLimitBps` used for new pairs.\\n     * @return _defaultMaxSwappableReservoirLimitBps The `defaultMaxSwappableReservoirLimitBps` value\\n     */\\n    function defaultMaxSwappableReservoirLimitBps()\\n        external\\n        view\\n        returns (uint16 _defaultMaxSwappableReservoirLimitBps);\\n\\n    /**\\n     * @notice Returns the default value of `swappableReservoirGrowthWindow` used for new pairs.\\n     * @return _defaultSwappableReservoirGrowthWindow The `defaultSwappableReservoirGrowthWindow` value\\n     */\\n    function defaultSwappableReservoirGrowthWindow()\\n        external\\n        view\\n        returns (uint32 _defaultSwappableReservoirGrowthWindow);\\n\\n    /**\\n     * @notice Updates the default parameters used for new pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param newDefaultMovingAverageWindow The new defaultMovingAverageWindow\\n     * @param newDefaultMaxVolatilityBps The new defaultMaxVolatilityBps\\n     * @param newDefaultMinTimelockDuration The new defaultMinTimelockDuration\\n     * @param newDefaultMaxTimelockDuration The new defaultMaxTimelockDuration\\n     * @param newDefaultMaxSwappableReservoirLimitBps The new defaultMaxSwappableReservoirLimitBps\\n     * @param newDefaultSwappableReservoirGrowthWindow The new defaultSwappableReservoirGrowthWindow\\n     */\\n    function setDefaultParameters(\\n        uint32 newDefaultMovingAverageWindow,\\n        uint16 newDefaultMaxVolatilityBps,\\n        uint32 newDefaultMinTimelockDuration,\\n        uint32 newDefaultMaxTimelockDuration,\\n        uint16 newDefaultMaxSwappableReservoirLimitBps,\\n        uint32 newDefaultSwappableReservoirGrowthWindow\\n    ) external;\\n\\n    /**\\n     * @notice Updates the `movingAverageWindow` value of given Pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param newMovingAverageWindow The new `movingAverageWindow` value\\n     */\\n    function setMovingAverageWindow(address[] calldata pairs, uint32 newMovingAverageWindow) external;\\n\\n    /**\\n     * @notice Updates the `maxVolatilityBps` value of given Pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param newMaxVolatilityBps The new `maxVolatilityBps` value\\n     */\\n    function setMaxVolatilityBps(address[] calldata pairs, uint16 newMaxVolatilityBps) external;\\n\\n    /**\\n     * @notice Updates the `minTimelockDuration` value of given Pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param newMinTimelockDuration The new `minTimelockDuration` value\\n     */\\n    function setMinTimelockDuration(address[] calldata pairs, uint32 newMinTimelockDuration) external;\\n\\n    /**\\n     * @notice Updates the `maxTimelockDuration` value of given Pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param newMaxTimelockDuration The new `maxTimelockDuration` value\\n     */\\n    function setMaxTimelockDuration(address[] calldata pairs, uint32 newMaxTimelockDuration) external;\\n\\n    /**\\n     * @notice Updates the `maxSwappableReservoirLimitBps` value of given Pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param newMaxSwappableReservoirLimitBps The new `maxSwappableReservoirLimitBps` value\\n     */\\n    function setMaxSwappableReservoirLimitBps(address[] calldata pairs, uint16 newMaxSwappableReservoirLimitBps)\\n        external;\\n\\n    /**\\n     * @notice Updates the `swappableReservoirGrowthWindow` value of given Pairs.\\n     * This can only be called by the `paramSetter` address.\\n     * @param pairs A list of addresses for the pairs that should be updated\\n     * @param newSwappableReservoirGrowthWindow The new `swappableReservoirGrowthWindow` value\\n     */\\n    function setSwappableReservoirGrowthWindow(address[] calldata pairs, uint32 newSwappableReservoirGrowthWindow)\\n        external;\\n\\n    /**\\n     * @notice Returns the last token pair created and the parameters used.\\n     * @return token0 The first token address\\n     * @return token1 The second token address\\n     * @return movingAverageWindow The moving average window\\n     * @return maxVolatilityBps The max volatility bps\\n     * @return minTimelockDuration The minimum time lock duration\\n     * @return maxTimelockDuration The maximum time lock duration\\n     * @return maxSwappableReservoirLimitBps The max swappable reservoir limit bps\\n     * @return swappableReservoirGrowthWindow The swappable reservoir growth window\\n     */\\n    function lastCreatedTokensAndParameters()\\n        external\\n        returns (\\n            address token0,\\n            address token1,\\n            uint32 movingAverageWindow,\\n            uint16 maxVolatilityBps,\\n            uint32 minTimelockDuration,\\n            uint32 maxTimelockDuration,\\n            uint16 maxSwappableReservoirLimitBps,\\n            uint32 swappableReservoirGrowthWindow\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapPair/IButtonswapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IButtonswapPairErrors} from \\\"./IButtonswapPairErrors.sol\\\";\\nimport {IButtonswapPairEvents} from \\\"./IButtonswapPairEvents.sol\\\";\\nimport {IButtonswapERC20} from \\\"../IButtonswapERC20/IButtonswapERC20.sol\\\";\\n\\ninterface IButtonswapPair is IButtonswapPairErrors, IButtonswapPairEvents, IButtonswapERC20 {\\n    /**\\n     * @notice The smallest value that {IButtonswapERC20-totalSupply} can be.\\n     * @dev After the first mint the total liquidity (represented by the liquidity token total supply) can never drop below this value.\\n     *\\n     * This is to protect against an attack where the attacker mints a very small amount of liquidity, and then donates pool tokens to skew the ratio.\\n     * This results in future minters receiving no liquidity tokens when they deposit.\\n     * By enforcing a minimum liquidity value this attack becomes prohibitively expensive to execute.\\n     * @return MINIMUM_LIQUIDITY The MINIMUM_LIQUIDITY value\\n     */\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256 MINIMUM_LIQUIDITY);\\n\\n    /**\\n     * @notice The duration for which the moving average is calculated for.\\n     * @return _movingAverageWindow The value of movingAverageWindow\\n     */\\n    function movingAverageWindow() external view returns (uint32 _movingAverageWindow);\\n\\n    /**\\n     * @notice Updates the movingAverageWindow parameter of the pair.\\n     * This can only be called by the Factory address.\\n     * Refer to [parameters.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/parameters.md#movingaveragewindow) for more detail.\\n     * @param newMovingAverageWindow The new value for movingAverageWindow\\n     */\\n    function setMovingAverageWindow(uint32 newMovingAverageWindow) external;\\n\\n    /**\\n     * @notice Numerator (over 10_000) of the threshold when price volatility triggers maximum single-sided timelock duration.\\n     * @return _maxVolatilityBps The value of maxVolatilityBps\\n     */\\n    function maxVolatilityBps() external view returns (uint16 _maxVolatilityBps);\\n\\n    /**\\n     * @notice Updates the maxVolatilityBps parameter of the pair.\\n     * This can only be called by the Factory address.\\n     * Refer to [parameters.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/parameters.md#maxvolatilitybps) for more detail.\\n     * @param newMaxVolatilityBps The new value for maxVolatilityBps\\n     */\\n    function setMaxVolatilityBps(uint16 newMaxVolatilityBps) external;\\n\\n    /**\\n     * @notice How long the minimum singled-sided timelock lasts for.\\n     * @return _minTimelockDuration The value of minTimelockDuration\\n     */\\n    function minTimelockDuration() external view returns (uint32 _minTimelockDuration);\\n\\n    /**\\n     * @notice Updates the minTimelockDuration parameter of the pair.\\n     * This can only be called by the Factory address.\\n     * Refer to [parameters.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/parameters.md#mintimelockduration) for more detail.\\n     * @param newMinTimelockDuration The new value for minTimelockDuration\\n     */\\n    function setMinTimelockDuration(uint32 newMinTimelockDuration) external;\\n\\n    /**\\n     * @notice How long the maximum singled-sided timelock lasts for.\\n     * @return _maxTimelockDuration The value of maxTimelockDuration\\n     */\\n    function maxTimelockDuration() external view returns (uint32 _maxTimelockDuration);\\n\\n    /**\\n     * @notice Updates the maxTimelockDuration parameter of the pair.\\n     * This can only be called by the Factory address.\\n     * Refer to [parameters.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/parameters.md#maxtimelockduration) for more detail.\\n     * @param newMaxTimelockDuration The new value for maxTimelockDuration\\n     */\\n    function setMaxTimelockDuration(uint32 newMaxTimelockDuration) external;\\n\\n    /**\\n     * @notice Numerator (over 10_000) of the fraction of the pool balance that acts as the maximum limit on how much of the reservoir\\n     * can be swapped in a given timeframe.\\n     * @return _maxSwappableReservoirLimitBps The value of maxSwappableReservoirLimitBps\\n     */\\n    function maxSwappableReservoirLimitBps() external view returns (uint16 _maxSwappableReservoirLimitBps);\\n\\n    /**\\n     * @notice Updates the maxSwappableReservoirLimitBps parameter of the pair.\\n     * This can only be called by the Factory address.\\n     * Refer to [parameters.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/parameters.md#maxswappablereservoirlimitbps) for more detail.\\n     * @param newMaxSwappableReservoirLimitBps The new value for maxSwappableReservoirLimitBps\\n     */\\n    function setMaxSwappableReservoirLimitBps(uint16 newMaxSwappableReservoirLimitBps) external;\\n\\n    /**\\n     * @notice How much time it takes for the swappable reservoir value to grow from nothing to its maximum value.\\n     * @return _swappableReservoirGrowthWindow The value of swappableReservoirGrowthWindow\\n     */\\n    function swappableReservoirGrowthWindow() external view returns (uint32 _swappableReservoirGrowthWindow);\\n\\n    /**\\n     * @notice Updates the swappableReservoirGrowthWindow parameter of the pair.\\n     * This can only be called by the Factory address.\\n     * Refer to [parameters.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/parameters.md#swappablereservoirgrowthwindow) for more detail.\\n     * @param newSwappableReservoirGrowthWindow The new value for swappableReservoirGrowthWindow\\n     */\\n    function setSwappableReservoirGrowthWindow(uint32 newSwappableReservoirGrowthWindow) external;\\n\\n    /**\\n     * @notice The address of the {ButtonswapFactory} instance used to create this Pair.\\n     * @dev Set to `msg.sender` in the Pair constructor.\\n     * @return factory The factory address\\n     */\\n    function factory() external view returns (address factory);\\n\\n    /**\\n     * @notice The address of the first sorted token.\\n     * @return token0 The token address\\n     */\\n    function token0() external view returns (address token0);\\n\\n    /**\\n     * @notice The address of the second sorted token.\\n     * @return token1 The token address\\n     */\\n    function token1() external view returns (address token1);\\n\\n    /**\\n     * @notice The time-weighted average price of the Pair.\\n     * The price is of `token0` in terms of `token1`.\\n     * @dev The price is represented as a [UQ112x112](https://en.wikipedia.org/wiki/Q_(number_format)) to maintain precision.\\n     * Consequently this value must be divided by `2^112` to get the actual price.\\n     *\\n     * Because of the time weighting, `price0CumulativeLast` must also be divided by the total Pair lifetime to get the average price over that time period.\\n     * @return price0CumulativeLast The current cumulative `token0` price\\n     */\\n    function price0CumulativeLast() external view returns (uint256 price0CumulativeLast);\\n\\n    /**\\n     * @notice The time-weighted average price of the Pair.\\n     * The price is of `token1` in terms of `token0`.\\n     * @dev The price is represented as a [UQ112x112](https://en.wikipedia.org/wiki/Q_(number_format)) to maintain precision.\\n     * Consequently this value must be divided by `2^112` to get the actual price.\\n     *\\n     * Because of the time weighting, `price1CumulativeLast` must also be divided by the total Pair lifetime to get the average price over that time period.\\n     * @return price1CumulativeLast The current cumulative `token1` price\\n     */\\n    function price1CumulativeLast() external view returns (uint256 price1CumulativeLast);\\n\\n    /**\\n     * @notice The timestamp for when the single-sided timelock concludes.\\n     * The timelock is initiated based on price volatility of swaps over the last `movingAverageWindow`, and can be\\n     *   extended by new swaps if they are sufficiently volatile.\\n     * The timelock protects against attempts to manipulate the price that is used to valuate the reservoir tokens during\\n     *   single-sided operations.\\n     * It also guards against general legitimate volatility, as it is preferable to defer single-sided operations until\\n     *   it is clearer what the market considers the price to be.\\n     * @return singleSidedTimelockDeadline The current deadline timestamp\\n     */\\n    function singleSidedTimelockDeadline() external view returns (uint120 singleSidedTimelockDeadline);\\n\\n    /**\\n     * @notice The timestamp by which the amount of reservoir tokens that can be exchanged during a single-sided operation\\n     *   reaches its maximum value.\\n     * This maximum value is not necessarily the entirety of the reservoir, instead being calculated as a fraction of the\\n     *   corresponding token's active liquidity.\\n     * @return swappableReservoirLimitReachesMaxDeadline The current deadline timestamp\\n     */\\n    function swappableReservoirLimitReachesMaxDeadline()\\n        external\\n        view\\n        returns (uint120 swappableReservoirLimitReachesMaxDeadline);\\n\\n    /**\\n     * @notice Returns the current limit on the number of reservoir tokens that can be exchanged during a single-sided mint/burn operation.\\n     * @return swappableReservoirLimit The amount of reservoir token that can be exchanged\\n     */\\n    function getSwappableReservoirLimit() external view returns (uint256 swappableReservoirLimit);\\n\\n    /**\\n     * @notice Whether the Pair is currently paused\\n     * @return _isPaused The paused state\\n     */\\n    function getIsPaused() external view returns (bool _isPaused);\\n\\n    /**\\n     * @notice Updates the pause state.\\n     * This can only be called by the Factory address.\\n     * @param isPausedNew The new value for isPaused\\n     */\\n    function setIsPaused(bool isPausedNew) external;\\n\\n    /**\\n     * @notice Get the current liquidity values.\\n     * @return _pool0 The active `token0` liquidity\\n     * @return _pool1 The active `token1` liquidity\\n     * @return _reservoir0 The inactive `token0` liquidity\\n     * @return _reservoir1 The inactive `token1` liquidity\\n     * @return _blockTimestampLast The timestamp of when the price was last updated\\n     */\\n    function getLiquidityBalances()\\n        external\\n        view\\n        returns (uint112 _pool0, uint112 _pool1, uint112 _reservoir0, uint112 _reservoir1, uint32 _blockTimestampLast);\\n\\n    /**\\n     * @notice The current `movingAveragePrice0` value, based on the current block timestamp.\\n     * @dev This is the `token0` price, time weighted to prevent manipulation.\\n     * Refer to [reservoir-valuation.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/reservoir-valuation.md#price-stability) for more detail.\\n     *\\n     * The price is represented as a [UQ112x112](https://en.wikipedia.org/wiki/Q_(number_format)) to maintain precision.\\n     * It is used to valuate the reservoir tokens that are exchanged during single-sided operations.\\n     * @return _movingAveragePrice0 The current `movingAveragePrice0` value\\n     */\\n    function movingAveragePrice0() external view returns (uint256 _movingAveragePrice0);\\n\\n    /**\\n     * @notice Mints new liquidity tokens to `to` based on `amountIn0` of `token0` and `amountIn1  of`token1` deposited.\\n     * Expects both tokens to be deposited in a ratio that matches the current Pair price.\\n     * @dev The token deposits are deduced to be the delta between token balance before and after the transfers in order to account for unusual tokens.\\n     * Refer to [mint-math.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/mint-math.md#dual-sided-mint) for more detail.\\n     * @param amountIn0 The amount of `token0` that should be transferred in from the user\\n     * @param amountIn1 The amount of `token1` that should be transferred in from the user\\n     * @param to The account that receives the newly minted liquidity tokens\\n     * @return liquidityOut THe amount of liquidity tokens minted\\n     */\\n    function mint(uint256 amountIn0, uint256 amountIn1, address to) external returns (uint256 liquidityOut);\\n\\n    /**\\n     * @notice Mints new liquidity tokens to `to` based on how much `token0` or `token1` has been deposited.\\n     * The token transferred is the one that the Pair does not have a non-zero inactive liquidity balance for.\\n     * Expects only one token to be deposited, so that it can be paired with the other token's inactive liquidity.\\n     * @dev The token deposits are deduced to be the delta between token balance before and after the transfers in order to account for unusual tokens.\\n     * Refer to [mint-math.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/mint-math.md#single-sided-mint) for more detail.\\n     * @param amountIn The amount of tokens that should be transferred in from the user\\n     * @param to The account that receives the newly minted liquidity tokens\\n     * @return liquidityOut THe amount of liquidity tokens minted\\n     */\\n    function mintWithReservoir(uint256 amountIn, address to) external returns (uint256 liquidityOut);\\n\\n    /**\\n     * @notice Burns `liquidityIn` liquidity tokens to redeem to `to` the corresponding `amountOut0` of `token0` and `amountOut1` of `token1`.\\n     * @dev Refer to [burn-math.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/burn-math.md#dual-sided-burn) for more detail.\\n     * @param liquidityIn The amount of liquidity tokens to burn\\n     * @param to The account that receives the redeemed tokens\\n     * @return amountOut0 The amount of `token0` that the liquidity tokens are redeemed for\\n     * @return amountOut1 The amount of `token1` that the liquidity tokens are redeemed for\\n     */\\n    function burn(uint256 liquidityIn, address to) external returns (uint256 amountOut0, uint256 amountOut1);\\n\\n    /**\\n     * @notice Burns `liquidityIn` liquidity tokens to redeem to `to` the corresponding `amountOut0` of `token0` and `amountOut1` of `token1`.\\n     * Only returns tokens from the non-zero inactive liquidity balance, meaning one of `amountOut0` and `amountOut1` will be zero.\\n     * @dev Refer to [burn-math.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/burn-math.md#single-sided-burn) for more detail.\\n     * @param liquidityIn The amount of liquidity tokens to burn\\n     * @param to The account that receives the redeemed tokens\\n     * @return amountOut0 The amount of `token0` that the liquidity tokens are redeemed for\\n     * @return amountOut1 The amount of `token1` that the liquidity tokens are redeemed for\\n     */\\n    function burnFromReservoir(uint256 liquidityIn, address to)\\n        external\\n        returns (uint256 amountOut0, uint256 amountOut1);\\n\\n    /**\\n     * @notice Swaps one token for the other, taking `amountIn0` of `token0` and `amountIn1` of `token1` from the sender and sending `amountOut0` of `token0` and `amountOut1` of `token1` to `to`.\\n     * The price of the swap is determined by maintaining the \\\"K Invariant\\\".\\n     * A 0.3% fee is collected to distribute between liquidity providers and the protocol.\\n     * @dev The token deposits are deduced to be the delta between the current Pair contract token balances and the last stored balances.\\n     * Optional calldata can be passed to `data`, which will be used to confirm the output token transfer with `to` if `to` is a contract that implements the {IButtonswapCallee} interface.\\n     * Refer to [swap-math.md](https://github.com/buttonwood-protocol/buttonswap-core/blob/main/notes/swap-math.md) for more detail.\\n     * @param amountIn0 The amount of `token0` that the sender sends\\n     * @param amountIn1 The amount of `token1` that the sender sends\\n     * @param amountOut0 The amount of `token0` that the recipient receives\\n     * @param amountOut1 The amount of `token1` that the recipient receives\\n     * @param to The account that receives the swap output\\n     */\\n    function swap(uint256 amountIn0, uint256 amountIn1, uint256 amountOut0, uint256 amountOut1, address to) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// ToDo: Replace with solmate/SafeTransferLib\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint256 value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransfer(address token, address to, uint256 value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success,) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper: ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapFactory/IButtonswapFactoryErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\ninterface IButtonswapFactoryErrors {\\n    /**\\n     * @notice The given token addresses are the same\\n     */\\n    error TokenIdenticalAddress();\\n\\n    /**\\n     * @notice The given token address is the zero address\\n     */\\n    error TokenZeroAddress();\\n\\n    /**\\n     * @notice The given tokens already have a {ButtonswapPair} instance\\n     */\\n    error PairExists();\\n\\n    /**\\n     * @notice User does not have permission for the attempted operation\\n     */\\n    error Forbidden();\\n\\n    /**\\n     * @notice There was an attempt to update a parameter to an invalid value\\n     */\\n    error InvalidParameter();\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapFactory/IButtonswapFactoryEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\ninterface IButtonswapFactoryEvents {\\n    /**\\n     * @notice Emitted when a new Pair is created.\\n     * @param token0 The first sorted token\\n     * @param token1 The second sorted token\\n     * @param pair The address of the new {ButtonswapPair} contract\\n     * @param count The new total number of Pairs created\\n     */\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256 count);\\n\\n    /**\\n     * @notice Emitted when the default parameters for a new pair have been updated.\\n     * @param paramSetter The address that changed the parameters\\n     * @param newDefaultMovingAverageWindow The new movingAverageWindow default value\\n     * @param newDefaultMaxVolatilityBps The new maxVolatilityBps default value\\n     * @param newDefaultMinTimelockDuration The new minTimelockDuration default value\\n     * @param newDefaultMaxTimelockDuration The new maxTimelockDuration default value\\n     * @param newDefaultMaxSwappableReservoirLimitBps The new maxSwappableReservoirLimitBps default value\\n     * @param newDefaultSwappableReservoirGrowthWindow The new swappableReservoirGrowthWindow default value\\n     */\\n    event DefaultParametersUpdated(\\n        address indexed paramSetter,\\n        uint32 newDefaultMovingAverageWindow,\\n        uint16 newDefaultMaxVolatilityBps,\\n        uint32 newDefaultMinTimelockDuration,\\n        uint32 newDefaultMaxTimelockDuration,\\n        uint16 newDefaultMaxSwappableReservoirLimitBps,\\n        uint32 newDefaultSwappableReservoirGrowthWindow\\n    );\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapPair/IButtonswapPairErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IButtonswapERC20Errors} from \\\"../IButtonswapERC20/IButtonswapERC20Errors.sol\\\";\\n\\ninterface IButtonswapPairErrors is IButtonswapERC20Errors {\\n    /**\\n     * @notice Re-entrancy guard prevented method call\\n     */\\n    error Locked();\\n\\n    /**\\n     * @notice User does not have permission for the attempted operation\\n     */\\n    error Forbidden();\\n\\n    /**\\n     * @notice Integer maximums exceeded\\n     */\\n    error Overflow();\\n\\n    /**\\n     * @notice Initial deposit not yet made\\n     */\\n    error Uninitialized();\\n\\n    /**\\n     * @notice There was not enough liquidity in the reservoir\\n     */\\n    error InsufficientReservoir();\\n\\n    /**\\n     * @notice Not enough liquidity was created during mint\\n     */\\n    error InsufficientLiquidityMinted();\\n\\n    /**\\n     * @notice Not enough funds added to mint new liquidity\\n     */\\n    error InsufficientLiquidityAdded();\\n\\n    /**\\n     * @notice More liquidity must be burned to be redeemed for non-zero amounts\\n     */\\n    error InsufficientLiquidityBurned();\\n\\n    /**\\n     * @notice Swap was attempted with zero input\\n     */\\n    error InsufficientInputAmount();\\n\\n    /**\\n     * @notice Swap was attempted with zero output\\n     */\\n    error InsufficientOutputAmount();\\n\\n    /**\\n     * @notice Pool doesn't have the liquidity to service the swap\\n     */\\n    error InsufficientLiquidity();\\n\\n    /**\\n     * @notice The specified \\\"to\\\" address is invalid\\n     */\\n    error InvalidRecipient();\\n\\n    /**\\n     * @notice The product of pool balances must not change during a swap (save for accounting for fees)\\n     */\\n    error KInvariant();\\n\\n    /**\\n     * @notice The new price ratio after a swap is invalid (one or more of the price terms are zero)\\n     */\\n    error InvalidFinalPrice();\\n\\n    /**\\n     * @notice Single sided operations are not executable at this point in time\\n     */\\n    error SingleSidedTimelock();\\n\\n    /**\\n     * @notice The attempted operation would have swapped reservoir tokens above the current limit\\n     */\\n    error SwappableReservoirExceeded();\\n\\n    /**\\n     * @notice All operations on the pair other than dual-sided burning are currently paused\\n     */\\n    error Paused();\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapPair/IButtonswapPairEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IButtonswapERC20Events} from \\\"../IButtonswapERC20/IButtonswapERC20Events.sol\\\";\\n\\ninterface IButtonswapPairEvents is IButtonswapERC20Events {\\n    /**\\n     * @notice Emitted when a {IButtonswapPair-mint} is performed.\\n     * Some `token0` and `token1` are deposited in exchange for liquidity tokens representing a claim on them.\\n     * @param from The account that supplied the tokens for the mint\\n     * @param amount0 The amount of `token0` that was deposited\\n     * @param amount1 The amount of `token1` that was deposited\\n     * @param amountOut The amount of liquidity tokens that were minted\\n     * @param to The account that received the tokens from the mint\\n     */\\n    event Mint(address indexed from, uint256 amount0, uint256 amount1, uint256 amountOut, address indexed to);\\n\\n    /**\\n     * @notice Emitted when a {IButtonswapPair-burn} is performed.\\n     * Liquidity tokens are redeemed for underlying `token0` and `token1`.\\n     * @param from The account that supplied the tokens for the burn\\n     * @param amountIn The amount of liquidity tokens that were burned\\n     * @param amount0 The amount of `token0` that was received\\n     * @param amount1 The amount of `token1` that was received\\n     * @param to The account that received the tokens from the burn\\n     */\\n    event Burn(address indexed from, uint256 amountIn, uint256 amount0, uint256 amount1, address indexed to);\\n\\n    /**\\n     * @notice Emitted when a {IButtonswapPair-swap} is performed.\\n     * @param from The account that supplied the tokens for the swap\\n     * @param amount0In The amount of `token0` that went into the swap\\n     * @param amount1In The amount of `token1` that went into the swap\\n     * @param amount0Out The amount of `token0` that came out of the swap\\n     * @param amount1Out The amount of `token1` that came out of the swap\\n     * @param to The account that received the tokens from the swap\\n     */\\n    event Swap(\\n        address indexed from,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n\\n    /**\\n     * @notice Emitted when the movingAverageWindow parameter for the pair has been updated.\\n     * @param newMovingAverageWindow The new movingAverageWindow value\\n     */\\n    event MovingAverageWindowUpdated(uint32 newMovingAverageWindow);\\n\\n    /**\\n     * @notice Emitted when the maxVolatilityBps parameter for the pair has been updated.\\n     * @param newMaxVolatilityBps The new maxVolatilityBps value\\n     */\\n    event MaxVolatilityBpsUpdated(uint16 newMaxVolatilityBps);\\n\\n    /**\\n     * @notice Emitted when the minTimelockDuration parameter for the pair has been updated.\\n     * @param newMinTimelockDuration The new minTimelockDuration value\\n     */\\n    event MinTimelockDurationUpdated(uint32 newMinTimelockDuration);\\n\\n    /**\\n     * @notice Emitted when the maxTimelockDuration parameter for the pair has been updated.\\n     * @param newMaxTimelockDuration The new maxTimelockDuration value\\n     */\\n    event MaxTimelockDurationUpdated(uint32 newMaxTimelockDuration);\\n\\n    /**\\n     * @notice Emitted when the maxSwappableReservoirLimitBps parameter for the pair has been updated.\\n     * @param newMaxSwappableReservoirLimitBps The new maxSwappableReservoirLimitBps value\\n     */\\n    event MaxSwappableReservoirLimitBpsUpdated(uint16 newMaxSwappableReservoirLimitBps);\\n\\n    /**\\n     * @notice Emitted when the swappableReservoirGrowthWindow parameter for the pair has been updated.\\n     * @param newSwappableReservoirGrowthWindow The new swappableReservoirGrowthWindow value\\n     */\\n    event SwappableReservoirGrowthWindowUpdated(uint32 newSwappableReservoirGrowthWindow);\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapERC20/IButtonswapERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IButtonswapERC20Errors} from \\\"./IButtonswapERC20Errors.sol\\\";\\nimport {IButtonswapERC20Events} from \\\"./IButtonswapERC20Events.sol\\\";\\n\\ninterface IButtonswapERC20 is IButtonswapERC20Errors, IButtonswapERC20Events {\\n    /**\\n     * @notice Returns the name of the token.\\n     * @return _name The token name\\n     */\\n    function name() external view returns (string memory _name);\\n\\n    /**\\n     * @notice Returns the symbol of the token, usually a shorter version of the name.\\n     * @return _symbol The token symbol\\n     */\\n    function symbol() external view returns (string memory _symbol);\\n\\n    /**\\n     * @notice Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     * @dev This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract.\\n     * @return decimals The number of decimals\\n     */\\n    function decimals() external pure returns (uint8 decimals);\\n\\n    /**\\n     * @notice Returns the amount of tokens in existence.\\n     * @return totalSupply The amount of tokens in existence\\n     */\\n    function totalSupply() external view returns (uint256 totalSupply);\\n\\n    /**\\n     * @notice Returns the amount of tokens owned by `account`.\\n     * @param owner The account the balance is being checked for\\n     * @return balance The amount of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}.\\n     * This is zero by default.\\n     * This value changes when {approve} or {transferFrom} are called.\\n     * @param owner The account that owns the tokens\\n     * @param spender The account that can spend the tokens\\n     * @return allowance The amount of tokens owned by `owner` that the `spender` can transfer\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256 allowance);\\n\\n    /**\\n     * @notice Sets `value` as the allowance of `spender` over the caller's tokens.\\n     * @dev IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {IButtonswapERC20Events-Approval} event.\\n     * @param spender The account that is granted permission to spend the tokens\\n     * @param value The amount of tokens that can be spent\\n     * @return success Whether the operation succeeded\\n     */\\n    function approve(address spender, uint256 value) external returns (bool success);\\n\\n    /**\\n     * @notice Moves `value` tokens from the caller's account to `to`.\\n     * @dev Emits a {IButtonswapERC20Events-Transfer} event.\\n     * @param to The account that is receiving the tokens\\n     * @param value The amount of tokens being sent\\n     * @return success Whether the operation succeeded\\n     */\\n    function transfer(address to, uint256 value) external returns (bool success);\\n\\n    /**\\n     * @notice Moves `value` tokens from `from` to `to` using the allowance mechanism.\\n     * `value` is then deducted from the caller's allowance.\\n     * @dev Emits a {IButtonswapERC20Events-Transfer} event.\\n     * @param from The account that is sending the tokens\\n     * @param to The account that is receiving the tokens\\n     * @param value The amount of tokens being sent\\n     * @return success Whether the operation succeeded\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @notice Returns the domain separator used in the encoding of the signature for {permit}, as defined by [EIP712](https://eips.ethereum.org/EIPS/eip-712).\\n     * @return DOMAIN_SEPARATOR The `DOMAIN_SEPARATOR` value\\n     */\\n    function DOMAIN_SEPARATOR() external view returns (bytes32 DOMAIN_SEPARATOR);\\n\\n    /**\\n     * @notice Returns the typehash used in the encoding of the signature for {permit}, as defined by [EIP712](https://eips.ethereum.org/EIPS/eip-712).\\n     * @return PERMIT_TYPEHASH The `PERMIT_TYPEHASH` value\\n     */\\n    function PERMIT_TYPEHASH() external pure returns (bytes32 PERMIT_TYPEHASH);\\n\\n    /**\\n     * @notice Returns the current nonce for `owner`.\\n     * This value must be included whenever a signature is generated for {permit}.\\n     * @dev Every successful call to {permit} increases `owner`'s nonce by one.\\n     * This prevents a signature from being used multiple times.\\n     * @param owner The account to get the nonce for\\n     * @return nonce The current nonce for the given `owner`\\n     */\\n    function nonces(address owner) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Sets `value` as the allowance of `spender` over `owner`'s tokens, given `owner`'s signed approval.\\n     * @dev IMPORTANT: The same issues {approve} has related to transaction ordering also apply here.\\n     *\\n     * Emits an {IButtonswapERC20Events-Approval} event.\\n     *\\n     * Requirements:\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments.\\n     * - the signature must use `owner`'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the [relevant EIP section](https://eips.ethereum.org/EIPS/eip-2612#specification).\\n     * @param owner The account that owns the tokens\\n     * @param spender The account that can spend the tokens\\n     * @param value The amount of `owner`'s tokens that `spender` can transfer\\n     * @param deadline The future time after which the permit is no longer valid\\n     * @param v Part of the signature\\n     * @param r Part of the signature\\n     * @param s Part of the signature\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external;\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapERC20/IButtonswapERC20Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\ninterface IButtonswapERC20Errors {\\n    /**\\n     * @notice Permit deadline was exceeded\\n     */\\n    error PermitExpired();\\n\\n    /**\\n     * @notice Permit signature invalid\\n     */\\n    error PermitInvalidSignature();\\n}\\n\"\r\n    },\r\n    \"lib/buttonswap-core/src/interfaces/IButtonswapERC20/IButtonswapERC20Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\ninterface IButtonswapERC20Events {\\n    /**\\n     * @notice Emitted when the allowance of a `spender` for an `owner` is set by a call to {IButtonswapERC20-approve}.\\n     * `value` is the new allowance.\\n     * @param owner The account that has granted approval\\n     * @param spender The account that has been given approval\\n     * @param value The amount the spender can transfer\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @notice Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\\n     * @param from The account that sent the tokens\\n     * @param to The account that received the tokens\\n     * @param value The amount of tokens transferred\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=null/\",\r\n      \"openzeppelin-contracts/=null/\",\r\n      \"@openzeppelin-contracts/=null/\",\r\n      \"openzeppelin/=null/\",\r\n      \"mock-contracts/=null/\",\r\n      \"buttonswap-core/=null/\",\r\n      \"buttonswap-periphery_@openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"buttonswap-periphery_forge-std/=lib/forge-std/src/\",\r\n      \"buttonswap-periphery_mock-contracts/=lib/mock-contracts/src/\",\r\n      \"buttonswap-periphery_buttonswap-core/=lib/buttonswap-core/src/\",\r\n      \"buttonswap-core_@openzeppelin-contracts/=lib/buttonswap-core/lib/openzeppelin-contracts/contracts/\",\r\n      \"buttonswap-core_forge-std/=lib/buttonswap-core/lib/forge-std/src/\",\r\n      \"buttonswap-core_mock-contracts/=lib/buttonswap-core/lib/mock-contracts/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/buttonswap-core/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"mock-contracts_@openzeppelin-contracts/=lib/mock-contracts/lib/openzeppelin-contracts/contracts/\",\r\n      \"mock-contracts_forge-std/=lib/mock-contracts/lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_launcher\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_originalIsCreationRestrictedSetter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"batchCreate5\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"enqueuePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IButtonswapFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launcher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originalIsCreationRestrictedSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairStack\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PairLauncher", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d7e86bd77784217324b4e94aedc68e5c8227ec2b0000000000000000000000000941c258ca8a6afbf68ce585216c7cae7a85710e000000000000000000000000b8de4ab6c65e274630f5279f74eb69b66327ce50", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}