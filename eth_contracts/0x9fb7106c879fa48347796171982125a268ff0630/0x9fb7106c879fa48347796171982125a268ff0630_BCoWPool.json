{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/BCoWPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\n/*\\n\\nCoded for Balancer and CoW Swap with \u2665 by\\n\\n\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\\n\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n\u2591\u255a\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\\n\u2591\u2591\u2588\u2588\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2551\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\\n\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\\n\\nhttps://defi.sucks\\n\\n*/\\n\\nimport {BCoWConst} from './BCoWConst.sol';\\nimport {BPool} from './BPool.sol';\\nimport {GPv2Order} from '@cowprotocol/libraries/GPv2Order.sol';\\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\nimport {IBCoWFactory} from 'interfaces/IBCoWFactory.sol';\\nimport {IBCoWPool} from 'interfaces/IBCoWPool.sol';\\nimport {ISettlement} from 'interfaces/ISettlement.sol';\\n\\n/**\\n * @title BCoWPool\\n * @notice Pool contract that holds tokens, allows to swap, add and remove liquidity.\\n * @dev Inherits BPool contract functionalities, and can trade on CoW Swap Protocol.\\n */\\ncontract BCoWPool is IERC1271, IBCoWPool, BPool, BCoWConst {\\n  using GPv2Order for GPv2Order.Data;\\n  using SafeERC20 for IERC20;\\n\\n  /// @inheritdoc IBCoWPool\\n  address public immutable VAULT_RELAYER;\\n\\n  /// @inheritdoc IBCoWPool\\n  bytes32 public immutable SOLUTION_SETTLER_DOMAIN_SEPARATOR;\\n\\n  /// @inheritdoc IBCoWPool\\n  ISettlement public immutable SOLUTION_SETTLER;\\n\\n  /// @inheritdoc IBCoWPool\\n  bytes32 public immutable APP_DATA;\\n\\n  constructor(\\n    address cowSolutionSettler,\\n    bytes32 appData,\\n    // solhint-disable-next-line no-unused-vars\\n    string memory name,\\n    // solhint-disable-next-line no-unused-vars\\n    string memory symbol\\n  ) BPool(name, symbol) {\\n    SOLUTION_SETTLER = ISettlement(cowSolutionSettler);\\n    SOLUTION_SETTLER_DOMAIN_SEPARATOR = ISettlement(cowSolutionSettler).domainSeparator();\\n    VAULT_RELAYER = ISettlement(cowSolutionSettler).vaultRelayer();\\n    APP_DATA = appData;\\n  }\\n\\n  /// @inheritdoc IBCoWPool\\n  function commit(bytes32 orderHash) external _viewlock_ {\\n    if (msg.sender != address(SOLUTION_SETTLER)) {\\n      revert CommitOutsideOfSettlement();\\n    }\\n    _setLock(orderHash);\\n  }\\n\\n  /**\\n   * @inheritdoc IERC1271\\n   * @dev this function reverts if the order hash does not match the current commitment\\n   */\\n  function isValidSignature(bytes32 orderHash, bytes memory signature) external view returns (bytes4 magicValue) {\\n    (GPv2Order.Data memory order) = abi.decode(signature, (GPv2Order.Data));\\n\\n    if (order.appData != APP_DATA) {\\n      revert AppDataDoesNotMatch();\\n    }\\n\\n    bytes32 orderHash_ = order.hash(SOLUTION_SETTLER_DOMAIN_SEPARATOR);\\n    if (orderHash_ != orderHash) {\\n      revert OrderDoesNotMatchMessageHash();\\n    }\\n\\n    if (orderHash_ != _getLock()) {\\n      revert OrderDoesNotMatchCommitmentHash();\\n    }\\n\\n    verify(order);\\n\\n    // A signature is valid according to EIP-1271 if this function returns\\n    // its selector as the so-called \\\"magic value\\\".\\n    magicValue = this.isValidSignature.selector;\\n  }\\n\\n  /// @inheritdoc IBCoWPool\\n  function verify(GPv2Order.Data memory order) public view virtual {\\n    Record memory inRecord = _records[address(order.buyToken)];\\n    Record memory outRecord = _records[address(order.sellToken)];\\n\\n    if (!inRecord.bound || !outRecord.bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    if (order.receiver != GPv2Order.RECEIVER_SAME_AS_OWNER) {\\n      revert BCoWPool_ReceiverIsNotBCoWPool();\\n    }\\n    if (order.validTo > block.timestamp + MAX_ORDER_DURATION) {\\n      revert BCoWPool_OrderValidityTooLong();\\n    }\\n    if (order.feeAmount != 0) {\\n      revert BCoWPool_FeeMustBeZero();\\n    }\\n    if (order.kind != GPv2Order.KIND_SELL) {\\n      revert BCoWPool_InvalidOperation();\\n    }\\n    if (order.buyTokenBalance != GPv2Order.BALANCE_ERC20 || order.sellTokenBalance != GPv2Order.BALANCE_ERC20) {\\n      revert BCoWPool_InvalidBalanceMarker();\\n    }\\n\\n    uint256 buyTokenBalance = order.buyToken.balanceOf(address(this));\\n    if (order.buyAmount > bmul(buyTokenBalance, MAX_IN_RATIO)) {\\n      revert BPool_TokenAmountInAboveMaxRatio();\\n    }\\n\\n    uint256 tokenAmountOut = calcOutGivenIn({\\n      tokenBalanceIn: buyTokenBalance,\\n      tokenWeightIn: inRecord.denorm,\\n      tokenBalanceOut: order.sellToken.balanceOf(address(this)),\\n      tokenWeightOut: outRecord.denorm,\\n      tokenAmountIn: order.buyAmount,\\n      swapFee: 0\\n    });\\n\\n    if (tokenAmountOut < order.sellAmount) {\\n      revert BPool_TokenAmountOutBelowMinOut();\\n    }\\n  }\\n\\n  /**\\n   * @inheritdoc BPool\\n   * @dev Grants infinite approval to the vault relayer for all tokens in the\\n   * pool after the finalization of the setup. Also emits COWAMMPoolCreated() event.\\n   */\\n  function _afterFinalize() internal override {\\n    uint256 tokensLength = _tokens.length;\\n    for (uint256 i; i < tokensLength; i++) {\\n      IERC20(_tokens[i]).forceApprove(VAULT_RELAYER, type(uint256).max);\\n    }\\n\\n    // Make the factory emit the event, to be easily indexed by off-chain agents\\n    // If this pool was not deployed using a bCoWFactory, this will revert and catch\\n    // And the event will be emitted by this contract instead\\n    // solhint-disable-next-line no-empty-blocks\\n    try IBCoWFactory(FACTORY).logBCoWPool() {}\\n    catch {\\n      emit IBCoWFactory.COWAMMPoolCreated(address(this));\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/BCoWConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\n/**\\n * @title BCoWConst\\n * @notice Constants used in the scope of the BCoWPool contract.\\n */\\ncontract BCoWConst {\\n  /**\\n   * @notice The largest possible duration of any AMM order, starting from the\\n   * current block timestamp.\\n   * @return _maxOrderDuration The maximum order duration.\\n   */\\n  uint32 public constant MAX_ORDER_DURATION = 5 minutes;\\n}\\n\"\r\n    },\r\n    \"src/contracts/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {BMath} from './BMath.sol';\\nimport {BToken} from './BToken.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport {IBPool} from 'interfaces/IBPool.sol';\\n\\n/**\\n * @title BPool\\n * @notice Pool contract that holds tokens, allows to swap, add and remove liquidity.\\n */\\ncontract BPool is BToken, BMath, IBPool {\\n  using SafeERC20 for IERC20;\\n  /// @dev BFactory address to push token exitFee to\\n\\n  /// @inheritdoc IBPool\\n  address public immutable FACTORY;\\n  /// @dev Has CONTROL role\\n  address internal _controller;\\n  /// @dev Fee for swapping\\n  uint256 internal _swapFee;\\n  /// @dev Status of the pool. True if finalized, False otherwise\\n  bool internal _finalized;\\n  /// @dev Array of bound tokens\\n  address[] internal _tokens;\\n  /// @dev Metadata for each bound token\\n  mapping(address => Record) internal _records;\\n  /// @dev Sum of all token weights\\n  uint256 internal _totalWeight;\\n\\n  /// @dev Logs the call data\\n  modifier _logs_() {\\n    emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n    _;\\n  }\\n\\n  /// @dev Prevents reentrancy in non-view functions\\n  modifier _lock_() {\\n    if (_getLock() != _MUTEX_FREE) {\\n      revert BPool_Reentrancy();\\n    }\\n    _setLock(_MUTEX_TAKEN);\\n    _;\\n    _setLock(_MUTEX_FREE);\\n  }\\n\\n  /// @dev Throws an error when the reentrancy mutex is taken. Doesn't modify it.\\n  modifier _viewlock_() {\\n    if (_getLock() != _MUTEX_FREE) {\\n      revert BPool_Reentrancy();\\n    }\\n    _;\\n  }\\n\\n  /// @dev Throws an error if pool is not finalized\\n  modifier _finalized_() {\\n    if (!_finalized) {\\n      revert BPool_PoolNotFinalized();\\n    }\\n    _;\\n  }\\n\\n  /// @dev Throws an error if pool is finalized\\n  modifier _notFinalized_() {\\n    if (_finalized) {\\n      revert BPool_PoolIsFinalized();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws an error if caller is not controller\\n   */\\n  modifier _controller_() {\\n    if (msg.sender != _controller) {\\n      revert BPool_CallerIsNotController();\\n    }\\n    _;\\n  }\\n\\n  // solhint-disable-next-line no-unused-vars\\n  constructor(string memory name, string memory symbol) BToken(name, symbol) {\\n    _controller = msg.sender;\\n    FACTORY = msg.sender;\\n    _swapFee = MIN_FEE;\\n    _finalized = false;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function setSwapFee(uint256 swapFee) external _logs_ _lock_ _controller_ _notFinalized_ {\\n    if (swapFee < MIN_FEE) {\\n      revert BPool_FeeBelowMinimum();\\n    }\\n    if (swapFee > MAX_FEE) {\\n      revert BPool_FeeAboveMaximum();\\n    }\\n    _swapFee = swapFee;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function setController(address newController) external _logs_ _lock_ _controller_ {\\n    if (newController == address(0)) {\\n      revert BPool_AddressZero();\\n    }\\n\\n    _controller = newController;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function finalize() external _logs_ _lock_ _controller_ _notFinalized_ {\\n    if (_tokens.length < MIN_BOUND_TOKENS) {\\n      revert BPool_TokensBelowMinimum();\\n    }\\n\\n    _finalized = true;\\n\\n    _mintPoolShare(INIT_POOL_SUPPLY);\\n    _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    _afterFinalize();\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function bind(address token, uint256 balance, uint256 denorm) external _logs_ _lock_ _controller_ _notFinalized_ {\\n    if (_records[token].bound) {\\n      revert BPool_TokenAlreadyBound();\\n    }\\n    if (_tokens.length >= MAX_BOUND_TOKENS) {\\n      revert BPool_TokensAboveMaximum();\\n    }\\n    if (denorm < MIN_WEIGHT) {\\n      revert BPool_WeightBelowMinimum();\\n    }\\n    if (denorm > MAX_WEIGHT) {\\n      revert BPool_WeightAboveMaximum();\\n    }\\n    if (balance < MIN_BALANCE) {\\n      revert BPool_BalanceBelowMinimum();\\n    }\\n\\n    _totalWeight = badd(_totalWeight, denorm);\\n    if (_totalWeight > MAX_TOTAL_WEIGHT) {\\n      revert BPool_TotalWeightAboveMaximum();\\n    }\\n\\n    _records[token] = Record({bound: true, index: _tokens.length, denorm: denorm});\\n    _tokens.push(token);\\n\\n    _pullUnderlying(token, msg.sender, balance);\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function unbind(address token) external _logs_ _lock_ _controller_ _notFinalized_ {\\n    if (!_records[token].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n\\n    _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n    // Swap the token-to-unbind with the last token,\\n    // then delete the last token\\n    uint256 index = _records[token].index;\\n    uint256 last = _tokens.length - 1;\\n    _tokens[index] = _tokens[last];\\n    _records[_tokens[index]].index = index;\\n    _tokens.pop();\\n    _records[token] = Record({bound: false, index: 0, denorm: 0});\\n\\n    _pushUnderlying(token, msg.sender, IERC20(token).balanceOf(address(this)));\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ _finalized_ {\\n    uint256 poolTotal = totalSupply();\\n    uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n    if (ratio == 0) {\\n      revert BPool_InvalidPoolRatio();\\n    }\\n\\n    uint256 tokensLength = _tokens.length;\\n    for (uint256 i = 0; i < tokensLength; i++) {\\n      address t = _tokens[i];\\n      uint256 bal = IERC20(t).balanceOf(address(this));\\n      uint256 tokenAmountIn = bmul(ratio, bal);\\n      if (tokenAmountIn == 0) {\\n        revert BPool_InvalidTokenAmountIn();\\n      }\\n      if (tokenAmountIn > maxAmountsIn[i]) {\\n        revert BPool_TokenAmountInAboveMaxAmountIn();\\n      }\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      _pullUnderlying(t, msg.sender, tokenAmountIn);\\n    }\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ _finalized_ {\\n    uint256 poolTotal = totalSupply();\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n    uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n    if (ratio == 0) {\\n      revert BPool_InvalidPoolRatio();\\n    }\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _pushPoolShare(FACTORY, exitFee);\\n    _burnPoolShare(pAiAfterExitFee);\\n\\n    uint256 tokensLength = _tokens.length;\\n    for (uint256 i = 0; i < tokensLength; i++) {\\n      address t = _tokens[i];\\n      uint256 bal = IERC20(t).balanceOf(address(this));\\n      uint256 tokenAmountOut = bmul(ratio, bal);\\n      if (tokenAmountOut == 0) {\\n        revert BPool_InvalidTokenAmountOut();\\n      }\\n      if (tokenAmountOut < minAmountsOut[i]) {\\n        revert BPool_TokenAmountOutBelowMinAmountOut();\\n      }\\n      emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n      _pushUnderlying(t, msg.sender, tokenAmountOut);\\n    }\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external _logs_ _lock_ _finalized_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\\n    if (!_records[tokenIn].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    if (!_records[tokenOut].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n\\n    Record storage inRecord = _records[address(tokenIn)];\\n    Record storage outRecord = _records[address(tokenOut)];\\n\\n    uint256 tokenInBalance = IERC20(tokenIn).balanceOf(address(this));\\n    uint256 tokenOutBalance = IERC20(tokenOut).balanceOf(address(this));\\n\\n    if (tokenAmountIn > bmul(tokenInBalance, MAX_IN_RATIO)) {\\n      revert BPool_TokenAmountInAboveMaxRatio();\\n    }\\n\\n    uint256 spotPriceBefore =\\n      calcSpotPrice(tokenInBalance, inRecord.denorm, tokenOutBalance, outRecord.denorm, _swapFee);\\n    if (spotPriceBefore > maxPrice) {\\n      revert BPool_SpotPriceAboveMaxPrice();\\n    }\\n\\n    tokenAmountOut =\\n      calcOutGivenIn(tokenInBalance, inRecord.denorm, tokenOutBalance, outRecord.denorm, tokenAmountIn, _swapFee);\\n    if (tokenAmountOut < minAmountOut) {\\n      revert BPool_TokenAmountOutBelowMinOut();\\n    }\\n\\n    tokenInBalance = badd(tokenInBalance, tokenAmountIn);\\n    tokenOutBalance = bsub(tokenOutBalance, tokenAmountOut);\\n\\n    spotPriceAfter = calcSpotPrice(tokenInBalance, inRecord.denorm, tokenOutBalance, outRecord.denorm, _swapFee);\\n    if (spotPriceAfter < spotPriceBefore) {\\n      revert BPool_SpotPriceAfterBelowSpotPriceBefore();\\n    }\\n    if (spotPriceAfter > maxPrice) {\\n      revert BPool_SpotPriceAboveMaxPrice();\\n    }\\n    if (spotPriceBefore > bdiv(tokenAmountIn, tokenAmountOut)) {\\n      revert BPool_SpotPriceBeforeAboveTokenRatio();\\n    }\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external _logs_ _lock_ _finalized_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\\n    if (!_records[tokenIn].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    if (!_records[tokenOut].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n\\n    Record storage inRecord = _records[address(tokenIn)];\\n    Record storage outRecord = _records[address(tokenOut)];\\n\\n    uint256 tokenInBalance = IERC20(tokenIn).balanceOf(address(this));\\n    uint256 tokenOutBalance = IERC20(tokenOut).balanceOf(address(this));\\n\\n    if (tokenAmountOut > bmul(tokenOutBalance, MAX_OUT_RATIO)) {\\n      revert BPool_TokenAmountOutAboveMaxOut();\\n    }\\n\\n    uint256 spotPriceBefore =\\n      calcSpotPrice(tokenInBalance, inRecord.denorm, tokenOutBalance, outRecord.denorm, _swapFee);\\n    if (spotPriceBefore > maxPrice) {\\n      revert BPool_SpotPriceAboveMaxPrice();\\n    }\\n\\n    tokenAmountIn =\\n      calcInGivenOut(tokenInBalance, inRecord.denorm, tokenOutBalance, outRecord.denorm, tokenAmountOut, _swapFee);\\n    if (tokenAmountIn > maxAmountIn) {\\n      revert BPool_TokenAmountInAboveMaxAmountIn();\\n    }\\n\\n    tokenInBalance = badd(tokenInBalance, tokenAmountIn);\\n    tokenOutBalance = bsub(tokenOutBalance, tokenAmountOut);\\n\\n    spotPriceAfter = calcSpotPrice(tokenInBalance, inRecord.denorm, tokenOutBalance, outRecord.denorm, _swapFee);\\n    if (spotPriceAfter < spotPriceBefore) {\\n      revert BPool_SpotPriceAfterBelowSpotPriceBefore();\\n    }\\n    if (spotPriceAfter > maxPrice) {\\n      revert BPool_SpotPriceAboveMaxPrice();\\n    }\\n    if (spotPriceBefore > bdiv(tokenAmountIn, tokenAmountOut)) {\\n      revert BPool_SpotPriceBeforeAboveTokenRatio();\\n    }\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256) {\\n    if (!_records[tokenIn].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    if (!_records[tokenOut].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    Record storage inRecord = _records[tokenIn];\\n    Record storage outRecord = _records[tokenOut];\\n\\n    return calcSpotPrice(\\n      IERC20(tokenIn).balanceOf(address(this)),\\n      inRecord.denorm,\\n      IERC20(tokenOut).balanceOf(address(this)),\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256) {\\n    if (!_records[tokenIn].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    if (!_records[tokenOut].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    Record storage inRecord = _records[tokenIn];\\n    Record storage outRecord = _records[tokenOut];\\n\\n    return calcSpotPrice(\\n      IERC20(tokenIn).balanceOf(address(this)),\\n      inRecord.denorm,\\n      IERC20(tokenOut).balanceOf(address(this)),\\n      outRecord.denorm,\\n      0\\n    );\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function isFinalized() external view returns (bool) {\\n    return _finalized;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function isBound(address token) external view returns (bool) {\\n    return _records[token].bound;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getNumTokens() external view returns (uint256) {\\n    return _tokens.length;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getCurrentTokens() external view _viewlock_ returns (address[] memory) {\\n    return _tokens;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getFinalTokens() external view _viewlock_ _finalized_ returns (address[] memory) {\\n    return _tokens;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\\n    if (!_records[token].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    return _records[token].denorm;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\\n    return _totalWeight;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\\n    if (!_records[token].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    uint256 denorm = _records[token].denorm;\\n    return bdiv(denorm, _totalWeight);\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getBalance(address token) external view _viewlock_ returns (uint256) {\\n    if (!_records[token].bound) {\\n      revert BPool_TokenNotBound();\\n    }\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getSwapFee() external view _viewlock_ returns (uint256) {\\n    return _swapFee;\\n  }\\n\\n  /// @inheritdoc IBPool\\n  function getController() external view _viewlock_ returns (address) {\\n    return _controller;\\n  }\\n\\n  /**\\n   * @notice Sets the value of the transient storage slot used for reentrancy locks\\n   * @param value The value of the transient storage slot used for reentrancy locks.\\n   * @dev Should be set to _MUTEX_FREE after a call, any other value will\\n   * be interpreted as locked\\n   */\\n  function _setLock(bytes32 value) internal virtual {\\n    assembly (\\\"memory-safe\\\") {\\n      tstore(_MUTEX_TRANSIENT_STORAGE_SLOT, value)\\n    }\\n  }\\n\\n  /**\\n   * @dev Pulls tokens from the sender. Tokens needs to be approved first. Calls are not locked.\\n   * @param token The address of the token to pull\\n   * @param from The address to pull the tokens from\\n   * @param amount The amount of tokens to pull\\n   */\\n  function _pullUnderlying(address token, address from, uint256 amount) internal virtual {\\n    IERC20(token).safeTransferFrom(from, address(this), amount);\\n  }\\n\\n  /**\\n   * @dev Pushes tokens to the receiver. Calls are not locked.\\n   * @param token The address of the token to push\\n   * @param to The address to push the tokens to\\n   * @param amount The amount of tokens to push\\n   */\\n  function _pushUnderlying(address token, address to, uint256 amount) internal virtual {\\n    IERC20(token).safeTransfer(to, amount);\\n  }\\n\\n  /**\\n   * @dev Hook for extensions to execute custom logic when a pool is finalized,\\n   * e.g. Setting infinite allowance on BCoWPool\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  function _afterFinalize() internal virtual {}\\n\\n  /**\\n   * @dev Pulls pool tokens from the sender.\\n   * @param from The address to pull the pool tokens from\\n   * @param amount The amount of pool tokens to pull\\n   */\\n  function _pullPoolShare(address from, uint256 amount) internal virtual {\\n    _pull(from, amount);\\n  }\\n\\n  /**\\n   * @dev Pushes pool tokens to the receiver.\\n   * @param to The address to push the pool tokens to\\n   * @param amount The amount of pool tokens to push\\n   */\\n  function _pushPoolShare(address to, uint256 amount) internal virtual {\\n    _push(to, amount);\\n  }\\n\\n  /**\\n   * @dev Mints an amount of pool tokens.\\n   * @param amount The amount of pool tokens to mint\\n   */\\n  function _mintPoolShare(uint256 amount) internal virtual {\\n    _mint(address(this), amount);\\n  }\\n\\n  /**\\n   * @dev Burns an amount of pool tokens.\\n   * @param amount The amount of pool tokens to burn\\n   */\\n  function _burnPoolShare(uint256 amount) internal virtual {\\n    _burn(address(this), amount);\\n  }\\n\\n  /**\\n   * @notice Gets the value of the transient storage slot used for reentrancy locks\\n   * @return value Contents of transient storage slot used for reentrancy locks.\\n   * @dev Should only be compared against _MUTEX_FREE for the purposes of\\n   * allowing calls\\n   */\\n  function _getLock() internal view virtual returns (bytes32 value) {\\n    assembly (\\\"memory-safe\\\") {\\n      value := tload(_MUTEX_TRANSIENT_STORAGE_SLOT)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@cowprotocol/contracts/src/contracts/libraries/GPv2Order.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Order Library\\n/// @author Gnosis Developers\\nlibrary GPv2Order {\\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\\n    /// all order parameters that are signed for submitting to GP.\\n    struct Data {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"address receiver,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"bytes32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable,\\\" +\\n    ///         \\\"string sellTokenBalance,\\\" +\\n    ///         \\\"string buyTokenBalance\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant TYPE_HASH =\\n        hex\\\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\\\";\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant KIND_SELL =\\n        hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant KIND_BUY =\\n        hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\\n    /// computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"erc20\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_ERC20 =\\n        hex\\\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault external\\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\\n    /// order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"external\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_EXTERNAL =\\n        hex\\\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\\n    /// balances for computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"internal\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_INTERNAL =\\n        hex\\\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\\\";\\n\\n    /// @dev Marker address used to indicate that the receiver of the trade\\n    /// proceeds should the owner of the order.\\n    ///\\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\\n    /// to be the most common case.\\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 internal constant UID_LENGTH = 56;\\n\\n    /// @dev Returns the actual receiver for an order. This function checks\\n    /// whether or not the [`receiver`] field uses the marker value to indicate\\n    /// it is the same as the order owner.\\n    ///\\n    /// @return receiver The actual receiver of trade proceeds.\\n    function actualReceiver(\\n        Data memory order,\\n        address owner\\n    ) internal pure returns (address receiver) {\\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\\n            receiver = owner;\\n        } else {\\n            receiver = order.receiver;\\n        }\\n    }\\n\\n    /// @dev Return the EIP-712 signing hash for the specified order.\\n    ///\\n    /// @param order The order to compute the EIP-712 signing hash for.\\n    /// @param domainSeparator The EIP-712 domain separator to use.\\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\\n    function hash(\\n        Data memory order,\\n        bytes32 domainSeparator\\n    ) internal pure returns (bytes32 orderDigest) {\\n        bytes32 structHash;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\\n        // in the EIP proposal, noting that the order struct has 12 fields, and\\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(order, 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, TYPE_HASH)\\n            structHash := keccak256(dataStart, 416)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\\n        // hash using scratch memory past the free memory pointer. The signing\\n        // hash is computed from `\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash`.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\\n            mstore(add(freeMemoryPointer, 34), structHash)\\n            orderDigest := keccak256(freeMemoryPointer, 66)\\n        }\\n    }\\n\\n    /// @dev Packs order UID parameters into the specified memory location. The\\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\\n    /// it allows re-using the memory for packing the order UID.\\n    ///\\n    /// This function reverts if the order UID buffer is not the correct size.\\n    ///\\n    /// @param orderUid The buffer pack the order UID parameters into.\\n    /// @param orderDigest The EIP-712 struct digest derived from the order\\n    /// parameters.\\n    /// @param owner The address of the user who owns this order.\\n    /// @param validTo The epoch time at which the order will stop being valid.\\n    function packOrderUidParams(\\n        bytes memory orderUid,\\n        bytes32 orderDigest,\\n        address owner,\\n        uint32 validTo\\n    ) internal pure {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: uid buffer overflow\\\");\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // Additionally, since Solidity `bytes memory` are length prefixed,\\n        // 32 needs to be added to all the offsets.\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(add(orderUid, 56), validTo)\\n            mstore(add(orderUid, 52), owner)\\n            mstore(add(orderUid, 32), orderDigest)\\n        }\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(\\n        bytes calldata orderUid\\n    )\\n        internal\\n        pure\\n        returns (bytes32 orderDigest, address owner, uint32 validTo)\\n    {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: invalid uid\\\");\\n\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBCoWFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {IBFactory} from 'interfaces/IBFactory.sol';\\n\\ninterface IBCoWFactory is IBFactory {\\n  /**\\n   * @notice Emitted when a bCoWPool created by this factory is finalized\\n   * @param bCoWPool The pool just finalized\\n   */\\n  event COWAMMPoolCreated(address indexed bCoWPool);\\n\\n  /**\\n   * @notice thrown when the caller of `logBCoWPool()` is not a bCoWPool created by this factory\\n   */\\n  error BCoWFactory_NotValidBCoWPool();\\n\\n  /**\\n   * @notice Emits the COWAMMPoolCreated event if the caller is a bCoWPool, to be indexed by off-chain agents\\n   */\\n  function logBCoWPool() external;\\n\\n  /**\\n   * @notice The address of the CoW Protocol settlement contract. It is the\\n   * only address that can set commitments.\\n   * @return solutionSettler The address of the solution settler.\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function SOLUTION_SETTLER() external view returns (address solutionSettler);\\n\\n  /**\\n   * @notice The identifier describing which `GPv2Order.AppData` currently\\n   * apply to this AMM.\\n   * @return appData The 32 bytes identifier of the allowed GPv2Order AppData.\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function APP_DATA() external view returns (bytes32 appData);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBCoWPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {GPv2Order} from '@cowprotocol/libraries/GPv2Order.sol';\\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\\nimport {IBPool} from 'interfaces/IBPool.sol';\\nimport {ISettlement} from 'interfaces/ISettlement.sol';\\n\\ninterface IBCoWPool is IERC1271, IBPool {\\n  /**\\n   * @notice Thrown when a CoW order has a non-zero fee\\n   */\\n  error BCoWPool_FeeMustBeZero();\\n\\n  /**\\n   * @notice Thrown when a CoW order is executed after its deadline\\n   */\\n  error BCoWPool_OrderValidityTooLong();\\n\\n  /**\\n   * @notice Thrown when a CoW order has an unknown type (must be GPv2Order.KIND_SELL)\\n   */\\n  error BCoWPool_InvalidOperation();\\n\\n  /**\\n   * @notice Thrown when a CoW order has an invalid balance marker. BCoWPool\\n   * only supports BALANCE_ERC20, instructing to use the underlying ERC20\\n   * balance directly instead of balancer's internal accounting\\n   */\\n  error BCoWPool_InvalidBalanceMarker();\\n\\n  /**\\n   * @notice The `commit` function can only be called inside a CoW Swap\\n   * settlement. This error is thrown when the function is called from another\\n   * context.\\n   */\\n  error CommitOutsideOfSettlement();\\n\\n  /**\\n   * @notice Error thrown when a solver tries to settle an AMM order on CoW\\n   * Protocol whose hash doesn't match the one that has been committed to.\\n   */\\n  error OrderDoesNotMatchCommitmentHash();\\n\\n  /**\\n   * @notice On signature verification, the hash of the order supplied as part\\n   * of the signature does not match the provided message hash.\\n   * This usually means that the verification function is being provided a\\n   * signature that belongs to a different order.\\n   */\\n  error OrderDoesNotMatchMessageHash();\\n\\n  /**\\n   * @notice Thrown when AppData that was provided during signature verification\\n   * does not match the one stored in this contract.\\n   */\\n  error AppDataDoesNotMatch();\\n\\n  /**\\n   * @notice Thrown when the receiver of the order is not the bCoWPool itself.\\n   */\\n  error BCoWPool_ReceiverIsNotBCoWPool();\\n\\n  /**\\n   * @notice Restricts a specific AMM to being able to trade only the order\\n   * with the specified hash.\\n   * @dev The commitment is used to enforce that exactly one AMM order is\\n   * valid when a CoW Protocol batch is settled.\\n   * @param orderHash the order hash that will be enforced by the order\\n   * verification function.\\n   */\\n  function commit(bytes32 orderHash) external;\\n\\n  /**\\n   * @notice The address that can pull funds from the AMM vault to execute an order\\n   * @return vaultRelayer The address of the vault relayer.\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function VAULT_RELAYER() external view returns (address vaultRelayer);\\n\\n  /**\\n   * @notice The domain separator used for hashing CoW Protocol orders.\\n   * @return solutionSettlerDomainSeparator The domain separator.\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function SOLUTION_SETTLER_DOMAIN_SEPARATOR() external view returns (bytes32 solutionSettlerDomainSeparator);\\n\\n  /**\\n   * @notice The address of the CoW Protocol settlement contract. It is the\\n   * only address that can set commitments.\\n   * @return solutionSettler The address of the solution settler.\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function SOLUTION_SETTLER() external view returns (ISettlement solutionSettler);\\n\\n  /**\\n   * @notice The identifier describing which `GPv2Order.AppData` currently\\n   * apply to this AMM.\\n   * @return appData The 32 bytes identifier of the allowed GPv2Order AppData.\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function APP_DATA() external view returns (bytes32 appData);\\n\\n  /**\\n   * @notice This function checks that the input order is admissible for the\\n   * constant-product curve for the given trading parameters.\\n   * @param order `GPv2Order.Data` of a discrete order to be verified.\\n   */\\n  function verify(GPv2Order.Data memory order) external view;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISettlement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {IERC20} from '@cowprotocol/interfaces/IERC20.sol';\\nimport {GPv2Interaction} from '@cowprotocol/libraries/GPv2Interaction.sol';\\nimport {GPv2Trade} from '@cowprotocol/libraries/GPv2Trade.sol';\\n\\n/**\\n * @title ISettlement\\n * @notice External interface of CoW Protocol's SolutionSettler contract.\\n */\\ninterface ISettlement {\\n  /**\\n   * @notice Settles a batch of trades.\\n   * @param tokens The tokens that are traded in the batch.\\n   * @param clearingPrices The clearing prices of the trades.\\n   * @param trades The trades to settle.\\n   * @param interactions The interactions to execute.\\n   */\\n  function settle(\\n    IERC20[] calldata tokens,\\n    uint256[] calldata clearingPrices,\\n    GPv2Trade.Data[] calldata trades,\\n    GPv2Interaction.Data[][3] calldata interactions\\n  ) external;\\n\\n  /**\\n   * @return domainSeparator The domain separator for IERC1271 signature\\n   * @dev Immutable value, would not change on chain forks\\n   */\\n  function domainSeparator() external view returns (bytes32 domainSeparator);\\n\\n  /**\\n   * @return vaultRelayer The address that'll use the pool liquidity in CoWprotocol swaps\\n   * @dev Address that will transfer and transferFrom the pool. Has an infinite allowance.\\n   */\\n  function vaultRelayer() external view returns (address vaultRelayer);\\n}\\n\"\r\n    },\r\n    \"src/contracts/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {BConst} from './BConst.sol';\\nimport {BNum} from './BNum.sol';\\n\\n/**\\n * @title BMath\\n * @notice Includes functions for calculating the BPool related math.\\n */\\ncontract BMath is BConst, BNum {\\n  /**\\n   * @notice Calculate the spot price of a token in terms of another one\\n   * @dev The price denomination depends on the decimals of the tokens.\\n   * @dev To obtain the price with 18 decimals the next formula should be applied to the result\\n   * @dev spotPrice = spotPrice \u00f7 (10^tokenInDecimals) \u00d7 (10^tokenOutDecimals)\\n   * @param tokenBalanceIn The balance of the input token in the pool\\n   * @param tokenWeightIn The weight of the input token in the pool\\n   * @param tokenBalanceOut The balance of the output token in the pool\\n   * @param tokenWeightOut The weight of the output token in the pool\\n   * @param swapFee The swap fee of the pool\\n   * @return spotPrice The spot price of a token in terms of another one\\n   * @dev Formula:\\n   * sP = spotPrice\\n   * bI = tokenBalanceIn                ( bI / wI )         1\\n   * bO = tokenBalanceOut         sP =  -----------  *  ----------\\n   * wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )\\n   * wO = tokenWeightOut\\n   * sF = swapFee\\n   */\\n  function calcSpotPrice(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 swapFee\\n  ) public pure returns (uint256 spotPrice) {\\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n    uint256 ratio = bdiv(numer, denom);\\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\\n    return (spotPrice = bmul(ratio, scale));\\n  }\\n\\n  /**\\n   * @notice Calculate the amount of token out given the amount of token in for a swap\\n   * @param tokenBalanceIn The balance of the input token in the pool\\n   * @param tokenWeightIn The weight of the input token in the pool\\n   * @param tokenBalanceOut The balance of the output token in the pool\\n   * @param tokenWeightOut The weight of the output token in the pool\\n   * @param tokenAmountIn The amount of the input token\\n   * @param swapFee The swap fee of the pool\\n   * @return tokenAmountOut The amount of token out given the amount of token in for a swap\\n   * @dev Formula:\\n   * aO = tokenAmountOut\\n   * bO = tokenBalanceOut\\n   * bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\\\n   * aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |\\n   * wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /\\n   * wO = tokenWeightOut\\n   * sF = swapFee\\n   */\\n  function calcOutGivenIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) public pure returns (uint256 tokenAmountOut) {\\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n    uint256 adjustedIn = bsub(BONE, swapFee);\\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n    uint256 foo = bpow(y, weightRatio);\\n    uint256 bar = bsub(BONE, foo);\\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\\n    return tokenAmountOut;\\n  }\\n\\n  /**\\n   * @notice Calculate the amount of token in given the amount of token out for a swap\\n   * @param tokenBalanceIn The balance of the input token in the pool\\n   * @param tokenWeightIn The weight of the input token in the pool\\n   * @param tokenBalanceOut The balance of the output token in the pool\\n   * @param tokenWeightOut The weight of the output token in the pool\\n   * @param tokenAmountOut The amount of the output token\\n   * @param swapFee The swap fee of the pool\\n   * @return tokenAmountIn The amount of token in given the amount of token out for a swap\\n   * @dev Formula:\\n   * aI = tokenAmountIn\\n   * bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\\\n   * bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |\\n   * aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /\\n   * wI = tokenWeightIn           --------------------------------------------\\n   * wO = tokenWeightOut                          ( 1 - sF )\\n   * sF = swapFee\\n   */\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) public pure returns (uint256 tokenAmountIn) {\\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\\n    uint256 y = bdiv(tokenBalanceOut, diff);\\n    uint256 foo = bpow(y, weightRatio);\\n    foo = bsub(foo, BONE);\\n    tokenAmountIn = bsub(BONE, swapFee);\\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n    return tokenAmountIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\n/**\\n * @title BToken\\n * @notice Balancer Pool Token base contract, providing ERC20 functionality.\\n */\\ncontract BToken is ERC20 {\\n  constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\\n\\n  /**\\n   * @notice Increase the allowance of the spender.\\n   * @param spender The address which will spend the funds.\\n   * @param amount The amount of tokens to increase the allowance by.\\n   * @return success True if the operation is successful.\\n   */\\n  function increaseApproval(address spender, uint256 amount) external returns (bool success) {\\n    _approve(msg.sender, spender, allowance(msg.sender, spender) + amount);\\n    success = true;\\n  }\\n\\n  /**\\n   * @notice Decrease the allowance of the spender.\\n   * @param spender The address which will spend the funds.\\n   * @param amount The amount of tokens to decrease the allowance by.\\n   * @return success True if the operation is successful.\\n   */\\n  function decreaseApproval(address spender, uint256 amount) external returns (bool success) {\\n    uint256 oldValue = allowance(msg.sender, spender);\\n    if (amount > oldValue) {\\n      _approve(msg.sender, spender, 0);\\n    } else {\\n      _approve(msg.sender, spender, oldValue - amount);\\n    }\\n    success = true;\\n  }\\n\\n  /**\\n   * @notice Transfer tokens from one this contract to another.\\n   * @param to The address which you want to transfer to.\\n   * @param amount The amount of tokens to be transferred.\\n   */\\n  function _push(address to, uint256 amount) internal virtual {\\n    _transfer(address(this), to, amount);\\n  }\\n\\n  /**\\n   * @notice Pull tokens from another address to this contract.\\n   * @param from The address which you want to transfer from.\\n   * @param amount The amount of tokens to be transferred.\\n   */\\n  function _pull(address from, uint256 amount) internal virtual {\\n    _transfer(from, address(this), amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IBPool is IERC20 {\\n  /**\\n   * @dev Struct for token records.\\n   * @param bound If token is bound to pool.\\n   * @param index Internal index of token array.\\n   * @param denorm Denormalized weight of token.\\n   */\\n  struct Record {\\n    bool bound;\\n    uint256 index;\\n    uint256 denorm;\\n  }\\n\\n  /**\\n   * @notice Emitted when a swap is executed\\n   * @param caller The caller of the swap function\\n   * @param tokenIn The address of the token being swapped in\\n   * @param tokenOut The address of the token being swapped out\\n   * @param tokenAmountIn The amount of tokenIn being swapped in\\n   * @param tokenAmountOut The amount of tokenOut being swapped out\\n   */\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /**\\n   * @notice Emitted when a join operation is executed\\n   * @param caller The caller of the function\\n   * @param tokenIn The address of the token being sent to the pool\\n   * @param tokenAmountIn The balance of the token being sent to the pool\\n   */\\n  event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\\n\\n  /**\\n   * @notice Emitted when a token amount is removed from the pool\\n   * @param caller The caller of the function\\n   * @param tokenOut The address of the token being removed from the pool\\n   * @param tokenAmountOut The amount of the token being removed from the pool\\n   */\\n  event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\\n\\n  /**\\n   * @notice Emitted when a call is executed on the pool\\n   * @param sig The signature of the function selector being called\\n   * @param caller The caller of the function\\n   * @param data The complete data of the call\\n   */\\n  event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\\n\\n  /**\\n   * @notice Thrown when setting a variable to address zero\\n   */\\n  error BPool_AddressZero();\\n\\n  /**\\n   * @notice Thrown when a reentrant call is made\\n   */\\n  error BPool_Reentrancy();\\n\\n  /**\\n   * @notice Thrown when the pool is finalized\\n   */\\n  error BPool_PoolIsFinalized();\\n\\n  /**\\n   * @notice Thrown when the caller is not the controller\\n   */\\n  error BPool_CallerIsNotController();\\n\\n  /**\\n   * @notice Thrown when the pool is not finalized\\n   */\\n  error BPool_FeeBelowMinimum();\\n\\n  /**\\n   * @notice Thrown when the fee to set is above the maximum\\n   */\\n  error BPool_FeeAboveMaximum();\\n\\n  /**\\n   * @notice Thrown when the tokens array is below the minimum\\n   */\\n  error BPool_TokensBelowMinimum();\\n\\n  /**\\n   * @notice Thrown when the token is already bound in the pool\\n   */\\n  error BPool_TokenAlreadyBound();\\n\\n  /**\\n   * @notice Thrown when the tokens array is above the maximum\\n   */\\n  error BPool_TokensAboveMaximum();\\n\\n  /**\\n   * @notice Thrown when the weight to set is below the minimum\\n   */\\n  error BPool_WeightBelowMinimum();\\n\\n  /**\\n   * @notice Thrown when the weight to set is above the maximum\\n   */\\n  error BPool_WeightAboveMaximum();\\n\\n  /**\\n   * @notice Thrown when the balance to add is below the minimum\\n   */\\n  error BPool_BalanceBelowMinimum();\\n\\n  /**\\n   * @notice Thrown when the total weight is above the maximum\\n   */\\n  error BPool_TotalWeightAboveMaximum();\\n\\n  /**\\n   * @notice Thrown when the ratio between the pool token amount and the total supply is zero\\n   */\\n  error BPool_InvalidPoolRatio();\\n\\n  /**\\n   * @notice Thrown when the calculated token amount in is zero\\n   */\\n  error BPool_InvalidTokenAmountIn();\\n\\n  /**\\n   * @notice Thrown when the token amount in is above maximum amount in allowed by the caller\\n   */\\n  error BPool_TokenAmountInAboveMaxAmountIn();\\n\\n  /**\\n   * @notice Thrown when the calculated token amount out is zero\\n   */\\n  error BPool_InvalidTokenAmountOut();\\n\\n  /**\\n   * @notice Thrown when the token amount out is below minimum amount out allowed by the caller\\n   */\\n  error BPool_TokenAmountOutBelowMinAmountOut();\\n\\n  /**\\n   * @notice Thrown when the token is not bound in the pool\\n   */\\n  error BPool_TokenNotBound();\\n\\n  /**\\n   * @notice Thrown when the pool is not finalized\\n   */\\n  error BPool_PoolNotFinalized();\\n\\n  /**\\n   * @notice Thrown when the token amount in surpasses the maximum in ratio allowed by the pool\\n   */\\n  error BPool_TokenAmountInAboveMaxRatio();\\n\\n  /**\\n   * @notice Thrown when the spot price before or after the swap is above the max allowed by the caller\\n   */\\n  error BPool_SpotPriceAboveMaxPrice();\\n\\n  /**\\n   * @notice Thrown when the token amount out is below the minimum out allowed by the caller\\n   */\\n  error BPool_TokenAmountOutBelowMinOut();\\n\\n  /**\\n   * @notice Thrown when the spot price after the swap is below the spot price before the swap\\n   */\\n  error BPool_SpotPriceAfterBelowSpotPriceBefore();\\n\\n  /**\\n   * @notice Thrown when the spot price before the swap is above the ratio between the two tokens in the pool\\n   */\\n  error BPool_SpotPriceBeforeAboveTokenRatio();\\n\\n  /**\\n   * @notice Thrown when the token amount out surpasses the maximum out allowed by the pool\\n   */\\n  error BPool_TokenAmountOutAboveMaxOut();\\n\\n  /**\\n   * @notice Thrown when the pool token amount out is below the minimum pool token amount out allowed by the caller\\n   */\\n  error BPool_PoolAmountOutBelowMinPoolAmountOut();\\n\\n  /**\\n   * @notice Thrown when the calculated pool token amount in is zero\\n   */\\n  error BPool_InvalidPoolAmountIn();\\n\\n  /**\\n   * @notice Thrown when the pool token amount in is above the maximum amount in allowed by the caller\\n   */\\n  error BPool_PoolAmountInAboveMaxPoolAmountIn();\\n\\n  /**\\n   * @notice Sets the new swap fee\\n   * @param swapFee The new swap fee\\n   */\\n  function setSwapFee(uint256 swapFee) external;\\n\\n  /**\\n   * @notice Sets the new controller\\n   * @param manager The new controller\\n   */\\n  function setController(address manager) external;\\n\\n  /**\\n   * @notice Finalize the pool, removing the restrictions on the pool\\n   */\\n  function finalize() external;\\n\\n  /**\\n   * @notice Binds a token to the pool\\n   * @param token The address of the token to bind\\n   * @param balance The balance of the token to bind\\n   * @param denorm The denormalized weight of the token to bind\\n   */\\n  function bind(address token, uint256 balance, uint256 denorm) external;\\n\\n  /**\\n   * @notice Unbinds a token from the pool\\n   * @param token The address of the token to unbind\\n   */\\n  function unbind(address token) external;\\n\\n  /**\\n   * @notice Joins a pool, providing each token in the pool with a proportional amount\\n   * @param poolAmountOut The amount of pool tokens to mint\\n   * @param maxAmountsIn The maximum amount of tokens to send to the pool\\n   */\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  /**\\n   * @notice Exits a pool, receiving each token in the pool with a proportional amount\\n   * @param poolAmountIn The amount of pool tokens to burn\\n   * @param minAmountsOut The minimum amount of tokens to receive from the pool\\n   */\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  /**\\n   * @notice Swaps an exact amount of tokens in for an amount of tokens out\\n   * @param tokenIn The address of the token to swap in\\n   * @param tokenAmountIn The amount of token to swap in\\n   * @param tokenOut The address of the token to swap out\\n   * @param minAmountOut The minimum amount of token to receive from the swap\\n   * @param maxPrice The maximum price to pay for the swap\\n   * @return tokenAmountOut The amount of token swapped out\\n   * @return spotPriceAfter The spot price after the swap\\n   */\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n  /**\\n   * @notice Swaps as many tokens in as needed for an exact amount of tokens out\\n   * @param tokenIn The address of the token to swap in\\n   * @param maxAmountIn The maximum amount of token to swap in\\n   * @param tokenOut The address of the token to swap out\\n   * @param tokenAmountOut The amount of token to swap out\\n   * @param maxPrice The maximum price to pay for the swap\\n   * @return tokenAmountIn The amount of token swapped in\\n   * @return spotPriceAfter The spot price after the swap\\n   */\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n\\n  /**\\n   * @notice Gets the spot price of tokenIn in terms of tokenOut\\n   * @param tokenIn The address of the token to swap in\\n   * @param tokenOut The address of the token to swap out\\n   * @return spotPrice The spot price of the swap\\n   */\\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n  /**\\n   * @notice Gets the spot price of tokenIn in terms of tokenOut without the fee\\n   * @param tokenIn The address of the token to swap in\\n   * @param tokenOut The address of the token to swap out\\n   * @return spotPrice The spot price of the swap without the fee\\n   */\\n  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n  /**\\n   * @notice Gets the finalized status of the pool\\n   * @return isFinalized True if the pool is finalized, False otherwise\\n   */\\n  function isFinalized() external view returns (bool isFinalized);\\n\\n  /**\\n   * @notice Gets the bound status of a token\\n   * @param t The address of the token to check\\n   * @return isBound True if the token is bound, False otherwise\\n   */\\n  function isBound(address t) external view returns (bool isBound);\\n\\n  /**\\n   * @notice Gets the number of tokens in the pool\\n   * @return numTokens The number of tokens in the pool\\n   */\\n  function getNumTokens() external view returns (uint256 numTokens);\\n\\n  /**\\n   * @notice Gets the current array of tokens in the pool, while the pool is not finalized\\n   * @return tokens The array of tokens in the pool\\n   */\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  /**\\n   * @notice Gets the final array of tokens in the pool, after finalization\\n   * @return tokens The array of tokens in the pool\\n   */\\n  function getFinalTokens() external view returns (address[] memory tokens);\\n\\n  /**\\n   * @notice Gets the denormalized weight of a token in the pool\\n   * @param token The address of the token to check\\n   * @return denormWeight The denormalized weight of the token in the pool\\n   */\\n  function getDenormalizedWeight(address token) external view returns (uint256 denormWeight);\\n\\n  /**\\n   * @notice Gets the total denormalized weight of the pool\\n   * @return totalDenormWeight The total denormalized weight of the pool\\n   */\\n  function getTotalDenormalizedWeight() external view returns (uint256 totalDenormWeight);\\n\\n  /**\\n   * @notice Gets the normalized weight of a token in the pool\\n   * @param token The address of the token to check\\n   * @return normWeight The normalized weight of the token in the pool\\n   */\\n  function getNormalizedWeight(address token) external view returns (uint256 normWeight);\\n\\n  /**\\n   * @notice Gets the Pool's ERC20 balance of a token\\n   * @param token The address of the token to check\\n   * @return balance The Pool's ERC20 balance of the token\\n   */\\n  function getBalance(address token) external view returns (uint256 balance);\\n\\n  /**\\n   * @notice Gets the swap fee of the pool\\n   * @return swapFee The swap fee of the pool\\n   */\\n  function getSwapFee() external view returns (uint256 swapFee);\\n\\n  /**\\n   * @notice Gets the controller of the pool\\n   * @return controller The controller of the pool\\n   */\\n  function getController() external view returns (address controller);\\n\\n  /**\\n   * @notice Gets the BFactory address that deployed the pool\\n   * @return factory The address of the factory\\n   */\\n  // solhint-disable-next-line style-guide-casing\\n  function FACTORY() external view returns (address factory);\\n}\\n\"\r\n    },\r\n    \"node_modules/@cowprotocol/contracts/src/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// - Added `name`, `symbol` and `decimals` function declarations\\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals the token uses.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {IBPool} from 'interfaces/IBPool.sol';\\n\\ninterface IBFactory {\\n  /**\\n   * @notice Emitted when creating a new pool\\n   * @param caller The caller of the function that will be set as the controller\\n   * @param bPool The address of the new pool\\n   */\\n  event LOG_NEW_POOL(address indexed caller, address indexed bPool);\\n\\n  /**\\n   * @notice Emitted when setting the BDao address\\n   * @param caller The caller of the set BDao function\\n   * @param bDao The address of the new BDao\\n   */\\n  event LOG_BDAO(address indexed caller, address indexed bDao);\\n\\n  /**\\n   * @notice Thrown when setting a variable to address zero\\n   */\\n  error BFactory_AddressZero();\\n\\n  /**\\n   * @notice Thrown when caller is not BDao address\\n   */\\n  error BFactory_NotBDao();\\n\\n  /**\\n   * @notice Creates a new BPool, assigning the caller as the pool controller\\n   * @param name The name of the Pool ERC20 token\\n   * @param symbol The symbol of the Pool ERC20 token\\n   * @return bPool The new BPool\\n   */\\n  function newBPool(string memory name, string memory symbol) external returns (IBPool bPool);\\n\\n  /**\\n   * @notice Sets the BDao address in the factory\\n   * @param bDao The new BDao address\\n   */\\n  function setBDao(address bDao) external;\\n\\n  /**\\n   * @notice Collects the fees of a pool and transfers it to BDao address\\n   * @param bPool The address of the pool to collect fees from\\n   */\\n  function collect(IBPool bPool) external;\\n\\n  /**\\n   * @notice Checks if an address is a BPool created from this factory\\n   * @param bPool The address to check\\n   * @return isBPool True if the address is a BPool, False otherwise\\n   */\\n  function isBPool(address bPool) external view returns (bool isBPool);\\n\\n  /**\\n   * @notice Gets the BDao address\\n   * @return bDao The address of the BDao\\n   */\\n  function getBDao() external view returns (address bDao);\\n}\\n\"\r\n    },\r\n    \"node_modules/@cowprotocol/contracts/src/contracts/libraries/GPv2Interaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Gnosis Protocol v2 Interaction Library\\n/// @author Gnosis Developers\\nlibrary GPv2Interaction {\\n    /// @dev Interaction data for performing arbitrary contract interactions.\\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\\n    struct Data {\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    /// @dev Execute an arbitrary contract interaction.\\n    ///\\n    /// @param interaction Interaction data.\\n    function execute(Data calldata interaction) internal {\\n        address target = interaction.target;\\n        uint256 value = interaction.value;\\n        bytes calldata callData = interaction.callData;\\n\\n        // NOTE: Use assembly to call the interaction instead of a low level\\n        // call for two reasons:\\n        // - We don't want to copy the return data, since we discard it for\\n        // interactions.\\n        // - Solidity will under certain conditions generate code to copy input\\n        // calldata twice to memory (the second being a \\\"memcopy loop\\\").\\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\\n            if iszero(\\n                call(\\n                    gas(),\\n                    target,\\n                    value,\\n                    freeMemoryPointer,\\n                    callData.length,\\n                    0,\\n                    0\\n                )\\n            ) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\\n    ///\\n    /// @param interaction Interaction data.\\n    /// @return result The 4 byte function selector of the call encoded in\\n    /// this interaction.\\n    function selector(\\n        Data calldata interaction\\n    ) internal pure returns (bytes4 result) {\\n        bytes calldata callData = interaction.callData;\\n        if (callData.length >= 4) {\\n            // NOTE: Read the first word of the interaction's calldata. The\\n            // value does not need to be shifted since `bytesN` values are left\\n            // aligned, and the value does not need to be masked since masking\\n            // occurs when the value is accessed and not stored:\\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                result := calldataload(callData.offset)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@cowprotocol/contracts/src/contracts/libraries/GPv2Trade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../mixins/GPv2Signing.sol\\\";\\nimport \\\"./GPv2Order.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Trade Library.\\n/// @author Gnosis Developers\\nlibrary GPv2Trade {\\n    using GPv2Order for GPv2Order.Data;\\n    using GPv2Order for bytes;\\n\\n    /// @dev A struct representing a trade to be executed as part a batch\\n    /// settlement.\\n    struct Data {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    /// @dev Extracts the order data and signing scheme for the specified trade.\\n    ///\\n    /// @param trade The trade.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the trade parameters map to tokens in this array.\\n    /// @param order The memory location to extract the order data to.\\n    function extractOrder(\\n        Data calldata trade,\\n        IERC20[] calldata tokens,\\n        GPv2Order.Data memory order\\n    ) internal pure returns (GPv2Signing.Scheme signingScheme) {\\n        order.sellToken = tokens[trade.sellTokenIndex];\\n        order.buyToken = tokens[trade.buyTokenIndex];\\n        order.receiver = trade.receiver;\\n        order.sellAmount = trade.sellAmount;\\n        order.buyAmount = trade.buyAmount;\\n        order.validTo = trade.validTo;\\n        order.appData = trade.appData;\\n        order.feeAmount = trade.feeAmount;\\n        (\\n            order.kind,\\n            order.partiallyFillable,\\n            order.sellTokenBalance,\\n            order.buyTokenBalance,\\n            signingScheme\\n        ) = extractFlags(trade.flags);\\n    }\\n\\n    /// @dev Decodes trade flags.\\n    ///\\n    /// Trade flags are used to tightly encode information on how to decode\\n    /// an order. Examples that directly affect the structure of an order are\\n    /// the kind of order (either a sell or a buy order) as well as whether the\\n    /// order is partially fillable or if it is a \\\"fill-or-kill\\\" order. It also\\n    /// encodes the signature scheme used to validate the order. As the most\\n    /// likely values are fill-or-kill sell orders by an externally owned\\n    /// account, the flags are chosen such that `0x00` represents this kind of\\n    /// order. The flags byte uses the following format:\\n    ///\\n    /// ```\\n    /// bit | 31 ...   | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\n    /// ----+----------+-------+---+-------+---+---+\\n    ///     | reserved | *   * | * | *   * | * | * |\\n    ///                  |   |   |   |   |   |   |\\n    ///                  |   |   |   |   |   |   +---- order kind bit, 0 for a sell order\\n    ///                  |   |   |   |   |   |         and 1 for a buy order\\n    ///                  |   |   |   |   |   |\\n    ///                  |   |   |   |   |   +-------- order fill bit, 0 for fill-or-kill\\n    ///                  |   |   |   |   |             and 1 for a partially fillable order\\n    ///                  |   |   |   |   |\\n    ///                  |   |   |   +---+------------ use internal sell token balance bit:\\n    ///                  |   |   |                     0x: ERC20 token balance\\n    ///                  |   |   |                     10: external Balancer Vault balance\\n    ///                  |   |   |                     11: internal Balancer Vault balance\\n    ///                  |   |   |\\n    ///                  |   |   +-------------------- use buy token balance bit\\n    ///                  |   |                         0: ERC20 token balance\\n    ///                  |   |                         1: internal Balancer Vault balance\\n    ///                  |   |\\n    ///                  +---+------------------------ signature scheme bits:\\n    ///                                                00: EIP-712\\n    ///                                                01: eth_sign\\n    ///                                                10: EIP-1271\\n    ///                                                11: pre_sign\\n    /// ```\\n    function extractFlags(\\n        uint256 flags\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 kind,\\n            bool partiallyFillable,\\n            bytes32 sellTokenBalance,\\n            bytes32 buyTokenBalance,\\n            GPv2Signing.Scheme signingScheme\\n        )\\n    {\\n        if (flags & 0x01 == 0) {\\n            kind = GPv2Order.KIND_SELL;\\n        } else {\\n            kind = GPv2Order.KIND_BUY;\\n        }\\n        partiallyFillable = flags & 0x02 != 0;\\n        if (flags & 0x08 == 0) {\\n            sellTokenBalance = GPv2Order.BALANCE_ERC20;\\n        } else if (flags & 0x04 == 0) {\\n            sellTokenBalance = GPv2Order.BALANCE_EXTERNAL;\\n        } else {\\n            sellTokenBalance = GPv2Order.BALANCE_INTERNAL;\\n        }\\n        if (flags & 0x10 == 0) {\\n            buyTokenBalance = GPv2Order.BALANCE_ERC20;\\n        } else {\\n            buyTokenBalance = GPv2Order.BALANCE_INTERNAL;\\n        }\\n\\n        // NOTE: Take advantage of the fact that Solidity will revert if the\\n        // following expression does not produce a valid enum value. This means\\n        // we check here that the leading reserved bits must be 0.\\n        signingScheme = GPv2Signing.Scheme(flags >> 5);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\n/**\\n * @title BConst\\n * @notice Constants used in the scope of the BPool contract.\\n */\\ncontract BConst {\\n  /// @notice The unit of precision used in the calculations.\\n  uint256 public constant BONE = 10 ** 18;\\n\\n  /// @notice The minimum number of bound tokens in a pool.\\n  uint256 public constant MIN_BOUND_TOKENS = 2;\\n  /// @notice The maximum number of bound tokens in a pool.\\n  uint256 public constant MAX_BOUND_TOKENS = 8;\\n\\n  /// @notice The minimum swap fee that can be set.\\n  uint256 public constant MIN_FEE = BONE / 10 ** 6;\\n  /// @notice The maximum swap fee that can be set.\\n  uint256 public constant MAX_FEE = BONE - MIN_FEE;\\n  /// @notice The immutable exit fee percentage\\n  uint256 public constant EXIT_FEE = 0;\\n\\n  /// @notice The minimum weight that a token can have.\\n  uint256 public constant MIN_WEIGHT = BONE;\\n  /// @notice The maximum weight that a token can have.\\n  uint256 public constant MAX_WEIGHT = BONE * 50;\\n  /// @notice The maximum sum of weights of all tokens in a pool.\\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n  /// @notice The minimum balance that a token must have.\\n  uint256 public constant MIN_BALANCE = BONE / 10 ** 12;\\n\\n  /// @notice The initial total supply of the pool tokens (minted to the pool creator).\\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n  /// @notice The minimum base value for the bpow calculation.\\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\\n  /// @notice The maximum base value for the bpow calculation.\\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  /// @notice The precision of the bpow calculation.\\n  uint256 public constant BPOW_PRECISION = BONE / 10 ** 10;\\n\\n  /// @notice The maximum ratio of input tokens vs the current pool balance.\\n  uint256 public constant MAX_IN_RATIO = BONE >> 1;\\n  /// @notice The maximum ratio of output tokens vs the current pool balance.\\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n\\n  /**\\n   * @notice The storage slot used to write transient data.\\n   * @dev Using an arbitrary storage slot to prevent possible future\\n   * transient variables defined by solidity from overriding it.\\n   * @dev Value is: uint256(keccak256('BPool.transientStorageLock')) - 1;\\n   */\\n  uint256 internal constant _MUTEX_TRANSIENT_STORAGE_SLOT =\\n    0x3f8f4c536ce1b925b469af1b09a44da237dab5bbc584585648c12be1ca25a8c4;\\n  /// @notice The value representing an unlocked state of the mutex.\\n  bytes32 internal constant _MUTEX_FREE = bytes32(uint256(0));\\n  /// @notice The value representing a locked state of the mutex.\\n  bytes32 internal constant _MUTEX_TAKEN = bytes32(uint256(1));\\n}\\n\"\r\n    },\r\n    \"src/contracts/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport {BConst} from './BConst.sol';\\n\\n/**\\n * @title BNum\\n * @notice Includes functions for arithmetic operations with fixed-point numbers.\\n * @dev The arithmetic operations are implemented with a precision of BONE.\\n */\\n// solhint-disable private-vars-leading-underscore\\n// solhint-disable named-return-values\\ncontract BNum is BConst {\\n  /**\\n   * @notice Thrown when an overflow is encountered inside the add function\\n   */\\n  error BNum_AddOverflow();\\n\\n  /**\\n   * @notice Thrown when an underflow is encountered inside the sub function\\n   */\\n  error BNum_SubUnderflow();\\n\\n  /**\\n   * @notice Thrown when an overflow is encountered inside the mul function\\n   */\\n  error BNum_MulOverflow();\\n\\n  /**\\n   * @notice Thrown when attempting to divide by zero\\n   */\\n  error BNum_DivZero();\\n\\n  /**\\n   * @notice Thrown when an internal error occurs inside div function\\n   */\\n  error BNum_DivInternal();\\n\\n  /**\\n   * @notice Thrown when the base is too low in the bpow function\\n   */\\n  error BNum_BPowBaseTooLow();\\n\\n  /**\\n   * @notice Thrown when the base is too high in the bpow function\\n   */\\n  error BNum_BPowBaseTooHigh();\\n\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    unchecked {\\n      return a / BONE;\\n    }\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    unchecked {\\n      return btoi(a) * BONE;\\n    }\\n  }\\n\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) {\\n        revert BNum_AddOverflow();\\n      }\\n      return c;\\n    }\\n  }\\n\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    unchecked {\\n      (uint256 c, bool flag) = bsubSign(a, b);\\n      if (flag) {\\n        revert BNum_SubUnderflow();\\n      }\\n      return c;\\n    }\\n  }\\n\\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\n    unchecked {\\n      if (a >= b) {\\n        return (a - b, false);\\n      } else {\\n        return (b - a, true);\\n      }\\n    }\\n  }\\n\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 c0 = a * b;\\n      if (a != 0 && c0 / a != b) {\\n        revert BNum_MulOverflow();\\n      }\\n      // NOTE: using >> 1 instead of / 2\\n      uint256 c1 = c0 + (BONE >> 1);\\n      if (c1 < c0) {\\n        revert BNum_MulOverflow();\\n      }\\n      uint256 c2 = c1 / BONE;\\n      return c2;\\n    }\\n  }\\n\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    unchecked {\\n      if (b == 0) {\\n        revert BNum_DivZero();\\n      }\\n      uint256 c0 = a * BONE;\\n      if (a != 0 && c0 / a != BONE) {\\n        revert BNum_DivInternal(); // bmul overflow\\n      }\\n      // NOTE: using >> 1 instead of / 2\\n      uint256 c1 = c0 + (b >> 1);\\n      if (c1 < c0) {\\n        revert BNum_DivInternal(); //  badd require\\n      }\\n      uint256 c2 = c1 / b;\\n      return c2;\\n    }\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 z = n % 2 != 0 ? a : BONE;\\n\\n      for (n /= 2; n != 0; n /= 2) {\\n        a = bmul(a, a);\\n\\n        if (n % 2 != 0) {\\n          z = bmul(z, a);\\n        }\\n      }\\n      return z;\\n    }\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    unchecked {\\n      if (base < MIN_BPOW_BASE) {\\n        revert BNum_BPowBaseTooLow();\\n      }\\n      if (base > MAX_BPOW_BASE) {\\n        revert BNum_BPowBaseTooHigh();\\n      }\\n\\n      uint256 whole = bfloor(exp);\\n      uint256 remain = bsub(exp, whole);\\n\\n      uint256 wholePow = bpowi(base, btoi(whole));\\n\\n      if (remain == 0) {\\n        return wholePow;\\n      }\\n\\n      uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n      return bmul(wholePow, partialResult);\\n    }\\n  }\\n\\n  function bpowApprox(uint256 base, uint256 exp, uint256 precision) internal pure returns (uint256) {\\n    unchecked {\\n      // term 0:\\n      uint256 a = exp;\\n      (uint256 x, bool xneg) = bsubSign(base, BONE);\\n      uint256 term = BONE;\\n      uint256 sum = term;\\n      bool negative = false;\\n\\n      // term(k) = numer / denom\\n      //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n      // each iteration, multiply previous term by (a-(k-1)) * x / k\\n      // continue until term is less than precision\\n      for (uint256 i = 1; term >= precision; i++) {\\n        uint256 bigK = i * BONE;\\n        (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n        term = bmul(term, bmul(c, x));\\n        term = bdiv(term, bigK);\\n        if (term == 0) break;\\n\\n        if (xneg) negative = !negative;\\n        if (cneg) negative = !negative;\\n        if (negative) {\\n          sum = bsub(sum, term);\\n        } else {\\n          sum = badd(sum, term);\\n        }\\n      }\\n\\n      return sum;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@cowprotocol/contracts/src/contracts/mixins/GPv2Signing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/GPv2EIP1271.sol\\\";\\nimport \\\"../libraries/GPv2Order.sol\\\";\\nimport \\\"../libraries/GPv2Trade.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Signing Library.\\n/// @author Gnosis Developers\\nabstract contract GPv2Signing {\\n    using GPv2Order for GPv2Order.Data;\\n    using GPv2Order for bytes;\\n\\n    /// @dev Recovered trade data containing the extracted order and the\\n    /// recovered owner address.\\n    struct RecoveredOrder {\\n        GPv2Order.Data data;\\n        bytes uid;\\n        address owner;\\n        address receiver;\\n    }\\n\\n    /// @dev Signing scheme used for recovery.\\n    enum Scheme {\\n        Eip712,\\n        EthSign,\\n        Eip1271,\\n        PreSign\\n    }\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 private constant DOMAIN_NAME = keccak256(\\\"Gnosis Protocol\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 private constant DOMAIN_VERSION = keccak256(\\\"v2\\\");\\n\\n    /// @dev Marker value indicating an order is pre-signed.\\n    uint256 private constant PRE_SIGNED =\\n        uint256(keccak256(\\\"GPv2Signing.Scheme.PreSign\\\"));\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// GPv2 contracts.\\n    bytes32 public immutable domainSeparator;\\n\\n    /// @dev Storage indicating whether or not an order has been signed by a\\n    /// particular address.\\n    mapping(bytes => uint256) public preSignature;\\n\\n    /// @dev Event that is emitted when an account either pre-signs an order or\\n    /// revokes an existing pre-signature.\\n    event PreSignature(address indexed owner, bytes orderUid, bool signed);\\n\\n    constructor() {\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Sets a presignature for the specified order UID.\\n    ///\\n    /// @param orderUid The unique identifier of the order to pre-sign.\\n    /// @param signed True to set the order as tradable with pre-sign, false to\\n    /// false to unset it.\\n    function setPreSignature(bytes calldata orderUid, bool signed) external {\\n        (, address owner, ) = orderUid.extractOrderUidParams();\\n        require(owner == msg.sender, \\\"GPv2: cannot presign order\\\");\\n        if (signed) {\\n            preSignature[orderUid] = PRE_SIGNED;\\n        } else {\\n            preSignature[orderUid] = 0;\\n        }\\n        emit PreSignature(owner, orderUid, signed);\\n    }\\n\\n    /// @dev Returns an empty recovered order with a pre-allocated buffer for\\n    /// packing the unique identifier.\\n    ///\\n    /// @return recoveredOrder The empty recovered order data.\\n    function allocateRecoveredOrder()\\n        internal\\n        pure\\n        returns (RecoveredOrder memory recoveredOrder)\\n    {\\n        recoveredOrder.uid = new bytes(GPv2Order.UID_LENGTH);\\n    }\\n\\n    /// @dev Extracts order data and recovers the signer from the specified\\n    /// trade.\\n    ///\\n    /// @param recoveredOrder Memory location used for writing the recovered order data.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the trade parameters map to tokens in this array.\\n    /// @param trade The trade data to recover the order data from.\\n    function recoverOrderFromTrade(\\n        RecoveredOrder memory recoveredOrder,\\n        IERC20[] calldata tokens,\\n        GPv2Trade.Data calldata trade\\n    ) internal view {\\n        GPv2Order.Data memory order = recoveredOrder.data;\\n\\n        Scheme signingScheme = GPv2Trade.extractOrder(trade, tokens, order);\\n        (bytes32 orderDigest, address owner) = recoverOrderSigner(\\n            order,\\n            signingScheme,\\n            trade.signature\\n        );\\n\\n        recoveredOrder.uid.packOrderUidParams(\\n            orderDigest,\\n            owner,\\n            order.validTo\\n        );\\n        recoveredOrder.owner = owner;\\n        recoveredOrder.receiver = order.actualReceiver(owner);\\n    }\\n\\n    /// @dev The length of any signature from an externally owned account.\\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\\n\\n    /// @dev Recovers an order's signer from the specified order and signature.\\n    ///\\n    /// @param order The order to recover a signature for.\\n    /// @param signingScheme The signing scheme.\\n    /// @param signature The signature bytes.\\n    /// @return orderDigest The computed order hash.\\n    /// @return owner The recovered address from the specified signature.\\n    function recoverOrderSigner(\\n        GPv2Order.Data memory order,\\n        Scheme signingScheme,\\n        bytes calldata signature\\n    ) internal view returns (bytes32 orderDigest, address owner) {\\n        orderDigest = order.hash(domainSeparator);\\n        if (signingScheme == Scheme.Eip712) {\\n            owner = recoverEip712Signer(orderDigest, signature);\\n        } else if (signingScheme == Scheme.EthSign) {\\n            owner = recoverEthsignSigner(orderDigest, signature);\\n        } else if (signingScheme == Scheme.Eip1271) {\\n            owner = recoverEip1271Signer(orderDigest, signature);\\n        } else {\\n            // signingScheme == Scheme.PreSign\\n            owner = recoverPreSigner(orderDigest, signature, order.validTo);\\n        }\\n    }\\n\\n    /// @dev Perform an ECDSA recover for the specified message and calldata\\n    /// signature.\\n    ///\\n    /// The signature is encoded by tighyly packing the following struct:\\n    /// ```\\n    /// struct EncodedSignature {\\n    ///     bytes32 r;\\n    ///     bytes32 s;\\n    ///     uint8 v;\\n    /// }\\n    /// ```\\n    ///\\n    /// @param message The signed message.\\n    /// @param encodedSignature The encoded signature.\\n    function ecdsaRecover(\\n        bytes32 message,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address signer) {\\n        require(\\n            encodedSignature.length == ECDSA_SIGNATURE_LENGTH,\\n            \\\"GPv2: malformed ecdsa signature\\\"\\n        );\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // NOTE: Use assembly to efficiently decode signature data.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // r = uint256(encodedSignature[0:32])\\n            r := calldataload(encodedSignature.offset)\\n            // s = uint256(encodedSignature[32:64])\\n            s := calldataload(add(encodedSignature.offset, 32))\\n            // v = uint8(encodedSignature[64])\\n            v := shr(248, calldataload(add(encodedSignature.offset, 64)))\\n        }\\n\\n        signer = ecrecover(message, v, r, s);\\n        require(signer != address(0), \\\"GPv2: invalid ecdsa signature\\\");\\n    }\\n\\n    /// @dev Decodes signature bytes originating from an EIP-712-encoded\\n    /// signature.\\n    ///\\n    /// EIP-712 signs typed data. The specifications are described in the\\n    /// related EIP (<https://eips.ethereum.org/EIPS/eip-712>).\\n    ///\\n    /// EIP-712 signatures are encoded as standard ECDSA signatures as described\\n    /// in the corresponding decoding function [`ecdsaRecover`].\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature Calldata pointing to tightly packed signature\\n    /// bytes.\\n    /// @return owner The address of the signer.\\n    function recoverEip712Signer(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address owner) {\\n        owner = ecdsaRecover(orderDigest, encodedSignature);\\n    }\\n\\n    /// @dev Decodes signature bytes originating from the output of the eth_sign\\n    /// RPC call.\\n    ///\\n    /// The specifications are described in the Ethereum documentation\\n    /// (<https://eth.wiki/json-rpc/API#eth_sign>).\\n    ///\\n    /// eth_sign signatures are encoded as standard ECDSA signatures as\\n    /// described in the corresponding decoding function\\n    /// [`ecdsaRecover`].\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature Calldata pointing to tightly packed signature\\n    /// bytes.\\n    /// @return owner The address of the signer.\\n    function recoverEthsignSigner(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address owner) {\\n        // The signed message is encoded as:\\n        // `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" || length || data`, where\\n        // the length is a constant (32 bytes) and the data is defined as:\\n        // `orderDigest`.\\n        bytes32 ethsignDigest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", orderDigest)\\n        );\\n\\n        owner = ecdsaRecover(ethsignDigest, encodedSignature);\\n    }\\n\\n    /// @dev Verifies the input calldata as an EIP-1271 contract signature and\\n    /// returns the address of the signer.\\n    ///\\n    /// The encoded signature tightly packs the following struct:\\n    ///\\n    /// ```\\n    /// struct EncodedEip1271Signature {\\n    ///     address owner;\\n    ///     bytes signature;\\n    /// }\\n    /// ```\\n    ///\\n    /// This function enforces that the encoded data stores enough bytes to\\n    /// cover the full length of the decoded signature.\\n    ///\\n    /// @param encodedSignature The encoded EIP-1271 signature.\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the signer.\\n    function recoverEip1271Signer(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal view returns (address owner) {\\n        // NOTE: Use assembly to read the verifier address from the encoded\\n        // signature bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // owner = address(encodedSignature[0:20])\\n            owner := shr(96, calldataload(encodedSignature.offset))\\n        }\\n\\n        // NOTE: Configure prettier to ignore the following line as it causes\\n        // a panic in the Solidity plugin.\\n        // prettier-ignore\\n        bytes calldata signature = encodedSignature[20:];\\n\\n        require(\\n            EIP1271Verifier(owner).isValidSignature(orderDigest, signature) ==\\n                GPv2EIP1271.MAGICVALUE,\\n            \\\"GPv2: invalid eip1271 signature\\\"\\n        );\\n    }\\n\\n    /// @dev Verifies the order has been pre-signed. The signature is the\\n    /// address of the signer of the order.\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature The pre-sign signature reprenting the order UID.\\n    /// @param validTo The order expiry timestamp.\\n    /// @return owner The address of the signer.\\n    function recoverPreSigner(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature,\\n        uint32 validTo\\n    ) internal view returns (address owner) {\\n        require(encodedSignature.length == 20, \\\"GPv2: malformed presignature\\\");\\n        // NOTE: Use assembly to read the owner address from the encoded\\n        // signature bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // owner = address(encodedSignature[0:20])\\n            owner := shr(96, calldataload(encodedSignature.offset))\\n        }\\n\\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\\n\\n        require(\\n            preSignature[orderUid] == PRE_SIGNED,\\n            \\\"GPv2: order not presigned\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"node_modules/@cowprotocol/contracts/src/contracts/interfaces/GPv2EIP1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nlibrary GPv2EIP1271 {\\n    /// @dev Value returned by a call to `isValidSignature` if the signature\\n    /// was verified successfully. The value is defined in EIP-1271 as:\\n    /// bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\\n}\\n\\n/// @title EIP1271 Interface\\n/// @dev Standardized interface for an implementation of smart contract\\n/// signatures as described in EIP-1271. The code that follows is identical to\\n/// the code in the standard with the exception of formatting and syntax\\n/// changes to adapt the code to our Solidity version.\\ninterface EIP1271Verifier {\\n    /// @dev Should return whether the signature provided is valid for the\\n    /// provided data\\n    /// @param _hash      Hash of the data to be signed\\n    /// @param _signature Signature byte array associated with _data\\n    ///\\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\\n    /// solc > 0.5)\\n    /// MUST allow external calls\\n    ///\\n    function isValidSignature(\\n        bytes32 _hash,\\n        bytes memory _signature\\n    ) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"forge-gas-snapshot/=node_modules/forge-gas-snapshot/src/\",\r\n      \"solmate/=node_modules/solmate/src/\",\r\n      \"@cowprotocol/=node_modules/@cowprotocol/contracts/src/contracts/\",\r\n      \"cowprotocol/=node_modules/@cowprotocol/contracts/src/\",\r\n      \"@composable-cow/=node_modules/composable-cow/\",\r\n      \"@cow-amm/=node_modules/cow-amm/src/\",\r\n      \"lib/openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"contracts/=src/contracts/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"composable-cow/=node_modules/composable-cow/\",\r\n      \"cow-amm/=node_modules/cow-amm/\",\r\n      \"erc4626-tests/=node_modules/composable-cow/lib/@openzeppelin/lib/erc4626-tests/\",\r\n      \"murky/=node_modules/composable-cow/lib/murky/src/\",\r\n      \"openzeppelin-contracts/=node_modules/composable-cow/lib/murky/lib/openzeppelin-contracts/\",\r\n      \"safe/=node_modules/composable-cow/lib/safe/contracts/\",\r\n      \"lib/composable-cow:@openzeppelin/=node_modules/cow-amm/lib/openzeppelin/contracts/\",\r\n      \"lib/composable-cow:@openzeppelin/contracts/=node_modules/cow-amm/lib/openzeppelin/contracts/\",\r\n      \"lib/composable-cow:cowprotocol/=node_modules/cow-amm/lib/composable-cow/lib/cowprotocol/src/\",\r\n      \"lib/composable-cow:safe/=node_modules/cow-amm/lib/composable-cow/lib/safe/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cowSolutionSettler\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"appData\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AppDataDoesNotMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BCoWPool_FeeMustBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BCoWPool_InvalidBalanceMarker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BCoWPool_InvalidOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BCoWPool_OrderValidityTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BCoWPool_ReceiverIsNotBCoWPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_AddOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_BPowBaseTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_BPowBaseTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_DivInternal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_DivZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_MulOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BNum_SubUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_BalanceBelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_CallerIsNotController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_FeeAboveMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_FeeBelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_InvalidPoolAmountIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_InvalidPoolRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_InvalidTokenAmountIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_InvalidTokenAmountOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_PoolAmountInAboveMaxPoolAmountIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_PoolAmountOutBelowMinPoolAmountOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_PoolIsFinalized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_PoolNotFinalized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_SpotPriceAboveMaxPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_SpotPriceAfterBelowSpotPriceBefore\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_SpotPriceBeforeAboveTokenRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenAlreadyBound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenAmountInAboveMaxAmountIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenAmountInAboveMaxRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenAmountOutAboveMaxOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenAmountOutBelowMinAmountOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenAmountOutBelowMinOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokenNotBound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokensAboveMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TokensBelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_TotalWeightAboveMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_WeightAboveMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BPool_WeightBelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommitOutsideOfSettlement\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderDoesNotMatchCommitmentHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderDoesNotMatchMessageHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bCoWPool\",\"type\":\"address\"}],\"name\":\"COWAMMPoolCreated\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APP_DATA\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ORDER_DURATION\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SOLUTION_SETTLER\",\"outputs\":[{\"internalType\":\"contract ISettlement\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SOLUTION_SETTLER_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_RELAYER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validTo\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"appData\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}],\"internalType\":\"struct GPv2Order.Data\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BCoWPool", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "0000000000000000000000009008d19f58aabd9ed0d60971565aa8510560ab41362e5182440b52aa8fffe70a251550fbbcbca424740fe5a14f59bf0c1b06fe1d000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000095465737420506f6f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008544553542d425054000000000000000000000000000000000000000000000000", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}