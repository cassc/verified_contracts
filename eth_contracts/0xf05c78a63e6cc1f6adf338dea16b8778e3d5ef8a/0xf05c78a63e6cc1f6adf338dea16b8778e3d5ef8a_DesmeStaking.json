{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Pausable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\ninterface IERC20EXT {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nstruct StructAccount {\r\n    address selfAddress;\r\n    uint256 totalValueStaked;\r\n    uint256 stakingRewardsClaimed;\r\n    uint256 pendingStakingRewards;\r\n    uint256[] stakingIds;\r\n}\r\n\r\nstruct StructStaking {\r\n    bool isActive;\r\n    address owner;\r\n    uint256 stakingId;\r\n    uint256 valueStaked;\r\n    uint256 startTime;\r\n    uint256 stakingRewardClaimed;\r\n    uint256 initialRewards;\r\n    uint256 calStartTime;\r\n}\r\n\r\ncontract DesmeStaking is Ownable, Pausable {\r\n    address[] private _users;\r\n    uint256 private _totalStakingRewardsDistributed;\r\n\r\n    uint256 private _stakingsCount;\r\n\r\n    uint256 private _calStakingReward;\r\n    uint256 private _valueStaked;\r\n\r\n    uint256 private _lastTimeRewardDistributed;\r\n    uint256 private _carryForwardBalance;\r\n\r\n    address private _tokenAddress;\r\n\r\n    bool private _noReentrancy;\r\n\r\n    mapping(address => StructAccount) private _mappingAccounts;\r\n    mapping(uint256 => StructStaking) private _mappingStakings;\r\n\r\n    event SelfAddressUpdated(address newAddress);\r\n\r\n    event Stake(uint256 value, uint256 stakingId);\r\n    event UnStake(uint256 value);\r\n\r\n    event ClaimedStakingReward(uint256 value);\r\n    event DistributeStakingReward(uint256 value);\r\n    event ClaimCarryForwardBalance(address receiver, uint256 value);\r\n\r\n    event ContractPaused(bool isPaused);\r\n\r\n    modifier noReentrancy() {\r\n        require(!_noReentrancy, \"Reentrancy attack.\");\r\n        _noReentrancy = true;\r\n        _;\r\n        _noReentrancy = false;\r\n    }\r\n\r\n    receive() external payable {\r\n        distributeStakingRewards();\r\n    }\r\n\r\n    constructor(address initialOwner) Ownable(initialOwner) {\r\n        uint256 currentTime = block.timestamp;\r\n        _lastTimeRewardDistributed = currentTime;\r\n    }\r\n\r\n    function _updateUserAddress(\r\n        StructAccount storage _userAccount,\r\n        address _userAddress\r\n    ) private {\r\n        _userAccount.selfAddress = _userAddress;\r\n        emit SelfAddressUpdated(_userAddress);\r\n    }\r\n\r\n    function _updateCalStakingReward(\r\n        StructStaking storage stakingAccount,\r\n        uint256 _value\r\n    ) private {\r\n        if (_calStakingReward > 0) {\r\n            uint256 stakingReward = (_calStakingReward * _value) / _valueStaked;\r\n\r\n            stakingAccount.initialRewards += stakingReward;\r\n            _calStakingReward += stakingReward;\r\n        }\r\n    }\r\n\r\n    function _stake(address _userAddress, uint256 _value) private {\r\n        require(\r\n            _userAddress != address(0),\r\n            \"_stake(): AddressZero cannot stake.\"\r\n        );\r\n        require(_value > 0, \"_stake(): Value should be greater than zero.\");\r\n\r\n        StructAccount storage userAccount = _mappingAccounts[_userAddress];\r\n        uint256 currentStakingId = _stakingsCount;\r\n\r\n        if (userAccount.selfAddress == address(0)) {\r\n            _updateUserAddress(userAccount, _userAddress);\r\n            _users.push(_userAddress);\r\n        }\r\n\r\n        userAccount.stakingIds.push(currentStakingId);\r\n        userAccount.totalValueStaked += _value;\r\n\r\n        StructStaking storage stakingAccount = _mappingStakings[\r\n            currentStakingId\r\n        ];\r\n\r\n        stakingAccount.isActive = true;\r\n        stakingAccount.owner = _userAddress;\r\n        stakingAccount.stakingId = currentStakingId;\r\n        stakingAccount.valueStaked = _value;\r\n        stakingAccount.startTime = block.timestamp;\r\n        stakingAccount.calStartTime = _lastTimeRewardDistributed;\r\n\r\n        _updateCalStakingReward(stakingAccount, _value);\r\n\r\n        _valueStaked += _value;\r\n        _stakingsCount++;\r\n\r\n        emit Stake(_value, currentStakingId);\r\n    }\r\n\r\n    function stake(address _userAddress, uint256 _valueInWei)\r\n        external\r\n        whenNotPaused\r\n    {\r\n        bool sent = IERC20(_tokenAddress).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _toTokens(_tokenAddress, _valueInWei)\r\n        );\r\n\r\n        require(sent, \"unStake(): Tokens not transfered\");\r\n\r\n        _stake(_userAddress, _valueInWei);\r\n    }\r\n\r\n    function _getStakingRewardsById(StructStaking memory stakingAccount)\r\n        private\r\n        view\r\n        returns (\r\n            uint256 userStakingReward,\r\n            uint256 rewardClaimable,\r\n            uint256 carryForwardBalance\r\n        )\r\n    {\r\n        if (\r\n            _calStakingReward > 0 &&\r\n            stakingAccount.isActive &&\r\n            stakingAccount.calStartTime < _lastTimeRewardDistributed\r\n        ) {\r\n            userStakingReward =\r\n                ((_calStakingReward * stakingAccount.valueStaked) /\r\n                    _valueStaked) -\r\n                (stakingAccount.stakingRewardClaimed +\r\n                    stakingAccount.initialRewards);\r\n\r\n            if (userStakingReward > 0) {\r\n                carryForwardBalance = ((userStakingReward *\r\n                    (stakingAccount.startTime - stakingAccount.calStartTime)) /\r\n                    (_lastTimeRewardDistributed - stakingAccount.calStartTime));\r\n\r\n                rewardClaimable = userStakingReward - carryForwardBalance;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStakingRewardsById(uint256 _stakingId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 userStakingReward,\r\n            uint256 rewardClaimable,\r\n            uint256 carryForwardBalance\r\n        )\r\n    {\r\n        return _getStakingRewardsById(_mappingStakings[_stakingId]);\r\n    }\r\n\r\n    function _getUserAllStakingRewards(StructAccount memory userAccount)\r\n        private\r\n        view\r\n        returns (\r\n            uint256 userTotalStakingReward,\r\n            uint256 totalRewardClaimable,\r\n            uint256 totalCarryForwardBalance\r\n        )\r\n    {\r\n        uint256[] memory userStakingIds = userAccount.stakingIds;\r\n\r\n        for (uint256 i; i < userStakingIds.length; ++i) {\r\n            StructStaking memory stakingAccount = _mappingStakings[\r\n                userStakingIds[i]\r\n            ];\r\n\r\n            if (stakingAccount.isActive) {\r\n                (\r\n                    uint256 userStakingReward,\r\n                    uint256 rewardClaimable,\r\n                    uint256 carryForwardBalance\r\n                ) = _getStakingRewardsById(stakingAccount);\r\n\r\n                userTotalStakingReward += userStakingReward;\r\n                totalRewardClaimable += rewardClaimable;\r\n                totalCarryForwardBalance += carryForwardBalance;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUserStakingRewards(address _userAddress)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 userTotalStakingReward,\r\n            uint256 rewardClaimable,\r\n            uint256 carryForwardBalance\r\n        )\r\n    {\r\n        StructAccount memory userAccount = _mappingAccounts[_userAddress];\r\n\r\n        return _getUserAllStakingRewards(userAccount);\r\n    }\r\n\r\n    function _claimUserStakingReward(address _userAddress)\r\n        private\r\n        returns (uint256 totalRewardClaimable, uint256 totalCarryForwardBalance)\r\n    {\r\n        StructAccount storage userAccount = _mappingAccounts[_userAddress];\r\n        require(\r\n            userAccount.stakingIds.length > 0,\r\n            \"_claimStakingReward(): You have no stakings\"\r\n        );\r\n\r\n        for (uint256 i; i < userAccount.stakingIds.length; ++i) {\r\n            StructStaking storage stakingAccount = _mappingStakings[\r\n                userAccount.stakingIds[i]\r\n            ];\r\n\r\n            require(\r\n                stakingAccount.owner == _userAddress,\r\n                \"You are not the owner of this staking.\"\r\n            );\r\n\r\n            if (stakingAccount.isActive) {\r\n                (\r\n                    ,\r\n                    uint256 rewardClaimable,\r\n                    uint256 carryForwardBalance\r\n                ) = _getStakingRewardsById(stakingAccount);\r\n\r\n                if (rewardClaimable > 0) {\r\n                    stakingAccount.stakingRewardClaimed += rewardClaimable;\r\n                    totalRewardClaimable += rewardClaimable;\r\n                }\r\n\r\n                if (carryForwardBalance > 0) {\r\n                    stakingAccount.initialRewards += carryForwardBalance;\r\n                    totalCarryForwardBalance += carryForwardBalance;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (totalRewardClaimable > 0) {\r\n            userAccount.stakingRewardsClaimed += totalRewardClaimable;\r\n            _carryForwardBalance += totalCarryForwardBalance;\r\n\r\n            emit ClaimedStakingReward(totalRewardClaimable);\r\n        }\r\n    }\r\n\r\n    function claimStakingReward(address _userAddress) external noReentrancy {\r\n        (uint256 rewardClaimable, ) = _claimUserStakingReward(_userAddress);\r\n\r\n        require(\r\n            rewardClaimable > 0,\r\n            \"_claimUserStakingReward(): No rewards to claim.\"\r\n        );\r\n\r\n        uint256 ethBalanceThis = address(this).balance;\r\n\r\n        require(\r\n            ethBalanceThis >= rewardClaimable,\r\n            \"claimStakingReward(): Contract has less balance to pay.\"\r\n        );\r\n\r\n        (bool status, ) = payable(_userAddress).call{value: rewardClaimable}(\r\n            \"\"\r\n        );\r\n        require(status, \"claimStakingReward(): Reward ETH Not transfered.\");\r\n    }\r\n\r\n    function _unStake(address _userAddress)\r\n        private\r\n        returns (uint256 tokenUnStaked, uint256 stakingRewardClaimed)\r\n    {\r\n        StructAccount storage userAccount = _mappingAccounts[_userAddress];\r\n\r\n        require(\r\n            userAccount.stakingIds.length > 0,\r\n            \"_claimStakingReward(): You have no stakings\"\r\n        );\r\n\r\n        (uint256 rewardClaimable, ) = _claimUserStakingReward(_userAddress);\r\n\r\n        if (rewardClaimable > 0) {\r\n            stakingRewardClaimed += rewardClaimable;\r\n        }\r\n\r\n        userAccount.totalValueStaked = 0;\r\n        uint256 calRewards;\r\n\r\n        for (uint256 i; i < userAccount.stakingIds.length; ++i) {\r\n            StructStaking storage stakingAccount = _mappingStakings[\r\n                userAccount.stakingIds[i]\r\n            ];\r\n\r\n            require(\r\n                stakingAccount.owner == _userAddress,\r\n                \"You are not the owner of this staking.\"\r\n            );\r\n\r\n            if (stakingAccount.isActive) {\r\n                stakingAccount.isActive = false;\r\n                tokenUnStaked += stakingAccount.valueStaked;\r\n                calRewards += stakingAccount.stakingRewardClaimed;\r\n                calRewards += stakingAccount.initialRewards;\r\n            }\r\n        }\r\n\r\n        require(tokenUnStaked > 0, \"_unstake(): No value to unStake.\");\r\n\r\n        _calStakingReward -= calRewards;\r\n\r\n        _valueStaked -= tokenUnStaked;\r\n        emit UnStake(tokenUnStaked);\r\n    }\r\n\r\n    function unStake() external {\r\n        address msgSender = msg.sender;\r\n        (uint256 tokenUnStaked, uint256 stakingRewardClaimed) = _unStake(\r\n            msgSender\r\n        );\r\n\r\n        if (tokenUnStaked > 0) {\r\n            bool sent = IERC20(_tokenAddress).transfer(\r\n                msgSender,\r\n                _toTokens(_tokenAddress, tokenUnStaked)\r\n            );\r\n\r\n            require(sent, \"unStake(): Tokens not transfered\");\r\n        }\r\n\r\n        if (stakingRewardClaimed > 0) {\r\n            (bool status, ) = payable(msgSender).call{\r\n                value: stakingRewardClaimed\r\n            }(\"\");\r\n            require(status, \"unstake(): Reward not transfered.\");\r\n        }\r\n    }\r\n\r\n    function distributeStakingRewards() public payable {\r\n        uint256 msgValue = msg.value;\r\n\r\n        require(\r\n            msgValue > 0,\r\n            \"distributeStakingRewards(): Reward must be greater than zero.\"\r\n        );\r\n\r\n        if (_carryForwardBalance > 0) {\r\n            msgValue += _carryForwardBalance;\r\n            delete _carryForwardBalance;\r\n        }\r\n\r\n        _calStakingReward += msgValue;\r\n        _lastTimeRewardDistributed = block.timestamp;\r\n        _totalStakingRewardsDistributed += msgValue;\r\n\r\n        emit DistributeStakingReward(msgValue);\r\n    }\r\n\r\n    function getUsersParticipatedList()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return _users;\r\n    }\r\n\r\n    function getUserShare(address _userAddress)\r\n        external\r\n        view\r\n        returns (uint256 userShare)\r\n    {\r\n        StructAccount memory userAccount = _mappingAccounts[_userAddress];\r\n\r\n        userShare =\r\n            (userAccount.totalValueStaked * 100 * 1 ether) /\r\n            _valueStaked;\r\n    }\r\n\r\n    function getContractDefault() external view returns (address tokenAddress) {\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n\r\n    function setTokenAddress(address tokenAddress_) external onlyOwner {\r\n        _tokenAddress = tokenAddress_;\r\n    }\r\n\r\n    function getContractAnalytics()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 usersCount,\r\n            uint256 stakingsCount,\r\n            uint256 totalStakingRewardsDistributed,\r\n            uint256 calStakingReward,\r\n            uint256 valueStaked,\r\n            uint256 lastTimeRewardDistributed,\r\n            uint256 carryForwardBalance\r\n        )\r\n    {\r\n        usersCount = _users.length;\r\n        stakingsCount = _stakingsCount;\r\n        totalStakingRewardsDistributed = _totalStakingRewardsDistributed;\r\n        calStakingReward = _calStakingReward;\r\n        valueStaked = _valueStaked;\r\n        lastTimeRewardDistributed = _lastTimeRewardDistributed;\r\n        carryForwardBalance = _carryForwardBalance;\r\n    }\r\n\r\n    function getUserAccount(address _userAddress)\r\n        external\r\n        view\r\n        returns (StructAccount memory)\r\n    {\r\n        return _mappingAccounts[_userAddress];\r\n    }\r\n\r\n    function getStakingById(uint256 _stakingId)\r\n        external\r\n        view\r\n        returns (StructStaking memory)\r\n    {\r\n        return _mappingStakings[_stakingId];\r\n    }\r\n\r\n    function _toTokens(address tokenAddress_, uint256 _valueInWei)\r\n        private\r\n        view\r\n        returns (uint256 valueInTokens)\r\n    {\r\n        valueInTokens =\r\n            (_valueInWei * 10**IERC20EXT(tokenAddress_).decimals()) /\r\n            1 ether;\r\n    }\r\n\r\n    function _toWei(address _tokenAddress_, uint256 _valueInTokens)\r\n        private\r\n        view\r\n        returns (uint256 valueInWei)\r\n    {\r\n        valueInWei =\r\n            (_valueInTokens * 1 ether) /\r\n            10**IERC20EXT(_tokenAddress_).decimals();\r\n    }\r\n\r\n    function claimCarryForwardBalance(address _userAddress) external onlyOwner {\r\n        uint256 carryForwardBalance = _carryForwardBalance;\r\n        require(\r\n            carryForwardBalance > 0,\r\n            \"claimCarryForwardBalance(): Balance must be above zero.\"\r\n        );\r\n\r\n        (bool sent, ) = payable(_userAddress).call{value: carryForwardBalance}(\r\n            \"\"\r\n        );\r\n        require(sent, \"claimCarryForwardBalance(): ETH Not transfered.\");\r\n        delete _carryForwardBalance;\r\n\r\n        emit ClaimCarryForwardBalance(_userAddress, carryForwardBalance);\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ClaimCarryForwardBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ClaimedStakingReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"ContractPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DistributeStakingReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SelfAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UnStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"claimCarryForwardBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"claimStakingReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeStakingRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractAnalytics\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usersCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakingRewardsDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calStakingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeRewardDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carryForwardBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractDefault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingId\",\"type\":\"uint256\"}],\"name\":\"getStakingById\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingRewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct StructStaking\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingId\",\"type\":\"uint256\"}],\"name\":\"getStakingRewardsById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userStakingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardClaimable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carryForwardBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalValueStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingRewardsClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingStakingRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"stakingIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StructAccount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserStakingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userTotalStakingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardClaimable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carryForwardBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsersParticipatedList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_valueInWei\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DesmeStaking", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001d468e2cf436a0de2720da257b9a8b704d8b7314", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e3bec5f03fefca44bfdb76ac2a4a33beee0dff169fb2bb5d3b55a1d3ce3826d3"}