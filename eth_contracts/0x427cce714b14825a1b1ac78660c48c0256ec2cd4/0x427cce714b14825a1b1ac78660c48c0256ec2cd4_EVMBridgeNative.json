{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/EVMBridgeNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./utils/TransferHelper.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/SignedSafeMath.sol\\\";\\n\\nstruct Transfer {\\n    bytes32 hash;\\n    address from;\\n    address coin;\\n    uint256 quantity;\\n    string  fromChain;\\n    string  toChain;\\n    uint256 feesInToken;\\n    uint256 feesInETH;\\n    uint256 blockTimestamp;\\n    uint256 blockNumber;\\n    string  data;\\n}\\n\\nstruct Bridge {\\n    address addr;\\n    string chain;\\n}\\n\\nstruct Validator {\\n    address addr;\\n    uint256 warrantyAmount;\\n    uint256 totalLossAmount;\\n}\\n\\n/**\\n * @title EVMBridge\\n * @author Jeremy Guyet (@jguyet)\\n * @dev \\n * Smart Contract for manage the transfers between two blockchains\\n * who respect the Ethereum Virtual Machine normal. This Smart contract\\n * contains the list of the chains accepted and list all transactions initialized\\n * with their hash proof from the destination chain. this smart contract is decentralized\\n * but managed by one wallet address (The owner wallet of the Graphlinq project).\\n * This contract is managed by API in Nodejs and we wait 100 block before transfer anything.\\n */\\ncontract EVMBridgeNative {\\n\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    address public owner;\\n    address public program;\\n    string  public chain;\\n\\n    uint256 public feesInDollar;\\n    uint256 public defaultFeesInETH;\\n    uint256 public minimumTransferQuantity;\\n    uint256 public bridgeFeesInNative;\\n\\n    uint256 private blocksLength;\\n    mapping(bytes32 => uint256) private transfersIndexs;\\n    Transfer[] private transfers;\\n    mapping(bytes32 => bytes32) private transfersHashs;\\n\\n    // Private dex information\\n    address private dex_in;\\n    address private dex_out;\\n    address private dex_pool;\\n\\n    bool internal paused;\\n    bool internal locked;\\n\\n    constructor(\\n        string memory _bridgeChain,\\n        uint256 _feesInDollar,\\n        address _dex_in,\\n        address _dex_out,\\n        address _dex_pool) {\\n        require(msg.sender != address(0), \\\"ABORT sender - address(0)\\\");\\n        owner = msg.sender;\\n        program = msg.sender;\\n        chain = _bridgeChain;\\n        feesInDollar = _feesInDollar;\\n        dex_in = _dex_in;\\n        dex_out = _dex_out;\\n        dex_pool = _dex_pool;\\n        minimumTransferQuantity = 1 ether;\\n        defaultFeesInETH = 0;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only the owner can do this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyProgramOrOwner() {\\n        require(msg.sender == program || msg.sender == owner, \\\"Only program or Owner\\\");\\n        _;\\n    }\\n\\n    modifier activated() {\\n        require(paused == false, \\\"Bridge actually paused\\\");\\n        _;\\n    }\\n\\n    modifier noReentrant() {\\n        require(!locked, \\\"No re-entrancy\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    function getFeesInDollar() public view returns (uint256) {\\n        return feesInDollar;\\n    }\\n\\n    function setFeesInDollar(uint256 cost) public onlyOwner {\\n        feesInDollar = cost;\\n    }\\n\\n    function setDefaultFeesInETH(uint256 cost) public onlyOwner {\\n        defaultFeesInETH = cost;\\n    }\\n\\n    function getFeesInETH() public view returns (uint256) {\\n        if (dex_pool != address(0)) {\\n            uint256 oneDollar = getTokenPriceOutFromPoolBalance(dex_in, dex_out, dex_pool);\\n            return oneDollar.mul(1 ether).div(feesInDollar).mul(100); // multiplication 1 ether pour decaler les decimals.\\n        }\\n        return defaultFeesInETH;\\n    }\\n    \\n    function initTransfer(uint256 quantity, string calldata toChain, string calldata data) public payable noReentrant activated {\\n        require(quantity >= minimumTransferQuantity,\\n            \\\"INSUFISANT_QUANTITY\\\"\\n        );\\n        require(msg.value >= getFeesInETH().mul(90).div(100).add(quantity),\\n            \\\"PAYMENT_ABORT\\\" // 90% of the fees minimum\\n        );\\n        uint256 transferQuantity = quantity;\\n        uint256 transferETHFees = msg.value;\\n\\n        bridgeFeesInNative += msg.value.sub(transferQuantity);\\n        uint256 index = transfers.length;\\n        bytes32 transferHash = _getHash(block.timestamp, 0, msg.sender);\\n\\n        transfers.push(Transfer(\\n            transferHash,\\n            msg.sender,\\n            address(0),\\n            transferQuantity,\\n            chain,\\n            toChain,\\n            bridgeFeesInNative,\\n            transferETHFees,\\n            block.timestamp,\\n            block.number,\\n            data\\n        ));\\n        transfersIndexs[transferHash] = index;\\n        transfersHashs[transferHash] = transferHash;\\n    }\\n\\n    function transferExists(bytes32 transferHash) public view returns (bool) {\\n        return transfersHashs[transferHash] == transferHash;\\n    }\\n\\n    function getTransfer(bytes32 transferHash) public view returns (Transfer memory) {\\n        return transfers[transfersIndexs[transferHash]];\\n    }\\n\\n    function getTransferLength() public view returns (uint256) {\\n        return transfers.length;\\n    }\\n\\n    function getTransfers(int256 page, int256 pageSize) external view returns (Transfer[] memory) {\\n        uint256 poolLength = transfers.length;\\n        int256 queryStartPoolIndex = int256(poolLength).sub(pageSize.mul(page.add(1))).add(pageSize);\\n        require(queryStartPoolIndex >= 0, \\\"Out of bounds\\\");\\n        int256 queryEndPoolIndex = queryStartPoolIndex.sub(pageSize);\\n        if (queryEndPoolIndex < 0) {\\n            queryEndPoolIndex = 0;\\n        }\\n        int256 currentPoolIndex = queryStartPoolIndex;\\n        require(uint256(currentPoolIndex) <= poolLength, \\\"Out of bounds\\\");\\n        Transfer[] memory results = new Transfer[](uint256(currentPoolIndex - queryEndPoolIndex));\\n        uint256 index = 0;\\n\\n        for (currentPoolIndex; currentPoolIndex > queryEndPoolIndex; currentPoolIndex--) {\\n            Transfer memory transfer = transfers[uint256(currentPoolIndex).sub(1)];\\n            results[index] = transfer;\\n            index++;\\n        }\\n        return results;\\n    }\\n\\n    function collectTokenFees() public onlyOwner {\\n        require(bridgeFeesInNative <= balance(), \\\"Insufficient balance\\\");\\n        (bool success,)=owner.call{value:bridgeFeesInNative}(\\\"\\\");\\n        require(success, \\\"Transfer failed!\\\");\\n        bridgeFeesInNative = 0;\\n    }\\n\\n    function balance() public view returns (uint256){\\n        return payable(address(this)).balance;\\n    }\\n\\n    function depositETH(uint256 quantity) public payable onlyOwner noReentrant {\\n        require(msg.value >= quantity,\\n            \\\"PAYMENT_ABORT\\\"\\n        );\\n    }\\n\\n    function withdrawETH(uint quantity) public onlyOwner noReentrant {\\n        require(quantity <= balance(), \\\"Insufficient balance\\\");\\n        (bool success,)=owner.call{value:quantity}(\\\"\\\");\\n        require(success, \\\"Transfer failed!\\\");\\n    }\\n\\n    function withdraw(address coin, uint256 quantity) public onlyOwner noReentrant {\\n        require(IERC20(coin).balanceOf(address(this)) >= quantity, \\\"INSUFISANT_BALANCE\\\");\\n        TransferHelper.safeTransfer(coin, msg.sender, quantity);\\n    }\\n\\n    function getLastsTransfers(uint256 size) external view returns (Transfer[] memory) {\\n        uint256 poolLength = transfers.length;\\n        uint256 start = 0;\\n        uint256 memorySize = size;\\n\\n        if (transfers.length > size) {\\n            start = transfers.length.sub(size);\\n        } else {\\n            memorySize = transfers.length;\\n        }\\n        uint256 currentIndex = start;\\n        Transfer[] memory results = new Transfer[](memorySize);\\n        uint256 memoryIndex = 0;\\n\\n        for (currentIndex; currentIndex < poolLength; currentIndex++) {\\n            Transfer memory transfer = transfers[currentIndex];\\n            results[memoryIndex++] = transfer;\\n        }\\n        return results;\\n    }\\n\\n    function addTransfersFrom(string[] memory /* fromChains */, address[] memory transfersAddresses, uint256[] memory amounts, bytes32[] memory _transfersHashs) public onlyProgramOrOwner {\\n        for (uint256 i = 0; i < transfersAddresses.length; i++) {\\n            address transferAddress = transfersAddresses[i];\\n            uint256 amount = amounts[i];\\n            bytes32 transferHash = _transfersHashs[i];\\n\\n            require(transfersHashs[transferHash] == 0, \\\"Already transfered\\\");\\n            require(amount <= balance(), \\\"Insufficient balance\\\");\\n            (bool success,)=transferAddress.call{value:amount}(\\\"\\\");\\n            require(success, \\\"Transfer failed!\\\");\\n            transfersHashs[transferHash] = transferHash;\\n        }\\n    }\\n\\n    function getDex() public view returns (address, address, address) {\\n        return (dex_in, dex_out, dex_pool);\\n    }\\n\\n    /**\\n     * Only 18 decimals tokens.\\n     */\\n    function setDex(address _in, address _out, address _pool) public onlyOwner {\\n        dex_in = _in;\\n        dex_out = _out;\\n        dex_pool = _pool;\\n    }\\n\\n    function getTokenPriceOutFromPoolBalance(address _in, address _out, address _pool) public view returns (uint256) {\\n        uint256 balanceIn = IERC20(_in).balanceOf(_pool);\\n        uint256 balanceOut = IERC20(_out).balanceOf(_pool);\\n        require(balanceOut > 0);\\n        return balanceIn.mul(1 ether).div(balanceOut);\\n        // ex: in=USDC,out=ETH = price of ETH in USDC\\n        // ex: in=ETH,out=USDC = price of USDC in ETH\\n    }\\n\\n    function updateTransferCost(uint256 _feesInDollar) public onlyOwner {\\n        feesInDollar = _feesInDollar;\\n    }\\n\\n    function isPaused() public view returns (bool) {\\n        return paused;\\n    }\\n\\n    function setPaused(bool p) public onlyOwner {\\n        paused = p;\\n    }\\n\\n    function setMinimumTransferQuantity(uint256 quantity) public onlyOwner {\\n        minimumTransferQuantity = quantity;\\n    }\\n\\n    function changeOwner(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"No zero address\\\");\\n        owner = newOwner;\\n    }\\n\\n    function changeProgram(address newProgram) public onlyOwner {\\n        require(newProgram != address(0), \\\"No zero address\\\");\\n        program = newProgram;\\n    }\\n\\n    function _getHash(uint256 timestamp, uint256 nonce, address addr) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(timestamp, addr, nonce));\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/libs/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\npragma solidity ^0.8.0;\\n\\nlibrary SignedSafeMath {\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_bridgeChain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_feesInDollar\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dex_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dex_out\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dex_pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"transfersAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_transfersHashs\",\"type\":\"bytes32[]\"}],\"name\":\"addTransfersFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeFeesInNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newProgram\",\"type\":\"address\"}],\"name\":\"changeProgram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeesInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesInDollar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeesInDollar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeesInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getLastsTransfers\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"fromChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"toChain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"feesInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct Transfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_out\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getTokenPriceOutFromPoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transferHash\",\"type\":\"bytes32\"}],\"name\":\"getTransfer\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"fromChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"toChain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"feesInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct Transfer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransferLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"page\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"pageSize\",\"type\":\"int256\"}],\"name\":\"getTransfers\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"fromChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"toChain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"feesInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct Transfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"toChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"initTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTransferQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"program\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"setDefaultFeesInETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_out\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"setDex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"setFeesInDollar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"setMinimumTransferQuantity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"p\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transferHash\",\"type\":\"bytes32\"}],\"name\":\"transferExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feesInDollar\",\"type\":\"uint256\"}],\"name\":\"updateTransferCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EVMBridgeNative", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a478c2975ab1ea89e8196811f51a7b7ade33eb1100000000000000000000000000000000000000000000000000000000000000034554480000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}