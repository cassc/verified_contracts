{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/ccip/onRamp/EVM2EVMOnRamp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nimport {TypeAndVersionInterface} from \\\"../../interfaces/TypeAndVersionInterface.sol\\\";\\nimport {IPool} from \\\"../interfaces/pools/IPool.sol\\\";\\nimport {IARM} from \\\"../interfaces/IARM.sol\\\";\\nimport {IPriceRegistry} from \\\"../interfaces/IPriceRegistry.sol\\\";\\nimport {IEVM2AnyOnRamp} from \\\"../interfaces/IEVM2AnyOnRamp.sol\\\";\\nimport {ILinkAvailable} from \\\"../interfaces/automation/ILinkAvailable.sol\\\";\\n\\nimport {AggregateRateLimiter} from \\\"../AggregateRateLimiter.sol\\\";\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\nimport {RateLimiter} from \\\"../libraries/RateLimiter.sol\\\";\\nimport {USDPriceWith18Decimals} from \\\"../libraries/USDPriceWith18Decimals.sol\\\";\\nimport {EnumerableMapAddresses} from \\\"../../shared/enumerable/EnumerableMapAddresses.sol\\\";\\n\\nimport {SafeERC20} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\\\";\\nimport {EnumerableSet} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/utils/structs/EnumerableSet.sol\\\";\\nimport {EnumerableMap} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/utils/structs/EnumerableMap.sol\\\";\\n\\n/// @notice The onRamp is a contract that handles fee logic, NOP payments,\\n/// token support and an allowList. It will always be deployed 1:1:1 with a\\n/// commitStore and offRamp contract. These three contracts together form a\\n/// `lane`. A lane is an upgradable set of contracts within the non-upgradable\\n/// routers and are always deployed as complete set, even during upgrades.\\n/// This means an upgrade to an onRamp will require redeployment of the\\n/// commitStore and offRamp as well.\\ncontract EVM2EVMOnRamp is IEVM2AnyOnRamp, ILinkAvailable, AggregateRateLimiter, TypeAndVersionInterface {\\n  using SafeERC20 for IERC20;\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using EnumerableMapAddresses for EnumerableMapAddresses.AddressToAddressMap;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using USDPriceWith18Decimals for uint192;\\n\\n  error InvalidExtraArgsTag();\\n  error OnlyCallableByOwnerOrAdmin();\\n  error OnlyCallableByOwnerOrAdminOrNop();\\n  error InvalidWithdrawParams();\\n  error NoFeesToPay();\\n  error NoNopsToPay();\\n  error InsufficientBalance();\\n  error TooManyNops();\\n  error MaxFeeBalanceReached();\\n  error MessageTooLarge(uint256 maxSize, uint256 actualSize);\\n  error MessageGasLimitTooHigh();\\n  error UnsupportedNumberOfTokens();\\n  error UnsupportedToken(IERC20 token);\\n  error MustBeCalledByRouter();\\n  error RouterMustSetOriginalSender();\\n  error InvalidTokenPoolConfig();\\n  error PoolAlreadyAdded();\\n  error PoolDoesNotExist(address token);\\n  error TokenPoolMismatch();\\n  error SenderNotAllowed(address sender);\\n  error InvalidConfig();\\n  error InvalidAddress(bytes encodedAddress);\\n  error BadARMSignal();\\n  error LinkBalanceNotSettled();\\n  error InvalidNopAddress(address nop);\\n  error NotAFeeToken(address token);\\n\\n  event AllowListAdd(address sender);\\n  event AllowListRemove(address sender);\\n  event AllowListEnabledSet(bool enabled);\\n  event ConfigSet(StaticConfig staticConfig, DynamicConfig dynamicConfig);\\n  event NopPaid(address indexed nop, uint256 amount);\\n  event FeeConfigSet(FeeTokenConfigArgs[] feeConfig);\\n  event TokenTransferFeeConfigSet(TokenTransferFeeConfigArgs[] transferFeeConfig);\\n  event CCIPSendRequested(Internal.EVM2EVMMessage message);\\n  event NopsSet(uint256 nopWeightsTotal, NopAndWeight[] nopsAndWeights);\\n  event PoolAdded(address token, address pool);\\n  event PoolRemoved(address token, address pool);\\n\\n  /// @dev Struct that contains the static configuration\\n  struct StaticConfig {\\n    address linkToken; // --------\u2510 Link token address\\n    uint64 chainSelector; // -----\u2518 Source chainSelector\\n    uint64 destChainSelector; // -\u2510 Destination chainSelector\\n    uint64 defaultTxGasLimit; //  | Default gas limit for a tx\\n    uint96 maxNopFeesJuels; // ---\u2518 Max nop fee balance onramp can have\\n    address prevOnRamp; // -------  Address of previous-version OnRamp\\n    address armProxy; // ---------- Address of ARM proxy\\n  }\\n\\n  /// @dev Struct to contains the dynamic configuration\\n  struct DynamicConfig {\\n    address router; // -------- \u2510  Router address\\n    uint16 maxTokensLength; //  \u2518  Maximum number of distinct ERC20 tokens that can be sent per message\\n    address priceRegistry; // --\u2510 Price registry address\\n    uint32 maxDataSize; //      | Maximum payload data size\\n    uint64 maxGasLimit; // -----\u2518 Maximum gas limit for messages targeting EVMs\\n  }\\n\\n  /// @dev Struct to hold the execution fee configuration for a fee token\\n  struct FeeTokenConfig {\\n    uint96 networkFeeAmountUSD; // --\u2510 Flat network fee in 1e18 USD\\n    uint64 gasMultiplier; //         | Price multiplier for gas costs, 1e18 based so 11e17 = 10% extra cost.\\n    uint32 destGasOverhead; //       | Extra gas charged on top of the gasLimit\\n    uint16 destGasPerPayloadByte; // | Destination chain gas charged per byte of `data` payload\\n    bool enabled; // ----------------\u2518 Whether this fee token is enabled\\n  }\\n\\n  /// @dev Struct to hold the fee configuration for a fee token, same as the FeeTokenConfig but with\\n  /// token included so that an array of these can be passed in to setFeeTokenConfig to set the mapping\\n  struct FeeTokenConfigArgs {\\n    address token; // ---------------\u2510 Token address\\n    uint64 gasMultiplier; // --------\u2518 Price multiplier for gas costs, 1e18 based so 11e17 = 10% extra cost.\\n    uint96 networkFeeAmountUSD; // --\u2510 Flat network fee in 1e18 USD\\n    uint32 destGasOverhead; //       | Extra gas charged on top of the gasLimit\\n    uint16 destGasPerPayloadByte; // | Destination chain gas charged per byte of `data` payload\\n    bool enabled; // ----------------\u2518 Whether this fee token is enabled\\n  }\\n\\n  /// @dev Struct to hold the transfer fee configuration for token transfers\\n  struct TokenTransferFeeConfig {\\n    uint32 minFee; // ---\u2510 Minimum USD fee to charge, multiples of 1 US cent, or 0.01USD\\n    uint32 maxFee; //    | Maximum USD fee to charge, multiples of 1 US cent, or 0.01USD\\n    uint16 ratio; // ----\u2518 Ratio of token transfer value to charge as fee, multiples of 0.1bps, or 10e-5\\n  }\\n\\n  /// @dev Same as TokenTransferFeeConfig\\n  /// token included so that an array of these can be passed in to setTokenTransferFeeConfig\\n  struct TokenTransferFeeConfigArgs {\\n    address token; // ---\u2510 Token address\\n    uint32 minFee; //    | Minimum USD fee to charge, multiples of 1 US cent, or 0.01USD\\n    uint32 maxFee; //    | Maximum USD fee to charge, multiples of 1 US cent, or 0.01USD\\n    uint16 ratio; // ----\u2518 Ratio of token transfer value to charge as fee, multiples of 0.1bps, or 10e-5\\n  }\\n\\n  /// @dev Nop address and weight, used to set the nops and their weights\\n  struct NopAndWeight {\\n    address nop; // -----\u2510 Address of the node operator\\n    uint16 weight; // ---\u2518 Weight for nop rewards\\n  }\\n\\n  // STATIC CONFIG\\n  // solhint-disable-next-line chainlink-solidity/all-caps-constant-storage-variables\\n  string public constant override typeAndVersion = \\\"EVM2EVMOnRamp 1.0.0\\\";\\n  /// @dev The metadata hash for this contract\\n  bytes32 internal immutable i_metadataHash;\\n  /// @dev Default gas limit for a transactions that did not specify\\n  /// a gas limit in the extraArgs.\\n  uint64 internal immutable i_defaultTxGasLimit;\\n  /// @dev Maximum nop fee that can accumulate in this onramp\\n  uint96 internal immutable i_maxNopFeesJuels;\\n  /// @dev The link token address - known to pay nops for their work\\n  address internal immutable i_linkToken;\\n  /// @dev The chain ID of the source chain that this contract is deployed to\\n  uint64 internal immutable i_chainSelector;\\n  /// @dev The chain ID of the destination chain\\n  uint64 internal immutable i_destChainSelector;\\n  /// @dev The address of previous-version OnRamp for this lane\\n  address internal immutable i_prevOnRamp;\\n  /// @dev The address of the arm proxy\\n  address internal immutable i_armProxy;\\n  /// @dev the maximum number of nops that can be configured at the same time.\\n  uint256 private constant MAX_NUMBER_OF_NOPS = 64;\\n\\n  // DYNAMIC CONFIG\\n  /// @dev The config for the onRamp\\n  DynamicConfig internal s_dynamicConfig;\\n  /// @dev (address nop => uint256 weight)\\n  EnumerableMap.AddressToUintMap internal s_nops;\\n  /// @dev source token => token pool\\n  EnumerableMapAddresses.AddressToAddressMap private s_poolsBySourceToken;\\n\\n  /// @dev A set of addresses which can make ccipSend calls.\\n  EnumerableSet.AddressSet private s_allowList;\\n  /// @dev The execution fee token config that can be set by the owner or fee admin\\n  mapping(address token => FeeTokenConfig feeTokenConfig) internal s_feeTokenConfig;\\n  /// @dev The token transfer fee config that can be set by the owner or fee admin\\n  mapping(address token => TokenTransferFeeConfig tranferFeeConfig) internal s_tokenTransferFeeConfig;\\n\\n  // STATE\\n  /// @dev The current nonce per sender\\n  mapping(address sender => uint64 nonce) internal s_senderNonce;\\n  /// @dev The amount of LINK available to pay NOPS\\n  uint96 internal s_nopFeesJuels;\\n  /// @dev The combined weight of all NOPs weights\\n  uint32 internal s_nopWeightsTotal;\\n  /// @dev The last used sequence number. This is zero in the case where no\\n  /// messages has been sent yet. 0 is not a valid sequence number for any\\n  /// real transaction.\\n  uint64 internal s_sequenceNumber;\\n  /// @dev Whether this OnRamp is paused or not\\n  bool private s_paused = false;\\n  /// @dev This allowListing will be removed before public launch\\n  /// @dev Whether s_allowList is enabled or not.\\n  bool private s_allowlistEnabled;\\n\\n  constructor(\\n    StaticConfig memory staticConfig,\\n    DynamicConfig memory dynamicConfig,\\n    Internal.PoolUpdate[] memory tokensAndPools,\\n    address[] memory allowlist,\\n    RateLimiter.Config memory rateLimiterConfig,\\n    FeeTokenConfigArgs[] memory feeTokenConfigs,\\n    TokenTransferFeeConfigArgs[] memory tokenTransferFeeConfigArgs,\\n    NopAndWeight[] memory nopsAndWeights\\n  ) AggregateRateLimiter(rateLimiterConfig) {\\n    if (\\n      staticConfig.linkToken == address(0) ||\\n      staticConfig.chainSelector == 0 ||\\n      staticConfig.destChainSelector == 0 ||\\n      staticConfig.defaultTxGasLimit == 0 ||\\n      staticConfig.armProxy == address(0)\\n    ) revert InvalidConfig();\\n\\n    i_metadataHash = keccak256(\\n      abi.encode(\\n        Internal.EVM_2_EVM_MESSAGE_HASH,\\n        staticConfig.chainSelector,\\n        staticConfig.destChainSelector,\\n        address(this)\\n      )\\n    );\\n    i_linkToken = staticConfig.linkToken;\\n    i_chainSelector = staticConfig.chainSelector;\\n    i_destChainSelector = staticConfig.destChainSelector;\\n    i_defaultTxGasLimit = staticConfig.defaultTxGasLimit;\\n    i_maxNopFeesJuels = staticConfig.maxNopFeesJuels;\\n    i_prevOnRamp = staticConfig.prevOnRamp;\\n    i_armProxy = staticConfig.armProxy;\\n\\n    _setDynamicConfig(dynamicConfig);\\n    _setFeeTokenConfig(feeTokenConfigs);\\n    _setTokenTransferFeeConfig(tokenTransferFeeConfigArgs);\\n    _setNops(nopsAndWeights);\\n\\n    // Set new tokens and pools\\n    _applyPoolUpdates(new Internal.PoolUpdate[](0), tokensAndPools);\\n\\n    if (allowlist.length > 0) {\\n      s_allowlistEnabled = true;\\n      _applyAllowListUpdates(new address[](0), allowlist);\\n    }\\n  }\\n\\n  // ================================================================\\n  // |                          Messaging                           |\\n  // ================================================================\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  function getExpectedNextSequenceNumber() external view returns (uint64) {\\n    return s_sequenceNumber + 1;\\n  }\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  function getSenderNonce(address sender) external view returns (uint64) {\\n    uint256 senderNonce = s_senderNonce[sender];\\n\\n    if (senderNonce == 0 && i_prevOnRamp != address(0)) {\\n      // If OnRamp was upgraded, check if sender has a nonce from the previous OnRamp.\\n      return IEVM2AnyOnRamp(i_prevOnRamp).getSenderNonce(sender);\\n    }\\n    return uint64(senderNonce);\\n  }\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  function forwardFromRouter(\\n    Client.EVM2AnyMessage calldata message,\\n    uint256 feeTokenAmount,\\n    address originalSender\\n  ) external whenHealthy returns (bytes32) {\\n    // EVM destination addresses should be abi encoded and therefore always 32 bytes long\\n    if (message.receiver.length != 32) revert InvalidAddress(message.receiver);\\n    uint256 decodedReceiver = abi.decode(message.receiver, (uint256));\\n    // We want to disallow sending to address(0) and to precompiles, which exist on address(1) through address(9).\\n    if (decodedReceiver > type(uint160).max || decodedReceiver < 10) revert InvalidAddress(message.receiver);\\n\\n    Client.EVMExtraArgsV1 memory extraArgs = _fromBytes(message.extraArgs);\\n    // Validate the message with various checks\\n    _validateMessage(message.data.length, extraArgs.gasLimit, message.tokenAmounts.length, originalSender);\\n    // Rate limit on aggregated token value\\n    _rateLimitValue(message.tokenAmounts, IPriceRegistry(s_dynamicConfig.priceRegistry));\\n\\n    // Convert feeToken to link if not already in link\\n    if (message.feeToken == i_linkToken) {\\n      // Since there is only 1b link this is safe\\n      s_nopFeesJuels += uint96(feeTokenAmount);\\n    } else {\\n      // the cast from uint256 to uint96 is considered safe, uint96 can store more than max supply of link token\\n      s_nopFeesJuels += uint96(\\n        IPriceRegistry(s_dynamicConfig.priceRegistry).convertTokenAmount(message.feeToken, feeTokenAmount, i_linkToken)\\n      );\\n    }\\n    if (s_nopFeesJuels > i_maxNopFeesJuels) revert MaxFeeBalanceReached();\\n\\n    if (s_senderNonce[originalSender] == 0 && i_prevOnRamp != address(0)) {\\n      // If this is first time send for a sender in new OnRamp, check if they have a nonce\\n      // from the previous OnRamp and start from there instead of zero.\\n      s_senderNonce[originalSender] = IEVM2AnyOnRamp(i_prevOnRamp).getSenderNonce(originalSender);\\n    }\\n\\n    // We need the next available sequence number so we increment before we use the value\\n    Internal.EVM2EVMMessage memory newMessage = Internal.EVM2EVMMessage({\\n      sourceChainSelector: i_chainSelector,\\n      sequenceNumber: ++s_sequenceNumber,\\n      feeTokenAmount: feeTokenAmount,\\n      sender: originalSender,\\n      nonce: ++s_senderNonce[originalSender],\\n      gasLimit: extraArgs.gasLimit,\\n      strict: extraArgs.strict,\\n      receiver: address(uint160(decodedReceiver)),\\n      data: message.data,\\n      tokenAmounts: message.tokenAmounts,\\n      feeToken: message.feeToken,\\n      messageId: \\\"\\\"\\n    });\\n    newMessage.messageId = Internal._hash(newMessage, i_metadataHash);\\n\\n    // Lock the tokens as last step. TokenPools may not always be trusted.\\n    // There should be no state changes after external call to TokenPools.\\n    for (uint256 i = 0; i < message.tokenAmounts.length; ++i) {\\n      Client.EVMTokenAmount memory tokenAndAmount = message.tokenAmounts[i];\\n      getPoolBySourceToken(IERC20(tokenAndAmount.token)).lockOrBurn(\\n        originalSender,\\n        message.receiver,\\n        tokenAndAmount.amount,\\n        i_destChainSelector,\\n        bytes(\\\"\\\") // any future extraArgs component would be added here\\n      );\\n    }\\n\\n    // Emit message request\\n    emit CCIPSendRequested(newMessage);\\n    return newMessage.messageId;\\n  }\\n\\n  /// @dev Convert the extra args bytes into a struct\\n  /// @param extraArgs The extra args bytes\\n  /// @return The extra args struct\\n  function _fromBytes(bytes calldata extraArgs) internal view returns (Client.EVMExtraArgsV1 memory) {\\n    if (extraArgs.length == 0) {\\n      return Client.EVMExtraArgsV1({gasLimit: i_defaultTxGasLimit, strict: false});\\n    }\\n    if (bytes4(extraArgs) != Client.EVM_EXTRA_ARGS_V1_TAG) revert InvalidExtraArgsTag();\\n    return abi.decode(extraArgs[4:], (Client.EVMExtraArgsV1));\\n  }\\n\\n  /// @notice Validate the forwarded message with various checks.\\n  /// @param dataLength The length of the data field of the message\\n  /// @param gasLimit The gasLimit set in message for destination execution\\n  /// @param numberOfTokens The number of tokens to be sent.\\n  /// @param originalSender The original sender of the message on the router.\\n  function _validateMessage(\\n    uint256 dataLength,\\n    uint256 gasLimit,\\n    uint256 numberOfTokens,\\n    address originalSender\\n  ) internal view {\\n    if (originalSender == address(0)) revert RouterMustSetOriginalSender();\\n    // Router address may be zero intentionally to pause.\\n    if (msg.sender != s_dynamicConfig.router) revert MustBeCalledByRouter();\\n    // Check that payload is formed correctly\\n    uint256 maxDataSize = uint256(s_dynamicConfig.maxDataSize);\\n    if (dataLength > maxDataSize) revert MessageTooLarge(maxDataSize, dataLength);\\n    if (gasLimit > uint256(s_dynamicConfig.maxGasLimit)) revert MessageGasLimitTooHigh();\\n    if (numberOfTokens > uint256(s_dynamicConfig.maxTokensLength)) revert UnsupportedNumberOfTokens();\\n    if (s_allowlistEnabled && !s_allowList.contains(originalSender)) revert SenderNotAllowed(originalSender);\\n  }\\n\\n  // ================================================================\\n  // |                           Config                             |\\n  // ================================================================\\n\\n  /// @notice Returns the static onRamp config.\\n  /// @return the configuration.\\n  function getStaticConfig() external view returns (StaticConfig memory) {\\n    return\\n      StaticConfig({\\n        linkToken: i_linkToken,\\n        chainSelector: i_chainSelector,\\n        destChainSelector: i_destChainSelector,\\n        defaultTxGasLimit: i_defaultTxGasLimit,\\n        maxNopFeesJuels: i_maxNopFeesJuels,\\n        prevOnRamp: i_prevOnRamp,\\n        armProxy: i_armProxy\\n      });\\n  }\\n\\n  /// @notice Returns the dynamic onRamp config.\\n  /// @return dynamicConfig the configuration.\\n  function getDynamicConfig() external view returns (DynamicConfig memory dynamicConfig) {\\n    return s_dynamicConfig;\\n  }\\n\\n  /// @notice Sets the dynamic configuration.\\n  /// @param dynamicConfig The configuration.\\n  function setDynamicConfig(DynamicConfig memory dynamicConfig) external onlyOwner {\\n    _setDynamicConfig(dynamicConfig);\\n  }\\n\\n  /// @notice Internal version of setDynamicConfig to allow for reuse in the constructor.\\n  function _setDynamicConfig(DynamicConfig memory dynamicConfig) internal {\\n    // We permit router to be set to zero as a way to pause the contract.\\n    if (dynamicConfig.priceRegistry == address(0)) revert InvalidConfig();\\n\\n    s_dynamicConfig = dynamicConfig;\\n\\n    emit ConfigSet(\\n      StaticConfig({\\n        linkToken: i_linkToken,\\n        chainSelector: i_chainSelector,\\n        destChainSelector: i_destChainSelector,\\n        defaultTxGasLimit: i_defaultTxGasLimit,\\n        maxNopFeesJuels: i_maxNopFeesJuels,\\n        prevOnRamp: i_prevOnRamp,\\n        armProxy: i_armProxy\\n      }),\\n      dynamicConfig\\n    );\\n  }\\n\\n  // ================================================================\\n  // |                      Tokens and pools                        |\\n  // ================================================================\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  function getSupportedTokens() external view returns (address[] memory) {\\n    address[] memory sourceTokens = new address[](s_poolsBySourceToken.length());\\n    for (uint256 i = 0; i < sourceTokens.length; ++i) {\\n      (sourceTokens[i], ) = s_poolsBySourceToken.at(i);\\n    }\\n    return sourceTokens;\\n  }\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  function getPoolBySourceToken(IERC20 sourceToken) public view returns (IPool) {\\n    if (!s_poolsBySourceToken.contains(address(sourceToken))) revert UnsupportedToken(sourceToken);\\n    return IPool(s_poolsBySourceToken.get(address(sourceToken)));\\n  }\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  /// @dev This method can only be called by the owner of the contract.\\n  function applyPoolUpdates(\\n    Internal.PoolUpdate[] memory removes,\\n    Internal.PoolUpdate[] memory adds\\n  ) external onlyOwner {\\n    _applyPoolUpdates(removes, adds);\\n  }\\n\\n  function _applyPoolUpdates(Internal.PoolUpdate[] memory removes, Internal.PoolUpdate[] memory adds) internal {\\n    for (uint256 i = 0; i < removes.length; ++i) {\\n      address token = removes[i].token;\\n      address pool = removes[i].pool;\\n\\n      if (!s_poolsBySourceToken.contains(token)) revert PoolDoesNotExist(token);\\n      if (s_poolsBySourceToken.get(token) != pool) revert TokenPoolMismatch();\\n\\n      if (s_poolsBySourceToken.remove(token)) {\\n        emit PoolRemoved(token, pool);\\n      }\\n    }\\n\\n    for (uint256 i = 0; i < adds.length; ++i) {\\n      address token = adds[i].token;\\n      address pool = adds[i].pool;\\n\\n      if (token == address(0) || pool == address(0)) revert InvalidTokenPoolConfig();\\n      if (token != address(IPool(pool).getToken())) revert TokenPoolMismatch();\\n\\n      if (s_poolsBySourceToken.set(token, pool)) {\\n        emit PoolAdded(token, pool);\\n      } else {\\n        revert PoolAlreadyAdded();\\n      }\\n    }\\n  }\\n\\n  // ================================================================\\n  // |                             Fees                             |\\n  // ================================================================\\n\\n  /// @inheritdoc IEVM2AnyOnRamp\\n  function getFee(Client.EVM2AnyMessage calldata message) external view returns (uint256) {\\n    FeeTokenConfig memory feeTokenConfig = s_feeTokenConfig[message.feeToken];\\n    if (!feeTokenConfig.enabled) revert NotAFeeToken(message.feeToken);\\n\\n    (uint192 feeTokenPrice, uint192 gasPrice) = IPriceRegistry(s_dynamicConfig.priceRegistry).getTokenAndGasPrices(\\n      message.feeToken,\\n      i_destChainSelector\\n    );\\n\\n    // Total tx fee in USD with 18 decimals precision, excluding token bps\\n    // We add the message gas limit, the overhead gas and the calldata gas together.\\n    // We then multiple this destination chain gas total with the gas multiplier and\\n    // convert it into USD.\\n    uint256 executionFeeUsdValue = (gasPrice *\\n      ((_fromBytes(message.extraArgs).gasLimit +\\n        feeTokenConfig.destGasOverhead +\\n        message.data.length *\\n        feeTokenConfig.destGasPerPayloadByte) * feeTokenConfig.gasMultiplier)) /\\n      1 ether +\\n      feeTokenConfig.networkFeeAmountUSD;\\n\\n    // Transform the execution fee into fee token amount and add the token bps fee\\n    // which is already priced in fee token\\n    return\\n      feeTokenPrice._calcTokenAmountFromUSDValue(executionFeeUsdValue) +\\n      _getTokenTransferFee(message.feeToken, feeTokenPrice, message.tokenAmounts);\\n  }\\n\\n  /// @notice Returns the fee based on the tokens transferred. Will always be 0 if\\n  /// no tokens are transferred. The token fee is calculated based on basis points.\\n  function _getTokenTransferFee(\\n    address feeToken,\\n    uint192 feeTokenPrice,\\n    Client.EVMTokenAmount[] calldata tokenAmounts\\n  ) internal view returns (uint256 feeTokenAmount) {\\n    uint256 numberOfTokens = tokenAmounts.length;\\n    // short-circuit with 0 transfer fee if no token is being transferred\\n    if (numberOfTokens == 0) {\\n      return 0;\\n    }\\n\\n    for (uint256 i = 0; i < numberOfTokens; ++i) {\\n      Client.EVMTokenAmount memory tokenAmount = tokenAmounts[i];\\n      TokenTransferFeeConfig memory transferFeeConfig = s_tokenTransferFeeConfig[tokenAmount.token];\\n\\n      uint256 feeValue = 0;\\n      // ratio can be 0, only calculate bps fee if ratio is greater than 0\\n      if (transferFeeConfig.ratio > 0) {\\n        uint192 tokenPrice = feeTokenPrice;\\n        if (tokenAmount.token != feeToken) {\\n          tokenPrice = IPriceRegistry(s_dynamicConfig.priceRegistry).getValidatedTokenPrice(tokenAmount.token);\\n        }\\n\\n        // calculate token transfer value, then apply fee ratio\\n        // ratio represents multiples of 0.1bps, or 10e-5\\n        feeValue = (tokenPrice._calcUSDValueFromTokenAmount(tokenAmount.amount) * transferFeeConfig.ratio) / 1e5;\\n      }\\n\\n      // convert USD values with 2 decimals to 18 decimals\\n      uint256 minFeeValue = uint256(transferFeeConfig.minFee) * 1e16;\\n      uint256 maxFeeValue = uint256(transferFeeConfig.maxFee) * 1e16;\\n\\n      if (feeValue < minFeeValue) {\\n        feeValue = minFeeValue;\\n      } else if (feeValue > maxFeeValue) {\\n        feeValue = maxFeeValue;\\n      }\\n\\n      feeTokenAmount += feeTokenPrice._calcTokenAmountFromUSDValue(feeValue);\\n    }\\n\\n    return feeTokenAmount;\\n  }\\n\\n  /// @notice Gets the fee configuration for a token\\n  /// @param token The token to get the fee configuration for\\n  /// @return feeTokenConfig FeeTokenConfig struct\\n  function getFeeTokenConfig(address token) external view returns (FeeTokenConfig memory feeTokenConfig) {\\n    return s_feeTokenConfig[token];\\n  }\\n\\n  /// @notice Sets the fee configuration for a token\\n  /// @param feeTokenConfigArgs Array of FeeTokenConfigArgs structs.\\n  function setFeeTokenConfig(FeeTokenConfigArgs[] memory feeTokenConfigArgs) external onlyOwnerOrAdmin {\\n    _setFeeTokenConfig(feeTokenConfigArgs);\\n  }\\n\\n  /// @dev Set the fee config\\n  /// @param feeTokenConfigArgs The fee token configs.\\n  function _setFeeTokenConfig(FeeTokenConfigArgs[] memory feeTokenConfigArgs) internal {\\n    for (uint256 i = 0; i < feeTokenConfigArgs.length; ++i) {\\n      FeeTokenConfigArgs memory configArg = feeTokenConfigArgs[i];\\n\\n      s_feeTokenConfig[configArg.token] = FeeTokenConfig({\\n        networkFeeAmountUSD: configArg.networkFeeAmountUSD,\\n        gasMultiplier: configArg.gasMultiplier,\\n        destGasOverhead: configArg.destGasOverhead,\\n        destGasPerPayloadByte: configArg.destGasPerPayloadByte,\\n        enabled: configArg.enabled\\n      });\\n    }\\n    emit FeeConfigSet(feeTokenConfigArgs);\\n  }\\n\\n  /// @notice Gets the transfer fee config for a given token.\\n  function getTokenTransferFeeConfig(\\n    address token\\n  ) external view returns (TokenTransferFeeConfig memory tokenTransferFeeConfig) {\\n    return s_tokenTransferFeeConfig[token];\\n  }\\n\\n  /// @notice Sets the transfer fee config.\\n  /// @dev only callable by the owner or admin.\\n  function setTokenTransferFeeConfig(\\n    TokenTransferFeeConfigArgs[] memory tokenTransferFeeConfigArgs\\n  ) external onlyOwnerOrAdmin {\\n    _setTokenTransferFeeConfig(tokenTransferFeeConfigArgs);\\n  }\\n\\n  /// @notice internal helper to set the token transfer fee config.\\n  function _setTokenTransferFeeConfig(TokenTransferFeeConfigArgs[] memory tokenTransferFeeConfigArgs) internal {\\n    for (uint256 i = 0; i < tokenTransferFeeConfigArgs.length; ++i) {\\n      TokenTransferFeeConfigArgs memory configArg = tokenTransferFeeConfigArgs[i];\\n\\n      s_tokenTransferFeeConfig[configArg.token] = TokenTransferFeeConfig({\\n        minFee: configArg.minFee,\\n        maxFee: configArg.maxFee,\\n        ratio: configArg.ratio\\n      });\\n    }\\n    emit TokenTransferFeeConfigSet(tokenTransferFeeConfigArgs);\\n  }\\n\\n  // ================================================================\\n  // |                         NOP payments                         |\\n  // ================================================================\\n\\n  /// @notice Get the total amount of fees to be paid to the Nops (in LINK)\\n  /// @return totalNopFees\\n  function getNopFeesJuels() external view returns (uint96) {\\n    return s_nopFeesJuels;\\n  }\\n\\n  /// @notice Gets the Nops and their weights\\n  /// @return nopsAndWeights Array of NopAndWeight structs\\n  /// @return weightsTotal The sum weight of all Nops\\n  function getNops() external view returns (NopAndWeight[] memory nopsAndWeights, uint256 weightsTotal) {\\n    uint256 length = s_nops.length();\\n    nopsAndWeights = new NopAndWeight[](length);\\n    for (uint256 i = 0; i < length; ++i) {\\n      (address nopAddress, uint256 nopWeight) = s_nops.at(i);\\n      nopsAndWeights[i] = NopAndWeight({nop: nopAddress, weight: uint16(nopWeight)});\\n    }\\n    weightsTotal = s_nopWeightsTotal;\\n    return (nopsAndWeights, weightsTotal);\\n  }\\n\\n  /// @notice Sets the Nops and their weights\\n  /// @param nopsAndWeights Array of NopAndWeight structs\\n  function setNops(NopAndWeight[] calldata nopsAndWeights) external onlyOwnerOrAdmin {\\n    _setNops(nopsAndWeights);\\n  }\\n\\n  /// @dev Clears existing nops, sets new nops and weights\\n  /// @param nopsAndWeights New set of nops and weights\\n  function _setNops(NopAndWeight[] memory nopsAndWeights) internal {\\n    uint256 numberOfNops = nopsAndWeights.length;\\n    if (numberOfNops > MAX_NUMBER_OF_NOPS) revert TooManyNops();\\n\\n    // Make sure all nops have been paid before removing nops\\n    // We only have to pay when there are nops and there is enough\\n    // outstanding NOP balance to trigger a payment.\\n    if (s_nopWeightsTotal > 0 && s_nopFeesJuels >= s_nopWeightsTotal) {\\n      payNops();\\n    }\\n\\n    // Remove all previous nops, move from end to start to avoid shifting\\n    for (uint256 i = s_nops.length(); i > 0; --i) {\\n      (address nop, ) = s_nops.at(i - 1);\\n      s_nops.remove(nop);\\n    }\\n\\n    // Add new\\n    uint32 nopWeightsTotal = 0;\\n    // nopWeightsTotal is bounded by the MAX_NUMBER_OF_NOPS and the weight of\\n    // a single nop being of type uint16. This ensures nopWeightsTotal will\\n    // always fit into the uint32 type.\\n    for (uint256 i = 0; i < numberOfNops; ++i) {\\n      // Make sure the LINK token is not a nop because the link token doesn't allow\\n      // self transfers. If set as nop, payNops would always revert. Since setNops\\n      // calls payNops, we can never remove the LINK token as a nop.\\n      address nop = nopsAndWeights[i].nop;\\n      uint16 weight = nopsAndWeights[i].weight;\\n      if (nop == i_linkToken || nop == address(0)) revert InvalidNopAddress(nop);\\n      s_nops.set(nop, weight);\\n      nopWeightsTotal += weight;\\n    }\\n    s_nopWeightsTotal = nopWeightsTotal;\\n    emit NopsSet(nopWeightsTotal, nopsAndWeights);\\n  }\\n\\n  /// @notice Pays the Node Ops their outstanding balances.\\n  /// @dev some balance can remain after payments are done. This is at most the sum\\n  /// of the weight of all nops. Since nop weights are uint16s and we can have at\\n  /// most MAX_NUMBER_OF_NOPS NOPs, the highest possible value is 2**22 or 0.04 gjuels.\\n  function payNops() public onlyOwnerOrAdminOrNop {\\n    uint256 weightsTotal = s_nopWeightsTotal;\\n    if (weightsTotal == 0) revert NoNopsToPay();\\n\\n    uint96 totalFeesToPay = s_nopFeesJuels;\\n    if (totalFeesToPay < weightsTotal) revert NoFeesToPay();\\n    if (_linkLeftAfterNopFees() < 0) revert InsufficientBalance();\\n\\n    uint96 fundsLeft = totalFeesToPay;\\n    uint256 numberOfNops = s_nops.length();\\n    for (uint256 i = 0; i < numberOfNops; ++i) {\\n      (address nop, uint256 weight) = s_nops.at(i);\\n      // amount can never be higher than totalFeesToPay so the cast to uint96 is safe\\n      uint96 amount = uint96((totalFeesToPay * weight) / weightsTotal);\\n      fundsLeft -= amount;\\n      IERC20(i_linkToken).safeTransfer(nop, amount);\\n      emit NopPaid(nop, amount);\\n    }\\n    // Some funds can remain, since this is an incredibly small\\n    // amount we consider this OK.\\n    s_nopFeesJuels = fundsLeft;\\n  }\\n\\n  /// @notice Allows the owner to withdraw any ERC20 token that is not the fee token\\n  /// @param feeToken The token to withdraw\\n  /// @param to The address to send the tokens to\\n  function withdrawNonLinkFees(address feeToken, address to) external onlyOwnerOrAdmin {\\n    if (feeToken == i_linkToken || to == address(0)) revert InvalidWithdrawParams();\\n\\n    // We require the link balance to be settled before allowing withdrawal\\n    // of non-link fees.\\n    if (_linkLeftAfterNopFees() < 0) revert LinkBalanceNotSettled();\\n\\n    IERC20(feeToken).safeTransfer(to, IERC20(feeToken).balanceOf(address(this)));\\n  }\\n\\n  // ================================================================\\n  // |                        Link monitoring                       |\\n  // ================================================================\\n\\n  /// @notice Calculate remaining LINK balance after paying nops\\n  /// @return balance if nops were to be paid\\n  function _linkLeftAfterNopFees() private view returns (int256) {\\n    // Since LINK caps at uint96, casting to int256 is safe\\n    return int256(IERC20(i_linkToken).balanceOf(address(this))) - int256(uint256(s_nopFeesJuels));\\n  }\\n\\n  /// @notice Allow keeper to monitor funds available for paying nops\\n  function linkAvailableForPayment() external view returns (int256) {\\n    return _linkLeftAfterNopFees();\\n  }\\n\\n  // ================================================================\\n  // |                          Allowlist                           |\\n  // ================================================================\\n\\n  /// @notice Gets whether the allowList functionality is enabled.\\n  /// @return true is enabled, false if not.\\n  function getAllowListEnabled() external view returns (bool) {\\n    return s_allowlistEnabled;\\n  }\\n\\n  /// @notice Enables or disabled the allowList functionality.\\n  /// @param enabled Signals whether the allowlist should be enabled.\\n  function setAllowListEnabled(bool enabled) external onlyOwner {\\n    s_allowlistEnabled = enabled;\\n    emit AllowListEnabledSet(enabled);\\n  }\\n\\n  /// @notice Gets the allowed addresses.\\n  /// @return The allowed addresses.\\n  /// @dev May not work if allow list gets too large. Use events in that case to compute the set.\\n  function getAllowList() external view returns (address[] memory) {\\n    return s_allowList.values();\\n  }\\n\\n  /// @notice Apply updates to the allow list.\\n  /// @param removes The addresses to be removed.\\n  /// @param adds The addresses to be added.\\n  /// @dev allowListing will be removed before public launch\\n  function applyAllowListUpdates(address[] memory removes, address[] memory adds) external onlyOwner {\\n    _applyAllowListUpdates(removes, adds);\\n  }\\n\\n  /// @notice Internal version of applyAllowListUpdates to allow for reuse in the constructor.\\n  /// @dev allowListing will be removed before public launch\\n  function _applyAllowListUpdates(address[] memory removes, address[] memory adds) internal {\\n    for (uint256 i = 0; i < removes.length; ++i) {\\n      address toRemove = removes[i];\\n      if (s_allowList.remove(toRemove)) {\\n        emit AllowListRemove(toRemove);\\n      }\\n    }\\n    for (uint256 i = 0; i < adds.length; ++i) {\\n      address toAdd = adds[i];\\n      if (toAdd == address(0)) {\\n        continue;\\n      }\\n      if (s_allowList.add(toAdd)) {\\n        emit AllowListAdd(toAdd);\\n      }\\n    }\\n  }\\n\\n  // ================================================================\\n  // |                        Access and ARM                        |\\n  // ================================================================\\n\\n  /// @dev Require that the sender is the owner or the fee admin or a nop\\n  modifier onlyOwnerOrAdminOrNop() {\\n    if (msg.sender != owner() && msg.sender != s_admin && !s_nops.contains(msg.sender))\\n      revert OnlyCallableByOwnerOrAdminOrNop();\\n    _;\\n  }\\n\\n  /// @dev Require that the sender is the owner or the fee admin\\n  modifier onlyOwnerOrAdmin() {\\n    if (msg.sender != owner() && msg.sender != s_admin) revert OnlyCallableByOwnerOrAdmin();\\n    _;\\n  }\\n\\n  /// @notice Ensure that the ARM has not emitted a bad signal, and that the latest heartbeat is not stale.\\n  modifier whenHealthy() {\\n    if (IARM(i_armProxy).isCursed()) revert BadARMSignal();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/pools/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\\\";\\n\\n// Shared public interface for multiple pool types.\\n// Each pool type handles a different child token model (lock/unlock, mint/burn.)\\ninterface IPool {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param originalSender Original sender of the tokens.\\n  /// @param receiver Receiver of the tokens on destination chain.\\n  /// @param amount Amount to lock or burn.\\n  /// @param destChainSelector Destination chain Id.\\n  /// @param extraArgs Additional data passed in by sender for lockOrBurn processing\\n  /// in custom pools on source chain.\\n  /// @return retData Optional field that contains bytes. Unused for now but already\\n  /// implemented to allow future upgrades while preserving the interface.\\n  function lockOrBurn(\\n    address originalSender,\\n    bytes calldata receiver,\\n    uint256 amount,\\n    uint64 destChainSelector,\\n    bytes calldata extraArgs\\n  ) external returns (bytes memory);\\n\\n  /// @notice Releases or mints tokens to the receiver address.\\n  /// @param originalSender Original sender of the tokens.\\n  /// @param receiver Receiver of the tokens.\\n  /// @param amount Amount to release or mint.\\n  /// @param sourceChainSelector Source chain Id.\\n  /// @param extraData Additional data supplied offchain for releaseOrMint processing in\\n  /// custom pools on dest chain. This could be an attestation that was retrieved through a\\n  /// third party API.\\n  /// @dev offchainData can come from any untrusted source.\\n  function releaseOrMint(\\n    bytes memory originalSender,\\n    address receiver,\\n    uint256 amount,\\n    uint64 sourceChainSelector,\\n    bytes memory extraData\\n  ) external;\\n\\n  /// @notice Gets the IERC20 token that this pool can lock or burn.\\n  /// @return token The IERC20 token representation.\\n  function getToken() external view returns (IERC20 token);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/IARM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @notice This interface contains the only ARM-related functions that might be used on-chain by other CCIP contracts.\\ninterface IARM {\\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\\n  struct TaggedRoot {\\n    address commitStore;\\n    bytes32 root;\\n  }\\n\\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\\n  function isBlessed(TaggedRoot calldata taggedRoot) external view returns (bool);\\n\\n  /// @notice When the ARM is \\\"cursed\\\", CCIP pauses until the curse is lifted.\\n  function isCursed() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/IPriceRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\ninterface IPriceRegistry {\\n  /// @notice Update the price for given tokens and destination chain.\\n  /// @param priceUpdates The price updates to apply.\\n  function updatePrices(Internal.PriceUpdates memory priceUpdates) external;\\n\\n  /// @notice Get the `tokenPrice` for a given token.\\n  /// @param token The token to get the price for.\\n  /// @return tokenPrice The tokenPrice for the given token.\\n  function getTokenPrice(address token) external view returns (Internal.TimestampedUint192Value memory);\\n\\n  /// @notice Get the `tokenPrice` for a given token, checks if the price is valid.\\n  /// @param token The token to get the price for.\\n  /// @return tokenPrice The tokenPrice for the given token if it exists and is valid.\\n  function getValidatedTokenPrice(address token) external view returns (uint192);\\n\\n  /// @notice Get the `tokenPrice` for an array of tokens.\\n  /// @param tokens The tokens to get prices for.\\n  /// @return tokenPrices The tokenPrices for the given tokens.\\n  function getTokenPrices(address[] calldata tokens) external view returns (Internal.TimestampedUint192Value[] memory);\\n\\n  /// @notice Get the `gasPrice` for a given destination chain ID.\\n  /// @param destChainSelector The destination chain to get the price for.\\n  /// @return gasPrice The gasPrice for the given destination chain ID.\\n  function getDestinationChainGasPrice(\\n    uint64 destChainSelector\\n  ) external view returns (Internal.TimestampedUint192Value memory);\\n\\n  /// @notice Gets the fee token price and the gas price, both denominated in dollars.\\n  /// @param token The source token to get the price for.\\n  /// @param destChainSelector The destination chain to get the gas price for.\\n  /// @return tokenPrice The price of the feeToken in 1e18 dollars per base unit.\\n  /// @return gasPrice The price of gas in 1e18 dollars per base unit.\\n  function getTokenAndGasPrices(\\n    address token,\\n    uint64 destChainSelector\\n  ) external view returns (uint192 tokenPrice, uint192 gasPrice);\\n\\n  /// @notice Convert a given token amount to target token amount.\\n  /// @param fromToken The given token address.\\n  /// @param fromTokenAmount The given token amount.\\n  /// @param toToken The target token address.\\n  /// @return toTokenAmount The target token amount.\\n  function convertTokenAmount(\\n    address fromToken,\\n    uint256 fromTokenAmount,\\n    address toToken\\n  ) external view returns (uint256 toTokenAmount);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/IEVM2AnyOnRamp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IPool} from \\\"./pools/IPool.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\nimport {IERC20} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\\\";\\n\\ninterface IEVM2AnyOnRamp {\\n  /// @notice Get the fee for a given ccip message\\n  /// @param message The message to calculate the cost for\\n  /// @return fee The calculated fee\\n  function getFee(Client.EVM2AnyMessage calldata message) external view returns (uint256 fee);\\n\\n  /// @notice Get the pool for a specific token\\n  /// @param sourceToken The source chain token to get the pool for\\n  /// @return pool Token pool\\n  function getPoolBySourceToken(IERC20 sourceToken) external view returns (IPool);\\n\\n  /// @notice Gets a list of all supported source chain tokens.\\n  /// @return tokens The addresses of all tokens that this onRamp supports for sending.\\n  function getSupportedTokens() external view returns (address[] memory tokens);\\n\\n  /// @notice Gets the next sequence number to be used in the onRamp\\n  /// @return the next sequence number to be used\\n  function getExpectedNextSequenceNumber() external view returns (uint64);\\n\\n  /// @notice Get the next nonce for a given sender\\n  /// @param sender The sender to get the nonce for\\n  /// @return nonce The next nonce for the sender\\n  function getSenderNonce(address sender) external view returns (uint64 nonce);\\n\\n  /// @notice Adds and removed token pools.\\n  /// @param removes The tokens and pools to be removed\\n  /// @param adds The tokens and pools to be added.\\n  function applyPoolUpdates(Internal.PoolUpdate[] memory removes, Internal.PoolUpdate[] memory adds) external;\\n\\n  /// @notice Send a message to the remote chain\\n  /// @dev only callable by the Router\\n  /// @dev approve() must have already been called on the token using the this ramp address as the spender.\\n  /// @dev if the contract is paused, this function will revert.\\n  /// @param message Message struct to send\\n  /// @param originalSender The original initiator of the CCIP request\\n  function forwardFromRouter(\\n    Client.EVM2AnyMessage memory message,\\n    uint256 feeTokenAmount,\\n    address originalSender\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/automation/ILinkAvailable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @notice Implement this contract so that a keeper-compatible contract can monitor\\n/// and fund the implementation contract with LINK if it falls below a defined threshold.\\ninterface ILinkAvailable {\\n  function linkAvailableForPayment() external view returns (int256 availableBalance);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/AggregateRateLimiter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nimport {IPriceRegistry} from \\\"./interfaces/IPriceRegistry.sol\\\";\\n\\nimport {OwnerIsCreator} from \\\"./../shared/access/OwnerIsCreator.sol\\\";\\nimport {Client} from \\\"./libraries/Client.sol\\\";\\nimport {RateLimiter} from \\\"./libraries/RateLimiter.sol\\\";\\nimport {USDPriceWith18Decimals} from \\\"./libraries/USDPriceWith18Decimals.sol\\\";\\n\\ncontract AggregateRateLimiter is OwnerIsCreator {\\n  using RateLimiter for RateLimiter.TokenBucket;\\n  using USDPriceWith18Decimals for uint192;\\n\\n  error PriceNotFoundForToken(address token);\\n  event AdminSet(address newAdmin);\\n\\n  // The address of the token limit admin that has the same permissions as the owner.\\n  address internal s_admin;\\n\\n  // The token bucket object that contains the bucket state.\\n  RateLimiter.TokenBucket private s_rateLimiter;\\n\\n  /// @param config The RateLimiter.Config containing the capacity and refill rate\\n  /// of the bucket, plus the admin address.\\n  constructor(RateLimiter.Config memory config) {\\n    s_rateLimiter = RateLimiter.TokenBucket({\\n      rate: config.rate,\\n      capacity: config.capacity,\\n      tokens: config.capacity,\\n      lastUpdated: uint32(block.timestamp),\\n      isEnabled: config.isEnabled\\n    });\\n  }\\n\\n  /// @notice Consumes value from the rate limiter bucket based on the\\n  /// token value given. First, calculate the prices\\n  function _rateLimitValue(Client.EVMTokenAmount[] memory tokenAmounts, IPriceRegistry priceRegistry) internal {\\n    uint256 numberOfTokens = tokenAmounts.length;\\n\\n    uint256 value = 0;\\n    for (uint256 i = 0; i < numberOfTokens; ++i) {\\n      // not fetching validated price, as price staleness is not important for value-based rate limiting\\n      // we only need to verify price is not 0\\n      uint192 pricePerToken = priceRegistry.getTokenPrice(tokenAmounts[i].token).value;\\n      if (pricePerToken == 0) revert PriceNotFoundForToken(tokenAmounts[i].token);\\n      value += pricePerToken._calcUSDValueFromTokenAmount(tokenAmounts[i].amount);\\n    }\\n\\n    s_rateLimiter._consume(value, address(0));\\n  }\\n\\n  /// @notice Gets the token bucket with its values for the block it was requested at.\\n  /// @return The token bucket.\\n  function currentRateLimiterState() external view returns (RateLimiter.TokenBucket memory) {\\n    return s_rateLimiter._currentTokenBucketState();\\n  }\\n\\n  /// @notice Sets the rate limited config.\\n  /// @param config The new rate limiter config.\\n  /// @dev should only be callable by the owner or token limit admin.\\n  function setRateLimiterConfig(RateLimiter.Config memory config) external onlyAdminOrOwner {\\n    s_rateLimiter._setTokenBucketConfig(config);\\n  }\\n\\n  // ================================================================\\n  // |                           Access                             |\\n  // ================================================================\\n\\n  /// @notice Gets the token limit admin address.\\n  /// @return the token limit admin address.\\n  function getTokenLimitAdmin() external view returns (address) {\\n    return s_admin;\\n  }\\n\\n  /// @notice Sets the token limit admin address.\\n  /// @param newAdmin the address of the new admin.\\n  /// @dev setting this to address(0) indicates there is no active admin.\\n  function setAdmin(address newAdmin) external onlyAdminOrOwner {\\n    s_admin = newAdmin;\\n    emit AdminSet(newAdmin);\\n  }\\n\\n  /// @notice a modifier that allows the owner or the s_tokenLimitAdmin call the functions\\n  /// it is applied to.\\n  modifier onlyAdminOrOwner() {\\n    if (msg.sender != owner() && msg.sender != s_admin) revert RateLimiter.OnlyCallableByAdminOrOwner();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // extraArgs will evolve to support new features\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\\n    bool strict; // See strict sequencing details below.\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"./Client.sol\\\";\\nimport {MerkleMultiProof} from \\\"../libraries/MerkleMultiProof.sol\\\";\\n\\n// Library for CCIP internal definitions common to multiple contracts.\\nlibrary Internal {\\n  struct PriceUpdates {\\n    TokenPriceUpdate[] tokenPriceUpdates;\\n    uint64 destChainSelector; // --\u2510 Destination chain selector\\n    uint192 usdPerUnitGas; // -----\u2518 1e18 USD per smallest unit (e.g. wei) of destination chain gas\\n  }\\n\\n  struct TokenPriceUpdate {\\n    address sourceToken; // Source token\\n    uint192 usdPerToken; // 1e18 USD per smallest unit of token\\n  }\\n\\n  struct TimestampedUint192Value {\\n    uint192 value; // -------\u2510 The price, in 1e18 USD.\\n    uint64 timestamp; // ----\u2518 Timestamp of the most recent price update.\\n  }\\n\\n  struct PoolUpdate {\\n    address token; // The IERC20 token address\\n    address pool; // The token pool address\\n  }\\n\\n  struct ExecutionReport {\\n    EVM2EVMMessage[] messages;\\n    // Contains a bytes array for each message\\n    // each inner bytes array contains bytes per transferred token\\n    bytes[][] offchainTokenData;\\n    bytes32[] proofs;\\n    uint256 proofFlagBits;\\n  }\\n\\n  // @notice The cross chain message that gets committed to EVM chains\\n  struct EVM2EVMMessage {\\n    uint64 sourceChainSelector;\\n    uint64 sequenceNumber;\\n    uint256 feeTokenAmount;\\n    address sender;\\n    uint64 nonce;\\n    uint256 gasLimit;\\n    bool strict;\\n    // User fields\\n    address receiver;\\n    bytes data;\\n    Client.EVMTokenAmount[] tokenAmounts;\\n    address feeToken;\\n    bytes32 messageId;\\n  }\\n\\n  function _toAny2EVMMessage(\\n    EVM2EVMMessage memory original,\\n    Client.EVMTokenAmount[] memory destTokenAmounts\\n  ) internal pure returns (Client.Any2EVMMessage memory message) {\\n    message = Client.Any2EVMMessage({\\n      messageId: original.messageId,\\n      sourceChainSelector: original.sourceChainSelector,\\n      sender: abi.encode(original.sender),\\n      data: original.data,\\n      destTokenAmounts: destTokenAmounts\\n    });\\n  }\\n\\n  bytes32 internal constant EVM_2_EVM_MESSAGE_HASH = keccak256(\\\"EVM2EVMMessageEvent\\\");\\n\\n  function _hash(EVM2EVMMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\\n          metadataHash,\\n          original.sequenceNumber,\\n          original.nonce,\\n          original.sender,\\n          original.receiver,\\n          keccak256(original.data),\\n          keccak256(abi.encode(original.tokenAmounts)),\\n          original.gasLimit,\\n          original.strict,\\n          original.feeToken,\\n          original.feeTokenAmount\\n        )\\n      );\\n  }\\n\\n  /// @notice Enum listing the possible message execution states within\\n  /// the offRamp contract.\\n  /// UNTOUCHED never executed\\n  /// IN_PROGRESS currently being executed, used a replay protection\\n  /// SUCCESS successfully executed. End state\\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\\n  enum MessageExecutionState {\\n    UNTOUCHED,\\n    IN_PROGRESS,\\n    SUCCESS,\\n    FAILURE\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/RateLimiter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @notice Implements Token Bucket rate limiting.\\n/// @dev uint128 is safe for rate limiter state.\\n/// For USD value rate limiting, it can adequately store USD value in 18 decimals.\\n/// For ERC20 token amount rate limiting, all tokens that will be listed will have at most\\n/// a supply of uint128.max tokens, and it will therefore not overflow the bucket.\\n/// In exceptional scenarios where tokens consumed may be larger than uint128,\\n/// e.g. compromised issuer, an enabled RateLimiter will check and revert.\\nlibrary RateLimiter {\\n  error BucketOverfilled();\\n  error OnlyCallableByAdminOrOwner();\\n  error TokenMaxCapacityExceeded(uint256 capacity, uint256 requested, address tokenAddress);\\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\\n  error AggregateValueMaxCapacityExceeded(uint256 capacity, uint256 requested);\\n  error AggregateValueRateLimitReached(uint256 minWaitInSeconds, uint256 available);\\n\\n  event TokensConsumed(uint256 tokens);\\n  event ConfigChanged(Config config);\\n\\n  struct TokenBucket {\\n    uint128 tokens; // ------\u2510 Current number of tokens that are in the bucket.\\n    uint32 lastUpdated; //   | Timestamp in seconds of the last token refill, good for 100+ years.\\n    bool isEnabled; // ------\u2518 Indication whether the rate limiting is enabled or not\\n    uint128 capacity; // ----\u2510 Maximum number of tokens that can be in the bucket.\\n    uint128 rate; // --------\u2518 Number of tokens per second that the bucket is refilled.\\n  }\\n\\n  struct Config {\\n    bool isEnabled; // Indication whether the rate limiting should be enabled\\n    uint128 capacity; // ----\u2510 Specifies the capacity of the rate limiter\\n    uint128 rate; //  -------\u2518 Specifies the rate of the rate limiter\\n  }\\n\\n  /// @notice _consume removes the given tokens from the pool, lowering the\\n  /// rate tokens allowed to be consumed for subsequent calls.\\n  /// @param requestTokens The total tokens to be consumed from the bucket.\\n  /// @param tokenAddress The token to consume capacity for, use 0x0 to indicate aggregate value capacity.\\n  /// @dev Reverts when requestTokens exceeds bucket capacity or available tokens in the bucket\\n  /// @dev emits removal of requestTokens if requestTokens is > 0\\n  function _consume(TokenBucket storage s_bucket, uint256 requestTokens, address tokenAddress) internal {\\n    // If there is no value to remove or rate limiting is turned off, skip this step to reduce gas usage\\n    if (!s_bucket.isEnabled || requestTokens == 0) {\\n      return;\\n    }\\n\\n    uint256 tokens = s_bucket.tokens;\\n    uint256 capacity = s_bucket.capacity;\\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\\n\\n    if (timeDiff != 0) {\\n      if (tokens > capacity) revert BucketOverfilled();\\n\\n      // Refill tokens when arriving at a new block time\\n      tokens = _calculateRefill(capacity, tokens, timeDiff, s_bucket.rate);\\n\\n      s_bucket.lastUpdated = uint32(block.timestamp);\\n    }\\n\\n    if (capacity < requestTokens) {\\n      // Token address 0 indicates consuming aggregate value rate limit capacity.\\n      if (tokenAddress == address(0)) revert AggregateValueMaxCapacityExceeded(capacity, requestTokens);\\n      revert TokenMaxCapacityExceeded(capacity, requestTokens, tokenAddress);\\n    }\\n    if (tokens < requestTokens) {\\n      uint256 rate = s_bucket.rate;\\n      // Wait required until the bucket is refilled enough to accept this value, round up to next higher second\\n      // Consume is not guaranteed to succeed after wait time passes if there is competing traffic.\\n      // This acts as a lower bound of wait time.\\n      uint256 minWaitInSeconds = ((requestTokens - tokens) + (rate - 1)) / rate;\\n\\n      if (tokenAddress == address(0)) revert AggregateValueRateLimitReached(minWaitInSeconds, tokens);\\n      revert TokenRateLimitReached(minWaitInSeconds, tokens, tokenAddress);\\n    }\\n    tokens -= requestTokens;\\n\\n    // Downcast is safe here, as tokens is not larger than capacity\\n    s_bucket.tokens = uint128(tokens);\\n    emit TokensConsumed(requestTokens);\\n  }\\n\\n  /// @notice Gets the token bucket with its values for the block it was requested at.\\n  /// @return The token bucket.\\n  function _currentTokenBucketState(TokenBucket memory bucket) internal view returns (TokenBucket memory) {\\n    // We update the bucket to reflect the status at the exact time of the\\n    // call. This means we might need to refill a part of the bucket based\\n    // on the time that has passed since the last update.\\n    bucket.tokens = uint128(\\n      _calculateRefill(bucket.capacity, bucket.tokens, block.timestamp - bucket.lastUpdated, bucket.rate)\\n    );\\n    bucket.lastUpdated = uint32(block.timestamp);\\n    return bucket;\\n  }\\n\\n  /// @notice Sets the rate limited config.\\n  /// @param s_bucket The token bucket\\n  /// @param config The new config\\n  function _setTokenBucketConfig(TokenBucket storage s_bucket, Config memory config) internal {\\n    // First update the bucket to make sure the proper rate is used for all the time\\n    // up until the config change.\\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\\n    if (timeDiff != 0) {\\n      s_bucket.tokens = uint128(_calculateRefill(s_bucket.capacity, s_bucket.tokens, timeDiff, s_bucket.rate));\\n\\n      s_bucket.lastUpdated = uint32(block.timestamp);\\n    }\\n\\n    s_bucket.tokens = uint128(_min(config.capacity, s_bucket.tokens));\\n    s_bucket.isEnabled = config.isEnabled;\\n    s_bucket.capacity = config.capacity;\\n    s_bucket.rate = config.rate;\\n\\n    emit ConfigChanged(config);\\n  }\\n\\n  /// @notice Calculate refilled tokens\\n  /// @param capacity bucket capacity\\n  /// @param tokens current bucket tokens\\n  /// @param timeDiff block time difference since last refill\\n  /// @param rate bucket refill rate\\n  /// @return the value of tokens after refill\\n  function _calculateRefill(\\n    uint256 capacity,\\n    uint256 tokens,\\n    uint256 timeDiff,\\n    uint256 rate\\n  ) private pure returns (uint256) {\\n    return _min(capacity, tokens + timeDiff * rate);\\n  }\\n\\n  /// @notice Return the smallest of two integers\\n  /// @param a first int\\n  /// @param b second int\\n  /// @return smallest\\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/USDPriceWith18Decimals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary USDPriceWith18Decimals {\\n  /// @notice Takes a price in USD, with 18 decimals per 1e18 token amount,\\n  /// and amount of the smallest token denomination,\\n  /// calculates the value in USD with 18 decimals.\\n  /// @param tokenPrice The USD price of the token.\\n  /// @param tokenAmount Amount of the smallest token denomination.\\n  /// @return USD value with 18 decimals.\\n  /// @dev this function assumes that no more than 1e59 US dollar worth of token is passed in.\\n  /// If more is sent, this function will overflow and revert.\\n  /// Since there isn't even close to 1e59 dollars, this is ok for all legit tokens.\\n  function _calcUSDValueFromTokenAmount(uint192 tokenPrice, uint256 tokenAmount) internal pure returns (uint256) {\\n    /// LINK Example:\\n    /// tokenPrice:         8e18 -> $8/LINK, as 1e18 token amount is 1 LINK, worth 8 USD, or 8e18 with 18 decimals\\n    /// tokenAmount:        2e18 -> 2 LINK\\n    /// result:             8e18 * 2e18 / 1e18 -> 16e18 with 18 decimals = $16\\n\\n    /// USDC Example:\\n    /// tokenPrice:         1e30 -> $1/USDC, as 1e18 token amount is 1e12 USDC, worth 1e12 USD, or 1e30 with 18 decimals\\n    /// tokenAmount:        5e6  -> 5 USDC\\n    /// result:             1e30 * 5e6 / 1e18 -> 5e18 with 18 decimals = $5\\n    return (tokenPrice * tokenAmount) / 1e18;\\n  }\\n\\n  /// @notice Takes a price in USD, with 18 decimals per 1e18 token amount,\\n  /// and USD value with 18 decimals,\\n  /// calculates amount of the smallest token denomination.\\n  /// @param tokenPrice The USD price of the token.\\n  /// @param usdValue USD value with 18 decimals.\\n  /// @return Amount of the smallest token denomination.\\n  function _calcTokenAmountFromUSDValue(uint192 tokenPrice, uint256 usdValue) internal pure returns (uint256) {\\n    /// LINK Example:\\n    /// tokenPrice:          8e18 -> $8/LINK, as 1e18 token amount is 1 LINK, worth 8 USD, or 8e18 with 18 decimals\\n    /// usdValue:           16e18 -> $16\\n    /// result:             16e18 * 1e18 / 8e18 -> 2e18 = 2 LINK\\n\\n    /// USDC Example:\\n    /// tokenPrice:         1e30 -> $1/USDC, as 1e18 token amount is 1e12 USDC, worth 1e12 USD, or 1e30 with 18 decimals\\n    /// usdValue:           5e18 -> $5\\n    /// result:             5e18 * 1e18 / 1e30 -> 5e6 = 5 USDC\\n    return (usdValue * 1e18) / tokenPrice;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/enumerable/EnumerableMapAddresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {EnumerableMap} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/utils/structs/EnumerableMap.sol\\\";\\n\\nlibrary EnumerableMapAddresses {\\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n  struct AddressToAddressMap {\\n    EnumerableMap.UintToAddressMap _inner;\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function set(AddressToAddressMap storage map, address key, address value) internal returns (bool) {\\n    return map._inner.set(uint256(uint160(key)), value);\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\\n    return map._inner.remove(uint256(uint160(key)));\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\\n    return map._inner.contains(uint256(uint160(key)));\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function length(AddressToAddressMap storage map) internal view returns (uint256) {\\n    return map._inner.length();\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function at(AddressToAddressMap storage map, uint256 index) internal view returns (address, address) {\\n    (uint256 key, address value) = map._inner.at(index);\\n    return (address(uint160(key)), value);\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function tryGet(AddressToAddressMap storage map, address key) internal view returns (bool, address) {\\n    return map._inner.tryGet(uint256(uint160(key)));\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function get(AddressToAddressMap storage map, address key) internal view returns (address) {\\n    return map._inner.get(uint256(uint160(key)));\\n  }\\n\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function get(\\n    AddressToAddressMap storage map,\\n    address key,\\n    string memory errorMessage\\n  ) internal view returns (address) {\\n    return map._inner.get(uint256(uint160(key)), errorMessage);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n      uint256 newAllowance = oldAllowance - value;\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n}\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position of the value in the `values` array, plus 1 because index 0\\n    // means a value is not in the set.\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We read and store the value's index to prevent multiple reads from the same storage slot\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (lastIndex != toDeleteIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the last value to the index where the value to delete is\\n        set._values[toDeleteIndex] = lastValue;\\n        // Update the index for the moved value\\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the index for the deleted slot\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Map type with\\n  // bytes32 keys and values.\\n  // The Map implementation uses private functions, and user-facing\\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\\n  // the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit\\n  // in bytes32.\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n   * key. O(1).\\n   *\\n   * Returns true if the key was added to the map, that is if it was not\\n   * already present.\\n   */\\n  function set(\\n    Bytes32ToBytes32Map storage map,\\n    bytes32 key,\\n    bytes32 value\\n  ) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n   *\\n   * Returns true if the key was removed from the map, that is if it was present.\\n   */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n   */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n   */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of entries inside the\\n   * array, and it may change when more entries are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n   * Does not revert if `key` is not in the map.\\n   */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n   *\\n   * Requirements:\\n   *\\n   * - `key` must be in the map.\\n   */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryGet}.\\n   */\\n  function get(\\n    Bytes32ToBytes32Map storage map,\\n    bytes32 key,\\n    string memory errorMessage\\n  ) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    require(value != 0 || contains(map, key), errorMessage);\\n    return value;\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n   * key. O(1).\\n   *\\n   * Returns true if the key was added to the map, that is if it was not\\n   * already present.\\n   */\\n  function set(\\n    UintToUintMap storage map,\\n    uint256 key,\\n    uint256 value\\n  ) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the key was removed from the map, that is if it was present.\\n   */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n   */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n   */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the set. O(1).\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n   * Does not revert if `key` is not in the map.\\n   */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n   *\\n   * Requirements:\\n   *\\n   * - `key` must be in the map.\\n   */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryGet}.\\n   */\\n  function get(\\n    UintToUintMap storage map,\\n    uint256 key,\\n    string memory errorMessage\\n  ) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key), errorMessage));\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n   * key. O(1).\\n   *\\n   * Returns true if the key was added to the map, that is if it was not\\n   * already present.\\n   */\\n  function set(\\n    UintToAddressMap storage map,\\n    uint256 key,\\n    address value\\n  ) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the key was removed from the map, that is if it was present.\\n   */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n   */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n   */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the set. O(1).\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n   * Does not revert if `key` is not in the map.\\n   */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n   *\\n   * Requirements:\\n   *\\n   * - `key` must be in the map.\\n   */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryGet}.\\n   */\\n  function get(\\n    UintToAddressMap storage map,\\n    uint256 key,\\n    string memory errorMessage\\n  ) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n   * key. O(1).\\n   *\\n   * Returns true if the key was added to the map, that is if it was not\\n   * already present.\\n   */\\n  function set(\\n    AddressToUintMap storage map,\\n    address key,\\n    uint256 value\\n  ) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the key was removed from the map, that is if it was present.\\n   */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n   */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n   */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the set. O(1).\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n   * Does not revert if `key` is not in the map.\\n   */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n   *\\n   * Requirements:\\n   *\\n   * - `key` must be in the map.\\n   */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryGet}.\\n   */\\n  function get(\\n    AddressToUintMap storage map,\\n    address key,\\n    string memory errorMessage\\n  ) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n   * key. O(1).\\n   *\\n   * Returns true if the key was added to the map, that is if it was not\\n   * already present.\\n   */\\n  function set(\\n    Bytes32ToUintMap storage map,\\n    bytes32 key,\\n    uint256 value\\n  ) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the key was removed from the map, that is if it was present.\\n   */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n   */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n   */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the set. O(1).\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n   * Does not revert if `key` is not in the map.\\n   */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n   *\\n   * Requirements:\\n   *\\n   * - `key` must be in the map.\\n   */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryGet}.\\n   */\\n  function get(\\n    Bytes32ToUintMap storage map,\\n    bytes32 key,\\n    string memory errorMessage\\n  ) internal view returns (uint256) {\\n    return uint256(get(map._inner, key, errorMessage));\\n  }\\n}\"\r\n    },\r\n    \"src/v0.8/shared/access/OwnerIsCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ConfirmedOwner} from \\\"../../ConfirmedOwner.sol\\\";\\n\\n/// @title The OwnerIsCreator contract\\n/// @notice A contract with helpers for basic contract ownership.\\ncontract OwnerIsCreator is ConfirmedOwner {\\n  constructor() ConfirmedOwner(msg.sender) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/MerkleMultiProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary MerkleMultiProof {\\n  /// @notice Leaf domain separator, should be used as the first 32 bytes of a leaf's preimage.\\n  bytes32 internal constant LEAF_DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n  /// @notice Internal domain separator, should be used as the first 32 bytes of an internal node's preiimage.\\n  bytes32 internal constant INTERNAL_DOMAIN_SEPARATOR =\\n    0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n  uint256 internal constant MAX_NUM_HASHES = 256;\\n\\n  error InvalidProof();\\n  error LeavesCannotBeEmpty();\\n\\n  /// @notice Computes the root based on provided pre-hashed leaf nodes in\\n  /// leaves, internal nodes in proofs, and using proofFlagBits' i-th bit to\\n  /// determine if an element of proofs or one of the previously computed leafs\\n  /// or internal nodes will be used for the i-th hash.\\n  /// @param leaves Should be pre-hashed and the first 32 bytes of a leaf's\\n  /// preimage should match LEAF_DOMAIN_SEPARATOR.\\n  /// @param proofs The hashes to be used instead of a leaf hash when the proofFlagBits\\n  ///  indicates a proof should be used.\\n  /// @param proofFlagBits A single uint256 of which each bit indicates whether a leaf or\\n  ///  a proof needs to be used in a hash operation.\\n  /// @dev the maximum number of hash operations it set to 256. Any input that would require\\n  ///  more than 256 hashes to get to a root will revert.\\n  /// @dev For given input `leaves` = [a,b,c] `proofs` = [D] and `proofFlagBits` = 5\\n  ///     totalHashes = 3 + 1 - 1 = 3\\n  ///  ** round 1 **\\n  ///    proofFlagBits = (5 >> 0) & 1 = true\\n  ///    hashes[0] = hashPair(a, b)\\n  ///    (leafPos, hashPos, proofPos) = (2, 0, 0);\\n  ///\\n  ///  ** round 2 **\\n  ///    proofFlagBits = (5 >> 1) & 1 = false\\n  ///    hashes[1] = hashPair(D, c)\\n  ///    (leafPos, hashPos, proofPos) = (3, 0, 1);\\n  ///\\n  ///  ** round 3 **\\n  ///    proofFlagBits = (5 >> 2) & 1 = true\\n  ///    hashes[2] = hashPair(hashes[0], hashes[1])\\n  ///    (leafPos, hashPos, proofPos) = (3, 2, 1);\\n  ///\\n  ///    i = 3 and no longer < totalHashes. The algorithm is done\\n  ///    return hashes[totalHashes - 1] = hashes[2]; the last hash we computed.\\n  // We mark this function as internal to force it to be inlined in contracts\\n  // that use it, but semantically it is public.\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function merkleRoot(\\n    bytes32[] memory leaves,\\n    bytes32[] memory proofs,\\n    uint256 proofFlagBits\\n  ) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 leavesLen = leaves.length;\\n      uint256 proofsLen = proofs.length;\\n      if (leavesLen == 0) revert LeavesCannotBeEmpty();\\n      if (!(leavesLen <= MAX_NUM_HASHES + 1 && proofsLen <= MAX_NUM_HASHES + 1)) revert InvalidProof();\\n      uint256 totalHashes = leavesLen + proofsLen - 1;\\n      if (!(totalHashes <= MAX_NUM_HASHES)) revert InvalidProof();\\n      if (totalHashes == 0) {\\n        return leaves[0];\\n      }\\n      bytes32[] memory hashes = new bytes32[](totalHashes);\\n      (uint256 leafPos, uint256 hashPos, uint256 proofPos) = (0, 0, 0);\\n\\n      for (uint256 i = 0; i < totalHashes; ++i) {\\n        // Checks if the bit flag signals the use of a supplied proof or a leaf/previous hash.\\n        bytes32 a;\\n        if (proofFlagBits & (1 << i) == (1 << i)) {\\n          // Use a leaf or a previously computed hash.\\n          if (leafPos < leavesLen) {\\n            a = leaves[leafPos++];\\n          } else {\\n            a = hashes[hashPos++];\\n          }\\n        } else {\\n          // Use a supplied proof.\\n          a = proofs[proofPos++];\\n        }\\n\\n        // The second part of the hashed pair is never a proof as hashing two proofs would result in a\\n        // hash that can already be computed offchain.\\n        bytes32 b;\\n        if (leafPos < leavesLen) {\\n          b = leaves[leafPos++];\\n        } else {\\n          b = hashes[hashPos++];\\n        }\\n\\n        if (!(hashPos <= i)) revert InvalidProof();\\n\\n        hashes[i] = _hashPair(a, b);\\n      }\\n      if (!(hashPos == totalHashes - 1 && leafPos == leavesLen && proofPos == proofsLen)) revert InvalidProof();\\n      // Return the last hash.\\n      return hashes[totalHashes - 1];\\n    }\\n  }\\n\\n  /// @notice Hashes two bytes32 objects in their given order, prepended by the\\n  /// INTERNAL_DOMAIN_SEPARATOR.\\n  function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32 hash) {\\n    return keccak256(abi.encode(INTERNAL_DOMAIN_SEPARATOR, left, right));\\n  }\\n\\n  /// @notice Hashes two bytes32 objects. The order is taken into account,\\n  /// using the lower value first.\\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n    return a < b ? _hashInternalNode(a, b) : _hashInternalNode(b, a);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n   * given ``owner``'s signed approval.\\n   *\\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n   * ordering also apply here.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `deadline` must be a timestamp in the future.\\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n   * over the EIP712-formatted function arguments.\\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\\n   *\\n   * For more information on the signature format, see the\\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n   * section].\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n   * included whenever a signature is generated for {permit}.\\n   *\\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n   * prevents a signature from being used multiple times.\\n   */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n   *\\n   * _Available since v4.8._\\n   */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason or using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=foundry-lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=foundry-lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=foundry-lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=foundry-lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 26000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"destChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"defaultTxGasLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"maxNopFeesJuels\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"prevOnRamp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"internalType\":\"struct EVM2EVMOnRamp.StaticConfig\",\"name\":\"staticConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"maxTokensLength\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceRegistry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxDataSize\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"maxGasLimit\",\"type\":\"uint64\"}],\"internalType\":\"struct EVM2EVMOnRamp.DynamicConfig\",\"name\":\"dynamicConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"internalType\":\"struct Internal.PoolUpdate[]\",\"name\":\"tokensAndPools\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"allowlist\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gasMultiplier\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"networkFeeAmountUSD\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"destGasOverhead\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"destGasPerPayloadByte\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"internalType\":\"struct EVM2EVMOnRamp.FeeTokenConfigArgs[]\",\"name\":\"feeTokenConfigs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxFee\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"ratio\",\"type\":\"uint16\"}],\"internalType\":\"struct EVM2EVMOnRamp.TokenTransferFeeConfigArgs[]\",\"name\":\"tokenTransferFeeConfigArgs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nop\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"}],\"internalType\":\"struct EVM2EVMOnRamp.NopAndWeight[]\",\"name\":\"nopsAndWeights\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"}],\"name\":\"AggregateValueMaxCapacityExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWaitInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"AggregateValueRateLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadARMSignal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BucketOverfilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedAddress\",\"type\":\"bytes\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExtraArgsTag\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nop\",\"type\":\"address\"}],\"name\":\"InvalidNopAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenPoolConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWithdrawParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkBalanceNotSettled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxFeeBalanceReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MessageGasLimitTooHigh\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualSize\",\"type\":\"uint256\"}],\"name\":\"MessageTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeCalledByRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoFeesToPay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoNopsToPay\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"NotAFeeToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByAdminOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByOwnerOrAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByOwnerOrAdminOrNop\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"PoolDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"PriceNotFoundForToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RouterMustSetOriginalSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenMaxCapacityExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenPoolMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWaitInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenRateLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyNops\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedNumberOfTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"UnsupportedToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AllowListAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"AllowListEnabledSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AllowListRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sequenceNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"feeTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"strict\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct Internal.EVM2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"CCIPSendRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"destChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"defaultTxGasLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"maxNopFeesJuels\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"prevOnRamp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct EVM2EVMOnRamp.StaticConfig\",\"name\":\"staticConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"maxTokensLength\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceRegistry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxDataSize\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"maxGasLimit\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct EVM2EVMOnRamp.DynamicConfig\",\"name\":\"dynamicConfig\",\"type\":\"tuple\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gasMultiplier\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"networkFeeAmountUSD\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"destGasOverhead\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"destGasPerPayloadByte\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct EVM2EVMOnRamp.FeeTokenConfigArgs[]\",\"name\":\"feeConfig\",\"type\":\"tuple[]\"}],\"name\":\"FeeConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nop\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NopPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nopWeightsTotal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nop\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct EVM2EVMOnRamp.NopAndWeight[]\",\"name\":\"nopsAndWeights\",\"type\":\"tuple[]\"}],\"name\":\"NopsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxFee\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"ratio\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct EVM2EVMOnRamp.TokenTransferFeeConfigArgs[]\",\"name\":\"transferFeeConfig\",\"type\":\"tuple[]\"}],\"name\":\"TokenTransferFeeConfigSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"removes\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adds\",\"type\":\"address[]\"}],\"name\":\"applyAllowListUpdates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"internalType\":\"struct Internal.PoolUpdate[]\",\"name\":\"removes\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"internalType\":\"struct Internal.PoolUpdate[]\",\"name\":\"adds\",\"type\":\"tuple[]\"}],\"name\":\"applyPoolUpdates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRateLimiterState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"tokens\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdated\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.TokenBucket\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"receiver\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraArgs\",\"type\":\"bytes\"}],\"internalType\":\"struct Client.EVM2AnyMessage\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"originalSender\",\"type\":\"address\"}],\"name\":\"forwardFromRouter\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDynamicConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"maxTokensLength\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceRegistry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxDataSize\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"maxGasLimit\",\"type\":\"uint64\"}],\"internalType\":\"struct EVM2EVMOnRamp.DynamicConfig\",\"name\":\"dynamicConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpectedNextSequenceNumber\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"receiver\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraArgs\",\"type\":\"bytes\"}],\"internalType\":\"struct Client.EVM2AnyMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFeeTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"networkFeeAmountUSD\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"gasMultiplier\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"destGasOverhead\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"destGasPerPayloadByte\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"internalType\":\"struct EVM2EVMOnRamp.FeeTokenConfig\",\"name\":\"feeTokenConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNopFeesJuels\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNops\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nop\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"}],\"internalType\":\"struct EVM2EVMOnRamp.NopAndWeight[]\",\"name\":\"nopsAndWeights\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"weightsTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"sourceToken\",\"type\":\"address\"}],\"name\":\"getPoolBySourceToken\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getSenderNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStaticConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"destChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"defaultTxGasLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"maxNopFeesJuels\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"prevOnRamp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"internalType\":\"struct EVM2EVMOnRamp.StaticConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenLimitAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenTransferFeeConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"minFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxFee\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"ratio\",\"type\":\"uint16\"}],\"internalType\":\"struct EVM2EVMOnRamp.TokenTransferFeeConfig\",\"name\":\"tokenTransferFeeConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkAvailableForPayment\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payNops\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"maxTokensLength\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceRegistry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxDataSize\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"maxGasLimit\",\"type\":\"uint64\"}],\"internalType\":\"struct EVM2EVMOnRamp.DynamicConfig\",\"name\":\"dynamicConfig\",\"type\":\"tuple\"}],\"name\":\"setDynamicConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gasMultiplier\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"networkFeeAmountUSD\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"destGasOverhead\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"destGasPerPayloadByte\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"internalType\":\"struct EVM2EVMOnRamp.FeeTokenConfigArgs[]\",\"name\":\"feeTokenConfigArgs\",\"type\":\"tuple[]\"}],\"name\":\"setFeeTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nop\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"}],\"internalType\":\"struct EVM2EVMOnRamp.NopAndWeight[]\",\"name\":\"nopsAndWeights\",\"type\":\"tuple[]\"}],\"name\":\"setNops\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setRateLimiterConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxFee\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"ratio\",\"type\":\"uint16\"}],\"internalType\":\"struct EVM2EVMOnRamp.TokenTransferFeeConfigArgs[]\",\"name\":\"tokenTransferFeeConfigArgs\",\"type\":\"tuple[]\"}],\"name\":\"setTokenTransferFeeConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawNonLinkFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EVM2EVMOnRamp", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "26000", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000000000000000000000000000045849994fc9c7b15000000000000000000000000000000000000000000000000383a1891ae1915b10000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000000000000000000000000043c33c19375648000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000411de17f12d1a34ecc7f45f49844626267c75e81000000000000000000000000e561d5e02207fb5eb32cca20a699e0d8919a14760000000000000000000000000000000000000000000000000000000000000005000000000000000000000000020082a7a9c2510e1921116001152dee4da81985000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000001e8480000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000002e0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000152d02c7e14af68000000000000000000000000000000000000000000000000000090d972f32323c0000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004a000000000000000000000000000000000000000000000000000000000000005400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000c2291992a08ebfdfedfe248f2ccd34da63570df400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000000000000000000000000000000e92596fd6290000000000000000000000000000000000000000000000000000063eb89da4ed0000000000000000000000000000000000000000000000000000000000000005573000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000e92596fd629000000000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000000000000000000000000000000000000055730000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}