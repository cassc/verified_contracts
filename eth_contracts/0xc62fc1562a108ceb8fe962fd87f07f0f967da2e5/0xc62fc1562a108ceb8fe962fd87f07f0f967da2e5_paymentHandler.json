{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/paymentHandler.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\ncontract paymentHandler is Ownable, ReentrancyGuard {\r\n\r\n    address public fundsHandler;\r\n    uint public totalMinted;\r\n\r\n    //mappings\r\n    mapping(uint => uint) public tierLeftover;\r\n    mapping (uint => uint) public tierMaxSupply;\r\n    mapping(uint => uint) public tierToPrice;\r\n    mapping (address => uint) public userMinted;\r\n    mapping (address => uint) public rewardsEarned;\r\n    mapping(address => mapping(uint=> uint)) public userTierLeftover;\r\n    mapping(address => string) public referralCodes;\r\n    mapping(string => address) public codeToAddress;\r\n    mapping (address => bool) public isInitialized;\r\n    \r\n    //events\r\n    event paymentReceived(address indexed minter, uint256 amount, uint quantity, string refCode);\r\n    event Refer(address indexed referrer, address indexed referee, uint tokenId, uint referralRewards);\r\n\r\n    constructor(address initialOwner) \r\n        Ownable(initialOwner) {}\r\n    \r\n\r\n    function mint(uint quantity, string memory refCode) public payable nonReentrant {\r\n        \r\n        if(!isInitialized[msg.sender]){\r\n            initializeUser(msg.sender);\r\n        }\r\n        require(msg.value == calcPrice(quantity, msg.sender, refCode), \"Low value sent\");\r\n        uint finalPayment = msg.value;\r\n\r\n        if (codeToAddress[refCode] != address(0)) {\r\n            address referrer = codeToAddress[refCode];\r\n            uint referRewards = msg.value * 10 / 100;\r\n            finalPayment = finalPayment * 90 / 100;\r\n            (bool referSuccess, ) = payable(referrer).call{value: referRewards}(\"\");\r\n            require(referSuccess, \"Payment failed\");\r\n            rewardsEarned[referrer]+= referRewards;\r\n            emit Refer(referrer, msg.sender, quantity, referRewards);\r\n        }\r\n\r\n        (bool success, ) = payable(fundsHandler).call{value: finalPayment}(\"\");\r\n        require(success, \"Payment failed\");\r\n        deductMint(quantity,msg.sender);\r\n        userMinted[msg.sender] += quantity;\r\n        totalMinted += quantity;\r\n        emit paymentReceived( msg.sender, finalPayment, quantity, refCode );\r\n    }\r\n\r\n    // Core logic set functions\r\n    function setTiers(uint tier, uint totalAllocated, uint priceTier) external onlyOwner {\r\n        require(tier >0 && tier <= 15 && priceTier >= 0.075 ether);\r\n        tierLeftover[tier] = totalAllocated;\r\n        tierMaxSupply[tier] = totalAllocated;\r\n        tierToPrice[tier] = priceTier;\r\n    }\r\n\r\n    function setReferralCode(string[] memory code, address[] memory wallet) external  onlyOwner {\r\n        require(code.length == wallet.length);\r\n        for (uint i = 0; i< code.length; i++) {\r\n            referralCodes[wallet[i]] = code[i];\r\n            codeToAddress[code[i]] = wallet[i];\r\n        }\r\n    }\r\n\r\n    function setFundsHandler(address _newFundsHandler) external onlyOwner{\r\n        require(_newFundsHandler != address(0), \"Invalid address\");\r\n        fundsHandler = _newFundsHandler;\r\n    }\r\n    \r\n    //internal functions\r\n    function initializeUser(address userToInit) internal {\r\n        require(!isInitialized[userToInit]);\r\n        for(uint i=1; i<=15; i++) {\r\n            userTierLeftover[userToInit][i] = i;\r\n            if(i == 5) {\r\n                userTierLeftover[userToInit][i] = 0;\r\n            }\r\n        }\r\n        isInitialized[userToInit] = !isInitialized[userToInit];\r\n    }\r\n\r\n    function deductMint(uint amount, address minter) internal {\r\n        require(isInitialized[minter]);\r\n        require(maxMintable(minter) >= amount);\r\n        uint remAmount = amount;   \r\n        for (uint256 i = 1; i <= 15; i++) {\r\n            if(tierLeftover[i] >= userTierLeftover[minter][i] ) {\r\n                if(remAmount >= userTierLeftover[minter][i]) {\r\n                    tierLeftover[i] -= userTierLeftover[minter][i];\r\n                    remAmount -= userTierLeftover[minter][i];\r\n                    userTierLeftover[minter][i] = 0;\r\n                }\r\n                else{\r\n                    userTierLeftover[minter][i] -= remAmount;\r\n                    tierLeftover[i] -= remAmount;\r\n                    remAmount = 0;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                userTierLeftover[minter][i] -= tierLeftover[i];\r\n                \r\n                remAmount -= tierLeftover[i];\r\n                tierLeftover[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n\r\n    //view functions\r\n    function calcPrice(uint amount, address minter, string memory refCode) public view returns (uint) {\r\n        require(isInitialized[minter]);\r\n        require(maxMintable(minter) >= amount);\r\n        uint price;\r\n        uint remAmount = amount;\r\n        uint finalPrice;    \r\n        for (uint256 i = 1; i <= 15; i++) {\r\n            \r\n            if(tierLeftover[i] >= userTierLeftover[minter][i] ) {\r\n                if(remAmount >= userTierLeftover[minter][i]) {\r\n                    price += tierToPrice[i] * userTierLeftover[minter][i];\r\n                    remAmount -= userTierLeftover[minter][i];\r\n                }\r\n                \r\n                else {\r\n                    price += tierToPrice[i] * remAmount;\r\n                    remAmount = 0;\r\n                    break;\r\n                }\r\n\r\n            }\r\n            else {\r\n                price += tierToPrice[i] * (tierLeftover[i]);\r\n                remAmount -= tierLeftover[i];\r\n            }\r\n        }\r\n        finalPrice = price;\r\n        if(codeToAddress[refCode] != address(0)) {\r\n            finalPrice = finalPrice * 90 / 100;\r\n        }\r\n        return finalPrice;\r\n    }\r\n\r\n    function maxMintable(address userToCheck) public view returns(uint) {\r\n        uint maxMint;\r\n        if (!isInitialized[userToCheck]) {\r\n            for(uint i = 1; i<= 15; i++) {\r\n                if(tierLeftover[i]>=i) {\r\n                    maxMint += i;\r\n                }\r\n                else {\r\n                    maxMint += tierLeftover[i];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for(uint i = 1; i<= 15; i++) {\r\n                if(userTierLeftover[userToCheck][i] > tierLeftover[i]) {\r\n                    maxMint += tierLeftover[i];\r\n                }\r\n                else{\r\n                    maxMint += userTierLeftover[userToCheck][i]; \r\n                }\r\n            }\r\n        }\r\n        return maxMint;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralRewards\",\"type\":\"uint256\"}],\"name\":\"Refer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"paymentReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"calcPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"codeToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userToCheck\",\"type\":\"address\"}],\"name\":\"maxMintable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCodes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardsEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFundsHandler\",\"type\":\"address\"}],\"name\":\"setFundsHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"code\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"wallet\",\"type\":\"address[]\"}],\"name\":\"setReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAllocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTier\",\"type\":\"uint256\"}],\"name\":\"setTiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tierLeftover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tierMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tierToPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userTierLeftover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "paymentHandler", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b3aea1dcbc7f6714026c6c8bb0103fd08b09dd4e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://74e4c1d71c076cbb9af381a0b80688b2144231489ad652640cc116815f27d87e"}