{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/root/predicates/ERC20PredicateBurnOnly.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {BytesLib} from \\\"../../common/lib/BytesLib.sol\\\";\\nimport {Common} from \\\"../../common/lib/Common.sol\\\";\\nimport {Math} from \\\"openzeppelin-solidity/contracts/math/Math.sol\\\";\\nimport {RLPEncode} from \\\"../../common/lib/RLPEncode.sol\\\";\\nimport {RLPReader} from \\\"../../common/lib/RLPReader.sol\\\";\\nimport {SafeMath} from \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport {ExitPayloadReader} from \\\"../../common/lib/ExitPayloadReader.sol\\\";\\nimport {IErcPredicate} from \\\"./IPredicate.sol\\\";\\nimport {Registry} from \\\"../../common/Registry.sol\\\";\\nimport {WithdrawManagerHeader} from \\\"../withdrawManager/WithdrawManagerStorage.sol\\\";\\n\\ncontract ERC20PredicateBurnOnly is IErcPredicate {\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n    using SafeMath for uint256;\\n\\n    using ExitPayloadReader for bytes;\\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\\n    using ExitPayloadReader for ExitPayloadReader.Log;\\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\\n\\n    // keccak256('Withdraw(address,address,uint256,uint256,uint256)')\\n    bytes32 constant WITHDRAW_EVENT_SIG = 0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f;\\n\\n    constructor(\\n        address _withdrawManager,\\n        address _depositManager\\n    ) public IErcPredicate(_withdrawManager, _depositManager) {\\n    }\\n\\n    function startExitWithBurntTokens(bytes calldata data) external {\\n        ExitPayloadReader.ExitPayload memory payload = data.toExitPayload();\\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\\n        uint256 logIndex = payload.getReceiptLogIndex();\\n        require(logIndex < MAX_LOGS, \\\"Supporting a max of 10 logs\\\");\\n        uint256 age = withdrawManager.verifyInclusion(\\n            data,\\n            0, /* offset */\\n            false /* verifyTxInclusion */\\n        );\\n        ExitPayloadReader.Log memory log = receipt.getLog();\\n\\n        // \\\"address\\\" (contract address that emitted the log) field in the receipt\\n        address childToken = log.getEmitter();\\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\\n        // now, inputItems[i] refers to i-th (0-based) topic in the topics array\\n        // event Withdraw(address indexed token, address indexed from, uint256 amountOrTokenId, uint256 input1, uint256 output1)\\n        require(\\n            bytes32(topics.getField(0).toUint()) == WITHDRAW_EVENT_SIG,\\n            \\\"Not a withdraw event signature\\\"\\n        );\\n        require(\\n            msg.sender == address(topics.getField(2).toUint()), // from\\n            \\\"Withdrawer and burn exit tx do not match\\\"\\n        );\\n        address rootToken = address(topics.getField(1).toUint());\\n        uint256 exitAmount = BytesLib.toUint(log.getData(), 0); // amountOrTokenId\\n        withdrawManager.addExitToQueue(\\n            msg.sender,\\n            childToken,\\n            rootToken,\\n            exitAmount,\\n            bytes32(0x0),\\n            true, /* isRegularExit */\\n            age << 1\\n        );\\n    }\\n\\n    function verifyDeprecation(\\n        bytes calldata exit,\\n        bytes calldata inputUtxo,\\n        bytes calldata challengeData\\n    ) external returns (bool) {}\\n\\n    function interpretStateUpdate(bytes calldata state)\\n        external\\n        view\\n        returns (bytes memory) {}\\n}\\n\"\r\n    },\r\n    \"contracts/common/lib/BytesLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n        return tempBytes;\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n        bytes memory tempBytes;\\n        assembly {\\n            switch iszero(_length)\\n                case 0 {\\n                    // Get a location of some free memory and store it in tempBytes as\\n                    // Solidity does for memory variables.\\n                    tempBytes := mload(0x40)\\n\\n                    // The first word of the slice result is potentially a partial\\n                    // word read from the original array. To read it, we calculate\\n                    // the length of that partial word and start copying that many\\n                    // bytes into the array. The first word we copy will start with\\n                    // data we don't care about, but the last `lengthmod` bytes will\\n                    // land at the beginning of the contents of the new array. When\\n                    // we're done copying, we overwrite the full first word with\\n                    // the actual length of the slice.\\n                    let lengthmod := and(_length, 31)\\n\\n                    // The multiplication in the next line is necessary\\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                    // the following copy loop was copying the origin's length\\n                    // and then ending prematurely not copying everything it should.\\n                    let mc := add(\\n                        add(tempBytes, lengthmod),\\n                        mul(0x20, iszero(lengthmod))\\n                    )\\n                    let end := add(mc, _length)\\n\\n                    for {\\n                        // The multiplication in the next line has the same exact purpose\\n                        // as the one above.\\n                        let cc := add(\\n                            add(\\n                                add(_bytes, lengthmod),\\n                                mul(0x20, iszero(lengthmod))\\n                            ),\\n                            _start\\n                        )\\n                    } lt(mc, end) {\\n                        mc := add(mc, 0x20)\\n                        cc := add(cc, 0x20)\\n                    } {\\n                        mstore(mc, mload(cc))\\n                    }\\n\\n                    mstore(tempBytes, _length)\\n\\n                    //update free-memory pointer\\n                    //allocating the array padded to 32 bytes like the compiler does now\\n                    mstore(0x40, and(add(mc, 31), not(31)))\\n                }\\n                //if we want a zero-length slice let's just return a zero-length array\\n                default {\\n                    tempBytes := mload(0x40)\\n                    mstore(0x40, add(tempBytes, 0x20))\\n                }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    // Pad a bytes array to 32 bytes\\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\\n        return concat(newBytes, _bytes);\\n    }\\n\\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\\n        require(b.length >= 32, \\\"Bytes array should atleast be 32 bytes\\\");\\n        bytes32 out;\\n        for (uint256 i = 0; i < 32; i++) {\\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\\n        assembly {\\n            result := mload(add(b, 32))\\n        }\\n    }\\n\\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\\n        bytes memory b = new bytes(32);\\n        for (uint256 i = 0; i < 32; i++) {\\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\\n        }\\n        return b;\\n    }\\n\\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\\n        _ret = new bytes(32);\\n        assembly {\\n            mstore(add(_ret, 32), _num)\\n        }\\n    }\\n\\n    function toUint(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n        return tempUint;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n        assembly {\\n            tempAddress := div(\\n                mload(add(add(_bytes, 0x20), _start)),\\n                0x1000000000000000000000000\\n            )\\n        }\\n\\n        return tempAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/lib/Common.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"./BytesLib.sol\\\";\\n\\nlibrary Common {\\n    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {\\n        if (chainId > 0) {\\n            return\\n                uint8(\\n                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8\\n                );\\n        } else {\\n            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));\\n        }\\n    }\\n\\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\\n    function isContract(address _addr) public view returns (bool) {\\n        uint256 length;\\n        assembly {\\n            //retrieve the size of the code on target address, this needs assembly\\n            length := extcodesize(_addr)\\n        }\\n        return (length > 0);\\n    }\\n\\n    // convert bytes to uint8\\n    function toUint8(bytes memory _arg) public pure returns (uint8) {\\n        return uint8(_arg[0]);\\n    }\\n\\n    function toUint16(bytes memory _arg) public pure returns (uint16) {\\n        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/math/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Math\\n * @dev Assorted math operations\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Calculates the average of two numbers. Since these are integers,\\n     * averages of an even and odd number cannot be represented, and will be\\n     * rounded down.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/lib/RLPEncode.sol\": {\r\n      \"content\": \"// Library for RLP encoding a list of bytes arrays.\\n// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)\\n// [Very] modified version of Sam Mayo's library.\\npragma solidity ^0.5.2;\\n\\nimport \\\"./BytesLib.sol\\\";\\n\\nlibrary RLPEncode {\\n    // Encode an item (bytes memory)\\n    function encodeItem(bytes memory self)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory encoded;\\n        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {\\n            encoded = new bytes(1);\\n            encoded = self;\\n        } else {\\n            encoded = BytesLib.concat(encodeLength(self.length, 128), self);\\n        }\\n        return encoded;\\n    }\\n\\n    // Encode a list of items\\n    function encodeList(bytes[] memory self)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory encoded;\\n        for (uint256 i = 0; i < self.length; i++) {\\n            encoded = BytesLib.concat(encoded, encodeItem(self[i]));\\n        }\\n        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);\\n    }\\n\\n    // Hack to encode nested lists. If you have a list as an item passed here, included\\n    // pass = true in that index. E.g.\\n    // [item, list, item] --> pass = [false, true, false]\\n    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {\\n    //   bytes memory encoded;\\n    //   for (uint i=0; i < self.length; i++) {\\n    // \\t\\tif (pass[i] == true) {\\n    // \\t\\t\\tencoded = BytesLib.concat(encoded, self[i]);\\n    // \\t\\t} else {\\n    // \\t\\t\\tencoded = BytesLib.concat(encoded, encodeItem(self[i]));\\n    // \\t\\t}\\n    //   }\\n    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);\\n    // }\\n\\n    // Generate the prefix for an item or the entire list based on RLP spec\\n    function encodeLength(uint256 L, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (L < 56) {\\n            bytes memory prefix = new bytes(1);\\n            prefix[0] = bytes1(uint8(L + offset));\\n            return prefix;\\n        } else {\\n            // lenLen is the length of the hex representation of the data length\\n            uint256 lenLen;\\n            uint256 i = 0x1;\\n\\n            while (L / i != 0) {\\n                lenLen++;\\n                i *= 0x100;\\n            }\\n\\n            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);\\n            bytes memory prefix1 = getLengthBytes(L);\\n            return BytesLib.concat(prefix0, prefix1);\\n        }\\n    }\\n\\n    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {\\n        // Figure out if we need 1 or two bytes to express the length.\\n        // 1 byte gets us to max 255\\n        // 2 bytes gets us to max 65535 (no payloads will be larger than this)\\n        uint256 nBytes = 1;\\n        if (x > 255) {\\n            nBytes = 2;\\n        }\\n\\n        b = new bytes(nBytes);\\n        // Encode the length and return it\\n        for (uint256 i = 0; i < nBytes; i++) {\\n            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/lib/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n        // New check to see if the last mempointer of the last read item has moved farther than the parent item is long\\n        require(memPtr - item.memPtr == item.len, \\\"Wrong total length.\\\");\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/lib/ExitPayloadReader.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\nimport {BytesLib} from \\\"./BytesLib.sol\\\";\\n\\nlibrary ExitPayloadReader {\\n  using RLPReader for bytes;\\n  using RLPReader for RLPReader.RLPItem;\\n\\n  uint8 constant WORD_SIZE = 32;\\n\\n  struct ExitPayload {\\n    RLPReader.RLPItem[] data;\\n  }\\n\\n  struct Receipt {\\n    RLPReader.RLPItem[] data;\\n    bytes raw;\\n    uint256 logIndex;\\n  }\\n\\n  struct Log {\\n    RLPReader.RLPItem data;\\n    RLPReader.RLPItem[] list;\\n  }\\n\\n  struct LogTopics {\\n    RLPReader.RLPItem[] data;\\n  }\\n\\n  function toExitPayload(bytes memory data)\\n        internal\\n        pure\\n        returns (ExitPayload memory)\\n    {\\n        RLPReader.RLPItem[] memory payloadData = data\\n            .toRlpItem()\\n            .toList();\\n\\n        return ExitPayload(payloadData);\\n    }\\n\\n    function copy(uint src, uint dest, uint len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[0].toUint();\\n    }\\n\\n    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[1].toBytes();\\n    }\\n\\n    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[2].toUint();\\n    }\\n\\n    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[3].toUint();\\n    }\\n\\n    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {\\n      return bytes32(payload.data[4].toUint());\\n    }\\n\\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {\\n      return bytes32(payload.data[5].toUint());\\n    }\\n\\n    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {\\n      receipt.raw = payload.data[6].toBytes();\\n      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\\n\\n      if (receiptItem.isList()) {\\n          // legacy tx\\n          receipt.data = receiptItem.toList();\\n      } else {\\n          // pop first byte before parsting receipt\\n          bytes memory typedBytes = receipt.raw;\\n          bytes memory result = new bytes(typedBytes.length - 1);\\n          uint256 srcPtr;\\n          uint256 destPtr;\\n          assembly {\\n              srcPtr := add(33, typedBytes)\\n              destPtr := add(0x20, result)\\n          }\\n\\n          copy(srcPtr, destPtr, result.length);\\n          receipt.data = result.toRlpItem().toList();\\n      }\\n\\n      receipt.logIndex = getReceiptLogIndex(payload);\\n      return receipt;\\n    }\\n\\n    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[7].toBytes();\\n    }\\n\\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[8].toBytes();\\n    }\\n\\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[8].toUint();\\n    }\\n\\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[9].toUint();\\n    }\\n\\n    function getTx(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[10].toBytes();\\n    }\\n\\n    function getTxProof(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[11].toBytes();\\n    }\\n    \\n    // Receipt methods\\n    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {\\n        return receipt.raw;\\n    }\\n\\n    function getLog(Receipt memory receipt) internal pure returns(Log memory) {\\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\\n        return Log(logData, logData.toList());\\n    }\\n\\n    // Log methods\\n    function getEmitter(Log memory log) internal pure returns(address) {\\n      return RLPReader.toAddress(log.list[0]);\\n    }\\n\\n    function getTopics(Log memory log) internal pure returns(LogTopics memory) {\\n        return LogTopics(log.list[1].toList());\\n    }\\n\\n    function getData(Log memory log) internal pure returns(bytes memory) {\\n        return log.list[2].toBytes();\\n    }\\n\\n    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {\\n      return log.data.toRlpBytes();\\n    }\\n\\n    // LogTopics methods\\n    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {\\n      return topics.data[index];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/root/predicates/IPredicate.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {RLPReader} from \\\"../../common/lib/RLPReader.sol\\\";\\n\\nimport {Common} from \\\"../../common/lib/Common.sol\\\";\\nimport {RLPEncode} from \\\"../../common/lib/RLPEncode.sol\\\";\\n\\nimport {IWithdrawManager} from \\\"../withdrawManager/IWithdrawManager.sol\\\";\\nimport {IDepositManager} from \\\"../depositManager/IDepositManager.sol\\\";\\nimport {ExitsDataStructure} from \\\"../withdrawManager/WithdrawManagerStorage.sol\\\";\\nimport {ChainIdMixin} from \\\"../../common/mixin/ChainIdMixin.sol\\\";\\n\\ninterface IPredicate {\\n    /**\\n   * @notice Verify the deprecation of a state update\\n   * @param exit ABI encoded PlasmaExit data\\n   * @param inputUtxo ABI encoded Input UTXO data\\n   * @param challengeData RLP encoded data of the challenge reference tx that encodes the following fields\\n   * headerNumber Header block number of which the reference tx was a part of\\n   * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n   * blockNumber Block number of which the reference tx is a part of\\n   * blockTime Reference tx block time\\n   * blocktxRoot Transactions root of block\\n   * blockReceiptsRoot Receipts root of block\\n   * receipt Receipt of the reference transaction\\n   * receiptProof Merkle proof of the reference receipt\\n   * branchMask Merkle proof branchMask for the receipt\\n   * logIndex Log Index to read from the receipt\\n   * tx Challenge transaction\\n   * txProof Merkle proof of the challenge tx\\n   * @return Whether or not the state is deprecated\\n   */\\n    function verifyDeprecation(\\n        bytes calldata exit,\\n        bytes calldata inputUtxo,\\n        bytes calldata challengeData\\n    ) external returns (bool);\\n\\n    function interpretStateUpdate(bytes calldata state)\\n        external\\n        view\\n        returns (bytes memory);\\n    function onFinalizeExit(bytes calldata data) external;\\n}\\n\\ncontract PredicateUtils is ExitsDataStructure, ChainIdMixin {\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    // Bonded exits collaterized at 0.1 ETH\\n    uint256 private constant BOND_AMOUNT = 10**17;\\n\\n    IWithdrawManager internal withdrawManager;\\n    IDepositManager internal depositManager;\\n\\n    modifier onlyWithdrawManager() {\\n        require(\\n            msg.sender == address(withdrawManager),\\n            \\\"ONLY_WITHDRAW_MANAGER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier isBondProvided() {\\n        require(msg.value == BOND_AMOUNT, \\\"Invalid Bond amount\\\");\\n        _;\\n    }\\n\\n    function onFinalizeExit(bytes calldata data) external onlyWithdrawManager {\\n        (, address token, address exitor, uint256 tokenId) = decodeExitForProcessExit(\\n            data\\n        );\\n        depositManager.transferAssets(token, exitor, tokenId);\\n    }\\n\\n    function sendBond() internal {\\n        address(uint160(address(withdrawManager))).transfer(BOND_AMOUNT);\\n    }\\n\\n    function getAddressFromTx(RLPReader.RLPItem[] memory txList)\\n        internal\\n        pure\\n        returns (address signer, bytes32 txHash)\\n    {\\n        bytes[] memory rawTx = new bytes[](9);\\n        for (uint8 i = 0; i <= 5; i++) {\\n            rawTx[i] = txList[i].toBytes();\\n        }\\n        rawTx[6] = networkId;\\n        rawTx[7] = hex\\\"\\\"; // [7] and [8] have something to do with v, r, s values\\n        rawTx[8] = hex\\\"\\\";\\n\\n        txHash = keccak256(RLPEncode.encodeList(rawTx));\\n        signer = ecrecover(\\n            txHash,\\n            Common.getV(txList[6].toBytes(), Common.toUint16(networkId)),\\n            bytes32(txList[7].toUint()),\\n            bytes32(txList[8].toUint())\\n        );\\n        require(signer != address(0), \\\"Invalid signer\\\");\\n    }\\n\\n    function decodeExit(bytes memory data)\\n        internal\\n        pure\\n        returns (PlasmaExit memory)\\n    {\\n        (address owner, address token, uint256 amountOrTokenId, bytes32 txHash, bool isRegularExit) = abi\\n            .decode(data, (address, address, uint256, bytes32, bool));\\n        return\\n            PlasmaExit(\\n                amountOrTokenId,\\n                txHash,\\n                owner,\\n                token,\\n                isRegularExit,\\n                address(0) /* predicate value is not required */\\n            );\\n    }\\n\\n    function decodeExitForProcessExit(bytes memory data)\\n        internal\\n        pure\\n        returns (uint256 exitId, address token, address exitor, uint256 tokenId)\\n    {\\n        (exitId, token, exitor, tokenId) = abi.decode(\\n            data,\\n            (uint256, address, address, uint256)\\n        );\\n    }\\n\\n    function decodeInputUtxo(bytes memory data)\\n        internal\\n        pure\\n        returns (uint256 age, address signer, address predicate, address token)\\n    {\\n        (age, signer, predicate, token) = abi.decode(\\n            data,\\n            (uint256, address, address, address)\\n        );\\n    }\\n\\n}\\n\\ncontract IErcPredicate is IPredicate, PredicateUtils {\\n    enum ExitType {Invalid, OutgoingTransfer, IncomingTransfer, Burnt}\\n\\n    struct ExitTxData {\\n        uint256 amountOrToken;\\n        bytes32 txHash;\\n        address childToken;\\n        address signer;\\n        ExitType exitType;\\n    }\\n\\n    struct ReferenceTxData {\\n        uint256 closingBalance;\\n        uint256 age;\\n        address childToken;\\n        address rootToken;\\n    }\\n\\n    uint256 internal constant MAX_LOGS = 10;\\n\\n    constructor(address _withdrawManager, address _depositManager) public {\\n        withdrawManager = IWithdrawManager(_withdrawManager);\\n        depositManager = IDepositManager(_depositManager);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Registry.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {Governable} from \\\"./governance/Governable.sol\\\";\\nimport {IWithdrawManager} from \\\"../root/withdrawManager/IWithdrawManager.sol\\\";\\n\\n\\ncontract Registry is Governable {\\n    // @todo hardcode constants\\n    bytes32 private constant WETH_TOKEN = keccak256(\\\"wethToken\\\");\\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\\\"depositManager\\\");\\n    bytes32 private constant STAKE_MANAGER = keccak256(\\\"stakeManager\\\");\\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\\\"validatorShare\\\");\\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\\\"withdrawManager\\\");\\n    bytes32 private constant CHILD_CHAIN = keccak256(\\\"childChain\\\");\\n    bytes32 private constant STATE_SENDER = keccak256(\\\"stateSender\\\");\\n    bytes32 private constant SLASHING_MANAGER = keccak256(\\\"slashingManager\\\");\\n\\n    address public erc20Predicate;\\n    address public erc721Predicate;\\n\\n    mapping(bytes32 => address) public contractMap;\\n    mapping(address => address) public rootToChildToken;\\n    mapping(address => address) public childToRootToken;\\n    mapping(address => bool) public proofValidatorContracts;\\n    mapping(address => bool) public isERC721;\\n\\n    enum Type {Invalid, ERC20, ERC721, Custom}\\n    struct Predicate {\\n        Type _type;\\n    }\\n    mapping(address => Predicate) public predicates;\\n\\n    event TokenMapped(address indexed rootToken, address indexed childToken);\\n    event ProofValidatorAdded(address indexed validator, address indexed from);\\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\\n    event PredicateAdded(address indexed predicate, address indexed from);\\n    event PredicateRemoved(address indexed predicate, address indexed from);\\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\\n\\n    constructor(address _governance) public Governable(_governance) {}\\n\\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\\n        contractMap[_key] = _address;\\n    }\\n\\n    /**\\n     * @dev Map root token to child token\\n     * @param _rootToken Token address on the root chain\\n     * @param _childToken Token address on the child chain\\n     * @param _isERC721 Is the token being mapped ERC721\\n     */\\n    function mapToken(\\n        address _rootToken,\\n        address _childToken,\\n        bool _isERC721\\n    ) external onlyGovernance {\\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \\\"INVALID_TOKEN_ADDRESS\\\");\\n        rootToChildToken[_rootToken] = _childToken;\\n        childToRootToken[_childToken] = _rootToken;\\n        isERC721[_rootToken] = _isERC721;\\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\\n        emit TokenMapped(_rootToken, _childToken);\\n    }\\n\\n    function addErc20Predicate(address predicate) public onlyGovernance {\\n        require(predicate != address(0x0), \\\"Can not add null address as predicate\\\");\\n        erc20Predicate = predicate;\\n        addPredicate(predicate, Type.ERC20);\\n    }\\n\\n    function addErc721Predicate(address predicate) public onlyGovernance {\\n        erc721Predicate = predicate;\\n        addPredicate(predicate, Type.ERC721);\\n    }\\n\\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\\n        require(predicates[predicate]._type == Type.Invalid, \\\"Predicate already added\\\");\\n        predicates[predicate]._type = _type;\\n        emit PredicateAdded(predicate, msg.sender);\\n    }\\n\\n    function removePredicate(address predicate) public onlyGovernance {\\n        require(predicates[predicate]._type != Type.Invalid, \\\"Predicate does not exist\\\");\\n        delete predicates[predicate];\\n        emit PredicateRemoved(predicate, msg.sender);\\n    }\\n\\n    function getValidatorShareAddress() public view returns (address) {\\n        return contractMap[VALIDATOR_SHARE];\\n    }\\n\\n    function getWethTokenAddress() public view returns (address) {\\n        return contractMap[WETH_TOKEN];\\n    }\\n\\n    function getDepositManagerAddress() public view returns (address) {\\n        return contractMap[DEPOSIT_MANAGER];\\n    }\\n\\n    function getStakeManagerAddress() public view returns (address) {\\n        return contractMap[STAKE_MANAGER];\\n    }\\n\\n    function getSlashingManagerAddress() public view returns (address) {\\n        return contractMap[SLASHING_MANAGER];\\n    }\\n\\n    function getWithdrawManagerAddress() public view returns (address) {\\n        return contractMap[WITHDRAW_MANAGER];\\n    }\\n\\n    function getChildChainAndStateSender() public view returns (address, address) {\\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\\n    }\\n\\n    function isTokenMapped(address _token) public view returns (bool) {\\n        return rootToChildToken[_token] != address(0x0);\\n    }\\n\\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\\n        require(isTokenMapped(_token), \\\"TOKEN_NOT_MAPPED\\\");\\n        return isERC721[_token];\\n    }\\n\\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\\n        if (isTokenMappedAndIsErc721(_token)) {\\n            return erc721Predicate;\\n        }\\n        return erc20Predicate;\\n    }\\n\\n    function isChildTokenErc721(address childToken) public view returns (bool) {\\n        address rootToken = childToRootToken[childToken];\\n        require(rootToken != address(0x0), \\\"Child token is not mapped\\\");\\n        return isERC721[rootToken];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/root/withdrawManager/WithdrawManagerStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {ProxyStorage} from \\\"../../common/misc/ProxyStorage.sol\\\";\\nimport {Registry} from \\\"../../common/Registry.sol\\\";\\nimport {RootChain} from \\\"../RootChain.sol\\\";\\nimport {ExitNFT} from \\\"./ExitNFT.sol\\\";\\n\\n\\ncontract ExitsDataStructure {\\n    struct Input {\\n        address utxoOwner;\\n        address predicate;\\n        address token;\\n    }\\n\\n    struct PlasmaExit {\\n        uint256 receiptAmountOrNFTId;\\n        bytes32 txHash;\\n        address owner;\\n        address token;\\n        bool isRegularExit;\\n        address predicate;\\n        // Mapping from age of input to Input\\n        mapping(uint256 => Input) inputs;\\n    }\\n}\\n\\n\\ncontract WithdrawManagerHeader is ExitsDataStructure {\\n    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);\\n\\n    event ExitStarted(\\n        address indexed exitor,\\n        uint256 indexed exitId,\\n        address indexed token,\\n        uint256 amount,\\n        bool isRegularExit\\n    );\\n\\n    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);\\n    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);\\n\\n    event ExitCancelled(uint256 indexed exitId);\\n}\\n\\n\\ncontract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {\\n    // 0.5 week = 7 * 86400 / 2 = 302400\\n    uint256 public HALF_EXIT_PERIOD = 302400;\\n\\n    // Bonded exits collaterized at 0.1 ETH\\n    uint256 internal constant BOND_AMOUNT = 10**17;\\n\\n    Registry internal registry;\\n    RootChain internal rootChain;\\n\\n    mapping(uint128 => bool) isKnownExit;\\n    mapping(uint256 => PlasmaExit) public exits;\\n    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)\\n    mapping(bytes32 => uint256) public ownerExits;\\n    mapping(address => address) public exitsQueues;\\n    ExitNFT public exitNft;\\n\\n    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively\\n    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)\\n    // uint32 constant internal ITERATION_GAS = 52000;\\n\\n    // So putting an upper limit of 155000 + 52000 + leeway\\n    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;\\n\\n    uint256 public exitWindow;\\n}\\n\"\r\n    },\r\n    \"contracts/root/withdrawManager/IWithdrawManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract IWithdrawManager {\\n    function createExitQueue(address token) external;\\n\\n    function verifyInclusion(\\n        bytes calldata data,\\n        uint8 offset,\\n        bool verifyTxInclusion\\n    ) external view returns (uint256 age);\\n\\n    function addExitToQueue(\\n        address exitor,\\n        address childToken,\\n        address rootToken,\\n        uint256 exitAmountOrTokenId,\\n        bytes32 txHash,\\n        bool isRegularExit,\\n        uint256 priority\\n    ) external;\\n\\n    function addInput(\\n        uint256 exitId,\\n        uint256 age,\\n        address utxoOwner,\\n        address token\\n    ) external;\\n\\n    function challengeExit(\\n        uint256 exitId,\\n        uint256 inputId,\\n        bytes calldata challengeData,\\n        address adjudicatorPredicate\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/root/depositManager/IDepositManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ninterface IDepositManager {\\n    function depositEther() external payable;\\n    function transferAssets(\\n        address _token,\\n        address _user,\\n        uint256 _amountOrNFTId\\n    ) external;\\n    function depositERC20(address _token, uint256 _amount) external;\\n    function depositERC721(address _token, uint256 _tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/common/mixin/ChainIdMixin.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ChainIdMixin {\\n  bytes constant public networkId = hex\\\"3A99\\\";\\n  uint256 constant public CHAINID = 15001;\\n}\\n\"\r\n    },\r\n    \"contracts/common/governance/Governable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {IGovernance} from \\\"./IGovernance.sol\\\";\\n\\ncontract Governable {\\n    IGovernance public governance;\\n\\n    constructor(address _governance) public {\\n        governance = IGovernance(_governance);\\n    }\\n\\n    modifier onlyGovernance() {\\n        _assertGovernance();\\n        _;\\n    }\\n\\n    function _assertGovernance() private view {\\n        require(\\n            msg.sender == address(governance),\\n            \\\"Only governance contract is authorized\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/misc/ProxyStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\nimport {Ownable} from \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\n\\ncontract ProxyStorage is Ownable {\\n    address internal proxyTo;\\n}\\n\"\r\n    },\r\n    \"contracts/root/RootChain.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {RLPReader} from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\nimport {SafeMath} from \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\nimport {RootChainHeader, RootChainStorage} from \\\"./RootChainStorage.sol\\\";\\n\\nimport {IStakeManager} from \\\"../staking/stakeManager/IStakeManager.sol\\\";\\nimport {IRootChain} from \\\"./IRootChain.sol\\\";\\nimport {Registry} from \\\"../common/Registry.sol\\\";\\n\\n\\ncontract RootChain is RootChainStorage, IRootChain {\\n    using SafeMath for uint256;\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    modifier onlyDepositManager() {\\n        require(msg.sender == registry.getDepositManagerAddress(), \\\"UNAUTHORIZED_DEPOSIT_MANAGER_ONLY\\\");\\n        _;\\n    }\\n\\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {\\n        revert();\\n    }\\n\\n    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {\\n        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi\\n            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));\\n        require(CHAINID == _borChainID, \\\"Invalid bor chain id\\\");\\n\\n        require(_buildHeaderBlock(proposer, start, end, rootHash), \\\"INCORRECT_HEADER_DATA\\\");\\n\\n        // check if it is better to keep it in local storage instead\\n        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());\\n        uint256 _reward = stakeManager.checkSignatures(\\n            end.sub(start).add(1),\\n            /**  \\n                prefix 01 to data \\n                01 represents positive vote on data and 00 is negative vote\\n                malicious validator can try to send 2/3 on negative vote so 01 is appended\\n             */\\n            keccak256(abi.encodePacked(bytes(hex\\\"01\\\"), data)),\\n            accountHash,\\n            proposer,\\n            sigs\\n        );\\n\\n        require(_reward != 0, \\\"Invalid checkpoint\\\");\\n        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);\\n        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);\\n        _blockDepositId = 1;\\n    }\\n\\n    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {\\n        depositId = currentHeaderBlock().add(_blockDepositId);\\n        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)\\n        _blockDepositId = _blockDepositId.add(numDeposits);\\n        require(\\n            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed\\n            _blockDepositId <= MAX_DEPOSITS,\\n            \\\"TOO_MANY_DEPOSITS\\\"\\n        );\\n    }\\n\\n    function getLastChildBlock() external view returns (uint256) {\\n        return headerBlocks[currentHeaderBlock()].end;\\n    }\\n\\n    function slash() external {\\n        //TODO: future implementation\\n    }\\n\\n    function currentHeaderBlock() public view returns (uint256) {\\n        return _nextHeaderBlock.sub(MAX_DEPOSITS);\\n    }\\n\\n    function _buildHeaderBlock(\\n        address proposer,\\n        uint256 start,\\n        uint256 end,\\n        bytes32 rootHash\\n    ) private returns (bool) {\\n        uint256 nextChildBlock;\\n        /*\\n    The ID of the 1st header block is MAX_DEPOSITS.\\n    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0\\n    */\\n        if (_nextHeaderBlock > MAX_DEPOSITS) {\\n            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;\\n        }\\n        if (nextChildBlock != start) {\\n            return false;\\n        }\\n\\n        HeaderBlock memory headerBlock = HeaderBlock({\\n            root: rootHash,\\n            start: nextChildBlock,\\n            end: end,\\n            createdAt: now,\\n            proposer: proposer\\n        });\\n\\n        headerBlocks[_nextHeaderBlock] = headerBlock;\\n        return true;\\n    }\\n\\n    // Housekeeping function. @todo remove later\\n    function setNextHeaderBlock(uint256 _value) public onlyOwner {\\n        require(_value % MAX_DEPOSITS == 0, \\\"Invalid value\\\");\\n        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {\\n            delete headerBlocks[i];\\n        }\\n        _nextHeaderBlock = _value;\\n        _blockDepositId = 1;\\n        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);\\n    }\\n\\n    // Housekeeping function. @todo remove later\\n    function setHeimdallId(string memory _heimdallId) public onlyOwner {\\n        heimdallId = keccak256(abi.encodePacked(_heimdallId));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/root/withdrawManager/ExitNFT.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {ERC721} from \\\"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\\\";\\nimport {Registry} from \\\"../../common/Registry.sol\\\";\\n\\ncontract ExitNFT is ERC721 {\\n    Registry internal registry;\\n\\n    modifier onlyWithdrawManager() {\\n        require(\\n            msg.sender == registry.getWithdrawManagerAddress(),\\n            \\\"UNAUTHORIZED_WITHDRAW_MANAGER_ONLY\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _registry) public {\\n        registry = Registry(_registry);\\n    }\\n\\n    function mint(address _owner, uint256 _tokenId)\\n        external\\n        onlyWithdrawManager\\n    {\\n        _mint(_owner, _tokenId);\\n    }\\n\\n    function burn(uint256 _tokenId) external onlyWithdrawManager {\\n        _burn(_tokenId);\\n    }\\n\\n    function exists(uint256 tokenId) public view returns (bool) {\\n        return _exists(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/governance/IGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ninterface IGovernance {\\n    function update(address target, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/solidity-rlp/contracts/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/root/RootChainStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {Registry} from \\\"../common/Registry.sol\\\";\\nimport {ProxyStorage} from \\\"../common/misc/ProxyStorage.sol\\\";\\nimport {ChainIdMixin} from \\\"../common/mixin/ChainIdMixin.sol\\\";\\n\\n\\ncontract RootChainHeader {\\n    event NewHeaderBlock(\\n        address indexed proposer,\\n        uint256 indexed headerBlockId,\\n        uint256 indexed reward,\\n        uint256 start,\\n        uint256 end,\\n        bytes32 root\\n    );\\n    // housekeeping event\\n    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n}\\n\\n\\ncontract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {\\n    bytes32 public heimdallId;\\n    uint8 public constant VOTE_TYPE = 2;\\n\\n    uint16 internal constant MAX_DEPOSITS = 10000;\\n    uint256 public _nextHeaderBlock = MAX_DEPOSITS;\\n    uint256 internal _blockDepositId = 1;\\n    mapping(uint256 => HeaderBlock) public headerBlocks;\\n    Registry internal registry;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/stakeManager/IStakeManager.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\ncontract IStakeManager {\\n    // validator replacement\\n    function startAuction(\\n        uint256 validatorId,\\n        uint256 amount,\\n        bool acceptDelegation,\\n        bytes calldata signerPubkey\\n    ) external;\\n\\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\\n\\n    function transferFunds(\\n        uint256 validatorId,\\n        uint256 amount,\\n        address delegator\\n    ) external returns (bool);\\n\\n    function delegationDeposit(\\n        uint256 validatorId,\\n        uint256 amount,\\n        address delegator\\n    ) external returns (bool);\\n\\n    function unstake(uint256 validatorId) external;\\n\\n    function totalStakedFor(address addr) external view returns (uint256);\\n\\n    function stakeFor(\\n        address user,\\n        uint256 amount,\\n        uint256 heimdallFee,\\n        bool acceptDelegation,\\n        bytes memory signerPubkey\\n    ) public;\\n\\n    function checkSignatures(\\n        uint256 blockInterval,\\n        bytes32 voteHash,\\n        bytes32 stateRoot,\\n        address proposer,\\n        uint[3][] calldata sigs\\n    ) external returns (uint256);\\n\\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\\n\\n    function ownerOf(uint256 tokenId) public view returns (address);\\n\\n    function slash(bytes calldata slashingInfoList) external returns (uint256);\\n\\n    function validatorStake(uint256 validatorId) public view returns (uint256);\\n\\n    function epoch() public view returns (uint256);\\n\\n    function getRegistry() public view returns (address);\\n\\n    function withdrawalDelay() public view returns (uint256);\\n\\n    function delegatedAmount(uint256 validatorId) public view returns(uint256);\\n\\n    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\\n\\n    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\\n\\n    function delegatorsReward(uint256 validatorId) public view returns(uint256);\\n\\n    function dethroneAndStake(\\n        address auctionUser,\\n        uint256 heimdallFee,\\n        uint256 validatorId,\\n        uint256 auctionAmount,\\n        bool acceptDelegation,\\n        bytes calldata signerPubkey\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/root/IRootChain.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n\\ninterface IRootChain {\\n    function slash() external;\\n\\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)\\n        external;\\n    \\n    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)\\n        external;\\n\\n    function getLastChildBlock() external view returns (uint256);\\n\\n    function currentHeaderBlock() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../drafts/Counters.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is ERC165, IERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using Counters for Counters.Counter;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from token ID to owner\\n    mapping (uint256 => address) private _tokenOwner;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to number of owned token\\n    mapping (address => Counters.Counter) private _ownedTokensCount;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    /*\\n     * 0x80ac58cd ===\\n     *     bytes4(keccak256('balanceOf(address)')) ^\\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\\n     *     bytes4(keccak256('approve(address,uint256)')) ^\\n     *     bytes4(keccak256('getApproved(uint256)')) ^\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\\n     */\\n\\n    constructor () public {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address\\n     * @param owner address to query the balance of\\n     * @return uint256 representing the amount owned by the passed address\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0));\\n        return _ownedTokensCount[owner].current();\\n    }\\n\\n    /**\\n     * @dev Gets the owner of the specified token ID\\n     * @param tokenId uint256 ID of the token to query the owner of\\n     * @return address currently marked as the owner of the given token ID\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0));\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Approves another address to transfer the given token ID\\n     * The zero address indicates there is no approved address.\\n     * There can only be one approved address per token at a given time.\\n     * Can only be called by the token owner or an approved operator.\\n     * @param to address to be approved for the given token ID\\n     * @param tokenId uint256 ID of the token to be approved\\n     */\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner);\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the approved address for a token ID, or zero if no address set\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to query the approval of\\n     * @return address currently approved for the given token ID\\n     */\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId));\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Sets or unsets the approval of a given operator\\n     * An operator is allowed to transfer all tokens of the sender on their behalf\\n     * @param to operator address to set the approval\\n     * @param approved representing the status of the approval to be set\\n     */\\n    function setApprovalForAll(address to, bool approved) public {\\n        require(to != msg.sender);\\n        _operatorApprovals[msg.sender][to] = approved;\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    /**\\n     * @dev Tells whether an operator is approved by a given owner\\n     * @param owner owner address which you want to query the approval of\\n     * @param operator operator address which you want to query the approval of\\n     * @return bool whether the given operator is approved by the given owner\\n     */\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Transfers the ownership of a given token ID to another address\\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId));\\n\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\\n        transferFrom(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data));\\n    }\\n\\n    /**\\n     * @dev Returns whether the specified token exists\\n     * @param tokenId uint256 ID of the token to query the existence of\\n     * @return bool whether the token exists\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether the given spender can transfer a given token ID\\n     * @param spender address of the spender to query\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @return bool whether the msg.sender is approved for the given token ID,\\n     * is an operator of the owner, or is the owner of the token\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token\\n     * Reverts if the given token ID already exists\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0));\\n        require(!_exists(tokenId));\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to].increment();\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token\\n     * Reverts if the token does not exist\\n     * Deprecated, use _burn(uint256) instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == owner);\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[owner].decrement();\\n        _tokenOwner[tokenId] = address(0);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token\\n     * Reverts if the token does not exist\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        _burn(ownerOf(tokenId), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from);\\n        require(to != address(0));\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from].decrement();\\n        _ownedTokensCount[to].increment();\\n\\n        _tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke `onERC721Received` on a target address\\n     * The call is not executed if the target address is not a contract\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /**\\n     * @dev Private function to clear current approval of a given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     * after a `safeTransfer`. This function MUST return the function selector,\\n     * otherwise the caller will revert the transaction. The selector to be\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\n     * function MAY throw to revert and reject the transfer.\\n     * Note: the ERC721 contract address is always the message sender.\\n     * @param operator The address which called `safeTransferFrom` function\\n     * @param from The address which previously owned the token\\n     * @param tokenId The NFT identifier which is being transferred\\n     * @param data Additional data with no specified format\\n     * @return bytes4 `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param account address of the account to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/drafts/Counters.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title ERC165\\n * @author Matt Condon (@shrugs)\\n * @dev Implements ERC165 using a lookup table.\\n */\\ncontract ERC165 is IERC165 {\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n    /*\\n     * 0x01ffc9a7 ===\\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\\n     */\\n\\n    /**\\n     * @dev a mapping of interface id to whether or not it's supported\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev A contract implementing SupportsInterfaceWithLookup\\n     * implement ERC165 itself\\n     */\\n    constructor () internal {\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev implement supportsInterface(bytes4) using a lookup table\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev internal method for registering an interface\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff);\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/openzeppelin-solidity/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title IERC165\\n * @dev https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin-solidity/=node_modules/openzeppelin-solidity/\",\r\n      \"solidity-rlp/=node_modules/solidity-rlp/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"state\",\"type\":\"bytes\"}],\"name\":\"interpretStateUpdate\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"networkId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFinalizeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"startExitWithBurntTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"exit\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"inputUtxo\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"challengeData\",\"type\":\"bytes\"}],\"name\":\"verifyDeprecation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20PredicateBurnOnly", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002a88696e0ffa76baa1338f2c74497cc013495922000000000000000000000000401f6c983ea34274ec46f84d70b31c151321188b", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}