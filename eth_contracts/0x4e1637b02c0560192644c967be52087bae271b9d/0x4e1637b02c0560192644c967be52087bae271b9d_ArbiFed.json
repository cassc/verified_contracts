{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/arbi-fed/ArbiFed.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nimport \\\"src/interfaces/IERC20.sol\\\";\\nimport \\\"src/interfaces/velo/IDola.sol\\\";\\nimport \\\"src/interfaces/velo/IL1ERC20Bridge.sol\\\";\\nimport {IL1GatewayRouter} from \\\"arbitrum/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol\\\";\\n\\ncontract ArbiFed {\\n    address public chair;\\n    address public gov;\\n    address public l2Chair;\\n    uint public underlyingSupply;\\n    uint public gasLimit;\\n    uint public maxSubmissionCost;\\n\\n    IDola public immutable DOLA = IDola(0x865377367054516e17014CcdED1e7d814EDC9ce4);\\n    IL1GatewayRouter public immutable gatewayRouter = IL1GatewayRouter(0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef); \\n    IL1GatewayRouter  public immutable gateway = IL1GatewayRouter(0xb4299A1F5f26fF6a98B7BA35572290C359fde900);\\n    address public immutable l1ERC20Gateway = 0xa3A7B6F88361F48403514059F1F16C8E78d60EeC;\\n\\n    address public auraFarmer; // On L2\\n\\n    event Expansion(uint amount);\\n    event Contraction(uint amount);\\n\\n    error OnlyGov();\\n    error OnlyChair();\\n    error OnlyGuardian();\\n    error CantBurnZeroDOLA();\\n    error DeltaAboveMax();\\n    error ZeroGasPriceBid();\\n    error InsufficientGasFunds();\\n    \\n    constructor(\\n            address gov_,\\n            address auraFarmer_,\\n            address chair_,\\n            address l2Chair_)\\n    {\\n        chair = chair_;\\n        gov = gov_;\\n        auraFarmer = auraFarmer_;\\n        l2Chair = l2Chair_;\\n\\n        DOLA.approve(address(l1ERC20Gateway), type(uint).max); \\n    }\\n\\n    modifier onlyGov {\\n        if (msg.sender != gov) revert OnlyGov();\\n        _;\\n    }\\n\\n    modifier onlyChair {\\n        if (msg.sender != chair) revert OnlyChair();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Mints & deposits `amountToBridge` of DOLA into Arbitrum Gateway to the `auraFarmer` contract\\n     * @param amountToBridge Amount of underlying token to briged into Aura farmer on Arbitrum\\n     * @param gasPriceBid Price per gas unit in ethereum as measured in wei\\n     */\\n    function expansion(uint amountToBridge, uint256 gasPriceBid) external payable onlyChair {\\n        if (gasPriceBid == 0) revert ZeroGasPriceBid();\\n        if (msg.value < maxSubmissionCost + gasLimit * gasPriceBid) revert InsufficientGasFunds();\\n        uint dolaBal = DOLA.balanceOf(address(this));\\n        if(dolaBal < amountToBridge){\\n            uint amountToMint = amountToBridge - dolaBal;\\n            underlyingSupply += amountToMint;\\n            DOLA.mint(address(this), amountToMint);\\n            emit Expansion(amountToMint);\\n        }\\n        bytes memory data = abi.encode(maxSubmissionCost, \\\"\\\");\\n\\n        gatewayRouter.outboundTransferCustomRefund{value: msg.value}(\\n            address(DOLA),\\n            l2Chair,\\n            auraFarmer,\\n            amountToBridge,\\n            gasLimit, \\n            gasPriceBid, \\n            data\\n        );\\n\\n    }\\n\\n    /**\\n     * @notice Burns `amountUnderlying` of DOLA held in this contract\\n     * @param amountUnderlying Amount of underlying DOLA to burn\\n     */\\n    function contraction(uint amountUnderlying) external onlyChair {\\n\\n        _contraction(amountUnderlying);\\n    }\\n\\n    /**\\n     * @notice Attempts to contract (burn) all DOLA held by this contract\\n     */\\n    function contractAll() external onlyChair {\\n\\n        _contraction(DOLA.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * @notice Attempts to contract (burn) `amount` of DOLA. Sends remainder to `gov` if `amount` > DOLA minted by this fed.\\n     * @param amount Amount to contract\\n     */\\n    function _contraction(uint amount) internal {\\n        if (amount == 0) revert CantBurnZeroDOLA();\\n        if(amount > underlyingSupply){\\n            DOLA.burn(underlyingSupply);\\n            DOLA.transfer(gov, amount - underlyingSupply);\\n            emit Contraction(underlyingSupply);\\n            underlyingSupply = 0;\\n        } else {\\n            DOLA.burn(amount);\\n            underlyingSupply -= amount;\\n            emit Contraction(amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Method for current chair of the Arbi FED to resign\\n     */\\n    function resign() external onlyChair {\\n        chair = address(0);\\n    }\\n\\n    /**\\n     * @notice Fedchair function for setting the max submission cost as measured in wei\\n     * @dev The max submission cost is the cost of having a ticket resubmitted and kept in memory in case of it not going through the first time due to high gas on L1\\n     * @param newMaxSubmissionCost new max submission cost\\n     */\\n    function setMaxSubmissionCost(uint newMaxSubmissionCost) external onlyChair {\\n        maxSubmissionCost = newMaxSubmissionCost; \\n    }\\n    \\n    /**\\n     * @notice Sets the gas limit for calls made on the Arbitrum network by the bridge\\n     * @param newGasLimit The new gas limit\\n     */\\n    function setGasLimit(uint newGasLimit) external onlyChair {\\n        gasLimit = newGasLimit;\\n    }\\n\\n    /**\\n     * @notice Method for gov to change gov address\\n     */\\n    function changeGov(address newGov) external onlyGov {\\n        gov = newGov;\\n    }\\n\\n    /**\\n     * @notice Method for gov to change the chair\\n     */\\n    function changeChair(address newChair) external onlyGov {\\n        chair = newChair;\\n    }\\n\\n    /**\\n     * @notice Method for gov to change the chair\\n     * @dev Address that will receive excess gas on arbitrum\\n     */\\n    function changeL2Chair(address newL2Chair) external onlyGov {\\n        l2Chair = newL2Chair;\\n    }\\n\\n    /**\\n     * @notice Method for gov to change the L2 auraFarmer address\\n     */\\n    function changeAuraFarmer(address newAuraFarmer) external onlyGov {\\n        auraFarmer = newAuraFarmer;\\n    }\\n\\n    /**\\n     * @notice Method for gov to withdraw any ERC20 token from this contract\\n     */\\n    function emergecyWithdraw(address token, address to, uint256 amount) external onlyGov {\\n        IERC20(token).transfer(to, amount);\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n\\n     * @dev Returns the decimal points used by the token.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     \\n    * @dev Returns the amount of tokens owned by `account`.\\n    */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n    \\n    /**\\n     * @dev Burns `amount` of token, shringking total supply\\n     */\\n    function burn(uint amount) external;\\n\\n    /**\\n     * @dev Mints `amount` of token to address `to` increasing total supply\\n     */\\n    function mint(address to, uint amount) external;\\n\\n    //For testing\\n    function addMinter(address minter_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/velo/IDola.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IDola {\\n    function decimals() external view returns (uint8);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function mint(address recipient, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function addMinter(address minter) external;\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/velo/IL1ERC20Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IL1ERC20Bridge\\n */\\ninterface IL1ERC20Bridge {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event ERC20DepositInitiated(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event ERC20WithdrawalFinalized(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @dev get the address of the corresponding L2 bridge contract.\\n     * @return Address of the corresponding L2 bridge contract.\\n     */\\n    function l2TokenBridge() external returns (address);\\n\\n    /**\\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _amount Amount of the ERC20 to deposit\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _to L2 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\\n     * L1 ERC20 token.\\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\\n     *\\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\\n     * @param _from L2 address initiating the transfer.\\n     * @param _to L1 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _data Data provided by the sender on L2. This data is provided\\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *   length, these contracts provide no guarantees about its content.\\n     */\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external;\\n}\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"../../libraries/gateway/ITokenGateway.sol\\\";\\nimport \\\"../../libraries/IERC165.sol\\\";\\n\\n/**\\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\\n * @notice Router also serves as an L1-L2 token address oracle.\\n */\\ninterface IL1GatewayRouter is ITokenGateway, IERC165 {\\n    /**\\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum using the registered or otherwise default gateway\\n     * @dev Some legacy gateway might not have the outboundTransferCustomRefund method and will revert, in such case use outboundTransfer instead\\n     *      L2 address alias will not be applied to the following types of addresses on L1:\\n     *      - an externally-owned account\\n     *      - a contract in construction\\n     *      - an address where a contract will be created\\n     *      - an address where a contract lived, but was destroyed\\n     * @param _token L1 address of ERC20\\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\\n     * @param _amount Token Amount\\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\\n     * @param _gasPriceBid Gas price for L2 execution\\n     * @param _data encoded data from router and user\\n     * @return res abi encoded inbox sequence number\\n     */\\n    function outboundTransferCustomRefund(\\n        address _token,\\n        address _refundTo,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    /**\\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\\n     * @param _gateway l1 gateway address\\n     * @param _maxGas max gas for L2 retryable exrecution\\n     * @param _gasPriceBid gas price for L2 retryable ticket\\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\\n     * @param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\\n     * @return Retryable ticket ID\\n     */\\n    function setGateway(\\n        address _gateway,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        uint256 _maxSubmissionCost,\\n        address _creditBackAddress\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\\n     * @param _gateway l1 gateway address\\n     * @param _maxGas max gas for L2 retryable exrecution\\n     * @param _gasPriceBid gas price for L2 retryable ticket\\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\\n     * @return Retryable ticket ID\\n     */\\n    function setGateway(\\n        address _gateway,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        uint256 _maxSubmissionCost\\n    ) external payable returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function inbox() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface ITokenGateway {\\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\\n    // event OutboundTransferInitiated(\\n    //     address token,\\n    //     address indexed _from,\\n    //     address indexed _to,\\n    //     uint256 indexed _transferId,\\n    //     uint256 _amount,\\n    //     bytes _data\\n    // );\\n\\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\\n    // event InboundTransferFinalized(\\n    //     address token,\\n    //     address indexed _from,\\n    //     address indexed _to,\\n    //     uint256 indexed _transferId,\\n    //     uint256 _amount,\\n    //     bytes _data\\n    // );\\n\\n    function outboundTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    function finalizeInboundTransfer(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external payable;\\n\\n    /**\\n     * @notice Calculate the address used when bridging an ERC20 token\\n     * @dev the L1 and L2 address oracles may not always be in sync.\\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\\n     * @param l1ERC20 address of L1 token\\n     * @return L2 address of a bridged ERC20 token\\n     */\\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\\n\\n    function getOutboundCalldata(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/libraries/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\n// With pragma modification to allow interface compatibility with >=0.6.9 <0.9.0\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.6/contracts/utils/introspection/IERC165.sol\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"arbitrum-nitro/=lib/arbitrum-nitro/\",\r\n      \"arbitrum/=lib/arbitrum/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gov_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auraFarmer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chair_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Chair_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CantBurnZeroDOLA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeltaAboveMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientGasFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyChair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGov\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroGasPriceBid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Contraction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Expansion\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOLA\",\"outputs\":[{\"internalType\":\"contract IDola\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auraFarmer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAuraFarmer\",\"type\":\"address\"}],\"name\":\"changeAuraFarmer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newChair\",\"type\":\"address\"}],\"name\":\"changeChair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"changeGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newL2Chair\",\"type\":\"address\"}],\"name\":\"changeL2Chair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"contraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergecyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToBridge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"}],\"name\":\"expansion\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IL1GatewayRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatewayRouter\",\"outputs\":[{\"internalType\":\"contract IL1GatewayRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1ERC20Gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2Chair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGasLimit\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxSubmissionCost\",\"type\":\"uint256\"}],\"name\":\"setMaxSubmissionCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ArbiFed", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000011ec78492d53c9276dd7a184b1dbfb34e50b710d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000008f97cca30dbe80e7a8b462f1dd1a51c32accdfc8000000000000000000000000a3e46b3bef1366ac066edcb54e0bcf97feda8923", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}