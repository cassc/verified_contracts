{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/DegenBoxConvexWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport {SafeApproveLib} from \\\"libraries/SafeApproveLib.sol\\\";\\nimport {IBentoBoxV1} from \\\"interfaces/IBentoBoxV1.sol\\\";\\nimport {IConvexWrapper} from \\\"interfaces/IConvexWrapper.sol\\\";\\n\\n/// @notice Wrap token to ConvexWrapper and deposit into DegenBox for recipient\\n/// Need to be used atomically, do not transfer fund in it and then wrap / unwrap on another block as\\n/// it could be retrieved by anyone else, by calling deposit or withdraw.\\ncontract DegenBoxConvexWrapper {\\n    using SafeApproveLib for IERC20;\\n\\n    IBentoBoxV1 immutable degenBox;\\n    IConvexWrapper immutable wrapper;\\n    IERC20 immutable underlying;\\n\\n    constructor(IBentoBoxV1 _degenBox, IConvexWrapper _wrapper) {\\n        degenBox = _degenBox;\\n        wrapper = _wrapper;\\n\\n        IERC20 _underlying = IERC20(wrapper.curveToken());\\n        _underlying.approve(address(wrapper), type(uint256).max);\\n        _underlying.approve(address(degenBox), type(uint256).max);\\n        underlying = _underlying;\\n    }\\n\\n    function wrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\\n        wrapper.deposit(amount, address(degenBox));\\n        return degenBox.deposit(IERC20(address(wrapper)), address(degenBox), recipient, amount, 0);\\n    }\\n\\n    function unwrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\\n        wrapper.withdrawAndUnwrap(amount);\\n        return degenBox.deposit(underlying, address(this), recipient, amount, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\\n    // By removing them you can't accidentally use them.\\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ninterface IStrictERC20 {\\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeApproveLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\n\\nlibrary SafeApproveLib {\\n    error ErrApproveFailed();\\n    error ErrApproveFailedWithData(bytes data);\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeCall(IERC20.approve, (to, value)));\\n        if (!success) {\\n            revert ErrApproveFailed();\\n        }\\n        if (data.length != 0 && !abi.decode(data, (bool))) {\\n            revert ErrApproveFailedWithData(data);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"src/interfaces/IBentoBoxV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport {Rebase} from \\\"BoringSolidity/libraries/BoringRebase.sol\\\";\\nimport {IStrategy} from \\\"interfaces/IStrategy.sol\\\";\\n\\ninterface IFlashBorrower {\\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param token The address of the token that is loaned.\\n    /// @param amount of the `token` that is loaned.\\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onFlashLoan(\\n        address sender,\\n        IERC20 token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBatchFlashBorrower {\\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onBatchFlashLoan(\\n        address sender,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        uint256[] calldata fees,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBentoBoxV1 {\\n    function balanceOf(IERC20, address) external view returns (uint256);\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\n\\n    function batchFlashLoan(\\n        IBatchFlashBorrower borrower,\\n        address[] calldata receivers,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function claimOwnership() external;\\n\\n    function flashLoan(\\n        IFlashBorrower borrower,\\n        address receiver,\\n        IERC20 token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function deploy(\\n        address masterContract,\\n        bytes calldata data,\\n        bool useCreate2\\n    ) external payable returns (address);\\n\\n    function deposit(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    function harvest(\\n        IERC20 token,\\n        bool balance,\\n        uint256 maxChangeAmount\\n    ) external;\\n\\n    function masterContractApproved(address, address) external view returns (bool);\\n\\n    function masterContractOf(address) external view returns (address);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function pendingStrategy(IERC20) external view returns (IStrategy);\\n\\n    function permitToken(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function registerProtocol() external;\\n\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\\n\\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\\n\\n    function strategy(IERC20) external view returns (IStrategy);\\n\\n    function strategyData(IERC20)\\n        external\\n        view\\n        returns (\\n            uint64 strategyStartDate,\\n            uint64 targetPercentage,\\n            uint128 balance\\n        );\\n\\n    function toAmount(\\n        IERC20 token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n\\n    function toShare(\\n        IERC20 token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n\\n    function totals(IERC20) external view returns (Rebase memory totals_);\\n\\n    function transfer(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function transferMultiple(\\n        IERC20 token,\\n        address from,\\n        address[] calldata tos,\\n        uint256[] calldata shares\\n    ) external;\\n\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) external;\\n\\n    function whitelistMasterContract(address masterContract, bool approved) external;\\n\\n    function whitelistedMasterContracts(address) external view returns (bool);\\n\\n    function withdraw(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IConvexWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IConvexWrapper {\\n    struct EarnedData {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function addRewards() external;\\n\\n    function addTokenReward(address _token) external;\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function cauldrons(uint256) external view returns (address);\\n\\n    function cauldronsLength() external view returns (uint256);\\n\\n    function collateralVault() external view returns (address);\\n\\n    function convexBooster() external view returns (address);\\n\\n    function convexPool() external view returns (address);\\n\\n    function convexPoolId() external view returns (uint256);\\n\\n    function convexToken() external view returns (address);\\n\\n    function crv() external view returns (address);\\n\\n    function curveToken() external view returns (address);\\n\\n    function cvx() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    function deposit(uint256 _amount, address _to) external;\\n\\n    function earmarkRewards() external returns (bool);\\n\\n    function earned(address _account) external returns (EarnedData[] memory claimable);\\n\\n    function factory() external view returns (address);\\n\\n    function getReward(address _account, address _forwardTo) external;\\n\\n    function getReward(address _account) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function initialize(uint256 _poolId) external;\\n\\n    function invalidateReward(address _token) external;\\n\\n    function isInit() external view returns (bool);\\n\\n    function isShutdown() external view returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function owner() external view returns (address);\\n\\n    function registeredRewards(address) external view returns (uint256);\\n\\n    function renounceOwnership() external;\\n\\n    function rewardHook() external view returns (address);\\n\\n    function rewardLength() external view returns (uint256);\\n\\n    function rewardRedirect(address) external view returns (address);\\n\\n    function rewards(\\n        uint256\\n    ) external view returns (address reward_token, address reward_pool, uint256 reward_integral, uint256 reward_remaining);\\n\\n    function setApprovals() external;\\n\\n    function setCauldron(address _cauldron) external;\\n\\n    function setHook(address _hook) external;\\n\\n    function setRewardRedirect(address _to) external;\\n\\n    function shutdown() external;\\n\\n    function stake(uint256 _amount, address _to) external;\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalBalanceOf(address _account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function user_checkpoint(address _account) external returns (bool);\\n\\n    function withdraw(uint256 _amount) external;\\n\\n    function withdrawAndUnwrap(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringRebase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {BoringMath, BoringMath128} from \\\"./BoringMath.sol\\\";\\n\\nstruct Rebase {\\n    uint128 elastic;\\n    uint128 base;\\n}\\n\\n/// @notice A rebasing library using overflow-/underflow-safe math.\\nlibrary RebaseLibrary {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n\\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\\n    function toBase(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (uint256 base) {\\n        if (total.elastic == 0) {\\n            base = elastic;\\n        } else {\\n            base = (elastic * total.base) / total.elastic;\\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\\n                base++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\\n    function toElastic(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (uint256 elastic) {\\n        if (total.base == 0) {\\n            elastic = base;\\n        } else {\\n            elastic = (base * total.elastic) / total.base;\\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\\n                elastic++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\\n    /// @return (Rebase) The new total.\\n    /// @return base in relationship to `elastic`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 base) {\\n        base = toBase(total, elastic, roundUp);\\n        total.elastic += elastic.to128();\\n        total.base += base.to128();\\n        return (total, base);\\n    }\\n\\n    /// @notice Sub `base` from `total` and update `total.elastic`.\\n    /// @return (Rebase) The new total.\\n    /// @return elastic in relationship to `base`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 elastic) {\\n        elastic = toElastic(total, base, roundUp);\\n        total.elastic -= elastic.to128();\\n        total.base -= base.to128();\\n        return (total, elastic);\\n    }\\n\\n    /// @notice Add `elastic` and `base` to `total`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic += elastic.to128();\\n        total.base += base.to128();\\n        return total;\\n    }\\n\\n    /// @notice Subtract `elastic` and `base` to `total`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic -= elastic.to128();\\n        total.base -= base.to128();\\n        return total;\\n    }\\n\\n    /// @notice Add `elastic` to `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic += elastic.to128();\\n    }\\n\\n    /// @notice Subtract `elastic` from `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic -= elastic.to128();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IStrategy {\\n    function skim(uint256 amount) external;\\n\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\n\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\n\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary BoringMath {\\n    error ErrOverflow();\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function to32(uint256 a) internal pure returns (uint32) {\\n        if (a > type(uint32).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint32(a);\\n    }\\n\\n    function to40(uint256 a) internal pure returns (uint40) {\\n        if (a > type(uint40).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint40(a);\\n    }\\n\\n    function to64(uint256 a) internal pure returns (uint64) {\\n        if (a > type(uint64).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint64(a);\\n    }\\n\\n    function to112(uint256 a) internal pure returns (uint112) {\\n        if (a > type(uint112).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint112(a);\\n    }\\n\\n    function to128(uint256 a) internal pure returns (uint128) {\\n        if (a > type(uint128).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint128(a);\\n    }\\n\\n    function to208(uint256 a) internal pure returns (uint208) {\\n        if (a > type(uint208).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint208(a);\\n    }\\n\\n    function to216(uint256 a) internal pure returns (uint216) {\\n        if (a > type(uint216).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint216(a);\\n    }\\n\\n    function to224(uint256 a) internal pure returns (uint224) {\\n        if (a > type(uint224).max) {\\n            revert ErrOverflow();\\n        }\\n        return uint224(a);\\n    }\\n}\\n\\nlibrary BoringMath32 {\\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a + b;\\n    }\\n\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a - b;\\n    }\\n\\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a * b;\\n    }\\n\\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a / b;\\n    }\\n}\\n\\nlibrary BoringMath64 {\\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a + b;\\n    }\\n\\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a - b;\\n    }\\n\\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a * b;\\n    }\\n\\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a / b;\\n    }\\n}\\n\\nlibrary BoringMath112 {\\n    function add(uint112 a, uint112 b) internal pure returns (uint112) {\\n        return a + b;\\n    }\\n\\n    function sub(uint112 a, uint112 b) internal pure returns (uint112) {\\n        return a - b;\\n    }\\n\\n    function mul(uint112 a, uint112 b) internal pure returns (uint112) {\\n        return a * b;\\n    }\\n\\n    function div(uint112 a, uint112 b) internal pure returns (uint112) {\\n        return a / b;\\n    }\\n}\\n\\nlibrary BoringMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a + b;\\n    }\\n\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a - b;\\n    }\\n\\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a * b;\\n    }\\n\\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a / b;\\n    }\\n}\\n\\nlibrary BoringMath224 {\\n    function add(uint224 a, uint224 b) internal pure returns (uint224) {\\n        return a + b;\\n    }\\n\\n    function sub(uint224 a, uint224 b) internal pure returns (uint224) {\\n        return a - b;\\n    }\\n\\n    function mul(uint224 a, uint224 b) internal pure returns (uint224) {\\n        return a * b;\\n    }\\n\\n    function div(uint224 a, uint224 b) internal pure returns (uint224) {\\n        return a / b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"BoringSolidity/=lib/BoringSolidity/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"utils/=utils/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"cauldrons/=src/cauldrons/\",\r\n      \"staking/=src/staking/\",\r\n      \"swappers/=src/swappers/\",\r\n      \"oracles/=src/oracles/\",\r\n      \"strategies/=src/strategies/\",\r\n      \"tokens/=src/tokens/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"mixins/=src/mixins/\",\r\n      \"lenses/=src/lenses/\",\r\n      \"surl/=lib/surl/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-deploy/=lib/forge-deploy/contracts/\",\r\n      \"ExcessivelySafeCall/=lib/ExcessivelySafeCall/src/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"fuzzlib/=lib/fuzzlib/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"_degenBox\",\"type\":\"address\"},{\"internalType\":\"contract IConvexWrapper\",\"name\":\"_wrapper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DegenBoxConvexWrapper", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "000000000000000000000000d96f48665a1410c0cd669a88898eca36b9fc2cce0000000000000000000000009447c1413da928af354a114954bfc9e6114c5646", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}