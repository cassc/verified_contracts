{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DoomsdaySettlersV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"./interfaces/IERC721TokenReceiver.sol\\\";\\nimport \\\"./interfaces/IDoomsdaySettlersDarkAge.sol\\\";\\nimport \\\"./interfaces/IDoomsdaySettlersMetadata.sol\\\";\\nimport \\\"./interfaces/IDoomsdaySettlersBlacklist.sol\\\";\\n\\ncontract DoomsdaySettlersV2 {\\n\\n    struct Settlement{\\n        uint32 settleBlock;\\n        uint24 supplyAtMint;\\n        uint16 age;\\n        uint8 settlementType;\\n        uint80 relics;\\n        uint80 supplies;\\n    }\\n\\n    uint80 constant CREATOR_PERCENT = 15;\\n    uint80 constant DESTRUCTION_FEE = 0.01 ether;\\n    uint80 constant DAMAGE_FEE      = 0.008 ether;\\n    uint80 constant REINFORCE_PERCENT_WINNER  = 85;\\n    uint80 constant REINFORCE_PERCENT_CREATOR = 15;\\n    uint256 constant BLOCK_TIME = 12 seconds;\\n    uint256 constant DISASTER_BLOCK_INTERVAL = 75;\\n\\n    uint256 immutable BASE_DIFFICULTY;\\n    uint256 immutable DIFFICULTY_RAMP;\\n    uint256 immutable DIFFICULTY_COOLDOWN;\\n    uint256 immutable DIFFICULTY_COOLDOWN_SLOPE;\\n    address immutable DARK_AGE;\\n    uint256 immutable COLLAPSE_INITIAL;\\n    uint256 immutable COLLAPSE_RAMP;\\n    uint256 immutable COLLAPSE_MIN;\\n\\n\\n\\n    uint16 age = 2;\\n    uint32 firstSettlement;\\n\\n    uint32 abandoned;\\n\\n\\n    bool itIsTheDawnOfANewAge;\\n\\n    address public owner;\\n    address creator;\\n    uint80 supplies;\\n    uint80 relics;\\n\\n    uint80 mintFee;\\n    uint80 creatorEarnings;\\n    bytes32[] hashes;\\n    uint32[] public destroyed;\\n\\n    mapping( uint32 => Settlement) public settlements;\\n\\n    event Settle(uint32 _tokenId, bytes32 _hash, address _settler, uint24 _newSupply, uint80 _newMintFee, uint32 _collapseBlock, uint8 _settlementType, address indexed _data, uint32 _blockNumber);\\n    event Abandon(uint32 indexed _tokenId, bytes32 _hash, uint80 _growth, uint24 _supplyAtMint, uint32 _newAbandoned, uint80 _newMintFee, uint80 _eth, uint32 _settled, bool _itIsTheDawnOfANewAge, uint32 _blockNumber);\\n    event Reinforce(uint32 indexed _tokenId, uint8 _type);\\n    event Disaster(uint32 indexed _tokenId, uint8 _type, bool _destroyed, bool _darkAgeOver);\\n\\n    constructor(\\n        address _darkAge,\\n        uint256 _BASE_DIFFICULTY,\\n        uint256 _DIFFICULTY_RAMP,\\n        uint256 _DIFFICULTY_COOLDOWN,\\n        uint256 _DIFFICULTY_COOLDOWN_SLOPE,\\n        uint256 _COLLAPSE_INITIAL,\\n        uint256 _COLLAPSE_RAMP,\\n        uint256 _COLLAPSE_MIN\\n    ) payable {\\n\\n        BASE_DIFFICULTY     = _BASE_DIFFICULTY;\\n        DIFFICULTY_RAMP     = _DIFFICULTY_RAMP;\\n        DIFFICULTY_COOLDOWN = _DIFFICULTY_COOLDOWN;\\n        DIFFICULTY_COOLDOWN_SLOPE = _DIFFICULTY_COOLDOWN_SLOPE;\\n        COLLAPSE_INITIAL    = _COLLAPSE_INITIAL;\\n        COLLAPSE_RAMP       = _COLLAPSE_RAMP;\\n        COLLAPSE_MIN        = _COLLAPSE_MIN;\\n\\n        DARK_AGE = _darkAge;\\n\\n        require(msg.value == DESTRUCTION_FEE,\\\"destruction\\\");\\n\\n        // ERC165 stuff\\n        supportsInterface[0x80ac58cd] = true; //ERC721\\n        supportsInterface[0x5b5e139f] = true; //ERC721Metadata\\n        supportsInterface[0x01ffc9a7] = true; //ERC165\\n\\n        owner = msg.sender;\\n        creator = msg.sender;\\n\\n        bytes32 _hash = blockhash(block.number - 1);\\n        uint256 _settlementType = settlementType(_hash,0);\\n\\n        _mint(1,msg.sender,_hash);\\n\\n        settlements[1] = Settlement(uint32(block.number),0,age,uint8(_settlementType), 0,0);\\n\\n        mintFee += uint80((uint88(2363029719748390562045450) >> _settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\\n        firstSettlement = 1;\\n    }\\n\\n    function _settle(uint32 tokenId, bytes32 _hash, uint32 index, uint supply, uint32 collapseBlock, address data) internal returns(uint cost){\\n\\n        cost = uint256(mintFee) + DESTRUCTION_FEE;\\n        uint80 creatorFee = uint80(cost * CREATOR_PERCENT / 100);\\n        creatorEarnings += creatorFee;\\n        cost += creatorFee;\\n\\n        bytes32 hash = keccak256(abi.encodePacked(\\n                _hash,\\n                index\\n            ));\\n\\n        uint8 _settlementType = uint8(settlementType(hash,supply));\\n\\n        hash = keccak256(abi.encodePacked(hash,block.prevrandao));\\n\\n        settlements[tokenId] = Settlement( uint32(block.number), uint24(supply), age, _settlementType, 0, 0);\\n\\n        relics += mintFee/2;\\n\\n        mintFee +=    uint80((uint88(2363029719748390562045450) >> _settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\\n\\n        _mint(tokenId,msg.sender,hash);\\n\\n        emit Settle(tokenId, hash, msg.sender, uint24(supply + 1), mintFee, collapseBlock, _settlementType,  data, uint32(block.number));\\n\\n        return cost;\\n\\n    }\\n\\n    function settle(uint256 location, uint8 count, address data) external payable {\\n        require(!isDarkAge(),\\\"dark age\\\");\\n        require(count != 0,\\\"count min\\\");\\n        require(count <= 20,\\\"count max\\\");\\n\\n        unchecked{\\n            require(address(this).balance < type(uint80).max,\\\"balance overflow\\\");\\n\\n            uint32 tokenId = uint32(hashes.length + 1);\\n\\n            if(itIsTheDawnOfANewAge){\\n                ++age;\\n                firstSettlement = tokenId;\\n                itIsTheDawnOfANewAge = false;\\n            }\\n\\n            uint256 supply = (hashes.length - destroyed.length - abandoned);\\n            uint256 difficulty = BASE_DIFFICULTY - (DIFFICULTY_RAMP * supply);\\n            uint256 lastSettleBlock = settlements[uint32(hashes.length )].settleBlock;\\n\\n            require(block.number > lastSettleBlock,\\\"lastSettleBlock\\\");\\n            uint256 blockDif = (block.number - lastSettleBlock);\\n\\n            if(blockDif < DIFFICULTY_COOLDOWN){\\n                difficulty /= DIFFICULTY_COOLDOWN_SLOPE * (DIFFICULTY_COOLDOWN - blockDif);\\n            }\\n\\n            bytes32 hash = keccak256(abi.encodePacked(\\n                    msg.sender,\\n                    hashes[hashes.length - 1],\\n                    location\\n                ));\\n\\n            require(uint256(hash) < difficulty,\\\"difficulty\\\");\\n\\n            uint32 collapseBlock;\\n            if((supply + count) * COLLAPSE_RAMP <  COLLAPSE_INITIAL - COLLAPSE_MIN){\\n                collapseBlock = uint32(block.number + (COLLAPSE_INITIAL - (supply + count) * COLLAPSE_RAMP) / BLOCK_TIME);\\n            } else{\\n                collapseBlock = uint32(block.number + COLLAPSE_MIN / BLOCK_TIME);\\n            }\\n\\n            uint256 cost;\\n            for(uint32 i = 0; i < uint32(count); ++i){\\n                cost += _settle(tokenId + i, hash,i,supply + i,collapseBlock,data);\\n            }\\n\\n            require(msg.value >= cost,\\\"cost\\\");\\n            require(gasleft() > 10000,\\\"gas\\\");\\n            if(msg.value > cost){\\n                payable(msg.sender).transfer(msg.value - cost);\\n            }\\n        }\\n    }\\n\\n    function abandon(uint32[] calldata _tokenIds, uint32 _data) external {\\n        unchecked{\\n            require(_tokenIds.length != 0,\\\"tokenIds\\\");\\n            uint256 total;\\n            for(uint256 i = 0; i < _tokenIds.length; ++i){\\n                total += _abandon(_tokenIds[i],_data);\\n            }\\n            payable(msg.sender).transfer(total);\\n        }\\n    }\\n\\n    function confirmDisaster(uint32 _tokenId, uint32 _data) external {\\n        require(isDarkAge(),\\\"dark age\\\");\\n        require(_isValidToken(_tokenId),\\\"invalid\\\");\\n        uint256 eliminationWindow = (block.number % DISASTER_BLOCK_INTERVAL);\\n\\n        if(eliminationWindow < 25){\\n            require(msg.sender == ownerOf(_tokenId),\\\"owner\\\");\\n        }else if(eliminationWindow < 50){\\n            require(balanceOf[msg.sender] != 0,\\\"balance\\\");\\n        }\\n\\n        uint8 _type;\\n        bool _destroyed;\\n\\n        uint minted = hashes.length;\\n        uint supply = minted - destroyed.length - abandoned;\\n\\n        unchecked{\\n            (_type, _destroyed) =\\n                IDoomsdaySettlersDarkAge(DARK_AGE).disaster(_tokenId, supply);\\n        }\\n\\n        bool darkAgeOver = false;\\n        uint80 disaster_fee;\\n\\n        if(_destroyed){\\n            unchecked{\\n                uint80 tokenFee = uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\\n                uint80 growth;\\n                if(_tokenId >= firstSettlement){\\n                    growth = uint80(minted - _tokenId);\\n                }else{\\n                    growth = uint80(minted - firstSettlement) + 1;\\n                }\\n                uint80 _relics = growth * tokenFee;\\n\\n                relics += _relics/2 +\\n                    settlements[_tokenId].relics +\\n                    settlements[_tokenId].supplies +\\n                    IDoomsdaySettlersDarkAge(DARK_AGE).getUnusedFees(_tokenId) * DAMAGE_FEE;\\n\\n                destroyed.push(_tokenId);\\n\\n                _burn(_tokenId);\\n                --supply;\\n\\n                if(supply == 1){\\n                    _processWinner(_data);\\n                    darkAgeOver = true;\\n                }\\n            }\\n\\n            disaster_fee = DESTRUCTION_FEE;\\n        }else{\\n            disaster_fee = DAMAGE_FEE;\\n        }\\n\\n        emit Disaster(_tokenId,_type, _destroyed, darkAgeOver);\\n        payable(msg.sender).transfer(disaster_fee);\\n    }\\n\\n    function reinforce(uint32 _tokenId, bool[4] memory _resources) external payable{\\n        require(msg.sender == ownerOf(_tokenId),\\\"ownerOf\\\");\\n        unchecked{\\n            require(address(this).balance < type(uint80).max,\\\"balance overflow\\\");\\n            uint80 cost = IDoomsdaySettlersDarkAge(DARK_AGE).reinforce(\\n                _tokenId,\\n                hashOf(_tokenId),\\n                _resources,\\n                isDarkAge()\\n            );\\n            uint80 total;\\n            for(uint256 i = 0; i < 4; ++i){\\n                if(_resources[i]){\\n                    total += DAMAGE_FEE;\\n                    emit Reinforce(_tokenId,uint8(i));\\n                }\\n            }\\n            require(total != 0,\\\"empty\\\");\\n\\n            cost *= mintFee / uint80(4);\\n            total += cost;\\n\\n            require(total <= msg.value,\\\"msg.value\\\");\\n\\n            creatorEarnings += cost * REINFORCE_PERCENT_CREATOR / 100;\\n            supplies        += cost * REINFORCE_PERCENT_WINNER  / 100;\\n\\n            require(gasleft() > 10000,\\\"gas\\\");\\n            if(msg.value > total){\\n                payable(msg.sender).transfer(msg.value - total);\\n            }\\n        }\\n    }\\n\\n    function miningState() external view returns(\\n        bytes32 _lastHash,\\n        uint32 _settled,\\n        uint32 _abandoned,\\n        uint32 _lastSettleBlock,\\n        uint32 _collapseBlock,\\n        uint80 _mintFee,\\n        uint256 _blockNumber\\n    ){\\n        uint256 collapseBlock = settlements[uint32(hashes.length )].settleBlock;\\n        uint32 collapseSupply = settlements[uint32(hashes.length)].supplyAtMint + 1;\\n\\n        if(collapseSupply * COLLAPSE_RAMP <  COLLAPSE_INITIAL - COLLAPSE_MIN){\\n            collapseBlock += ( COLLAPSE_INITIAL - collapseSupply * COLLAPSE_RAMP ) / BLOCK_TIME;\\n        } else{\\n            collapseBlock +=  COLLAPSE_MIN / BLOCK_TIME;\\n        }\\n        return (\\n            hashes[hashes.length - 1],\\n            uint32(hashes.length),\\n            uint32(destroyed.length) + abandoned,\\n            settlements[uint32(hashes.length)].settleBlock,\\n            uint32(collapseBlock),\\n            mintFee,\\n            block.number\\n        );\\n    }\\n\\n    function currentState() external view returns(\\n        bool _itIsTheDawnOfANewAge,\\n        uint32 _firstSettlement,\\n        uint16 _age,\\n        uint80 _creatorEarnings,\\n        uint80 _relics,\\n        uint80 _supplies,\\n        uint256 _blockNumber\\n    ){\\n        return (\\n        itIsTheDawnOfANewAge,\\n        firstSettlement,\\n        age,\\n        creatorEarnings,\\n        relics,\\n        supplies,\\n        block.number\\n        );\\n    }\\n\\n\\n    function settlementType(bytes32 hash, uint256 _supplyAtMint) public pure returns(uint256){\\n        unchecked{\\n            uint256 settlementTypeMax = _supplyAtMint / 1000 + 2 ;\\n            if(settlementTypeMax > 8) settlementTypeMax = 8;\\n            return (uint256(hash)%100)**2 * ( settlementTypeMax + 1 ) / 1_00_00;\\n        }\\n    }\\n\\n    function isDarkAge() public view returns(bool){\\n        unchecked{\\n            uint minted = hashes.length;\\n            uint256 supply = (minted - destroyed.length - abandoned);\\n            uint256 collapseBlock = settlements[uint32(minted)].settleBlock;\\n            uint32 collapseSupply = settlements[uint32(minted)].supplyAtMint + 1;\\n\\n            if(collapseSupply * COLLAPSE_RAMP <  COLLAPSE_INITIAL - COLLAPSE_MIN){\\n                collapseBlock += ( COLLAPSE_INITIAL - collapseSupply * COLLAPSE_RAMP ) / BLOCK_TIME;\\n            } else{\\n                collapseBlock +=  COLLAPSE_MIN / BLOCK_TIME;\\n            }\\n            return supply > 1 && (block.number > collapseBlock );\\n        }\\n    }\\n\\n\\n    function hashOf(uint32 _tokenId) public view returns(bytes32){\\n        require(_isValidToken(_tokenId),\\\"invalid\\\");\\n        unchecked{\\n            return hashes[_tokenId - 1];\\n        }\\n    }\\n\\n\\n    function _processWinner(uint32 _winner) private{\\n        require(_isValidToken(_winner),\\\"invalid\\\");\\n        unchecked{\\n            settlements[_winner].relics     += relics;\\n            settlements[_winner].supplies   += supplies;\\n\\n            uint80 tokenFee = uint80((uint88(2363029719748390562045450) >> settlements[_winner].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\\n            uint80 growth;\\n            if(_winner > firstSettlement){\\n                growth = uint80(hashes.length) - uint80(_winner);\\n            }else{\\n                growth = (uint80(hashes.length) - uint80(firstSettlement)) + 1;\\n            }\\n            uint80 _relics = growth * tokenFee;\\n            settlements[_winner].relics += _relics / 2;\\n            relics = 0;\\n            supplies = 0;\\n            mintFee = tokenFee;\\n            itIsTheDawnOfANewAge = true;\\n        }\\n    }\\n\\n    function _abandon(uint32 _tokenId, uint32 _data) private returns(uint256){\\n        unchecked{\\n            require(msg.sender == ownerOf(_tokenId),\\\"ownerOf\\\");\\n            bytes32 hash = hashes[_tokenId - 1];\\n            uint80 growth;\\n            if(_tokenId >= firstSettlement){\\n                growth = uint80(hashes.length - _tokenId);\\n            }else{\\n                growth = uint80(hashes.length) - uint80(firstSettlement) + 1;\\n            }\\n            uint80 _relics;\\n            if(!itIsTheDawnOfANewAge){\\n                _relics = growth * uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\\n            }\\n\\n            bool _isDarkAge = isDarkAge();\\n            if(_isDarkAge){\\n                require(!IDoomsdaySettlersDarkAge(DARK_AGE).checkVulnerable(_tokenId),\\\"vulnerable\\\");\\n                _relics /= 2;\\n                uint80 __abandoned;\\n                uint80 __settled;\\n\\n                if(age > 2){\\n                    ++__abandoned;\\n                    ++__settled;\\n                }\\n\\n                __abandoned += uint80(destroyed.length + abandoned) - (uint80(firstSettlement) - 1);\\n                __settled   += uint80(hashes.length) - (uint80(firstSettlement) - 1);\\n\\n                uint80 spoils = uint80(relics) / uint80(hashes.length - destroyed.length - abandoned)\\n                    * (10_000_000_000 + ( 30_000_000_000 * __abandoned / __settled  ))  / 40_000_000_000;\\n\\n                _relics += spoils;\\n                relics -= spoils;\\n            }else if(!itIsTheDawnOfANewAge){\\n                relics -= _relics / 2;\\n                mintFee -= uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\\n            }\\n\\n            ++abandoned;\\n            _relics +=\\n                DESTRUCTION_FEE + IDoomsdaySettlersDarkAge(DARK_AGE).getUnusedFees(_tokenId) * DAMAGE_FEE\\n                    + settlements[_tokenId].relics\\n                    + settlements[_tokenId].supplies;\\n\\n            _burn(_tokenId);\\n            if(_isDarkAge){\\n                if(hashes.length - destroyed.length - abandoned == 1){\\n                    _processWinner(_data);\\n                }\\n            }\\n            emit Abandon(\\n                _tokenId,\\n                hash,\\n                growth,\\n                settlements[_tokenId].supplyAtMint,\\n                uint32(destroyed.length) + abandoned,\\n                mintFee,\\n                _relics,\\n                uint32(hashes.length),\\n                itIsTheDawnOfANewAge,\\n                uint32(block.number)\\n            );\\n            return _relics;\\n        }\\n    }\\n\\n\\n\\n    //////===721 Standard\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    //////===721 Implementation\\n\\n    mapping(address => uint256) public balanceOf;\\n    mapping (uint256 => address) internal allowance;\\n    mapping (address => mapping (address => bool)) public isApprovedForAll;\\n\\n    mapping(uint256 => address) owners;\\n\\n    //    METADATA VARS\\n    string constant public name = \\\"Doomsday: Settlers of the Wasteland\\\";\\n    string constant public symbol = \\\"SETTLEMENT\\\";\\n\\n    address private __metadata;\\n    function _mint(uint256 _tokenId,address _to, bytes32 _hash) private{\\n        unchecked{\\n            owners[_tokenId] = msg.sender;\\n            ++balanceOf[_to];\\n            hashes.push(_hash);\\n            emit Transfer(address(0),_to,_tokenId);\\n        }\\n    }\\n    function _burn(uint256 _tokenId) private{\\n    unchecked{\\n        address _owner = owners[_tokenId];\\n        --balanceOf[ _owner ];\\n        delete owners[_tokenId];\\n        emit Transfer(_owner,address(0),_tokenId);\\n    }\\n    }\\n\\n    function _isValidToken(uint256 _tokenId) internal view returns(bool){\\n        return owners[_tokenId] != address(0);\\n    }\\n\\n    function ownerOf(uint256 _tokenId) public view returns(address){\\n        require(_isValidToken(_tokenId),\\\"invalid\\\");\\n        return owners[_tokenId];\\n    }\\n\\n    function approve(address _approved, uint256 _tokenId)  external{\\n        _noBlocked(_approved);\\n\\n        address _owner = ownerOf(_tokenId);\\n        require( _owner == msg.sender\\n            || isApprovedForAll[_owner][msg.sender]\\n            ,\\\"permission\\\");\\n        emit Approval(_owner, _approved, _tokenId);\\n        allowance[_tokenId] = _approved;\\n    }\\n\\n    function getApproved(uint256 _tokenId) external view returns (address) {\\n        require(_isValidToken(_tokenId),\\\"invalid\\\");\\n        return allowance[_tokenId];\\n    }\\n\\n    function setApprovalForAll(address _operator, bool _approved) external {\\n        _noBlocked(_operator);\\n        emit ApprovalForAll(msg.sender,_operator, _approved);\\n        isApprovedForAll[msg.sender][_operator] = _approved;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\\n        address _owner = ownerOf(_tokenId);\\n        if(isDarkAge()){\\n            require(!IDoomsdaySettlersDarkAge(DARK_AGE).checkVulnerable(uint32(_tokenId)),\\\"vulnerable\\\");\\n        }\\n        if(_from != msg.sender){\\n            _noBlocked(msg.sender);\\n        }\\n\\n        require ( _owner == msg.sender\\n            || allowance[_tokenId] == msg.sender\\n            || isApprovedForAll[_owner][msg.sender]\\n        ,\\\"permission\\\");\\n\\n        require(_owner == _from,\\\"owner\\\");\\n        require(_to != address(0),\\\"zero\\\");\\n\\n        emit Transfer(_from, _to, _tokenId);\\n        owners[_tokenId] =_to;\\n        --balanceOf[_from];\\n        ++balanceOf[_to];\\n\\n        if(allowance[_tokenId] != address(0)){\\n            delete allowance[_tokenId];\\n        }\\n    }\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\\n        transferFrom(_from, _to, _tokenId);\\n\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_to)\\n        }\\n        if(size != 0){\\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(0x150b7a02),\\\"receiver\\\");\\n        }\\n    }\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\\n        safeTransferFrom(_from,_to,_tokenId,\\\"\\\");\\n    }\\n\\n    function tokenURI(uint256 _tokenId) external view returns (string memory){\\n        ownerOf(_tokenId);\\n        return IDoomsdaySettlersMetadata(__metadata).tokenURI(\\n            _tokenId\\n        );\\n    }\\n\\n    function totalSupply() external view returns (uint256){\\n        unchecked{\\n            return hashes.length - destroyed.length - abandoned;\\n        }\\n    }\\n    ///==End 721\\n\\n    ///////===165 Implementation\\n    mapping (bytes4 => bool) public supportsInterface;\\n    ///==End 165\\n\\n    //// ==== Admin\\n    function _onlyOwner() private view{\\n        require(msg.sender == owner,\\\"owner\\\");\\n    }\\n    function _onlyCreator() private view{\\n        require(msg.sender == creator,\\\"creator\\\");\\n    }\\n\\n    function setOwner(address newOwner) external  {\\n        _onlyOwner();\\n        owner = newOwner;\\n    }\\n\\n    function setMetadata(address _metadata) external {\\n        _onlyOwner();\\n        __metadata = _metadata;\\n    }\\n\\n    function creatorWithdraw() external {\\n        _onlyCreator();\\n        uint256 toWithdraw = creatorEarnings;\\n        delete creatorEarnings;\\n        payable(msg.sender).transfer(toWithdraw);\\n    }\\n\\n    function setCreator(address newCreator) external {\\n        _onlyCreator();\\n        creator = newCreator;\\n    }\\n\\n    //OPERATOR FILTER\\n    IDoomsdaySettlersBlacklist blacklist;\\n    function _noBlocked(address _addr) private view{\\n\\n        if (address(blacklist).code.length > 0) {\\n            try blacklist.checkBlocked(_addr) returns (bool result){\\n                require(!result,\\\"blocked\\\");\\n            } catch {\\n                //External error, let them cook\\n            }\\n        }\\n    }\\n\\n//    function tryCatchExternalCall(uint _i) public {\\n//        try foo.myFunc(_i) returns (string memory result) {\\n//            emit Log(result);\\n//        } catch {\\n//            emit Log(\\\"external call failed\\\");\\n//        }\\n//    }\\n\\n    function setBlacklist(address _newBlacklist) external{\\n        _onlyOwner();\\n        blacklist = IDoomsdaySettlersBlacklist(_newBlacklist);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDoomsdaySettlersBlacklist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\ninterface IDoomsdaySettlersBlacklist {\\n    function checkBlocked(address _addr) external view returns(bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDoomsdaySettlersDarkAge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\ninterface IDoomsdaySettlersDarkAge {\\n    function checkVulnerable(uint32 _tokenId) external view returns (bool);\\n    function getUnusedFees(uint32 _tokenId) external view returns (uint80);\\n    function disaster(uint32 _tokenId, uint256 _totalSupply) external returns(uint8 _type, bool destroyed);\\n    function reinforce(\\n        uint32 _tokenId,\\n        bytes32 _tokenHash,\\n        bool[4] memory _resources,\\n        bool _isDarkAge\\n    ) external returns (uint80 _cost);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDoomsdaySettlersMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\ninterface IDoomsdaySettlersMetadata {\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_darkAge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_BASE_DIFFICULTY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_DIFFICULTY_RAMP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_DIFFICULTY_COOLDOWN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_DIFFICULTY_COOLDOWN_SLOPE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_COLLAPSE_INITIAL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_COLLAPSE_RAMP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_COLLAPSE_MIN\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"_growth\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"_supplyAtMint\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_newAbandoned\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"_newMintFee\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"_eth\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_settled\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_itIsTheDawnOfANewAge\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_blockNumber\",\"type\":\"uint32\"}],\"name\":\"Abandon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_destroyed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_darkAgeOver\",\"type\":\"bool\"}],\"name\":\"Disaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"Reinforce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_settler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"_newSupply\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"_newMintFee\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_collapseBlock\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_settlementType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_data\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_blockNumber\",\"type\":\"uint32\"}],\"name\":\"Settle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_tokenIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"_data\",\"type\":\"uint32\"}],\"name\":\"abandon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_data\",\"type\":\"uint32\"}],\"name\":\"confirmDisaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_itIsTheDawnOfANewAge\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"_firstSettlement\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_age\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"_creatorEarnings\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"_relics\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"_supplies\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"destroyed\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"}],\"name\":\"hashOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDarkAge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miningState\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_settled\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_abandoned\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_lastSettleBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_collapseBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint80\",\"name\":\"_mintFee\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"internalType\":\"bool[4]\",\"name\":\"_resources\",\"type\":\"bool[4]\"}],\"name\":\"reinforce\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBlacklist\",\"type\":\"address\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"setCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_metadata\",\"type\":\"address\"}],\"name\":\"setMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_supplyAtMint\",\"type\":\"uint256\"}],\"name\":\"settlementType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"settlements\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"settleBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"supplyAtMint\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"age\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"settlementType\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"relics\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"supplies\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DoomsdaySettlersV2", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000079cf8466c12ac1acb9c1bf1179ea7308cf28eb0300000597a7e03ca484679197fbc312c8120b53a983aad3362bc462536a998a380000000000000000000000000000000000000000000000000000000000003a980000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000024", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}