{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/abstract/TSAggregator_V3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {SafeTransferLib} from \\\"../../lib/SafeTransferLib.sol\\\";\\nimport {ReentrancyGuard} from \\\"../../lib/ReentrancyGuard.sol\\\";\\nimport {Owners} from \\\"../../lib/Owners.sol\\\";\\nimport {TSAggregatorTokenTransferProxy} from \\\"../misc/TSAggregatorTokenTransferProxy.sol\\\";\\n\\nabstract contract TSAggregator_V3 is Owners, ReentrancyGuard {\\n    using SafeTransferLib for address;\\n\\n    event FeeSet(uint256 fee, address feeRecipient);\\n\\n    uint256 public fee;\\n    address public feeRecipient;\\n    TSAggregatorTokenTransferProxy public tokenTransferProxy;\\n\\n    constructor(address _tokenTransferProxy) {\\n        _setOwner(msg.sender, true);\\n        tokenTransferProxy = TSAggregatorTokenTransferProxy(\\n            _tokenTransferProxy\\n        );\\n    }\\n\\n    // Needed for the swap router to be able to send back ETH\\n    receive() external payable {}\\n\\n    function setFee(uint256 _fee, address _feeRecipient) external isOwner {\\n        require(_fee <= 1000, \\\"fee can not be more than 10%\\\");\\n        fee = _fee;\\n        feeRecipient = _feeRecipient;\\n        emit FeeSet(_fee, _feeRecipient);\\n    }\\n\\n    function takeFeeGas(uint256 amount) internal returns (uint256) {\\n        uint256 amountFee = getFee(amount);\\n        if (amountFee > 0) {\\n            feeRecipient.safeTransferETH(amountFee);\\n            amount -= amountFee;\\n        }\\n        return amount;\\n    }\\n\\n    function takeFeeToken(\\n        address token,\\n        uint256 amount\\n    ) internal nonReentrant returns (uint256) {\\n        uint256 amountFee = getFee(amount);\\n        if (amountFee > 0) {\\n            token.safeTransfer(feeRecipient, amountFee);\\n            amount -= amountFee;\\n        }\\n        return amount;\\n    }\\n\\n    function getFee(uint256 amount) internal view returns (uint256) {\\n        if (fee != 0 && feeRecipient != address(0)) {\\n            return (amount * fee) / 10000;\\n        }\\n        return 0;\\n    }\\n\\n    // Parse amountOutMin treating the last 2 digits as an exponent\\n    // So 1504 = 150000. This allows for compressed memos on chains\\n    // with limited space like Bitcoin\\n    function _parseAmountOutMin(\\n        uint256 amount\\n    ) internal pure returns (uint256) {\\n        return (amount / 100) * (10 ** (amount % 100));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstract/TSMemoGenLedger_V1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nabstract contract TSMemoGenLedger_V1 {\\n    function swapMemo(\\n        string calldata asset, // BNB.BNB\\n        string calldata destAddr, // bnb108n64knfm38f0mm23nkreqqmpc7rpcw89sqqw5\\n        string calldata limit, // 1231230/2/6\\n        string calldata affiliate, // t\\n        string calldata fee // 30\\n    ) public pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"=:\\\",\\n                    asset,\\n                    \\\":\\\",\\n                    destAddr,\\n                    \\\":\\\",\\n                    limit,\\n                    \\\":\\\",\\n                    affiliate,\\n                    \\\":\\\",\\n                    fee\\n                )\\n            );\\n    }\\n\\n    // Function to hash UTF-8 memo\\n    function hashMemo(string calldata memo) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(memo));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/misc/TSAggregatorTokenTransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {SafeTransferLib} from \\\"../../lib/SafeTransferLib.sol\\\";\\nimport {Owners} from \\\"../../lib/Owners.sol\\\";\\n\\ncontract TSAggregatorTokenTransferProxy is Owners {\\n    using SafeTransferLib for address;\\n\\n    constructor() {\\n        _setOwner(msg.sender, true);\\n    }\\n\\n    function transferTokens(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external isOwner {\\n        require(from == tx.origin || _isContract(from), \\\"Invalid from address\\\");\\n        token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/wrappers/TSWrapperLedger_V1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// -------------------\\n// Compatibility\\n// TC Router V4\\n// TS Memo Generator Ledger V1\\n// -------------------\\n\\nimport {Owners} from \\\"../../lib/Owners.sol\\\";\\nimport {SafeTransferLib} from \\\"../../lib/SafeTransferLib.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {IThorchainRouterV4} from \\\"../../interfaces/IThorchainRouterV4.sol\\\";\\nimport {IUniswapRouterV2} from \\\"../../interfaces/IUniswapRouterV2extended.sol\\\";\\nimport {TSAggregator_V3} from \\\"../abstract/TSAggregator_V3.sol\\\";\\nimport {TSMemoGenLedger_V1} from \\\"../abstract/TSMemoGenLedger_V1.sol\\\";\\n\\ncontract TSWrapperLedger_V1 is Owners, TSAggregator_V3, TSMemoGenLedger_V1 {\\n    using SafeTransferLib for address;\\n\\n    address public weth;\\n    IThorchainRouterV4 public tcRouter;\\n    IUniswapRouterV2 public swapRouter;\\n\\n    mapping(address => bool) public tokensWithTransferFee;\\n\\n    event SwapIn(\\n        address from,\\n        address token,\\n        uint256 amount,\\n        uint256 out,\\n        uint256 fee,\\n        address vault,\\n        string memo\\n    );\\n\\n    event SwapOut(address to, address token, uint256 amount, uint256 fee);\\n\\n    constructor(\\n        address _ttp,\\n        address _weth,\\n        address _swapRouter,\\n        address _tcRouter\\n    ) TSAggregator_V3(_ttp) {\\n        weth = _weth;\\n        tcRouter = IThorchainRouterV4(_tcRouter);\\n        swapRouter = IUniswapRouterV2(_swapRouter);\\n        _setOwner(msg.sender, true);\\n    }\\n\\n    function addTokenWithTransferFee(address token) external isOwner {\\n        tokensWithTransferFee[token] = true;\\n    }\\n\\n    function thorchainSwap(\\n        address payable vault,\\n        address inAsset,\\n        uint amount,\\n        uint expiration,\\n        string calldata outAsset,\\n        string calldata destinationAddress,\\n        string calldata limit,\\n        string calldata affiliate,\\n        string calldata memoFee\\n    ) public payable nonReentrant {\\n        string memory memo = swapMemo(\\n            outAsset,\\n            destinationAddress,\\n            limit,\\n            affiliate,\\n            memoFee\\n        );\\n\\n        uint safeAmount;\\n        if (inAsset == address(0)) {\\n            safeAmount = takeFeeGas(msg.value);\\n            tcRouter.depositWithExpiry{value: safeAmount}(\\n                vault,\\n                inAsset,\\n                safeAmount,\\n                memo,\\n                expiration\\n            );\\n        } else {\\n            safeAmount = takeFeeToken(inAsset, amount);\\n            tcRouter.depositWithExpiry{value: 0}(\\n                vault,\\n                inAsset,\\n                safeAmount,\\n                memo,\\n                expiration\\n            );\\n        }\\n    }\\n\\n    function thorchainSwapIn(\\n        address vault,\\n        address token,\\n        uint amount,\\n        uint amountOutMin,\\n        uint deadline,\\n        string calldata outAsset,\\n        string calldata destinationAddress,\\n        string calldata limit,\\n        string calldata affiliate,\\n        string calldata memoFee\\n    ) public nonReentrant {\\n        tokenTransferProxy.transferTokens(\\n            token,\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n        token.safeApprove(address(swapRouter), 0); // USDT quirk\\n        token.safeApprove(address(swapRouter), amount);\\n\\n        string memory memo = swapMemo(\\n            outAsset,\\n            destinationAddress,\\n            limit,\\n            affiliate,\\n            memoFee\\n        );\\n\\n        address[] memory path = new address[](2);\\n        path[0] = token;\\n        path[1] = weth;\\n\\n        swapRouter.swapExactTokensForETH(\\n            amount,\\n            amountOutMin,\\n            path,\\n            address(this),\\n            deadline\\n        );\\n\\n        uint256 out = address(this).balance;\\n        {\\n            uint256 outMinusFee = takeFeeGas(out);\\n            tcRouter.depositWithExpiry{value: outMinusFee}(\\n                payable(vault),\\n                address(0),\\n                outMinusFee,\\n                memo,\\n                deadline\\n            );\\n        }\\n\\n        emit SwapIn(\\n            msg.sender,\\n            token,\\n            amount,\\n            out + getFee(out),\\n            getFee(out),\\n            vault,\\n            memo\\n        );\\n    }\\n\\n    function swapOut(\\n        address token,\\n        address to,\\n        uint256 amountOutMin\\n    ) public payable nonReentrant {\\n        uint256 amount = takeFeeGas(msg.value);\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = token;\\n\\n        if (tokensWithTransferFee[token]) {\\n            swapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                value: amount\\n            }(\\n                _parseAmountOutMin(amountOutMin),\\n                path,\\n                to,\\n                type(uint).max // deadline\\n            );\\n        } else {\\n            swapRouter.swapExactETHForTokens{value: amount}(\\n                _parseAmountOutMin(amountOutMin),\\n                path,\\n                to,\\n                type(uint).max // deadline\\n            );\\n        }\\n\\n        emit SwapOut(to, token, msg.value, msg.value - amount);\\n    }\\n\\n    function uniswapV2Swap(\\n        address tokenIn,\\n        address tokenOut,\\n        address recipient,\\n        uint256 amount,\\n        uint256 amountOutMin,\\n        uint256 deadline\\n    ) public payable nonReentrant {\\n        require(tokenIn != tokenOut, \\\"same token\\\");\\n\\n        address[] memory path = new address[](2);\\n        path[0] = tokenIn;\\n        path[1] = tokenOut;\\n\\n        // Ether -> Token\\n        if (tokenIn == address(0)) {\\n            swapRouter.swapExactETHForTokens{value: amount}(\\n                amountOutMin,\\n                path,\\n                recipient,\\n                deadline\\n            );\\n        }\\n        // Token -> Ether\\n        else if (tokenOut == address(0)) {\\n            tokenTransferProxy.transferTokens(\\n                tokenIn,\\n                msg.sender,\\n                address(this),\\n                amount\\n            );\\n            tokenIn.safeApprove(address(swapRouter), 0); // USDT quirk\\n            tokenIn.safeApprove(address(swapRouter), amount);\\n\\n            swapRouter.swapExactTokensForETH(\\n                amount,\\n                amountOutMin,\\n                path,\\n                recipient,\\n                deadline\\n            );\\n        }\\n        // Token -> Token\\n        else {\\n            tokenTransferProxy.transferTokens(\\n                tokenIn,\\n                msg.sender,\\n                address(this),\\n                amount\\n            );\\n            tokenIn.safeApprove(address(swapRouter), 0); // USDT quirk\\n            tokenIn.safeApprove(address(swapRouter), amount);\\n\\n            swapRouter.swapExactTokensForTokens(\\n                amount,\\n                amountOutMin,\\n                path,\\n                recipient,\\n                deadline\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IThorchainRouterV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IThorchainRouterV4 {\\n    function depositWithExpiry(\\n        address payable vault,\\n        address asset,\\n        uint amount,\\n        string memory memo,\\n        uint expiration\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapRouterV2extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IUniswapRouterV2 {\\n    function WETH() external view returns (address);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/lib/Owners.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nabstract contract Owners {\\n    event OwnerSet(address indexed owner, bool active);\\n\\n    mapping(address => bool) public owners;\\n\\n    modifier isOwner() {\\n        require(owners[msg.sender], \\\"Unauthorized\\\");\\n        _;\\n    }\\n\\n    function _setOwner(address owner, bool active) internal virtual {\\n        owners[owner] = active;\\n        emit OwnerSet(owner, active);\\n    }\\n\\n    function setOwner(address owner, bool active) external virtual isOwner {\\n        _setOwner(owner, active);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"from\\\" argument.\\n            mstore(\\n                add(freeMemoryPointer, 36),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(\\n            didLastOptionalReturnCallSucceed(callStatus),\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(\\n            didLastOptionalReturnCallSucceed(callStatus),\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(\\n        bool callStatus\\n    ) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ttp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tcRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"FeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"SwapIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SwapOut\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addTokenWithTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"hashMemo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"asset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destAddr\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"limit\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"affiliate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fee\",\"type\":\"string\"}],\"name\":\"swapMemo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"swapOut\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tcRouter\",\"outputs\":[{\"internalType\":\"contract IThorchainRouterV4\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"outAsset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"limit\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"affiliate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"memoFee\",\"type\":\"string\"}],\"name\":\"thorchainSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"outAsset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"limit\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"affiliate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"memoFee\",\"type\":\"string\"}],\"name\":\"thorchainSwapIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTransferProxy\",\"outputs\":[{\"internalType\":\"contract TSAggregatorTokenTransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensWithTransferFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"uniswapV2Swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TSWrapperLedger_V1", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f892fef9da200d9e84c9b0647ecff0f34633abe8000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000d37bbe5744d730a1d98d8dc97c42f0ca46ad7146", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}