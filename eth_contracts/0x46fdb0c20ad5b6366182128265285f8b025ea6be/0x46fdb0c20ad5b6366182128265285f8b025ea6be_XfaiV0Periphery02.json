{"SourceCode": "{\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\u0027./IERC165.sol\\u0027;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n   * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n   * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\u0027./IERC721.sol\\u0027;\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  /**\\n   * @dev Returns the total amount of tokens stored by the contract.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n   * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n   * Use along with {totalSupply} to enumerate all tokens.\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.19;\\n\\nimport \\u0027./IERC20Metadata.sol\\u0027;\\n\\ninterface IWETH is IERC20Metadata {\\n  function deposit() external payable;\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function withdraw(uint) external;\\n}\\n\"},\"IXfaiFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IXfaiFactory {\\n  function getPool(address _token) external view returns (address pool);\\n\\n  function allPools(uint256) external view returns (address pool);\\n\\n  function poolCodeHash() external pure returns (bytes32);\\n\\n  function allPoolsLength() external view returns (uint);\\n\\n  function createPool(address _token) external returns (address pool);\\n\\n  function setXfaiCore(address _core) external;\\n\\n  function getXfaiCore() external view returns (address);\\n\\n  function setOwner(address _owner) external;\\n\\n  function getOwner() external view returns (address);\\n\\n  event ChangedOwner(address indexed owner);\\n  event ChangedCore(address indexed core);\\n  event Whitelisting(bool state);\\n  event PoolCreated(address indexed token, address indexed pool, uint allPoolsSize);\\n}\\n\"},\"IXfaiINFT.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.19;\\nimport \\u0027./IERC721Enumerable.sol\\u0027;\\n\\ninterface IXfaiINFT is IERC721Enumerable {\\n  function reserve() external view returns (uint);\\n\\n  function totalSharesIssued() external view returns (uint);\\n\\n  function initialReserve() external view returns (uint);\\n\\n  function harvestedBalance(address _token) external view returns (uint);\\n\\n  function INFTShares(uint _id) external view returns (uint);\\n\\n  function sharesHarvestedByPool(address _token, uint _id) external view returns (uint);\\n\\n  function totalSharesHarvestedByPool(address _token) external view returns (uint);\\n\\n  function setBaseURI(string memory _baseURI) external;\\n\\n  function getStates() external view returns (uint, uint, uint);\\n\\n  function shareToTokenAmount(\\n    uint _tokenID,\\n    address _token\\n  ) external view returns (uint share2amount, uint inftShare, uint harvestedShares);\\n\\n  function premint(address[] memory _legacyLNFTHolders, uint[] memory _initialShares) external;\\n\\n  function mint(address _to) external returns (uint tokenID, uint share);\\n\\n  function boost(uint _tokenID) external returns (uint share);\\n\\n  function harvestToken(address _token, uint _tokenID, uint _amount) external returns (uint);\\n\\n  function harvestETH(uint _tokenID, uint _amount) external returns (uint);\\n\\n  event Mint(address indexed from, address indexed to, uint share, uint id);\\n  event Boost(address indexed from, uint share, uint id);\\n  event HarvestToken(address token, uint harvestedAmount, uint harvestedShare, uint id);\\n  event HarvestETH(uint harvestedAmount, uint harvestedShare, uint id);\\n}\\n\"},\"IXfaiPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\u0027./IERC20Metadata.sol\\u0027;\\n\\ninterface IXfaiPool is IERC20Metadata {\\n  function getXfaiCore() external view returns (address);\\n\\n  function poolToken() external view returns (address);\\n\\n  function initialize(address _token, address _xfaiFactory) external;\\n\\n  function getStates() external view returns (uint, uint);\\n\\n  function update(uint _reserveBalance, uint _weightBalance) external;\\n\\n  function mint(address _to, uint _amount) external;\\n\\n  function burn(address _to, uint _amount) external;\\n\\n  function linkedTransfer(address _token, address _to, uint256 _value) external;\\n\\n  event Sync(uint _reserve, uint _weight);\\n  event Write(uint _reserve, uint _weight, uint _blockTimestamp);\\n}\\n\"},\"IXfaiV0Core.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IXfaiV0Core {\\n  function lpFee() external view returns (uint);\\n\\n  function changeLpFee(uint _newFee) external;\\n\\n  function infinityNFTFee() external view returns (uint);\\n\\n  function changeInfinityNFTFee(uint _newFee) external;\\n\\n  function getTotalFee() external view returns (uint);\\n\\n  function pause(bool _p) external;\\n\\n  function swap(\\n    address _token0,\\n    address _token1,\\n    address _to\\n  ) external returns (uint input, uint output);\\n\\n  function flashLoan(address _token, uint _amount, address _to, bytes calldata _data) external;\\n\\n  function mint(address _token, address _to) external returns (uint liquidity);\\n\\n  function burn(\\n    address _token0,\\n    address _token1,\\n    address _to\\n  ) external returns (uint amount0, uint amount1);\\n\\n  function skim(address _token, address _to) external;\\n\\n  function sync(address _token) external;\\n\\n  event ChangedOwner(address indexed owner);\\n  event Mint(address indexed sender, uint liquidity);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(address indexed sender, uint input, uint output, address indexed to);\\n  event FlashLoan(address indexed sender, uint amount);\\n  event LpFeeChange(uint newFee);\\n  event InfinityNFTFeeChange(uint newFee);\\n  event Paused(bool p);\\n}\\n\"},\"IXfaiV0Periphery02.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IXfaiV0Periphery02 {\\n  function addLiquidity(\\n    address _to,\\n    address _token,\\n    uint _amountTokenDesired,\\n    uint _amountTokenMin,\\n    uint _amountETHMin,\\n    uint _deadline\\n  ) external payable returns (uint liquidity);\\n\\n  function addLiquidityETH(\\n    address _to,\\n    uint _deadline,\\n    uint _amountETHMin,\\n    uint _amountXfETHMin\\n  ) external payable returns (uint liquidity);\\n\\n  function removeLiquidity(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _liquidity,\\n    uint _amount0Min,\\n    uint _amount1Min,\\n    uint _deadline\\n  ) external returns (uint amount0, uint amount1);\\n\\n  function swapExactTokensForTokens(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _amount0In,\\n    uint _amount1OutMin,\\n    uint _deadline\\n  ) external returns (uint);\\n\\n  function swapTokensForExactTokens(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _amount1Out,\\n    uint _amount0InMax,\\n    uint _deadline\\n  ) external returns (uint);\\n\\n  function swapExactETHForTokens(\\n    address _to,\\n    address _token1,\\n    uint _amount1OutMin,\\n    uint _deadline\\n  ) external payable returns (uint);\\n\\n  function swapTokensForExactETH(\\n    address _to,\\n    address _token0,\\n    uint _amount1Out,\\n    uint _amount0InMax,\\n    uint _deadline\\n  ) external returns (uint amount0In);\\n\\n  function swapExactTokensForETH(\\n    address _to,\\n    address _token0,\\n    uint _amount0In,\\n    uint _amount1OutMin,\\n    uint _deadline\\n  ) external returns (uint);\\n\\n  function swapETHForExactTokens(\\n    address _to,\\n    address _token1,\\n    uint _amount1Out,\\n    uint _deadline\\n  ) external payable returns (uint input);\\n}\\n\"},\"IXFETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\u0027./IERC20Metadata.sol\\u0027;\\n\\ninterface IXFETH is IERC20Metadata {\\n  event Deposit(address indexed dst, uint amountXfETH, uint amountETH);\\n  event Withdrawal(address indexed src, uint amountETH);\\n  event FlashMint(address indexed dst, uint amountXfETH);\\n  event FeeChange(uint newFee);\\n  event OwnerChange(address newOwner);\\n  event ArbitrageurChange(address arbitrageur);\\n  event StatusChange(bool state);\\n\\n  function owner() external view returns (address _owner);\\n\\n  function flashMintFee() external view returns (uint _flashMintFee);\\n\\n  function setStatus(bool _state) external;\\n\\n  function setOwner(address _newOwner) external;\\n\\n  function setArbitrageur(address _arbitrageur) external;\\n\\n  function setFlashMintFee(uint _newFee) external;\\n\\n  function xfETHToETH(uint _xfETHAmount) external view returns (uint _ETH);\\n\\n  function ETHToXfETH(uint _ETHAmount) external view returns (uint _xfETH);\\n\\n  function deposit() external payable returns (uint amountInXfETH);\\n\\n  function withdraw(uint _liquidity) external returns (uint amountInETH);\\n\\n  function flashMint(uint _amount) external;\\n}\\n\"},\"XfaiV0Periphery02.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.19;\\n\\nimport \\u0027./IXfaiV0Core.sol\\u0027;\\nimport \\u0027./IXfaiPool.sol\\u0027;\\nimport \\u0027./IXfaiV0Periphery02.sol\\u0027;\\nimport \\u0027./IXfaiFactory.sol\\u0027;\\nimport \\u0027./IXFETH.sol\\u0027;\\nimport \\u0027./IXfaiINFT.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IWETH.sol\\u0027;\\n\\n\\nlibrary TransferHelper {\\n  function safeTransferFrom(address _token, address _from, address _to, uint256 _value) internal {\\n    require(_token.code.length \\u003e 0, \\u0027Xfai: TRANSFERFROM_FAILED\\u0027);\\n    (bool success, bytes memory data) = _token.call(\\n      abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _value)\\n    );\\n    require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027Xfai: TRANSFERFROM_FAILED\\u0027);\\n  }\\n\\n  function safeTransferETH(address _to, uint _value) internal {\\n    (bool success, ) = _to.call{value: _value}(new bytes(0));\\n    require(success, \\u0027Xfai: ETH_TRANSFER_FAILED\\u0027);\\n  }\\n\\n  function safeTransfer(address _token, address _to, uint256 _value) internal {\\n    require(_token.code.length \\u003e 0, \\u0027Xfai: TRANSFER_FAILED\\u0027);\\n    (bool success, bytes memory data) = _token.call(\\n      abi.encodeWithSelector(IERC20.transfer.selector, _to, _value)\\n    );\\n    require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027Xfai: TRANSFER_FAILED\\u0027);\\n  }\\n}\\n\\n\\nlibrary XfaiLibrary {\\n  /**\\n   * @notice Calculates the CREATE2 address for a pool without making any external calls\\n   * @param _token An ERC20 token address\\n   * @param _factory The factory contract of Xfai\\n   * @param _poolCodeHash The codehash of the Xfai pool contract\\n   * @return pool The deterministic pool address for a given _token\\n   */\\n  function poolFor(\\n    address _token,\\n    address _factory,\\n    bytes32 _poolCodeHash\\n  ) internal pure returns (address pool) {\\n    pool = address(\\n      uint160(\\n        uint256(\\n          keccak256(\\n            abi.encodePacked(\\n              hex\\u0027ff\\u0027,\\n              _factory,\\n              keccak256(abi.encodePacked(_token)),\\n              _poolCodeHash // init code hash\\n            )\\n          )\\n        )\\n      )\\n    );\\n  }\\n\\n  function getAdjustedOutput(uint _amountIn, uint _r, uint _w) internal pure returns (uint out) {\\n    out = (_amountIn * _w) / (_r + _amountIn);\\n  }\\n\\n  function getAdjustedInput(uint _amountOut, uint _r, uint _w) internal pure returns (uint input) {\\n    input = ((_amountOut * _r) / (_w - _amountOut)) + 1;\\n  }\\n\\n  function quote(uint _amountIn, uint _a, uint _b) internal pure returns (uint out) {\\n    out = (_amountIn * _a) / _b;\\n  }\\n\\n  /**\\n   * @notice Calculates the adjusted price of an _amountIn (of a token from _pool0) in terms of the token in _pool1\\n   * @dev either token0 or token1 must be xfETH\\n   * @param _reserve0 The reserve of _token0 (can be xfETH)\\n   * @param _reserve1 The reserve of _token1 (can be xfETH)\\n   * @param _amountIn The token input amount to _pool0\\n   * @return output The token output between a token - xfETH interaction\\n   */\\n  function getAmountOut(\\n    uint _reserve0,\\n    uint _reserve1,\\n    uint _amountIn,\\n    uint _totalFee\\n  ) public pure returns (uint output) {\\n    require(_amountIn \\u003e 0, \\u0027Xfai: INSUFFICIENT_AMOUNT\\u0027);\\n    require(_reserve0 \\u003e 0, \\u0027Xfai: INSUFFICIENT_LIQUIDITY\\u0027);\\n    require(_reserve1 \\u003e 0, \\u0027Xfai: INSUFFICIENT_LIQUIDITY\\u0027);\\n    uint amountInWithFee = _amountIn * (10000 - _totalFee);\\n    uint numerator = amountInWithFee * _reserve1;\\n    output = numerator / (_reserve0 * 10000 + amountInWithFee);\\n  }\\n\\n  /**\\n   * @notice Calculates the adjusted price of an _amountOut (of a token from _pool1) in terms of the token in _pool0\\n   * @param _reserve0 The reserve of _token0 (can be xfETH)\\n   * @param _reserve1 The reserve of _token1 (can be xfETH)\\n   * @param _amountOut The token output amount from _pool0\\n   * @return input The token input amount to _pool0\\n   */\\n  function getAmountIn(\\n    uint _reserve0,\\n    uint _reserve1,\\n    uint _amountOut,\\n    uint _totalFee\\n  ) public pure returns (uint input) {\\n    require(_amountOut \\u003e 0, \\u0027Xfai: INSUFFICIENT_AMOUNT\\u0027);\\n    require(_reserve0 \\u003e 0, \\u0027Xfai: INSUFFICIENT_LIQUIDITY\\u0027);\\n    require(_reserve1 \\u003e 0, \\u0027Xfai: INSUFFICIENT_LIQUIDITY\\u0027);\\n    uint numerator = _amountOut * _reserve0 * 10000;\\n    uint denominator = (_reserve1 - _amountOut) * (10000 - _totalFee);\\n    input = (numerator / denominator) + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates the adjusted price of an _amountIn (of a token from _pool0) in terms of the token in _pool1\\n   * @param _pool0 A pool address\\n   * @param _pool1 A pool address\\n   * @param _amountIn The token input amount to _pool0\\n   * @return out1 The token output amount from _pool1\\n   */\\n  function getAmountsOut(\\n    address _pool0,\\n    address _pool1,\\n    uint _amountIn,\\n    uint _totalFee\\n  ) public view returns (uint out1) {\\n    (uint r0, uint w0) = IXfaiPool(_pool0).getStates();\\n    (uint r1, uint w1) = IXfaiPool(_pool1).getStates();\\n    uint weight0Out = getAmountOut(r0, w0, _amountIn, _totalFee);\\n    out1 = getAdjustedOutput(weight0Out, w1, r1);\\n  }\\n\\n  /**\\n   * @notice Calculates the adjusted price of an _amountOut (of a token from _pool1) in terms of the token in _pool0\\n   * @param _pool0 A pool address\\n   * @param _pool1 A pool address\\n   * @param _amountOut The token output amount from _pool1\\n   * @return inp0 The token input amount to _pool0\\n   */\\n  function getAmountsIn(\\n    address _pool0,\\n    address _pool1,\\n    uint _amountOut,\\n    uint _totalFee\\n  ) public view returns (uint inp0) {\\n    (uint r0, uint w0) = IXfaiPool(_pool0).getStates();\\n    (uint r1, uint w1) = IXfaiPool(_pool1).getStates();\\n    uint weight0Out = getAdjustedInput(_amountOut, w1, r1);\\n    inp0 = getAmountIn(r0, w0, weight0Out, _totalFee);\\n  }\\n}\\n\\n\\n/**\\n * @title Xfai\\u0027s Xfai Periphery Contract\\n * @author Xfai\\n * @notice XfaiV0Periphery02 performs the necessary high level safety checks to interact with XfaiV0Core. It does not store any pool related state.\\n */\\ncontract XfaiV0Periphery02 is IXfaiV0Periphery02 {\\n  /**\\n   * @notice The factory address of Xfai\\n   */\\n  address private immutable factory;\\n\\n  /**\\n   * @notice The address of the xfETH token\\n   */\\n  address private immutable xfETH;\\n\\n  /**\\n   * @notice The address of the XfaiV0Core contract\\n   */\\n  address private immutable core;\\n\\n  /**\\n   * @notice The weth address.\\n   * @dev In the case of a chain ID other than Ethereum, the wrapped ERC20 token address of the chain\\u0027s native coin\\n   */\\n  address private immutable weth;\\n\\n  /**\\n   * @notice The code hash od XfaiPool\\n   * @dev keccak256(type(XfaiPool).creationCode)\\n   */\\n  bytes32 private immutable poolCodeHash;\\n\\n  modifier ensure(uint deadline) {\\n    require(deadline \\u003e= block.timestamp, \\u0027XfaiV0Periphery02: EXPIRED\\u0027);\\n    _;\\n  }\\n\\n  /**\\n   * @notice XfaiV0Periphery02 constructor\\n   * @param _factory The factory address of Xfai\\n   * @param _weth The weth address\\n   * @param _xfETH The xfETH address\\n   */\\n  constructor(address _factory, address _weth, address _xfETH) {\\n    factory = _factory;\\n    core = IXfaiFactory(_factory).getXfaiCore();\\n    xfETH = _xfETH;\\n    weth = _weth;\\n    poolCodeHash = IXfaiFactory(_factory).poolCodeHash();\\n  }\\n\\n  receive() external payable {\\n    assert(msg.sender == weth || msg.sender == xfETH); // only accept ETH via fallback from the weth contract\\n  }\\n\\n  // **** ADD LIQUIDITY ****\\n\\n  function _getLiquidityAmounts(\\n    address _token,\\n    uint _amountTokenDesired,\\n    uint _amountXfETHDesired,\\n    uint _amountTokenMin,\\n    uint _amountXfETHMin\\n  ) internal returns (uint amountToken, uint amountXfETH) {\\n    address pool = IXfaiFactory(factory).getPool(_token);\\n    if (pool == address(0)) {\\n      // create the pool if it doesn\\u0027t exist yet\\n      pool = IXfaiFactory(factory).createPool(_token);\\n    }\\n    (uint reserve, uint weight) = IXfaiPool(pool).getStates();\\n    if (reserve == 0 \\u0026\\u0026 weight == 0) {\\n      (amountToken, amountXfETH) = (_amountTokenDesired, _amountXfETHDesired);\\n    } else {\\n      uint amountXfETHOptimal = XfaiLibrary.quote(_amountTokenDesired, weight, reserve);\\n      if (amountXfETHOptimal \\u003c= _amountXfETHDesired) {\\n        require(amountXfETHOptimal \\u003e= _amountXfETHMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_1_AMOUNT\\u0027);\\n        (amountToken, amountXfETH) = (_amountTokenDesired, amountXfETHOptimal);\\n      } else {\\n        uint amountTokenOptimal = XfaiLibrary.quote(_amountXfETHDesired, reserve, weight);\\n        assert(amountTokenOptimal \\u003c= _amountTokenDesired);\\n        require(amountTokenOptimal \\u003e= _amountTokenMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_0_AMOUNT\\u0027);\\n        (amountToken, amountXfETH) = (amountTokenOptimal, _amountXfETHDesired);\\n      }\\n    }\\n  }\\n\\n  function _addLiquidity(\\n    address _token,\\n    uint _amountTokenDesired,\\n    uint _amountETHDesired,\\n    uint _amountTokenMin,\\n    uint _amountETHMin\\n  ) internal returns (uint amountToken, uint amountETH) {\\n    address _xfETH = xfETH; // gas saving\\n    uint amountXfETH;\\n    (amountToken, amountXfETH) = _getLiquidityAmounts(\\n      _token,\\n      _amountTokenDesired,\\n      IXFETH(_xfETH).ETHToXfETH(_amountETHDesired),\\n      _amountTokenMin,\\n      IXFETH(_xfETH).ETHToXfETH(_amountETHMin)\\n    );\\n    amountETH = IXFETH(_xfETH).xfETHToETH(amountXfETH);\\n  }\\n\\n  /**\\n   * @notice Provide two-sided liquidity to a pool\\n   * @dev Requires _token approval. A given amount of _token and ETH get consumed and a given amount of liquidity tokens is minted\\n   * @param _to The address of the recipient\\n   * @param _token An ERC20 token address\\n   * @param _amountTokenDesired The input amount of _token to be provided\\n   * @param _amountTokenMin The minimal amount that the user will accept for _amountTokenDesired\\n   * @param _amountETHMin The minimal amount that the user will accept for the provided ETH\\n   * @param _deadline The UTC timestamp that if reached, causes the transaction to fail automatically\\n   */\\n  function addLiquidity(\\n    address _to,\\n    address _token,\\n    uint _amountTokenDesired,\\n    uint _amountTokenMin,\\n    uint _amountETHMin,\\n    uint _deadline\\n  ) external payable override ensure(_deadline) returns (uint liquidity) {\\n    address pool = XfaiLibrary.poolFor(_token, factory, poolCodeHash);\\n    (uint amount0, uint amount1) = _addLiquidity(\\n      _token,\\n      _amountTokenDesired,\\n      msg.value,\\n      _amountTokenMin,\\n      _amountETHMin\\n    );\\n    TransferHelper.safeTransferFrom(_token, msg.sender, pool, amount0);\\n    uint amountXfETH = IXFETH(xfETH).deposit{value: amount1}();\\n    TransferHelper.safeTransfer(xfETH, pool, amountXfETH);\\n    liquidity = IXfaiV0Core(core).mint(_token, _to);\\n    // refund dust eth, if any\\n    if (msg.value \\u003e amount1) TransferHelper.safeTransferETH(msg.sender, msg.value - amount1);\\n  }\\n\\n  /**\\n   * @notice Provide one-sided liquidity to the ETH pool\\n   * @dev A given amount of ETH get consumed and a given amount of liquidity tokens is minted\\n   * @param _to The address of the recipient\\n   * @param _deadline The UTC timestamp that if reached, causes the transaction to fail automatically\\n   */\\n  function addLiquidityETH(\\n    address _to,\\n    uint _deadline,\\n    uint _amountETHMin,\\n    uint _amountXfETHMin\\n  ) external payable override ensure(_deadline) returns (uint liquidity) {\\n    address _weth = weth; // gas saving\\n    address _xfeth = xfETH; // gas saving\\n    uint amountETH;\\n    uint amountXfETHtoETH;\\n    address pool = IXfaiFactory(factory).getPool(_weth);\\n    if (pool == address(0)) {\\n      // create the pool if it doesn\\u0027t exist yet\\n      pool = IXfaiFactory(factory).createPool(_weth);\\n    }\\n    {\\n      (uint ETHReserve, uint xfETHReserve) = IXfaiPool(pool).getStates();\\n      if (ETHReserve == 0 \\u0026\\u0026 xfETHReserve == 0) {\\n        (amountETH, amountXfETHtoETH) = (msg.value / 2, msg.value / 2);\\n      } else {\\n        amountETH =\\n          (msg.value * ETHReserve) /\\n          (ETHReserve + IXFETH(_xfeth).xfETHToETH(xfETHReserve));\\n        amountXfETHtoETH = msg.value - amountETH;\\n      }\\n    }\\n    uint amountXfETH = IXFETH(_xfeth).deposit{value: amountXfETHtoETH}();\\n    require(amountETH \\u003e= _amountETHMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_0_AMOUNT\\u0027);\\n    require(amountXfETH \\u003e= _amountXfETHMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_0_AMOUNT\\u0027);\\n    IWETH(_weth).deposit{value: amountETH}();\\n    TransferHelper.safeTransfer(_xfeth, pool, amountXfETH);\\n    TransferHelper.safeTransfer(_weth, pool, amountETH);\\n    liquidity = IXfaiV0Core(core).mint(_weth, _to);\\n    require(msg.value == amountETH + amountXfETHtoETH, \\u0027XfaiV0Periphery02: INSUFFICIENT_AMOUNT\\u0027);\\n  }\\n\\n  // **** REMOVE LIQUIDITY ****\\n\\n  function _removeLiquidity(\\n    address _token0,\\n    address _token1,\\n    uint _liquidity,\\n    uint _amount0Min,\\n    uint _amount1Min,\\n    address _to\\n  ) private returns (uint amount0, uint amount1) {\\n    address _core = core; // gas saving\\n    address pool = XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\\n    TransferHelper.safeTransferFrom(pool, msg.sender, _core, _liquidity);\\n    (amount0, amount1) = IXfaiV0Core(_core).burn(_token0, _token1, _to);\\n    require(amount0 \\u003e= _amount0Min, \\u0027XfaiV0Periphery02: INSUFFICIENT_AMOUNT0\\u0027);\\n    require(amount1 \\u003e= _amount1Min, \\u0027XfaiV0Periphery02: INSUFFICIENT_AMOUNT1\\u0027);\\n  }\\n\\n  function _removeLiquidityOptions(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _liquidity,\\n    uint _amount0Min,\\n    uint _amount1Min\\n  ) private returns (uint amount0, uint amount1) {\\n    address wrappedETH = weth; // gas saving\\n    if (_token0 == wrappedETH \\u0026\\u0026 _token1 == wrappedETH) {\\n      (amount0, amount1) = _removeLiquidity(\\n        _token0,\\n        xfETH,\\n        _liquidity,\\n        _amount0Min,\\n        _amount1Min,\\n        address(this)\\n      );\\n      IWETH(_token0).withdraw(amount0);\\n      uint amountInETH = IXFETH(xfETH).withdraw(amount1);\\n      TransferHelper.safeTransferETH(_to, amount0 + amountInETH);\\n    } else if (_token0 == wrappedETH) {\\n      (amount0, amount1) = _removeLiquidity(\\n        _token0,\\n        _token1,\\n        _liquidity,\\n        _amount0Min,\\n        _amount1Min,\\n        address(this)\\n      );\\n      IWETH(_token0).withdraw(amount0);\\n      TransferHelper.safeTransferETH(_to, amount0);\\n      TransferHelper.safeTransfer(_token1, _to, amount1);\\n    } else if (_token1 == wrappedETH) {\\n      (amount0, amount1) = _removeLiquidity(\\n        _token0,\\n        xfETH,\\n        _liquidity,\\n        _amount0Min,\\n        _amount1Min,\\n        address(this)\\n      );\\n      uint amountInETH = IXFETH(xfETH).withdraw(amount1);\\n      TransferHelper.safeTransferETH(_to, amountInETH);\\n      TransferHelper.safeTransfer(_token0, _to, amount0);\\n    } else {\\n      (amount0, amount1) = _removeLiquidity(\\n        _token0,\\n        _token1,\\n        _liquidity,\\n        _amount0Min,\\n        _amount1Min,\\n        _to\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from pool0\\n   * @dev Requires approval of the pool\\u0027s liquidity token. At the end of the function call, a given amount of LP tokens are burned, and a given amount of _token0 and _token1 are returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token0 The address of an ERC20 token\\n   * @param _token1 The address of an ERC20 token\\n   * @param _liquidity The amount of LP tokens to be burned\\n   * @param _amount0Min The minimal amount of _token that the user will accept for a given amount of _liquidity\\n   * @param _amount1Min The minimal amount of _token that the user will accept for a given amount of _liquidity\\n   * @param _deadline The UTC timestamp that if reached, causes the transaction to fail automatically\\n   * @return amount0 The amount of _token that are returned to the recipient\\n   * @return amount1 The amount of ether that are returned to the recipient\\n   */\\n  function removeLiquidity(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _liquidity,\\n    uint _amount0Min,\\n    uint _amount1Min,\\n    uint _deadline\\n  ) external override ensure(_deadline) returns (uint amount0, uint amount1) {\\n    (amount0, amount1) = _removeLiquidityOptions(\\n      _to,\\n      _token0,\\n      _token1,\\n      _liquidity,\\n      _amount0Min,\\n      _amount1Min\\n    );\\n  }\\n\\n  // **** SWAP ****\\n  // requires the initial amount to have already been sent to the primary pool\\n  function _swap(\\n    address _token0,\\n    address _token1,\\n    address _to\\n  ) internal returns (uint input, uint output) {\\n    (input, output) = IXfaiV0Core(core).swap(_token0, _token1, _to);\\n  }\\n\\n  /**\\n   * @notice Swap an exact amount of one ERC20 token (_token0) for another one (_token1)\\n   * @dev Requires _token0  approval. At the end of the function call, an amount _amount0In of _token0 is deposited into Xfai, and a given amount (larger than _amount1OutMin) of _token1 is returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token0 An ERC20 token address\\n   * @param _token1 An ERC20 token address\\n   * @param _amount0In The amount of _token0 to be swapped\\n   * @param _amount1OutMin The minimal amount of _token1 that the user will accept for a given amount of _amount0In\\n   * @param _deadline The UTC timestamp that if reached, causes the transaction to fail automatically\\n   */\\n  function swapExactTokensForTokens(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _amount0In,\\n    uint _amount1OutMin,\\n    uint _deadline\\n  ) external override ensure(_deadline) returns (uint) {\\n    address pool;\\n    if (_token0 == xfETH) {\\n      pool = XfaiLibrary.poolFor(_token1, factory, poolCodeHash);\\n    } else {\\n      pool = XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\\n    }\\n    TransferHelper.safeTransferFrom(_token0, msg.sender, pool, _amount0In);\\n    (, uint amount1Out) = _swap(_token0, _token1, _to);\\n    require(amount1Out \\u003e= _amount1OutMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    return amount1Out;\\n  }\\n\\n  /**\\n   * @notice Swap an amount of one ERC20 token (_token0) for an exact amount of another one (_token1)\\n   * @dev Requires _token0  approval. At the end of the function call, an amount (smaller than _amount0InMax) of _token0 is deposited into xfai, and an amount _amount1Out og _token1 is returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token0 An ERC20 token address\\n   * @param _token1 An ERC20 token address\\n   * @param _amount1Out The amount of _token1 that one wants to receive\\n   * @param _amount0InMax The maximal amount of _token0 that the user is willing to trade for a given amount of _amount1Out\\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\\n   */\\n  function swapTokensForExactTokens(\\n    address _to,\\n    address _token0,\\n    address _token1,\\n    uint _amount1Out,\\n    uint _amount0InMax,\\n    uint _deadline\\n  ) external override ensure(_deadline) returns (uint amount0In) {\\n    address pool0;\\n    address pool1;\\n    if (_token0 == xfETH) {\\n      pool0 = XfaiLibrary.poolFor(_token1, factory, poolCodeHash);\\n      pool1 = XfaiLibrary.poolFor(_token1, factory, poolCodeHash);\\n      (uint r, uint w) = IXfaiPool(pool0).getStates();\\n      amount0In = XfaiLibrary.getAmountIn(w, r, _amount1Out, IXfaiV0Core(core).getTotalFee());\\n    } else if (_token1 == xfETH) {\\n      pool0 = XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\\n      (uint r, uint w) = IXfaiPool(pool0).getStates();\\n      amount0In = XfaiLibrary.getAmountIn(r, w, _amount1Out, IXfaiV0Core(core).getTotalFee());\\n    } else {\\n      pool0 = XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\\n      pool1 = XfaiLibrary.poolFor(_token1, factory, poolCodeHash);\\n      amount0In = XfaiLibrary.getAmountsIn(\\n        pool0,\\n        pool1,\\n        _amount1Out,\\n        IXfaiV0Core(core).getTotalFee()\\n      );\\n    }\\n    require(amount0In \\u003c= _amount0InMax, \\u0027XfaiV0Periphery02: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n    TransferHelper.safeTransferFrom(_token0, msg.sender, pool0, amount0In);\\n    _swap(_token0, _token1, _to);\\n  }\\n\\n  /**\\n   * @notice Swap an exact amount of ether for an ERC20 token (_token1)\\n   * @dev At the end of the function call, an exact amount of ether is deposited into Xfai, and a given amount (larger than _amount1OutMin) of _token1 is returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token1 An ERC20 token address\\n   * @param _amount1OutMin The minimal amount of _token1 that the user will accept for a given amount of _amount0In\\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\\n   */\\n  function swapExactETHForTokens(\\n    address _to,\\n    address _token1,\\n    uint _amount1OutMin,\\n    uint _deadline\\n  ) external payable override ensure(_deadline) returns (uint amount1Out) {\\n    address wrappedETH = weth; // gas savings\\n    uint amount0In = msg.value;\\n    address pool0 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\\n    IWETH(wrappedETH).deposit{value: amount0In}();\\n    assert(IWETH(weth).transfer(pool0, amount0In));\\n    if (_token1 == xfETH) {\\n      (, amount1Out) = _swap(wrappedETH, xfETH, _to);\\n    } else {\\n      (, amount1Out) = _swap(wrappedETH, _token1, _to);\\n    }\\n    require(amount1Out \\u003e= _amount1OutMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n  }\\n\\n  /**\\n   * @notice Swap an amount of one ERC20 token (_token0) for an exact amount of ether\\n   * @dev Requires _token0  approval. At the end of the function call, a given amount (smaller than _amount0InMax) of _token0 is deposited into xfai, and and the amount _amount1Out of ether is returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token0 An ERC20 token address\\n   * @param _amount1Out The amount of ether that one wants to receive\\n   * @param _amount0InMax The maximal amount of _token0 that the user is willing to trade for a given amount of _amount1Out\\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\\n   */\\n  function swapTokensForExactETH(\\n    address _to,\\n    address _token0,\\n    uint _amount1Out,\\n    uint _amount0InMax,\\n    uint _deadline\\n  ) external override ensure(_deadline) returns (uint amount0In) {\\n    address wrappedETH = weth; // gas savings\\n    address pool0;\\n    if (_token0 == xfETH) {\\n      pool0 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\\n      (uint r, uint w) = IXfaiPool(pool0).getStates();\\n      amount0In = XfaiLibrary.getAmountIn(w, r, _amount1Out, IXfaiV0Core(core).getTotalFee());\\n    } else {\\n      pool0 = XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\\n      amount0In = XfaiLibrary.getAmountsIn(\\n        pool0,\\n        XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash),\\n        _amount1Out,\\n        IXfaiV0Core(core).getTotalFee()\\n      );\\n    }\\n    require(amount0In \\u003c= _amount0InMax, \\u0027XfaiV0Periphery02: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n    TransferHelper.safeTransferFrom(_token0, msg.sender, pool0, amount0In);\\n    _swap(_token0, wrappedETH, address(this));\\n    IWETH(wrappedETH).withdraw(_amount1Out);\\n    TransferHelper.safeTransferETH(_to, _amount1Out);\\n    return amount0In;\\n  }\\n\\n  /**\\n   * @notice Swap an exact amount of one ERC20 token (_token0) for ether\\n   * @dev Requires _token0  approval. At the end of the function call, a given amount _amount0In of _token0 is deposited into Xfai, and an amount (larger than _amount1OutMin) of ether is returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token0 An ERC20 token address\\n   * @param _amount0In The amount of _token0 to be swapped\\n   * @param _amount1OutMin The minimal amount of ether that the user will accept for a given amount of _amount0In\\n   * @param _deadline The UTC timestamp that if reached, causes the transaction to fail automatically\\n   */\\n  function swapExactTokensForETH(\\n    address _to,\\n    address _token0,\\n    uint _amount0In,\\n    uint _amount1OutMin,\\n    uint _deadline\\n  ) external override ensure(_deadline) returns (uint amount1Out) {\\n    address pool0;\\n    address wrappedETH = weth;\\n    if (_token0 == xfETH) {\\n      pool0 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\\n    } else {\\n      pool0 = XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\\n    }\\n    TransferHelper.safeTransferFrom(_token0, msg.sender, pool0, _amount0In);\\n    (, amount1Out) = _swap(_token0, wrappedETH, address(this));\\n    require(amount1Out \\u003e= _amount1OutMin, \\u0027XfaiV0Periphery02: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    IWETH(wrappedETH).withdraw(amount1Out);\\n    TransferHelper.safeTransferETH(_to, amount1Out);\\n  }\\n\\n  /**\\n   * @notice Swap an amount of ether for an exact amount of ERC20 tokens (_token1)\\n   * @dev At the end of the function call, a given amount of ether is deposited into xfai, and a given amount _amount1Out of _token1 is returned to the recipient.\\n   * @param _to The address of the recipient\\n   * @param _token1 An ERC20 token address\\n   * @param _amount1Out The amount of _token1 that the user accepts for a given amount of ether\\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\\n   */\\n  function swapETHForExactTokens(\\n    address _to,\\n    address _token1,\\n    uint _amount1Out,\\n    uint _deadline\\n  ) external payable override ensure(_deadline) returns (uint input) {\\n    address wrappedETH = weth; // gas savings\\n    address pool0 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\\n    address pool1;\\n    if (_token1 == xfETH) {\\n      pool1 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\\n      (uint r, uint w) = IXfaiPool(pool1).getStates();\\n      input = XfaiLibrary.getAmountIn(r, w, _amount1Out, IXfaiV0Core(core).getTotalFee());\\n    } else {\\n      pool1 = XfaiLibrary.poolFor(_token1, factory, poolCodeHash);\\n      input = XfaiLibrary.getAmountsIn(pool0, pool1, _amount1Out, IXfaiV0Core(core).getTotalFee());\\n    }\\n    require(input \\u003c= msg.value, \\u0027XfaiV0Periphery02: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n    IWETH(wrappedETH).deposit{value: input}();\\n    assert(IWETH(weth).transfer(pool0, input));\\n    _swap(wrappedETH, _token1, _to);\\n    // refund dust eth, if any\\n    if (msg.value \\u003e input) TransferHelper.safeTransferETH(msg.sender, msg.value - input);\\n  }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xfETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountXfETHMin\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount1OutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0In\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1OutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0In\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1OutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount0InMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount0InMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "XfaiV0Periphery02", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000b51d00ef3df0b66766938220542185f6fdbc0b7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a449845c3309ac5269dfa6b2f80eb6e73d0ae021", "EVMVersion": "Default", "Library": "XfaiLibrary:0001c69ad3feec3c5592d7d1f3d5db4e1c98b4b7", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a95f33b4286ad5dea5afdaed301e181f75bbf44e00456839003044a4264ee0c5"}