{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Sorts the pair (a, b) and hashes the result.\\n     */\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/ListHelper.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/// @title A list helper contract\\nabstract contract ListHelper {\\n    uint16 internal constant LOOP_LIMIT = 500;\\n    bool internal constant ALLOW_ZERO = true;\\n    bool internal constant DISALLOW_ZERO = false;\\n\\n    error InvalidStart();\\n    error InvalidEnd();\\n    error InvalidSequence();\\n\\n    /**\\n     * @param _start Start\\n     * @param _end End\\n     * @param _total List total\\n     * @param _allowZero true - zero is a valid start or end, false - zero is an invalid start or end\\n     */\\n    modifier onlyValidSequence(\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 _total,\\n        bool _allowZero\\n    ) {\\n        _checkSequence(_start, _end, _total, _allowZero);\\n        _;\\n    }\\n\\n    /**\\n     * @param _start Start\\n     * @param _end End\\n     * @param _total Total\\n     * @param _allowZero true - zero is a valid start or end, false - zero is an invalid start or end\\n     * @dev check that a range of indexes is valid.\\n     */\\n    function _checkSequence(\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 _total,\\n        bool _allowZero\\n    ) private pure {\\n        if (_allowZero) {\\n            if (_start >= _total) revert InvalidStart();\\n            if (_end >= _total) revert InvalidEnd();\\n        } else {\\n            if (_start == 0 || _start > _total) revert InvalidStart();\\n            if (_end == 0 || _end > _total) revert InvalidEnd();\\n        }\\n        if (_start > _end) revert InvalidStart();\\n        if (_end - _start + 1 > LOOP_LIMIT) revert InvalidSequence();\\n    }\\n\\n    /// @dev _length List length\\n    function _validateListLength(uint256 _length) internal pure {\\n        if (_length == 0 || LOOP_LIMIT < _length) revert OTSeaErrors.InvalidArrayLength();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/// @title A transfer helper contract for ETH and tokens\\ncontract TransferHelper is Context {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev account -> Amount of ETH that failed to transfer\\n    mapping(address => uint256) private _maroonedETH;\\n\\n    error NativeTransferFailed();\\n\\n    event MaroonedETH(address account, uint256 amount);\\n    event MaroonedETHClaimed(address account, address receiver, uint256 amount);\\n\\n    /**\\n     * @notice Claim marooned ETH\\n     * @param _receiver Address to receive the marooned ETH\\n     */\\n    function claimMaroonedETH(address _receiver) external {\\n        if (_receiver == address(0)) revert OTSeaErrors.InvalidAddress();\\n        uint256 amount = _maroonedETH[_msgSender()];\\n        if (amount == 0) revert OTSeaErrors.NotAvailable();\\n        _maroonedETH[_msgSender()] = 0;\\n        _transferETHOrRevert(_receiver, amount);\\n        emit MaroonedETHClaimed(_msgSender(), _receiver, amount);\\n    }\\n\\n    /**\\n     * @notice Get the amount of marooned ETH for an account\\n     * @param _account Account to check\\n     * @return uint256 Marooned ETH\\n     */\\n    function getMaroonedETH(address _account) external view returns (uint256) {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        return _maroonedETH[_account];\\n    }\\n\\n    /**\\n     * @param _account Account to transfer ETH to\\n     * @param _amount Amount of ETH to transfer to _account\\n     * @dev Rather than reverting if the transfer fails, the _amount is stored for the _account to later claim\\n     */\\n    function _safeETHTransfer(address _account, uint256 _amount) internal {\\n        (bool success, ) = _account.call{value: _amount}(\\\"\\\");\\n        if (!success) {\\n            _maroonedETH[_account] += _amount;\\n            emit MaroonedETH(_account, _amount);\\n        }\\n    }\\n\\n    /**\\n     * @param _account Account to transfer ETH to\\n     * @param _amount Amount of ETH to transfer to _account\\n     * @dev The following will revert if the transfer fails\\n     */\\n    function _transferETHOrRevert(address _account, uint256 _amount) internal {\\n        (bool success, ) = _account.call{value: _amount}(\\\"\\\");\\n        if (!success) revert NativeTransferFailed();\\n    }\\n\\n    /**\\n     * @param _token Token to transfer into the contract from msg.sender\\n     * @param _amount Amount of _token to transfer\\n     * @return uint256 Actual amount transferred into the contract\\n     * @dev This function exists due to _token potentially having taxes\\n     */\\n    function _transferInTokens(IERC20 _token, uint256 _amount) internal returns (uint256) {\\n        uint256 balanceBefore = _token.balanceOf(address(this));\\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\\n        return _token.balanceOf(address(this)) - balanceBefore;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OTSeaErrors.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title Common OTSea errors\\nlibrary OTSeaErrors {\\n    error InvalidAmount();\\n    error InvalidAddress();\\n    error InvalidIndex(uint256 index);\\n    error InvalidAmountAtIndex(uint256 index);\\n    error InvalidAddressAtIndex(uint256 index);\\n    error DuplicateAddressAtIndex(uint256 index);\\n    error AddressNotFoundAtIndex(uint256 index);\\n    error Unauthorized();\\n    error ExpectationMismatch();\\n    error InvalidArrayLength();\\n    error InvalidFee();\\n    error NotAvailable();\\n    error InvalidPurchase();\\n    error InvalidETH(uint256 expected);\\n    error Unchanged();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OTSeaLibrary.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title Common OTSea variables\\nlibrary OTSeaLibrary {\\n    enum FeeType {\\n        Fish,\\n        Whale\\n    }\\n\\n    uint16 internal constant PERCENT_DENOMINATOR = 10000;\\n    address internal constant DEAD_ADDRESS = address(0xdead);\\n}\\n\"\r\n    },\r\n    \"contracts/token/OTSeaERC20.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    ERC20 Token.\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"contracts/helpers/TransferHelper.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\nimport \\\"contracts/libraries/OTSeaLibrary.sol\\\";\\nimport \\\"contracts/token/OTSeaMigration.sol\\\";\\nimport \\\"contracts/token/OTSeaRevenueDistributor.sol\\\";\\nimport \\\"contracts/token/OTSeaStaking.sol\\\";\\n\\n/**\\n * @title OTSea v1 ERC20 Token Overview\\n * @dev This ERC20 token, part of OTSea's v1, includes specific fees for buy/sell/transfer operations:\\n * - Burn Fee: A portion of tokens from each transaction is sent to the dead address.\\n * - Revenue Boost Fee: A portion of tokens from each transaction is accumulated in the contract. Once over a\\n *   \\\"swap threshold\\\", these tokens are converted to Ethereum (ETH) during sell transactions.\\n *\\n * All revenue fees from the token and the platform are sent to a revenue distributor contract that periodically\\n * distributes fees to stakers.\\n *\\n * The token is managed by a multi-signature wallet, with the following capabilities:\\n * - Add Initial Liquidity: Add initial liquidity into a Uniswap V2 pool.\\n * - Fee Adjustment: Alter or lower the fee percentages. Note: fee increases are not permitted.\\n * - Swap Threshold Management: Update the threshold for the Revenue Boost Fee conversion into ETH, within a range\\n *   of 1,000 to 100,000 tokens.\\n * - Transfer Fee Toggling: Can enable or disable fees on transfer. Note that this doesn't affect buy/sell fees.\\n * - Transfer Fee Whitelisting: Can exempt specific addresses from paying the transfer fees. Note that this doesn't\\n *   affect buy/sell fees.\\n *\\n * The owner, migration contract, and staking contract are permanently exempt from transfer fees. If the ownership\\n * is transferred to another wallet, the new owner also becomes transfer fee exempt. The previous owner remains transfer\\n * fee exempt and the new owner can decide whether or not to remove their transfer fee exempt status.\\n */\\ncontract OTSeaERC20 is Ownable, ERC20, TransferHelper {\\n    IUniswapV2Router02 private constant _router =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    uint88 private constant TOTAL_SUPPLY = 100_000_000 ether;\\n    uint88 private constant MIN_SWAP_AT = 1_000 ether;\\n    uint88 private constant MAX_SWAP_AT = 100_000 ether;\\n    OTSeaMigration public immutable migrationContract;\\n    OTSeaStaking public immutable stakingContract;\\n    OTSeaRevenueDistributor public immutable revenueDistributor;\\n    bool public isTransferFeeEnabled = true;\\n    /// @dev Revenue boost fee is initially set to 2% of the transaction\\n    uint16 private _revBoostFeePercent = 200;\\n    /// @dev Treasury fee is initially set to 2% of the transaction\\n    uint16 private _treasuryFeePercent = 200;\\n    /// @dev Burn fee is initially set to 0% of the transaction\\n    uint16 private _burnFeePercent = 0;\\n    /// @dev Threshold at which the collected revenue boost fees are swapped to ETH and sent to the revenue distributor\\n    uint88 private _swapAt = 5_000 ether;\\n    address private _pair;\\n    mapping(address => bool) public isExemptFromTransferFee;\\n\\n    event AddedLiquidity(address pair, uint256 token, uint256 eth);\\n    event FeesUpdated(uint16 revBoostFeePercent, uint16 treasuryFeePercent, uint16 burnFeePercent);\\n    event SwapAtUpdated(uint256 swapAt);\\n    event TransferFeeToggled(bool isTransferFeeEnabled);\\n    event TransferFeeWhitelistUpdated(address indexed account, bool whitelisted);\\n    event Burned(uint256 amount);\\n    event DistributedETHFees(uint256 revBoost, uint256 treasury);\\n\\n    modifier whenFeeIsSet() {\\n        _checkIfFeeIsSet();\\n        _;\\n    }\\n\\n    /**\\n     * @param _multiSigAdmin Multi-sig admin\\n     * @param _migrationContract Migration contract\\n     * @param _stakingContract Staking contract\\n     * @param _revenueDistributor Revenue distributor\\n     */\\n    constructor(\\n        address _multiSigAdmin,\\n        OTSeaMigration _migrationContract,\\n        OTSeaStaking _stakingContract,\\n        OTSeaRevenueDistributor _revenueDistributor\\n    ) ERC20(\\\"OTSea\\\", \\\"OTSea\\\") Ownable(_multiSigAdmin) {\\n        if (\\n            address(_migrationContract) == address(0) ||\\n            address(_stakingContract) == address(0) ||\\n            address(_revenueDistributor) == address(0)\\n        ) revert OTSeaErrors.InvalidAddress();\\n        if (\\n            _migrationContract.multiSigAdmin() != _multiSigAdmin ||\\n            _stakingContract.owner() != _multiSigAdmin ||\\n            _revenueDistributor.owner() != _multiSigAdmin\\n        ) revert OwnableInvalidOwner(_multiSigAdmin);\\n        migrationContract = _migrationContract;\\n        stakingContract = _stakingContract;\\n        revenueDistributor = _revenueDistributor;\\n        isExemptFromTransferFee[address(_migrationContract)] = true;\\n        isExemptFromTransferFee[_multiSigAdmin] = true;\\n        isExemptFromTransferFee[address(_stakingContract)] = true;\\n        _mint(address(_migrationContract), TOTAL_SUPPLY);\\n    }\\n\\n    /**\\n     * @notice Enter the sea\\n     * @param _amount Amount of OTSea to add to the initial liquidity\\n     */\\n    function enterTheSea(uint256 _amount) external payable onlyOwner {\\n        if (_pair != address(0)) revert OTSeaErrors.NotAvailable();\\n        if (_amount == 0 || msg.value == 0) revert OTSeaErrors.InvalidAmount();\\n        super._update(_msgSender(), address(this), _amount);\\n        _approve(address(this), address(_router), _amount);\\n        /// @dev multi-sig admin receives initial LP\\n        _router.addLiquidityETH{value: msg.value}(\\n            address(this),\\n            _amount,\\n            0,\\n            0,\\n            owner(),\\n            block.timestamp\\n        );\\n        address uniswapV2Pair = IUniswapV2Factory(_router.factory()).getPair(\\n            address(this),\\n            _router.WETH()\\n        );\\n        _pair = uniswapV2Pair;\\n        emit AddedLiquidity(_pair, _amount, msg.value);\\n    }\\n\\n    /**\\n     * @notice Update the fee percents\\n     * @param revBoostFeePercent_ Rev boost fee percent (2 d.p. e.g. 1% = 100)\\n     * @param treasuryFeePercent_ Treasury fee percent (2 d.p. e.g. 1% = 100)\\n     * @param burnFeePercent_ Burn fee percent (2 d.p. e.g. 1% = 100)\\n     */\\n    function updateFees(\\n        uint16 revBoostFeePercent_,\\n        uint16 treasuryFeePercent_,\\n        uint16 burnFeePercent_\\n    ) external onlyOwner whenFeeIsSet {\\n        uint16 totalFeePercent = _getTotalFeePercent();\\n        uint16 newTotalFeePercent = revBoostFeePercent_ + treasuryFeePercent_ + burnFeePercent_;\\n        if (totalFeePercent < newTotalFeePercent) revert OTSeaErrors.InvalidFee();\\n        if (newTotalFeePercent == 0) {\\n            uint256 balance = balanceOf(address(this));\\n            if (balance != 0) {\\n                _sendToDeadAddress(address(this), balance);\\n            }\\n            delete isTransferFeeEnabled;\\n            delete _swapAt;\\n        }\\n        _revBoostFeePercent = revBoostFeePercent_;\\n        _treasuryFeePercent = treasuryFeePercent_;\\n        _burnFeePercent = burnFeePercent_;\\n        emit FeesUpdated(revBoostFeePercent_, treasuryFeePercent_, burnFeePercent_);\\n    }\\n\\n    /**\\n     * @notice Update the swap at threshold at which the collected fees for rev boost and treasury get swapped for ETH\\n     * and distributed\\n     * @param _amount Amount of tokens required to trigger the swap\\n     */\\n    function updateSwapAt(uint88 _amount) external onlyOwner whenFeeIsSet {\\n        if (_amount < MIN_SWAP_AT || MAX_SWAP_AT < _amount) revert OTSeaErrors.InvalidAmount();\\n        _swapAt = _amount;\\n        emit SwapAtUpdated(_amount);\\n    }\\n\\n    /// @notice Toggle transfer fee\\n    function toggleTransferFee() external onlyOwner whenFeeIsSet {\\n        isTransferFeeEnabled = !isTransferFeeEnabled;\\n        emit TransferFeeToggled(isTransferFeeEnabled);\\n    }\\n\\n    /**\\n     * @notice Update the transfer fee whitelist\\n     * @param _account Account\\n     * @param _operation add (true) or remove (false) \\\"account\\\" to/from the whitelist\\n     */\\n    function updateTransferFeeWhitelist(\\n        address _account,\\n        bool _operation\\n    ) external onlyOwner whenFeeIsSet {\\n        if (_isSpecialAddress(_account)) revert OTSeaErrors.InvalidAddress();\\n        if (isExemptFromTransferFee[_account] == _operation) revert OTSeaErrors.Unchanged();\\n        _updateTransferFeeWhitelist(_account, _operation);\\n    }\\n\\n    /**\\n     * @notice Get the pair address\\n     * @return address Pair\\n     */\\n    function getPair() external view returns (address) {\\n        if (_pair == address(0)) revert OTSeaErrors.NotAvailable();\\n        return _pair;\\n    }\\n\\n    /**\\n     * @notice Get fee details\\n     * @return swapAt Swap at threshold where collected fees get swapped for ETH and distributed\\n     * @return revBoostPercent Rev boost percent\\n     * @return treasuryFeePercent Treasury percent\\n     * @return burnPercent Burn percent\\n     */\\n    function getFeeDetails()\\n        external\\n        view\\n        returns (\\n            uint256 swapAt,\\n            uint16 revBoostPercent,\\n            uint16 treasuryFeePercent,\\n            uint16 burnPercent\\n        )\\n    {\\n        return (_swapAt, _revBoostFeePercent, _treasuryFeePercent, _burnFeePercent);\\n    }\\n\\n    /**\\n     * @param _from From address\\n     * @param _to To address\\n     * @param _value Value\\n     * @dev Overrides ERC20's _update() function in order to handle fees and disable trading prior to adding liquidity\\n     */\\n    function _update(address _from, address _to, uint256 _value) internal override {\\n        /**\\n         * @dev the following if statement works as follows:\\n         * - _from == address(this): makes _swapAndDistributeFees tax free\\n         * - _pair == address(0) && _isSpecialAddress(_from): is for when the liquidity hasn't been added yet, only\\n         *   special addresses are allowed to transfer\\n         */\\n        if (_from == address(this) || (_pair == address(0) && _isSpecialAddress(_from))) {\\n            super._update(_from, _to, _value);\\n            return;\\n        }\\n        if (_pair == address(0)) {\\n            revert OTSeaErrors.Unauthorized();\\n        }\\n        uint256 totalFee = _getTotalFeePercent();\\n        if (totalFee != 0) {\\n            if (_to == _pair && _swapAt <= balanceOf(address(this))) {\\n                /// @dev For sell transactions once over the threshold the contract will swap tokens for ETH\\n                _swapAndDistributeFees();\\n            }\\n            if (_shouldChargeFee(_from, _to)) {\\n                /// @dev more gas efficient passing in the totalFee than fetching it again in _takeFee()\\n                _value = _takeFee(totalFee, _from, _value);\\n            }\\n        }\\n        /// @dev buy, sell and transfers\\n        super._update(_from, _to, _value);\\n    }\\n\\n    /// @param _newOwner New owner\\n    function _transferOwnership(address _newOwner) internal override {\\n        /**\\n         * @dev Cannot check _isSpecialAddress(_newOwner) because _transferOwnership() is called in the constructor\\n         * of this contract and _isSpecialAddress() contains immutable variables. Therefore we just simply only set the\\n         * new owner to be transfer fee exempt if it is not the zero address which is relevant if renounceOwnership()\\n         * is called.\\n         */\\n        if (_newOwner != address(0)) {\\n            _updateTransferFeeWhitelist(_newOwner, true);\\n        }\\n        super._transferOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @param _totalFee Total fee\\n     * @param _from From address\\n     * @param _value Value\\n     * @return uint256 Value after fees\\n     */\\n    function _takeFee(uint256 _totalFee, address _from, uint256 _value) private returns (uint256) {\\n        /// @dev calculate fee\\n        uint256 fee = (_value * _totalFee) / OTSeaLibrary.PERCENT_DENOMINATOR;\\n        uint256 burnFee = (fee * _burnFeePercent) / _totalFee;\\n        if (burnFee != 0) {\\n            /// @dev tokens are burned immediately\\n            _sendToDeadAddress(_from, burnFee);\\n        }\\n        /// @dev ethFee is for the rev share boost and treasury fees (if configured)\\n        uint256 ethFee = fee - burnFee;\\n        if (ethFee != 0) {\\n            /// @dev tokens are stored in the contract to be later swapped for ETH\\n            super._update(_from, address(this), ethFee);\\n        }\\n        return _value - fee;\\n    }\\n\\n    function _swapAndDistributeFees() private {\\n        /// @dev slightly cheaper in gas setting _treasuryFeePercent to a local variable\\n        uint256 treasuryFeePercent = _treasuryFeePercent;\\n        uint256 total = treasuryFeePercent + _revBoostFeePercent;\\n        /// @dev swaps tokens for ETH and transfers to the revenueDistributor\\n        uint256 eth = _swapTokensForETH();\\n        uint256 treasury = (eth * treasuryFeePercent) / total;\\n        uint256 revBoost = eth - treasury;\\n        if (revBoost != 0) {\\n            _safeETHTransfer(address(revenueDistributor), revBoost);\\n        }\\n        if (treasury != 0) {\\n            _safeETHTransfer(owner(), treasury);\\n        }\\n        emit DistributedETHFees(revBoost, treasury);\\n    }\\n\\n    /// @return uint256 ETH received\\n    function _swapTokensForETH() private returns (uint256) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _router.WETH();\\n        /// @dev sell the _swapAt amount rather than the total balance\\n        uint256 amount = uint256(_swapAt);\\n        _approve(address(this), address(_router), amount);\\n        uint256 ethBalanceBefore = address(this).balance;\\n        _router.swapExactTokensForETH(amount, 0, path, address(this), block.timestamp);\\n        return address(this).balance - ethBalanceBefore;\\n    }\\n\\n    /**\\n     * @param _from From address\\n     * @param _amount Amount of tokens to send to the dead address\\n     */\\n    function _sendToDeadAddress(address _from, uint256 _amount) private {\\n        super._update(_from, OTSeaLibrary.DEAD_ADDRESS, _amount);\\n        emit Burned(_amount);\\n    }\\n\\n    /**\\n     * @param _account Account\\n     * @param _operation add (true) or remove (false) \\\"account\\\" to/from the whitelist\\n     */\\n    function _updateTransferFeeWhitelist(address _account, bool _operation) private {\\n        isExemptFromTransferFee[_account] = _operation;\\n        emit TransferFeeWhitelistUpdated(_account, _operation);\\n    }\\n\\n    /**\\n     * @param _account Account\\n     * @return bool true if _account is a special address, false if not\\n     */\\n    function _isSpecialAddress(address _account) private view returns (bool) {\\n        return\\n            _account == address(migrationContract) ||\\n            _account == owner() ||\\n            _account == address(stakingContract) ||\\n            _account == address(0);\\n    }\\n\\n    /**\\n     * @param _from From address\\n     * @param _to To address\\n     * @return bool true if a fee should be charged, false if not\\n     * @dev Checks whether a fee should be charged. The logic works as follows:\\n     * - Buy fees are always charged unless the buyer is the staking contract\\n     * - Sell fees are always charged\\n     * - Transfer fees are charged if the transfer fee is enabled and neither the _from nor _to address are transfer\\n     *   fee exempt\\n     */\\n    function _shouldChargeFee(address _from, address _to) private view returns (bool) {\\n        return\\n            (_from == _pair && _to != address(stakingContract)) ||\\n            _to == _pair ||\\n            (isTransferFeeEnabled &&\\n                !isExemptFromTransferFee[_from] &&\\n                !isExemptFromTransferFee[_to]);\\n    }\\n\\n    function _checkIfFeeIsSet() private view {\\n        if (_getTotalFeePercent() == 0) revert OTSeaErrors.NotAvailable();\\n    }\\n\\n    /// @return uint16 Total fee percent\\n    function _getTotalFeePercent() private view returns (uint16) {\\n        return _revBoostFeePercent + _treasuryFeePercent + _burnFeePercent;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/token/OTSeaMigration.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    Beta -> V1 Migration.\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"contracts/helpers/ListHelper.sol\\\";\\nimport \\\"contracts/helpers/TransferHelper.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\nimport \\\"contracts/libraries/OTSeaLibrary.sol\\\";\\n\\n/**\\n * @notice OTSea one-way beta -> v1 migration contract\\n * @dev This contract facilitates the migration from the current (beta) token to the new v1 token.\\n *\\n * Migration steps:\\n * 1. The team coordinate whales to approve the smart contract.\\n * 2. The team will take a snapshot of the holder's balances of the beta token and generate a merkle tree. From this\\n * merkle tree we can get the root.\\n * 3. The root is uploaded into the contract (can only be done once).\\n * 4. The team uses the smart contract to sell the approved tokens in Step 1, with the aim of gathering as much ETH\\n *    as possible so that it can be used to fund the v1 liquidity pool. All whales participating receive a credit as\\n *    opposed to receiving the v1 token straight away.\\n * 5. The team deploys and adds the v1 token address in the contract. The purpose of not deploying the v1 contract in a\\n *    prior step is because Etherscan will show that the OTSea deployer has deployed a new token which could affect the\\n *    amount of ETH received in Step 4 (depending on if the community sees the new token deployed).\\n * 6. Upon configuring the v1 token, users can then migrate their tokens from the beta token to the v1 token using\\n *    a merkle proof via the migrate() function (on the dApp). The coordinated whales that received a credit in Step 4\\n *    can claim their v1 tokens via the claimCredit() function. Also the team can claim tokens for addresses that can't\\n *    claim for themselves, these are known as special addresses.\\n *\\n * The following addresses are special address:\\n * - OTSeaERC20: 0x37DA9DE38c4094e090c014325f6eF4baEB302626\\n * - Dead address: 0x000000000000000000000000000000000000dEaD\\n * - OTSea (platform): 0x28A2F7849f0a2BCCf1F5D246cEf5a6867A5BFa23\\n * - Uniswap V2 pair (OTSea/WETH): 0xd46934919D9138d3005C1f8Db794f03E7415bAbD\\n *\\n * Note: Any tokens in the current (beta) OTSea (platform) contract will be claimed by the team (as per Step 6) and\\n * manually transferred to the relevant order creator(s).\\n */\\ncontract OTSeaMigration is Ownable, TransferHelper, ListHelper {\\n    using SafeERC20 for IERC20;\\n\\n    struct Migration {\\n        address wallet;\\n        /// @dev amount to migrate\\n        uint256 amount;\\n        /// @dev amount recorded on snapshot (used to reconstruct the leaf)\\n        uint256 snapshot;\\n        bytes32[] proof;\\n    }\\n\\n    IUniswapV2Router02 private constant _router =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    address private constant BETA_PAIR_ADDRESS = 0xd46934919D9138d3005C1f8Db794f03E7415bAbD;\\n    address private constant BETA_OTSEA_PLATFORM = 0x28A2F7849f0a2BCCf1F5D246cEf5a6867A5BFa23;\\n    IERC20 private constant _beta = IERC20(0x37DA9DE38c4094e090c014325f6eF4baEB302626);\\n    uint24 private constant MIGRATION_PERIOD = 90 days;\\n    address public immutable multiSigAdmin;\\n    IERC20 public v1;\\n    address public treasury;\\n    bool public hasLiquidityBeenExtracted;\\n    uint32 public migrationDeadline;\\n    bytes32 public merkleRoot;\\n    mapping(address => uint256) private _migrated;\\n    mapping(address => uint256) private _credit;\\n\\n    error InvalidRoot();\\n    error InvalidProof();\\n    error InvalidMinETHAmount();\\n    error AmountExceedsSnapshot();\\n    error RootNotUploaded();\\n\\n    event MerkleRootUploaded(bytes32 root);\\n    event Migrated(address indexed account, Migration migration);\\n    event CreditClaimed(address indexed account, uint256 credit);\\n    event V1TokenConfigured(address token, uint32 migrationDeadline);\\n    event ExtractedLiquidity(Migration[] migrations, uint256 amountSold, uint256 ethReceived);\\n    event SoldBetaTokens(uint256 amountSold, uint256 ethReceived);\\n    event ClaimedUnclaimedV1Tokens(uint256 amount);\\n\\n    modifier canMigrate() {\\n        _checkCanMigrate();\\n        _;\\n    }\\n\\n    modifier afterRootUploaded() {\\n        _checkRootUploaded();\\n        _;\\n    }\\n\\n    /**\\n     * @param _multiSigAdmin Multi-sig admin\\n     * @param _migrationHandler Migration handler\\n     */\\n    constructor(address _multiSigAdmin, address _migrationHandler) Ownable(_migrationHandler) {\\n        if (_multiSigAdmin == address(0)) revert OTSeaErrors.InvalidAddress();\\n        multiSigAdmin = _multiSigAdmin;\\n    }\\n\\n    /**\\n     * @notice Upload the merkle root, can only be uploaded once\\n     * @param _merkleRoot Merkle root\\n     */\\n    function uploadMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\\n        if (_isRootUploaded()) revert OTSeaErrors.NotAvailable();\\n        if (_merkleRoot == bytes32(0)) revert InvalidRoot();\\n        merkleRoot = _merkleRoot;\\n        emit MerkleRootUploaded(_merkleRoot);\\n    }\\n\\n    /**\\n     * @notice Extract liquidity by selling tokens from whales that have approved this contract\\n     * @param _migrations Migrations\\n     * @param _minETHAmount Minimum ETH to receive from selling\\n     * @dev this function can only be called once\\n     */\\n    function extractLiquidity(\\n        Migration[] calldata _migrations,\\n        uint256 _minETHAmount\\n    ) external onlyOwner afterRootUploaded {\\n        if (hasLiquidityBeenExtracted) revert OTSeaErrors.NotAvailable();\\n        uint256 length = _migrations.length;\\n        _validateListLength(length);\\n        if (_minETHAmount == 0) revert InvalidMinETHAmount();\\n        hasLiquidityBeenExtracted = true;\\n        uint256 betaBalanceBefore = _beta.balanceOf(address(this));\\n        for (uint256 i; i < length; ) {\\n            if (_migrations[i].wallet == address(0)) revert OTSeaErrors.InvalidAddressAtIndex(i);\\n            if (_credit[_migrations[i].wallet] != 0) revert OTSeaErrors.DuplicateAddressAtIndex(i);\\n            _validateMigration(_migrations[i]);\\n            _checkSufficientAmount(_migrations[i]);\\n            _credit[_migrations[i].wallet] = _migrations[i].amount;\\n            _beta.safeTransferFrom(_migrations[i].wallet, address(this), _migrations[i].amount);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        uint256 amountToSell = _beta.balanceOf(address(this)) - betaBalanceBefore;\\n        uint256 ethReceived = _sell(amountToSell, _minETHAmount);\\n        emit ExtractedLiquidity(_migrations, amountToSell, ethReceived);\\n    }\\n\\n    /**\\n     * @notice Configure the contract to add the v1 token, doing so will allow users to migrate\\n     * @param _token Token Migrations\\n     * @dev this function can only be called once\\n     */\\n    function configureV1Token(IERC20 _token) external onlyOwner {\\n        /// @dev Liquidity has to have been extracted first, v1 cannot already be configured\\n        if (!hasLiquidityBeenExtracted || address(v1) != address(0))\\n            revert OTSeaErrors.NotAvailable();\\n        if (address(_token) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        v1 = _token;\\n        /// @dev Set the deadline for migration to be 90 days after the v1 token has been configured\\n        migrationDeadline = uint32(block.timestamp + MIGRATION_PERIOD);\\n        emit V1TokenConfigured(address(_token), migrationDeadline);\\n    }\\n\\n    /**\\n     * @notice Claim v1 tokens for special addresses\\n     * @param _specialMigrations Special migrations\\n     */\\n    function claimSpecialAddresses(\\n        Migration[] calldata _specialMigrations\\n    ) external onlyOwner canMigrate {\\n        uint256 length = _specialMigrations.length;\\n        _validateListLength(length);\\n        uint256 totalAmount;\\n        for (uint256 i; i < length; ) {\\n            Migration calldata migration = _specialMigrations[i];\\n            if (\\n                migration.wallet == address(_beta) ||\\n                migration.wallet == BETA_PAIR_ADDRESS ||\\n                migration.wallet == BETA_OTSEA_PLATFORM ||\\n                migration.wallet == OTSeaLibrary.DEAD_ADDRESS\\n            ) {\\n                _validateMigration(migration);\\n                _migrated[migration.wallet] += migration.amount;\\n                totalAmount += migration.amount;\\n                emit Migrated(migration.wallet, migration);\\n            } else {\\n                /// @dev revert due to _specialMigrations containing a migration for a non-special wallet\\n                revert OTSeaErrors.InvalidAddressAtIndex(i);\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        /// @dev special addresses do not receive their tokens and instead the multi-sig receives them\\n        v1.safeTransfer(multiSigAdmin, totalAmount);\\n    }\\n\\n    /// @notice Claim v1 credit (only for users that took part in the liquidity extraction)\\n    function claimCredit() external canMigrate {\\n        uint256 credit = _credit[_msgSender()];\\n        if (credit == 0) revert OTSeaErrors.NotAvailable();\\n        _credit[_msgSender()] = 0;\\n        /// @dev update _migrated[_msgSender()] so that they cannot reclaim the credit amount using migrate()\\n        _migrated[_msgSender()] += credit;\\n        v1.safeTransfer(_msgSender(), credit);\\n        emit CreditClaimed(_msgSender(), credit);\\n    }\\n\\n    /**\\n     * @notice Swap beta tokens for ETH, to be used by the owner\\n     * @param _amountToSell Amount of beta tokens to sell\\n     * @param _minETHAmount Minimum ETH to receive from selling\\n     */\\n    function sellBetaTokens(uint256 _amountToSell, uint256 _minETHAmount) external onlyOwner {\\n        if (_amountToSell == 0 || _beta.balanceOf(address(this)) < _amountToSell)\\n            revert OTSeaErrors.InvalidAmount();\\n        if (_minETHAmount == 0) revert InvalidMinETHAmount();\\n        uint256 ethReceived = _sell(_amountToSell, _minETHAmount);\\n        emit SoldBetaTokens(_amountToSell, ethReceived);\\n    }\\n\\n    /// @notice After 90 days, any unclaimed tokens are available to be claimed by the multi-sig admin\\n    function claimUnclaimedV1Tokens() external {\\n        if (_msgSender() != multiSigAdmin) revert OTSeaErrors.Unauthorized();\\n        if (address(v1) == address(0)) revert OTSeaErrors.NotAvailable();\\n        uint256 amountToClaim = v1.balanceOf(address(this));\\n        /// @dev If the deadline has not been reached yet or it has but the amount to claim is 0, it reverts\\n        if (!_isDeadlineReached() || amountToClaim == 0) revert OTSeaErrors.NotAvailable();\\n        v1.safeTransfer(multiSigAdmin, amountToClaim);\\n        emit ClaimedUnclaimedV1Tokens(amountToClaim);\\n    }\\n\\n    /**\\n     * @notice Migrate beta -> v1 tokens provided a valid merkle proof is present\\n     * @param _migration Migration\\n     */\\n    function migrate(Migration calldata _migration) external canMigrate {\\n        /// @dev if credit is owed it must first be claimed\\n        if (_credit[_msgSender()] != 0) revert OTSeaErrors.NotAvailable();\\n        if (_migration.wallet != _msgSender()) revert OTSeaErrors.Unauthorized();\\n        _validateMigration(_migration);\\n        _checkSufficientAmount(_migration);\\n        _migrate(_migration);\\n    }\\n\\n    /**\\n     * @notice Get the amount migrated by an address\\n     * @param _account Account\\n     * @return uint256 Amount migrated by _account\\n     */\\n    function getMigratedAmountByAddress(address _account) external view returns (uint256) {\\n        return _migrated[_account];\\n    }\\n\\n    /**\\n     * @notice Get the amount of v1 credit owed to an address\\n     * @param _account Account\\n     * @return uint256 Amount of credited owed to _account\\n     */\\n    function getCreditAmountByAddress(address _account) external view returns (uint256) {\\n        return _credit[_account];\\n    }\\n\\n    /// @param _migration Migration\\n    function _migrate(Migration calldata _migration) private {\\n        _migrated[_migration.wallet] += _migration.amount;\\n        _beta.safeTransferFrom(_migration.wallet, address(this), _migration.amount);\\n        v1.safeTransfer(_migration.wallet, _migration.amount);\\n        emit Migrated(_migration.wallet, _migration);\\n    }\\n\\n    /**\\n     * @param _amountToSell Amount of beta tokens to sell\\n     * @param _minETHAmount Minimum ETH to receive from selling\\n     * @return received Amount of ETH received for selling _amountToSell beta tokens\\n     */\\n    function _sell(uint _amountToSell, uint _minETHAmount) private returns (uint256 received) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(_beta);\\n        path[1] = _router.WETH();\\n        _beta.forceApprove(address(_router), _amountToSell);\\n        uint256 ethBefore = multiSigAdmin.balance;\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            _amountToSell,\\n            _minETHAmount,\\n            path,\\n            multiSigAdmin,\\n            block.timestamp\\n        );\\n        received = multiSigAdmin.balance - ethBefore;\\n    }\\n\\n    /// @param _migration Migration\\n    function _validateMigration(Migration calldata _migration) private view {\\n        if (_migration.proof.length == 0) revert InvalidProof();\\n        if (_migration.amount == 0 || _migration.snapshot == 0) revert OTSeaErrors.InvalidAmount();\\n        if (_migration.snapshot < _migrated[_migration.wallet] + _migration.amount)\\n            revert AmountExceedsSnapshot();\\n        bytes32 leaf = keccak256(abi.encodePacked(_migration.wallet, _migration.snapshot));\\n        bool isValidProof = MerkleProof.verifyCalldata(_migration.proof, merkleRoot, leaf);\\n        if (!isValidProof) revert InvalidProof();\\n    }\\n\\n    /// @param _migration Migration\\n    function _checkSufficientAmount(Migration calldata _migration) private view {\\n        if (_beta.balanceOf(_migration.wallet) < _migration.amount)\\n            revert IERC20Errors.ERC20InsufficientBalance(\\n                _migration.wallet,\\n                _beta.balanceOf(_migration.wallet),\\n                _migration.amount\\n            );\\n        if (_beta.allowance(_migration.wallet, address(this)) < _migration.amount)\\n            revert IERC20Errors.ERC20InsufficientAllowance(\\n                address(this),\\n                _beta.allowance(_migration.wallet, address(this)),\\n                _migration.amount\\n            );\\n    }\\n\\n    function _checkCanMigrate() private view {\\n        /// @dev check if the token has been configured and the deadline has not been reached\\n        if (address(v1) == address(0) || _isDeadlineReached()) revert OTSeaErrors.NotAvailable();\\n    }\\n\\n    function _checkRootUploaded() private view {\\n        if (!_isRootUploaded()) revert RootNotUploaded();\\n    }\\n\\n    /// @return bool true if the deadline has been reached, false if not\\n    function _isDeadlineReached() private view returns (bool) {\\n        return migrationDeadline < block.timestamp;\\n    }\\n\\n    /// @return bool true if root has been uploaded, false if not\\n    function _isRootUploaded() private view returns (bool) {\\n        return merkleRoot != bytes32(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/OTSeaRevenueDistributor.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    Revenue Distributor.\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\nimport \\\"contracts/token/OTSeaStaking.sol\\\";\\n\\n/**\\n * @notice OTSea ETH revenue distributor\\n * @dev This contract collects revenue (in ETH) from v1 token fees and from the platform and distributes to stakes\\n * periodically.\\n *\\n * The minimum distribution period between distributions is set in the contract by the minInterval variable. By default\\n * this is set to 6 days 23 hours and 59 minutes, this is so that a CRON job can call this function approximately\\n * every 7 days.\\n *\\n * To avoid this contract being fully centralized, any user can call the distribute() function (provided the minimum\\n * period has been met), meaning that revenue can always be paid to stakers.\\n */\\ncontract OTSeaRevenueDistributor is Ownable {\\n    uint256 private constant MINIMUM_DISTRIBUTION = 0.0001 ether;\\n    uint256 private constant MINIMUM_STAKE = 1 ether;\\n    uint24 private constant MIN_EPOCH_TIME = 1 days;\\n    uint24 private constant MAX_EPOCH_TIME = 30 days;\\n    uint24 public minInterval = 7 days - 1 minutes;\\n    OTSeaStaking public stakingContract;\\n\\n    error AlreadyInitialized();\\n    error NotInitialized();\\n\\n    event Initialized(address stakingContract);\\n    event MinDistributionIntervalUpdated(uint24 time);\\n\\n    /// @param _multiSigAdmin Multi-sig admin\\n    constructor(address _multiSigAdmin) Ownable(_multiSigAdmin) {}\\n\\n    /**\\n     * @notice Initialize the contract\\n     * @param _stakingContract Staking contract\\n     */\\n    function initialize(OTSeaStaking _stakingContract) external onlyOwner {\\n        if (isInitialized()) revert AlreadyInitialized();\\n        if (address(_stakingContract) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        stakingContract = _stakingContract;\\n        emit Initialized(address(_stakingContract));\\n    }\\n\\n    /**\\n     * @notice Set the minimum interval between distributions\\n     * @param _time Minimum duration between distributions (in seconds, with a range between 1 - 30 days)\\n     */\\n    function setMinDistributionInterval(uint24 _time) external onlyOwner {\\n        if (_time < MIN_EPOCH_TIME || MAX_EPOCH_TIME < _time) revert OTSeaErrors.InvalidAmount();\\n        minInterval = _time;\\n        emit MinDistributionIntervalUpdated(_time);\\n    }\\n\\n    /**\\n     * @notice Distribute all ETH in this contract to stakers in the stakingContract contract\\n     * @dev Anyone can call distribute after the first epoch has been ended by the owner, therefore a\\n     * minimum time interval is enforced\\n     */\\n    function distribute() external {\\n        if (!isInitialized()) revert NotInitialized();\\n        (uint32 epochNumber, OTSeaStaking.Epoch memory epoch) = stakingContract.getCurrentEpoch();\\n        if (epochNumber == 1) {\\n            if (msg.sender != stakingContract.owner()) revert OTSeaErrors.Unauthorized();\\n        } else if (block.timestamp < epoch.startedAt + minInterval) {\\n            revert OTSeaErrors.NotAvailable();\\n        }\\n        uint256 balance = address(this).balance;\\n        if (balance < MINIMUM_DISTRIBUTION || epoch.totalStake < MINIMUM_STAKE) {\\n            stakingContract.skipEpoch();\\n        } else {\\n            stakingContract.distribute{value: balance}();\\n        }\\n    }\\n\\n    /**\\n     * @notice Check if the contract is initialized\\n     * @return bool true if initialized, false if not\\n     */\\n    function isInitialized() public view returns (bool) {\\n        return address(stakingContract) != address(0);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/token/OTSeaStaking.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    OTSea Staking.\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"contracts/helpers/ListHelper.sol\\\";\\nimport \\\"contracts/helpers/TransferHelper.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/**\\n * @title OTSea Staking Contract\\n * @dev This contract enables users to stake tokens and earn rewards from v1 token fees and platform revenue.\\n * It initiates a new epoch with each reward distribution. Users who stake during an epoch do not receive rewards\\n * for that epoch, preventing exploitation through immediate pre-reward staking and withdrawal.\\n * Similarly, users withdrawing their stake in any epoch forfeit rewards that would be distributed at the end of\\n * the epoch. Rewards are calculated pro-rata based on the token amount staked in each epoch.\\n *\\n * If the revenue for distribution is less than 0.0001 ETH or if the total staked tokens are fewer than 1, the current\\n * epoch is skipped. No rewards are distributed in this case, and the accumulated revenue is carried over to the\\n * next epoch.\\n */\\ncontract OTSeaStaking is Ownable, TransferHelper, ListHelper {\\n    using SafeERC20 for IERC20;\\n\\n    struct Deposit {\\n        /**\\n         * @dev rewardReferenceEpoch represents the reference point that rewards should be based off of.\\n         *  - Upon depositing it is set to the currentEpoch + 1.\\n         *  - Upon claiming rewards it is set to the currentEpoch\\n         *  - Upon withdrawing it is set to 0\\n         */\\n        uint32 rewardReferenceEpoch;\\n        uint88 amount;\\n    }\\n\\n    struct Epoch {\\n        uint168 startedAt;\\n        uint88 totalStake;\\n        uint256 sharePerToken;\\n    }\\n\\n    IUniswapV2Router02 private constant _router =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    uint256 private constant REWARD_PRECISION = 10e38;\\n    address private immutable _revenueDistributor;\\n    bool public isDepositingAllowed;\\n    uint32 private _currentEpoch = 1;\\n    IERC20 private _otseaERC20;\\n    mapping(address => Deposit[]) private _deposits;\\n    mapping(uint32 => Epoch) private _epochs;\\n\\n    error NoRewards();\\n    error InvalidEpoch();\\n    error DepositNotFound(uint256 index);\\n\\n    event Initialized(address token);\\n    event ToggledDepositing(bool isDepositingAllowed);\\n    event Deposited(address indexed account, uint256 indexed index, Deposit deposit);\\n    event Withdrawal(\\n        address indexed account,\\n        address indexed receiver,\\n        uint256[] indexes,\\n        uint88 amount\\n    );\\n    event Claimed(\\n        address indexed account,\\n        address indexed receiver,\\n        uint256[] indexes,\\n        uint256 amount\\n    );\\n    event Compounded(\\n        address indexed account,\\n        uint256[] indexes,\\n        uint256 amountSwapped,\\n        uint256 indexed newDepositIndex,\\n        Deposit deposit\\n    );\\n    event EpochEnded(uint32 indexed id, Epoch epoch, uint256 distributed);\\n\\n    modifier onlyRevenueDistributor() {\\n        _isCallerRevenueDistributor();\\n        _;\\n    }\\n\\n    /**\\n     * @param _multiSigAdmin Multi-sig admin\\n     * @param revenueDistributor_ Revenue distributor contract\\n     */\\n    constructor(address _multiSigAdmin, address revenueDistributor_) Ownable(_multiSigAdmin) {\\n        if (address(revenueDistributor_) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        _revenueDistributor = revenueDistributor_;\\n    }\\n\\n    /**\\n     * @notice Initialize and start the first epoch\\n     * @param _token Token\\n     */\\n    function initialize(IERC20 _token) external onlyOwner {\\n        if (address(_token) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        if (_isInitialized()) revert OTSeaErrors.NotAvailable();\\n        _otseaERC20 = _token;\\n        _epochs[1].startedAt = uint168(block.timestamp);\\n        emit Initialized(address(_token));\\n    }\\n\\n    /// @notice Toggle depositing\\n    function toggleDepositing() external onlyOwner {\\n        if (!_isInitialized()) revert OTSeaErrors.NotAvailable();\\n        isDepositingAllowed = !isDepositingAllowed;\\n        emit ToggledDepositing(isDepositingAllowed);\\n    }\\n\\n    /// @notice Distribute ETH to stakers (only revenue distributor)\\n    function distribute() external payable onlyRevenueDistributor {\\n        uint32 currentEpoch = _currentEpoch;\\n        uint256 sharePerToken = (REWARD_PRECISION * msg.value) / _epochs[currentEpoch].totalStake;\\n        _epochs[currentEpoch].sharePerToken += sharePerToken;\\n        _nextEpoch();\\n        emit EpochEnded(currentEpoch, _epochs[currentEpoch], msg.value);\\n    }\\n\\n    /// @notice Skip epoch (only revenue distributor)\\n    function skipEpoch() external onlyRevenueDistributor {\\n        uint32 currentEpoch = _currentEpoch;\\n        _nextEpoch();\\n        emit EpochEnded(currentEpoch, _epochs[currentEpoch], 0);\\n    }\\n\\n    /**\\n     * @notice Stake OTSea tokens and earn ETH\\n     * @param _amount OTSea amount\\n     */\\n    function stake(uint88 _amount) external {\\n        if (!isDepositingAllowed) revert OTSeaErrors.NotAvailable();\\n        if (_amount == 0) revert OTSeaErrors.InvalidAmount();\\n        _checkSufficientAmount(_amount);\\n        /**\\n         * @dev current deposit index = _deposits[_msgSender()].length - 1, therefore if we add 1 to get the next index\\n         * it cancels out with the \\\"-1\\\" to just give _deposits[_msgSender()].length\\n         */\\n        Deposit memory deposit = _createDeposit(_amount);\\n        _otseaERC20.safeTransferFrom(_msgSender(), address(this), uint256(_amount));\\n        emit Deposited(_msgSender(), _deposits[_msgSender()].length - 1, deposit);\\n    }\\n\\n    /**\\n     * @notice Withdraw multiple deposits as well as claim their rewards\\n     * @param _indexes A list of deposit IDs to withdraw\\n     * @param _receiver Address to receive the tokens and ETH\\n     */\\n    function withdraw(uint256[] calldata _indexes, address _receiver) external {\\n        if (_receiver == address(0)) revert OTSeaErrors.InvalidAddress();\\n        (uint88 totalAmount, uint256 totalRewards) = _withdrawMultiple(_indexes);\\n        if (totalRewards != 0) {\\n            _transferETHOrRevert(_receiver, totalRewards);\\n            emit Claimed(_msgSender(), _receiver, _indexes, totalRewards);\\n        }\\n        _otseaERC20.safeTransfer(_receiver, uint256(totalAmount));\\n        emit Withdrawal(_msgSender(), _receiver, _indexes, totalAmount);\\n    }\\n\\n    /**\\n     * @notice Claim rewards for multiple deposits\\n     * @param _indexes A list of deposit IDs to claim\\n     * @param _receiver Address to receive ETH\\n     */\\n    function claim(uint256[] calldata _indexes, address _receiver) external {\\n        if (_receiver == address(0)) revert OTSeaErrors.InvalidAddress();\\n        uint256 totalRewards = _claimMultiple(_indexes);\\n        _transferETHOrRevert(_receiver, totalRewards);\\n        emit Claimed(_msgSender(), _receiver, _indexes, totalRewards);\\n    }\\n\\n    /**\\n     * @notice Compound rewards by swapping ETH for tokens and creating a new deposit\\n     * @param _indexes A list of deposit IDs to compound\\n     * @param _amountToSwap Amount of rewards (ETH) to swap for tokens, left over rewards are sent to _remainderReceiver\\n     * @param _minTokenAmount Minimum token amount to receive when swapping _amountToSwap\\n     * @param _remainderReceiver Address to receive any remaining rewards (can be the zero address if amountToSwap\\n     * is equal to the total rewards for _indexes)\\n     * @dev The staking contract is exempt from buy fees making compounding fee-free\\n     */\\n    function compound(\\n        uint256[] calldata _indexes,\\n        uint256 _amountToSwap,\\n        uint88 _minTokenAmount,\\n        address _remainderReceiver\\n    ) external {\\n        if (_amountToSwap == 0 || _minTokenAmount == 0) revert OTSeaErrors.InvalidAmount();\\n        uint256 totalRewards = _claimMultiple(_indexes);\\n        if (totalRewards < _amountToSwap) revert OTSeaErrors.InvalidAmount();\\n        uint256 remaining = totalRewards - _amountToSwap;\\n        if (remaining != 0) {\\n            if (_remainderReceiver == address(0)) revert OTSeaErrors.InvalidAddress();\\n            _transferETHOrRevert(_remainderReceiver, remaining);\\n            emit Claimed(_msgSender(), _remainderReceiver, _indexes, remaining);\\n        }\\n        uint88 tokens = _swapETHForTokens(_amountToSwap, _minTokenAmount);\\n        Deposit memory deposit = _createDeposit(tokens);\\n        emit Compounded(\\n            _msgSender(),\\n            _indexes,\\n            _amountToSwap,\\n            _deposits[_msgSender()].length - 1,\\n            deposit\\n        );\\n    }\\n\\n    /**\\n     * @notice Get details about an epoch\\n     * @param _epoch Epoch ID (must be greater than 0 and not greater than the current epoch + 1)\\n     * @return Epoch Epoch details\\n     */\\n    function getEpoch(uint32 _epoch) external view returns (Epoch memory) {\\n        if (_epoch == 0 || _currentEpoch + 1 < _epoch) revert InvalidEpoch();\\n        return _epochs[_epoch];\\n    }\\n\\n    /**\\n     * @notice Get the current epoch ID and details\\n     * @return uint32 Epoch ID\\n     * @return Epoch Epoch details\\n     */\\n    function getCurrentEpoch() external view returns (uint32, Epoch memory) {\\n        return (_currentEpoch, _epochs[_currentEpoch]);\\n    }\\n\\n    /**\\n     * @notice Get the total deposits by a user\\n     * @param _account Account\\n     * @return total Total deposits by _account\\n     */\\n    function getTotalDeposits(address _account) public view returns (uint256 total) {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        return _deposits[_account].length;\\n    }\\n\\n    /**\\n     * @notice Get a deposit for a user by index\\n     * @param _account Account\\n     * @param _index Index of deposit\\n     * @return Deposit Deposit belonging to _account at index _index\\n     */\\n    function getDeposit(address _account, uint256 _index) external view returns (Deposit memory) {\\n        if (getTotalDeposits(_account) <= _index) revert DepositNotFound(_index);\\n        return _deposits[_account][_index];\\n    }\\n\\n    /**\\n     * @notice Get a list of deposits for a user in a sequence from an start index to an end index (inclusive)\\n     * @param _account Account\\n     * @param _startIndex Start deposit index\\n     * @param _endIndex End deposit index\\n     * @return deposits A list of deposits for _account within the range of _startIndex and _endIndex (inclusive)\\n     */\\n    function getDepositsInSequence(\\n        address _account,\\n        uint256 _startIndex,\\n        uint256 _endIndex\\n    )\\n        external\\n        view\\n        onlyValidSequence(_startIndex, _endIndex, getTotalDeposits(_account), ALLOW_ZERO)\\n        returns (Deposit[] memory deposits)\\n    {\\n        deposits = new Deposit[](_endIndex - _startIndex + 1);\\n        uint256 index;\\n        uint256 depositIndex = _startIndex;\\n        for (depositIndex; depositIndex <= _endIndex; ) {\\n            deposits[index] = _deposits[_account][depositIndex];\\n            unchecked {\\n                index++;\\n                depositIndex++;\\n            }\\n        }\\n        return deposits;\\n    }\\n\\n    /**\\n     * @notice Get a list of deposits for a user by providing a list\\n     * @param _account Account\\n     * @param _indexes A list of deposit indexes\\n     * @return deposits A list of deposits for _account based on the _indexes provided\\n     */\\n    function getDepositsByList(\\n        address _account,\\n        uint256[] calldata _indexes\\n    ) external view returns (Deposit[] memory deposits) {\\n        uint256 length = _indexes.length;\\n        _validateListLength(length);\\n        uint256 total = getTotalDeposits(_account);\\n        deposits = new Deposit[](length);\\n        for (uint256 i; i < length; ) {\\n            if (total <= _indexes[i]) revert DepositNotFound(_indexes[i]);\\n            deposits[i] = _deposits[_account][_indexes[i]];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return deposits;\\n    }\\n\\n    /**\\n     * @notice Calculate rewards for a user\\n     * @param _account Account\\n     * @param _indexes A list of deposit indexes\\n     * @return rewards Total rewards for _account based on the _indexes list\\n     */\\n    function calculateRewards(\\n        address _account,\\n        uint256[] calldata _indexes\\n    ) external view returns (uint256 rewards) {\\n        uint256 length = _indexes.length;\\n        _validateListLength(length);\\n        uint256 total = getTotalDeposits(_account);\\n        for (uint256 i; i < length; ) {\\n            if (total <= _indexes[i]) revert DepositNotFound(_indexes[i]);\\n            rewards += _calculateRewards(_account, _indexes[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return rewards;\\n    }\\n\\n    function _nextEpoch() private {\\n        /// @dev sets the current epoch = the current while updating state to the next one\\n        uint32 nextEpoch = ++_currentEpoch;\\n        _epochs[nextEpoch].startedAt = uint88(block.timestamp);\\n        _epochs[nextEpoch].sharePerToken = _epochs[nextEpoch - 1].sharePerToken;\\n        _epochs[nextEpoch].totalStake += _epochs[nextEpoch - 1].totalStake;\\n    }\\n\\n    /**\\n     * @param _amount Amount to deposit\\n     * @return deposit Deposit details\\n     */\\n    function _createDeposit(uint88 _amount) private returns (Deposit memory deposit) {\\n        uint32 nextEpoch = _currentEpoch + 1;\\n        deposit = Deposit(nextEpoch, _amount);\\n        _deposits[_msgSender()].push(deposit);\\n        _epochs[nextEpoch].totalStake += _amount;\\n        return deposit;\\n    }\\n\\n    /**\\n     * @param _indexes A list of deposit indexes\\n     * @return totalAmount Total amount to withdraw based on _indexes\\n     * @return totalRewards Total amount of rewards based on _indexes\\n     */\\n    function _withdrawMultiple(\\n        uint256[] calldata _indexes\\n    ) private returns (uint88 totalAmount, uint256 totalRewards) {\\n        uint256 length = _indexes.length;\\n        _validateListLength(length);\\n        uint256 total = getTotalDeposits(_msgSender());\\n        uint32 currentEpoch = _currentEpoch;\\n        for (uint256 i; i < length; ) {\\n            if (total <= _indexes[i]) revert DepositNotFound(_indexes[i]);\\n            totalRewards += _calculateRewards(_msgSender(), _indexes[i]);\\n            Deposit memory deposit = _deposits[_msgSender()][_indexes[i]];\\n            if (deposit.rewardReferenceEpoch == 0) revert OTSeaErrors.NotAvailable();\\n            _deposits[_msgSender()][_indexes[i]].rewardReferenceEpoch = 0;\\n            /**\\n             * @dev if the rewardReferenceEpoch is in the future, it means that the user deposited in the current\\n             * epoch (currentEpoch). Therefore next epoch's total stake needs to be reduced by the user's deposit.\\n             *\\n             * If the rewardReferenceEpoch is less than or equal to the currentEpoch it means that the user\\n             * either deposited or claimed rewards in a past epoch. Either way it means that the user's\\n             * deposit cannot possible be in the future therefore the current epoch's total stake needs to be reduced\\n             */\\n            _epochs[\\n                currentEpoch < deposit.rewardReferenceEpoch\\n                    ? deposit.rewardReferenceEpoch\\n                    : currentEpoch\\n            ].totalStake -= deposit.amount;\\n            totalAmount += deposit.amount;\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return (totalAmount, totalRewards);\\n    }\\n\\n    /**\\n     * @param _indexes A list of deposit indexes\\n     * @return totalRewards Total amount of rewards based on _indexes\\n     */\\n    function _claimMultiple(uint256[] calldata _indexes) private returns (uint256 totalRewards) {\\n        uint256 length = _indexes.length;\\n        _validateListLength(length);\\n        uint256 total = getTotalDeposits(_msgSender());\\n        uint32 currentEpoch = _currentEpoch;\\n        for (uint256 i; i < length; ) {\\n            if (total <= _indexes[i]) revert DepositNotFound(_indexes[i]);\\n            totalRewards += _calculateRewards(_msgSender(), _indexes[i]);\\n            _deposits[_msgSender()][_indexes[i]].rewardReferenceEpoch = currentEpoch;\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        if (totalRewards == 0) revert NoRewards();\\n        return totalRewards;\\n    }\\n\\n    /**\\n     * @param _amountToSwap Amount of ETH to swap for tokens\\n     * @param _minTokenAmount Minimum token amount to receive when swapping _amountToSwap\\n     * @return uint88 Tokens received\\n     */\\n    function _swapETHForTokens(\\n        uint256 _amountToSwap,\\n        uint88 _minTokenAmount\\n    ) private returns (uint88) {\\n        address[] memory path = new address[](2);\\n        path[0] = _router.WETH();\\n        path[1] = address(_otseaERC20);\\n        uint256[] memory amounts = _router.swapExactETHForTokens{value: _amountToSwap}(\\n            uint256(_minTokenAmount),\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        return uint88(amounts[1]);\\n    }\\n\\n    /**\\n     * @param _account Account\\n     * @param _index Deposit index belonging to _account\\n     * @return uint256 Rewards accumulated by _account for deposit _index\\n     */\\n    function _calculateRewards(address _account, uint256 _index) private view returns (uint256) {\\n        uint32 rewardReferenceEpoch = _deposits[_account][_index].rewardReferenceEpoch;\\n        if (rewardReferenceEpoch == 0 || _currentEpoch <= rewardReferenceEpoch) {\\n            return 0;\\n        }\\n        return\\n            (_deposits[_account][_index].amount *\\n                (_epochs[_currentEpoch - 1].sharePerToken -\\n                    _epochs[rewardReferenceEpoch - 1].sharePerToken)) / REWARD_PRECISION;\\n    }\\n\\n    /// @param _amount Amount\\n    function _checkSufficientAmount(uint88 _amount) private view {\\n        if (_otseaERC20.balanceOf(_msgSender()) < _amount)\\n            revert IERC20Errors.ERC20InsufficientBalance(\\n                _msgSender(),\\n                _otseaERC20.balanceOf(_msgSender()),\\n                uint256(_amount)\\n            );\\n        if (_otseaERC20.allowance(_msgSender(), address(this)) < _amount)\\n            revert IERC20Errors.ERC20InsufficientAllowance(\\n                address(this),\\n                _otseaERC20.allowance(_msgSender(), address(this)),\\n                uint256(_amount)\\n            );\\n    }\\n\\n    /// @return bool true if initialized, false if not\\n    function _isInitialized() private view returns (bool) {\\n        return address(_otseaERC20) != address(0);\\n    }\\n\\n    function _isCallerRevenueDistributor() private view {\\n        if (_msgSender() != _revenueDistributor) revert OTSeaErrors.Unauthorized();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multiSigAdmin\",\"type\":\"address\"},{\"internalType\":\"contract OTSeaMigration\",\"name\":\"_migrationContract\",\"type\":\"address\"},{\"internalType\":\"contract OTSeaStaking\",\"name\":\"_stakingContract\",\"type\":\"address\"},{\"internalType\":\"contract OTSeaRevenueDistributor\",\"name\":\"_revenueDistributor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAvailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unchanged\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"AddedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"revBoost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasury\",\"type\":\"uint256\"}],\"name\":\"DistributedETHFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"revBoostFeePercent\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"treasuryFeePercent\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"burnFeePercent\",\"type\":\"uint16\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaroonedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaroonedETHClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapAt\",\"type\":\"uint256\"}],\"name\":\"SwapAtUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isTransferFeeEnabled\",\"type\":\"bool\"}],\"name\":\"TransferFeeToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"TransferFeeWhitelistUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"claimMaroonedETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterTheSea\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapAt\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"revBoostPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"treasuryFeePercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"burnPercent\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getMaroonedETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExemptFromTransferFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTransferFeeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationContract\",\"outputs\":[{\"internalType\":\"contract OTSeaMigration\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueDistributor\",\"outputs\":[{\"internalType\":\"contract OTSeaRevenueDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"contract OTSeaStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"revBoostFeePercent_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"treasuryFeePercent_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"burnFeePercent_\",\"type\":\"uint16\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint88\",\"name\":\"_amount\",\"type\":\"uint88\"}],\"name\":\"updateSwapAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_operation\",\"type\":\"bool\"}],\"name\":\"updateTransferFeeWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OTSeaERC20", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000adedc7487c59ece60178cf69b8df7e3c4730d90000000000000000000000000e4eacc41aa1a8208d57c1b4766b6b69e1cfe50e9000000000000000000000000f2c8e860ca12cde3f3195423ecf54427a4f3091600000000000000000000000034bccf4af03870265fe99cec262524f343cca7ff", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}