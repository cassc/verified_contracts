{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gearbox-protocol/core-v2/contracts/tokens/DegenNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.10;\\n\\nimport { ERC721 } from \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport { AddressProvider } from \\\"../core/AddressProvider.sol\\\";\\nimport { ContractsRegister } from \\\"../core/ContractsRegister.sol\\\";\\n\\nimport { ACLTrait } from \\\"../core/ACLTrait.sol\\\";\\nimport { NotImplementedException } from \\\"../interfaces/IErrors.sol\\\";\\n\\nimport { ICreditManagerV2 } from \\\"../interfaces/ICreditManagerV2.sol\\\";\\nimport { ICreditFacade } from \\\"../interfaces/ICreditFacade.sol\\\";\\nimport { IDegenNFT } from \\\"../interfaces/IDegenNFT.sol\\\";\\n\\ncontract DegenNFT is ERC721, ACLTrait, IDegenNFT {\\n    using Address for address;\\n\\n    /// @dev Stores the total number of tokens on holder accounts\\n    uint256 public override totalSupply;\\n\\n    /// @dev address of Contracts register\\n    ContractsRegister internal immutable contractsRegister;\\n\\n    /// @dev address of the current minter\\n    address public minter;\\n\\n    /// @dev mapping from address to supported Credit Facade status\\n    mapping(address => bool) public isSupportedCreditFacade;\\n\\n    /// @dev Stores the base URI for NFT metadata\\n    string public override baseURI;\\n\\n    /// @dev contract version\\n    uint256 public constant override version = 1;\\n\\n    /// @dev Restricts calls to this contract's minter\\n    modifier onlyMinter() {\\n        if (msg.sender != minter) {\\n            revert MinterOnlyException();\\n        }\\n        _;\\n    }\\n\\n    /// @dev Restricts calls to the configurator or Credit Facades\\n    modifier creditFacadeOrConfiguratorOnly() {\\n        if (\\n            !isSupportedCreditFacade[msg.sender] &&\\n            !_acl.isConfigurator(msg.sender)\\n        ) {\\n            revert CreditFacadeOrConfiguratorOnlyException();\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address _addressProvider,\\n        string memory _name,\\n        string memory _symbol\\n    )\\n        ACLTrait(_addressProvider)\\n        ERC721(_name, _symbol) // F:[DNFT-1]\\n    {\\n        contractsRegister = ContractsRegister(\\n            AddressProvider(_addressProvider).getContractsRegister()\\n        );\\n    }\\n\\n    function setMinter(address minter_)\\n        external\\n        configuratorOnly // F:[DNFT-2B]\\n    {\\n        minter = minter_; // F: [DNFT-5A]\\n        emit NewMinterSet(minter);\\n    }\\n\\n    function addCreditFacade(address creditFacade_)\\n        external\\n        configuratorOnly // F: [DNFT-2C]\\n    {\\n        if (!isSupportedCreditFacade[creditFacade_]) {\\n            if (!creditFacade_.isContract()) {\\n                revert InvalidCreditFacadeException(); // F:[DNFT-6]\\n            }\\n\\n            address creditManager;\\n            try ICreditFacade(creditFacade_).creditManager() returns (\\n                ICreditManagerV2 cm\\n            ) {\\n                creditManager = address(cm);\\n            } catch {\\n                revert InvalidCreditFacadeException(); // F:[DNFT-6]\\n            }\\n\\n            if (\\n                !contractsRegister.isCreditManager(creditManager) ||\\n                ICreditFacade(creditFacade_).degenNFT() != address(this) ||\\n                ICreditManagerV2(creditManager).creditFacade() != creditFacade_\\n            ) revert InvalidCreditFacadeException(); // F:[DNFT-6]\\n\\n            isSupportedCreditFacade[creditFacade_] = true; // F: [DNFT-10]\\n            emit NewCreditFacadeAdded(creditFacade_);\\n        }\\n    }\\n\\n    function removeCreditFacade(address creditFacade_)\\n        external\\n        configuratorOnly // F: [DNFT-2D]\\n    {\\n        if (isSupportedCreditFacade[creditFacade_]) {\\n            isSupportedCreditFacade[creditFacade_] = false; // F: [DNFT-9]\\n            emit NewCreditFacadeRemoved(creditFacade_);\\n        }\\n    }\\n\\n    function setBaseUri(string calldata baseURI_)\\n        external\\n        configuratorOnly // F:[DNFT-2A]\\n    {\\n        baseURI = baseURI_; // F:[DNFT-5]\\n    }\\n\\n    function _baseURI() internal view override returns (string memory) {\\n        return baseURI; // F:[DNFT-5]\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override(IERC721Metadata, ERC721)\\n        returns (string memory)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721Metadata: URI query for nonexistent token\\\"\\n        );\\n\\n        return _baseURI();\\n    }\\n\\n    /// @dev Mints a specified amount of tokens to the address\\n    /// @param to Address the tokens are minted to\\n    /// @param amount The number of tokens to mint\\n    function mint(address to, uint256 amount)\\n        external\\n        override\\n        onlyMinter // F:[DNFT-3]\\n    {\\n        uint256 balanceBefore = balanceOf(to); // F:[DNFT-7]\\n\\n        for (uint256 i; i < amount; ) {\\n            uint256 tokenId = (uint256(uint160(to)) << 40) + balanceBefore + i; // F:[DNFT-7]\\n            _mint(to, tokenId); // F:[DNFT-7]\\n\\n            unchecked {\\n                ++i; // F:[DNFT-7]\\n            }\\n        }\\n\\n        totalSupply += amount; // F:[DNFT-7]\\n    }\\n\\n    /// @dev Burns a number of tokens from a specified address\\n    /// @param from The address a token will be burnt from\\n    /// @param amount The number of tokens to burn\\n    function burn(address from, uint256 amount)\\n        external\\n        override\\n        creditFacadeOrConfiguratorOnly // F:[DNFT-4]\\n    {\\n        uint256 balance = balanceOf(from); // F:[DNFT-8,8A]\\n\\n        if (balance < amount) {\\n            revert InsufficientBalanceException(); // F:[DNFT-8A]\\n        }\\n\\n        for (uint256 i; i < amount; ) {\\n            uint256 tokenId = (uint256(uint160(from)) << 40) + balance - i - 1; // F:[DNFT-8]\\n            _burn(tokenId); // F:[DNFT-8]\\n\\n            unchecked {\\n                ++i; // F:[DNFT-8]\\n            }\\n        }\\n\\n        totalSupply -= amount; // F:[DNFT-8]\\n    }\\n\\n    /// @dev Not implemented as the token is not transferrable\\n    function approve(address, uint256)\\n        public\\n        pure\\n        virtual\\n        override(IERC721, ERC721)\\n    {\\n        revert NotImplementedException(); // F:[DNFT-11]\\n    }\\n\\n    /// @dev Not implemented as the token is not transferrable\\n    function setApprovalForAll(address, bool)\\n        public\\n        pure\\n        virtual\\n        override(IERC721, ERC721)\\n    {\\n        revert NotImplementedException(); // F:[DNFT-11]\\n    }\\n\\n    /// @dev Not implemented as the token is not transferrable\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) public pure virtual override(IERC721, ERC721) {\\n        revert NotImplementedException(); // F:[DNFT-11]\\n    }\\n\\n    /// @dev Not implemented as the token is not transferrable\\n    function safeTransferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) public pure virtual override(IERC721, ERC721) {\\n        revert NotImplementedException(); // F:[DNFT-11]\\n    }\\n\\n    /// @dev Not implemented as the token is not transferrable\\n    function safeTransferFrom(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public pure virtual override(IERC721, ERC721) {\\n        revert NotImplementedException(); // F:[DNFT-11]\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/AddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IAddressProvider } from \\\"../interfaces/IAddressProvider.sol\\\";\\nimport { Claimable } from \\\"./access/Claimable.sol\\\";\\nimport { Errors } from \\\"../libraries/Errors.sol\\\";\\n\\n// Repositories & services\\nbytes32 constant CONTRACTS_REGISTER = \\\"CONTRACTS_REGISTER\\\";\\nbytes32 constant ACL = \\\"ACL\\\";\\nbytes32 constant PRICE_ORACLE = \\\"PRICE_ORACLE\\\";\\nbytes32 constant ACCOUNT_FACTORY = \\\"ACCOUNT_FACTORY\\\";\\nbytes32 constant DATA_COMPRESSOR = \\\"DATA_COMPRESSOR\\\";\\nbytes32 constant TREASURY_CONTRACT = \\\"TREASURY_CONTRACT\\\";\\nbytes32 constant GEAR_TOKEN = \\\"GEAR_TOKEN\\\";\\nbytes32 constant WETH_TOKEN = \\\"WETH_TOKEN\\\";\\nbytes32 constant WETH_GATEWAY = \\\"WETH_GATEWAY\\\";\\nbytes32 constant LEVERAGED_ACTIONS = \\\"LEVERAGED_ACTIONS\\\";\\n\\n/// @title AddressRepository\\n/// @notice Stores addresses of deployed contracts\\ncontract AddressProvider is Claimable, IAddressProvider {\\n    // Mapping from contract keys to respective addresses\\n    mapping(bytes32 => address) public addresses;\\n\\n    // Contract version\\n    uint256 public constant version = 2;\\n\\n    constructor() {\\n        // @dev Emits first event for contract discovery\\n        emit AddressSet(\\\"ADDRESS_PROVIDER\\\", address(this));\\n    }\\n\\n    /// @return Address of ACL contract\\n    function getACL() external view returns (address) {\\n        return _getAddress(ACL); // F:[AP-3]\\n    }\\n\\n    /// @dev Sets address of ACL contract\\n    /// @param _address Address of ACL contract\\n    function setACL(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(ACL, _address); // F:[AP-3]\\n    }\\n\\n    /// @return Address of ContractsRegister\\n    function getContractsRegister() external view returns (address) {\\n        return _getAddress(CONTRACTS_REGISTER); // F:[AP-4]\\n    }\\n\\n    /// @dev Sets address of ContractsRegister\\n    /// @param _address Address of ContractsRegister\\n    function setContractsRegister(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(CONTRACTS_REGISTER, _address); // F:[AP-4]\\n    }\\n\\n    /// @return Address of PriceOracle\\n    function getPriceOracle() external view override returns (address) {\\n        return _getAddress(PRICE_ORACLE); // F:[AP-5]\\n    }\\n\\n    /// @dev Sets address of PriceOracle\\n    /// @param _address Address of PriceOracle\\n    function setPriceOracle(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(PRICE_ORACLE, _address); // F:[AP-5]\\n    }\\n\\n    /// @return Address of AccountFactory\\n    function getAccountFactory() external view returns (address) {\\n        return _getAddress(ACCOUNT_FACTORY); // F:[AP-6]\\n    }\\n\\n    /// @dev Sets address of AccountFactory\\n    /// @param _address Address of AccountFactory\\n    function setAccountFactory(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(ACCOUNT_FACTORY, _address); // F:[AP-6]\\n    }\\n\\n    /// @return Address of DataCompressor\\n    function getDataCompressor() external view override returns (address) {\\n        return _getAddress(DATA_COMPRESSOR); // F:[AP-7]\\n    }\\n\\n    /// @dev Sets address of AccountFactory\\n    /// @param _address Address of AccountFactory\\n    function setDataCompressor(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(DATA_COMPRESSOR, _address); // F:[AP-7]\\n    }\\n\\n    /// @return Address of Treasury contract\\n    function getTreasuryContract() external view returns (address) {\\n        return _getAddress(TREASURY_CONTRACT); // F:[AP-8]\\n    }\\n\\n    /// @dev Sets address of Treasury Contract\\n    /// @param _address Address of Treasury Contract\\n    function setTreasuryContract(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(TREASURY_CONTRACT, _address); // F:[AP-8]\\n    }\\n\\n    /// @return Address of GEAR token\\n    function getGearToken() external view override returns (address) {\\n        return _getAddress(GEAR_TOKEN); // F:[AP-9]\\n    }\\n\\n    /// @dev Sets address of GEAR token\\n    /// @param _address Address of GEAR token\\n    function setGearToken(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(GEAR_TOKEN, _address); // F:[AP-9]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getWethToken() external view override returns (address) {\\n        return _getAddress(WETH_TOKEN); // F:[AP-10]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setWethToken(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(WETH_TOKEN, _address); // F:[AP-10]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getWETHGateway() external view override returns (address) {\\n        return _getAddress(WETH_GATEWAY); // F:[AP-11]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setWETHGateway(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(WETH_GATEWAY, _address); // F:[AP-11]\\n    }\\n\\n    /// @return Address of PathFinder\\n    function getLeveragedActions() external view returns (address) {\\n        return _getAddress(LEVERAGED_ACTIONS); // T:[AP-7]\\n    }\\n\\n    /// @dev Sets address of  PathFinder\\n    /// @param _address Address of  PathFinder\\n    function setLeveragedActions(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(LEVERAGED_ACTIONS, _address); // T:[AP-7]\\n    }\\n\\n    /// @return Address of key, reverts if the key doesn't exist\\n    function _getAddress(bytes32 key) internal view returns (address) {\\n        address result = addresses[key];\\n        require(result != address(0), Errors.AS_ADDRESS_NOT_FOUND); // F:[AP-1]\\n        return result; // F:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11]\\n    }\\n\\n    /// @dev Sets address to map by its key\\n    /// @param key Key in string format\\n    /// @param value Address\\n    function _setAddress(bytes32 key, address value) internal {\\n        addresses[key] = value; // F:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11]\\n        emit AddressSet(key, value); // F:[AP-2]\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/ACLTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport { AddressProvider } from \\\"./AddressProvider.sol\\\";\\nimport { IACL } from \\\"../interfaces/IACL.sol\\\";\\nimport { ZeroAddressException, CallerNotConfiguratorException, CallerNotPausableAdminException, CallerNotUnPausableAdminException } from \\\"../interfaces/IErrors.sol\\\";\\n\\n/// @title ACL Trait\\n/// @notice Utility class for ACL consumers\\nabstract contract ACLTrait is Pausable {\\n    // ACL contract to check rights\\n    IACL public immutable _acl;\\n\\n    /// @dev constructor\\n    /// @param addressProvider Address of address repository\\n    constructor(address addressProvider) {\\n        if (addressProvider == address(0)) revert ZeroAddressException(); // F:[AA-2]\\n\\n        _acl = IACL(AddressProvider(addressProvider).getACL());\\n    }\\n\\n    /// @dev  Reverts if msg.sender is not configurator\\n    modifier configuratorOnly() {\\n        if (!_acl.isConfigurator(msg.sender))\\n            revert CallerNotConfiguratorException();\\n        _;\\n    }\\n\\n    ///@dev Pause contract\\n    function pause() external {\\n        if (!_acl.isPausableAdmin(msg.sender))\\n            revert CallerNotPausableAdminException();\\n        _pause();\\n    }\\n\\n    /// @dev Unpause contract\\n    function unpause() external {\\n        if (!_acl.isUnpausableAdmin(msg.sender))\\n            revert CallerNotUnPausableAdminException();\\n\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/ContractsRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IContractsRegister } from \\\"../interfaces/IContractsRegister.sol\\\";\\nimport { Errors } from \\\"../libraries/Errors.sol\\\";\\nimport { ACLTrait } from \\\"./ACLTrait.sol\\\";\\n\\n/// @title Pool & Credit Manager registry\\n/// @notice Stores addresses of Pools and Credit Managers\\ncontract ContractsRegister is IContractsRegister, ACLTrait {\\n    /// @dev List of all registered pools\\n    address[] public override pools;\\n\\n    /// @dev Mapping storing whether an address is a pool\\n    mapping(address => bool) public override isPool;\\n\\n    /// @dev List of all registered Credit Managers\\n    address[] public override creditManagers;\\n\\n    /// @dev Mapping storing whether an address is a Credit Manager\\n    mapping(address => bool) public override isCreditManager;\\n\\n    /// @dev Contract version\\n    uint256 public constant version = 1;\\n\\n    constructor(address addressProvider) ACLTrait(addressProvider) {}\\n\\n    /// @dev Adds a pool to the list\\n    /// @param newPoolAddress Address of the new pool\\n    function addPool(address newPoolAddress)\\n        external\\n        configuratorOnly // T:[CR-1]\\n    {\\n        require(\\n            newPoolAddress != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n        require(!isPool[newPoolAddress], Errors.CR_POOL_ALREADY_ADDED); // T:[CR-2]\\n        pools.push(newPoolAddress); // T:[CR-3]\\n        isPool[newPoolAddress] = true; // T:[CR-3]\\n\\n        emit NewPoolAdded(newPoolAddress); // T:[CR-4]\\n    }\\n\\n    /// @dev Returns the array of registered pool addresses\\n    function getPools() external view override returns (address[] memory) {\\n        return pools;\\n    }\\n\\n    /// @return Returns the number of registered pools\\n    function getPoolsCount() external view override returns (uint256) {\\n        return pools.length; // T:[CR-3]\\n    }\\n\\n    /// @dev Adds credit accounts manager address to the registry\\n    /// @param newCreditManager Address of the new Credit Manager\\n    function addCreditManager(address newCreditManager)\\n        external\\n        configuratorOnly // T:[CR-1]\\n    {\\n        require(\\n            newCreditManager != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n\\n        require(\\n            !isCreditManager[newCreditManager],\\n            Errors.CR_CREDIT_MANAGER_ALREADY_ADDED\\n        ); // T:[CR-5]\\n        creditManagers.push(newCreditManager); // T:[CR-6]\\n        isCreditManager[newCreditManager] = true; // T:[CR-6]\\n\\n        emit NewCreditManagerAdded(newCreditManager); // T:[CR-7]\\n    }\\n\\n    /// @dev Returns the array of registered credit manager addresses\\n    function getCreditManagers()\\n        external\\n        view\\n        override\\n        returns (address[] memory)\\n    {\\n        return creditManagers;\\n    }\\n\\n    /// @return Returns the number of registered credit managers\\n    function getCreditManagersCount() external view override returns (uint256) {\\n        return creditManagers.length; // T:[CR-6]\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @dev Common contract exceptions\\n\\n/// @dev Thrown on attempting to set an important address to zero address\\nerror ZeroAddressException();\\n\\n/// @dev Thrown on attempting to call a non-implemented function\\nerror NotImplementedException();\\n\\n/// @dev Thrown on attempting to set an EOA as an important contract in the system\\nerror AddressIsNotContractException(address);\\n\\n/// @dev Thrown on attempting to use a non-ERC20 contract or an EOA as a token\\nerror IncorrectTokenContractException();\\n\\n/// @dev Thrown on attempting to set a token price feed to an address that is not a\\n///      correct price feed\\nerror IncorrectPriceFeedException();\\n\\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\\nerror CallerNotConfiguratorException();\\n\\n/// @dev Thrown on attempting to pause a contract as a non-Pausable admin\\nerror CallerNotPausableAdminException();\\n\\n/// @dev Thrown on attempting to pause a contract as a non-Unpausable admin\\nerror CallerNotUnPausableAdminException();\\n\\nerror TokenIsNotAddedToCreditManagerException(address token);\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/ICreditFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { Balance } from \\\"../libraries/Balances.sol\\\";\\nimport { MultiCall } from \\\"../libraries/MultiCall.sol\\\";\\nimport { ICreditManagerV2, ICreditManagerV2Exceptions } from \\\"./ICreditManagerV2.sol\\\";\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface ICreditFacadeExtended {\\n    /// @dev Stores expected balances (computed as current balance + passed delta)\\n    ///      and compare with actual balances at the end of a multicall, reverts\\n    ///      if at least one is less than expected\\n    /// @param expected Array of expected balance changes\\n    /// @notice This is an extenstion function that does not exist in the Credit Facade\\n    ///         itself and can only be used within a multicall\\n    function revertIfReceivedLessThan(Balance[] memory expected) external;\\n\\n    /// @dev Enables token in enabledTokenMask for the Credit Account of msg.sender\\n    /// @param token Address of token to enable\\n    function enableToken(address token) external;\\n\\n    /// @dev Disables a token on the caller's Credit Account\\n    /// @param token Token to disable\\n    /// @notice This is an extenstion function that does not exist in the Credit Facade\\n    ///         itself and can only be used within a multicall\\n    function disableToken(address token) external;\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param onBehalfOf Address of the borrower whose account is funded\\n    /// @param token Address of a collateral token\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    ) external payable;\\n\\n    /// @dev Increases debt for msg.sender's Credit Account\\n    /// - Borrows the requested amount from the pool\\n    /// - Updates the CA's borrowAmount / cumulativeIndexOpen\\n    ///   to correctly compute interest going forward\\n    /// - Performs a full collateral check\\n    ///\\n    /// @param amount Amount to borrow\\n    function increaseDebt(uint256 amount) external;\\n\\n    /// @dev Decrease debt\\n    /// - Decreases the debt by paying the requested amount + accrued interest + fees back to the pool\\n    /// - It's also include to this payment interest accrued at the moment and fees\\n    /// - Updates cunulativeIndex to cumulativeIndex now\\n    ///\\n    /// @param amount Amount to increase borrowed amount\\n    function decreaseDebt(uint256 amount) external;\\n}\\n\\ninterface ICreditFacadeEvents {\\n    /// @dev Emits when a new Credit Account is opened through the\\n    ///      Credit Facade\\n    event OpenCreditAccount(\\n        address indexed onBehalfOf,\\n        address indexed creditAccount,\\n        uint256 borrowAmount,\\n        uint16 referralCode\\n    );\\n\\n    /// @dev Emits when the account owner closes their CA normally\\n    event CloseCreditAccount(address indexed borrower, address indexed to);\\n\\n    /// @dev Emits when a Credit Account is liquidated due to low health factor\\n    event LiquidateCreditAccount(\\n        address indexed borrower,\\n        address indexed liquidator,\\n        address indexed to,\\n        uint256 remainingFunds\\n    );\\n\\n    /// @dev Emits when a Credit Account is liquidated due to expiry\\n    event LiquidateExpiredCreditAccount(\\n        address indexed borrower,\\n        address indexed liquidator,\\n        address indexed to,\\n        uint256 remainingFunds\\n    );\\n\\n    /// @dev Emits when the account owner increases CA's debt\\n    event IncreaseBorrowedAmount(address indexed borrower, uint256 amount);\\n\\n    /// @dev Emits when the account owner reduces CA's debt\\n    event DecreaseBorrowedAmount(address indexed borrower, uint256 amount);\\n\\n    /// @dev Emits when the account owner add new collateral to a CA\\n    event AddCollateral(\\n        address indexed onBehalfOf,\\n        address indexed token,\\n        uint256 value\\n    );\\n\\n    /// @dev Emits when a multicall is started\\n    event MultiCallStarted(address indexed borrower);\\n\\n    /// @dev Emits when a multicall is finished\\n    event MultiCallFinished();\\n\\n    /// @dev Emits when Credit Account ownership is transferred\\n    event TransferAccount(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev Emits when the user changes approval for account transfers to itself from another address\\n    event TransferAccountAllowed(\\n        address indexed from,\\n        address indexed to,\\n        bool state\\n    );\\n\\n    /// @dev Emits when the account owner enables a token on their CA\\n    event TokenEnabled(address indexed borrower, address indexed token);\\n\\n    /// @dev Emits when the account owner disables a token on their CA\\n    event TokenDisabled(address indexed borrower, address indexed token);\\n}\\n\\ninterface ICreditFacadeExceptions is ICreditManagerV2Exceptions {\\n    /// @dev Thrown if the CreditFacade is not expirable, and an aciton is attempted that\\n    ///      requires expirability\\n    error NotAllowedWhenNotExpirableException();\\n\\n    /// @dev Thrown if whitelisted mode is enabled, and an action is attempted that is\\n    ///      not allowed in whitelisted mode\\n    error NotAllowedInWhitelistedMode();\\n\\n    /// @dev Thrown if a user attempts to transfer a CA to an address that didn't allow it\\n    error AccountTransferNotAllowedException();\\n\\n    /// @dev Thrown if a liquidator tries to liquidate an account with a health factor above 1\\n    error CantLiquidateWithSuchHealthFactorException();\\n\\n    /// @dev Thrown if a liquidator tries to liquidate an account by expiry while a Credit Facade is not expired\\n    error CantLiquidateNonExpiredException();\\n\\n    /// @dev Thrown if call data passed to a multicall is too short\\n    error IncorrectCallDataException();\\n\\n    /// @dev Thrown inside account closure multicall if the borrower attempts an action that is forbidden on closing\\n    ///      an account\\n    error ForbiddenDuringClosureException();\\n\\n    /// @dev Thrown if debt increase and decrease are subsequently attempted in one multicall\\n    error IncreaseAndDecreaseForbiddenInOneCallException();\\n\\n    /// @dev Thrown if a selector that doesn't match any allowed function is passed to the Credit Facade\\n    ///      during a multicall\\n    error UnknownMethodException();\\n\\n    /// @dev Thrown if a user tries to open an account or increase debt with increaseDebtForbidden mode on\\n    error IncreaseDebtForbiddenException();\\n\\n    /// @dev Thrown if the account owner tries to transfer an unhealthy account\\n    error CantTransferLiquidatableAccountException();\\n\\n    /// @dev Thrown if too much new debt was taken within a single block\\n    error BorrowedBlockLimitException();\\n\\n    /// @dev Thrown if the new debt principal for a CA falls outside of borrowing limits\\n    error BorrowAmountOutOfLimitsException();\\n\\n    /// @dev Thrown if one of the balances on a Credit Account is less than expected\\n    ///      at the end of a multicall, if revertIfReceivedLessThan was called\\n    error BalanceLessThanMinimumDesiredException(address);\\n\\n    /// @dev Thrown if a user attempts to open an account on a Credit Facade that has expired\\n    error OpenAccountNotAllowedAfterExpirationException();\\n\\n    /// @dev Thrown if expected balances are attempted to be set through revertIfReceivedLessThan twice\\n    error ExpectedBalancesAlreadySetException();\\n\\n    /// @dev Thrown if a Credit Account has enabled forbidden tokens and the owner attempts to perform an action\\n    ///      that is not allowed with any forbidden tokens enabled\\n    error ActionProhibitedWithForbiddenTokensException();\\n}\\n\\ninterface ICreditFacade is\\n    ICreditFacadeEvents,\\n    ICreditFacadeExceptions,\\n    IVersion\\n{\\n    //\\n    // CREDIT ACCOUNT MANAGEMENT\\n    //\\n\\n    /// @dev Opens credit account, borrows funds from the pool and pulls collateral\\n    /// without any additional action.\\n    /// @param amount The amount of collateral provided by the borrower\\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\\n    /// msg.sender != obBehalfOf\\n    /// @param leverageFactor Percentage of the user's own funds to borrow. 100 is equal to 100% - borrows the same amount\\n    /// as the user's own collateral, equivalent to 2x leverage.\\n    /// @param referralCode Referral code that is used for potential rewards. 0 if no referral code provided.\\n    function openCreditAccount(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 leverageFactor,\\n        uint16 referralCode\\n    ) external payable;\\n\\n    /// @dev Opens a Credit Account and runs a batch of operations in a multicall\\n    /// @param borrowedAmount Debt size\\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\\n    /// msg.sender != obBehalfOf\\n    /// @param calls The array of MultiCall structs encoding the required operations. Generally must have\\n    /// at least a call to addCollateral, as otherwise the health check at the end will fail.\\n    /// @param referralCode Referral code which is used for potential rewards. 0 if no referral code provided\\n    function openCreditAccountMulticall(\\n        uint256 borrowedAmount,\\n        address onBehalfOf,\\n        MultiCall[] calldata calls,\\n        uint16 referralCode\\n    ) external payable;\\n\\n    /// @dev Runs a batch of transactions within a multicall and closes the account\\n    /// - Wraps ETH to WETH and sends it msg.sender if value > 0\\n    /// - Executes the multicall - the main purpose of a multicall when closing is to convert all assets to underlying\\n    /// in order to pay the debt.\\n    /// - Closes credit account:\\n    ///    + Checks the underlying balance: if it is greater than the amount paid to the pool, transfers the underlying\\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from msg.sender.\\n    ///    + Transfers all enabled assets with non-zero balances to the \\\"to\\\" address, unless they are marked\\n    ///      to be skipped in skipTokenMask\\n    ///    + If convertWETH is true, converts WETH into ETH before sending to the recipient\\n    /// - Emits a CloseCreditAccount event\\n    ///\\n    /// @param to Address to send funds to during account closing\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param convertWETH If true, converts WETH into ETH before sending to \\\"to\\\"\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before closing the account.\\n    function closeCreditAccount(\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account\\n    /// - Computes the total value and checks that hf < 1. An account can't be liquidated when hf >= 1.\\n    ///   Total value has to be computed before the multicall, otherwise the liquidator would be able\\n    ///   to manipulate it.\\n    /// - Wraps ETH to WETH and sends it to msg.sender (liquidator) if value > 0\\n    /// - Executes the multicall - the main purpose of a multicall when liquidating is to convert all assets to underlying\\n    ///   in order to pay the debt.\\n    /// - Liquidate credit account:\\n    ///    + Computes the amount that needs to be paid to the pool. If totalValue * liquidationDiscount < borrow + interest + fees,\\n    ///      only totalValue * liquidationDiscount has to be paid. Since liquidationDiscount < 1, the liquidator can take\\n    ///      totalValue * (1 - liquidationDiscount) as premium. Also computes the remaining funds to be sent to borrower\\n    ///      as totalValue * liquidationDiscount - amountToPool.\\n    ///    + Checks the underlying balance: if it is greater than amountToPool + remainingFunds, transfers the underlying\\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from the liquidator.\\n    ///    + Transfers all enabled assets with non-zero balances to the \\\"to\\\" address, unless they are marked\\n    ///      to be skipped in skipTokenMask. If the liquidator is confident that all assets were converted\\n    ///      during the multicall, they can set the mask to uint256.max - 1, to only transfer the underlying\\n    ///    + If convertWETH is true, converts WETH into ETH before sending\\n    /// - Emits LiquidateCreditAccount event\\n    ///\\n    /// @param to Address to send funds to after liquidation\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param convertWETH If true, converts WETH into ETH before sending to \\\"to\\\"\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account when\\n    /// this Credit Facade is expired\\n    /// The general flow of liquidation is nearly the same as normal liquidations, with two main differences:\\n    ///     - An account can be liquidated on an expired Credit Facade even with hf > 1. However,\\n    ///       no accounts can be liquidated through this function if the Credit Facade is not expired.\\n    ///     - Liquidation premiums and fees for liquidating expired accounts are reduced.\\n    /// It is still possible to normally liquidate an underwater Credit Account, even when the Credit Facade\\n    /// is expired.\\n    /// @param to Address to send funds to after liquidation\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param convertWETH If true, converts WETH into ETH before sending to \\\"to\\\"\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\\n    function liquidateExpiredCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev Increases debt for msg.sender's Credit Account\\n    /// - Borrows the requested amount from the pool\\n    /// - Updates the CA's borrowAmount / cumulativeIndexOpen\\n    ///   to correctly compute interest going forward\\n    /// - Performs a full collateral check\\n    ///\\n    /// @param amount Amount to borrow\\n    function increaseDebt(uint256 amount) external;\\n\\n    /// @dev Decrease debt\\n    /// - Decreases the debt by paying the requested amount + accrued interest + fees back to the pool\\n    /// - It's also include to this payment interest accrued at the moment and fees\\n    /// - Updates cunulativeIndex to cumulativeIndex now\\n    ///\\n    /// @param amount Amount to increase borrowed amount\\n    function decreaseDebt(uint256 amount) external;\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param onBehalfOf Address of the borrower whose account is funded\\n    /// @param token Address of a collateral token\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    ) external payable;\\n\\n    /// @dev Executes a batch of transactions within a Multicall, to manage an existing account\\n    ///  - Wraps ETH and sends it back to msg.sender, if value > 0\\n    ///  - Executes the Multicall\\n    ///  - Performs a fullCollateralCheck to verify that hf > 1 after all actions\\n    /// @param calls The array of MultiCall structs encoding the operations to execute.\\n    function multicall(MultiCall[] calldata calls) external payable;\\n\\n    /// @dev Returns true if the borrower has an open Credit Account\\n    /// @param borrower Borrower address\\n    function hasOpenedCreditAccount(address borrower)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @dev Sets token allowance from msg.sender's Credit Account to a connected target contract\\n    /// @param targetContract Contract to set allowance to. Cannot be in the list of upgradeable contracts\\n    /// @param token Token address\\n    /// @param amount Allowance amount\\n    function approve(\\n        address targetContract,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Approves account transfer from another user to msg.sender\\n    /// @param from Address for which account transfers are allowed/forbidden\\n    /// @param state True is transfer is allowed, false if forbidden\\n    function approveAccountTransfer(address from, bool state) external;\\n\\n    /// @dev Enables token in enabledTokenMask for the Credit Account of msg.sender\\n    /// @param token Address of token to enable\\n    function enableToken(address token) external;\\n\\n    /// @dev Transfers credit account to another user\\n    /// By default, this action is forbidden, and the user has to approve transfers from sender to itself\\n    /// by calling approveAccountTransfer.\\n    /// This is done to prevent malicious actors from transferring compromised accounts to other users.\\n    /// @param to Address to transfer the account to\\n    function transferAccountOwnership(address to) external;\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Calculates total value for provided Credit Account in underlying\\n    ///\\n    /// @param creditAccount Credit Account address\\n    /// @return total Total value in underlying\\n    /// @return twv Total weighted (discounted by liquidation thresholds) value in underlying\\n    function calcTotalValue(address creditAccount)\\n        external\\n        view\\n        returns (uint256 total, uint256 twv);\\n\\n    /**\\n     * @dev Calculates health factor for the credit account\\n     *\\n     *          sum(asset[i] * liquidation threshold[i])\\n     *   Hf = --------------------------------------------\\n     *         borrowed amount + interest accrued + fees\\n     *\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\\n     *\\n     * @param creditAccount Credit account address\\n     * @return hf = Health factor in bp (see PERCENTAGE FACTOR in PercentageMath.sol)\\n     */\\n    function calcCreditAccountHealthFactor(address creditAccount)\\n        external\\n        view\\n        returns (uint256 hf);\\n\\n    /// @dev Returns true if token is a collateral token and is not forbidden,\\n    /// otherwise returns false\\n    /// @param token Token to check\\n    function isTokenAllowed(address token) external view returns (bool);\\n\\n    /// @dev Returns the CreditManager connected to this Credit Facade\\n    function creditManager() external view returns (ICreditManagerV2);\\n\\n    /// @dev Returns true if 'from' is allowed to transfer Credit Accounts to 'to'\\n    /// @param from Sender address to check allowance for\\n    /// @param to Receiver address to check allowance for\\n    function transfersAllowed(address from, address to)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @return maxBorrowedAmountPerBlock Maximal amount of new debt that can be taken per block\\n    /// @return isIncreaseDebtForbidden True if increasing debt is forbidden\\n    /// @return expirationDate Timestamp of the next expiration (for expirable Credit Facades only)\\n    function params()\\n        external\\n        view\\n        returns (\\n            uint128 maxBorrowedAmountPerBlock,\\n            bool isIncreaseDebtForbidden,\\n            uint40 expirationDate\\n        );\\n\\n    /// @return minBorrowedAmount Minimal borrowed amount per credit account\\n    /// @return maxBorrowedAmount Maximal borrowed amount per credit account\\n    function limits()\\n        external\\n        view\\n        returns (uint128 minBorrowedAmount, uint128 maxBorrowedAmount);\\n\\n    /// @dev Address of the DegenNFT that gatekeeps account openings in whitelisted mode\\n    function degenNFT() external view returns (address);\\n\\n    /// @dev Address of the underlying asset\\n    function underlying() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IDegenNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IDegenNFTExceptions {\\n    /// @dev Thrown if an access-restricted function was called by non-CreditFacade\\n    error CreditFacadeOrConfiguratorOnlyException();\\n\\n    /// @dev Thrown if an access-restricted function was called by non-minter\\n    error MinterOnlyException();\\n\\n    /// @dev Thrown if trying to add a burner address that is not a correct Credit Facade\\n    error InvalidCreditFacadeException();\\n\\n    /// @dev Thrown if the account's balance is not sufficient for an action (usually a burn)\\n    error InsufficientBalanceException();\\n}\\n\\ninterface IDegenNFTEvents {\\n    /// @dev Minted when new minter set\\n    event NewMinterSet(address indexed);\\n\\n    /// @dev Minted each time when new credit facade added\\n    event NewCreditFacadeAdded(address indexed);\\n\\n    /// @dev Minted each time when new credit facade added\\n    event NewCreditFacadeRemoved(address indexed);\\n}\\n\\ninterface IDegenNFT is\\n    IDegenNFTExceptions,\\n    IDegenNFTEvents,\\n    IVersion,\\n    IERC721Metadata\\n{\\n    /// @dev address of the current minter\\n    function minter() external view returns (address);\\n\\n    /// @dev Stores the total number of tokens on holder accounts\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @dev Stores the base URI for NFT metadata\\n    function baseURI() external view returns (string memory);\\n\\n    /// @dev Mints a specified amount of tokens to the address\\n    /// @param to Address the tokens are minted to\\n    /// @param amount The number of tokens to mint\\n    function mint(address to, uint256 amount) external;\\n\\n    /// @dev Burns a number of tokens from a specified address\\n    /// @param from The address a token will be burnt from\\n    /// @param amount The number of tokens to burn\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/ICreditManagerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IPriceOracleV2 } from \\\"./IPriceOracle.sol\\\";\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\nenum ClosureAction {\\n    CLOSE_ACCOUNT,\\n    LIQUIDATE_ACCOUNT,\\n    LIQUIDATE_EXPIRED_ACCOUNT,\\n    LIQUIDATE_PAUSED\\n}\\n\\ninterface ICreditManagerV2Events {\\n    /// @dev Emits when a call to an external contract is made through the Credit Manager\\n    event ExecuteOrder(address indexed borrower, address indexed target);\\n\\n    /// @dev Emits when a configurator is upgraded\\n    event NewConfigurator(address indexed newConfigurator);\\n}\\n\\ninterface ICreditManagerV2Exceptions {\\n    /// @dev Thrown if an access-restricted function is called by an address that is not\\n    ///      the connected Credit Facade, or an allowed adapter\\n    error AdaptersOrCreditFacadeOnlyException();\\n\\n    /// @dev Thrown if an access-restricted function is called by an address that is not\\n    ///      the connected Credit Facade\\n    error CreditFacadeOnlyException();\\n\\n    /// @dev Thrown if an access-restricted function is called by an address that is not\\n    ///      the connected Credit Configurator\\n    error CreditConfiguratorOnlyException();\\n\\n    /// @dev Thrown on attempting to open a Credit Account for or transfer a Credit Account\\n    ///      to the zero address or an address that already owns a Credit Account\\n    error ZeroAddressOrUserAlreadyHasAccountException();\\n\\n    /// @dev Thrown on attempting to execute an order to an address that is not an allowed\\n    ///      target contract\\n    error TargetContractNotAllowedException();\\n\\n    /// @dev Thrown on failing a full collateral check after an operation\\n    error NotEnoughCollateralException();\\n\\n    /// @dev Thrown on attempting to receive a token that is not a collateral token\\n    ///      or was forbidden\\n    error TokenNotAllowedException();\\n\\n    /// @dev Thrown if an attempt to approve a collateral token to a target contract failed\\n    error AllowanceFailedException();\\n\\n    /// @dev Thrown on attempting to perform an action for an address that owns no Credit Account\\n    error HasNoOpenedAccountException();\\n\\n    /// @dev Thrown on attempting to add a token that is already in a collateral list\\n    error TokenAlreadyAddedException();\\n\\n    /// @dev Thrown on configurator attempting to add more than 256 collateral tokens\\n    error TooManyTokensException();\\n\\n    /// @dev Thrown if more than the maximal number of tokens were enabled on a Credit Account,\\n    ///      and there are not enough unused token to disable\\n    error TooManyEnabledTokensException();\\n\\n    /// @dev Thrown when a reentrancy into the contract is attempted\\n    error ReentrancyLockException();\\n}\\n\\n/// @notice All Credit Manager functions are access-restricted and can only be called\\n///         by the Credit Facade or allowed adapters. Users are not allowed to\\n///         interact with the Credit Manager directly\\ninterface ICreditManagerV2 is\\n    ICreditManagerV2Events,\\n    ICreditManagerV2Exceptions,\\n    IVersion\\n{\\n    //\\n    // CREDIT ACCOUNT MANAGEMENT\\n    //\\n\\n    ///  @dev Opens credit account and borrows funds from the pool.\\n    /// - Takes Credit Account from the factory;\\n    /// - Requests the pool to lend underlying to the Credit Account\\n    ///\\n    /// @param borrowedAmount Amount to be borrowed by the Credit Account\\n    /// @param onBehalfOf The owner of the newly opened Credit Account\\n    function openCreditAccount(uint256 borrowedAmount, address onBehalfOf)\\n        external\\n        returns (address);\\n\\n    ///  @dev Closes a Credit Account - covers both normal closure and liquidation\\n    /// - Checks whether the contract is paused, and, if so, if the payer is an emergency liquidator.\\n    ///   Only emergency liquidators are able to liquidate account while the CM is paused.\\n    ///   Emergency liquidations do not pay a liquidator premium or liquidation fees.\\n    /// - Calculates payments to various recipients on closure:\\n    ///    + Computes amountToPool, which is the amount to be sent back to the pool.\\n    ///      This includes the principal, interest and fees, but can't be more than\\n    ///      total position value\\n    ///    + Computes remainingFunds during liquidations - these are leftover funds\\n    ///      after paying the pool and the liquidator, and are sent to the borrower\\n    ///    + Computes protocol profit, which includes interest and liquidation fees\\n    ///    + Computes loss if the totalValue is less than borrow amount + interest\\n    /// - Checks the underlying token balance:\\n    ///    + if it is larger than amountToPool, then the pool is paid fully from funds on the Credit Account\\n    ///    + else tries to transfer the shortfall from the payer - either the borrower during closure, or liquidator during liquidation\\n    /// - Send assets to the \\\"to\\\" address, as long as they are not included into skipTokenMask\\n    /// - If convertWETH is true, the function converts WETH into ETH before sending\\n    /// - Returns the Credit Account back to factory\\n    ///\\n    /// @param borrower Borrower address\\n    /// @param closureActionType Whether the account is closed, liquidated or liquidated due to expiry\\n    /// @param totalValue Portfolio value for liqution, 0 for ordinary closure\\n    /// @param payer Address which would be charged if credit account has not enough funds to cover amountToPool\\n    /// @param to Address to which the leftover funds will be sent\\n    /// @param skipTokenMask Tokenmask contains 1 for tokens which needed to be skipped for sending\\n    /// @param convertWETH If true converts WETH to ETH\\n    function closeCreditAccount(\\n        address borrower,\\n        ClosureAction closureActionType,\\n        uint256 totalValue,\\n        address payer,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH\\n    ) external returns (uint256 remainingFunds);\\n\\n    /// @dev Manages debt size for borrower:\\n    ///\\n    /// - Increase debt:\\n    ///   + Increases debt by transferring funds from the pool to the credit account\\n    ///   + Updates the cumulative index to keep interest the same. Since interest\\n    ///     is always computed dynamically as borrowedAmount * (cumulativeIndexNew / cumulativeIndexOpen - 1),\\n    ///     cumulativeIndexOpen needs to be updated, as the borrow amount has changed\\n    ///\\n    /// - Decrease debt:\\n    ///   + Repays debt partially + all interest and fees accrued thus far\\n    ///   + Updates cunulativeIndex to cumulativeIndex now\\n    ///\\n    /// @param creditAccount Address of the Credit Account to change debt for\\n    /// @param amount Amount to increase / decrease the principal by\\n    /// @param increase True to increase principal, false to decrease\\n    /// @return newBorrowedAmount The new debt principal\\n    function manageDebt(\\n        address creditAccount,\\n        uint256 amount,\\n        bool increase\\n    ) external returns (uint256 newBorrowedAmount);\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param payer Address of the account which will be charged to provide additional collateral\\n    /// @param creditAccount Address of the Credit Account\\n    /// @param token Collateral token to add\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address payer,\\n        address creditAccount,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Transfers Credit Account ownership to another address\\n    /// @param from Address of previous owner\\n    /// @param to Address of new owner\\n    function transferAccountOwnership(address from, address to) external;\\n\\n    /// @dev Requests the Credit Account to approve a collateral token to another contract.\\n    /// @param borrower Borrower's address\\n    /// @param targetContract Spender to change allowance for\\n    /// @param token Collateral token to approve\\n    /// @param amount New allowance amount\\n    function approveCreditAccount(\\n        address borrower,\\n        address targetContract,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Requests a Credit Account to make a low-level call with provided data\\n    /// This is the intended pathway for state-changing interactions with 3rd-party protocols\\n    /// @param borrower Borrower's address\\n    /// @param targetContract Contract to be called\\n    /// @param data Data to pass with the call\\n    function executeOrder(\\n        address borrower,\\n        address targetContract,\\n        bytes memory data\\n    ) external returns (bytes memory);\\n\\n    //\\n    // COLLATERAL VALIDITY AND ACCOUNT HEALTH CHECKS\\n    //\\n\\n    /// @dev Enables a token on a Credit Account, including it\\n    /// into account health and total value calculations\\n    /// @param creditAccount Address of a Credit Account to enable the token for\\n    /// @param token Address of the token to be enabled\\n    function checkAndEnableToken(address creditAccount, address token) external;\\n\\n    /// @dev Optimized health check for individual swap-like operations.\\n    /// @notice Fast health check assumes that only two tokens (input and output)\\n    ///         participate in the operation and computes a % change in weighted value between\\n    ///         inbound and outbound collateral. The cumulative negative change across several\\n    ///         swaps in sequence cannot be larger than feeLiquidation (a fee that the\\n    ///         protocol is ready to waive if needed). Since this records a % change\\n    ///         between just two tokens, the corresponding % change in TWV will always be smaller,\\n    ///         which makes this check safe.\\n    ///         More details at https://dev.gearbox.fi/docs/documentation/risk/fast-collateral-check#fast-check-protection\\n    /// @param creditAccount Address of the Credit Account\\n    /// @param tokenIn Address of the token spent by the swap\\n    /// @param tokenOut Address of the token received from the swap\\n    /// @param balanceInBefore Balance of tokenIn before the operation\\n    /// @param balanceOutBefore Balance of tokenOut before the operation\\n    function fastCollateralCheck(\\n        address creditAccount,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 balanceInBefore,\\n        uint256 balanceOutBefore\\n    ) external;\\n\\n    /// @dev Performs a full health check on an account, summing up\\n    /// value of all enabled collateral tokens\\n    /// @param creditAccount Address of the Credit Account to check\\n    function fullCollateralCheck(address creditAccount) external;\\n\\n    /// @dev Checks that the number of enabled tokens on a Credit Account\\n    ///      does not violate the maximal enabled token limit and tries\\n    ///      to disable unused tokens if it does\\n    /// @param creditAccount Account to check enabled tokens for\\n    function checkAndOptimizeEnabledTokens(address creditAccount) external;\\n\\n    /// @dev Disables a token on a credit account\\n    /// @notice Usually called by adapters to disable spent tokens during a multicall,\\n    ///         but can also be called separately from the Credit Facade to remove\\n    ///         unwanted tokens\\n    /// @return True if token mask was change otherwise False\\n    function disableToken(address creditAccount, address token)\\n        external\\n        returns (bool);\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Returns the address of a borrower's Credit Account, or reverts if there is none.\\n    /// @param borrower Borrower's address\\n    function getCreditAccountOrRevert(address borrower)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @dev Computes amounts that must be sent to various addresses before closing an account\\n    /// @param totalValue Credit Accounts total value in underlying\\n    /// @param closureActionType Type of account closure\\n    ///        * CLOSE_ACCOUNT: The account is healthy and is closed normally\\n    ///        * LIQUIDATE_ACCOUNT: The account is unhealthy and is being liquidated to avoid bad debt\\n    ///        * LIQUIDATE_EXPIRED_ACCOUNT: The account has expired and is being liquidated (lowered liquidation premium)\\n    ///        * LIQUIDATE_PAUSED: The account is liquidated while the system is paused due to emergency (no liquidation premium)\\n    /// @param borrowedAmount Credit Account's debt principal\\n    /// @param borrowedAmountWithInterest Credit Account's debt principal + interest\\n    /// @return amountToPool Amount of underlying to be sent to the pool\\n    /// @return remainingFunds Amount of underlying to be sent to the borrower (only applicable to liquidations)\\n    /// @return profit Protocol's profit from fees (if any)\\n    /// @return loss Protocol's loss from bad debt (if any)\\n    function calcClosePayments(\\n        uint256 totalValue,\\n        ClosureAction closureActionType,\\n        uint256 borrowedAmount,\\n        uint256 borrowedAmountWithInterest\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 amountToPool,\\n            uint256 remainingFunds,\\n            uint256 profit,\\n            uint256 loss\\n        );\\n\\n    /// @dev Calculates the debt accrued by a Credit Account\\n    /// @param creditAccount Address of the Credit Account\\n    /// @return borrowedAmount The debt principal\\n    /// @return borrowedAmountWithInterest The debt principal + accrued interest\\n    /// @return borrowedAmountWithInterestAndFees The debt principal + accrued interest and protocol fees\\n    function calcCreditAccountAccruedInterest(address creditAccount)\\n        external\\n        view\\n        returns (\\n            uint256 borrowedAmount,\\n            uint256 borrowedAmountWithInterest,\\n            uint256 borrowedAmountWithInterestAndFees\\n        );\\n\\n    /// @dev Maps Credit Accounts to bit masks encoding their enabled token sets\\n    /// Only enabled tokens are counted as collateral for the Credit Account\\n    /// @notice An enabled token mask encodes an enabled token by setting\\n    ///         the bit at the position equal to token's index to 1\\n    function enabledTokensMap(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Maps the Credit Account to its current percentage drop across all swaps since\\n    ///      the last full check, in RAY format\\n    function cumulativeDropAtFastCheckRAY(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Returns the collateral token at requested index and its liquidation threshold\\n    /// @param id The index of token to return\\n    function collateralTokens(uint256 id)\\n        external\\n        view\\n        returns (address token, uint16 liquidationThreshold);\\n\\n    /// @dev Returns the collateral token with requested mask and its liquidationThreshold\\n    /// @param tokenMask Token mask corresponding to the token\\n    function collateralTokensByMask(uint256 tokenMask)\\n        external\\n        view\\n        returns (address token, uint16 liquidationThreshold);\\n\\n    /// @dev Total number of known collateral tokens.\\n    function collateralTokensCount() external view returns (uint256);\\n\\n    /// @dev Returns the mask for the provided token\\n    /// @param token Token to returns the mask for\\n    function tokenMasksMap(address token) external view returns (uint256);\\n\\n    /// @dev Bit mask encoding a set of forbidden tokens\\n    function forbiddenTokenMask() external view returns (uint256);\\n\\n    /// @dev Maps allowed adapters to their respective target contracts.\\n    function adapterToContract(address adapter) external view returns (address);\\n\\n    /// @dev Maps 3rd party contracts to their respective adapters\\n    function contractToAdapter(address targetContract)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @dev Address of the underlying asset\\n    function underlying() external view returns (address);\\n\\n    /// @dev Address of the connected pool\\n    function pool() external view returns (address);\\n\\n    /// @dev Address of the connected pool\\n    /// @notice [DEPRECATED]: use pool() instead.\\n    function poolService() external view returns (address);\\n\\n    /// @dev A map from borrower addresses to Credit Account addresses\\n    function creditAccounts(address borrower) external view returns (address);\\n\\n    /// @dev Address of the connected Credit Configurator\\n    function creditConfigurator() external view returns (address);\\n\\n    /// @dev Address of WETH\\n    function wethAddress() external view returns (address);\\n\\n    /// @dev Returns the liquidation threshold for the provided token\\n    /// @param token Token to retrieve the LT for\\n    function liquidationThresholds(address token)\\n        external\\n        view\\n        returns (uint16);\\n\\n    /// @dev The maximal number of enabled tokens on a single Credit Account\\n    function maxAllowedEnabledTokenLength() external view returns (uint8);\\n\\n    /// @dev Maps addresses to their status as emergency liquidator.\\n    /// @notice Emergency liquidators are trusted addresses\\n    /// that are able to liquidate positions while the contracts are paused,\\n    /// e.g. when there is a risk of bad debt while an exploit is being patched.\\n    /// In the interest of fairness, emergency liquidators do not receive a premium\\n    /// And are compensated by the Gearbox DAO separately.\\n    function canLiquidateWhilePaused(address) external view returns (bool);\\n\\n    /// @dev Returns the fee parameters of the Credit Manager\\n    /// @return feeInterest Percentage of interest taken by the protocol as profit\\n    /// @return feeLiquidation Percentage of account value taken by the protocol as profit\\n    ///         during unhealthy account liquidations\\n    /// @return liquidationDiscount Multiplier that reduces the effective totalValue during unhealthy account liquidations,\\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremium)\\n    /// @return feeLiquidationExpired Percentage of account value taken by the protocol as profit\\n    ///         during expired account liquidations\\n    /// @return liquidationDiscountExpired Multiplier that reduces the effective totalValue during expired account liquidations,\\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremiumExpired)\\n    function fees()\\n        external\\n        view\\n        returns (\\n            uint16 feeInterest,\\n            uint16 feeLiquidation,\\n            uint16 liquidationDiscount,\\n            uint16 feeLiquidationExpired,\\n            uint16 liquidationDiscountExpired\\n        );\\n\\n    /// @dev Address of the connected Credit Facade\\n    function creditFacade() external view returns (address);\\n\\n    /// @dev Address of the connected Price Oracle\\n    function priceOracle() external view returns (IPriceOracleV2);\\n\\n    /// @dev Address of the universal adapter\\n    function universalAdapter() external view returns (address);\\n\\n    /// @dev Contract's version\\n    function version() external view returns (uint256);\\n\\n    /// @dev Paused() state\\n    function checkEmergencyPausable(address caller, bool state)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IAddressProviderEvents {\\n    /// @dev Emits when an address is set for a contract role\\n    event AddressSet(bytes32 indexed service, address indexed newAddress);\\n}\\n\\n/// @title Optimised for front-end Address Provider interface\\ninterface IAddressProvider is IAddressProviderEvents, IVersion {\\n    /// @return Address of ACL contract\\n    function getACL() external view returns (address);\\n\\n    /// @return Address of ContractsRegister\\n    function getContractsRegister() external view returns (address);\\n\\n    /// @return Address of AccountFactory\\n    function getAccountFactory() external view returns (address);\\n\\n    /// @return Address of DataCompressor\\n    function getDataCompressor() external view returns (address);\\n\\n    /// @return Address of GEAR token\\n    function getGearToken() external view returns (address);\\n\\n    /// @return Address of WETH token\\n    function getWethToken() external view returns (address);\\n\\n    /// @return Address of WETH Gateway\\n    function getWETHGateway() external view returns (address);\\n\\n    /// @return Address of PriceOracle\\n    function getPriceOracle() external view returns (address);\\n\\n    /// @return Address of DAO Treasury Multisig\\n    function getTreasuryContract() external view returns (address);\\n\\n    /// @return Address of PathFinder\\n    function getLeveragedActions() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title Errors library\\nlibrary Errors {\\n    //\\n    // COMMON\\n    //\\n    string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = \\\"Z0\\\";\\n    string public constant NOT_IMPLEMENTED = \\\"NI\\\";\\n    string public constant INCORRECT_PATH_LENGTH = \\\"PL\\\";\\n    string public constant INCORRECT_ARRAY_LENGTH = \\\"CR\\\";\\n    string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = \\\"CP\\\";\\n    string public constant REGISTERED_POOLS_ONLY = \\\"RP\\\";\\n    string public constant INCORRECT_PARAMETER = \\\"IP\\\";\\n\\n    //\\n    // MATH\\n    //\\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"M1\\\";\\n    string public constant MATH_ADDITION_OVERFLOW = \\\"M2\\\";\\n    string public constant MATH_DIVISION_BY_ZERO = \\\"M3\\\";\\n\\n    //\\n    // POOL\\n    //\\n    string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = \\\"PS0\\\";\\n    string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = \\\"PS1\\\";\\n    string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = \\\"PS2\\\";\\n    string public constant POOL_INCORRECT_WITHDRAW_FEE = \\\"PS3\\\";\\n    string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = \\\"PS4\\\";\\n\\n    //\\n    // ACCOUNT FACTORY\\n    //\\n    string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK =\\n        \\\"AF1\\\";\\n    string public constant AF_MINING_IS_FINISHED = \\\"AF2\\\";\\n    string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = \\\"AF3\\\";\\n    string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = \\\"AF4\\\";\\n\\n    //\\n    // ADDRESS PROVIDER\\n    //\\n    string public constant AS_ADDRESS_NOT_FOUND = \\\"AP1\\\";\\n\\n    //\\n    // CONTRACTS REGISTER\\n    //\\n    string public constant CR_POOL_ALREADY_ADDED = \\\"CR1\\\";\\n    string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = \\\"CR2\\\";\\n\\n    //\\n    // CREDIT ACCOUNT\\n    //\\n    string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = \\\"CA1\\\";\\n    string public constant CA_FACTORY_ONLY = \\\"CA2\\\";\\n\\n    //\\n    // ACL\\n    //\\n    string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = \\\"ACL1\\\";\\n    string public constant ACL_CALLER_NOT_CONFIGURATOR = \\\"ACL2\\\";\\n\\n    //\\n    // WETH GATEWAY\\n    //\\n    string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = \\\"WG1\\\";\\n    string public constant WG_RECEIVE_IS_NOT_ALLOWED = \\\"WG2\\\";\\n    string public constant WG_NOT_ENOUGH_FUNDS = \\\"WG3\\\";\\n\\n    //\\n    // TOKEN DISTRIBUTOR\\n    //\\n    string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = \\\"TD1\\\";\\n    string public constant TD_INCORRECT_WEIGHTS = \\\"TD2\\\";\\n    string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = \\\"TD3\\\";\\n    string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = \\\"TD4\\\";\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/access/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Claimable\\n/// @dev Implements logic for a two-step ownership transfer on top of Ownable\\ncontract Claimable is Ownable {\\n    /// @dev The new owner that has not claimed ownership yet\\n    address public pendingOwner;\\n\\n    /// @dev A modifier that restricts the function to the pending owner only\\n    modifier onlyPendingOwner() {\\n        if (msg.sender != pendingOwner) {\\n            revert(\\\"Claimable: Sender is not pending owner\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev Sets pending owner to the new owner, but does not\\n    /// transfer ownership yet\\n    /// @param newOwner The address to become the future owner\\n    function transferOwnership(address newOwner) public override onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Claimable: new owner is the zero address\\\"\\n        );\\n        pendingOwner = newOwner;\\n    }\\n\\n    /// @dev Used by the pending owner to claim ownership after transferOwnership\\n    function claimOwnership() external onlyPendingOwner {\\n        _transferOwnership(pendingOwner);\\n        pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title IVersion\\n/// @dev Declares a version function which returns the contract's version\\ninterface IVersion {\\n    /// @dev Returns contract version\\n    function version() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IACLExceptions {\\n    /// @dev Thrown when attempting to delete an address from a set that is not a pausable admin\\n    error AddressNotPausableAdminException(address addr);\\n\\n    /// @dev Thrown when attempting to delete an address from a set that is not a unpausable admin\\n    error AddressNotUnpausableAdminException(address addr);\\n}\\n\\ninterface IACLEvents {\\n    /// @dev Emits when a new admin is added that can pause contracts\\n    event PausableAdminAdded(address indexed newAdmin);\\n\\n    /// @dev Emits when a Pausable admin is removed\\n    event PausableAdminRemoved(address indexed admin);\\n\\n    /// @dev Emits when a new admin is added that can unpause contracts\\n    event UnpausableAdminAdded(address indexed newAdmin);\\n\\n    /// @dev Emits when an Unpausable admin is removed\\n    event UnpausableAdminRemoved(address indexed admin);\\n}\\n\\n/// @title ACL interface\\ninterface IACL is IACLEvents, IACLExceptions, IVersion {\\n    /// @dev Returns true if the address is a pausable admin and false if not\\n    /// @param addr Address to check\\n    function isPausableAdmin(address addr) external view returns (bool);\\n\\n    /// @dev Returns true if the address is unpausable admin and false if not\\n    /// @param addr Address to check\\n    function isUnpausableAdmin(address addr) external view returns (bool);\\n\\n    /// @dev Returns true if an address has configurator rights\\n    /// @param account Address to check\\n    function isConfigurator(address account) external view returns (bool);\\n\\n    /// @dev Returns address of configurator\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IContractsRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IContractsRegisterEvents {\\n    /// @dev Emits when a new pool is registered in the system\\n    event NewPoolAdded(address indexed pool);\\n\\n    /// @dev Emits when a new Credit Manager is registered in the system\\n    event NewCreditManagerAdded(address indexed creditManager);\\n}\\n\\ninterface IContractsRegister is IContractsRegisterEvents, IVersion {\\n    //\\n    // POOLS\\n    //\\n\\n    /// @dev Returns the array of registered pools\\n    function getPools() external view returns (address[] memory);\\n\\n    /// @dev Returns a pool address from the list under the passed index\\n    /// @param i Index of the pool to retrieve\\n    function pools(uint256 i) external returns (address);\\n\\n    /// @return Returns the number of registered pools\\n    function getPoolsCount() external view returns (uint256);\\n\\n    /// @dev Returns true if the passed address is a pool\\n    function isPool(address) external view returns (bool);\\n\\n    //\\n    // CREDIT MANAGERS\\n    //\\n\\n    /// @dev Returns the array of registered Credit Managers\\n    function getCreditManagers() external view returns (address[] memory);\\n\\n    /// @dev Returns a Credit Manager's address from the list under the passed index\\n    /// @param i Index of the Credit Manager to retrieve\\n    function creditManagers(uint256 i) external returns (address);\\n\\n    /// @return Returns the number of registered Credit Managers\\n    function getCreditManagersCount() external view returns (uint256);\\n\\n    /// @dev Returns true if the passed address is a Credit Manager\\n    function isCreditManager(address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Balances.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nstruct Balance {\\n    address token;\\n    uint256 balance;\\n}\\n\\nlibrary BalanceOps {\\n    error UnknownToken(address);\\n\\n    function copyBalance(Balance memory b)\\n        internal\\n        pure\\n        returns (Balance memory)\\n    {\\n        return Balance({ token: b.token, balance: b.balance });\\n    }\\n\\n    function addBalance(\\n        Balance[] memory b,\\n        address token,\\n        uint256 amount\\n    ) internal pure {\\n        b[getIndex(b, token)].balance += amount;\\n    }\\n\\n    function subBalance(\\n        Balance[] memory b,\\n        address token,\\n        uint256 amount\\n    ) internal pure {\\n        b[getIndex(b, token)].balance -= amount;\\n    }\\n\\n    function getBalance(Balance[] memory b, address token)\\n        internal\\n        pure\\n        returns (uint256 amount)\\n    {\\n        return b[getIndex(b, token)].balance;\\n    }\\n\\n    function setBalance(\\n        Balance[] memory b,\\n        address token,\\n        uint256 amount\\n    ) internal pure {\\n        b[getIndex(b, token)].balance = amount;\\n    }\\n\\n    function getIndex(Balance[] memory b, address token)\\n        internal\\n        pure\\n        returns (uint256 index)\\n    {\\n        for (uint256 i; i < b.length; ) {\\n            if (b[i].token == token) {\\n                return i;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        revert UnknownToken(token);\\n    }\\n\\n    function copy(Balance[] memory b, uint256 len)\\n        internal\\n        pure\\n        returns (Balance[] memory res)\\n    {\\n        res = new Balance[](len);\\n        for (uint256 i; i < len; ) {\\n            res[i] = copyBalance(b[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function clone(Balance[] memory b)\\n        internal\\n        pure\\n        returns (Balance[] memory)\\n    {\\n        return copy(b, b.length);\\n    }\\n\\n    function getModifiedAfterSwap(\\n        Balance[] memory b,\\n        address tokenFrom,\\n        uint256 amountFrom,\\n        address tokenTo,\\n        uint256 amountTo\\n    ) internal pure returns (Balance[] memory res) {\\n        res = copy(b, b.length);\\n        setBalance(res, tokenFrom, getBalance(b, tokenFrom) - amountFrom);\\n        setBalance(res, tokenTo, getBalance(b, tokenTo) + amountTo);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/MultiCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.10;\\n\\nstruct MultiCall {\\n    address target;\\n    bytes callData;\\n}\\n\\nlibrary MultiCallOps {\\n    function copyMulticall(MultiCall memory call)\\n        internal\\n        pure\\n        returns (MultiCall memory)\\n    {\\n        return MultiCall({ target: call.target, callData: call.callData });\\n    }\\n\\n    function trim(MultiCall[] memory calls)\\n        internal\\n        pure\\n        returns (MultiCall[] memory trimmed)\\n    {\\n        uint256 len = calls.length;\\n\\n        if (len == 0) return calls;\\n\\n        uint256 foundLen;\\n        while (calls[foundLen].target != address(0)) {\\n            unchecked {\\n                ++foundLen;\\n                if (foundLen == len) return calls;\\n            }\\n        }\\n\\n        if (foundLen > 0) return copy(calls, foundLen);\\n    }\\n\\n    function copy(MultiCall[] memory calls, uint256 len)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        res = new MultiCall[](len);\\n        for (uint256 i; i < len; ) {\\n            res[i] = copyMulticall(calls[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function clone(MultiCall[] memory calls)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        return copy(calls, calls.length);\\n    }\\n\\n    function append(MultiCall[] memory calls, MultiCall memory newCall)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        uint256 len = calls.length;\\n        res = new MultiCall[](len + 1);\\n        for (uint256 i; i < len; ) {\\n            res[i] = copyMulticall(calls[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        res[len] = copyMulticall(newCall);\\n    }\\n\\n    function prepend(MultiCall[] memory calls, MultiCall memory newCall)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        uint256 len = calls.length;\\n        res = new MultiCall[](len + 1);\\n        res[0] = copyMulticall(newCall);\\n\\n        for (uint256 i = 1; i < len + 1; ) {\\n            res[i] = copyMulticall(calls[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function concat(MultiCall[] memory calls1, MultiCall[] memory calls2)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        uint256 len1 = calls1.length;\\n        uint256 lenTotal = len1 + calls2.length;\\n\\n        if (lenTotal == calls1.length) return clone(calls1);\\n        if (lenTotal == calls2.length) return clone(calls2);\\n\\n        res = new MultiCall[](lenTotal);\\n\\n        for (uint256 i; i < lenTotal; ) {\\n            res[i] = (i < len1)\\n                ? copyMulticall(calls1[i])\\n                : copyMulticall(calls2[i - len1]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IPriceOracleV2Events {\\n    /// @dev Emits when a new price feed is added\\n    event NewPriceFeed(address indexed token, address indexed priceFeed);\\n}\\n\\ninterface IPriceOracleV2Exceptions {\\n    /// @dev Thrown if a price feed returns 0\\n    error ZeroPriceException();\\n\\n    /// @dev Thrown if the last recorded result was not updated in the last round\\n    error ChainPriceStaleException();\\n\\n    /// @dev Thrown on attempting to get a result for a token that does not have a price feed\\n    error PriceOracleNotExistsException();\\n}\\n\\n/// @title Price oracle interface\\ninterface IPriceOracleV2 is\\n    IPriceOracleV2Events,\\n    IPriceOracleV2Exceptions,\\n    IVersion\\n{\\n    /// @dev Converts a quantity of an asset to USD (decimals = 8).\\n    /// @param amount Amount to convert\\n    /// @param token Address of the token to be converted\\n    function convertToUSD(uint256 amount, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Converts a quantity of USD (decimals = 8) to an equivalent amount of an asset\\n    /// @param amount Amount to convert\\n    /// @param token Address of the token converted to\\n    function convertFromUSD(uint256 amount, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Converts one asset into another\\n    ///\\n    /// @param amount Amount to convert\\n    /// @param tokenFrom Address of the token to convert from\\n    /// @param tokenTo Address of the token to convert to\\n    function convert(\\n        uint256 amount,\\n        address tokenFrom,\\n        address tokenTo\\n    ) external view returns (uint256);\\n\\n    /// @dev Returns collateral values for two tokens, required for a fast check\\n    /// @param amountFrom Amount of the outbound token\\n    /// @param tokenFrom Address of the outbound token\\n    /// @param amountTo Amount of the inbound token\\n    /// @param tokenTo Address of the inbound token\\n    /// @return collateralFrom Value of the outbound token amount in USD\\n    /// @return collateralTo Value of the inbound token amount in USD\\n    function fastCheck(\\n        uint256 amountFrom,\\n        address tokenFrom,\\n        uint256 amountTo,\\n        address tokenTo\\n    ) external view returns (uint256 collateralFrom, uint256 collateralTo);\\n\\n    /// @dev Returns token's price in USD (8 decimals)\\n    /// @param token The token to compute the price for\\n    function getPrice(address token) external view returns (uint256);\\n\\n    /// @dev Returns the price feed address for the passed token\\n    /// @param token Token to get the price feed for\\n    function priceFeeds(address token)\\n        external\\n        view\\n        returns (address priceFeed);\\n\\n    /// @dev Returns the price feed for the passed token,\\n    ///      with additional parameters\\n    /// @param token Token to get the price feed for\\n    function priceFeedsWithFlags(address token)\\n        external\\n        view\\n        returns (\\n            address priceFeed,\\n            bool skipCheck,\\n            uint256 decimals\\n        );\\n}\\n\\ninterface IPriceOracleV2Ext is IPriceOracleV2 {\\n    /// @dev Sets a price feed if it doesn't exist, or updates an existing one\\n    /// @param token Address of the token to set the price feed for\\n    /// @param priceFeed Address of a USD price feed adhering to Chainlink's interface\\n    function addPriceFeed(address token, address priceFeed) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressProvider\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerNotConfiguratorException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotPausableAdminException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotUnPausableAdminException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreditFacadeOrConfiguratorOnlyException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalanceException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCreditFacadeException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinterOnlyException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotImplementedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressException\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewCreditFacadeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewCreditFacadeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewMinterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acl\",\"outputs\":[{\"internalType\":\"contract IACL\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creditFacade_\",\"type\":\"address\"}],\"name\":\"addCreditFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSupportedCreditFacade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creditFacade_\",\"type\":\"address\"}],\"name\":\"removeCreditFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DegenNFT", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000cf64698aff7e5f27a11dff868af228653ba53be0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000008446567656e4e46540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004444e465400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}