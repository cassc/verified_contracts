{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UniV3Buyer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISwapRouter.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IPool.sol\\\";\\n\\ncontract UniV3Buyer {\\n    address constant UNIV3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n\\n    ISwapRouter internal router;\\n\\n    constructor() {\\n        router = ISwapRouter(UNIV3_ROUTER);\\n    }\\n\\n    function approveForRouter(address token, uint256 amount) public {\\n        IERC20 tokenErc = IERC20(token);\\n        tokenErc.approve(UNIV3_ROUTER, amount);\\n    }\\n\\n    function resetAllowance(address token) public {\\n        IERC20 tokenErc = IERC20(token);\\n        tokenErc.approve(UNIV3_ROUTER, 0);\\n    }\\n\\n    function readPool(address poolAddress)\\n        public\\n        view\\n        returns (\\n            uint256 sqrtPriceX96,\\n            uint256 liquidity,\\n            int24 tickSpacing\\n        )\\n    {\\n        IPool pool = IPool(poolAddress);\\n        IPool.Slot0 memory slot0 = pool.slot0();\\n\\n        sqrtPriceX96 = slot0.sqrtPriceX96;\\n        liquidity = pool.liquidity();\\n        tickSpacing = pool.tickSpacing();\\n    }\\n\\n    function exactOutputSingle(\\n        ISwapRouter.ExactOutputSingleParams calldata params\\n    )\\n        public\\n        returns (\\n            // payable\\n            uint256 amountIn\\n        )\\n    {\\n        IERC20(params.tokenIn).transferFrom(\\n            msg.sender,\\n            address(this),\\n            params.amountInMaximum\\n        );\\n\\n        approveForRouter(params.tokenIn, params.amountInMaximum);\\n        amountIn = router.exactOutputSingle(params);\\n\\n        if (amountIn < params.amountInMaximum) {\\n            IERC20(params.tokenIn).transfer(\\n                msg.sender,\\n                params.amountInMaximum - amountIn\\n            );\\n        }\\n\\n        resetAllowance(params.tokenIn);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.17;\\n\\ninterface IPool {\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        // the most-recently updated index of the observations array\\n        uint16 observationIndex;\\n        // the current maximum number of observations that are being stored\\n        uint16 observationCardinality;\\n        // the next maximum number of observations to store, triggered in observations.write\\n        uint16 observationCardinalityNext;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n    }\\n\\n    function slot0() external view returns (Slot0 memory);\\n\\n    function liquidity() external view returns (uint256);\\n\\n    function tickSpacing() external view returns (int24);\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface ISwapRouter {\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveForRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct ISwapRouter.ExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"readPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sqrtPriceX96\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"resetAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UniV3Buyer", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}