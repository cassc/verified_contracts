{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BillyTheBull.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { NFTOutlet } from \\\"./NFTOutlet.sol\\\";\\nimport { IPuzzle } from \\\"./interfaces/IPuzzle.sol\\\";\\nimport { IERC721 } from \\\"./interfaces/IERC721.sol\\\";\\n\\n/**\\nYou are Billy the Bull, the most infamous of NFT influencers.\\nYour trades move markets,\\n    your lambos fill Instagram timelines,\\n        your Twitter threads are the stuff of legends.\\n\\nThere's just one problem: you're broke.\\n\\nWith just one more trade, you'd certainly earn it all back.\\nBut your mom is done lending you money, and there's nowhere left to turn.\\n\\nA new mint has just opened up on The NFT Outlet. You _know_ it'll be a hit.\\nYour strategy is clear: You need 2 NFTs. Sell one. Keep the other for your collection.\\nIf only there were a way to get them without paying...\\n*/\\ncontract BillyTheBull is IPuzzle {\\n    address public owner;\\n    NFTOutlet public nftOutlet;\\n    uint public nftPrice;\\n    uint cachedSolution;\\n\\n    event OwnsBoth(address indexed wallet, uint tokenId1, uint tokenId2);\\n\\n    constructor() {\\n        owner = address(tx.origin);\\n    }\\n\\n    function initialize(address _nftOutlet, uint _startingNftPrice) external {\\n        require(address(nftOutlet) == address(0), \\\"already initialized\\\");\\n        nftOutlet = NFTOutlet(_nftOutlet);\\n        nftPrice = _startingNftPrice;\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return \\\"Billy the Bull\\\";\\n    }\\n\\n    function generate(address _seed) public pure returns (uint256 start) {\\n        start = uint256(keccak256(abi.encode(_seed)));\\n    }\\n\\n    function verify(uint _start, uint _solution) public noTampering(_solution) returns (bool) {\\n        // decode & cache input arguments\\n        uint tokenId1 = _start >> 128;\\n        uint tokenId2 = uint(uint128(_start));\\n        address wallet = address(uint160(_solution));\\n        IERC721 nftToBuy = nftOutlet.nftDealOfTheDay();\\n\\n        // use external logic with local storage to determine the ~~magic flag~~\\n        bytes32 pre = keccak256(abi.encode(owner, nftOutlet, nftPrice, cachedSolution, nftToBuy.totalSupply()));\\n        (, bytes memory d0) = wallet.delegatecall(abi.encodeWithSignature(\\\"getMagicFlag()\\\"));\\n        bytes32 post = keccak256(abi.encode(owner, nftOutlet, nftPrice, cachedSolution, nftToBuy.totalSupply()));\\n        require(pre == post, \\\"bad boy\\\");\\n\\n        // ensure we have a unique magic flag\\n        bytes memory magicFlag = abi.decode(d0, (bytes));\\n        require(nftOutlet.magicFlagsUsed(keccak256(magicFlag)) == false, \\\"no reusing flags\\\");\\n        nftOutlet.setMagicFlagUsed(keccak256(magicFlag));\\n\\n        // alright houdini, pay without paying\\n        uint balanceBefore = nftOutlet.paymentToken().balanceOf(wallet);\\n        (bool s1, bytes memory d1) = address(nftOutlet).call(\\n            abi.encodeWithSignature(\\\"pay(address,uint256)\\\", wallet, _incrementNFTPrice(1e18))\\n        );\\n        require(!_returnedFalse(s1, d1), \\\"transfer must succeed\\\");\\n        require(balanceBefore == nftOutlet.paymentToken().balanceOf(wallet), \\\"sneaky sneaky\\\");\\n\\n        // mint an nft to your wallet\\n        (bool s2, bytes memory d2) = address(nftOutlet).call(\\n            abi.encodeWithSignature(\\\"mint(address,uint256)\\\", wallet, tokenId1)\\n        );\\n        require(!_returnedFalse(s2, d2), \\\"mint must succeed\\\");\\n\\n        // did you end up with both nfts?\\n        require(nftToBuy.ownerOf(tokenId1) == wallet, \\\"must own token id 1\\\");\\n        require(nftToBuy.ownerOf(tokenId2) == wallet, \\\"must own token id 2\\\");\\n        emit OwnsBoth(wallet, tokenId1, tokenId2);\\n\\n        // you win ... if you got the magic flag right\\n        return uint(keccak256(magicFlag)) == _solution;\\n    }\\n\\n    function _returnedFalse(bool success, bytes memory data) internal pure returns (bool) {\\n        return success && !abi.decode(data, (bool));\\n    }\\n\\n    function _incrementNFTPrice(uint _incrementBy) public returns (uint oldPrice) {\\n        require(_incrementBy < 10e18, \\\"lets keep this affordable\\\");\\n        oldPrice = nftPrice;\\n        nftPrice = nftPrice + _incrementBy;\\n    }\\n\\n    modifier noTampering(uint _solution) {\\n        if (cachedSolution == 0) {\\n            cachedSolution = _solution;\\n            _;\\n            cachedSolution = 0;\\n        } else {\\n            require(cachedSolution == _solution, \\\"max one solution\\\");\\n            _;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/NFTOutlet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { BillyTheBull } from \\\"./BillyTheBull.sol\\\";\\nimport { ERC20 } from \\\"@solmate/tokens/ERC20.sol\\\";\\nimport { IERC721 } from \\\"./interfaces/IERC721.sol\\\";\\n\\ncontract NFTOutlet {\\n    address immutable puzzle;\\n\\n    ERC20 public paymentToken;\\n    IERC721 public nftDealOfTheDay;\\n    address treasury;\\n\\n    mapping(address => bool) public validAssets;\\n    mapping(address => bool) public mintsClaimed;\\n    mapping(bytes32 => bool) public magicFlagsUsed;\\n\\n    constructor(\\n        address _puzzle,\\n        address[] memory _paymentTokens,\\n        address[] memory _nfts\\n    ) {\\n        puzzle = _puzzle;\\n        paymentToken = ERC20(_paymentTokens[0]);\\n        nftDealOfTheDay = IERC721(_nfts[0]);\\n\\n        for (uint256 i = 0; i < _paymentTokens.length; i++) {\\n            validAssets[_paymentTokens[i]] = true;\\n        }\\n\\n        for (uint256 i = 0; i < _nfts.length; i++) {\\n            validAssets[_nfts[i]] = true;\\n        }\\n    }\\n\\n    /////////////////////////\\n    /////// MODIFIERS ///////\\n    /////////////////////////\\n\\n    modifier onlyPuzzle() {\\n        require(msg.sender == puzzle, \\\"only puzzle\\\");\\n        _;\\n    }\\n\\n    modifier onlyPuzzleOwner() {\\n        require(msg.sender == BillyTheBull(puzzle).owner(), \\\"only puzzle owner\\\");\\n        _;\\n    }\\n\\n    /////////////////////////\\n    //// PAYMENT ACTIONS ////\\n    /////////////////////////\\n\\n    function pay(address _from, uint256 _amount) public onlyPuzzle returns (bool) {\\n        require(_from != address(0), \\\"no zero address\\\");\\n        try paymentToken.transferFrom(_from, address(this), _amount) returns (bool) {\\n            require(\\n                keccak256(abi.encode(_amount)) !=\\n                0x420badbabe420badbabe420badbabe420badbabe420badbabe420badbabe6969,\\n                \\\"too immature\\\"\\n            );\\n            return true;\\n        } catch {\\n            require(uint(uint32(_amount)) <= 4294967295, \\\"invalid amount\\\");\\n            return false;\\n        }\\n    }\\n\\n    /////////////////////////\\n    //// MINTING ACTIONS ////\\n    /////////////////////////\\n\\n    function mint(address _to, uint256 _tokenId) public onlyPuzzle returns (bool) {\\n        require(!mintsClaimed[_to], \\\"already claimed\\\");\\n        try nftDealOfTheDay.safeMint(_to, _tokenId) {\\n            mintsClaimed[_to] = true;\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    /////////////////////////\\n    ///// ADMIN ACTIONS /////\\n    /////////////////////////\\n\\n    function setMagicFlagUsed(bytes32 _magicFlag) onlyPuzzle public {\\n        magicFlagsUsed[_magicFlag] = true;\\n    }\\n\\n    function changePaymentToken(address _newStablecoin) public onlyPuzzleOwner {\\n        require(validAssets[_newStablecoin], \\\"no sneaky assets\\\");\\n        paymentToken = ERC20(_newStablecoin);\\n    }\\n\\n    function rescueERC20(address _token) public {\\n        ERC20(_token).transfer(treasury, ERC20(_token).balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPuzzle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPuzzle {\\n    /// @notice Returns the puzzle's name.\\n    /// @return The puzzle's name.\\n    function name() external pure returns (string memory);\\n\\n    /// @notice Generates the puzzle's starting position based on a seed.\\n    /// @dev The seed is intended to be `msg.sender` of some wrapper function or\\n    /// call.\\n    /// @param _seed The seed to use to generate the puzzle.\\n    /// @return The puzzle's starting position.\\n    function generate(address _seed) external returns (uint256);\\n\\n    /// @notice Verifies that a solution is valid for the puzzle.\\n    /// @dev `_start` is intended to be an output from {IPuzzle-generate}.\\n    /// @param _start The puzzle's starting position.\\n    /// @param _solution The solution to the puzzle.\\n    /// @return Whether the solution is valid.\\n    function verify(uint256 _start, uint256 _solution) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ERC721 } from \\\"@solmate/tokens/ERC721.sol\\\";\\n\\nabstract contract IERC721 is ERC721 {\\n    function initialize(address _puzzle) external virtual;\\n    function safeMint(address to, uint256 tokenId) external virtual;\\n    function totalSupply() external view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId2\",\"type\":\"uint256\"}],\"name\":\"OwnsBoth\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_incrementBy\",\"type\":\"uint256\"}],\"name\":\"_incrementNFTPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_seed\",\"type\":\"address\"}],\"name\":\"generate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftOutlet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startingNftPrice\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftOutlet\",\"outputs\":[{\"internalType\":\"contract NFTOutlet\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_solution\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BillyTheBull", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}