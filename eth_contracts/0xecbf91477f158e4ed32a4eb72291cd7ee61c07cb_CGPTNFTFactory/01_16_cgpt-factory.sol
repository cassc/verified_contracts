// SPDX-License-Identifier: UNLICENSED
/*
Generated by ChainGPT AI NFT app
www.ChainGPT.org

Disclaimer: This smart contract collection is independently created and not owned 
or associated with ChainGPT. It is important to note that the content of this 
collection has been solely generated by the AI tools provided through the ChainGPT 
platform. ChainGPT does not endorse or assume any responsibility for the accuracy,
reliability, or legality of the contents within this collection. Users are advised 
to exercise caution and conduct their own due diligence before engaging with this 
smart contract collection. By using this smart contract, you acknowledge and agree 
that ChainGPT is not liable for any damages or losses incurred as a result of your 
interactions with this collection.
*/

pragma solidity ^0.8.0;

import "./cgpt-nft.sol";
import "./dependencies/ReentrancyGuard.sol";
import "./dependencies/Ownable.sol";

/**
 * @title ChainGPT NFT Factory Contract
 * @author Tammy
 * @notice NFT, ERC721, Factory
 * @custom:version 1.0.0
 * @custom:simple-description Factory contract that creates ChainGPT NFT Contract. 
 * @dev ERC721 NFT Factory
 *
 */

contract CGPTNFTFactory is ReentrancyGuard, Ownable {
    address[] public cNFTs;
    uint256 public length;

    address private constant treasury = 0xbAcf170AF90A36Bd221D6EA5884Da7c1714210c1;
    uint256 private constant MINT_FEE = 0.00005 ether;

    /**
     * @dev An external method for users to create ChainGPT NFT contract with options.
     * 
     * @param _name NFT Name
     * @param _symbol NFT Symbol
     * @param _uri Token URI used for metadata
     * @param maxSupply Maximum # of NFTs
     * @param tokenIDs The array of the NFTs to mint
     * @param _isMintable Further NFT mintable value
     */
    function create(
        string memory _name,
        string memory _symbol,
        string memory _uri,
        uint256 maxSupply,
        uint256[] memory tokenIDs,
        bool _isMintable
    ) external payable nonReentrant returns(address) {
        uint256 fee = MINT_FEE * tokenIDs.length;
        require(msg.value >= fee, "Insufficient payment");
        uint256 refundAmount = msg.value - fee;

        CGPTNFT cgptnft = new CGPTNFT(
            _name,
            _symbol,
            _uri,
            maxSupply,
            tokenIDs,
            _isMintable,
            msg.sender
        );

        (bool sent, ) = treasury.call{value: fee}("");
        require(sent, "Failed to send Ether to treasury address");

        // Refund remaining amount to user
        if (refundAmount > 0) {
            payable(msg.sender).transfer(refundAmount);
        }

        cNFTs.push(address(cgptnft));
        length += 1;

        return address(cgptnft);
    }

    // This function returns an array of ChainGPT NFT addresses
    function getCGPTNFTs() public view returns (address[] memory) {
        return cNFTs;
    }
}