{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/src/RiscZeroVerifierEmergencyStop.sol\": {\r\n      \"content\": \"// Copyright 2024 RISC Zero, Inc.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.9;\\n\\nimport {Ownable, Ownable2Step} from \\\"openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Pausable} from \\\"openzeppelin/contracts/utils/Pausable.sol\\\";\\n\\nimport {IRiscZeroVerifier, Receipt} from \\\"./IRiscZeroVerifier.sol\\\";\\n\\n/// @notice Wrapper for an IRiscZeroVerifier contract, providing emergency stop function.\\ncontract RiscZeroVerifierEmergencyStop is IRiscZeroVerifier, Ownable2Step, Pausable {\\n    IRiscZeroVerifier public immutable verifier;\\n\\n    /// @notice Error raised when calling estop with a receipt that cannot be verified as proof\\n    /// of an exploit on the verifier contract.\\n    error InvalidProofOfExploit();\\n\\n    constructor(IRiscZeroVerifier _verifier, address guardian) Ownable(guardian) {\\n        verifier = _verifier;\\n    }\\n\\n    /// @notice Initiate an emergency stop of the verifier contract.\\n    ///         Can only be used by the guardian address assigned as owner of this contract.\\n    ///\\n    ///         When stopped, all calls to the verify and verifyIntegrity functions will revert.\\n    ///         Once stopped, this contract can never be restarted.\\n    function estop() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Initiate an emergency stop of the verifier contract, via the \\\"circuit breaker\\\".\\n    ///         This method can be called by anyone who can produce a verifying proof for a receipt\\n    ///         claim digest of all zeroes. The existence of such a proof demonstrates a critical\\n    ///         vulnerability in the proof system.\\n    ///\\n    ///         When stopped, all calls to the verify and verifyIntegrity functions will revert.\\n    ///         Once stopped, this contract can never be restarted.\\n    function estop(Receipt calldata receipt) external {\\n        if (receipt.claimDigest != bytes32(0)) {\\n            revert InvalidProofOfExploit();\\n        }\\n        // Check that the proof of exploit receipt really does verify.\\n        verifyIntegrity(receipt);\\n        _pause();\\n    }\\n\\n    /// @inheritdoc IRiscZeroVerifier\\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view whenNotPaused {\\n        // Forward the call on to the wrapped contract.\\n        verifier.verify(seal, imageId, journalDigest);\\n    }\\n\\n    /// @inheritdoc IRiscZeroVerifier\\n    function verifyIntegrity(Receipt calldata receipt) public view whenNotPaused {\\n        // Forward the call on to the wrapped contract.\\n        verifier.verifyIntegrity(receipt);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/src/IRiscZeroVerifier.sol\": {\r\n      \"content\": \"// Copyright 2024 RISC Zero, Inc.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.9;\\n\\nimport {reverseByteOrderUint32} from \\\"./Util.sol\\\";\\n\\n/// @notice A receipt attesting to the execution of a guest program.\\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\\n/// image ID identifies the program that was executed, and the journal is the public data written\\n/// by the program. Note that this struct only contains the claim digest, as can be obtained with\\n/// the `digest()` function on `ReceiptClaimLib`.\\nstruct Receipt {\\n    bytes seal;\\n    bytes32 claimDigest;\\n}\\n\\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\\n/// @dev Also includes important information such as the exit code and the starting and ending system\\n/// state (i.e. the state of memory). `ReceiptClaim` is a \\\"Merkle-ized struct\\\" supporting\\n/// partial openings of the underlying fields from a hash commitment to the full structure.\\nstruct ReceiptClaim {\\n    /// @notice Digest of the SystemState just before execution has begun.\\n    bytes32 preStateDigest;\\n    /// @notice Digest of the SystemState just after execution has completed.\\n    bytes32 postStateDigest;\\n    /// @notice The exit code for the execution.\\n    ExitCode exitCode;\\n    /// @notice A digest of the input to the guest.\\n    /// @dev This field is currently unused and must be set to the zero digest.\\n    bytes32 input;\\n    /// @notice Digest of the Output of the guest, including the journal\\n    /// and assumptions set during execution.\\n    bytes32 output;\\n}\\n\\nlibrary ReceiptClaimLib {\\n    using OutputLib for Output;\\n    using SystemStateLib for SystemState;\\n\\n    bytes32 constant TAG_DIGEST = sha256(\\\"risc0.ReceiptClaim\\\");\\n\\n    // Define a constant to ensure hashing is done at compile time. Can't use the\\n    // SystemStateLib.digest method here because the Solidity compiler complains.\\n    bytes32 private constant SYSTEM_STATE_ZERO_DIGEST = sha256(\\n        abi.encodePacked(\\n            SystemStateLib.TAG_DIGEST,\\n            // down\\n            bytes32(0),\\n            // data\\n            uint32(0),\\n            // down.length\\n            uint16(1) << 8\\n        )\\n    );\\n\\n    /// @notice Construct a ReceiptClaim from the given imageId and journalDigest.\\n    ///         Returned ReceiptClaim will represent a successful execution of the zkVM, running\\n    ///         the program committed by imageId and resulting in the journal specified by\\n    ///         journalDigest.\\n    /// @param imageId The identifier for the guest program.\\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\\n    /// @dev Input hash and postStateDigest are set to all-zeros (i.e. no committed input, or\\n    ///      final memory state), the exit code is (Halted, 0), and there are no assumptions\\n    ///      (i.e. the receipt is unconditional).\\n    function ok(bytes32 imageId, bytes32 journalDigest) internal pure returns (ReceiptClaim memory) {\\n        return ReceiptClaim(\\n            imageId,\\n            SYSTEM_STATE_ZERO_DIGEST,\\n            ExitCode(SystemExitCode.Halted, 0),\\n            bytes32(0),\\n            Output(journalDigest, bytes32(0)).digest()\\n        );\\n    }\\n\\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\\n        return sha256(\\n            abi.encodePacked(\\n                TAG_DIGEST,\\n                // down\\n                claim.input,\\n                claim.preStateDigest,\\n                claim.postStateDigest,\\n                claim.output,\\n                // data\\n                uint32(claim.exitCode.system) << 24,\\n                uint32(claim.exitCode.user) << 24,\\n                // down.length\\n                uint16(4) << 8\\n            )\\n        );\\n    }\\n}\\n\\n/// @notice Commitment to the memory state and program counter (pc) of the zkVM.\\n/// @dev The \\\"pre\\\" and \\\"post\\\" fields of the ReceiptClaim are digests of the system state at the\\n///      start are stop of execution. Programs are loaded into the zkVM by creating a memory image\\n///      of the loaded program, and creating a system state for initializing the zkVM. This is\\n///      known as the \\\"image ID\\\".\\nstruct SystemState {\\n    /// @notice Program counter.\\n    uint32 pc;\\n    /// @notice Root hash of a merkle tree which confirms the integrity of the memory image.\\n    bytes32 merkle_root;\\n}\\n\\nlibrary SystemStateLib {\\n    bytes32 constant TAG_DIGEST = sha256(\\\"risc0.SystemState\\\");\\n\\n    function digest(SystemState memory state) internal pure returns (bytes32) {\\n        return sha256(\\n            abi.encodePacked(\\n                TAG_DIGEST,\\n                // down\\n                state.merkle_root,\\n                // data\\n                reverseByteOrderUint32(state.pc),\\n                // down.length\\n                uint16(1) << 8\\n            )\\n        );\\n    }\\n}\\n\\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\\n/// @dev Exit codes have a \\\"system\\\" part and a \\\"user\\\" part. Semantically, the system part is set to\\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\\n/// error).\\nstruct ExitCode {\\n    SystemExitCode system;\\n    uint8 user;\\n}\\n\\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\\n/// @dev\\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\\n/// guest program. A halted program cannot be resumed.\\n///\\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\\n/// guest program. A paused program can be resumed such that execution picks up where it left\\n/// of, with the same memory state.\\n///\\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\\n/// split has no output and no conclusions can be drawn about whether the program will eventually\\n/// halt. System split is used in continuations to split execution into individually provable segments.\\nenum SystemExitCode {\\n    Halted,\\n    Paused,\\n    SystemSplit\\n}\\n\\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\\nstruct Output {\\n    /// @notice Digest of the journal committed to by the guest execution.\\n    bytes32 journalDigest;\\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\\n    /// calls to `env::verify` and `env::verify_integrity`.\\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\\n    /// verifying a `Receipt` for every digest in the assumptions list.\\n    bytes32 assumptionsDigest;\\n}\\n\\nlibrary OutputLib {\\n    bytes32 constant TAG_DIGEST = sha256(\\\"risc0.Output\\\");\\n\\n    function digest(Output memory output) internal pure returns (bytes32) {\\n        return sha256(\\n            abi.encodePacked(\\n                TAG_DIGEST,\\n                // down\\n                output.journalDigest,\\n                output.assumptionsDigest,\\n                // down.length\\n                uint16(2) << 8\\n            )\\n        );\\n    }\\n}\\n\\n/// @notice Error raised when cryptographic verification of the zero-knowledge proof fails.\\nerror VerificationFailed();\\n\\n/// @notice Verifier interface for RISC Zero receipts of execution.\\ninterface IRiscZeroVerifier {\\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\\n    ///     given image ID and journal digest. Reverts on failure.\\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\\n    /// receipt is unconditional).\\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\\n    /// @param imageId The identifier for the guest program.\\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view;\\n\\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\\n    /// valid a cryptographic proof of the execution with the given `claim`. Reverts on failure.\\n    /// @param receipt The receipt to be verified.\\n    function verifyIntegrity(Receipt calldata receipt) external view;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/src/Util.sol\": {\r\n      \"content\": \"// Copyright 2024 RISC Zero, Inc.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.9;\\n\\n/// @notice reverse the byte order of the uint256 value.\\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\\n/// ensure that the encoded value will be little-endian.\\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\\n    v = input;\\n\\n    // swap bytes\\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n    // swap 2-byte long pairs\\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n    // swap 4-byte long pairs\\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n    // swap 8-byte long pairs\\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n    // swap 16-byte long pairs\\n    v = (v >> 128) | (v << 128);\\n}\\n\\n/// @notice reverse the byte order of the uint32 value.\\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\\n/// ensure that the encoded value will be little-endian.\\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\\n    v = input;\\n\\n    // swap bytes\\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\\n\\n    // swap 2-byte long pairs\\n    v = (v >> 16) | (v << 16);\\n}\\n\\n/// @notice reverse the byte order of the uint16 value.\\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\\n/// ensure that the encoded value will be little-endian.\\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\\nfunction reverseByteOrderUint16(uint16 input) pure returns (uint16 v) {\\n    v = input;\\n\\n    // swap bytes\\n    v = (v >> 8) | ((v & 0x00FF) << 8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IRiscZeroVerifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProofOfExploit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"claimDigest\",\"type\":\"bytes32\"}],\"internalType\":\"struct Receipt\",\"name\":\"receipt\",\"type\":\"tuple\"}],\"name\":\"estop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IRiscZeroVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"imageId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"journalDigest\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"claimDigest\",\"type\":\"bytes32\"}],\"internalType\":\"struct Receipt\",\"name\":\"receipt\",\"type\":\"tuple\"}],\"name\":\"verifyIntegrity\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RiscZeroVerifierEmergencyStop", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f70abab028eb6f4100a24b203e113d94e87de93c000000000000000000000000f616a4f81857cfee54a4a049ec187172574bd412", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}