{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BidsBot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nstruct BetTypeWin {\\n    uint betTypeId;\\n    bool choice;\\n}\\n\\nstruct Bet {\\n    address participant;\\n    uint256 amount;\\n    uint betTypeId;\\n    uint blockNum;\\n    bool choice;\\n}\\n\\ncontract BetBox{\\n    BettingContract[] public bets;\\n    address payable private owner;\\n\\n    constructor() public {\\n        owner = payable(msg.sender);\\n    }\\n\\n    modifier onlyOwner(){\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function createBet (\\n        string memory _title,\\n        string memory _description,\\n        string[] calldata types\\n    ) public onlyOwner {\\n        BettingContract newBet = new BettingContract(payable(msg.sender), payable(msg.sender), _title, _description, types);\\n        bets.push(newBet);\\n    }\\n\\n    function createBetForUsers (\\n        string memory _title,\\n        string memory _description,\\n        string[] calldata types\\n    ) public {\\n        BettingContract newBet = new BettingContract(owner, payable(msg.sender), _title, _description, types);\\n        bets.push(newBet);\\n    }\\n\\n    function returnAllBets() public view returns(BettingContract[] memory){\\n        return bets;\\n    }\\n}\\n\\ncontract BettingContract {\\n    using SafeMath for uint256;\\n\\n    address public owner;\\n    address public creator;\\n    string public title;\\n    string public description;\\n\\n    uint numerator = 990000000000;\\n    uint denominator = 1000000000000;\\n\\n    enum State { Default, Running, Stopped, Finalized }\\n    State public betState = State.Default;\\n\\n    Bet[] public bets;\\n    string [] public betTypes;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier bettingActive() {\\n        require(betState == State.Running);\\n        _;\\n    }\\n\\n    constructor(\\n        address payable _owner,\\n        address payable _creator,\\n        string memory _title,\\n        string memory _description,\\n        string[] memory types\\n    ) {\\n        owner = _owner;\\n        creator = _creator;\\n        title = _title;\\n        description = _description;\\n\\n        for (uint256 i = 0; i < types.length; i++) {\\n            betTypes.push(types[i]);\\n        }\\n\\n        if (_owner == _creator) {\\n            betState = State.Running;\\n        }\\n    }\\n\\n    function getBets() external view returns (Bet[] memory) {\\n        return bets;\\n    }\\n\\n    function getBetTypes() external view returns (string[] memory) {\\n        return betTypes;\\n    }\\n\\n    function placeBet(uint betTypeId, bool choice) external payable bettingActive {\\n        require(msg.value > 0);\\n        require(choice == true || choice == false);\\n        require(betTypeId < betTypes.length);\\n\\n        Bet memory newBet = Bet({\\n            participant: msg.sender,\\n            amount: msg.value,\\n            choice: choice,\\n            betTypeId: betTypeId,\\n            blockNum: block.number\\n        });\\n\\n        bets.push(newBet);\\n    }\\n\\n    function stopBet() external onlyOwner {\\n        require(betState == State.Running, \\\"Betting has already been stopped\\\");\\n        betState = State.Stopped;\\n    }\\n\\n    function startBet() external onlyOwner {\\n        require(betState == State.Default);\\n        betState = State.Running;\\n    }\\n\\n    function distributeWinningPool(BetTypeWin[] calldata betsWin) external onlyOwner {\\n        require(betState == State.Stopped);\\n\\n        for (uint256 b = 0; b < betsWin.length; b++) {\\n            uint256 totalPool = 0;\\n            uint256 winningPool = 0;\\n            for (uint256 i = 0; i < bets.length; i++) {\\n                if (bets[i].betTypeId == betsWin[b].betTypeId) {\\n                    totalPool += bets[i].amount;\\n                    if (bets[i].choice == betsWin[b].choice) {\\n                        winningPool += bets[i].amount;\\n                    }\\n                }\\n            }\\n\\n            if (winningPool > 0) {\\n                for (uint256 i = 0; i < bets.length; i++) {\\n                    if (bets[i].amount > 0 && bets[i].choice == betsWin[b].choice && bets[i].betTypeId == betsWin[b].betTypeId) {\\n                        uint256 participantShare = bets[i].amount\\n                            .mul(numerator)\\n                            .mul(totalPool)\\n                            .div(winningPool)\\n                            .div(denominator);\\n\\n                        (bool success, ) = payable(bets[i].participant).call{value: participantShare}(\\\"\\\");\\n                        require(success, \\\"Transfer failed\\\");\\n                    }\\n                }\\n            }\\n        }\\n        if (owner != creator) {\\n            payable(creator).call{value:  address (this).balance.mul(400).div(1000) }(\\\"\\\");\\n        }\\n        payable(owner).transfer(address (this).balance);\\n        betState = State.Finalized;\\n    }\\n\\n    function refundBets(BetTypeWin[] calldata betsWin) external onlyOwner {\\n        for (uint256 b = 0; b < betsWin.length; b++) {\\n            for (uint256 i = 0; i < bets.length; i++) {\\n                if (bets[i].betTypeId == betsWin[b].betTypeId) {\\n                    (bool success, ) = payable(bets[i].participant).call{value: bets[i].amount}(\\\"\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function refundLateBets(uint blockNum) external onlyOwner {\\n        for (uint256 i = 0; i < bets.length; i++) {\\n            if (bets[i].blockNum > blockNum) {\\n                (bool success, ) = payable(bets[i].participant).call{value: bets[i].amount}(\\\"\\\");\\n                if (success) {\\n                    bets[i].amount = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    function emergencyReturn(address payable owner) public onlyOwner {\\n        owner.transfer(address(this).balance);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"contract BettingContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"types\",\"type\":\"string[]\"}],\"name\":\"createBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"types\",\"type\":\"string[]\"}],\"name\":\"createBetForUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnAllBets\",\"outputs\":[{\"internalType\":\"contract BettingContract[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BetBox", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}