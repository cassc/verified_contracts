{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/eip-4337/IAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n\\t/**\\n\\t * validate aggregated signature.\\n\\t * revert if the aggregated signature does not match the given list of operations.\\n\\t */\\n\\tfunction validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\\n\\n\\t/**\\n\\t * validate signature of a single userOp\\n\\t * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n\\t * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n\\t * @param userOp the userOperation received from the user.\\n\\t * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n\\t *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n\\t */\\n\\tfunction validateUserOpSignature(UserOperation calldata userOp) external view returns (bytes memory sigForUserOp);\\n\\n\\t/**\\n\\t * aggregate multiple signatures into a single value.\\n\\t * This method is called off-chain to calculate the signature to pass with handleOps()\\n\\t * bundler MAY use optimized custom code perform this aggregation\\n\\t * @param userOps array of UserOperations to collect the signatures from.\\n\\t * @return aggregatedSignature the aggregated signature\\n\\t */\\n\\tfunction aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/eip-4337/IEntryPoint.sol\": {\r\n      \"content\": \"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n\\t/***\\n\\t * An event emitted after each successful request\\n\\t * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n\\t * @param sender - the account that generates this request.\\n\\t * @param paymaster - if non-null, the paymaster that pays for this request.\\n\\t * @param nonce - the nonce value from the request.\\n\\t * @param success - true if the sender transaction succeeded, false if reverted.\\n\\t * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n\\t * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n\\t */\\n\\tevent UserOperationEvent(\\n\\t\\tbytes32 indexed userOpHash,\\n\\t\\taddress indexed sender,\\n\\t\\taddress indexed paymaster,\\n\\t\\tuint256 nonce,\\n\\t\\tbool success,\\n\\t\\tuint256 actualGasCost,\\n\\t\\tuint256 actualGasUsed\\n\\t);\\n\\n\\t/**\\n\\t * account \\\"sender\\\" was deployed.\\n\\t * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n\\t * @param sender the account that is deployed\\n\\t * @param factory the factory used to deploy this account (in the initCode)\\n\\t * @param paymaster the paymaster used by this UserOp\\n\\t */\\n\\tevent AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\\n\\n\\t/**\\n\\t * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n\\t * @param userOpHash the request unique identifier.\\n\\t * @param sender the sender of this request\\n\\t * @param nonce the nonce used in the request\\n\\t * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n\\t */\\n\\tevent UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n\\t/**\\n\\t * an event emitted by handleOps(), before starting the execution loop.\\n\\t * any event emitted before this event, is part of the validation.\\n\\t */\\n\\tevent BeforeExecution();\\n\\n\\t/**\\n\\t * signature aggregator used by the following UserOperationEvents within this bundle.\\n\\t */\\n\\tevent SignatureAggregatorChanged(address indexed aggregator);\\n\\n\\t/**\\n\\t * a custom revert error of handleOps, to identify the offending op.\\n\\t *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n\\t *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n\\t *  @param reason - revert reason\\n\\t *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n\\t *      so a failure can be attributed to the correct entity.\\n\\t *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n\\t *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n\\t */\\n\\terror FailedOp(uint256 opIndex, string reason);\\n\\n\\t/**\\n\\t * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n\\t */\\n\\terror SignatureValidationFailed(address aggregator);\\n\\n\\t/**\\n\\t * Successful result from simulateValidation.\\n\\t * @param returnInfo gas and time-range returned values\\n\\t * @param senderInfo stake information about the sender\\n\\t * @param factoryInfo stake information about the factory (if any)\\n\\t * @param paymasterInfo stake information about the paymaster (if any)\\n\\t */\\n\\terror ValidationResult(ReturnInfo returnInfo, StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\\n\\n\\t/**\\n\\t * Successful result from simulateValidation, if the account returns a signature aggregator\\n\\t * @param returnInfo gas and time-range returned values\\n\\t * @param senderInfo stake information about the sender\\n\\t * @param factoryInfo stake information about the factory (if any)\\n\\t * @param paymasterInfo stake information about the paymaster (if any)\\n\\t * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n\\t *      bundler MUST use it to verify the signature, or reject the UserOperation\\n\\t */\\n\\terror ValidationResultWithAggregation(\\n\\t\\tReturnInfo returnInfo,\\n\\t\\tStakeInfo senderInfo,\\n\\t\\tStakeInfo factoryInfo,\\n\\t\\tStakeInfo paymasterInfo,\\n\\t\\tAggregatorStakeInfo aggregatorInfo\\n\\t);\\n\\n\\t/**\\n\\t * return value of getSenderAddress\\n\\t */\\n\\terror SenderAddressResult(address sender);\\n\\n\\t/**\\n\\t * return value of simulateHandleOp\\n\\t */\\n\\terror ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\\n\\n\\t//UserOps handled, per aggregator\\n\\tstruct UserOpsPerAggregator {\\n\\t\\tUserOperation[] userOps;\\n\\t\\t// aggregator address\\n\\t\\tIAggregator aggregator;\\n\\t\\t// aggregated signature\\n\\t\\tbytes signature;\\n\\t}\\n\\n\\t/**\\n\\t * Execute a batch of UserOperation.\\n\\t * no signature aggregator is used.\\n\\t * if any account requires an aggregator (that is, it returned an aggregator when\\n\\t * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n\\t * @param ops the operations to execute\\n\\t * @param beneficiary the address to receive the fees\\n\\t */\\n\\tfunction handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n\\t/**\\n\\t * Execute a batch of UserOperation with Aggregators\\n\\t * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n\\t * @param beneficiary the address to receive the fees\\n\\t */\\n\\tfunction handleAggregatedOps(UserOpsPerAggregator[] calldata opsPerAggregator, address payable beneficiary) external;\\n\\n\\t/**\\n\\t * generate a request Id - unique identifier for this request.\\n\\t * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n\\t */\\n\\tfunction getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n\\t/**\\n\\t * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n\\t * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n\\t * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n\\t * @param userOp the user operation to validate.\\n\\t */\\n\\tfunction simulateValidation(UserOperation calldata userOp) external;\\n\\n\\t/**\\n\\t * gas and return values during simulation\\n\\t * @param preOpGas the gas used for validation (including preValidationGas)\\n\\t * @param prefund the required prefund for this operation\\n\\t * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n\\t * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n\\t * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n\\t * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n\\t */\\n\\tstruct ReturnInfo {\\n\\t\\tuint256 preOpGas;\\n\\t\\tuint256 prefund;\\n\\t\\tbool sigFailed;\\n\\t\\tuint48 validAfter;\\n\\t\\tuint48 validUntil;\\n\\t\\tbytes paymasterContext;\\n\\t}\\n\\n\\t/**\\n\\t * returned aggregated signature info.\\n\\t * the aggregator returned by the account, and its current stake.\\n\\t */\\n\\tstruct AggregatorStakeInfo {\\n\\t\\taddress aggregator;\\n\\t\\tStakeInfo stakeInfo;\\n\\t}\\n\\n\\t/**\\n\\t * Get counterfactual sender address.\\n\\t *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n\\t * this method always revert, and returns the address in SenderAddressResult error\\n\\t * @param initCode the constructor code to be passed into the UserOperation.\\n\\t */\\n\\tfunction getSenderAddress(bytes memory initCode) external;\\n\\n\\t/**\\n\\t * simulate full execution of a UserOperation (including both validation and target execution)\\n\\t * this method will always revert with \\\"ExecutionResult\\\".\\n\\t * it performs full validation of the UserOperation, but ignores signature error.\\n\\t * an optional target address is called after the userop succeeds, and its value is returned\\n\\t * (before the entire call is reverted)\\n\\t * Note that in order to collect the the success/failure of the target call, it must be executed\\n\\t * with trace enabled to track the emitted events.\\n\\t * @param op the UserOperation to simulate\\n\\t * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n\\t *        are set to the return from that call.\\n\\t * @param targetCallData callData to pass to target address\\n\\t */\\n\\tfunction simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/eip-4337/INonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ninterface INonceManager {\\n\\t/**\\n\\t * Return the next nonce for this sender.\\n\\t * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n\\t * But UserOp with different keys can come with arbitrary order.\\n\\t *\\n\\t * @param sender the account address\\n\\t * @param key the high 192 bit of the nonce\\n\\t * @return nonce a full nonce to pass for next UserOp with this sender.\\n\\t */\\n\\tfunction getNonce(address sender, uint192 key) external view returns (uint256 nonce);\\n\\n\\t/**\\n\\t * Manually increment the nonce of the sender.\\n\\t * This method is exposed just for completeness..\\n\\t * Account does NOT need to call it, neither during validation, nor elsewhere,\\n\\t * as the EntryPoint will update the nonce regardless.\\n\\t * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n\\t * UserOperations will not pay extra for the first transaction with a given key.\\n\\t */\\n\\tfunction incrementNonce(uint192 key) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/eip-4337/IPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n\\tenum PostOpMode {\\n\\t\\topSucceeded, // user op succeeded\\n\\t\\topReverted, // user op reverted. still has to pay for gas.\\n\\t\\tpostOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\\n\\t}\\n\\n\\t/**\\n\\t * payment validation: check if paymaster agrees to pay.\\n\\t * Must verify sender is the entryPoint.\\n\\t * Revert to reject this request.\\n\\t * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\\n\\t * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n\\t * @param userOp the user operation\\n\\t * @param userOpHash hash of the user's request data.\\n\\t * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n\\t * @return context value to send to a postOp\\n\\t *      zero length to signify postOp is not required.\\n\\t * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\\n\\t *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n\\t *         otherwise, an address of an \\\"authorizer\\\" contract.\\n\\t *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n\\t *      <6-byte> validAfter - first timestamp this operation is valid\\n\\t *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n\\t */\\n\\tfunction validatePaymasterUserOp(\\n\\t\\tUserOperation calldata userOp,\\n\\t\\tbytes32 userOpHash,\\n\\t\\tuint256 maxCost\\n\\t) external returns (bytes memory context, uint256 validationData);\\n\\n\\t/**\\n\\t * post-operation handler.\\n\\t * Must verify sender is the entryPoint\\n\\t * @param mode enum with the following options:\\n\\t *      opSucceeded - user operation succeeded.\\n\\t *      opReverted  - user op reverted. still has to pay for gas.\\n\\t *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n\\t *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n\\t * @param context - the context value returned by validatePaymasterUserOp\\n\\t * @param actualGasCost - actual gas used so far (without this postOp call).\\n\\t */\\n\\tfunction postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/eip-4337/IStakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.17;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n\\tevent Deposited(address indexed account, uint256 totalDeposit);\\n\\n\\tevent Withdrawn(address indexed account, address withdrawAddress, uint256 amount);\\n\\n\\t/// Emitted when stake or unstake delay are modified\\n\\tevent StakeLocked(address indexed account, uint256 totalStaked, uint256 unstakeDelaySec);\\n\\n\\t/// Emitted once a stake is scheduled for withdrawal\\n\\tevent StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n\\tevent StakeWithdrawn(address indexed account, address withdrawAddress, uint256 amount);\\n\\n\\t/**\\n\\t * @param deposit the entity's deposit\\n\\t * @param staked true if this entity is staked.\\n\\t * @param stake actual amount of ether staked for this entity.\\n\\t * @param unstakeDelaySec minimum delay to withdraw the stake.\\n\\t * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n\\t * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n\\t *    and the rest fit into a 2nd cell.\\n\\t *    112 bit allows for 10^15 eth\\n\\t *    48 bit for full timestamp\\n\\t *    32 bit allows 150 years for unstake delay\\n\\t */\\n\\tstruct DepositInfo {\\n\\t\\tuint112 deposit;\\n\\t\\tbool staked;\\n\\t\\tuint112 stake;\\n\\t\\tuint32 unstakeDelaySec;\\n\\t\\tuint48 withdrawTime;\\n\\t}\\n\\n\\t//API struct used by getStakeInfo and simulateValidation\\n\\tstruct StakeInfo {\\n\\t\\tuint256 stake;\\n\\t\\tuint256 unstakeDelaySec;\\n\\t}\\n\\n\\t/// @return info - full deposit information of given account\\n\\tfunction getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n\\t/// @return the deposit (for gas payment) of the account\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * add to the deposit of the given account\\n\\t */\\n\\tfunction depositTo(address account) external payable;\\n\\n\\t/**\\n\\t * add to the account's stake - amount and delay\\n\\t * any pending unstake is first cancelled.\\n\\t * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n\\t */\\n\\tfunction addStake(uint32 _unstakeDelaySec) external payable;\\n\\n\\t/**\\n\\t * attempt to unlock the stake.\\n\\t * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n\\t */\\n\\tfunction unlockStake() external;\\n\\n\\t/**\\n\\t * withdraw from the (unlocked) stake.\\n\\t * must first call unlockStake and wait for the unstakeDelay to pass\\n\\t * @param withdrawAddress the address to send withdrawn value.\\n\\t */\\n\\tfunction withdrawStake(address payable withdrawAddress) external;\\n\\n\\t/**\\n\\t * withdraw from the deposit.\\n\\t * @param withdrawAddress the address to send withdrawn value.\\n\\t * @param withdrawAmount the amount to withdraw.\\n\\t */\\n\\tfunction withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/eip-4337/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor/\\n * @param callData the method call to execute on this account.\\n * @param callGasLimit the gas limit passed to the callData method call.\\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter.\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n\\taddress sender;\\n\\tuint256 nonce;\\n\\tbytes initCode;\\n\\tbytes callData;\\n\\tuint256 callGasLimit;\\n\\tuint256 verificationGasLimit;\\n\\tuint256 preVerificationGas;\\n\\tuint256 maxFeePerGas;\\n\\tuint256 maxPriorityFeePerGas;\\n\\tbytes paymasterAndData;\\n\\tbytes signature;\\n}\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\tfunction getSender(UserOperation calldata userOp) internal pure returns (address) {\\n\\t\\taddress data;\\n\\t\\t//read sender from userOp, which is first userOp member (saves 800 gas...)\\n\\t\\tassembly {\\n\\t\\t\\tdata := calldataload(userOp)\\n\\t\\t}\\n\\t\\treturn address(uint160(data));\\n\\t}\\n\\n\\t//relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n\\t// pay above what he signed for.\\n\\tfunction gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 maxFeePerGas = userOp.maxFeePerGas;\\n\\t\\t\\tuint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n\\t\\t\\tif (maxFeePerGas == maxPriorityFeePerGas) {\\n\\t\\t\\t\\t//legacy mode (for networks that don't support basefee opcode)\\n\\t\\t\\t\\treturn maxFeePerGas;\\n\\t\\t\\t}\\n\\t\\t\\treturn min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n\\t\\t//lighter signature scheme. must match UserOp.ts#packUserOp\\n\\t\\tbytes calldata sig = userOp.signature;\\n\\t\\t// copy directly the userOp from calldata up to (but not including) the signature.\\n\\t\\t// this encoding depends on the ABI encoding of calldata, but is much lighter to copy\\n\\t\\t// than referencing each field separately.\\n\\t\\tassembly {\\n\\t\\t\\tlet ofs := userOp\\n\\t\\t\\tlet len := sub(sub(sig.offset, ofs), 32)\\n\\t\\t\\tret := mload(0x40)\\n\\t\\t\\tmstore(0x40, add(ret, add(len, 32)))\\n\\t\\t\\tmstore(ret, len)\\n\\t\\t\\tcalldatacopy(add(ret, 32), ofs, len)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(pack(userOp));\\n\\t}\\n\\n\\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a < b ? a : b;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/paymaster/BasePaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.17;\\n\\n/* solhint-disable reason-string */\\n\\n\\nimport \\\"../utils/Ownable2StepNoRenounce.sol\\\";\\nimport \\\"../interfaces/eip-4337/IPaymaster.sol\\\";\\nimport \\\"../interfaces/eip-4337/IEntryPoint.sol\\\";\\n\\n/**\\n * @title BasePaymaster\\n * @author fun.xyz eth-infinitism\\n * @notice Helper class for creating a paymaster.\\n * provides helper methods for staking.\\n * validates that the postOp is called only by the entryPoint\\n */\\nabstract contract BasePaymaster is IPaymaster, Ownable2StepNoRenounce {\\n\\tIEntryPoint public immutable entryPoint;\\n\\n\\tconstructor(IEntryPoint _entryPoint) {\\n\\t\\trequire(address(_entryPoint) != address(0), \\\"FW300\\\");\\n\\t\\tentryPoint = _entryPoint;\\n\\t\\temit PaymasterCreated(_entryPoint);\\n\\t}\\n\\n\\t/**\\n\\t * payment validation: check if paymaster agrees to pay.\\n\\t * Must verify sender is the entryPoint.\\n\\t * Revert to reject this request.\\n\\t * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\\n\\t * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n\\t * @param userOp the user operation\\n\\t * @param userOpHash hash of the user's request data.\\n\\t * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n\\t * @return context value to send to a postOp\\n\\t *      zero length to signify postOp is not required.\\n\\t * @return sigTimeRange Note: we do not currently support validUntil and validAfter\\n\\t */\\n\\tfunction validatePaymasterUserOp(\\n\\t\\tUserOperation calldata userOp,\\n\\t\\tbytes32 userOpHash,\\n\\t\\tuint256 maxCost\\n\\t) external override returns (bytes memory context, uint256 sigTimeRange) {\\n\\t\\t_requireFromEntryPoint();\\n\\t\\treturn _validatePaymasterUserOp(userOp, userOpHash, maxCost);\\n\\t}\\n\\n\\t/**\\n\\t * payment validation: check if paymaster agrees to pay.\\n\\t * Must verify sender is the entryPoint.\\n\\t * Revert to reject this request.\\n\\t * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\\n\\t * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n\\t * @param userOp the user operation\\n\\t * @param userOpHash hash of the user's request data.\\n\\t * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n\\t * @return context value to send to a postOp\\n\\t *      zero length to signify postOp is not required.\\n\\t * @return sigTimeRange Note: we do not currently support validUntil and validAfter\\n\\t */\\n\\tfunction _validatePaymasterUserOp(\\n\\t\\tUserOperation calldata userOp,\\n\\t\\tbytes32 userOpHash,\\n\\t\\tuint256 maxCost\\n\\t) internal virtual returns (bytes memory context, uint256 sigTimeRange);\\n\\n\\t/**\\n\\t * post-operation handler.\\n\\t * Must verify sender is the entryPoint\\n\\t * @param mode enum with the following options:\\n\\t *      opSucceeded - user operation succeeded.\\n\\t *      opReverted  - user op reverted. still has to pay for gas.\\n\\t *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n\\t *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n\\t * @param context - the context value returned by validatePaymasterUserOp\\n\\t * @param actualGasCost - actual gas used so far (without this postOp call).\\n\\t */\\n\\tfunction postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external override {\\n\\t\\t_requireFromEntryPoint();\\n\\t\\t_postOp(mode, context, actualGasCost);\\n\\t}\\n\\n\\t/**\\n\\t * post-operation handler.\\n\\t * (verified to be called only through the entryPoint)\\n\\t * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\\n\\t * @param mode enum with the following options:\\n\\t *      opSucceeded - user operation succeeded.\\n\\t *      opReverted  - user op reverted. still has to pay for gas.\\n\\t *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n\\t *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n\\t * @param context - the context value returned by validatePaymasterUserOp\\n\\t * @param actualGasCost - actual gas used so far (without this postOp call).\\n\\t */\\n\\tfunction _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal virtual {\\n\\t\\t(mode, context, actualGasCost); // unused params\\n\\t\\t// subclass must override this method if validatePaymasterUserOp returns a context\\n\\t\\trevert(\\\"must override\\\");\\n\\t}\\n\\n\\t/**\\n\\t * add stake for this paymaster.\\n\\t * This method can also carry eth value to add to the current stake.\\n\\t * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\\n\\t */\\n\\tfunction addStakeToEntryPoint(uint32 unstakeDelaySec) external payable onlyOwner {\\n\\t\\tentryPoint.addStake{value: msg.value}(unstakeDelaySec);\\n\\t}\\n\\n\\t/**\\n\\t * unlock the stake, in order to withdraw it.\\n\\t * The paymaster can't serve requests once unlocked, until it calls addStake again\\n\\t */\\n\\tfunction unlockStakeFromEntryPoint() external onlyOwner {\\n\\t\\tentryPoint.unlockStake();\\n\\t}\\n\\n\\t/**\\n\\t * withdraw the entire paymaster's stake.\\n\\t * stake must be unlocked first (and then wait for the unstakeDelay to be over)\\n\\t * @param withdrawAddress the address to send withdrawn value.\\n\\t */\\n\\tfunction withdrawStakeFromEntryPoint(address payable withdrawAddress) external onlyOwner {\\n\\t\\trequire(withdrawAddress != address(0), \\\"FW351\\\");\\n\\t\\tentryPoint.withdrawStake(withdrawAddress);\\n\\t}\\n\\n\\t/// validate the call is made from a valid entrypoint\\n\\tfunction _requireFromEntryPoint() internal virtual {\\n\\t\\trequire(msg.sender == address(entryPoint), \\\"FW301\\\");\\n\\t}\\n\\n\\tevent PaymasterCreated(IEntryPoint entryPoint);\\n}\\n\"\r\n    },\r\n    \"contracts/paymaster/GaslessPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.17;\\n\\n/* solhint-disable reason-string */\\n\\nimport \\\"./BasePaymaster.sol\\\";\\nimport \\\"../utils/HashLib.sol\\\";\\n\\nenum ModeKeys {\\n\\tLISTMODE,\\n\\tBLACKLIST,\\n\\tWHITELIST\\n}\\n\\n/**\\n * @title Gasless paymaster Contract\\n * @author fun.xyz\\n * @notice A contract that extends the BasePaymaster contract. This allows sponsors to pay for the gas of their users.\\n */\\ncontract GaslessPaymaster is BasePaymaster {\\n\\tusing UserOperationLib for UserOperation;\\n\\n\\t//calculated cost of the postOp\\n\\tuint256 public constant COST_OF_POST = 35000;\\n\\n\\t/**\\n\\t * @dev This constant is used to define the version of this contract.\\n\\t */\\n\\tuint256 public constant VERSION = 1;\\n\\n\\tmapping(bytes32 => bool) private sponsorApprovals;\\n\\n\\t// Token and UnlockBlock\\n\\tmapping(address => uint256) private unlockBlock;\\n\\tmapping(address => uint256) private balances;\\n\\n\\tconstructor(IEntryPoint _entryPoint) BasePaymaster(_entryPoint) {}\\n\\n\\t/**\\n\\t * @notice batch call method\\n\\t * @dev Executes a batch of transactions.\\n\\t * @param data An array of transaction data to execute.\\n\\t */\\n\\tfunction batchActions(bytes[] calldata data) public payable {\\n\\t\\tuint256 value = 0;\\n\\t\\tunchecked {\\n\\t\\t\\tfor (uint256 i = 0; i < data.length; ++i) {\\n\\t\\t\\t\\tif (bytes4(data[i][:4]) == this.batchActions.selector) {\\n\\t\\t\\t\\t\\trevert(\\\"FW344\\\");\\n\\t\\t\\t\\t} else if (bytes4(data[i][:4]) == this.addDepositTo.selector) {\\n\\t\\t\\t\\t\\t(address sponsor, uint256 amount) = abi.decode(data[i][4:], (address, uint256));\\n\\t\\t\\t\\t\\tvalue += amount;\\n\\t\\t\\t\\t\\t_addDepositTo(sponsor, amount);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t(bool success, ) = address(this).delegatecall(data[i]);\\n\\t\\t\\t\\t\\trequire(success, \\\"FW302\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trequire(value == msg.value, \\\"FW303\\\");\\n\\t\\temit BatchActions(data);\\n\\t}\\n\\n\\t// Internal Access Control Key Getters\\n\\n\\tfunction _getListModeKey(address sponsor) internal pure returns (bytes32) {\\n\\t\\treturn HashLib.hash2(sponsor, uint8(ModeKeys.LISTMODE));\\n\\t}\\n\\n\\tfunction _getSpenderBlacklistKey(address sponsor, address spender) internal pure returns (bytes32) {\\n\\t\\treturn HashLib.hash3(sponsor, spender, uint8(ModeKeys.BLACKLIST));\\n\\t}\\n\\n\\tfunction _getSpenderWhitelistKey(address sponsor, address spender) internal pure returns (bytes32) {\\n\\t\\treturn HashLib.hash3(sponsor, spender, uint8(ModeKeys.WHITELIST));\\n\\t}\\n\\n\\t///////////////////////\\n\\t// START INTERNAL OPS//\\n\\t///////////////////////\\n\\n\\t/**\\n\\t * @dev Helper function for addDepositTo()\\n\\t */\\n\\tfunction _addDepositTo(address spender, uint256 amount) internal {\\n\\t\\tentryPoint.depositTo{value: amount}(address(this));\\n\\t\\tbalances[spender] += amount;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Helper function for withdrawDepositTo()\\n\\t */\\n\\tfunction _withdrawDepositTo(address sender, address payable target, uint256 amount) internal {\\n\\t\\tuint256 unlockBlockValue = unlockBlock[sender];\\n\\t\\trequire(block.number > unlockBlockValue && unlockBlockValue != 0, \\\"FW304\\\");\\n\\t\\trequire(balances[sender] >= amount, \\\"FW305\\\");\\n\\t\\tbalances[sender] -= amount;\\n\\t\\tentryPoint.withdrawTo(target, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Helper function to set the unlock block for a sponsor\\n\\t */\\n\\tfunction _setUnlockBlock(address sponsor, uint256 num) internal {\\n\\t\\tunlockBlock[sponsor] = num;\\n\\t}\\n\\n\\t// Basic access control Setters\\n\\n\\t/**\\n\\t * @dev helper function for setListMode()\\n\\t */\\n\\tfunction _setListMode(address sponsor, bool mode) internal {\\n\\t\\tsponsorApprovals[_getListModeKey(sponsor)] = mode;\\n\\t}\\n\\n\\t/**\\n\\t * @dev helper function for setSpenderBlacklistMode()\\n\\t */\\n\\tfunction _setSpenderBlacklistMode(address sponsor, address spender, bool mode) internal {\\n\\t\\tsponsorApprovals[_getSpenderBlacklistKey(sponsor, spender)] = mode;\\n\\t}\\n\\n\\t/**\\n\\t * @dev helper function for setSpenderWhitelistMode()\\n\\t */\\n\\tfunction _setSpenderWhitelistMode(address sponsor, address spender, bool mode) internal {\\n\\t\\tsponsorApprovals[_getSpenderWhitelistKey(sponsor, spender)] = mode;\\n\\t}\\n\\n\\t/////////////////////\\n\\t// END INTERNAL OPS//\\n\\t/////////////////////\\n\\tfunction _getSponsorApproval(address spender, address sponsor) internal view returns (bool) {\\n\\t\\tbool blackListMode = sponsorApprovals[_getListModeKey(sponsor)];\\n\\t\\tif (blackListMode) {\\n\\t\\t\\treturn !sponsorApprovals[_getSpenderBlacklistKey(sponsor, spender)];\\n\\t\\t}\\n\\t\\treturn sponsorApprovals[_getSpenderWhitelistKey(sponsor, spender)];\\n\\t}\\n\\n\\t// EIP4337 OPS\\n\\t/**\\n\\t * Verify that the user has permission to use this gasless paymaster\\n\\t * @param userOp ERC4337 UserOperation\\n\\t * @param opHash keccak256 hash of the userOp\\n\\t * @param maxCost The maximum gas cost for this userOp\\n\\t * @return context The context containing the sponsor, spender, gasPriceUserOp, and opHash\\n\\t * @return sigTimeRange A uint256 value indicating the result of the validation, always returns 0 in this implementation\\n\\t */\\n\\tfunction _validatePaymasterUserOp(\\n\\t\\tUserOperation calldata userOp,\\n\\t\\tbytes32 opHash,\\n\\t\\tuint256 maxCost\\n\\t) internal view override returns (bytes memory context, uint256 sigTimeRange) {\\n\\t\\trequire(userOp.paymasterAndData.length == 20 + 20, \\\"FW306\\\");\\n\\t\\t// verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\\n\\t\\trequire(userOp.verificationGasLimit > COST_OF_POST, \\\"FW307\\\");\\n\\n\\t\\taddress sponsor = address(bytes20(userOp.paymasterAndData[20:]));\\n\\t\\tuint256 sponsorUnlockBlock = unlockBlock[sponsor];\\n\\t\\trequire(sponsorUnlockBlock == 0 || sponsorUnlockBlock > block.number, \\\"FW308\\\");\\n\\n\\t\\taddress spender = userOp.getSender();\\n\\t\\trequire(_getSponsorApproval(spender, sponsor), \\\"FW309\\\");\\n\\t\\trequire(balances[sponsor] >= maxCost, \\\"FW310\\\");\\n\\n\\t\\tuint256 gasPriceUserOp = userOp.gasPrice();\\n\\t\\treturn (abi.encode(sponsor, spender, gasPriceUserOp, opHash), 0);\\n\\t}\\n\\n\\t/**\\n\\t * post-operation handler.\\n\\t * Must verify sender is the entryPoint\\n\\t * @param context - the context value returned by validatePaymasterUserOp\\n\\t * @param actualGasCost - actual gas used so far (without this postOp call).\\n\\t */\\n\\tfunction _postOp(PostOpMode, bytes calldata context, uint256 actualGasCost) internal override {\\n\\t\\t(address sponsor, address spender, uint256 gasPricePostOp, bytes32 opHash) = abi.decode(context, (address, address, uint256, bytes32));\\n\\t\\t//use same conversion rate as used for validation.\\n\\t\\tbalances[sponsor] -= actualGasCost + COST_OF_POST * gasPricePostOp;\\n\\t\\temit PostOpGasPaid(opHash, spender, sponsor, actualGasCost + COST_OF_POST * gasPricePostOp);\\n\\t}\\n\\n\\t///////////////////////\\n\\t// START EXTERNAL OPS//\\n\\t///////////////////////\\n\\n\\t/**\\n\\t * @notice Adds the specified deposit amount to the deposit balance of the given sponsor address.\\n\\t * @param sponsor The address of the sponsor whose deposit balance will be increased.\\n\\t * @param amount The amount of the deposit to be added.\\n\\t */\\n\\tfunction addDepositTo(address sponsor, uint256 amount) public payable {\\n\\t\\trequire(msg.value == amount, \\\"FW311\\\");\\n\\t\\t_addDepositTo(sponsor, amount);\\n\\t\\temit AddDepositTo(sponsor, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Withdraws the specified deposit amount from the deposit balance of the calling sender and transfers it to the target address.\\n\\t * @param target The address to which the deposit amount will be transferred.\\n\\t * @param amount The amount of the deposit to be withdrawn and transferred.\\n\\t */\\n\\tfunction withdrawDepositTo(address payable target, uint256 amount) public payable {\\n\\t\\t_withdrawDepositTo(msg.sender, target, amount);\\n\\t\\temit WithdrawDepositTo(msg.sender, target, amount);\\n\\t}\\n\\n\\t// Deposit Locking\\n\\t/**\\n\\t * @notice Locks the deposit of the calling sender by setting the unlock block to zero.\\n\\t */\\n\\tfunction lockDeposit() public payable {\\n\\t\\t_setUnlockBlock(msg.sender, 0);\\n\\t\\temit LockDeposit(msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Unlocks the deposit of the calling sender after the specified number of blocks have passed.\\n\\t * @param num The number of blocks to wait before unlocking the deposit.\\n\\t */\\n\\tfunction unlockDepositAfter(uint256 num) public payable {\\n\\t\\t_setUnlockBlock(msg.sender, block.number + num);\\n\\t\\temit UnlockDepositAfter(msg.sender, block.number + num);\\n\\t}\\n\\n\\t// Basic access control Setters\\n\\t/**\\n\\t * @notice Sets the list mode for the calling sender.\\n\\t * @dev true means blacklist mode, false means whitelist mode.\\n\\t * @param mode The boolean value to set the list mode to.\\n\\t */\\n\\tfunction setListMode(bool mode) public payable {\\n\\t\\t_setListMode(msg.sender, mode);\\n\\t\\temit SetListMode(msg.sender, mode);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets the blacklist mode for the specified spender of the calling sponsor address.\\n\\t * @param spender The address of the spender to set the blacklist mode for.\\n\\t * @param mode The boolean value to set the blacklist mode to.\\n\\t */\\n\\tfunction setSpenderBlacklistMode(address spender, bool mode) public payable {\\n\\t\\t_setSpenderBlacklistMode(msg.sender, spender, mode);\\n\\t\\temit SetSpenderBlacklistMode(msg.sender, spender, mode);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets the whitelist mode for the specified spender of the calling sponsor address.\\n\\t * @param spender The address of the spender to set the whitelist mode for.\\n\\t * @param mode The boolean value to set the whitelist mode to.\\n\\t */\\n\\tfunction setSpenderWhitelistMode(address spender, bool mode) public payable {\\n\\t\\t_setSpenderWhitelistMode(msg.sender, spender, mode);\\n\\t\\temit SetSpenderWhitelistMode(msg.sender, spender, mode);\\n\\t}\\n\\n\\t// External Data Getters\\n\\t/**\\n\\t * @notice Returns the deposit balance of the specified sponsor address.\\n\\t * @param sponsor The address of the sponsor to retrieve the deposit balance for.\\n\\t * @return The deposit balance of the specified sponsor address.\\n\\t */\\n\\tfunction getBalance(address sponsor) public view returns (uint256) {\\n\\t\\treturn balances[sponsor];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns the unlock block of the specified spender address.\\n\\t * @param spender The address of the spender to retrieve the unlock block for.\\n\\t * @return The unlock block of the specified spender address.\\n\\t */\\n\\tfunction getUnlockBlock(address spender) public view returns (uint256) {\\n\\t\\treturn unlockBlock[spender];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns the list mode of the specified spender address.\\n\\t * @param spender The address of the spender to retrieve the list mode for.\\n\\t * @return The list mode of the specified spender address.\\n\\t */\\n\\tfunction getListMode(address spender) public view returns (bool) {\\n\\t\\treturn sponsorApprovals[_getListModeKey(spender)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns the whitelist mode of the specified spender address for the specified sponsor.\\n\\t * @param sponsor The address of the sponsor to retrieve the whitelist mode for.\\n\\t * @param spender The address of the spender to retrieve the whitelist mode for.\\n\\t * @return The whitelist mode of the specified spender address for the specified sponsor.\\n\\t */\\n\\tfunction getSpenderWhitelistMode(address spender, address sponsor) public view returns (bool) {\\n\\t\\treturn sponsorApprovals[_getSpenderWhitelistKey(sponsor, spender)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns the blacklist mode of the specified spender address for the specified sponsor.\\n\\t * @param sponsor The address of the sponsor to retrieve the blacklist mode for.\\n\\t * @param spender The address of the spender to retrieve the blacklist mode for.\\n\\t * @return The blacklist mode of the specified spender address for the specified sponsor.\\n\\t */\\n\\tfunction getSpenderBlacklistMode(address spender, address sponsor) public view returns (bool) {\\n\\t\\treturn sponsorApprovals[_getSpenderBlacklistKey(sponsor, spender)];\\n\\t}\\n\\n\\t/////////////////////\\n\\t// END EXTERNAL OPS//\\n\\t/////////////////////\\n\\tevent AddDepositTo(address indexed sponsor, uint256 amount);\\n\\tevent BatchActions(bytes[] data);\\n\\tevent LockDeposit(address indexed locker);\\n\\tevent PostOpGasPaid(bytes32 indexed opHash, address indexed spender, address indexed sponsor, uint256 sponsorCost);\\n\\tevent SetListMode(address indexed sponsor, bool mode);\\n\\tevent SetSpenderBlacklistMode(address indexed sponsor, address indexed spender, bool mode);\\n\\tevent SetSpenderWhitelistMode(address indexed sponsor, address indexed spender, bool mode);\\n\\tevent UnlockDepositAfter(address indexed locker, uint256 unlockBlockNum);\\n\\tevent WithdrawDepositTo(address indexed sponsor, address indexed target, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/HashLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.17;\\n\\nlibrary HashLib {\\n\\t/**\\n\\t * Keccak256 all parameters together\\n\\t * @param a bytes32\\n\\t */\\n\\tfunction hash1(bytes32 a) internal pure returns (bytes32 _hash) {\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, a)\\n\\t\\t\\t_hash := keccak256(0x00, 0x20)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash1(address a) internal pure returns (bytes32 _hash) {\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, a)\\n\\t\\t\\t_hash := keccak256(0x00, 0x20)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash2(bytes32 a, bytes32 b) internal pure returns (bytes32 _hash) {\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, a)\\n\\t\\t\\tmstore(0x20, b)\\n\\t\\t\\t_hash := keccak256(0x00, 0x40)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash2(bytes32 a, address b) internal pure returns (bytes32 _hash) {\\n\\t\\tbytes20 _b = bytes20(b);\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, a)\\n\\t\\t\\tmstore(0x20, _b)\\n\\t\\t\\t_hash := keccak256(0x00, 0x34)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash2(address a, address b) internal pure returns (bytes32 _hash) {\\n\\t\\tbytes20 _a = bytes20(a);\\n\\t\\tbytes20 _b = bytes20(b);\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, _a)\\n\\t\\t\\tmstore(0x14, _b)\\n\\t\\t\\t_hash := keccak256(0x00, 0x28)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash2(address a, uint8 b) internal pure returns (bytes32 _hash) {\\n\\t\\tbytes20 _a = bytes20(a);\\n\\t\\tbytes1 _b = bytes1(b);\\n\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, _b)\\n\\t\\t\\tmstore(0x1, _a)\\n\\t\\t\\t_hash := keccak256(0x00, 0x15)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash2(bytes32 a, uint8 b) internal pure returns (bytes32 _hash) {\\n\\t\\tbytes1 _b = bytes1(b);\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x0, _b)\\n\\t\\t\\tmstore(0x1, a)\\n\\t\\t\\t_hash := keccak256(0x00, 0x21)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hash3(address a, address b, uint8 c) internal pure returns (bytes32 _hash) {\\n\\t\\tbytes20 _a = bytes20(a);\\n\\t\\tbytes20 _b = bytes20(b);\\n\\t\\tbytes1 _c = bytes1(c);\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, _c)\\n\\t\\t\\tmstore(0x01, _a)\\n\\t\\t\\tmstore(0x15, _b)\\n\\t\\t\\t_hash := keccak256(0x00, 0x29)\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable2StepNoRenounce.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\n\\ncontract Ownable2StepNoRenounce is Ownable2Step {\\n\\tfunction renounceOwnership() public override onlyOwner {\\n\\t\\trevert(\\\"FW601\\\");\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddDepositTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"BatchActions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"name\":\"LockDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IEntryPoint\",\"name\":\"entryPoint\",\"type\":\"address\"}],\"name\":\"PaymasterCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"opHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sponsorCost\",\"type\":\"uint256\"}],\"name\":\"PostOpGasPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"SetListMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"SetSpenderBlacklistMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"SetSpenderWhitelistMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockBlockNum\",\"type\":\"uint256\"}],\"name\":\"UnlockDepositAfter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDepositTo\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COST_OF_POST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addDepositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"}],\"name\":\"addStakeToEntryPoint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"batchActions\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getListMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"getSpenderBlacklistMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"getSpenderWhitelistMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getUnlockBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPaymaster.PostOpMode\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"}],\"name\":\"postOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"setListMode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"setSpenderBlacklistMode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"setSpenderWhitelistMode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"unlockDepositAfter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockStakeFromEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxCost\",\"type\":\"uint256\"}],\"name\":\"validatePaymasterUserOp\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sigTimeRange\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDepositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawStakeFromEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GaslessPaymaster", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "50000", "ConstructorArguments": "0000000000000000000000005ff137d4b0fdcd49dca30c7cf57e578a026d2789", "EVMVersion": "london", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}