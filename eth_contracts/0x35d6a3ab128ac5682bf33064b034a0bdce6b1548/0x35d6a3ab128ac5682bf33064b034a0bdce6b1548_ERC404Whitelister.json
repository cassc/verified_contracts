{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"contracts/src/ERC404/ERC404.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nabstract contract Ownable {\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    error Unauthorized();\\n    error InvalidOwner();\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        if (_owner == address(0)) revert InvalidOwner();\\n\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    function transferOwnership(address _owner) public virtual onlyOwner {\\n        if (_owner == address(0)) revert InvalidOwner();\\n\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(msg.sender, _owner);\\n    }\\n\\n    function revokeOwnership() public virtual onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(msg.sender, address(0));\\n    }\\n}\\n\\nabstract contract ERC721Receiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721Receiver.onERC721Received.selector;\\n    }\\n}\\n\\n/// @notice ERC404\\n///         A gas-efficient, mixed ERC20 / ERC721 implementation\\n///         with native liquidity and fractionalization.\\n///\\n///         This is an experimental standard designed to integrate\\n///         with pre-existing ERC20 / ERC721 support as smoothly as\\n///         possible.\\n///\\n/// @dev    In order to support full functionality of ERC20 and ERC721\\n///         supply assumptions are made that slightly constraint usage.\\n///         Ensure decimals are sufficiently large (standard 18 recommended)\\n///         as ids are effectively encoded in the lowest range of amounts.\\n///\\n///         NFTs are spent on ERC20 functions in a FILO queue, this is by\\n///         design.\\n///\\nabstract contract ERC404 is Ownable {\\n    // Events\\n    event ERC20Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed id\\n    );\\n    event ERC721Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed id\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    // Errors\\n    error NotFound();\\n    error AlreadyExists();\\n    error InvalidRecipient();\\n    error InvalidSender();\\n    error UnsafeRecipient();\\n\\n    // Metadata\\n    /// @dev Token name\\n    string public name;\\n\\n    /// @dev Token symbol\\n    string public symbol;\\n\\n    /// @dev Decimals for fractional representation\\n    uint8 public immutable decimals;\\n\\n    /// @dev Total supply in fractionalized representation\\n    uint256 public immutable totalSupply;\\n\\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\\n    uint256 public minted;\\n\\n    // Mappings\\n    /// @dev Balance of user in fractional representation\\n    mapping(address => uint256) public balanceOf;\\n\\n    /// @dev Allowance of user in fractional representation\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /// @dev Approval in native representaion\\n    mapping(uint256 => address) public getApproved;\\n\\n    /// @dev Approval for all in native representation\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /// @dev Owner of id in native representation\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    /// @dev Array of owned ids in native representation\\n    mapping(address => uint256[]) internal _owned;\\n\\n    /// @dev Tracks indices for the _owned mapping\\n    mapping(uint256 => uint256) internal _ownedIndex;\\n\\n    /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\\n    mapping(address => bool) public whitelist;\\n\\n    // Constructor\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint256 _totalNativeSupply,\\n        address _owner\\n    ) Ownable(_owner) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        totalSupply = _totalNativeSupply * (10 ** decimals);\\n    }\\n\\n    /// @notice Initialization function to set pairs / etc\\n    ///         saving gas by avoiding mint / burn on unnecessary targets\\n    function setWhitelist(address target, bool state) public onlyOwner {\\n        whitelist[target] = state;\\n    }\\n\\n    /// @notice Function to find owner of a given native token\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        owner = _ownerOf[id];\\n\\n        if (owner == address(0)) {\\n            revert NotFound();\\n        }\\n    }\\n\\n    /// @notice tokenURI must be implemented by child contract\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /// @notice Function for token approvals\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\n    function approve(\\n        address spender,\\n        uint256 amountOrId\\n    ) public virtual returns (bool) {\\n        if (amountOrId <= minted && amountOrId > 0) {\\n            address owner = _ownerOf[amountOrId];\\n\\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\\n                revert Unauthorized();\\n            }\\n\\n            getApproved[amountOrId] = spender;\\n\\n            emit Approval(owner, spender, amountOrId);\\n        } else {\\n            allowance[msg.sender][spender] = amountOrId;\\n\\n            emit Approval(msg.sender, spender, amountOrId);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Function native approvals\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice Function for mixed transfers\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amountOrId\\n    ) public virtual {\\n        if (amountOrId <= minted) {\\n            if (from != _ownerOf[amountOrId]) {\\n                revert InvalidSender();\\n            }\\n\\n            if (to == address(0)) {\\n                revert InvalidRecipient();\\n            }\\n\\n            if (\\n                msg.sender != from &&\\n                !isApprovedForAll[from][msg.sender] &&\\n                msg.sender != getApproved[amountOrId]\\n            ) {\\n                revert Unauthorized();\\n            }\\n\\n            balanceOf[from] -= _getUnit();\\n\\n            unchecked {\\n                balanceOf[to] += _getUnit();\\n            }\\n\\n            _ownerOf[amountOrId] = to;\\n            delete getApproved[amountOrId];\\n\\n            // update _owned for sender\\n            uint256 updatedId = _owned[from][_owned[from].length - 1];\\n            _owned[from][_ownedIndex[amountOrId]] = updatedId;\\n            // pop\\n            _owned[from].pop();\\n            // update index for the moved id\\n            _ownedIndex[updatedId] = _ownedIndex[amountOrId];\\n            // push token to to owned\\n            _owned[to].push(amountOrId);\\n            // update index for to owned\\n            _ownedIndex[amountOrId] = _owned[to].length - 1;\\n\\n            emit Transfer(from, to, amountOrId);\\n            emit ERC20Transfer(from, to, _getUnit());\\n        } else {\\n            uint256 allowed = allowance[from][msg.sender];\\n\\n            if (allowed != type(uint256).max)\\n                allowance[from][msg.sender] = allowed - amountOrId;\\n\\n            _transfer(from, to, amountOrId);\\n        }\\n    }\\n\\n    /// @notice Function for fractional transfers\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        return _transfer(msg.sender, to, amount);\\n    }\\n\\n    /// @notice Function for native transfers with contract support\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") !=\\n            ERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /// @notice Function for native transfers with contract support and callback data\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\\n            ERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /// @notice Internal function for fractional transfers\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        uint256 unit = _getUnit();\\n        uint256 balanceBeforeSender = balanceOf[from];\\n        uint256 balanceBeforeReceiver = balanceOf[to];\\n\\n        balanceOf[from] -= amount;\\n\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        // Skip burn for certain addresses to save gas\\n        if (!whitelist[from]) {\\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\\n                (balanceOf[from] / unit);\\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\\n                _burn(from);\\n            }\\n        }\\n\\n        // Skip minting for certain addresses to save gas\\n        if (!whitelist[to]) {\\n            uint256 tokens_to_mint = (balanceOf[to] / unit) -\\n                (balanceBeforeReceiver / unit);\\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\\n                _mint(to);\\n            }\\n        }\\n\\n        emit ERC20Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    // Internal utility logic\\n    function _getUnit() internal view returns (uint256) {\\n        return 10 ** decimals;\\n    }\\n\\n    function _mint(address to) internal virtual {\\n        if (to == address(0)) {\\n            revert InvalidRecipient();\\n        }\\n\\n        unchecked {\\n            minted++;\\n        }\\n\\n        uint256 id = minted;\\n\\n        if (_ownerOf[id] != address(0)) {\\n            revert AlreadyExists();\\n        }\\n\\n        _ownerOf[id] = to;\\n        _owned[to].push(id);\\n        _ownedIndex[id] = _owned[to].length - 1;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(address from) internal virtual {\\n        if (from == address(0)) {\\n            revert InvalidSender();\\n        }\\n\\n        uint256 id = _owned[from][_owned[from].length - 1];\\n        _owned[from].pop();\\n        delete _ownedIndex[id];\\n        delete _ownerOf[id];\\n        delete getApproved[id];\\n\\n        emit Transfer(from, address(0), id);\\n    }\\n\\n    function _setNameSymbol(\\n        string memory _name,\\n        string memory _symbol\\n    ) internal {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/src/ERC404/ERC404Whitelister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC404.sol\\\";\\nimport \\\"./IERC404.sol\\\";\\nimport \\\"../../lib/ReentrancyGuard.sol\\\";\\n\\n\\ncontract ERC404Whitelister is ReentrancyGuard {\\n    event Whitelist(address indexed target, bool state);\\n\\n    struct Base404 {\\n        address admin;\\n        bool allowContractWhitelists;\\n        IERC404 baseInterface;\\n    }\\n\\n    mapping(address => Base404) public base404s;\\n\\n    // This function allows an address to whitelist themselves\\n    function selfWhitelist(address _baseAddress, bool _state) public {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        _whitelist(base404, msg.sender, _state);\\n    }\\n\\n    // This function allows any address to whitelist a contract they are the owner of\\n    function contractWhitelist(address _baseAddress, address _target, bool _state) public {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        require(base404.allowContractWhitelists, \\\"Contract whitelisting not allowed\\\");\\n        require(IOwnable(_target).owner() == msg.sender, \\\"You are not the owner of this contract\\\");\\n        _whitelist(base404, _target, _state);\\n    }\\n\\n    // This function allows the admin to whitelist any address\\n    function adminWhitelist(address _baseAddress, address _target, bool _state) public {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        require(\\n            base404.admin == msg.sender &&\\n            base404.admin != address(0),\\n            \\\"You are not the admin of this contract\\\");\\n        _whitelist(base404, _target, _state);\\n    }\\n\\n    // This function removes admin permissions from the contract\\n    // After calling this function, the admin will not be able to\\n    // recover ownership of the base contract\\n    function renounceAdmin(address _baseAddress) public {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        require(base404.admin == msg.sender, \\\"You are not the admin of this contract\\\");\\n        base404.admin = address(0);\\n    }\\n\\n    // This function enables self-whitelisting permissions\\n    // Call this function before transferring ownership\\n    function add404(address _baseAddress) public {\\n        address owner = IOwnable(_baseAddress).owner();\\n        require(\\n            (owner == msg.sender && owner != address(0)) || \\n            (owner == address(this) && !_exists(base404s[_baseAddress])),\\n            \\\"Failed to verify ownership\\\"\\n            );\\n\\n        base404s[_baseAddress] = Base404({\\n            admin: owner,\\n            allowContractWhitelists: false,\\n            baseInterface: IERC404(_baseAddress)\\n        });\\n\\n        // In the scenario where the contract admin accidentally transfers ownership \\n        // before calling this function, they will not be able to recover ownership,\\n        // but anyone can then call the add404 function, allowing\\n        // users to interact with this contract. It is effectively\\n        // the renounceOwnership function of the base contract.\\n    }\\n\\n    // This function disables self-whitelisting permissions\\n    // and transfers ownership back to the admin\\n    function remove404(address _baseAddress) public {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        require(\\n            base404.admin == msg.sender &&\\n            base404.admin != address(0),\\n            \\\"You are not the admin of this contract\\\");\\n        IERC404(_baseAddress).transferOwnership(base404.admin);\\n        // Remove the mapping\\n        delete base404s[_baseAddress];\\n    }\\n\\n    // This function allows the admin to enable or disable contract whitelisting\\n    function setAllowContractWhitelist(address _baseAddress, bool _state) public {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        require(_exists(base404), \\\"Base404 not found\\\");\\n        require(\\n            base404.admin == msg.sender &&\\n            base404.admin != address(0), \\n            \\\"You are not the admin of this contract\\\");\\n        base404.allowContractWhitelists = _state;\\n    }\\n\\n    // For users to check if an address is whitelisted\\n    function checkWhitelist(address _baseAddress, address _target) public view returns (bool) {\\n        Base404 storage base404 = base404s[_baseAddress];\\n        require(_exists(base404), \\\"Base404 not found\\\");\\n        return base404.baseInterface.whitelist(_target);\\n    }\\n\\n    function _exists(Base404 storage base404) internal view returns (bool) {\\n        return address(base404.baseInterface) != address(0);\\n    }\\n\\n    function _whitelist(Base404 storage base404, address _target, bool _state) internal {\\n        require(_exists(base404), \\\"Base404 not found\\\");\\n        require(base404.baseInterface.balanceOf(_target) == 0, \\\"Only addresses with zero balance can change whitelist state\\\");\\n        base404.baseInterface.setWhitelist(_target, _state);\\n        \\n        emit Whitelist(_target, _state);\\n    }\\n\\n    // Fallback function reverts\\n    receive() external payable {\\n        revert(\\\"This contract does not accept Ether\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/src/ERC404/IERC404.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC404 {\\n    function setWhitelist(address target, bool state) external;\\n    function whitelist(address target) external view returns (bool);\\n    function transferOwnership(address newOwner) external;\\n    function balanceOf(address _address) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 amount) external;\\n    function transfer(address to, uint256 amount) external;\\n}\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"Whitelist\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"}],\"name\":\"add404\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"adminWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"base404s\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowContractWhitelists\",\"type\":\"bool\"},{\"internalType\":\"contract IERC404\",\"name\":\"baseInterface\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"checkWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"contractWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"}],\"name\":\"remove404\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"}],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"selfWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setAllowContractWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC404Whitelister", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}