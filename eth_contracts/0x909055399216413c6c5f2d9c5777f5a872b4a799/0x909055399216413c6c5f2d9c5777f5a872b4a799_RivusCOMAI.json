{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {ERC165Upgradeable} from \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\\n    struct AccessControlStorage {\\n        mapping(bytes32 role => RoleData) _roles;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.AccessControl\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\\n\\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\\n        assembly {\\n            $.slot := AccessControlStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        $._roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (!hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {OwnableUpgradeable} from \\\"./OwnableUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable2Step\\n    struct Ownable2StepStorage {\\n        address _pendingOwner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable2Step\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant Ownable2StepStorageLocation = 0x237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00;\\n\\n    function _getOwnable2StepStorage() private pure returns (Ownable2StepStorage storage $) {\\n        assembly {\\n            $.slot := Ownable2StepStorageLocation\\n        }\\n    }\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    function __Ownable2Step_init() internal onlyInitializing {\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\\n        return $._pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\\n        $._pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\\n        delete $._pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\\n    struct OwnableStorage {\\n        address _owner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\\n\\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\\n        assembly {\\n            $.slot := OwnableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        return $._owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        address oldOwner = $._owner;\\n        $._owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {ContextUpgradeable} from \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport {IERC20Errors} from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\\n    struct ERC20Storage {\\n        mapping(address account => uint256) _balances;\\n\\n        mapping(address account => mapping(address spender => uint256)) _allowances;\\n\\n        uint256 _totalSupply;\\n\\n        string _name;\\n        string _symbol;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ERC20\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\\n\\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\\n        assembly {\\n            $.slot := ERC20StorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        $._name = name_;\\n        $._symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            $._totalSupply += value;\\n        } else {\\n            uint256 fromBalance = $._balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                $._balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                $._totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                $._balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        $._allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IBridge {\\r\\n    function claimTokens(bytes memory signature, uint256 tokenAmount) external returns(bool);\\r\\n    function bridgeBack(uint256 _amount, string memory _to) external returns(bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interface/IwCOMAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IwCOMAI {\\r\\n    function mint(address to, uint256 amount) external returns (bool);\\r\\n    function burnFrom(address account, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler's built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/RivusCOMAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.20;\\r\\n\\r\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport { ERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\r\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\n\\r\\nimport { ReentrancyGuardUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\r\\nimport { SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"./interface/IwCOMAI.sol\\\";\\r\\nimport \\\"./interface/IBridge.sol\\\";\\r\\nimport \\\"./rsCOMAI.sol\\\";\\r\\n\\r\\ncontract RivusCOMAI is\\r\\n  Initializable,\\r\\n  RsCOMAI,\\r\\n  Ownable2StepUpgradeable,\\r\\n  ReentrancyGuardUpgradeable,\\r\\n  AccessControlUpgradeable\\r\\n{\\r\\n  using SafeERC20 for IERC20;\\r\\n  struct UnstakeRequest {\\r\\n    uint256 amount;\\r\\n    uint256 comaiAmt;\\r\\n    bool isReadyForUnstake;\\r\\n    address wrappedToken;\\r\\n    uint256 timestamp;\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   * set the exchange rate of wCOMAI:RivusCOMAI.\\r\\n   * exchange rate is in 10^18\\r\\n   */\\r\\n  uint256 public exchangeRate; // 1 * 10^18\\r\\n  /*\\r\\n   * How much COMAI it cost to unstake. This is to account for bridging cost from Commume to eth\\r\\n   */\\r\\n  uint256 public unstakingFee;\\r\\n  /*\\r\\n   * How much COMAI it cost to stake. This is to account for bridging cost from eth to Commume\\r\\n   */\\r\\n  uint256 public stakingFee;\\r\\n  /*\\r\\n   * How much COMAI it cost to bridge.\\r\\n   */\\r\\n  uint256 public bridgingFee;\\r\\n  /*\\r\\n   * How much is needed to be staked to be able to perform staking in 1 txn\\r\\n   */\\r\\n  uint256 public minStakingAmt;\\r\\n  /*\\r\\n   * Underlying token\\r\\n   */\\r\\n  address public wrappedToken;\\r\\n  /*\\r\\n   * Set the max amount of wCOMAI that can be deposited at once\\r\\n   */\\r\\n  uint256 public maxDepositPerRequest;\\r\\n  /*\\r\\n   * Total Supply Limit\\r\\n   */\\r\\n  uint256 public cap;\\r\\n  /*\\r\\n   * Determine if the contract is paused\\r\\n   */\\r\\n  bool public isPaused;\\r\\n  /*\\r\\n   * Commume wallet that will receive the wCOMAI after wrap()\\r\\n   * NOTE: it must be at least 48 chars so validation shall\\r\\n   * be done to ensure that it is true\\r\\n   */\\r\\n  string public nativeWalletReceiver;\\r\\n  /*\\r\\n   * Set the max amount of unstake request for a given user\\r\\n   */\\r\\n  uint256 public maxUnstakeRequests;\\r\\n  /*\\r\\n   * Mapping from address to current active UnstakeRequest[]\\r\\n   */\\r\\n  mapping(address => UnstakeRequest[]) public unstakeRequests;\\r\\n  /*\\r\\n   * The address that can be allowed to withdraw\\r\\n   */\\r\\n  address public withdrawalManager;\\r\\n  /*\\r\\n   * The service fee that is charged for each unstake request in ETH\\r\\n   * This is to pay for the gas fees for the withdrawal manager\\r\\n   */\\r\\n  uint256 public serviceFee;\\r\\n\\r\\n  uint256 public lastRebaseTime;\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Defines totalSupply for RivusCOMAI\\r\\n   *\\r\\n   *\\r\\n   */\\r\\n  uint256 public totalRsCOMAIMinted;\\r\\n\\r\\n  /*\\r\\n   * Defines both the upper bound and lower bound of the exchange rate\\r\\n   */\\r\\n\\r\\n  uint256 public lowerExchangeRateBound;\\r\\n  uint256 public upperExchangeRateBound;\\r\\n\\r\\n  address public protocolVault;\\r\\n  address public bridge;\\r\\n\\r\\n  bytes32 public constant PAUSE_ROLE = keccak256(\\\"PAUSE_ROLE\\\");\\r\\n  bytes32 public constant EXCHANGE_UPDATE_ROLE = keccak256(\\\"EXCHANGE_UPDATE_ROLE\\\");\\r\\n  bytes32 public constant MANAGE_STAKING_CONFIG_ROLE = keccak256(\\\"MANAGE_STAKING_CONFIG_ROLE\\\");\\r\\n  bytes32 public constant TOKEN_SAFE_PULL_ROLE = keccak256(\\\"TOKEN_SAFE_PULL_ROLE\\\");\\r\\n  bytes32 public constant APPROVE_WITHDRAWAL_ROLE = keccak256(\\\"APPROVE_WITHDRAWAL_ROLE\\\");\\r\\n\\r\\n\\r\\n  modifier canPauseRole() {\\r\\n    require(hasRole(PAUSE_ROLE, msg.sender), \\\"Caller does not have PAUSE_ROLE\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier hasExchangeUpdateRole() {\\r\\n    require(\\r\\n      hasRole(EXCHANGE_UPDATE_ROLE, msg.sender),\\r\\n      \\\"Caller does not have EXCHANGE_UPDATE_ROLE\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier hasManageStakingConfigRole() {\\r\\n    require(\\r\\n      hasRole(MANAGE_STAKING_CONFIG_ROLE, msg.sender),\\r\\n      \\\"Caller does not have MANAGE_STAKING_UPDATE_ROLE\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier hasTokenSafePullRole() {\\r\\n    require(\\r\\n      hasRole(TOKEN_SAFE_PULL_ROLE, msg.sender),\\r\\n      \\\"Caller does not have TOKEN_SAFE_PULL_ROLE\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier hasApproveWithdrawalRole() {\\r\\n    require(\\r\\n      hasRole(APPROVE_WITHDRAWAL_ROLE, msg.sender),\\r\\n      \\\"Caller does not have APPROVE_WITHDRAWAL_ROLE\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n\\r\\n  struct UserRequest {\\r\\n    address user;\\r\\n    uint256 requestIndex;\\r\\n  }\\r\\n\\r\\n  // Declaration of all events\\r\\n  event UserUnstakeRequested(\\r\\n    address indexed user,\\r\\n    uint256 idx,\\r\\n    uint256 requestTimestamp,\\r\\n    uint256 wstAmount,\\r\\n    uint256 outComaiAmt,\\r\\n    address wrappedToken\\r\\n  );\\r\\n  event AdminUnstakeApproved(\\r\\n    address indexed user,\\r\\n    uint256 idx,\\r\\n    uint256 approvedTimestamp\\r\\n  );\\r\\n  event UserUnstake(\\r\\n    address indexed user,\\r\\n    uint256 idx,\\r\\n    uint256 unstakeTimestamp\\r\\n  );\\r\\n  event UserStake(\\r\\n    address indexed user,\\r\\n    uint256 stakeTimestamp,\\r\\n    uint256 inComaiAmt,\\r\\n    uint256 wstAmount\\r\\n  );\\r\\n  event UpdateProtocolVault(address newProtocolVault);\\r\\n  event UpdateServiceFee(uint256 serviceFee);\\r\\n  event UpdateWithdrawalManager(address withdrawalManager);\\r\\n  event UpdateMinStakingAmt(uint256 minStakingAmt);\\r\\n  event UpdateStakingFee(uint256 stakingFee);\\r\\n  event UpdateBridgeFee(uint256 bridgingFee);\\r\\n  event UpdateMaxDepositPerRequest(uint256 maxDepositPerRequest);\\r\\n  event UpdateMaxUnstakeRequest(uint256 maxUnstakeRequests);\\r\\n  event UpdateExchangeRate(uint256 newRate);\\r\\n  event LowerBoundUpdated(uint256 newLowerBound);\\r\\n  event UpperBoundUpdated(uint256 newUpperBound);\\r\\n  event ContractPaused(bool paused);\\r\\n  event UpdateWComai(address newWCOMAI);\\r\\n  event UpdateUnstakingFee(uint256 newUnstakingFee);\\r\\n  event UpdateNativeCommumeReceiver(string newNativeWalletReceiver);\\r\\n  event Mint(address indexed recipient, uint256 amount, uint256 timestamp);\\r\\n  event Burn(address indexed provider, uint256 amount, uint256 timestamp);\\r\\n  event ERC20TokenPulled(address tokenAddress, address to, uint256 amount);\\r\\n  event NativeTokenPulled(address to, uint256 amount);\\r\\n  // event Rebase(uint256 apr, uint256 totalSharesAmount, uint256 burnAmount, address excuter, uint256 timestamp);\\r\\n  event Rebase(uint256 apr, uint256 totalRsCOMAIMinted, uint256 totalShares, uint256 mintAmoount, uint256 timestamp);\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * In this initialization function, we initialize and \\r\\n   * set the intiailOwner as the owner of RivusCOMAI\\r\\n   */\\r\\n  function initialize(\\r\\n        address _owner, address _wCOMAI, \\r\\n        string memory _nativeTokenReceiver, \\r\\n        address _protocolVault, address _bridge\\r\\n  ) public initializer {\\r\\n    require(_owner != address(0), \\\"Owner cannot be null\\\");\\r\\n    __Ownable_init(_owner);\\r\\n    __AccessControl_init();\\r\\n    __ReentrancyGuard_init();\\r\\n\\r\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\r\\n    _grantRole(DEFAULT_ADMIN_ROLE, _owner);\\r\\n    _grantRole(EXCHANGE_UPDATE_ROLE, _owner);\\r\\n    _grantRole(MANAGE_STAKING_CONFIG_ROLE, _owner);\\r\\n    _grantRole(APPROVE_WITHDRAWAL_ROLE, _owner);\\r\\n    _grantRole(PAUSE_ROLE, _owner);\\r\\n\\r\\n    wrappedToken = _wCOMAI;\\r\\n    protocolVault = _protocolVault;\\r\\n    withdrawalManager = _owner;\\r\\n    _checkValidCommumeWallet(_nativeTokenReceiver);\\r\\n    nativeWalletReceiver = _nativeTokenReceiver;\\r\\n\\r\\n    bridgingFee = 3; // multiplier is 1000\\r\\n    unstakingFee = 10; // multiplier is 1000\\r\\n    stakingFee = 0; // multiplier is 1000\\r\\n    serviceFee = 0.003 ether;\\r\\n\\r\\n    maxDepositPerRequest = 1_000_000 * (10 ** decimals());\\r\\n    minStakingAmt = 15 * (10 ** decimals());\\r\\n    maxUnstakeRequests = 1_000_000 * (10 ** decimals());\\r\\n\\r\\n    lowerExchangeRateBound = 0.5 ether;\\r\\n    upperExchangeRateBound = 1.5 ether;\\r\\n    exchangeRate = 1 ether; // 1 * 10^18\\r\\n\\r\\n    cap = 1_000_000 * (10 ** decimals());\\r\\n    bridge = _bridge;\\r\\n    \\r\\n    _transferOwnership(_owner);\\r\\n  }\\r\\n\\r\\n  function _getTotalMintedRsCOMAI() internal view override returns (uint256) {\\r\\n      return totalRsCOMAIMinted;\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   * Common setters for the contract\\r\\n   *\\r\\n   */\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Function to update the current ETH service fee to support gas transactions for unstaking.\\r\\n   *\\r\\n   * Value Boundary: serviceFee can be 0 ETH\\r\\n   *\\r\\n   */\\r\\n  function setServiceFee(uint256 _serviceFee) public hasManageStakingConfigRole {\\r\\n    require(_serviceFee <= 0.01 ether, \\\"Service fee cannot be more than 0.01 ETH\\\");\\r\\n    serviceFee = _serviceFee;\\r\\n    emit UpdateServiceFee(serviceFee);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Function to set the withdrawal manager address that will receive the ETH service fee\\r\\n   *\\r\\n   * Value boundary: withdrawalManager cannot be address(0)\\r\\n   *\\r\\n   */\\r\\n  function setWithdrawalManager(address _withdrawalManager) public hasManageStakingConfigRole {\\r\\n    require(_withdrawalManager != address(0), \\\"Withdrawal manager cannot be null\\\");\\r\\n    withdrawalManager = _withdrawalManager;\\r\\n    emit UpdateWithdrawalManager(withdrawalManager);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This function sets the protocol vault address that\\r\\n   * shall be responsible for receiving the staking fees.\\r\\n   *\\r\\n   * Boundary: address cannot be address(0)\\r\\n   *\\r\\n   */\\r\\n  function setProtocolVault(address _protocolVault) public hasManageStakingConfigRole {\\r\\n    require(_protocolVault != address(0), \\\"Protocol vault cannot be null\\\");\\r\\n    protocolVault = _protocolVault;\\r\\n    emit UpdateProtocolVault(protocolVault);\\r\\n  }\\r\\n  \\r\\n  /*\\r\\n   *\\r\\n   * This method sets the min staking amount required to perform staking\\r\\n   *\\r\\n   * Value Boundary: minStakingAmt can be any value even 0 in the event that minStakingAmt by comaibridge changes in the future\\r\\n   *\\r\\n   */\\r\\n  function setMinStakingAmt(uint256 _minStakingAmt) public hasManageStakingConfigRole {\\r\\n    require(_minStakingAmt > 15 * (10 ** decimals()), \\\"Min staking amount must be more than bridging fee\\\");\\r\\n    minStakingAmt = _minStakingAmt;\\r\\n    emit UpdateMinStakingAmt(minStakingAmt);\\r\\n  }\\r\\n\\r\\n  function updateBridge(address _bridge) public hasManageStakingConfigRole {\\r\\n    bridge = _bridge;\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Value Boundary: stakingFee can be between 0-999 (0% to 99.9%)\\r\\n   *\\r\\n   * 0% can be set in case stakingFee is disabled in the future.\\r\\n   *\\r\\n   */\\r\\n  function setStakingFee(uint256 _stakingFee) public hasManageStakingConfigRole {\\r\\n    // Staking fee cannot be equivalent to 2% staking fee. Max it can go is 19 (1.9%)\\r\\n    require(_stakingFee < 20, \\\"Staking fee cannot be more than equal to 20\\\");\\r\\n    stakingFee = _stakingFee;\\r\\n    emit UpdateStakingFee(stakingFee);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This function sets the bridging fee that is used to bridge from eth to Commume\\r\\n   *\\r\\n   * Value Boundary: bridgingFee can be any value even 0 in the event that bridgingFee by comaibridge changes in the future\\r\\n   *\\r\\n   */\\r\\n  function setBridgingFee(uint256 _bridgingFee) public hasManageStakingConfigRole {\\r\\n    require(_bridgingFee > 3, \\\"Bridging fee should be more than 0.3%\\\");\\r\\n    bridgingFee = _bridgingFee; // Assuming _bridgingFee is passed in mwei\\r\\n    emit UpdateBridgeFee(bridgingFee);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Set the maximum number of deposit per request for a given user\\r\\n   *\\r\\n   * Value Boundary: maxDepositPerRequest must be more than 0\\r\\n   *\\r\\n   */\\r\\n  function setMaxDepositPerRequest(uint256 _maxDepositPerRequest)\\r\\n    public\\r\\n    hasManageStakingConfigRole\\r\\n  {\\r\\n    require(_maxDepositPerRequest > 0, \\\"Max deposit per request must be more than 0\\\");\\r\\n    maxDepositPerRequest = _maxDepositPerRequest;\\r\\n    emit UpdateMaxDepositPerRequest(maxDepositPerRequest);\\r\\n  }\\r\\n\\r\\n  function updateCap(uint256 _newCap)\\r\\n    public\\r\\n    hasManageStakingConfigRole\\r\\n  {\\r\\n    require(_newCap > 0, \\\"Max deposit per request must be more than 0\\\");\\r\\n    cap = _newCap;\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Set maximum unstake request\\r\\n   *\\r\\n   * Value Boundary: maxUnstakeRequests must be more than 0\\r\\n   *\\r\\n   */\\r\\n  function setMaxUnstakeRequest(uint256 _maxUnstakeRequests) public hasManageStakingConfigRole {\\r\\n    require(_maxUnstakeRequests > 0, \\\"Max unstake requests must be more than 0\\\");\\r\\n    maxUnstakeRequests = _maxUnstakeRequests;\\r\\n    emit UpdateMaxUnstakeRequest(maxUnstakeRequests);\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() public override onlyOwner {}\\r\\n\\r\\n  // Ensure that the lower bound is less than upper bound\\r\\n  function setLowerExchangeRateBound(uint256 _newLowerBound) public hasExchangeUpdateRole {\\r\\n    require(_newLowerBound > 0, \\\"New lower bound must be more than 0\\\");\\r\\n    require(\\r\\n      _newLowerBound < upperExchangeRateBound,\\r\\n      \\\"New lower bound must be less than current upper bound\\\"\\r\\n    );\\r\\n    lowerExchangeRateBound = _newLowerBound;\\r\\n    emit LowerBoundUpdated(_newLowerBound);\\r\\n  }\\r\\n\\r\\n  // Ensure that the upper bound is more than lower bound\\r\\n  function setUpperExchangeRateBound(uint256 _newUpperBound) public hasExchangeUpdateRole {\\r\\n    require(_newUpperBound > 0, \\\"New upper bound must be more than 0\\\");\\r\\n    require(\\r\\n      _newUpperBound > lowerExchangeRateBound,\\r\\n      \\\"New upper bound must be greater than current lower bound\\\"\\r\\n    );\\r\\n    upperExchangeRateBound = _newUpperBound;\\r\\n    emit UpperBoundUpdated(_newUpperBound);\\r\\n  }\\r\\n\\r\\n  function setPaused(bool _isPaused) public canPauseRole {\\r\\n    isPaused = _isPaused;\\r\\n    emit ContractPaused(isPaused);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This function determines the unstaking fee that is charged to the user\\r\\n   *\\r\\n   * The value is in gwei so if _unstakingFee is 1 gwei, it means 1 COMAI is charged as unstaking fee\\r\\n   *\\r\\n   * Value Boundary: UnstakingFee can be any value even 0 in the event that unstakingFee is not longer charged.\\r\\n   *\\r\\n   */\\r\\n  function setUnstakingFee(uint256 _unstakingFee) public hasManageStakingConfigRole {\\r\\n    require(_unstakingFee <= 100, \\\"Unstaking fee cannot be more than 10%\\\");\\r\\n    unstakingFee = _unstakingFee;\\r\\n    emit UpdateUnstakingFee(unstakingFee);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This function sets to wcomai address that will be used to wrap and unwrap\\r\\n   *\\r\\n   * Value boundary: wCOMAI cannot be address(0)\\r\\n   *\\r\\n   */\\r\\n  function setWCOMAI(address _wCOMAI) public hasManageStakingConfigRole {\\r\\n    // Check to ensure _wCOMAI is not null\\r\\n    _requireNonZeroAddress(_wCOMAI, \\\"wCOMAI address cannot be null\\\");\\r\\n    wrappedToken = _wCOMAI;\\r\\n    emit UpdateWComai(_wCOMAI);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   * Function to set the natvive token receiver. Validation performed to determine if 48 characters\\r\\n   */\\r\\n  function setNativeTokenReceiver(string memory _nativeWalletReceiver)\\r\\n    public\\r\\n    hasManageStakingConfigRole\\r\\n  {\\r\\n    // Ensure it is a valid Commume wallet before updating.\\r\\n    _checkValidCommumeWallet(_nativeWalletReceiver);\\r\\n    nativeWalletReceiver = _nativeWalletReceiver;\\r\\n    emit UpdateNativeCommumeReceiver(_nativeWalletReceiver);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * These those methods shall help to calculate the exchange rate\\r\\n   * of rsCOMAI given wCOMAI input and vice versa\\r\\n   *\\r\\n   * Note that there would be precision loss that would be rounded down\\r\\n   * so the user will get less than expected to a precision of up to 1 wei if the rounding\\r\\n   * down happens.\\r\\n   *\\r\\n   */\\r\\n  function getRsCOMAIbyWCOMAI(uint256 wcomaiAmount) public view returns (uint256) {\\r\\n    return (wcomaiAmount * exchangeRate) / 1 ether;\\r\\n  }\\r\\n\\r\\n  function getWCOMAIByrsCOMAI(uint256 rsCOMAIAmount) public view returns (uint256) {\\r\\n    return (rsCOMAIAmount * 1 ether) / exchangeRate;\\r\\n  }\\r\\n\\r\\n  function getWCOMAIByrsCOMAIAfterFee(uint256 rsCOMAIAmount)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256, uint256, uint256)\\r\\n  {\\r\\n    uint256 unstakingFeeAmt = rsCOMAIAmount * unstakingFee / 1000;\\r\\n    uint256 bridgingFeeAmt = rsCOMAIAmount * bridgingFee / 1000;\\r\\n    if(bridgingFeeAmt < 1 * (10 ** decimals())) bridgingFeeAmt = 1 * (10 ** decimals());\\r\\n    uint256 unstakingAmt = rsCOMAIAmount - bridgingFeeAmt - unstakingFeeAmt;\\r\\n    return (unstakingAmt, bridgingFeeAmt, unstakingFeeAmt);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Here we add utility functions so that\\r\\n   * we can perform checks using DRY principles\\r\\n   *\\r\\n   */\\r\\n\\r\\n  \\r\\n  /*\\r\\n   *\\r\\n   *\\r\\n   */\\r\\n  function _transferToVault(address from, uint256 _feeAmt) internal {\\r\\n    if(_feeAmt > 0) {\\r\\n      if(from == address(this)) {\\r\\n        require(\\r\\n          IERC20(wrappedToken).transfer(address(protocolVault), _feeAmt),\\r\\n          \\\"Transfer to protocol vault address failed\\\"\\r\\n        );\\r\\n      } else {\\r\\n        require(\\r\\n          IERC20(wrappedToken).transferFrom(from, address(protocolVault), _feeAmt),\\r\\n          \\\"Transfer to protocol vault address failed\\\"\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _transferToContract(uint256 _wrapAmt) internal {\\r\\n    if(_wrapAmt > 0) {\\r\\n      require(\\r\\n        IERC20(wrappedToken).transferFrom(msg.sender, address(this), _wrapAmt),\\r\\n        \\\"Transfer to contract address failed\\\"\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  // Check if the address is a non null address\\r\\n  // @param _address The address to check\\r\\n  // @param errorMessage The error message to display if the address is null\\r\\n  function _requireNonZeroAddress(address _address, string memory errorMessage)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    require(_address != address(0), errorMessage);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * this method is used to check if the native wallet receiver is valid\\r\\n   * Commume walllet must be 48 characters\\r\\n   *\\r\\n   * @param _nativeWalletReceiver The native wallet receiver to check\\r\\n   *\\r\\n   */\\r\\n  function _checkValidCommumeWallet(string memory _nativeWalletReceiver)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    require(\\r\\n      bytes(_nativeWalletReceiver).length == 48,\\r\\n      \\\"nativeWalletReceiver must be of length 48\\\"\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * Mints only if the max supply is exceeded\\r\\n   *\\r\\n   */\\r\\n\\r\\n  // Check if the contract is paused\\r\\n  modifier checkPaused() {\\r\\n    require(!isPaused, \\\"Contract is paused\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n\\r\\n  /*\\r\\n   * This function is used for users to request for unstaking\\r\\n   * When users request for unstaking, they will need to pay a fee\\r\\n   * The fee will be used to pay for the gas fees for the withdrawal manager\\r\\n   *\\r\\n   * After user successfully request for unstake, the withdrawal manage will\\r\\n   * need to approve the request before the user can unstake\\r\\n   *\\r\\n   * @params rsCOMAIAmt The amount of rsCOMAI to unstake\\r\\n   *\\r\\n   *\\r\\n   */\\r\\n  function requestUnstake(uint256 rsCOMAIAmt) public payable nonReentrant checkPaused {\\r\\n    // Check that wrappedToken and withdrawalManager is a valid address\\r\\n    _requireNonZeroAddress(\\r\\n      address(wrappedToken),\\r\\n      \\\"wrappedToken address is invalid\\\"\\r\\n    );\\r\\n    _requireNonZeroAddress(\\r\\n      address(withdrawalManager),\\r\\n      \\\"withdrawal address cannot be null\\\"\\r\\n    );\\r\\n\\r\\n    uint256 outWComaiAmt = getWCOMAIByrsCOMAI(rsCOMAIAmt);\\r\\n\\r\\n    // Ensure that the fee amount is sufficient\\r\\n    require(msg.value >= serviceFee, \\\"Fee amount is not sufficient\\\");\\r\\n    // Check if enough balance\\r\\n    require(balanceOf(msg.sender) >= rsCOMAIAmt, \\\"Insufficient rsCOMAI balance\\\");\\r\\n\\r\\n    uint256 length = unstakeRequests[msg.sender].length;\\r\\n    bool added = false;\\r\\n    // Loop throught the list of existing unstake requests\\r\\n    for (uint256 i = 0; i < length; i++) {\\r\\n      uint256 currAmt = unstakeRequests[msg.sender][i].amount;\\r\\n      if (currAmt > 0) {\\r\\n        continue;\\r\\n      } else {\\r\\n        // If the curr amt is zero, it means\\r\\n        // we can add the unstake request in this index\\r\\n        unstakeRequests[msg.sender][i] = UnstakeRequest({\\r\\n          amount: rsCOMAIAmt,\\r\\n          comaiAmt: outWComaiAmt,\\r\\n          isReadyForUnstake: false,\\r\\n          timestamp: block.timestamp,\\r\\n          wrappedToken: wrappedToken\\r\\n        });\\r\\n        added = true;\\r\\n        emit UserUnstakeRequested(\\r\\n          msg.sender,\\r\\n          i,\\r\\n          block.timestamp,\\r\\n          rsCOMAIAmt,\\r\\n          outWComaiAmt,\\r\\n          wrappedToken\\r\\n        );\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // If we have not added the unstake request, it means that\\r\\n    // we need to push a new unstake request into the array\\r\\n    if (!added) {\\r\\n      require(\\r\\n        unstakeRequests[msg.sender].length < maxUnstakeRequests,\\r\\n        \\\"Maximum unstake requests exceeded\\\"\\r\\n      );\\r\\n      unstakeRequests[msg.sender].push(\\r\\n        UnstakeRequest({\\r\\n          amount: rsCOMAIAmt,\\r\\n          comaiAmt: outWComaiAmt,\\r\\n          isReadyForUnstake: false,\\r\\n          timestamp: block.timestamp,\\r\\n          wrappedToken: wrappedToken\\r\\n        })\\r\\n      );\\r\\n      emit UserUnstakeRequested(\\r\\n        msg.sender,\\r\\n        length,\\r\\n        block.timestamp,\\r\\n        rsCOMAIAmt,\\r\\n        outWComaiAmt,\\r\\n        wrappedToken\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // Perform burn\\r\\n    _burnRsCOMAI(msg.sender, rsCOMAIAmt);\\r\\n    // transfer the service fee to the withdrawal manager\\r\\n    // withdrawalManager have already been checked to be a non zero address\\r\\n    // in the guard condition at start of function\\r\\n    bool success = payable(withdrawalManager).send(serviceFee);\\r\\n    require(success, \\\"Service fee transfer failed\\\");\\r\\n  }\\r\\n\\r\\n  function getUnstakeRequestByUser(address user)\\r\\n    public\\r\\n    view\\r\\n    returns (UnstakeRequest[] memory)\\r\\n  {\\r\\n    return unstakeRequests[user];\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This method shall be used to approve withdrawals by the user\\r\\n   * The withdrawal manager will need to approve the withdrawal.\\r\\n   *\\r\\n   * Note that multiple requests can be approved at once\\r\\n   *\\r\\n   * @params requests The list of requests to approve\\r\\n   *\\r\\n   *\\r\\n   */\\r\\n  function approveMultipleUnstakes(UserRequest[] calldata requests)\\r\\n    public\\r\\n    hasApproveWithdrawalRole\\r\\n    nonReentrant\\r\\n    checkPaused\\r\\n  {\\r\\n    uint256 totalRequiredComaiAmt = 0;\\r\\n    require(requests.length > 0, \\\"Requests array is empty\\\");\\r\\n    require(\\r\\n      requests[0].requestIndex < unstakeRequests[requests[0].user].length,\\r\\n      \\\"First request index out of bounds\\\"\\r\\n    );\\r\\n    // There might be cases that the underlying token might be different\\r\\n    // so we need to add checks to ensure that the unstaking is the same token\\r\\n    // across all indexes in the current requests UserRequest[] array\\r\\n    // If there is 2 different tokens underlying in the requests, we return the\\r\\n    // error as system is not designed to handle such a scenario.\\r\\n    // In that scenario, the user needs to unstake the tokens separately\\r\\n    // in two separate request\\r\\n    address commonWrappedToken = unstakeRequests[requests[0].user][requests[0].requestIndex].wrappedToken;\\r\\n\\r\\n    // Loop through each request to unstake and check if the request is valid\\r\\n    for (uint256 i = 0; i < requests.length; i++) {\\r\\n      UserRequest calldata request = requests[i];\\r\\n      require(\\r\\n        request.requestIndex < unstakeRequests[request.user].length,\\r\\n        \\\"Invalid request index\\\"\\r\\n      );\\r\\n      require(\\r\\n        unstakeRequests[request.user][request.requestIndex].amount > 0,\\r\\n        \\\"Request is invalid\\\"\\r\\n      );\\r\\n      require(\\r\\n        !unstakeRequests[request.user][request.requestIndex].isReadyForUnstake,\\r\\n        \\\"Request is already approved\\\"\\r\\n      );\\r\\n\\r\\n      // Check if wrappedToken is the same for all requests\\r\\n      require(\\r\\n        unstakeRequests[request.user][request.requestIndex].wrappedToken == commonWrappedToken,\\r\\n        \\\"Wrapped token is not the same across all unstake requests\\\"\\r\\n      );\\r\\n\\r\\n      (uint256 wcomaiAmt,,uint256 unstakingFeeAmt) = getWCOMAIByrsCOMAIAfterFee(unstakeRequests[request.user][request.requestIndex].comaiAmt);\\r\\n      totalRequiredComaiAmt = totalRequiredComaiAmt + wcomaiAmt + unstakingFeeAmt;\\r\\n    }\\r\\n\\r\\n    // Check if the sender has allowed the contract to spend enough tokens\\r\\n    require(\\r\\n      IERC20(commonWrappedToken).allowance(msg.sender, address(this)) >=\\r\\n        totalRequiredComaiAmt,\\r\\n      \\\"Insufficient token allowance\\\"\\r\\n    );\\r\\n\\r\\n    for (uint256 i = 0; i < requests.length; i++) {\\r\\n      UserRequest calldata request = requests[i];\\r\\n      unstakeRequests[request.user][request.requestIndex]\\r\\n        .isReadyForUnstake = true;\\r\\n    }\\r\\n\\r\\n    // Transfer the COMAI from the withdrawal manager to this contract\\r\\n    require(\\r\\n      IERC20(commonWrappedToken).transferFrom(\\r\\n        msg.sender,\\r\\n        address(this),\\r\\n        totalRequiredComaiAmt\\r\\n      ),\\r\\n      \\\"comaiAmt transfer failed\\\"\\r\\n    );\\r\\n\\r\\n    // Emit events after state changes and external interactions\\r\\n    for (uint256 i = 0; i < requests.length; i++) {\\r\\n      UserRequest calldata request = requests[i];\\r\\n      emit AdminUnstakeApproved(\\r\\n        request.user,\\r\\n        request.requestIndex,\\r\\n        block.timestamp\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This method shall be used by the user to unstake and withdraw the\\r\\n   * redeemed COMAI to their wallet\\r\\n   *\\r\\n   * @params requestIndex The index of the request to unstake\\r\\n   *\\r\\n   */\\r\\n  function unstake(uint256 requestIndex) public nonReentrant checkPaused {\\r\\n\\r\\n    require(\\r\\n      requestIndex < unstakeRequests[msg.sender].length,\\r\\n      \\\"Invalid request index\\\"\\r\\n    );\\r\\n    UnstakeRequest memory request = unstakeRequests[msg.sender][requestIndex];\\r\\n    require(request.amount > 0, \\\"No unstake request found\\\");\\r\\n    require(request.isReadyForUnstake, \\\"Unstake not approved yet\\\");\\r\\n\\r\\n    // Transfer wCOMAI tokens back to the user\\r\\n    (uint256 amountToTransfer,,uint256 unstakingFeeAmt) = getWCOMAIByrsCOMAIAfterFee(request.comaiAmt);\\r\\n    _transferToVault(address(this), unstakingFeeAmt);\\r\\n\\r\\n    // Update state to false\\r\\n    delete unstakeRequests[msg.sender][requestIndex];\\r\\n\\r\\n    // Perform ERC20 transfer\\r\\n    bool transferSuccessful = IERC20(request.wrappedToken).transfer(\\r\\n      msg.sender,\\r\\n      amountToTransfer\\r\\n    );\\r\\n    require(transferSuccessful, \\\"wCOMAI transfer failed\\\");\\r\\n\\r\\n    // Process the unstake event\\r\\n    emit UserUnstake(msg.sender, requestIndex, block.timestamp);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   *\\r\\n   * This method shall be used by the admin to exchange the market rate\\r\\n   * and the value of wCOMAI:RivusCOMAI.\\r\\n   *\\r\\n   * Owner shall be multisignature wallet\\r\\n   *\\r\\n   * @params newRate The new exchange rate\\r\\n   *\\r\\n   */\\r\\n  function updateExchangeRate(uint256 newRate) public hasExchangeUpdateRole {\\r\\n    require(newRate > 0, \\\"New rate must be more than 0\\\");\\r\\n    require(\\r\\n      newRate >= lowerExchangeRateBound && newRate <= upperExchangeRateBound,\\r\\n      \\\"New rate must be within bounds\\\"\\r\\n    );\\r\\n    // This also checks for newRate > 0 since lowerExchangeRateBound is always more than 0\\r\\n    // Recommended min lower and upper bound is define upon initialization\\r\\n    require(\\r\\n      lowerExchangeRateBound > 0 && upperExchangeRateBound > 0,\\r\\n      \\\"Bounds must be more than 0\\\"\\r\\n    );\\r\\n\\r\\n    exchangeRate = newRate;\\r\\n    emit UpdateExchangeRate(newRate);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   * This method calculates the amount of wCOMAI after deducting both\\r\\n   * the bridging fee and the staking fee\\r\\n   *\\r\\n   * In this calculation:\\r\\n   * 1. We first deduct the bridging fee from the wCOMAI amount\\r\\n   * 2. We then calculate the staking fee based on the amountAfterBridgingFee \\r\\n   * 3. We then deduct the staking fee from the amountAfterBridgingFee\\r\\n   *\\r\\n   * Note: \\r\\n   * 1. wCOMAIAmont must be bigger than bridgingFee \\r\\n   * 2. amountAfterTotalFees much be more than 0\\r\\n   *\\r\\n   */\\r\\n  function calculateAmtAfterFee(uint256 wcomaiAmount)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256, uint256, uint256)\\r\\n  {\\r\\n    require(\\r\\n      wcomaiAmount > bridgingFee,\\r\\n      \\\"wCOMAI amount must be more than bridging fee\\\"\\r\\n    );\\r\\n    uint256 _bridgeFee = wcomaiAmount * bridgingFee / 1000;\\r\\n    if(_bridgeFee < 1 * (10 ** decimals())) _bridgeFee = 1 * (10 ** decimals());\\r\\n    uint256 amountAfterBridgingFee = wcomaiAmount - _bridgeFee;\\r\\n\\r\\n    // Apply the staking fee as a percentage (e.g., 0.1%)\\r\\n    // Note: Multiply by 1000 to convert the decimal percentage to an integer\\r\\n    uint256 feeAmount = 0;\\r\\n    if(stakingFee > 0) {\\r\\n      /*\\r\\n       *\\r\\n       * Formula to calculate feeAmount. Note that there might be precision loss of\\r\\n       * 1 wei due to the division which is approx 4e-7 if COMAI is $400 which is negliglbe\\r\\n       * So we can accept this precision loss\\r\\n       *\\r\\n       */\\r\\n      feeAmount = (amountAfterBridgingFee * stakingFee) / 1000;\\r\\n    }\\r\\n\\r\\n    // Subtract the percentage-based staking fee from the amount after bridging fee\\r\\n    uint256 amountAfterTotalFees = amountAfterBridgingFee - feeAmount;\\r\\n\\r\\n    require(amountAfterTotalFees > 0, \\\"Wrap amount after fee must be more than 0\\\");\\r\\n\\r\\n    return (amountAfterTotalFees, _bridgeFee, feeAmount);\\r\\n  }\\r\\n\\r\\n  \\r\\n  /**\\r\\n    * @dev Mint RsCOMAI\\r\\n    */\\r\\n  function _mintRsCOMAI(\\r\\n      address _recipient,\\r\\n      uint256 _amount\\r\\n  ) internal {\\r\\n      uint256 sharesAmount = getSharesByMintedRsCOMAI(_amount);\\r\\n      if (sharesAmount == 0) {\\r\\n          //RsCOMAI totalSupply is 0: assume that shares correspond to RsCOMAI 1-to-1\\r\\n          sharesAmount = _amount;\\r\\n      }\\r\\n      _mintShares(_recipient, sharesAmount);\\r\\n      totalRsCOMAIMinted += _amount;\\r\\n      emit Mint(_recipient, _amount, block.timestamp);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @notice Burn _provideramount RsCOMAI to payback minted RsCOMAI for _provider.\\r\\n    */\\r\\n  function _burnRsCOMAI(\\r\\n      address _provider,\\r\\n      uint256 _amount\\r\\n  ) internal {\\r\\n      uint256 sharesAmount = getSharesByMintedRsCOMAI(_amount);\\r\\n      _burnShares(_provider, sharesAmount);\\r\\n      totalRsCOMAIMinted -= _amount;\\r\\n      emit Burn(_provider, _amount, block.timestamp);\\r\\n  }\\r\\n\\r\\n  /*\\r\\n   * This function shall be used by the user to wrap their wCOMAI tokens\\r\\n   * and get RivusCOMAI in return\\r\\n   *\\r\\n   * Note that stakingFee cna be 0% (0) so we do need to check for that\\r\\n   *\\r\\n   */\\r\\n  function wrap(uint256 wcomaiAmount) public nonReentrant checkPaused returns (uint256) {\\r\\n\\r\\n    require(\\r\\n      maxDepositPerRequest >= wcomaiAmount,\\r\\n      \\\"Deposit amount exceeds maximum\\\"\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      cap >= totalRsCOMAIMinted,\\r\\n      \\\"Deposit amount exceeds maximum\\\"\\r\\n    );\\r\\n\\r\\n    string memory _nativeWalletReceiver = nativeWalletReceiver;\\r\\n    IERC20 _wrappedToken = IERC20(wrappedToken);\\r\\n    // Check that the nativeWalletReceiver is not an empty string\\r\\n    _checkValidCommumeWallet(_nativeWalletReceiver);\\r\\n    _requireNonZeroAddress(\\r\\n      address(_wrappedToken),\\r\\n      \\\"wrappedToken address is invalid\\\"\\r\\n    );\\r\\n    require(\\r\\n      _wrappedToken.balanceOf(msg.sender) >= wcomaiAmount,\\r\\n      \\\"Insufficient wCOMAI balance\\\"\\r\\n    );\\r\\n\\r\\n    // Check to ensure that the protocol vault address is not zero\\r\\n    _requireNonZeroAddress(\\r\\n      address(protocolVault),\\r\\n      \\\"Protocol vault address cannot be 0\\\"\\r\\n    );\\r\\n\\r\\n    // Ensure that at least 15 COMAI is being bridged\\r\\n    // based on the smart contract\\r\\n    require(wcomaiAmount >= minStakingAmt, \\\"Does not meet minimum staking amount\\\");\\r\\n\\r\\n\\r\\n    // Ensure that the wrap amount after free is more than 0\\r\\n    (uint256 wrapAmountAfterFee, uint256 bridgeFeeAmt, uint256 feeAmt) = calculateAmtAfterFee(wcomaiAmount);\\r\\n\\r\\n    uint256 rsCOMAIAmount = getRsCOMAIbyWCOMAI(wrapAmountAfterFee);\\r\\n\\r\\n    // Perform token transfers\\r\\n    _mintRsCOMAI(msg.sender, rsCOMAIAmount);\\r\\n    _transferToVault(msg.sender, feeAmt);\\r\\n    uint256 amtToBridge = wrapAmountAfterFee + bridgeFeeAmt;\\r\\n    _transferToContract(amtToBridge);\\r\\n\\r\\n    bool success = IBridge(bridge).bridgeBack(amtToBridge, _nativeWalletReceiver);\\r\\n    require(success, \\\"Bridge back failed\\\");\\r\\n\\r\\n    emit UserStake(msg.sender, block.timestamp, wcomaiAmount, rsCOMAIAmount);\\r\\n    return rsCOMAIAmount;\\r\\n  }\\r\\n\\r\\n\\r\\n  function safePullERC20(\\r\\n    address tokenAddress,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) public hasTokenSafePullRole checkPaused {\\r\\n    _requireNonZeroAddress(to, \\\"Recipient address cannot be null address\\\");\\r\\n\\r\\n    require(amount > 0, \\\"Amount must be greater than 0\\\");\\r\\n\\r\\n    IERC20 token = IERC20(tokenAddress);\\r\\n    uint256 balance = token.balanceOf(address(this));\\r\\n    require(balance >= amount, \\\"Not enough tokens in contract\\\");\\r\\n\\r\\n    // \\\"to\\\" have been checked to be a non zero address\\r\\n    bool success = token.transfer(to, amount);\\r\\n    require(success, \\\"Token transfer failed\\\");\\r\\n    emit ERC20TokenPulled(tokenAddress, to, amount);\\r\\n  }\\r\\n\\r\\n  function pullNativeToken(address to, uint256 amount) public hasTokenSafePullRole checkPaused {\\r\\n    _requireNonZeroAddress(to, \\\"Recipient address cannot be null address\\\");\\r\\n    require(amount > 0, \\\"Amount must be greater than 0\\\");\\r\\n\\r\\n    uint256 balance = address(this).balance;\\r\\n    require(balance >= amount, \\\"Not enough native tokens in contract\\\");\\r\\n\\r\\n    // \\\"to\\\" have been checked to be a non zero address\\r\\n    (bool success, ) = to.call{ value: amount }(\\\"\\\");\\r\\n    require(success, \\\"Native token transfer failed\\\");\\r\\n    emit NativeTokenPulled(to, amount);\\r\\n  }\\r\\n  \\r\\n  function rebase(uint256 apr) external hasManageStakingConfigRole {\\r\\n    // uint256 totalSharesAmount = getTotalShares();\\r\\n    // uint256 burnAmount = totalSharesAmount * apr / 1000000 / 365;\\r\\n    // _burnSharesForOnlyRebase(burnAmount);\\r\\n    // lastRebaseTime = block.timestamp;\\r\\n    // emit Rebase(\\r\\n    //     apr,\\r\\n    //     totalSharesAmount,\\r\\n    //     burnAmount,\\r\\n    //     address(msg.sender),\\r\\n    //     block.timestamp\\r\\n    // );\\r\\n    uint256 mintAmount = totalRsCOMAIMinted * apr / 1000000 / 365;\\r\\n    totalRsCOMAIMinted = totalRsCOMAIMinted + mintAmount;\\r\\n    lastRebaseTime = block.timestamp;\\r\\n    emit Rebase(\\r\\n        apr,\\r\\n        totalRsCOMAIMinted,\\r\\n        getTotalShares(),\\r\\n        mintAmount,\\r\\n        block.timestamp\\r\\n    );\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/rsCOMAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./lib/SafeMath.sol\\\";\\r\\nimport \\\"./interface/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interest-bearing ERC20-like token for RivusCOMAI protocol.\\r\\n *\\r\\n * This contract is abstract. To make the contract deployable override the\\r\\n * `_getTotalMintedRsCOMAI` function. `RivusCOMAI.sol` contract inherits RsCOMAI and defines\\r\\n * the `_getTotalMintedRsCOMAI` function.\\r\\n *\\r\\n * RsCOMAI balances are dynamic and represent the holder's share in the total amount\\r\\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\\r\\n * contract also stores the sum of all shares to calculate each account's token balance\\r\\n * which equals to:\\r\\n *\\r\\n *   shares[account] * _getTotalMintedRsCOMAI() / _getTotalShares()\\r\\n *\\r\\n * For example, assume that we have:\\r\\n *\\r\\n *   _getTotalMintedRsCOMAI() -> 1000 RsCOMAI\\r\\n *   sharesOf(user1) -> 100\\r\\n *   sharesOf(user2) -> 400\\r\\n *\\r\\n * Therefore:\\r\\n *\\r\\n *   balanceOf(user1) -> 2 tokens which corresponds 200 RsCOMAI\\r\\n *   balanceOf(user2) -> 8 tokens which corresponds 800 RsCOMAI\\r\\n *\\r\\n * Since balances of all token holders change when the amount of total supplied RsCOMAI\\r\\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\\r\\n * events upon explicit transfer between holders. In contrast, when total amount of\\r\\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\\r\\n * emitting an event for each token holder and thus running an unbounded loop.\\r\\n */\\r\\nabstract contract RsCOMAI is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    uint256 private totalShares;\\r\\n\\r\\n    /**\\r\\n     * @dev RsCOMAI balances are dynamic and are calculated based on the accounts' shares\\r\\n     * and the total supply by the protocol. Account shares aren't\\r\\n     * normalized, so the contract also stores the sum of all shares to calculate\\r\\n     * each account's token balance which equals to:\\r\\n     *\\r\\n     *   shares[account] * _getTotalMintedRsCOMAI() / _getTotalShares()\\r\\n     */\\r\\n    mapping(address => uint256) private shares;\\r\\n\\r\\n    /**\\r\\n     * @dev Allowances are nominated in tokens, not token shares.\\r\\n     */\\r\\n    mapping(address => mapping(address => uint256)) private allowances;\\r\\n\\r\\n    /**\\r\\n     * @notice An executed shares transfer from `sender` to `recipient`.\\r\\n     *\\r\\n     * @dev emitted in pair with an ERC20-defined `Transfer` event.\\r\\n     */\\r\\n    event TransferShares(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 sharesValue\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice An executed `burnShares` request\\r\\n     *\\r\\n     * @dev Reports simultaneously burnt shares amount\\r\\n     * and corresponding RsCOMAI amount.\\r\\n     * The RsCOMAI amount is calculated twice: before and after the burning incurred rebase.\\r\\n     *\\r\\n     * @param account holder of the burnt shares\\r\\n     * @param preRebaseTokenAmount amount of RsCOMAI the burnt shares corresponded to before the burn\\r\\n     * @param postRebaseTokenAmount amount of RsCOMAI the burnt shares corresponded to after the burn\\r\\n     * @param sharesAmount amount of burnt shares\\r\\n     */\\r\\n    event SharesBurnt(\\r\\n        address indexed account,\\r\\n        uint256 preRebaseTokenAmount,\\r\\n        uint256 postRebaseTokenAmount,\\r\\n        uint256 sharesAmount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @return the name of the token.\\r\\n     */\\r\\n    function name() public pure returns (string memory) {\\r\\n        return \\\"Rivus Staked COMAI\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return \\\"rsCOMAI\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the number of decimals for getting user representation of a token amount.\\r\\n     */\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the amount of RsCOMAI in existence.\\r\\n     *\\r\\n     * @dev Always equals to `_getTotalMintedRsCOMAI()` since token amount\\r\\n     * is pegged to the total amount of RsCOMAI controlled by the protocol.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _getTotalMintedRsCOMAI();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the amount of tokens owned by the `_account`.\\r\\n     *\\r\\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\\r\\n     * total Ether controlled by the protocol. See `sharesOf`.\\r\\n     */\\r\\n    function balanceOf(address _account) public view returns (uint256) {\\r\\n        return getMintedRsCOMAIByShares(_sharesOf(_account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\\r\\n     *\\r\\n     * @return a boolean value indicating whether the operation succeeded.\\r\\n     * Emits a `Transfer` event.\\r\\n     * Emits a `TransferShares` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `_amount`.\\r\\n     * - the contract must not be paused.\\r\\n     *\\r\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\r\\n     */\\r\\n    function transfer(\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    ) public returns (bool) {\\r\\n        _transfer(msg.sender, _recipient, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the remaining number of tokens that `_spender` is allowed to spend\\r\\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\\r\\n     *\\r\\n     * @dev This value changes when `approve` or `transferFrom` is called.\\r\\n     */\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address _spender\\r\\n    ) public view returns (uint256) {\\r\\n        return allowances[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\\r\\n     *\\r\\n     * @return a boolean value indicating whether the operation succeeded.\\r\\n     * Emits an `Approval` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_spender` cannot be the zero address.\\r\\n     * - the contract must not be paused.\\r\\n     *\\r\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\r\\n     */\\r\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\r\\n        _approve(msg.sender, _spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\\r\\n     * allowance mechanism. `_amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * @return a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     * Emits a `TransferShares` event.\\r\\n     * Emits an `Approval` event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_sender` and `_recipient` cannot be the zero addresses.\\r\\n     * - `_sender` must have a balance of at least `_amount`.\\r\\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\\r\\n     * - the contract must not be paused.\\r\\n     *\\r\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address _sender,\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    ) public returns (bool) {\\r\\n        uint256 currentAllowance = allowances[_sender][msg.sender];\\r\\n        require(\\r\\n            currentAllowance >= _amount,\\r\\n            \\\"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\\\"\\r\\n        );\\r\\n\\r\\n        _transfer(_sender, _recipient, _amount);\\r\\n        _approve(_sender, msg.sender, currentAllowance.sub(_amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\\r\\n     *\\r\\n     * This is an alternative to `approve` that can be used as a mitigation for\\r\\n     * problems described in:\\r\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\\r\\n     * Emits an `Approval` event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_spender` cannot be the the zero address.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function increaseAllowance(\\r\\n        address _spender,\\r\\n        uint256 _addedValue\\r\\n    ) public returns (bool) {\\r\\n        _approve(\\r\\n            msg.sender,\\r\\n            _spender,\\r\\n            allowances[msg.sender][_spender].add(_addedValue)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\\r\\n     *\\r\\n     * This is an alternative to `approve` that can be used as a mitigation for\\r\\n     * problems described in:\\r\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\\r\\n     * Emits an `Approval` event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_spender` cannot be the zero address.\\r\\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function decreaseAllowance(\\r\\n        address _spender,\\r\\n        uint256 _subtractedValue\\r\\n    ) public returns (bool) {\\r\\n        uint256 currentAllowance = allowances[msg.sender][_spender];\\r\\n        require(\\r\\n            currentAllowance >= _subtractedValue,\\r\\n            \\\"DECREASED_ALLOWANCE_BELOW_ZERO\\\"\\r\\n        );\\r\\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the total amount of shares in existence.\\r\\n     *\\r\\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\\r\\n     * it is necessary to store it in order to calculate each account's relative share.\\r\\n     */\\r\\n    function getTotalShares() public view returns (uint256) {\\r\\n        return _getTotalShares();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the amount of shares owned by `_account`.\\r\\n     */\\r\\n    function sharesOf(address _account) public view returns (uint256) {\\r\\n        return _sharesOf(_account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the amount of shares that corresponds to `_RsCOMAIAmount` protocol-supplied RsCOMAI.\\r\\n     */\\r\\n    function getSharesByMintedRsCOMAI(\\r\\n        uint256 _RsCOMAIAmount\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 totalMintedRsCOMAI = _getTotalMintedRsCOMAI();\\r\\n        if (totalMintedRsCOMAI == 0) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return _RsCOMAIAmount.mul(_getTotalShares()).div(totalMintedRsCOMAI);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the amount of RsCOMAI that corresponds to `_sharesAmount` token shares.\\r\\n     */\\r\\n    function getMintedRsCOMAIByShares(\\r\\n        uint256 _sharesAmount\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 totalSharesAmount = _getTotalShares();\\r\\n        if (totalShares == 0) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return\\r\\n                _sharesAmount.mul(_getTotalMintedRsCOMAI()).div(totalSharesAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\\r\\n     *\\r\\n     * @return amount of transferred tokens.\\r\\n     * Emits a `TransferShares` event.\\r\\n     * Emits a `Transfer` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_recipient` cannot be the zero address.\\r\\n     * - the caller must have at least `_sharesAmount` shares.\\r\\n     * - the contract must not be paused.\\r\\n     *\\r\\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\\r\\n     */\\r\\n    function transferShares(\\r\\n        address _recipient,\\r\\n        uint256 _sharesAmount\\r\\n    ) public returns (uint256) {\\r\\n        _transferShares(msg.sender, _recipient, _sharesAmount);\\r\\n        emit TransferShares(msg.sender, _recipient, _sharesAmount);\\r\\n        uint256 tokensAmount = getMintedRsCOMAIByShares(_sharesAmount);\\r\\n        emit Transfer(msg.sender, _recipient, tokensAmount);\\r\\n        return tokensAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the total amount of RsCOMAI.\\r\\n     * @dev This is used for calculating tokens from shares and vice versa.\\r\\n     * @dev This function is required to be implemented in a derived contract.\\r\\n     */\\r\\n    function _getTotalMintedRsCOMAI() internal view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\\r\\n     * Emits a `Transfer` event.\\r\\n     * Emits a `TransferShares` event.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address _sender,\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    ) internal {\\r\\n        uint256 _sharesToTransfer = getSharesByMintedRsCOMAI(_amount);\\r\\n        _transferShares(_sender, _recipient, _sharesToTransfer);\\r\\n        emit Transfer(_sender, _recipient, _amount);\\r\\n        emit TransferShares(_sender, _recipient, _sharesToTransfer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_owner` cannot be the zero address.\\r\\n     * - `_spender` cannot be the zero address.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function _approve(\\r\\n        address _owner,\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    ) internal {\\r\\n        require(_owner != address(0), \\\"APPROVE_FROM_ZERO_ADDRESS\\\");\\r\\n        require(_spender != address(0), \\\"APPROVE_TO_ZERO_ADDRESS\\\");\\r\\n\\r\\n        allowances[_owner][_spender] = _amount;\\r\\n        emit Approval(_owner, _spender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the total amount of shares in existence.\\r\\n     */\\r\\n    function _getTotalShares() internal view returns (uint256) {\\r\\n        return totalShares;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the amount of shares owned by `_account`.\\r\\n     */\\r\\n    function _sharesOf(address _account) internal view returns (uint256) {\\r\\n        return shares[_account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_sender` cannot be the zero address.\\r\\n     * - `_recipient` cannot be the zero address.\\r\\n     * - `_sender` must hold at least `_sharesAmount` shares.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function _transferShares(\\r\\n        address _sender,\\r\\n        address _recipient,\\r\\n        uint256 _sharesAmount\\r\\n    ) internal {\\r\\n        require(_sender != address(0), \\\"TRANSFER_FROM_THE_ZERO_ADDRESS\\\");\\r\\n        require(_recipient != address(0), \\\"TRANSFER_TO_THE_ZERO_ADDRESS\\\");\\r\\n\\r\\n        uint256 currentSenderShares = shares[_sender];\\r\\n        require(\\r\\n            _sharesAmount <= currentSenderShares,\\r\\n            \\\"TRANSFER_AMOUNT_EXCEEDS_BALANCE\\\"\\r\\n        );\\r\\n\\r\\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\\r\\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\\r\\n     * @dev This doesn't increase the token total supply.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_recipient` cannot be the zero address.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function _mintShares(\\r\\n        address _recipient,\\r\\n        uint256 _sharesAmount\\r\\n    ) internal returns (uint256 newTotalShares) {\\r\\n        require(_recipient != address(0), \\\"MINT_TO_THE_ZERO_ADDRESS\\\");\\r\\n\\r\\n        uint256 _amount = getMintedRsCOMAIByShares(_sharesAmount);\\r\\n        if (_amount == 0) {\\r\\n            //RsCOMAI totalSupply is 0: assume that shares correspond to RsCOMAI 1-to-1\\r\\n            _amount = _sharesAmount;\\r\\n        }\\r\\n        newTotalShares = _getTotalShares().add(_sharesAmount);\\r\\n        totalShares = newTotalShares;\\r\\n\\r\\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\\r\\n\\r\\n        emit Transfer(address(0), _recipient, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\\r\\n     * @dev This doesn't decrease the token total supply.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_account` cannot be the zero address.\\r\\n     * - `_account` must hold at least `_sharesAmount` shares.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function _burnShares(\\r\\n        address _account,\\r\\n        uint256 _sharesAmount\\r\\n    ) internal returns (uint256 newTotalShares) {\\r\\n        require(_account != address(0), \\\"BURN_FROM_THE_ZERO_ADDRESS\\\");\\r\\n\\r\\n        uint256 accountShares = shares[_account];\\r\\n        require(_sharesAmount <= accountShares, \\\"BURN_AMOUNT_EXCEEDS_BALANCE\\\");\\r\\n\\r\\n        uint256 preRebaseTokenAmount = getMintedRsCOMAIByShares(_sharesAmount);\\r\\n\\r\\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\\r\\n        totalShares = newTotalShares;\\r\\n\\r\\n        shares[_account] = accountShares.sub(_sharesAmount);\\r\\n\\r\\n        uint256 postRebaseTokenAmount = getMintedRsCOMAIByShares(_sharesAmount);\\r\\n\\r\\n        emit SharesBurnt(\\r\\n            _account,\\r\\n            preRebaseTokenAmount,\\r\\n            postRebaseTokenAmount,\\r\\n            _sharesAmount\\r\\n        );\\r\\n        emit Transfer(_account, address(0), preRebaseTokenAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\\r\\n     * @dev This doesn't decrease the token total supply.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_account` cannot be the zero address.\\r\\n     * - `_account` must hold at least `_sharesAmount` shares.\\r\\n     * - the contract must not be paused.\\r\\n     */\\r\\n    function _burnSharesForOnlyRebase(\\r\\n        uint256 _sharesAmount\\r\\n    ) internal returns (uint256 newTotalShares) {\\r\\n        uint256 preRebaseTokenAmount = getMintedRsCOMAIByShares(_sharesAmount);\\r\\n\\r\\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\\r\\n        totalShares = newTotalShares;\\r\\n\\r\\n        uint256 postRebaseTokenAmount = getMintedRsCOMAIByShares(_sharesAmount);\\r\\n\\r\\n        emit SharesBurnt(\\r\\n            address(this),\\r\\n            preRebaseTokenAmount,\\r\\n            postRebaseTokenAmount,\\r\\n            _sharesAmount\\r\\n        );\\r\\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\\r\\n        // works by redistributing the amount of tokens corresponding to the burned shares between\\r\\n        // all other token holders. The total supply of the token doesn't change as the result.\\r\\n        // This is equivalent to performing a send from `address` to each other token holder address,\\r\\n        // but we cannot reflect this as it would require sending an unbounded number of events.\\r\\n\\r\\n        // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvedTimestamp\",\"type\":\"uint256\"}],\"name\":\"AdminUnstakeApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"ContractPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20TokenPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLowerBound\",\"type\":\"uint256\"}],\"name\":\"LowerBoundUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NativeTokenPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRsCOMAIMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmoount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Rebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"preRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"postRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"SharesBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesValue\",\"type\":\"uint256\"}],\"name\":\"TransferShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgingFee\",\"type\":\"uint256\"}],\"name\":\"UpdateBridgeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"UpdateExchangeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxDepositPerRequest\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxDepositPerRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUnstakeRequests\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxUnstakeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minStakingAmt\",\"type\":\"uint256\"}],\"name\":\"UpdateMinStakingAmt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newNativeWalletReceiver\",\"type\":\"string\"}],\"name\":\"UpdateNativeCommumeReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newProtocolVault\",\"type\":\"address\"}],\"name\":\"UpdateProtocolVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"serviceFee\",\"type\":\"uint256\"}],\"name\":\"UpdateServiceFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingFee\",\"type\":\"uint256\"}],\"name\":\"UpdateStakingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUnstakingFee\",\"type\":\"uint256\"}],\"name\":\"UpdateUnstakingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWCOMAI\",\"type\":\"address\"}],\"name\":\"UpdateWComai\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawalManager\",\"type\":\"address\"}],\"name\":\"UpdateWithdrawalManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUpperBound\",\"type\":\"uint256\"}],\"name\":\"UpperBoundUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inComaiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wstAmount\",\"type\":\"uint256\"}],\"name\":\"UserStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakeTimestamp\",\"type\":\"uint256\"}],\"name\":\"UserUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wstAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outComaiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"UserUnstakeRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APPROVE_WITHDRAWAL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXCHANGE_UPDATE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGE_STAKING_CONFIG_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_SAFE_PULL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct RivusCOMAI.UserRequest[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"name\":\"approveMultipleUnstakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wcomaiAmount\",\"type\":\"uint256\"}],\"name\":\"calculateAmtAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"getMintedRsCOMAIByShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wcomaiAmount\",\"type\":\"uint256\"}],\"name\":\"getRsCOMAIbyWCOMAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_RsCOMAIAmount\",\"type\":\"uint256\"}],\"name\":\"getSharesByMintedRsCOMAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUnstakeRequestByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"comaiAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReadyForUnstake\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct RivusCOMAI.UnstakeRequest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rsCOMAIAmount\",\"type\":\"uint256\"}],\"name\":\"getWCOMAIByrsCOMAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rsCOMAIAmount\",\"type\":\"uint256\"}],\"name\":\"getWCOMAIByrsCOMAIAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wCOMAI\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_nativeTokenReceiver\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_protocolVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerExchangeRateBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDepositPerRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnstakeRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakingAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeWalletReceiver\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullNativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"}],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rsCOMAIAmt\",\"type\":\"uint256\"}],\"name\":\"requestUnstake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"safePullERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bridgingFee\",\"type\":\"uint256\"}],\"name\":\"setBridgingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLowerBound\",\"type\":\"uint256\"}],\"name\":\"setLowerExchangeRateBound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDepositPerRequest\",\"type\":\"uint256\"}],\"name\":\"setMaxDepositPerRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxUnstakeRequests\",\"type\":\"uint256\"}],\"name\":\"setMaxUnstakeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakingAmt\",\"type\":\"uint256\"}],\"name\":\"setMinStakingAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nativeWalletReceiver\",\"type\":\"string\"}],\"name\":\"setNativeTokenReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolVault\",\"type\":\"address\"}],\"name\":\"setProtocolVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceFee\",\"type\":\"uint256\"}],\"name\":\"setServiceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingFee\",\"type\":\"uint256\"}],\"name\":\"setStakingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unstakingFee\",\"type\":\"uint256\"}],\"name\":\"setUnstakingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newUpperBound\",\"type\":\"uint256\"}],\"name\":\"setUpperExchangeRateBound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wCOMAI\",\"type\":\"address\"}],\"name\":\"setWCOMAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawalManager\",\"type\":\"address\"}],\"name\":\"setWithdrawalManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRsCOMAIMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"transferShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unstakeRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"comaiAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReadyForUnstake\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"updateBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCap\",\"type\":\"uint256\"}],\"name\":\"updateCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperExchangeRateBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wcomaiAmount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RivusCOMAI", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}