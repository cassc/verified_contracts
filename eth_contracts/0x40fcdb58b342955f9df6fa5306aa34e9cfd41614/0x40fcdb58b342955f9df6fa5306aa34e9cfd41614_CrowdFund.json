{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract CrowdFund is ReentrancyGuard, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public _minimumContribution;\r\n    uint256 public _maximumContribution;\r\n    uint256 public _deadline; //seconds\r\n    uint256 public _targetGoal;\r\n    uint256 public _raisedAmount;\r\n    uint256 public _totalContributors;\r\n    uint256 public _price;\r\n    uint256 public _crowdFundDuration;\r\n    uint256 public _extensionTimes = 0;\r\n    bool public _emergencyRefundEnabled;\r\n\r\n    address[] private _contributorsList;\r\n    mapping(address => uint256) public _contributors;\r\n\r\n    mapping(address => uint256) public _refundableAmount;\r\n\r\n    event RefundRequested(address contributor, uint256 amount);\r\n    event RefundWithdrawn(address contributor, uint256 amount);\r\n\r\n    enum ContractState {\r\n        Paused,\r\n        Active,\r\n        Refunding\r\n    }\r\n    ContractState public _currentState;\r\n\r\n    event DepositsEnabled();\r\n    event DepositsPaused();\r\n    event RefundEnabled();\r\n    event ContributionMade(address contributor, uint256 amount);\r\n    event RefundIssued(address contributor, uint256 amount);\r\n    event FundsWithdrawn(uint256 amount);\r\n    event MinimumContributionChanged(uint256 newMinimum);\r\n    event MaximumContributionChanged(uint256 newMaximum);\r\n    event DeadlineExtended();\r\n\r\n    constructor(\r\n        uint256 targetGoal_,\r\n        uint256 crowdFundDuration_,\r\n        uint256 price_,\r\n        uint256 minimumContribution_,\r\n        uint256 maximumContribution_\r\n    ) Ownable() {\r\n        require(targetGoal_ > 0, \"Target goal must be greater than zero\");\r\n        require(crowdFundDuration_ > 0, \"Duration  must be greater than zero\");\r\n        require(price_ > 0, \"Price must be greater than zero\");\r\n        require(\r\n            minimumContribution_ > 0,\r\n            \"Minimum contribution must be greater than zero\"\r\n        );\r\n        require(\r\n            maximumContribution_ >= minimumContribution_,\r\n            \"Maximum contribution must be greater than or equal to minimum contribution\"\r\n        );\r\n\r\n        _deadline = block.timestamp + crowdFundDuration_;\r\n        _crowdFundDuration = crowdFundDuration_;\r\n        _targetGoal = targetGoal_;\r\n        _minimumContribution = minimumContribution_;\r\n        _maximumContribution = maximumContribution_;\r\n        _price = price_;\r\n        _currentState = ContractState.Active;\r\n        _emergencyRefundEnabled = false;\r\n    }\r\n\r\n    function enableEmergencyRefund() external onlyOwner {\r\n        require(!_emergencyRefundEnabled, \"Emergency Refund already enabled\");\r\n        _emergencyRefundEnabled = true;\r\n    }\r\n\r\n    function enableDeposits() public onlyOwner {\r\n        require(\r\n            _currentState != ContractState.Active,\r\n            \"The deposits are already active\"\r\n        );\r\n        _currentState = ContractState.Active;\r\n        emit DepositsEnabled();\r\n    }\r\n\r\n    function pauseDeposits() public onlyOwner {\r\n        require(\r\n            _currentState != ContractState.Paused,\r\n            \"The deposits are already paused\"\r\n        );\r\n        _currentState = ContractState.Paused;\r\n        emit DepositsPaused();\r\n    }\r\n\r\n    function enableRefunds() public onlyOwner {\r\n        require(\r\n            _currentState != ContractState.Refunding,\r\n            \"Refunding is already enabled\"\r\n        );\r\n        _currentState = ContractState.Refunding;\r\n        emit RefundEnabled();\r\n    }\r\n\r\n    function getTokenAmount(address contributor) public view returns (uint256) {\r\n        uint256 contribution = _contributors[contributor];\r\n        return contribution / _price;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function contribute() public payable nonReentrant {\r\n        require(\r\n            block.timestamp < _deadline,\r\n            \"Crowd Funding deadline has passed.\"\r\n        );\r\n        require(\r\n            _currentState == ContractState.Active,\r\n            \"Contract is not active\"\r\n        );\r\n        require(\r\n            msg.value >= _minimumContribution,\r\n            \"Contribution is less than the minimum required amount.\"\r\n        );\r\n\r\n        uint256 newContribution = _contributors[msg.sender] + msg.value;\r\n        require(\r\n            newContribution <= _maximumContribution,\r\n            \"Contribution exceeds the maximum allowed amount.\"\r\n        );\r\n\r\n        uint256 newTotalRaised = _raisedAmount + msg.value;\r\n        require(\r\n            newTotalRaised <= _targetGoal,\r\n            \"Contribution would exceed the target amount.\"\r\n        );\r\n\r\n        if (_contributors[msg.sender] == 0) {\r\n            _totalContributors++;\r\n            _contributorsList.push(msg.sender);\r\n        }\r\n\r\n        _contributors[msg.sender] = newContribution;\r\n        _raisedAmount += msg.value;\r\n\r\n        emit ContributionMade(msg.sender, msg.value);\r\n    }\r\n\r\n    function requestRefund(address contributor) public onlyOwner {\r\n        require(_contributors[contributor] > 0, \"Not a contributor\");\r\n        require(\r\n            _currentState == ContractState.Refunding,\r\n            \"Refunds are not currently enabled\"\r\n        );\r\n\r\n        uint256 amount = _contributors[contributor];\r\n        _contributors[contributor] = 0;\r\n        _raisedAmount = _raisedAmount.sub(amount);\r\n        _refundableAmount[contributor] = amount;\r\n\r\n        removeContributor(contributor);\r\n\r\n        emit RefundRequested(contributor, amount);\r\n    }\r\n\r\n    function withdrawRefund() public nonReentrant {\r\n        uint256 amount;\r\n\r\n        if (_emergencyRefundEnabled) {\r\n            amount = _contributors[msg.sender];\r\n            require(amount > 0, \"No contribution found\");\r\n            _contributors[msg.sender] = 0; // Zero out the contribution\r\n        } else {\r\n            amount = _refundableAmount[msg.sender];\r\n            require(amount > 0, \"No refund available\");\r\n            _refundableAmount[msg.sender] = 0; // Clear the refundable amount\r\n        }\r\n\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Insufficient contract balance\"\r\n        );\r\n\r\n        if (_raisedAmount >= amount) {\r\n            _raisedAmount -= amount; // Update total raised amount\r\n        } else {\r\n            _raisedAmount = 0; // Set to zero if amount is greater than _raisedAmount\r\n        }\r\n\r\n        removeContributor(msg.sender); // Remove from contributors list\r\n\r\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n\r\n        emit RefundWithdrawn(msg.sender, amount);\r\n    }\r\n\r\n    function getRefundableAmount(\r\n        address contributor\r\n    ) public view returns (uint256) {\r\n        return _refundableAmount[contributor];\r\n    }\r\n\r\n    function ownerWithdraw() public onlyOwner nonReentrant {\r\n        uint256 amount = address(this).balance;\r\n\r\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n\r\n        emit FundsWithdrawn(amount);\r\n    }\r\n\r\n    function setMinimumContribution(uint256 newMinimum) public onlyOwner {\r\n        require(\r\n            newMinimum <= _maximumContribution,\r\n            \"Minimum contribution cannot be greater than maximum contribution\"\r\n        );\r\n        _minimumContribution = newMinimum;\r\n        emit MinimumContributionChanged(newMinimum);\r\n    }\r\n\r\n    function setMaximumContribution(uint256 newMaximum) public onlyOwner {\r\n        require(\r\n            newMaximum >= _minimumContribution,\r\n            \"Maximum contribution cannot be less than minimum contribution\"\r\n        );\r\n        _maximumContribution = newMaximum;\r\n        emit MaximumContributionChanged(newMaximum);\r\n    }\r\n\r\n    function extendDeadline() public onlyOwner {\r\n        require(\r\n            _extensionTimes < 3,\r\n            \"you have reached the maximum amount of extension times\"\r\n        );\r\n\r\n        _deadline += _crowdFundDuration;\r\n        _extensionTimes += 1;\r\n\r\n        emit DeadlineExtended();\r\n    }\r\n\r\n    function removeContributor(address contributor) private {\r\n        for (uint i = 0; i < _contributorsList.length; i++) {\r\n            if (_contributorsList[i] == contributor) {\r\n                _contributorsList[i] = _contributorsList[\r\n                    _contributorsList.length - 1\r\n                ];\r\n                _contributorsList.pop();\r\n                _totalContributors--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getContributorsList() public view returns (address[] memory) {\r\n        return _contributorsList;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetGoal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crowdFundDuration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumContribution_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumContribution_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContributionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DeadlineExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DepositsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DepositsPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaximum\",\"type\":\"uint256\"}],\"name\":\"MaximumContributionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinimum\",\"type\":\"uint256\"}],\"name\":\"MinimumContributionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contributors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_crowdFundDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_currentState\",\"outputs\":[{\"internalType\":\"enum CrowdFund.ContractState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_deadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_emergencyRefundEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_extensionTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maximumContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minimumContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_raisedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_refundableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_targetGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalContributors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableEmergencyRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableRefunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extendDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContributorsList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"getRefundableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"requestRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaximum\",\"type\":\"uint256\"}],\"name\":\"setMaximumContribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimum\",\"type\":\"uint256\"}],\"name\":\"setMinimumContribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CrowdFund", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000007735cf7cfc9b00000000000000000000000000000000000000000000000000000000000000127500000000000000000000000000000000000000000000000000000001084345960000000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000000000000000000000000000000de0b6b3a7640000", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2c3a5c07c277c4b745b8cbde83245f809022828631cc72277e40afb3f653ba2a"}