{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n/**\r\n WELCOME TO ZE DICE ROULETTE.\r\n DIVE INTO THE WORLD OF PUMPMENTAL BETTING.\r\n\r\n\r\n    .-------.\r\n   / *   * /|\r\n  / *   * / |\r\n .-------.* |\r\n | *   * | *.\r\n | *   * | /\r\n | *   * |/\r\n '-------'\r\n\r\nWebsite: https://wagerzz.gg/\r\nTelegram: https://t.me/wagerZz_gg\r\nX: https://twitter.com/wagerzz_gg\r\n**/\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.2\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/TelegramDiceRoulette/telegramDiceRoulette.sol\r\n\r\n\r\n/**\r\n WELCOME TO ZE DICE ROULETTE.\r\n DIVE INTO THE WORLD OF PUMPMENTAL BETTING.\r\n\r\n\r\n    .-------.\r\n   / *   * /|\r\n  / *   * / |\r\n .-------.* |\r\n | *   * | *.\r\n | *   * | /\r\n | *   * |/\r\n '-------'\r\n\r\nWebsite: https://wagerzz.gg/\r\nTelegram: https://t.me/wagerZz_gg\r\nX: https://twitter.com/wagerzz_gg\r\n**/\r\n\r\npragma solidity 0.8.15;\r\n\r\ncontract TelegramDiceRoulette {\r\n\r\n    IERC20 public bettingToken;\r\n    address public owner;\r\n    address public collectorWallet;\r\n    uint16 public protocolFeeBps = 0; // 1% (100 basis points)\r\n    uint16 public burnBps = 0;    // 1% (100 basis points)\r\n    address public maintainer;\r\n    uint32 private cardIdCounter = 0;\r\n    // Mapping from the player's Ethereum address to their unique cardId\r\n    mapping(address => uint32) public playerCards;\r\n\r\n    struct Game {\r\n        bool inProgress;\r\n        address[] players;\r\n        uint256[] bets;\r\n        bytes32 hashedPredictedOutcomes;\r\n        address[] winners;\r\n    }\r\n\r\n    mapping(int64 => Game) public games;\r\n    int64[] public allTgChats;\r\n\r\n    event NewGame(int64 indexed tgChatId, address indexed player, uint256 betAmount, bytes32 hashedPredictedOutcomes);\r\n    event Win(int64 indexed tgChatId, address indexed winner, uint256 amountWon);\r\n    event Collected(int64 indexed tgChatId, uint256 amount);\r\n    event Burn(int64 indexed tgChatId, uint256 amount);\r\n    event GameAborted(int64 indexed tgChatId);\r\n\r\n    modifier onlyOwnerOrMaintainer() {\r\n        require(msg.sender == owner || msg.sender == maintainer, \"Not the owner or maintainer\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the contract owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _bettingToken, address _collectorWallet, address _maintainer) {\r\n        bettingToken = IERC20(_bettingToken);\r\n        collectorWallet = _collectorWallet;\r\n        owner = msg.sender;\r\n        maintainer = _maintainer;\r\n    }\r\n\r\n    function setParameters(uint16 _protocolFeeBps, uint16 _burnBps, address _collectorWallet) public onlyOwner {\r\n        require(_protocolFeeBps + _burnBps <= 10000, \"Total BPS can't exceed 10000\");\r\n        protocolFeeBps = _protocolFeeBps;\r\n        burnBps = _burnBps;\r\n        collectorWallet = _collectorWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new player card for the caller and assign a unique cardId\r\n     * @param secret The secret that the bot is expecting.\r\n     * @return The assigned cardId for the new player card\r\n     */\r\n    function createPlayerCard(uint32 secret) external returns (uint32) {\r\n        // Check if the user already has a player card\r\n        require(playerCards[msg.sender] == 0, \"User already has a player card\");\r\n        // Increment the cardId counter\r\n        cardIdCounter++;\r\n        // Assign the new cardId to the caller's address\r\n        playerCards[msg.sender] = cardIdCounter;\r\n        // Return the assigned cardId to the caller\r\n        return cardIdCounter;\r\n    }\r\n\r\n    function newGame(int64 _tgChatId, address[] memory _players, uint256[] memory _bets, bytes32 _hashedPredictedOutcomes) public onlyOwnerOrMaintainer {\r\n        require(_players.length == _bets.length, \"Players and bets arrays length mismatch\");\r\n        require(!games[_tgChatId].inProgress, \"Game already in progress for this chat ID\");\r\n\r\n        uint256 totalTransferred = 0;\r\n        for (uint16 i = 0; i < _players.length; i++) {\r\n            require(bettingToken.transferFrom(_players[i], address(this), _bets[i]), \"Token transfer failed\");\r\n            totalTransferred += _bets[i];\r\n        }\r\n\r\n        games[_tgChatId] = Game({\r\n        inProgress: true,\r\n        players: _players,\r\n        bets: _bets,\r\n        hashedPredictedOutcomes: _hashedPredictedOutcomes,\r\n        winners: new address[](0)\r\n        });\r\n        allTgChats.push(_tgChatId);\r\n\r\n        emit NewGame(_tgChatId, msg.sender, totalTransferred, _hashedPredictedOutcomes);\r\n    }\r\n\r\n    function endGame(int64 _tgChatId, address[] memory winners) public onlyOwnerOrMaintainer {\r\n        require(games[_tgChatId].inProgress, \"No game in progress for this chat ID.\");\r\n\r\n        uint256 totalPot = 0;\r\n        uint256 totalWinningBets = 0;\r\n        uint256 fees = 0;\r\n        uint256 burnAmount = 0;\r\n        uint256 distributablePot = 0;\r\n        uint256[] memory winnerBets = new uint256[](winners.length);\r\n\r\n        for (uint16 i = 0; i < games[_tgChatId].players.length; i++) {\r\n            totalPot += games[_tgChatId].bets[i];\r\n        }\r\n\r\n        // Calculate total winning bets and store individual winner bets\r\n        for (uint16 i = 0; i < winners.length; i++) {\r\n            for (uint16 j = 0; j < games[_tgChatId].players.length; j++) {\r\n                if (winners[i] == games[_tgChatId].players[j]) {\r\n                    totalWinningBets += games[_tgChatId].bets[j];\r\n                    winnerBets[i] = games[_tgChatId].bets[j];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        fees = (totalPot * protocolFeeBps) / 10000;\r\n        burnAmount = (totalPot * burnBps) / 10000;\r\n        distributablePot = totalPot - fees - burnAmount;\r\n\r\n        // Distribute the winnings proportionally based on each winner's bet\r\n        for (uint16 i = 0; i < winners.length; i++) {\r\n            uint256 playerWinnings = (winnerBets[i] * distributablePot) / totalWinningBets;\r\n            require(bettingToken.transfer(winners[i], playerWinnings), \"Winnings transfer failed.\");\r\n            emit Win(_tgChatId, winners[i], playerWinnings);\r\n        }\r\n\r\n        // Transfer fees and burn amounts\r\n        if (fees > 0) {\r\n            require(bettingToken.transfer(collectorWallet, fees), \"protcol fee transfer failed.\");\r\n            emit Collected(_tgChatId, fees);\r\n        }\r\n        if (burnAmount > 0) {\r\n            require(bettingToken.transfer(address(0xdead), burnAmount), \"burnAmount transfer failed.\");\r\n            emit Burn(_tgChatId, burnAmount);\r\n        }\r\n\r\n        // Update the game details with the winners and mark the game as ended\r\n        games[_tgChatId].winners = winners;\r\n        games[_tgChatId].inProgress = false;\r\n    }\r\n\r\n    function abortGame(int64 _tgChatId) public onlyOwnerOrMaintainer {\r\n        require(games[_tgChatId].inProgress, \"No game in progress for this chat ID.\");\r\n\r\n        for (uint16 i = 0; i < games[_tgChatId].players.length; i++) {\r\n            require(bettingToken.transfer(games[_tgChatId].players[i], games[_tgChatId].bets[i]), \"Refund transfer failed.\");\r\n        }\r\n\r\n        games[_tgChatId].inProgress = false;\r\n        emit GameAborted(_tgChatId);\r\n    }\r\n\r\n    function abortAllGames() public onlyOwnerOrMaintainer {\r\n        for (uint256 i = 0; i < allTgChats.length; i++) {\r\n            int64 tgChatId = allTgChats[i];\r\n            if (games[tgChatId].inProgress) {\r\n                abortGame(tgChatId);\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeTgId(int64 _tgChatId) public onlyOwnerOrMaintainer {\r\n        require(!games[_tgChatId].inProgress, \"Game still in progress for this chat ID.\");\r\n        delete games[_tgChatId];\r\n    }\r\n\r\n    function isGameInProgress(int64 _tgChatId) public view returns (bool) {\r\n        return games[_tgChatId].inProgress;\r\n    }\r\n\r\n    function setMaintainer(address _newMaintainer) public onlyOwner {\r\n        maintainer = _newMaintainer;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bettingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collectorWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_maintainer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int64\",\"name\":\"tgChatId\",\"type\":\"int64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int64\",\"name\":\"tgChatId\",\"type\":\"int64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Collected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int64\",\"name\":\"tgChatId\",\"type\":\"int64\"}],\"name\":\"GameAborted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int64\",\"name\":\"tgChatId\",\"type\":\"int64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hashedPredictedOutcomes\",\"type\":\"bytes32\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int64\",\"name\":\"tgChatId\",\"type\":\"int64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWon\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"abortAllGames\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int64\",\"name\":\"_tgChatId\",\"type\":\"int64\"}],\"name\":\"abortGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTgChats\",\"outputs\":[{\"internalType\":\"int64\",\"name\":\"\",\"type\":\"int64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bettingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnBps\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectorWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"secret\",\"type\":\"uint32\"}],\"name\":\"createPlayerCard\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int64\",\"name\":\"_tgChatId\",\"type\":\"int64\"},{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"name\":\"endGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int64\",\"name\":\"\",\"type\":\"int64\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"inProgress\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"hashedPredictedOutcomes\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int64\",\"name\":\"_tgChatId\",\"type\":\"int64\"}],\"name\":\"isGameInProgress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maintainer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int64\",\"name\":\"_tgChatId\",\"type\":\"int64\"},{\"internalType\":\"address[]\",\"name\":\"_players\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bets\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"_hashedPredictedOutcomes\",\"type\":\"bytes32\"}],\"name\":\"newGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerCards\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeBps\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int64\",\"name\":\"_tgChatId\",\"type\":\"int64\"}],\"name\":\"removeTgId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaintainer\",\"type\":\"address\"}],\"name\":\"setMaintainer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_protocolFeeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_burnBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_collectorWallet\",\"type\":\"address\"}],\"name\":\"setParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TelegramDiceRoulette", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bbb1fd3320f1fe124c6288ca2009ba782b618e03000000000000000000000000f39814aabd898737356a71ce83442eea005042f800000000000000000000000016719d5a9512e1b1628ad2992c08f2964eabe367", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cae68c365895193b4a306290be93c611536a302cd76a7af513e98962e2609c75"}