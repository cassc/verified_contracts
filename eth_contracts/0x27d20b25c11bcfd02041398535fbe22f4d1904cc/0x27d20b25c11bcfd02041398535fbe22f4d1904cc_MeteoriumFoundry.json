{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC721A {\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function burn(uint256) external;\r\n    function ownershipOf(uint256) external view returns (TokenOwnership memory);\r\n}\r\n\r\ninterface IMeteorium {\r\n    function mint(address, uint256) external;\r\n    function burn(uint256 tokenId, bytes calldata signature) external;\r\n}\r\n\r\nstruct TokenOwnership {\r\n    address addr;\r\n    uint64 startTimestamp;\r\n    bool burned;\r\n    uint24 extraData;\r\n}\r\n\r\n/**\r\n * Burn, burn, burn, BUUUUUURN!\r\n */\r\ncontract MeteoriumFoundry is Ownable {\r\n    error TransferFailed();\r\n    error ForgingDisabledForType();\r\n    error NotEnoughTokenIdsGiven();\r\n    error IncorrectTokenIdsAmountGiven();\r\n    error NotTokenOwner();\r\n    error IncorrectETHValue();\r\n    error TokenIdNotInBounds();\r\n    error NotHoldingForLongEnough();\r\n\r\n    struct FoundryRequirements {\r\n        bool enabled;\r\n        uint32 mtoHoldTime;\r\n        uint8 reqMto;\r\n        bool isMtoTribute;\r\n        uint16 minMtoId;\r\n        uint16 maxMtoId;\r\n        uint32 mtomHoldTime;\r\n        uint8 reqMtom;\r\n        bool isMtomTribute;\r\n        uint16 minMtomId;\r\n        uint16 maxMtomId;\r\n        uint64 price;\r\n    }\r\n\r\n    mapping(uint256 => FoundryRequirements) public forgeRequirements;\r\n\r\n    address private immutable _MTO;\r\n    address private immutable _MTOM;\r\n\r\n    event MeteoriumForgeRequirementsUpdated(\r\n        uint256 mtomType,\r\n        FoundryRequirements req\r\n    );\r\n    event ForgedMeteoriums(uint256 meteoriumtype, uint256 forged);\r\n\r\n    constructor(address mto, address mtom) {\r\n        _MTO = mto;\r\n        _MTOM = mtom;\r\n    }\r\n\r\n    function updateForgeRequirements(\r\n        uint256 meteoriumType,\r\n        FoundryRequirements calldata req\r\n    ) external onlyOwner {\r\n        forgeRequirements[meteoriumType] = req;\r\n\r\n        emit MeteoriumForgeRequirementsUpdated(meteoriumType, req);\r\n    }\r\n\r\n    function withdraw(address _address, uint256 _amount) external onlyOwner {\r\n        (bool success, ) = _address.call{value: _amount}(\"\");\r\n\r\n        if (!success) revert TransferFailed();\r\n    }\r\n\r\n    function burnBatch(\r\n        uint256[] calldata tokenIds,\r\n        bytes[] calldata sigs\r\n    ) external onlyOwner {\r\n        unchecked {\r\n            for (uint256 i; i < tokenIds.length; ++i) {\r\n                IMeteorium(_MTOM).burn(tokenIds[i], sigs[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function forgeMeteorium(\r\n        uint256 mtomType,\r\n        uint256[] calldata mtoIds,\r\n        uint256[] calldata mtomIds\r\n    ) external payable {\r\n        FoundryRequirements memory req = forgeRequirements[mtomType];\r\n\r\n        // Automatically define as disabled any non initialized struct\r\n        if (!req.enabled) revert ForgingDisabledForType();\r\n\r\n        uint256 toForge;\r\n\r\n        unchecked {\r\n            uint256 reqMto = req.reqMto;\r\n            uint256 mtoHoldTime = req.mtoHoldTime;\r\n\r\n            if (mtoHoldTime + reqMto > 0) {\r\n                uint256 mtoCount = mtoIds.length;\r\n\r\n                if (reqMto > mtoCount)\r\n                    revert NotEnoughTokenIdsGiven();\r\n                if (mtoCount % reqMto > 0)\r\n                    revert IncorrectTokenIdsAmountGiven();\r\n\r\n                toForge = mtoCount / reqMto;\r\n\r\n                uint256 startId = req.minMtoId;\r\n                uint256 endId = req.maxMtoId;\r\n                bool isTribute = req.isMtoTribute;\r\n\r\n                // Dirty duplicating blocks => reduce gas cost => avoid\r\n                // performing ops on each loops or pushing internal calls\r\n                if (startId + endId > 2) {\r\n                    for (uint256 i; i < mtoCount; ++i) {\r\n                        uint256 id = mtoIds[i];\r\n\r\n                        if (id < startId || id > endId)\r\n                            revert TokenIdNotInBounds();\r\n\r\n                        TokenOwnership memory tokenOwnership =\r\n                            IERC721A(_MTO).ownershipOf(id);\r\n\r\n                        if (block.timestamp - tokenOwnership.startTimestamp < mtoHoldTime)\r\n                            revert NotHoldingForLongEnough();\r\n\r\n                        if (isTribute) {\r\n                            if (tokenOwnership.addr != msg.sender)\r\n                                revert NotTokenOwner();\r\n\r\n                            IERC721A(_MTO).burn(id);\r\n                        } else {\r\n                            // No ownership check needed => TransferFromIncorrectOwner\r\n                            // Trick to update the last hold since time\r\n                            IERC721A(_MTO).transferFrom(\r\n                                msg.sender,\r\n                                msg.sender,\r\n                                id\r\n                            );\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (uint256 i; i < mtoCount; ++i) {\r\n                        uint256 id = mtoIds[i];\r\n\r\n                        TokenOwnership memory tokenOwnership =\r\n                            IERC721A(_MTO).ownershipOf(id);\r\n\r\n                        if (block.timestamp - tokenOwnership.startTimestamp < mtoHoldTime)\r\n                            revert NotHoldingForLongEnough();\r\n\r\n                        if (isTribute) {\r\n                            if (tokenOwnership.addr != msg.sender)\r\n                                revert NotTokenOwner();\r\n\r\n                            IERC721A(_MTO).burn(id);\r\n                        } else {\r\n                            // Trick to update the last hold since time\r\n                            IERC721A(_MTO).transferFrom(\r\n                                msg.sender,\r\n                                msg.sender,\r\n                                id\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Duplicating here allows us to use only one fn to combinate all kind\r\n        // of requirement or only the one configured. splitting it into 3 fn\r\n        // would cost much in deployment for a gas saving of only 2xx on 2 calls\r\n        unchecked {\r\n            uint256 reqMtom = req.reqMtom;\r\n            uint256 mtomHoldTime = req.mtomHoldTime;\r\n\r\n            if (mtomHoldTime + reqMtom > 0) {\r\n                uint256 mtomCount = mtomIds.length;\r\n\r\n                if (reqMtom > mtomCount)\r\n                    revert NotEnoughTokenIdsGiven();\r\n                if (mtomCount % reqMtom > 0)\r\n                    revert IncorrectTokenIdsAmountGiven();\r\n\r\n                toForge = mtomCount / reqMtom;\r\n\r\n                uint256 startId = req.minMtomId;\r\n                uint256 endId = req.maxMtomId;\r\n\r\n                // Dirty duplicating blocks => reduce gas cost => avoid\r\n                // performing ops on each loops or pusing internal calls\r\n                if (startId + endId > 2) {\r\n                    for (uint256 i; i < mtomCount; ++i) {\r\n                        uint256 id = mtomIds[i];\r\n\r\n                        if (id < startId || id > endId)\r\n                            revert TokenIdNotInBounds();\r\n\r\n                        TokenOwnership memory tokenOwnership =\r\n                            IERC721A(_MTOM).ownershipOf(id);\r\n\r\n                        if (block.timestamp - tokenOwnership.startTimestamp < mtomHoldTime)\r\n                            revert NotHoldingForLongEnough();\r\n\r\n                        // No ownership checks here either as transfered to\r\n                        // the contract (due to sig system)\r\n                        if (req.isMtomTribute) {\r\n                            IERC721A(_MTOM).transferFrom(\r\n                                msg.sender,\r\n                                address(this),\r\n                                id\r\n                            );\r\n                        } else {\r\n                            // Trick to update the last hold since time\r\n                            IERC721A(_MTOM).transferFrom(\r\n                                msg.sender,\r\n                                msg.sender,\r\n                                id\r\n                            );\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (uint256 i; i < mtomCount; ++i) {\r\n                        uint256 id = mtomIds[i];\r\n\r\n                        TokenOwnership memory tokenOwnership =\r\n                            IERC721A(_MTOM).ownershipOf(id);\r\n\r\n                        if (block.timestamp - tokenOwnership.startTimestamp < mtomHoldTime)\r\n                            revert NotHoldingForLongEnough();\r\n\r\n                        if (req.isMtomTribute) {\r\n                            IERC721A(_MTOM).transferFrom(\r\n                                msg.sender,\r\n                                address(this),\r\n                                id\r\n                            );\r\n                        } else {\r\n                            // Trick to update the last hold since time\r\n                            IERC721A(_MTOM).transferFrom(\r\n                                msg.sender,\r\n                                msg.sender,\r\n                                id\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (msg.value != toForge * req.price) revert IncorrectETHValue();\r\n\r\n        IMeteorium(_MTOM).mint(msg.sender, toForge);\r\n\r\n        emit ForgedMeteoriums(mtomType, toForge);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mto\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mtom\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ForgingDisabledForType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectETHValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectTokenIdsAmountGiven\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughTokenIdsGiven\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHoldingForLongEnough\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIdNotInBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"meteoriumtype\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forged\",\"type\":\"uint256\"}],\"name\":\"ForgedMeteoriums\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mtomType\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"mtoHoldTime\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"reqMto\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMtoTribute\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"minMtoId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxMtoId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"mtomHoldTime\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"reqMtom\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMtomTribute\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"minMtomId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxMtomId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct MeteoriumFoundry.FoundryRequirements\",\"name\":\"req\",\"type\":\"tuple\"}],\"name\":\"MeteoriumForgeRequirementsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sigs\",\"type\":\"bytes[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mtomType\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"mtoIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mtomIds\",\"type\":\"uint256[]\"}],\"name\":\"forgeMeteorium\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forgeRequirements\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"mtoHoldTime\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"reqMto\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMtoTribute\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"minMtoId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxMtoId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"mtomHoldTime\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"reqMtom\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMtomTribute\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"minMtomId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxMtomId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"meteoriumType\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"mtoHoldTime\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"reqMto\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMtoTribute\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"minMtoId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxMtoId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"mtomHoldTime\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"reqMtom\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMtomTribute\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"minMtomId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxMtomId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"}],\"internalType\":\"struct MeteoriumFoundry.FoundryRequirements\",\"name\":\"req\",\"type\":\"tuple\"}],\"name\":\"updateForgeRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MeteoriumFoundry", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004bd3b5e3936254ce753d154907997597021ce64a000000000000000000000000be6f122f79c80022eb30b358f8445df8bf50307d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eb101dce37345371647aa64a6a677ba132acb4539660d1d3eb8b50df8a8aa4c4"}