{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.23;\r\n\r\n/// Standard IERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// Interface for the pairs of uniswap and forks\r\ninterface IPair {\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function sync() external;\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns(address);\r\n    function token1() external view returns(address);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n/// Transfer Helper to ensure the correct transfer of the tokens or ETH\r\nlibrary SafeTransfer {\r\n    using Address for address;\r\n    function _pullUnderlying(IERC20 erc20, address from, uint amount) internal\r\n    {\r\n        safeTransferFrom(erc20,from,address(this),amount);\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function _pushUnderlying(IERC20 erc20, address to, uint amount) internal\r\n    {\r\n        safeTransfer(erc20,to,amount);\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    mapping(address => bool) whitelist;\r\n    uint256 private _status;\r\n    uint256 private _status2;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED || whitelist[msg.sender], \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function addWhitelist(address toAdd) internal {\r\n        whitelist[toAdd] = true;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuardCopy {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface Reader {\r\n    function isAdmin(address addy) external view returns (bool);\r\n    function superAdmin(address addy) external view returns (bool);\r\n    function protocolAddy() external view returns (address);\r\n    function sdDepAddy() external view returns (address);\r\n    function getProtocolFee() external view returns (uint256);\r\n    function breaker() external view returns (bool); //circuit breaked in case of an exploit to handle\r\n    function dataAddress() external view returns (address);\r\n    function isWhitelistContract(address addy) external view returns (bool);\r\n    function isSD(address addy) external view returns (bool);\r\n    function fegAddress() external view returns(address);\r\n    function UNISWAP_V2_ROUTER() external view returns(address);\r\n    function uniswapV2Pair() external view returns(address);\r\n    function wETH() external view returns(address);\r\n    function frontRun(address who, uint256 range) external view returns(bool yes);\r\n    function DATA_READ() external view returns(address); \r\n    function feeConverter() external view returns (address); \r\n    function cont(address addy, uint256 fee) external;\r\n    function createFeeConverter(address sd, address user) external returns(address fc);\r\n    function setFeeConverterSD(address who, address addy) external;\r\n    function sdOwner() external view returns(address);\r\n    function range() external view returns(uint256,uint256);\r\n    function setWhitelistContract(address addy, bool boolean) external;\r\n    function getSDPerConvert(address token, uint256 thr) external view returns(uint256);\r\n    function setSDFeeRecipient(address addy) external;\r\n}\r\n\r\ncontract FeeConverterDeployer is ReentrancyGuard {\r\n    address private constant BURN = 0x000000000000000000000000000000000000dEaD;  \r\n    uint256 public rate = 1; // in dollars\r\n    uint256 public _range = 0; // desired slippage range check \r\n    uint256 public slip = 20; // desired slippage\r\n    mapping(address => uint256) public totalConvertedTo;\r\n    address public logic = 0x94597C4160898E64cad84b85E218DF2E4A102480;\r\n    mapping(address => bool) public isCreated;\r\n    mapping(address => address) public feeconv;\r\n\r\n    function DATA_READ() public view returns(address) {\r\n       return Reader(0xcCeD1a96321B2B2a06E8F3F4B0B883dDD059968c).DATA_READ();\r\n    }\r\n\r\n    function range() external view returns(uint256,uint256) {\r\n        return (_range,slip);\r\n    }\r\n\r\n    function FEG() public view returns(address) {\r\n       return Reader(DATA_READ()).fegAddress();\r\n    }\r\n\r\n    function addTotalConvertedTo(address to, uint256 amt) external {\r\n        require(isCreated[msg.sender], \"invalid\");\r\n        totalConvertedTo[to] += amt;\r\n    }\r\n\r\n    function getFEGcost() public view returns(uint256) {\r\n        address feg = FEG();        \r\n        address DR = DATA_READ();\r\n        return Reader(Reader(DR).feeConverter()).getSDPerConvert(feg, rate) + 1e18;\r\n    }\r\n\r\n    function setLogic(address addy) external {        \r\n        require(Reader(DATA_READ()).superAdmin(msg.sender), \"You do not have permission\");\r\n        logic = addy;\r\n    }\r\n    \r\n    function createFeeConverter(address sd) external returns(address converter) {\r\n        require(msg.sender == Reader(sd).sdOwner(), \"not owner\");\r\n        address D = DATA_READ();\r\n        require(Reader(D).isSD(sd), \"not SD\");\r\n        converter = Reader(logic).createFeeConverter(sd, msg.sender);\r\n        isCreated[converter] = true;\r\n        Reader(D).setFeeConverterSD(sd, converter);\r\n        uint256 r = getFEGcost();\r\n        if(!Reader(D).isAdmin(msg.sender) && rate > 0) {\r\n        SafeTransfer.safeTransferFrom(IERC20(FEG()), msg.sender, BURN, r);\r\n        }\r\n        Reader(D).setWhitelistContract(converter, true);\r\n        Reader(sd).setSDFeeRecipient(converter);\r\n        feeconv[sd] = converter;\r\n    }\r\n\r\n    function setRate(uint256 amt) external {\r\n        require(Reader(DATA_READ()).superAdmin(msg.sender), \"You do not have permission\");\r\n        require(amt <= 500e18, \"1-50\");\r\n        rate = amt;\r\n    }\r\n\r\n    function saveLostTokens(address toSave) external { //save any lost tokens\r\n        require(Reader(DATA_READ()).superAdmin(msg.sender), \"You do not have permission\");\r\n        uint256 toSend = IERC20(toSave).balanceOf(address(this));\r\n        TransferHelper.safeTransfer(toSave, msg.sender, toSend);\r\n        if(address(this).balance > 0) {\r\n        TransferHelper.safeTransferETH(msg.sender, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function seeDecimal(address addy) external view returns(uint256){\r\n        return IERC20(addy).decimals();\r\n    }\r\n\r\n    // desired slippage input for frontrun protection\r\n    function setRange(uint256 _Range, uint256 _slip) external {\r\n        require(Reader(DATA_READ()).superAdmin(msg.sender), \"admin\");\r\n        require(_range < 100, \"100\");\r\n        require(_slip > 2 && _slip < 31, \"3-30\");\r\n        _range = _Range;\r\n        slip = _slip;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"DATA_READ\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"addTotalConvertedTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"}],\"name\":\"createFeeConverter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"converter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeconv\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFEGcost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toSave\",\"type\":\"address\"}],\"name\":\"saveLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"seeDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_Range\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slip\",\"type\":\"uint256\"}],\"name\":\"setRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalConvertedTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FeeConverterDeployer", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://140a2039690eaae1c354c540a7b3cada2dd3ffcb8a5a8d3dda5b781063a876f3"}