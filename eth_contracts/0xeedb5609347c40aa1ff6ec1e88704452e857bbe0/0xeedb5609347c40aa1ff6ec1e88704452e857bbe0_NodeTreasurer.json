{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NodeTreasurer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nstruct Rental {\\n  address renter;\\n  address lender;\\n  uint256 pendingAmount;\\n  uint256 totalAmount;\\n  uint256 pendingDisputeAmount;\\n  uint256 totalDisputeAmount;\\n  uint256 startTime;\\n  uint256 endTime;\\n  bool ended;\\n  bool active;\\n}\\n\\ncontract NodeTreasurer is ReentrancyGuard {\\n  // The owner of the contract\\n  address public owner;\\n\\n  // The system that will call the functions\\n  address private system;\\n\\n  // The staking contract that implements a depositReward function\\n  address public stakingContract;\\n\\n  // The rentals\\n  mapping(bytes32 => Rental) public rentals;\\n\\n  // Whether new rentals are paused\\n  bool public isPaused;\\n\\n  // The percentage of revenue to share\\n  uint256 public revenueSharePercentage;\\n\\n  // The total revenue shared\\n  uint256 public totalRevenueShared;\\n\\n  // Events\\n  event Deposit(bytes32 key, uint256 amount);\\n  event Withdraw(bytes32 key, uint256 amount);\\n  event Dispute(bytes32 key, uint256 disputeAmount);\\n  event Refund(bytes32 key, uint256 amount);\\n  event Migrated(address indexed newTreasurer, uint256 ethAmount);\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlySystem() {\\n    require(\\n      msg.sender == system || msg.sender == owner,\\n      'Only system can call this function.'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, 'Only owner can call this function.');\\n    _;\\n  }\\n\\n  /* Will be called by owner to set the system */\\n  function setSystem(address _system) external onlyOwner {\\n    system = _system;\\n  }\\n\\n  /* Will be called by our systems to set the revenue share percentage */\\n  function setRevenueSharePercentage(\\n    uint256 _revenueSharePercentage\\n  ) external onlyOwner {\\n    require(\\n      _revenueSharePercentage <= 100,\\n      'Revenue share percentage must be less than or equal to 100'\\n    );\\n\\n    revenueSharePercentage = _revenueSharePercentage;\\n  }\\n\\n  /* Will be called by our systems to set the staking contract */\\n  function setStakingContract(address _stakingContract) external onlyOwner {\\n    stakingContract = _stakingContract;\\n  }\\n\\n  /* Will be called by our systems to pause new rentals */\\n  function pause(bool state) external onlyOwner {\\n    require(state != isPaused, 'State is already set to this value');\\n    isPaused = state;\\n  }\\n\\n  /* Will be called by the renter to deposit the rental amount */\\n  function deposit(bytes32 key) external payable nonReentrant {\\n    require(msg.value > 0, 'Deposit must be greater than 0');\\n    require(!isPaused, 'Rentals are paused');\\n    require(rentals[key].totalAmount == 0, 'Rental already exists');\\n\\n    Rental storage rental = rentals[key];\\n    rental.renter = msg.sender;\\n\\n    rental.pendingAmount = msg.value;\\n    rental.totalAmount = msg.value;\\n    rental.pendingDisputeAmount = 0;\\n    rental.totalDisputeAmount = 0;\\n\\n    rental.active = false;\\n\\n    emit Deposit(key, msg.value);\\n  }\\n\\n  /* Will be called by the renter to withdraw the rental amount */\\n  function withdraw(bytes32 key) external nonReentrant {\\n    Rental storage rental = rentals[key];\\n\\n    require(block.timestamp >= rental.endTime, 'Rental period has not ended');\\n    require(rental.active, 'Rental is not active');\\n    require(!rental.ended, 'Rental has already ended');\\n    require(msg.sender == rental.lender, 'Only lender can withdraw');\\n    require(stakingContract != address(0), 'Staking contract is not set');\\n\\n    uint256 amountToPay = rental.totalAmount - rental.totalDisputeAmount;\\n\\n    rental.ended = true;\\n    rental.pendingAmount = 0;\\n\\n    uint256 revenueShare = (amountToPay * revenueSharePercentage) / 100;\\n    uint256 amountToWithdraw = amountToPay - revenueShare;\\n\\n    (bool sent, ) = stakingContract.call{value: revenueShare}('');\\n    require(sent, 'Failed to send revenue share amount to staking contract');\\n    totalRevenueShared += revenueShare;\\n\\n    (bool withdrawSent, ) = msg.sender.call{value: amountToWithdraw}('');\\n    require(withdrawSent, 'Failed to send amount to withdraw');\\n\\n    emit Withdraw(key, amountToWithdraw);\\n  }\\n\\n  /* Will be called by the lender to claim the refund */\\n  function claimRefund(bytes32 key) external nonReentrant {\\n    Rental storage rental = rentals[key];\\n\\n    require(msg.sender == rental.renter, 'Only renter can claim refund');\\n    require(rental.pendingDisputeAmount > 0, 'No dispute amount to refund');\\n\\n    (bool disputeSent, ) = msg.sender.call{value: rental.pendingDisputeAmount}(\\n      ''\\n    );\\n    require(disputeSent, 'Failed to send dispute amount');\\n\\n    emit Refund(key, rental.pendingDisputeAmount);\\n\\n    rental.pendingDisputeAmount = 0;\\n  }\\n\\n  /* Will be set from our systems and starts the rental period */\\n  function setRentalInfo(\\n    bytes32 key,\\n    address lender,\\n    uint256 endTime\\n  ) external onlySystem {\\n    Rental storage rental = rentals[key];\\n\\n    rental.lender = lender;\\n    rental.startTime = block.timestamp;\\n    rental.endTime = endTime;\\n    rental.active = true;\\n  }\\n\\n  /* Will be set from our systems that detects uptime */\\n  function raiseDispute(\\n    bytes32 key,\\n    uint256 disputeAmount\\n  ) external onlySystem {\\n    Rental storage rental = rentals[key];\\n\\n    require(rental.active, 'Rental is not active');\\n    require(disputeAmount > 0, 'Dispute amount must be greater than 0');\\n    require(\\n      disputeAmount <= rental.totalAmount - rental.totalDisputeAmount,\\n      'Dispute amount exceeds rental amount'\\n    );\\n\\n    rental.pendingDisputeAmount += disputeAmount;\\n    rental.totalDisputeAmount += disputeAmount;\\n\\n    emit Dispute(key, disputeAmount);\\n  }\\n\\n  /* Migrates the treasurer contract to a new contract */\\n  function migrate(address _newStakingContract) external onlyOwner {\\n    require(_newStakingContract != address(0), 'Invalid address');\\n\\n    uint256 contractETHBalance = address(this).balance;\\n    (bool sent, ) = _newStakingContract.call{value: contractETHBalance}('');\\n\\n    require(sent, 'Failed to transfer ETH');\\n\\n    emit Migrated(\\n      _newStakingContract,\\n      contractETHBalance\\n    );\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeAmount\",\"type\":\"uint256\"}],\"name\":\"Dispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTreasurer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newStakingContract\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"disputeAmount\",\"type\":\"uint256\"}],\"name\":\"raiseDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"rentals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"renter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDisputeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDisputeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueSharePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"setRentalInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_revenueSharePercentage\",\"type\":\"uint256\"}],\"name\":\"setRevenueSharePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"name\":\"setStakingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"}],\"name\":\"setSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRevenueShared\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NodeTreasurer", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}