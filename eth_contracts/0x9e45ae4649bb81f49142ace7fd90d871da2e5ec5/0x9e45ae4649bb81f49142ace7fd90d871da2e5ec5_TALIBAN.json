{"SourceCode": "/*\r\n    $TALIBAN GANG\r\n\r\n    T.me/WeDemBoyzPortal\r\n\r\n    Twitter.com/TalibanSquad911\r\n\r\n    https://talibaninthishoe.com/\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal _owner;\r\n    event OwnershipTransferred(address _owner);\r\n    constructor(address creatorOwner) { _owner = creatorOwner; }\r\n    modifier onlyOwner() { require(msg.sender == _owner, \"Only owner can call this\"); _; }\r\n    function owner() public view returns (address) { return _owner; }\r\n    function renounceOwnership() external onlyOwner { \r\n        _owner = address(0); \r\n        emit OwnershipTransferred(address(0)); \r\n    }\r\n}\r\n\r\ncontract TALIBAN is IERC20, Auth {\r\n    string private constant _name         = unicode\"I fucking said you are a pussy ass hoe, got it? I\u2019ll have YOU know we ran y\u2019all bitch ass niggas out of Afghanistan. I was blowing y\u2019all up to smithereens before sleepy Joe called it off and didn\u2019t want you motherfuckers to keep dropping like flies so keep telling lies. And we ran your profile, you have 8 meals cooked and 3 bathrooms cleaned you pussy ass liar, why are you telling people you have 300 confirmed kills, we don\u2019t kill and tell, we run the stat sheets. We got you beat. You\u2019ve never even been on the field. I\u2019ve been rocking an AK-47 since 13 years old protecting the homeland. Russia tried and got fucked! USA tried and got manhandled. What, y\u2019all think y\u2019all did something? Bitch ass nigga we them boys! Y\u2019all motherfuckers can\u2019t do anything except submit to the devil. I call you to islam, but until then we\u2019re enemies. Buddy is talking about secret spies and some other bullshit about IP\u2019s. You\u2019re a keyboard warrior. Pussy ass nigga see me on the playing field. Bitch ass nigga we them boys, we took over the government and fucking televised it. Y\u2019all niggas throwing money to Ukraine with nothing to show for it pussy ass nigga you not a navyseal, keep it real.\";\r\n    string private constant _symbol       = \"TALIBAN\";\r\n    uint8 private constant _decimals      = 18;\r\n    uint256 private constant _totalSupply = 420_690_000_000_000 * (10**_decimals);\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    address payable private _walletMarketing = payable(0xDD6c66e5dD9e8fFC67E824Cd307EA79b5758b597);\r\n    uint256 private constant _taxSwapMin = _totalSupply *  1 / 10000;\r\n    uint256 private constant _taxSwapMax = _totalSupply * 15 / 10000;\r\n    uint256 private _maxTx;\r\n    uint256 private _maxWallet;\r\n    uint8 private _buyTaxRate;\r\n    uint8 private _sellTaxRate;\r\n\r\n    mapping (address => bool) private _noFees;\r\n    mapping (address => bool) private _noLimits;\r\n    mapping (address => bool) private _bots;\r\n\r\n    address private constant _swapRouterAddress = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    IUniswapV2Router02 private _primarySwapRouter = IUniswapV2Router02(_swapRouterAddress);\r\n    address private _primaryLP;\r\n    mapping (address => bool) private _isLP;\r\n\r\n    uint256 private _antiSnipeBlock;\r\n    bool private _tradingOpen;\r\n\r\n    bool private _inTaxSwap = false;\r\n    modifier lockTaxSwap { \r\n        _inTaxSwap = true; \r\n        _; \r\n        _inTaxSwap = false; \r\n    }\r\n\r\n    event TokensAirdropped(uint256 totalWallets, uint256 totalTokens);\r\n\r\n    constructor() Auth(msg.sender) {\r\n        address reservedWallet = address(0x92f964A2bcA69EA2aA0A62e01414B085665DA27F);\r\n        _balances[reservedWallet] = _totalSupply * 120 / 1000;\r\n        emit Transfer(address(0), reservedWallet, _balances[reservedWallet]);\r\n        _balances[_owner] = _totalSupply - _balances[reservedWallet];\r\n        emit Transfer(address(0), _owner, _balances[_owner]);\r\n\r\n        _noFees[_owner] = true;\r\n        _noFees[address(this)] = true;\r\n        _noFees[_swapRouterAddress] = true;\r\n        _noFees[_walletMarketing] = true;\r\n\r\n        _noLimits[_owner] = true;\r\n        _noLimits[address(this)] = true;\r\n        _noLimits[_swapRouterAddress] = true;\r\n        _noLimits[_walletMarketing] = true;\r\n\r\n        _maxTx       = (_totalSupply * 5 / 1000) + (10**_decimals);\r\n        _maxWallet   = (_totalSupply * 10 / 1000) + (10**_decimals);\r\n        _buyTaxRate  = 2;\r\n        _sellTaxRate = 3;\r\n    }\r\n\r\n    receive() external payable {}\r\n    \r\n    function totalSupply() external pure override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function taxBuy() external view returns (uint16) { return _buyTaxRate; }\r\n    function taxSell() external view returns (uint16) { return _sellTaxRate; }\r\n    function marketingWallet() external view returns (address) { return _walletMarketing; }\r\n    function maxTransactionAmount() external view returns (uint256) { return _maxTx; }\r\n    function maxWalletAmount() external view returns (uint256) { return _maxWallet; }\r\n    function blacklists(address wallet) external view returns (bool) { return _bots[wallet]; }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        require(_checkTradingOpen(msg.sender), \"Trading not open\");\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        require(_checkTradingOpen(sender), \"Trading not open\");\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _approveRouter(uint256 _tokenAmount) internal {\r\n        if ( _allowances[address(this)][_swapRouterAddress] < _tokenAmount ) {\r\n            _allowances[address(this)][_swapRouterAddress] = type(uint256).max;\r\n            emit Approval(address(this), _swapRouterAddress, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    function addLiquidity() external payable onlyOwner lockTaxSwap {\r\n        require(_primaryLP == address(0), \"LP exists\");\r\n        require(!_tradingOpen, \"trading is open\");\r\n        require(msg.value > 0 || address(this).balance>0, \"No ETH in contract or message\");\r\n        require(_balances[address(this)]>0, \"No tokens in contract\");\r\n        _primaryLP = IUniswapV2Factory(_primarySwapRouter.factory()).createPair(address(this), _primarySwapRouter.WETH());\r\n        _addLiquidity(_balances[address(this)], address(this).balance);\r\n        _isLP[_primaryLP] = true;\r\n        _antiSnipeBlock = block.number + 3; // 3 blocks after adding liquidity\r\n        _tradingOpen = true;\r\n    }\r\n\r\n    function _addLiquidity(uint256 _tokenAmount, uint256 _ethAmountWei) internal {\r\n        _approveRouter(_tokenAmount);\r\n        _primarySwapRouter.addLiquidityETH{value: _ethAmountWei} ( address(this), _tokenAmount, 0, 0, _owner, block.timestamp );\r\n    }\r\n\r\n    function _markSniper(address wallet) private {\r\n        if ( !_isLP[wallet] && wallet != address(this) && wallet != _swapRouterAddress ) {\r\n            _bots[wallet] = true; \r\n        }\r\n    }\r\n\r\n    function _antiSnipe(address from, address to) private returns (bool) {\r\n        bool isSafe = true;\r\n        if (block.number <= _antiSnipeBlock) {  // 3 blocks after adding liquidity\r\n            if ( _isLP[from] || _bots[from] ) { _markSniper(to); }\r\n        } else { isSafe = !_bots[from]; }\r\n        return isSafe;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"No transfers from Zero wallet\");\r\n        require(_limitCheck(sender, recipient, amount), \"Limits exceeded\");\r\n\r\n        if (!_tradingOpen) { require(_noFees[sender], \"Trading not open\"); }\r\n        else { require(_antiSnipe(sender, recipient), \"Address restricted\"); }\r\n\r\n        if ( !_inTaxSwap && _isLP[recipient] ) { _swapTax(); }\r\n\r\n        uint256 _taxAmount = _calculateTax(sender, recipient, amount);\r\n        uint256 _transferAmount = amount - _taxAmount;\r\n        _balances[sender] -= amount;\r\n        _balances[address(this)] += _taxAmount; \r\n        _balances[recipient] += _transferAmount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _checkTradingOpen(address sender) private view returns (bool){\r\n        bool checkResult;\r\n        if ( _tradingOpen ) { checkResult = true; } \r\n        else if (_noFees[sender]) { checkResult = true; } \r\n        return checkResult;\r\n    }\r\n\r\n    function _limitCheck(address from, address to, uint256 amount) private view returns (bool) {\r\n        bool txSize = true;\r\n        if ( amount > _maxTx && !_noLimits[from] && !_noLimits[to] ) { txSize = false; }\r\n        bool walletSize = true;\r\n        uint256 newBalanceTo = _balances[to] + amount;\r\n        if ( newBalanceTo > _maxWallet && !_noLimits[from] && !_noLimits[to] && !_isLP[to] ) { walletSize = false; } \r\n        return (txSize && walletSize);\r\n    }\r\n\r\n    function _calculateTax(address sender, address recipient, uint256 amount) internal view returns (uint256) {\r\n        uint256 taxAmount;\r\n        uint256 taxBlock0 = _antiSnipeBlock; //  3 blocks after adding liquidity\r\n        uint256 taxBlock1 = taxBlock0 + 12;   //  15 blocks after adding liquidity\r\n        uint256 taxBlock2 = taxBlock1 + 35;   // 50 blocks after adding liquidity\r\n\r\n        if ( _tradingOpen && !_noFees[sender] && !_noFees[recipient] ) { \r\n            uint8 taxRate;\r\n            if ( _isLP[sender] ) {\r\n                if (block.number > taxBlock2) { taxRate = _buyTaxRate; }\r\n                else if (block.number > taxBlock1) { taxRate = 25; }\r\n                else if (block.number > taxBlock0) { taxRate = 25; }\r\n            } else if ( _isLP[recipient] ) {\r\n                if (block.number > taxBlock2) { taxRate = _sellTaxRate; }\r\n                else if (block.number > taxBlock1) { taxRate = 25; }\r\n                else if (block.number > taxBlock0) { taxRate = 99; }\r\n            }\r\n            taxAmount = amount * taxRate / 100; \r\n        }\r\n        return taxAmount;\r\n    }\r\n\r\n    function _swapTax() private lockTaxSwap {\r\n        uint256 _tokensToSwap = balanceOf(address(this));\r\n        if ( _tokensToSwap >= _taxSwapMin && _tradingOpen ) {\r\n            if ( _tokensToSwap >= _taxSwapMax ) { _tokensToSwap = _taxSwapMax; }        \r\n            _swapTaxTokensForEth(_tokensToSwap);\r\n            uint256 _contractETHBalance = address(this).balance;\r\n            if(_contractETHBalance > 0) { \r\n                (bool sent,) = _walletMarketing.call{value: _contractETHBalance}(\"\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _swapTaxTokensForEth(uint256 tokenAmount) private {\r\n        _approveRouter(tokenAmount);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _primarySwapRouter.WETH();\r\n        _primarySwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount,0,path,address(this),block.timestamp);\r\n    }\r\n\r\n    function airdrop(address[] calldata addresses, uint256[] calldata tokenAmounts) external onlyOwner {\r\n        require(addresses.length <= 250,\"More than 250 wallets\");\r\n        require(addresses.length == tokenAmounts.length,\"List length mismatch\");\r\n\r\n        uint256 airdropTotal = 0;\r\n        for(uint i=0; i < addresses.length; i++){\r\n            airdropTotal += (tokenAmounts[i] * 10**_decimals);\r\n        }\r\n        require(_balances[msg.sender] >= airdropTotal, \"Token balance too low\");\r\n\r\n        for(uint i=0; i < addresses.length; i++){\r\n            _balances[msg.sender] -= (tokenAmounts[i] * 10**_decimals);\r\n            _balances[addresses[i]] += (tokenAmounts[i] * 10**_decimals);\r\n            emit Transfer(msg.sender, addresses[i], (tokenAmounts[i] * 10**_decimals) );       \r\n        }\r\n\r\n        emit TokensAirdropped(addresses.length, airdropTotal);\r\n    }\r\n\r\n    function blacklistBots(address[] calldata addresses, bool blacklisted) external onlyOwner {\r\n        for(uint i=0; i < addresses.length; i++){\r\n            require(!_isLP[addresses[i]] && addresses[i] != _swapRouterAddress);\r\n            _bots[addresses[i]] = blacklisted;\r\n        }\r\n    }\r\n\r\n    function setLimits(uint16 maxTxPermille, uint16 maxWalletPermille) external onlyOwner {\r\n        uint256 newMaxTx = _totalSupply * maxTxPermille / 1000;\r\n        uint256 newMaxWallet = _totalSupply * maxWalletPermille / 1000; \r\n        require(newMaxTx >= _maxTx && newMaxWallet >= _maxWallet, \"Cannot decrease limits\");\r\n        _maxTx = newMaxTx;\r\n        _maxWallet = newMaxWallet;\r\n    }\r\n\r\n    function setTaxRates(uint8 taxBuyRate, uint8 taxSellRate) external onlyOwner {\r\n        _buyTaxRate = taxBuyRate;\r\n        _sellTaxRate = taxSellRate;\r\n    }\r\n\r\n    function setTaxWallet(address payable walletMarketing) external onlyOwner {\r\n        require(!_isLP[walletMarketing] && walletMarketing != _swapRouterAddress && walletMarketing != address(this) && walletMarketing != address(0) );\r\n        _noFees[walletMarketing] = true;\r\n        _noLimits[walletMarketing] = true;\r\n        _walletMarketing = walletMarketing;\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory { \r\n    function createPair(address tokenA, address tokenB) external returns (address pair); \r\n}\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function WETH() external pure returns (address);\r\n    function factory() external pure returns (address);\r\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWallets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"}],\"name\":\"TokensAirdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"name\":\"blacklistBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"blacklists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"maxTxPermille\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxWalletPermille\",\"type\":\"uint16\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"taxBuyRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"taxSellRate\",\"type\":\"uint8\"}],\"name\":\"setTaxRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"walletMarketing\",\"type\":\"address\"}],\"name\":\"setTaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBuy\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxSell\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TALIBAN", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5e66425603daa6083254444fd3522ec860690de7ede6ec5c07ad3e226b3f832b"}