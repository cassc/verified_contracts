{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/protocol/src/rateModels/EarnerRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { wadLn } from \\\"../../lib/solmate/src/utils/SignedWadMath.sol\\\";\\nimport { UIntMath } from \\\"../../lib/common/src/libs/UIntMath.sol\\\";\\n\\nimport { ContinuousIndexingMath } from \\\"../libs/ContinuousIndexingMath.sol\\\";\\n\\nimport { IMToken } from \\\"../interfaces/IMToken.sol\\\";\\nimport { IMinterGateway } from \\\"../interfaces/IMinterGateway.sol\\\";\\nimport { IRateModel } from \\\"../interfaces/IRateModel.sol\\\";\\nimport { ITTGRegistrar } from \\\"../interfaces/ITTGRegistrar.sol\\\";\\n\\nimport { IEarnerRateModel } from \\\"./interfaces/IEarnerRateModel.sol\\\";\\n\\n/**\\n * @title  Earner Rate Model contract set in TTG (Two Token Governance) Registrar and accessed by MToken.\\n * @author M^0 Labs\\n */\\ncontract EarnerRateModel is IEarnerRateModel {\\n    /* ============ Variables ============ */\\n\\n    /// @inheritdoc IEarnerRateModel\\n    uint32 public constant RATE_CONFIDENCE_INTERVAL = 30 days;\\n\\n    /// @inheritdoc IEarnerRateModel\\n    uint32 public constant RATE_MULTIPLIER = 9_000; // 90% in basis points.\\n\\n    /// @inheritdoc IEarnerRateModel\\n    uint32 public constant ONE = 10_000; // 100% in basis points.\\n\\n    /// @notice The name of parameter in TTG that defines the max earner rate.\\n    bytes32 internal constant _MAX_EARNER_RATE = \\\"max_earner_rate\\\";\\n\\n    /// @notice The scaling of rates in for exponent math.\\n    uint256 internal constant _EXP_SCALED_ONE = 1e12;\\n\\n    /// @notice The scaling of `_EXP_SCALED_ONE` for wad maths operations.\\n    int256 internal constant _WAD_TO_EXP_SCALER = 1e6;\\n\\n    /// @inheritdoc IEarnerRateModel\\n    address public immutable mToken;\\n\\n    /// @inheritdoc IEarnerRateModel\\n    address public immutable minterGateway;\\n\\n    /// @inheritdoc IEarnerRateModel\\n    address public immutable ttgRegistrar;\\n\\n    /* ============ Constructor ============ */\\n\\n    /**\\n     * @notice Constructs the EarnerRateModel contract.\\n     * @param minterGateway_ The address of the Minter Gateway contract.\\n     */\\n    constructor(address minterGateway_) {\\n        if ((minterGateway = minterGateway_) == address(0)) revert ZeroMinterGateway();\\n        if ((ttgRegistrar = IMinterGateway(minterGateway_).ttgRegistrar()) == address(0)) revert ZeroTTGRegistrar();\\n        if ((mToken = IMinterGateway(minterGateway_).mToken()) == address(0)) revert ZeroMToken();\\n    }\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @inheritdoc IRateModel\\n    function rate() external view returns (uint256) {\\n        uint256 safeEarnerRate_ = getSafeEarnerRate(\\n            IMinterGateway(minterGateway).totalActiveOwedM(),\\n            IMToken(mToken).totalEarningSupply(),\\n            IMinterGateway(minterGateway).minterRate()\\n        );\\n\\n        return UIntMath.min256(maxRate(), (RATE_MULTIPLIER * safeEarnerRate_) / ONE);\\n    }\\n\\n    /// @inheritdoc IEarnerRateModel\\n    function maxRate() public view returns (uint256) {\\n        return uint256(ITTGRegistrar(ttgRegistrar).get(_MAX_EARNER_RATE));\\n    }\\n\\n    /// @inheritdoc IEarnerRateModel\\n    function getSafeEarnerRate(\\n        uint240 totalActiveOwedM_,\\n        uint240 totalEarningSupply_,\\n        uint32 minterRate_\\n    ) public pure returns (uint32) {\\n        // solhint-disable max-line-length\\n        // When `totalActiveOwedM_ >= totalEarningSupply_`, it is possible for the earner rate to be higher than the\\n        // minter rate and still ensure cashflow safety over some period of time (`RATE_CONFIDENCE_INTERVAL`). To ensure\\n        // cashflow safety, we start with `cashFlowOfActiveOwedM >= cashFlowOfEarningSupply` over some time `dt`.\\n        // Effectively: p1 * (exp(rate1 * dt) - 1) >= p2 * (exp(rate2 * dt) - 1)\\n        //          So: rate2 <= ln(1 + (p1 * (exp(rate1 * dt) - 1)) / p2) / dt\\n        // 1. totalActive * (delta_minterIndex - 1) >= totalEarning * (delta_earnerIndex - 1)\\n        // 2. totalActive * (delta_minterIndex - 1) / totalEarning >= delta_earnerIndex - 1\\n        // 3. 1 + (totalActive * (delta_minterIndex - 1) / totalEarning) >= delta_earnerIndex\\n        // Substitute `delta_earnerIndex` with `exponent((earnerRate * dt) / SECONDS_PER_YEAR)`:\\n        // 4. 1 + (totalActive * (delta_minterIndex - 1) / totalEarning) >= exponent((earnerRate * dt) / SECONDS_PER_YEAR)\\n        // 5. ln(1 + (totalActive * (delta_minterIndex - 1) / totalEarning)) >= (earnerRate * dt) / SECONDS_PER_YEAR\\n        // 6. ln(1 + (totalActive * (delta_minterIndex - 1) / totalEarning)) * SECONDS_PER_YEAR / dt >= earnerRate\\n\\n        // When `totalActiveOwedM_ <= totalEarningSupply_`, the instantaneous earner cash flow must be less than the\\n        // instantaneous minter cash flow. To ensure instantaneous cashflow safety, we we use the derivatives of the\\n        // previous starting inequality, and substitute `dt = 0`.\\n        // Effectively: p1 * rate1 >= p2 * rate2\\n        //          So: rate2 <= p1 * rate1 / p2\\n        // 1. totalActive * minterRate >= totalEarning * earnerRate\\n        // 2. totalActive * minterRate / totalEarning >= earnerRate\\n        // solhint-enable max-line-length\\n\\n        if (totalActiveOwedM_ == 0 || minterRate_ == 0) return 0;\\n\\n        if (totalEarningSupply_ == 0) return type(uint32).max;\\n\\n        if (totalActiveOwedM_ <= totalEarningSupply_) {\\n            // NOTE: `totalActiveOwedM_ * minterRate_` can revert due to overflow, so in some distant future, a new\\n            //       rate model contract may be needed that handles this differently.\\n            return uint32((uint256(totalActiveOwedM_) * minterRate_) / totalEarningSupply_);\\n        }\\n\\n        uint48 deltaMinterIndex_ = ContinuousIndexingMath.getContinuousIndex(\\n            ContinuousIndexingMath.convertFromBasisPoints(minterRate_),\\n            RATE_CONFIDENCE_INTERVAL\\n        );\\n\\n        // NOTE: `totalActiveOwedM_ * deltaMinterIndex_` can revert due to overflow, so in some distant future, a new\\n        //       rate model contract may be needed that handles this differently.\\n        int256 lnArg_ = int256(\\n            _EXP_SCALED_ONE +\\n                ((uint256(totalActiveOwedM_) * (deltaMinterIndex_ - _EXP_SCALED_ONE)) / totalEarningSupply_)\\n        );\\n\\n        int256 lnResult_ = wadLn(lnArg_ * _WAD_TO_EXP_SCALER) / _WAD_TO_EXP_SCALER;\\n\\n        uint256 expRate_ = (uint256(lnResult_) * ContinuousIndexingMath.SECONDS_PER_YEAR) / RATE_CONFIDENCE_INTERVAL;\\n\\n        if (expRate_ > type(uint64).max) return type(uint32).max;\\n\\n        // NOTE: Do not need to do `UIntMath.safe256` because it is known that `lnResult_` will not be negative.\\n        uint40 safeRate_ = ContinuousIndexingMath.convertToBasisPoints(uint64(expRate_));\\n\\n        return (safeRate_ > type(uint32).max) ? type(uint32).max : uint32(safeRate_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/solmate/src/utils/SignedWadMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18.\\n        r := mul(x, 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative second amounts, it assumes x is positive.\\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18 and then divide it by 86400.\\n        r := div(mul(x, 1000000000000000000), 86400)\\n    }\\n}\\n\\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative day amounts, it assumes x is positive.\\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 86400 and then divide it by 1e18.\\n        r := div(mul(x, 86400), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by y and divide by 1e18.\\n        r := sdiv(mul(x, y), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero and will\\n/// not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18 and divide it by y.\\n        r := sdiv(mul(x, 1000000000000000000), y)\\n    }\\n}\\n\\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Store x * y in r for now.\\n        r := mul(x, y)\\n\\n        // Combined overflow check (`x == 0 || (x * y) / x == y`) and edge case check\\n        // where x == -1 and y == type(int256).min, for y == -1 and x == min int256,\\n        // the second overflow check will catch this.\\n        // See: https://secure-contracts.com/learn_evm/arithmetic-checks.html#arithmetic-checks-for-int256-multiplication\\n        // Combining into 1 expression saves gas as resulting bytecode will only have 1 `JUMPI`\\n        // rather than 2.\\n        if iszero(\\n            and(\\n                or(iszero(x), eq(sdiv(r, x), y)),\\n                or(lt(x, not(0)), sgt(y, 0x8000000000000000000000000000000000000000000000000000000000000000))\\n            )\\n        ) {\\n            revert(0, 0)\\n        }\\n\\n        // Scale the result down by 1e18.\\n        r := sdiv(r, 1000000000000000000)\\n    }\\n}\\n\\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Store x * 1e18 in r for now.\\n        r := mul(x, 1000000000000000000)\\n\\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\\n            revert(0, 0)\\n        }\\n\\n        // Divide r by y.\\n        r := sdiv(r, y)\\n    }\\n}\\n\\n/// @dev Will not work with negative bases, only use when x is positive.\\nfunction wadPow(int256 x, int256 y) pure returns (int256) {\\n    // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n    return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.\\n}\\n\\nfunction wadExp(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        // When the result is < 0.5 we return zero. This happens when\\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n        if (x <= -42139678854452767551) return 0;\\n\\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n        if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n        // for more intermediate precision and a binary basis. This base conversion\\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n        x = (x << 78) / 5**18;\\n\\n        // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n        x = x - k * 54916777467707473351141471128;\\n\\n        // k is in the range [-61, 195].\\n\\n        // Evaluate using a (6, 7)-term rational approximation.\\n        // p is made monic, we'll multiply by a scale factor later.\\n        int256 y = x + 1346386616545796478920950773328;\\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n        int256 p = y + x - 94201549194550492254356042504812;\\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n        p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        int256 q = x - 2855989394907223263936484059900;\\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\\n            // No scaling is necessary because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r should be in the range (0.09, 0.25) * 2**96.\\n\\n        // We now need to multiply r by:\\n        // * the scale factor s = ~6.031367120.\\n        // * the 2**k factor from the range reduction.\\n        // * the 1e18 / 2**96 factor for base conversion.\\n        // We do this all at once, with an intermediate result in 2**213\\n        // basis, so the final right shift is always by a positive amount.\\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n    }\\n}\\n\\nfunction wadLn(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n        // We do this by multiplying by 2**96 / 10**18. But since\\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n        // and add ln(2**96 / 10**18) at the end.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n\\n        // Reduce range of x to (1, 2) * 2**96\\n        // ln(2^k * x) = k * ln(2) + ln(x)\\n        int256 k = r - 96;\\n        x <<= uint256(159 - k);\\n        x = int256(uint256(x) >> 159);\\n\\n        // Evaluate using a (8, 8)-term rational approximation.\\n        // p is made monic, we will multiply by a scale factor later.\\n        int256 p = x + 3273285459638523848632254066296;\\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n        p = p * x - (795164235651350426258249787498 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        // q is monic by convention.\\n        int256 q = x + 5573035233440673466300451813936;\\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r is in the range (0, 0.125) * 2**96\\n\\n        // Finalization, we need to:\\n        // * multiply by the scale factor s = 5.549\u2026\\n        // * add ln(2**96 / 10**18)\\n        // * add k * ln(2)\\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n        r *= 1677202110996718588342820967067443963516166;\\n        // add ln(2) * k * 5e18 * 2**192\\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n        // base conversion: mul 2**18 / 2**192\\n        r >>= 174;\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero.\\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Divide x by y.\\n        r := sdiv(x, y)\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/libs/UIntMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Library to perform safe math operations on uint types\\n * @author M^0 Labs\\n */\\nlibrary UIntMath {\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Emitted when a passed value is greater than the maximum value of uint16.\\n    error InvalidUInt16();\\n\\n    /// @notice Emitted when a passed value is greater than the maximum value of uint40.\\n    error InvalidUInt40();\\n\\n    /// @notice Emitted when a passed value is greater than the maximum value of uint48.\\n    error InvalidUInt48();\\n\\n    /// @notice Emitted when a passed value is greater than the maximum value of uint112.\\n    error InvalidUInt112();\\n\\n    /// @notice Emitted when a passed value is greater than the maximum value of uint128.\\n    error InvalidUInt128();\\n\\n    /// @notice Emitted when a passed value is greater than the maximum value of uint240.\\n    error InvalidUInt240();\\n\\n    /* ============ Internal View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Casts a given uint256 value to a uint16,\\n     *         ensuring that it is less than or equal to the maximum uint16 value.\\n     * @param  n The value to check.\\n     * @return The value casted to uint16.\\n     */\\n    function safe16(uint256 n) internal pure returns (uint16) {\\n        if (n > type(uint16).max) revert InvalidUInt16();\\n        return uint16(n);\\n    }\\n\\n    /**\\n     * @notice Casts a given uint256 value to a uint40,\\n     *         ensuring that it is less than or equal to the maximum uint40 value.\\n     * @param  n The value to check.\\n     * @return The value casted to uint40.\\n     */\\n    function safe40(uint256 n) internal pure returns (uint40) {\\n        if (n > type(uint40).max) revert InvalidUInt40();\\n        return uint40(n);\\n    }\\n\\n    /**\\n     * @notice Casts a given uint256 value to a uint48,\\n     *         ensuring that it is less than or equal to the maximum uint48 value.\\n     * @param  n The value to check.\\n     * @return The value casted to uint48.\\n     */\\n    function safe48(uint256 n) internal pure returns (uint48) {\\n        if (n > type(uint48).max) revert InvalidUInt48();\\n        return uint48(n);\\n    }\\n\\n    /**\\n     * @notice Casts a given uint256 value to a uint112,\\n     *         ensuring that it is less than or equal to the maximum uint112 value.\\n     * @param  n The value to check.\\n     * @return The value casted to uint112.\\n     */\\n    function safe112(uint256 n) internal pure returns (uint112) {\\n        if (n > type(uint112).max) revert InvalidUInt112();\\n        return uint112(n);\\n    }\\n\\n    /**\\n     * @notice Casts a given uint256 value to a uint128,\\n     *         ensuring that it is less than or equal to the maximum uint128 value.\\n     * @param  n The value to check.\\n     * @return The value casted to uint128.\\n     */\\n    function safe128(uint256 n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) revert InvalidUInt128();\\n        return uint128(n);\\n    }\\n\\n    /**\\n     * @notice Casts a given uint256 value to a uint240,\\n     *         ensuring that it is less than or equal to the maximum uint240 value.\\n     * @param  n The value to check.\\n     * @return The value casted to uint240.\\n     */\\n    function safe240(uint256 n) internal pure returns (uint240) {\\n        if (n > type(uint240).max) revert InvalidUInt240();\\n        return uint240(n);\\n    }\\n\\n    /**\\n     * @notice Limits a given uint256 value to the maximum uint32 value.\\n     * @param  n The value to check.\\n     * @return The value limited to within uint32 bounds.\\n     */\\n    function bound32(uint256 n) internal pure returns (uint32) {\\n        return uint32(min256(n, uint256(type(uint32).max)));\\n    }\\n\\n    /**\\n     * @notice Limits a given uint256 value to the maximum uint112 value.\\n     * @param  n The value to check.\\n     * @return The value limited to within uint112 bounds.\\n     */\\n    function bound112(uint256 n) internal pure returns (uint112) {\\n        return uint112(min256(n, uint256(type(uint112).max)));\\n    }\\n\\n    /**\\n     * @notice Limits a given uint256 value to the maximum uint128 value.\\n     * @param  n The value to check.\\n     * @return The value limited to within uint128 bounds.\\n     */\\n    function bound128(uint256 n) internal pure returns (uint128) {\\n        return uint128(min256(n, uint256(type(uint128).max)));\\n    }\\n\\n    /**\\n     * @notice Limits a given uint256 value to the maximum uint240 value.\\n     * @param  n The value to check.\\n     * @return The value limited to within uint240 bounds.\\n     */\\n    function bound240(uint256 n) internal pure returns (uint240) {\\n        return uint240(min256(n, uint256(type(uint240).max)));\\n    }\\n\\n    /**\\n     * @notice Compares two uint32 values and returns the larger one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The larger value.\\n     */\\n    function max32(uint32 a_, uint32 b_) internal pure returns (uint32) {\\n        return a_ > b_ ? a_ : b_;\\n    }\\n\\n    /**\\n     * @notice Compares two uint40 values and returns the larger one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The larger value.\\n     */\\n    function max40(uint40 a_, uint40 b_) internal pure returns (uint40) {\\n        return a_ > b_ ? a_ : b_;\\n    }\\n\\n    /**\\n     * @notice Compares two uint32 values and returns the lesser one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The lesser value.\\n     */\\n    function min32(uint32 a_, uint32 b_) internal pure returns (uint32) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    /**\\n     * @notice Compares two uint40 values and returns the lesser one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The lesser value.\\n     */\\n    function min40(uint40 a_, uint40 b_) internal pure returns (uint40) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    /**\\n     * @notice Compares two uint240 values and returns the lesser one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The lesser value.\\n     */\\n    function min240(uint240 a_, uint240 b_) internal pure returns (uint240) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    /**\\n     * @notice Compares two uint112 values and returns the lesser one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The lesser value.\\n     */\\n    function min112(uint112 a_, uint112 b_) internal pure returns (uint112) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    /**\\n     * @notice Compares two uint256 values and returns the lesser one.\\n     * @param  a_  Value to check.\\n     * @param  b_  Value to check.\\n     * @return The lesser value.\\n     */\\n    function min256(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/libs/ContinuousIndexingMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { UIntMath } from \\\"../../lib/common/src/libs/UIntMath.sol\\\";\\n\\n/**\\n * @title  Arithmetic library with operations for calculating continuous indexing.\\n * @author M^0 Labs\\n */\\nlibrary ContinuousIndexingMath {\\n    /* ============ Variables ============ */\\n\\n    /// @notice The number of seconds in a year.\\n    uint32 internal constant SECONDS_PER_YEAR = 31_536_000;\\n\\n    /// @notice 100% in basis points.\\n    uint16 internal constant BPS_SCALED_ONE = 1e4;\\n\\n    /// @notice The scaling of rates in for exponent math.\\n    uint56 internal constant EXP_SCALED_ONE = 1e12;\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Emitted when a division by zero occurs.\\n    error DivisionByZero();\\n\\n    /* ============ Internal View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / index`, rounded down.\\n     * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n     */\\n    function divideDown(uint240 x, uint128 index) internal pure returns (uint112 z) {\\n        if (index == 0) revert DivisionByZero();\\n\\n        unchecked {\\n            // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are\\n            //       only used for the purpose of principal/present amount calculations for continuous indexing, and\\n            //       so for an `x` to be large enough to overflow this, it would have to be a possible result of\\n            //       `multiplyDown` or `multiplyUp`, which would already satisfy\\n            //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.\\n            return UIntMath.safe112((uint256(x) * EXP_SCALED_ONE) / index);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / index`, rounded up.\\n     * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n     */\\n    function divideUp(uint240 x, uint128 index) internal pure returns (uint112 z) {\\n        if (index == 0) revert DivisionByZero();\\n\\n        unchecked {\\n            // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are\\n            //       only used for the purpose of principal/present amount calculations for continuous indexing, and\\n            //       so for an `x` to be large enough to overflow this, it would have to be a possible result of\\n            //       `multiplyDown` or `multiplyUp`, which would already satisfy\\n            //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.\\n            return UIntMath.safe112(((uint256(x) * EXP_SCALED_ONE) + index - 1) / index);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded down.\\n     * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n     */\\n    function multiplyDown(uint112 x, uint128 index) internal pure returns (uint240 z) {\\n        unchecked {\\n            return uint240((uint256(x) * index) / EXP_SCALED_ONE);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded up.\\n     * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n     */\\n    function multiplyUp(uint112 x, uint128 index) internal pure returns (uint240 z) {\\n        unchecked {\\n            return uint240(((uint256(x) * index) + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded down.\\n     * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n     */\\n    function multiplyIndicesDown(uint128 index, uint48 deltaIndex) internal pure returns (uint144 z) {\\n        unchecked {\\n            return uint144((uint256(index) * deltaIndex) / EXP_SCALED_ONE);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded up.\\n     * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n     */\\n    function multiplyIndicesUp(uint128 index, uint48 deltaIndex) internal pure returns (uint144 z) {\\n        unchecked {\\n            return uint144((uint256(index) * deltaIndex + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate e^rt (continuous compounding formula).\\n     * @dev    `uint64 yearlyRate` can accommodate 1000% interest per year.\\n     * @dev    `uint32 time` can accommodate 100 years.\\n     * @dev    `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR` fits in a `uint72`.\\n     */\\n    function getContinuousIndex(uint64 yearlyRate, uint32 time) internal pure returns (uint48 index) {\\n        unchecked {\\n            // NOTE: Casting `uint256(yearlyRate) * time` to a `uint72` is safe because the largest value is\\n            //      `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR`, which is less than `type(uint72).max`.\\n            return exponent(uint72((uint256(yearlyRate) * time) / SECONDS_PER_YEAR));\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to calculate y = e^x using R(4,4) Pad\u00e9 approximation:\\n     *           e(x) = (1 + x/2 + 3(x^2)/28 + x^3/84 + x^4/1680) / (1 - x/2 + 3(x^2)/28 - x^3/84 + x^4/1680)\\n     *           See: https://en.wikipedia.org/wiki/Pad%C3%A9_table\\n     *           See: https://www.wolframalpha.com/input?i=PadeApproximant%5Bexp%5Bx%5D%2C%7Bx%2C0%2C%7B4%2C+4%7D%7D%5D\\n     *         Despite itself being a whole number, `x` represents a real number scaled by `EXP_SCALED_ONE`, thus\\n     *         allowing for y = e^x where x is a real number.\\n     * @dev    Output `y` for a `uint72` input `x` will fit in `uint48`\\n     */\\n    function exponent(uint72 x) internal pure returns (uint48 y) {\\n        // NOTE: This can be done unchecked even for `x = type(uint72).max`.\\n        //       Verify by removing `unchecked` and running `test_exponent()`.\\n        unchecked {\\n            uint256 x2 = uint256(x) * x;\\n\\n            // `additiveTerms` is `(1 + 3(x^2)/28 + x^4/1680)`, and scaled by `84e27`.\\n            // NOTE: `84e27` the cleanest and largest scalar, given the various intermediate overflow possibilities.\\n            // NOTE: The resulting `(x2 * x2) / 20e21` term has been split up in order to avoid overflow of `x2 * x2`.\\n            uint256 additiveTerms = 84e27 + (9e3 * x2) + ((x2 / 2e11) * (x2 / 1e11));\\n\\n            // `differentTerms` is `(- x/2 - x^3/84)`, but positive (will be subtracted later), and scaled by `84e27`.\\n            uint256 differentTerms = uint256(x) * (42e15 + (x2 / 1e9));\\n\\n            // Result needs to be scaled by `1e12`.\\n            // NOTE: Can cast to `uint48` because contents can never be larger than `type(uint48).max` for any `x`.\\n            //       Max `y` is ~200e12, before falling off. See links above for reference.\\n            return uint48(((additiveTerms + differentTerms) * 1e12) / (additiveTerms - differentTerms));\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to convert 12-decimal representation to basis points.\\n     * @param  input The input in 12-decimal representation.\\n     * @return The output in basis points.\\n     */\\n    function convertToBasisPoints(uint64 input) internal pure returns (uint40) {\\n        unchecked {\\n            return uint40((uint256(input) * BPS_SCALED_ONE) / EXP_SCALED_ONE);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to convert basis points to 12-decimal representation.\\n     * @param  input The input in basis points.\\n     * @return The output in 12-decimal representation.\\n     */\\n    function convertFromBasisPoints(uint32 input) internal pure returns (uint64) {\\n        unchecked {\\n            return uint64((uint256(input) * EXP_SCALED_ONE) / BPS_SCALED_ONE);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/interfaces/IMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20Extended } from \\\"../../lib/common/src/interfaces/IERC20Extended.sol\\\";\\n\\nimport { IContinuousIndexing } from \\\"./IContinuousIndexing.sol\\\";\\n\\n/**\\n * @title  M Token Interface.\\n * @author M^0 Labs\\n */\\ninterface IMToken is IContinuousIndexing, IERC20Extended {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when account starts being an M earner.\\n     * @param  account The account that started earning.\\n     */\\n    event StartedEarning(address indexed account);\\n\\n    /**\\n     * @notice Emitted when account stops being an M earner.\\n     * @param  account The account that stopped earning.\\n     */\\n    event StoppedEarning(address indexed account);\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Emitted when there is insufficient balance to decrement from `account`.\\n     * @param  account     The account with insufficient balance.\\n     * @param  rawBalance  The raw balance of the account.\\n     * @param  amount      The amount to decrement the `rawBalance` by.\\n     */\\n    error InsufficientBalance(address account, uint256 rawBalance, uint256 amount);\\n\\n    /// @notice Emitted when calling `stopEarning` for an account approved as earner by TTG.\\n    error IsApprovedEarner();\\n\\n    /// @notice Emitted when calling `startEarning` for an account not approved as earner by TTG.\\n    error NotApprovedEarner();\\n\\n    /// @notice Emitted when calling `mint`, `burn` not by Minter Gateway.\\n    error NotMinterGateway();\\n\\n    /// @notice Emitted when principal of total supply (earning and non-earning) will overflow a `type(uint112).max`.\\n    error OverflowsPrincipalOfTotalSupply();\\n\\n    /// @notice Emitted in constructor if Minter Gateway is 0x0.\\n    error ZeroMinterGateway();\\n\\n    /// @notice Emitted in constructor if TTG Registrar is 0x0.\\n    error ZeroTTGRegistrar();\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Mints tokens.\\n     * @param  account The address of account to mint to.\\n     * @param  amount  The amount of M Token to mint.\\n     */\\n    function mint(address account, uint256 amount) external;\\n\\n    /**\\n     * @notice Burns tokens.\\n     * @param  account The address of account to burn from.\\n     * @param  amount  The amount of M Token to burn.\\n     */\\n    function burn(address account, uint256 amount) external;\\n\\n    /// @notice Starts earning for caller if allowed by TTG.\\n    function startEarning() external;\\n\\n    /// @notice Stops earning for caller.\\n    function stopEarning() external;\\n\\n    /**\\n     * @notice Stops earning for `account`.\\n     * @dev    MUST revert if `account` is an approved earner in TTG Registrar.\\n     * @param  account The account to stop earning for.\\n     */\\n    function stopEarning(address account) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice The address of the Minter Gateway contract.\\n    function minterGateway() external view returns (address);\\n\\n    /// @notice The address of the TTG Registrar contract.\\n    function ttgRegistrar() external view returns (address);\\n\\n    /// @notice The address of TTG approved earner rate model.\\n    function rateModel() external view returns (address);\\n\\n    /// @notice The current value of earner rate in basis points.\\n    function earnerRate() external view returns (uint32);\\n\\n    /**\\n     * @notice The principal of an earner M token balance.\\n     * @param  account The account to get the principal balance of.\\n     * @return The principal balance of the account.\\n     */\\n    function principalBalanceOf(address account) external view returns (uint240);\\n\\n    /// @notice The principal of the total earning supply of M Token.\\n    function principalOfTotalEarningSupply() external view returns (uint112);\\n\\n    /// @notice The total earning supply of M Token.\\n    function totalEarningSupply() external view returns (uint240);\\n\\n    /// @notice The total non-earning supply of M Token.\\n    function totalNonEarningSupply() external view returns (uint240);\\n\\n    /**\\n     * @notice Checks if account is an earner.\\n     * @param  account The account to check.\\n     * @return True if account is an earner, false otherwise.\\n     */\\n    function isEarning(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/interfaces/IMinterGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC712 } from \\\"../../lib/common/src/interfaces/IERC712.sol\\\";\\n\\nimport { IContinuousIndexing } from \\\"./IContinuousIndexing.sol\\\";\\n\\n/**\\n * @title  Minter Gateway Interface.\\n * @author M^0 Labs\\n */\\ninterface IMinterGateway is IContinuousIndexing, IERC712 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when M tokens are burned and an inactive minter's owed M balance decreased.\\n     * @param  minter The address of the minter.\\n     * @param  amount The amount of M tokens burned.\\n     * @param  payer  The address of the payer.\\n     */\\n    event BurnExecuted(address indexed minter, uint240 amount, address indexed payer);\\n\\n    /**\\n     * @notice Emitted when M tokens are burned and an active minter's owed M balance decreased.\\n     * @param  minter          The address of the minter.\\n     * @param  principalAmount The principal amount of M tokens burned.\\n     * @param  amount          The amount of M tokens burned.\\n     * @param  payer           The address of the payer.\\n     */\\n    event BurnExecuted(address indexed minter, uint112 principalAmount, uint240 amount, address indexed payer);\\n\\n    /**\\n     * @notice Emitted when a minter's collateral is updated.\\n     * @param  minter                           Address of the minter\\n     * @param  collateral                       The latest amount of collateral\\n     * @param  totalResolvedCollateralRetrieval The total collateral amount of outstanding retrievals resolved.\\n     * @param  metadataHash                     The hash of some metadata reserved for future informational use.\\n     * @param  timestamp                        The timestamp of the collateral update,\\n     *                                          minimum of given validators' signatures.\\n     */\\n    event CollateralUpdated(\\n        address indexed minter,\\n        uint240 collateral,\\n        uint240 totalResolvedCollateralRetrieval,\\n        bytes32 indexed metadataHash,\\n        uint40 timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when a minter is activated.\\n     * @param  minter Address of the minter that was activated\\n     * @param  caller Address who called the function\\n     */\\n    event MinterActivated(address indexed minter, address indexed caller);\\n\\n    /**\\n     * @notice Emitted when a minter is deactivated.\\n     * @param  minter        Address of the minter that was deactivated.\\n     * @param  inactiveOwedM Amount of M tokens owed by the minter (in an inactive state).\\n     * @param  caller        Address who called the function.\\n     */\\n    event MinterDeactivated(address indexed minter, uint240 inactiveOwedM, address indexed caller);\\n\\n    /**\\n     * @notice Emitted when a minter is frozen.\\n     * @param  minter      Address of the minter that was frozen\\n     * @param  frozenUntil Timestamp until the minter is frozen\\n     */\\n    event MinterFrozen(address indexed minter, uint40 frozenUntil);\\n\\n    /**\\n     * @notice Emitted when a mint proposal is canceled.\\n     * @param  mintId    The id of the canceled mint proposal.\\n     * @param  minter    The address of the minter for which the mint was canceled.\\n     * @param  canceller The address of the validator who canceled the mint proposal.\\n     */\\n    event MintCanceled(uint48 indexed mintId, address indexed minter, address indexed canceller);\\n\\n    /**\\n     * @notice Emitted when a mint proposal is executed.\\n     * @param  mintId          The id of the executed mint proposal.\\n     * @param  minter          The address of the minter that executed the mint.\\n     * @param  principalAmount The principal amount of M tokens minted.\\n     * @param  amount          The amount of M tokens minted.\\n     */\\n    event MintExecuted(uint48 indexed mintId, address indexed minter, uint112 principalAmount, uint240 amount);\\n\\n    /**\\n     * @notice Emitted when a mint proposal is created.\\n     * @param  mintId      The id of mint proposal.\\n     * @param  minter      The address of the minter that proposed the mint.\\n     * @param  amount      The amount of M tokens to mint.\\n     * @param  destination The address to mint to.\\n     */\\n    event MintProposed(uint48 indexed mintId, address indexed minter, uint240 amount, address indexed destination);\\n\\n    /**\\n     * @notice Emitted when a penalty is imposed on `minter` for missed update collateral intervals.\\n     * @param  minter          The address of the minter.\\n     * @param  missedIntervals The number of update intervals missed.\\n     * @param  penaltyAmount   The present amount of penalty charge.\\n     */\\n    event MissedIntervalsPenaltyImposed(address indexed minter, uint40 missedIntervals, uint240 penaltyAmount);\\n\\n    /**\\n     * @notice Emitted when a penalty is imposed on `minter` for undercollateralization.\\n     * @param  minter        The address of the minter.\\n     * @param  excessOwedM   The present amount of owed M in excess of allowed owed M.\\n     * @param  timeSpan      The span of time over which the undercollateralization penalty was applied.\\n     * @param  penaltyAmount The present amount of penalty charge.\\n     */\\n    event UndercollateralizedPenaltyImposed(\\n        address indexed minter,\\n        uint240 excessOwedM,\\n        uint40 timeSpan,\\n        uint240 penaltyAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when a collateral retrieval proposal is created.\\n     * @param  retrievalId The id of retrieval proposal.\\n     * @param  minter      The address of the minter.\\n     * @param  amount      The amount of collateral to retrieve.\\n     */\\n    event RetrievalCreated(uint48 indexed retrievalId, address indexed minter, uint240 amount);\\n\\n    /**\\n     * @notice Emitted when a collateral retrieval proposal is resolved.\\n     * @param  retrievalId The id of retrieval proposal.\\n     * @param  minter      The address of the minter.\\n     */\\n    event RetrievalResolved(uint48 indexed retrievalId, address indexed minter);\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Emitted when calling `activateMinter` with a minter who was previously deactivated.\\n    error DeactivatedMinter();\\n\\n    /// @notice Emitted when repay will burn more M than the repay specified.\\n    error ExceedsMaxRepayAmount(uint240 amount, uint240 maxAmount);\\n\\n    /// @notice Emitted when calling `mintM` with a proposal that was created more than `mintDelay + mintTTL` time ago.\\n    error ExpiredMintProposal(uint40 deadline);\\n\\n    /// @notice Emitted when calling `mintM` or `proposeMint` by a minter who was frozen by validator.\\n    error FrozenMinter();\\n\\n    /// @notice Emitted when calling `updateCollateral` with any validator timestamp in the future.\\n    error FutureTimestamp();\\n\\n    /// @notice Emitted when calling a function only allowed for active minters.\\n    error InactiveMinter();\\n\\n    /// @notice Emitted when calling `cancelMint` or `mintM` with invalid `mintId`.\\n    error InvalidMintProposal();\\n\\n    /// @notice Emitted when calling `updateCollateral` if `validators` addresses are not ordered in ascending order.\\n    error InvalidSignatureOrder();\\n\\n    /// @notice Emitted when calling `activateMinter` if minter was not approved by TTG.\\n    error NotApprovedMinter();\\n\\n    /// @notice Emitted when calling `cancelMint` or `freezeMinter` if `validator` was not approved by TTG.\\n    error NotApprovedValidator(address validator);\\n\\n    /// @notice Emitted when calling `updateCollateral` if `validatorThreshold` of signatures was not reached.\\n    error NotEnoughValidSignatures(uint256 validSignatures, uint256 requiredThreshold);\\n\\n    /// @notice Emitted when principal of total owed M (active and inactive) will overflow a `type(uint112).max`.\\n    error OverflowsPrincipalOfTotalOwedM();\\n\\n    /// @notice Emitted when calling `mintM` if `mintDelay` time has not passed yet.\\n    error PendingMintProposal(uint40 activeTimestamp);\\n\\n    /// @notice Emitted when calling `proposeRetrieval` if sum of all outstanding retrievals\\n    ///         Plus new proposed retrieval amount is greater than collateral.\\n    error RetrievalsExceedCollateral(uint240 totalPendingRetrievals, uint240 collateral);\\n\\n    /// @notice Emitted when calling `updateCollateral`\\n    ///         If `validators`, `signatures`, `timestamps` lengths do not match.\\n    error SignatureArrayLengthsMismatch();\\n\\n    /// @notice Emitted when updating collateral with a timestamp earlier than allowed.\\n    error StaleCollateralUpdate(uint40 newTimestamp, uint40 earliestAllowedTimestamp);\\n\\n    /// @notice Emitted when calling `updateCollateral` with any validator timestamp older than the last signature\\n    ///         timestamp for that minter and validator.\\n    error OutdatedValidatorTimestamp(address validator, uint256 timestamp, uint256 lastSignatureTimestamp);\\n\\n    /// @notice Emitted when calling `deactivateMinter` with a minter still approved in TTG Registrar.\\n    error StillApprovedMinter();\\n\\n    /**\\n     * @notice Emitted when calling `proposeMint`, `mintM`, `proposeRetrieval`\\n     *         If minter position becomes undercollateralized.\\n     * @dev    `activeOwedM` is a `uint256` because it may represent some resulting owed M from computations.\\n     */\\n    error Undercollateralized(uint256 activeOwedM, uint256 maxAllowedOwedM);\\n\\n    /// @notice Emitted when calling `burnM` if amount is 0.\\n    error ZeroBurnAmount();\\n\\n    /// @notice Emitted in constructor if M Token is 0x0.\\n    error ZeroMToken();\\n\\n    /// @notice Emitted when calling `proposeMint` if amount is 0.\\n    error ZeroMintAmount();\\n\\n    /// @notice Emitted when calling `proposeMint` if destination is 0x0.\\n    error ZeroMintDestination();\\n\\n    /// @notice Emitted when calling `proposeRetrieval` if collateral is 0.\\n    error ZeroRetrievalAmount();\\n\\n    /// @notice Emitted in constructor if TTG Registrar is 0x0.\\n    error ZeroTTGRegistrar();\\n\\n    /// @notice Emitted in constructor if TTG Distribution Vault is set to 0x0 in TTG Registrar.\\n    error ZeroTTGVault();\\n\\n    /// @notice Emitted when calling `updateCollateral` with any validator timestamp of 0.\\n    error ZeroTimestamp();\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Updates collateral for minters\\n     * @param  collateral   The amount of collateral\\n     * @param  retrievalIds The list of active proposeRetrieval requests to close\\n     * @param  metadataHash The hash of metadata of the collateral update, reserved for future informational use\\n     * @param  validators   The list of validators\\n     * @param  timestamps   The list of timestamps of validators' signatures\\n     * @param  signatures   The list of signatures\\n     * @return minTimestamp The minimum timestamp of all validators' signatures\\n     */\\n    function updateCollateral(\\n        uint256 collateral,\\n        uint256[] calldata retrievalIds,\\n        bytes32 metadataHash,\\n        address[] calldata validators,\\n        uint256[] calldata timestamps,\\n        bytes[] calldata signatures\\n    ) external returns (uint40 minTimestamp);\\n\\n    /**\\n     * @notice Proposes retrieval of minter's off-chain collateral\\n     * @param  collateral  The amount of collateral to retrieve\\n     * @return retrievalId The unique id of created retrieval proposal\\n     */\\n    function proposeRetrieval(uint256 collateral) external returns (uint48 retrievalId);\\n\\n    /**\\n     * @notice Proposes minting of M tokens\\n     * @param  amount      The amount of M tokens to mint\\n     * @param  destination The address to mint to\\n     * @return mintId      The unique id of created mint proposal\\n     */\\n    function proposeMint(uint256 amount, address destination) external returns (uint48 mintId);\\n\\n    /**\\n     * @notice Executes minting of M tokens\\n     * @param  mintId          The id of outstanding mint proposal for minter\\n     * @return principalAmount The amount of principal of owed M minted.\\n     * @return amount          The amount of M tokens minted.\\n     */\\n    function mintM(uint256 mintId) external returns (uint112 principalAmount, uint240 amount);\\n\\n    /**\\n     * @notice Burns M tokens\\n     * @dev    If amount to burn is greater than minter's owedM including penalties, burn all up to owedM.\\n     * @param  minter          The address of the minter to burn M tokens for.\\n     * @param  maxAmount       The max amount of M tokens to burn.\\n     * @return principalAmount The amount of principal of owed M burned.\\n     * @return amount          The amount of M tokens burned.\\n     */\\n    function burnM(address minter, uint256 maxAmount) external returns (uint112 principalAmount, uint240 amount);\\n\\n    /**\\n     * @notice Burns M tokens\\n     * @dev    If amount to burn is greater than minter's owedM including penalties, burn all up to owedM.\\n     * @param  minter             The address of the minter to burn M tokens for.\\n     * @param  maxPrincipalAmount The max amount of principal of owed M to burn.\\n     * @param  maxAmount          The max amount of M tokens to burn.\\n     * @return principalAmount    The amount of principal of owed M burned.\\n     * @return amount             The amount of M tokens burned.\\n     */\\n    function burnM(\\n        address minter,\\n        uint256 maxPrincipalAmount,\\n        uint256 maxAmount\\n    ) external returns (uint112 principalAmount, uint240 amount);\\n\\n    /**\\n     * @notice Cancels minting request for selected minter by validator\\n     * @param  minter The address of the minter to cancelMint minting request for\\n     * @param  mintId The id of outstanding mint request\\n     */\\n    function cancelMint(address minter, uint256 mintId) external;\\n\\n    /**\\n     * @notice Freezes minter\\n     * @param  minter      The address of the minter to freeze\\n     * @return frozenUntil The timestamp until which minter is frozen\\n     */\\n    function freezeMinter(address minter) external returns (uint40 frozenUntil);\\n\\n    /**\\n     * @notice Activate an approved minter.\\n     * @dev    MUST revert if `minter` is not recorded as an approved minter in TTG Registrar.\\n     * @dev    MUST revert if `minter` has been deactivated.\\n     * @param  minter The address of the minter to activate\\n     */\\n    function activateMinter(address minter) external;\\n\\n    /**\\n     * @notice Deactivates an active minter.\\n     * @dev    MUST revert if the minter is still approved.\\n     * @dev    MUST revert if the minter is not active.\\n     * @param  minter        The address of the minter to deactivate.\\n     * @return inactiveOwedM The inactive owed M for the deactivated minter.\\n     */\\n    function deactivateMinter(address minter) external returns (uint240 inactiveOwedM);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice The address of M token\\n    function mToken() external view returns (address);\\n\\n    /// @notice The address of TTG Registrar contract.\\n    function ttgRegistrar() external view returns (address);\\n\\n    /// @notice The address of TTG Vault contract.\\n    function ttgVault() external view returns (address);\\n\\n    /// @notice The last saved value of Minter rate.\\n    function minterRate() external view returns (uint32);\\n\\n    /// @notice The principal of total owed M for all active minters.\\n    function principalOfTotalActiveOwedM() external view returns (uint112);\\n\\n    /// @notice The total owed M for all active minters.\\n    function totalActiveOwedM() external view returns (uint240);\\n\\n    /// @notice The total owed M for all inactive minters.\\n    function totalInactiveOwedM() external view returns (uint240);\\n\\n    /// @notice The total owed M for all minters.\\n    function totalOwedM() external view returns (uint240);\\n\\n    /// @notice The difference between total owed M and M token total supply.\\n    function excessOwedM() external view returns (uint240);\\n\\n    /// @notice The principal of active owed M of minter.\\n    function principalOfActiveOwedMOf(address minter_) external view returns (uint112);\\n\\n    /// @notice The active owed M of minter.\\n    function activeOwedMOf(address minter) external view returns (uint240);\\n\\n    /**\\n     * @notice The max allowed active owed M of minter taking into account collateral amount and retrieval proposals.\\n     * @dev    This is the only present value that requires a `uint256` since it is the result of a multiplication\\n     *         between a `uint240` and a value that has a max of `65,000` (the mint ratio).\\n     */\\n    function maxAllowedActiveOwedMOf(address minter) external view returns (uint256);\\n\\n    /// @notice The inactive owed M of deactivated minter.\\n    function inactiveOwedMOf(address minter) external view returns (uint240);\\n\\n    /// @notice The collateral of a given minter.\\n    function collateralOf(address minter) external view returns (uint240);\\n\\n    /// @notice The timestamp of the last collateral update of minter.\\n    function collateralUpdateTimestampOf(address minter) external view returns (uint40);\\n\\n    /// @notice The timestamp after which an additional penalty for a missed update interval will be charged.\\n    function collateralPenaltyDeadlineOf(address minter) external view returns (uint40);\\n\\n    /// @notice The timestamp after which the minter's collateral is assumed to be 0 due to a missed update.\\n    function collateralExpiryTimestampOf(address minter) external view returns (uint40);\\n\\n    /// @notice The timestamp until which minter is already penalized for missed collateral updates.\\n    function penalizedUntilOf(address minter) external view returns (uint40);\\n\\n    /// @notice The timestamp when `minter` created their latest retrieval proposal.\\n    function latestProposedRetrievalTimestampOf(address minter) external view returns (uint40);\\n\\n    /**\\n     * @notice Returns the last signature timestamp used by `validator` to update collateral for `minter`.\\n     * @param  minter    The address of the minter.\\n     * @param  validator The address of the validator.\\n     * @return The last signature timestamp used.\\n     */\\n    function getLastSignatureTimestamp(address minter, address validator) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the EIP-712 digest for updateCollateral method.\\n     * @param  minter       The address of the minter.\\n     * @param  collateral   The amount of collateral.\\n     * @param  retrievalIds The list of outstanding collateral retrieval IDs to resolve.\\n     * @param  metadataHash The hash of metadata of the collateral update, reserved for future informational use.\\n     * @param  timestamp    The timestamp of the collateral update.\\n     */\\n    function getUpdateCollateralDigest(\\n        address minter,\\n        uint256 collateral,\\n        uint256[] calldata retrievalIds,\\n        bytes32 metadataHash,\\n        uint256 timestamp\\n    ) external view returns (bytes32);\\n\\n    /// @notice The mint proposal of minters, only 1 active proposal per minter\\n    function mintProposalOf(\\n        address minter\\n    ) external view returns (uint48 mintId, uint40 createdAt, address destination, uint240 amount);\\n\\n    /// @notice The amount of a pending retrieval request for an active minter.\\n    function pendingCollateralRetrievalOf(address minter, uint256 retrievalId) external view returns (uint240);\\n\\n    /// @notice The total amount of pending retrieval requests for an active minter.\\n    function totalPendingCollateralRetrievalOf(address minter) external view returns (uint240);\\n\\n    /// @notice The timestamp when minter becomes unfrozen after being frozen by validator.\\n    function frozenUntilOf(address minter) external view returns (uint40);\\n\\n    /// @notice Checks if minter was activated after approval by TTG\\n    function isActiveMinter(address minter) external view returns (bool);\\n\\n    /// @notice Checks if minter was deactivated after removal by TTG\\n    function isDeactivatedMinter(address minter) external view returns (bool);\\n\\n    /// @notice Checks if minter was frozen by validator\\n    function isFrozenMinter(address minter) external view returns (bool);\\n\\n    /// @notice Checks if minter was approved by TTG\\n    function isMinterApproved(address minter) external view returns (bool);\\n\\n    /// @notice Checks if validator was approved by TTG\\n    function isValidatorApproved(address validator) external view returns (bool);\\n\\n    /// @notice The delay between mint proposal creation and its earliest execution.\\n    function mintDelay() external view returns (uint32);\\n\\n    /// @notice The time while mint request can still be processed before it is considered expired.\\n    function mintTTL() external view returns (uint32);\\n\\n    /// @notice The freeze time for minter.\\n    function minterFreezeTime() external view returns (uint32);\\n\\n    /// @notice The allowed activeOwedM to collateral ratio.\\n    function mintRatio() external view returns (uint32);\\n\\n    /// @notice The % that defines penalty amount for missed collateral updates or excessive owedM value\\n    function penaltyRate() external view returns (uint32);\\n\\n    /// @notice The smart contract that defines the minter rate.\\n    function rateModel() external view returns (address);\\n\\n    /// @notice The interval that defines the required frequency of collateral updates.\\n    function updateCollateralInterval() external view returns (uint32);\\n\\n    /// @notice The number of signatures required for successful collateral update.\\n    function updateCollateralValidatorThreshold() external view returns (uint256);\\n\\n    /// @notice Descaler for variables in basis points. Effectively, 100% in basis points.\\n    function ONE() external pure returns (uint16);\\n\\n    /// @notice Mint ratio cap. 650% in basis points.\\n    function MAX_MINT_RATIO() external pure returns (uint32);\\n\\n    /// @notice Update collateral interval lower cap in seconds.\\n    function MIN_UPDATE_COLLATERAL_INTERVAL() external pure returns (uint32);\\n\\n    /// @notice The EIP-712 typehash for the `updateCollateral` method.\\n    function UPDATE_COLLATERAL_TYPEHASH() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/interfaces/IRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Rate Model Interface.\\n * @author M^0 Labs\\n */\\ninterface IRateModel {\\n    /**\\n     * @notice Returns the current yearly rate in BPS.\\n     *         This value does not account for the compounding interest.\\n     */\\n    function rate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/interfaces/ITTGRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  TTG (Two Token Governance) Registrar interface.\\n * @author M^0 Labs\\n */\\ninterface ITTGRegistrar {\\n    /**\\n     * @notice Key value pair getter.\\n     * @param  key The key to get the value of.\\n     * @return value The value of the key.\\n     */\\n    function get(bytes32 key) external view returns (bytes32 value);\\n\\n    /**\\n     * @notice Checks if the list contains the account.\\n     * @param  list The list to check.\\n     * @param  account The account to check.\\n     * @return True if the list contains the account, false otherwise.\\n     */\\n    function listContains(bytes32 list, address account) external view returns (bool);\\n\\n    /// @notice Returns the vault contract address.\\n    function vault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/rateModels/interfaces/IEarnerRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IRateModel } from \\\"../../interfaces/IRateModel.sol\\\";\\n\\n/**\\n * @title  Earner Rate Model Interface.\\n * @author M^0 Labs\\n */\\ninterface IEarnerRateModel is IRateModel {\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Emitted when M Token contract address is zero.\\n    error ZeroMToken();\\n\\n    /// @notice Emitted when Minter Gateway contract address is zero.\\n    error ZeroMinterGateway();\\n\\n    /// @notice Emitted when TTG Registrar contract address is zero.\\n    error ZeroTTGRegistrar();\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice The interval over which there's confidence cash flow to earners will not exceed cash flows from minters.\\n    function RATE_CONFIDENCE_INTERVAL() external view returns (uint32);\\n\\n    /// @notice The percent (in basis points) of the earner rate that will be effectively used.\\n    function RATE_MULTIPLIER() external view returns (uint32);\\n\\n    /// @notice 100% in basis points.\\n    function ONE() external view returns (uint32);\\n\\n    /// @notice The M Token contract address.\\n    function mToken() external view returns (address);\\n\\n    /// @notice The Minter Gateway contract address.\\n    function minterGateway() external view returns (address);\\n\\n    /// @notice The TTG Registrar contract address.\\n    function ttgRegistrar() external view returns (address);\\n\\n    /// @notice The max rate in basis points.\\n    function maxRate() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the safe earner rate.\\n     * @param  totalActiveOwedM   The total active owed M.\\n     * @param  totalEarningSupply The total earning supply of M Token.\\n     * @param  minterRate         The minter rate.\\n     * @return The safe earner rate.\\n     */\\n    function getSafeEarnerRate(\\n        uint240 totalActiveOwedM,\\n        uint240 totalEarningSupply,\\n        uint32 minterRate\\n    ) external pure returns (uint32);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/interfaces/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\nimport { IERC3009 } from \\\"./IERC3009.sol\\\";\\n\\n/**\\n * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712\\n *         and with EIP-1271 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).\\n * @author M^0 Labs\\n * @dev    The additional interface as defined by EIP-2612: https://eips.ethereum.org/EIPS/eip-2612\\n */\\ninterface IERC20Extended is IERC20, IERC3009 {\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Revert message when spender's allowance is not sufficient.\\n     * @param  spender    Address that may be allowed to operate on tokens without being their owner.\\n     * @param  allowance  Amount of tokens a `spender` is allowed to operate with.\\n     * @param  needed     Minimum amount required to perform a transfer.\\n     */\\n    error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @notice Revert message emitted when the transferred amount is insufficient.\\n     * @param  amount Amount transferred.\\n     */\\n    error InsufficientAmount(uint256 amount);\\n\\n    /**\\n     * @notice Revert message emitted when the recipient of a token is invalid.\\n     * @param  recipient Address of the invalid recipient.\\n     */\\n    error InvalidRecipient(address recipient);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.\\n     * @param  owner    The address of the account who's token balance is being approved to be spent by `spender`.\\n     * @param  spender  The address of an account allowed to spend on behalf of `owner`.\\n     * @param  value    The amount of the allowance being approved.\\n     * @param  deadline The last block number where the signature is still valid.\\n     * @param  v        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).\\n     * @param  r        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).\\n     * @param  s        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.\\n     * @param  owner     The address of the account who's token balance is being approved to be spent by `spender`.\\n     * @param  spender   The address of an account allowed to spend on behalf of `owner`.\\n     * @param  value     The amount of the allowance being approved.\\n     * @param  deadline  The last block number where the signature is still valid.\\n     * @param  signature An arbitrary signature (EIP-712).\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the EIP712 typehash used in the encoding of the digest for the permit function.\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/src/interfaces/IContinuousIndexing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Continuous Indexing Interface.\\n * @author M^0 Labs\\n */\\ninterface IContinuousIndexing {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when the index is updated.\\n     * @param  index The new index.\\n     * @param  rate  The current rate.\\n     */\\n    event IndexUpdated(uint128 indexed index, uint32 indexed rate);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Updates the latest index and latest accrual time in storage.\\n     * @return index The new stored index for computing present amounts from principal amounts.\\n     */\\n    function updateIndex() external returns (uint128);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice The current index that would be written to storage if `updateIndex` is called.\\n    function currentIndex() external view returns (uint128);\\n\\n    /// @notice The latest updated index.\\n    function latestIndex() external view returns (uint128);\\n\\n    /// @notice The latest timestamp when the index was updated.\\n    function latestUpdateTimestamp() external view returns (uint40);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/interfaces/IERC712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Typed structured data hashing and signing via EIP-712.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-712: https://eips.ethereum.org/EIPS/eip-712\\n */\\ninterface IERC712 {\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Revert message when an invalid signature is detected.\\n    error InvalidSignature();\\n\\n    /// @notice Revert message when a signature with invalid length is detected.\\n    error InvalidSignatureLength();\\n\\n    /// @notice Revert message when the S portion of a signature is invalid.\\n    error InvalidSignatureS();\\n\\n    /// @notice Revert message when the V portion of a signature is invalid.\\n    error InvalidSignatureV();\\n\\n    /**\\n     * @notice Revert message when a signature is being used beyond its deadline (i.e. expiry).\\n     * @param  deadline  The deadline of the signature.\\n     * @param  timestamp The current timestamp.\\n     */\\n    error SignatureExpired(uint256 deadline, uint256 timestamp);\\n\\n    /// @notice Revert message when a recovered signer does not match the account being purported to have signed.\\n    error SignerMismatch();\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the EIP712 domain separator used in the encoding of a signed digest.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  ERC20 Token Standard.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-20: https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when `spender` has been approved for `amount` of the token balance of `account`.\\n     * @param  account The address of the account.\\n     * @param  spender The address of the spender being approved for the allowance.\\n     * @param  amount  The amount of the allowance being approved.\\n     */\\n    event Approval(address indexed account, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when `amount` tokens is transferred from `sender` to `recipient`.\\n     * @param  sender    The address of the sender who's token balance is decremented.\\n     * @param  recipient The address of the recipient who's token balance is incremented.\\n     * @param  amount    The amount of tokens being transferred.\\n     */\\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Allows a calling account to approve `spender` to spend up to `amount` of its token balance.\\n     * @dev    MUST emit an `Approval` event.\\n     * @param  spender The address of the account being allowed to spend up to the allowed amount.\\n     * @param  amount  The amount of the allowance being approved.\\n     * @return Whether or not the approval was successful.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice Allows a calling account to transfer `amount` tokens to `recipient`.\\n     * @param  recipient The address of the recipient who's token balance will be incremented.\\n     * @param  amount    The amount of tokens being transferred.\\n     * @return Whether or not the transfer was successful.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.\\n     * @param  sender    The address of the sender who's token balance will be decremented.\\n     * @param  recipient The address of the recipient who's token balance will be incremented.\\n     * @param  amount    The amount of tokens being transferred.\\n     * @return Whether or not the transfer was successful.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the allowance `spender` is allowed to spend on behalf of `account`.\\n     * @param  account The address of the account who's token balance `spender` is allowed to spend.\\n     * @param  spender The address of an account allowed to spend on behalf of `account`.\\n     * @return The amount `spender` can spend on behalf of `account`.\\n     */\\n    function allowance(address account, address spender) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the token balance of `account`.\\n     * @param  account The address of some account.\\n     * @return The token balance of `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals UIs should assume all amounts have.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the name of the contract/token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the current total supply of the token.\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/interfaces/IERC3009.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IStatefulERC712 } from \\\"./IStatefulERC712.sol\\\";\\n\\n/**\\n * @title  Transfer via signed authorization following EIP-3009 standard.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-3009: https://eips.ethereum.org/EIPS/eip-3009\\n */\\ninterface IERC3009 is IStatefulERC712 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when an authorization has been canceled.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the canceled authorization.\\n     */\\n    event AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\\n\\n    /**\\n     * @notice Emitted when an authorization has been used.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the used authorization.\\n     */\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Emitted when an authorization has already been used.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the used authorization.\\n     */\\n    error AuthorizationAlreadyUsed(address authorizer, bytes32 nonce);\\n\\n    /**\\n     * @notice Emitted when an authorization is expired.\\n     * @param  timestamp   Timestamp at which the transaction was submitted.\\n     * @param  validBefore Timestamp before which the authorization would have been valid.\\n     */\\n    error AuthorizationExpired(uint256 timestamp, uint256 validBefore);\\n\\n    /**\\n     * @notice Emitted when an authorization is not yet valid.\\n     * @param  timestamp  Timestamp at which the transaction was submitted.\\n     * @param  validAfter Timestamp after which the authorization will be valid.\\n     */\\n    error AuthorizationNotYetValid(uint256 timestamp, uint256 validAfter);\\n\\n    /**\\n     * @notice Emitted when the caller of `receiveWithAuthorization` is not the payee.\\n     * @param  caller Caller's address.\\n     * @param  payee  Payee's address.\\n     */\\n    error CallerMustBePayee(address caller, address payee);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization.\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes memory signature\\n    ) external;\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization.\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  r           An ECDSA/secp256k1 signature parameter.\\n     * @param  vs          An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes32 r,\\n        bytes32 vs\\n    ) external;\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization.\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  v           v of the signature.\\n     * @param  r           r of the signature.\\n     * @param  s           s of the signature.\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer.\\n     * @dev    This has an additional check to ensure that the payee's address matches\\n     *         the caller of this function to prevent front-running attacks.\\n     *         (See security considerations)\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes memory signature\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer.\\n     * @dev    This has an additional check to ensure that the payee's address matches\\n     *         the caller of this function to prevent front-running attacks.\\n     *         (See security considerations)\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  r           An ECDSA/secp256k1 signature parameter.\\n     * @param  vs          An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes32 r,\\n        bytes32 vs\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer.\\n     * @dev    This has an additional check to ensure that the payee's address matches\\n     *         the caller of this function to prevent front-running attacks.\\n     *         (See security considerations)\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  v           v of the signature.\\n     * @param  r           r of the signature.\\n     * @param  s           s of the signature.\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Attempt to cancel an authorization.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @param  signature  A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     */\\n    function cancelAuthorization(address authorizer, bytes32 nonce, bytes memory signature) external;\\n\\n    /**\\n     * @notice Attempt to cancel an authorization.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @param  r          An ECDSA/secp256k1 signature parameter.\\n     * @param  vs         An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function cancelAuthorization(address authorizer, bytes32 nonce, bytes32 r, bytes32 vs) external;\\n\\n    /**\\n     * @notice Attempt to cancel an authorization.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @param  v          v of the signature.\\n     * @param  r          r of the signature.\\n     * @param  s          s of the signature.\\n     */\\n    function cancelAuthorization(address authorizer, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the state of an authorization.\\n     * @dev    Nonces are randomly generated 32-byte data unique to the authorizer's address\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @return True if the nonce is used.\\n     */\\n    function authorizationState(address authorizer, bytes32 nonce) external view returns (bool);\\n\\n    /// @notice Returns `transferWithAuthorization` typehash.\\n    function TRANSFER_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n\\n    /// @notice Returns `receiveWithAuthorization` typehash.\\n    function RECEIVE_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n\\n    /// @notice Returns `cancelAuthorization` typehash.\\n    function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/interfaces/IStatefulERC712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC712Extended } from \\\"./IERC712Extended.sol\\\";\\n\\n/**\\n * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.\\n * @author M^0 Labs\\n */\\ninterface IStatefulERC712 is IERC712Extended {\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Revert message when a signing account's nonce is not the expected current nonce.\\n     * @param  nonce         The nonce used in the signature.\\n     * @param  expectedNonce The expected nonce to be used in a signature by the signing account.\\n     */\\n    error InvalidAccountNonce(uint256 nonce, uint256 expectedNonce);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the next nonce to be used in a signature by `account`.\\n     * @param  account The address of some account.\\n     * @return nonce   The next nonce to be used in a signature by `account`.\\n     */\\n    function nonces(address account) external view returns (uint256 nonce);\\n}\\n\"\r\n    },\r\n    \"lib/protocol/lib/common/src/interfaces/IERC712Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC712 } from \\\"./IERC712.sol\\\";\\n\\n/**\\n * @title  EIP-712 extended by EIP-5267.\\n * @author M^0 Labs\\n * @dev    The additional interface as defined by EIP-5267: https://eips.ethereum.org/EIPS/eip-5267\\n */\\ninterface IERC712Extended is IERC712 {\\n    /* ============ Events ============ */\\n\\n    /// @notice MAY be emitted to signal that the domain could have changed.\\n    event EIP712DomainChanged();\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the fields and values that describe the domain separator used by this contract for EIP-712.\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"common/=lib/protocol/lib/common/src/\",\r\n      \"contract-test-utils/=lib/ttg/lib/erc20-helper/lib/contract-test-utils/contracts/\",\r\n      \"ds-test/=lib/protocol/lib/solmate/lib/ds-test/src/\",\r\n      \"erc20-helper/=lib/ttg/lib/erc20-helper/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"protocol/=lib/protocol/\",\r\n      \"solmate/=lib/protocol/lib/solmate/src/\",\r\n      \"ttg/=lib/ttg/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minterGateway_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ZeroMToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroMinterGateway\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroTTGRegistrar\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_CONFIDENCE_INTERVAL\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint240\",\"name\":\"totalActiveOwedM_\",\"type\":\"uint240\"},{\"internalType\":\"uint240\",\"name\":\"totalEarningSupply_\",\"type\":\"uint240\"},{\"internalType\":\"uint32\",\"name\":\"minterRate_\",\"type\":\"uint32\"}],\"name\":\"getSafeEarnerRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterGateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ttgRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EarnerRateModel", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000f7f9638cb444d65e5a40bf5ff98ebe4ff319f04e", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}