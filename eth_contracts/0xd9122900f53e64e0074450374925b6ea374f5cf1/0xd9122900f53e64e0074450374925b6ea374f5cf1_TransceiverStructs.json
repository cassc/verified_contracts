{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/libraries/TransceiverStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"wormhole-solidity-sdk/libraries/BytesParsing.sol\\\";\\nimport \\\"./TrimmedAmount.sol\\\";\\n\\nlibrary TransceiverStructs {\\n    using BytesParsing for bytes;\\n    using TrimmedAmountLib for TrimmedAmount;\\n\\n    /// @notice Error thrown when the payload length exceeds the allowed maximum.\\n    /// @dev Selector 0xa3419691.\\n    /// @param size The size of the payload.\\n    error PayloadTooLong(uint256 size);\\n\\n    /// @notice Error thrown when the prefix of an encoded message\\n    ///         does not match the expected value.\\n    /// @dev Selector 0x56d2569d.\\n    /// @param prefix The prefix that was found in the encoded message.\\n    error IncorrectPrefix(bytes4 prefix);\\n\\n    /// @notice Error thrown when the transceiver instructions aren't\\n    ///         encoded with strictly increasing indices\\n    /// @dev Selector 0x0555a4b9.\\n    /// @param lastIndex Last parsed instruction index\\n    /// @param instructionIndex The instruction index that was unordered\\n    error UnorderedInstructions(uint256 lastIndex, uint256 instructionIndex);\\n\\n    /// @notice Error thrown when a transceiver instruction index\\n    ///         is greater than the number of registered transceivers\\n    /// @dev We index from 0 so if providedIndex == numTransceivers then we're out-of-bounds too\\n    /// @dev Selector 0x689f5016.\\n    /// @param providedIndex The index specified in the instruction\\n    /// @param numTransceivers The number of registered transceivers\\n    error InvalidInstructionIndex(uint256 providedIndex, uint256 numTransceivers);\\n\\n    /// @dev Prefix for all NativeTokenTransfer payloads\\n    ///      This is 0x99'N''T''T'\\n    bytes4 constant NTT_PREFIX = 0x994E5454;\\n\\n    /// @dev Message emitted and received by the nttManager contract.\\n    ///      The wire format is as follows:\\n    ///      - id - 32 bytes\\n    ///      - sender - 32 bytes\\n    ///      - payloadLength - 2 bytes\\n    ///      - payload - `payloadLength` bytes\\n    struct NttManagerMessage {\\n        /// @notice unique message identifier\\n        /// @dev This is incrementally assigned on EVM chains, but this is not\\n        /// guaranteed on other runtimes.\\n        bytes32 id;\\n        /// @notice original message sender address.\\n        bytes32 sender;\\n        /// @notice payload that corresponds to the type.\\n        bytes payload;\\n    }\\n\\n    function nttManagerMessageDigest(\\n        uint16 sourceChainId,\\n        NttManagerMessage memory m\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(sourceChainId, encodeNttManagerMessage(m)));\\n    }\\n\\n    function encodeNttManagerMessage(NttManagerMessage memory m)\\n        public\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        if (m.payload.length > type(uint16).max) {\\n            revert PayloadTooLong(m.payload.length);\\n        }\\n        uint16 payloadLength = uint16(m.payload.length);\\n        return abi.encodePacked(m.id, m.sender, payloadLength, m.payload);\\n    }\\n\\n    /// @notice Parse a NttManagerMessage.\\n    /// @param encoded The byte array corresponding to the encoded message\\n    /// @return nttManagerMessage The parsed NttManagerMessage struct.\\n    function parseNttManagerMessage(bytes memory encoded)\\n        public\\n        pure\\n        returns (NttManagerMessage memory nttManagerMessage)\\n    {\\n        uint256 offset = 0;\\n        (nttManagerMessage.id, offset) = encoded.asBytes32Unchecked(offset);\\n        (nttManagerMessage.sender, offset) = encoded.asBytes32Unchecked(offset);\\n        uint256 payloadLength;\\n        (payloadLength, offset) = encoded.asUint16Unchecked(offset);\\n        (nttManagerMessage.payload, offset) = encoded.sliceUnchecked(offset, payloadLength);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Native Token Transfer payload.\\n    ///      The wire format is as follows:\\n    ///      - NTT_PREFIX - 4 bytes\\n    ///      - numDecimals - 1 byte\\n    ///      - amount - 8 bytes\\n    ///      - sourceToken - 32 bytes\\n    ///      - to - 32 bytes\\n    ///      - toChain - 2 bytes\\n    struct NativeTokenTransfer {\\n        /// @notice Amount being transferred (big-endian u64 and u8 for decimals)\\n        TrimmedAmount amount;\\n        /// @notice Source chain token address.\\n        bytes32 sourceToken;\\n        /// @notice Address of the recipient.\\n        bytes32 to;\\n        /// @notice Chain ID of the recipient\\n        uint16 toChain;\\n    }\\n\\n    function encodeNativeTokenTransfer(NativeTokenTransfer memory m)\\n        public\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        // The `amount` and `decimals` fields are encoded in reverse order compared to how they are declared in the\\n        // `TrimmedAmount` type. This is consistent with the Rust NTT implementation.\\n        TrimmedAmount transferAmount = m.amount;\\n        return abi.encodePacked(\\n            NTT_PREFIX,\\n            transferAmount.getDecimals(),\\n            transferAmount.getAmount(),\\n            m.sourceToken,\\n            m.to,\\n            m.toChain\\n        );\\n    }\\n\\n    /// @dev Parse a NativeTokenTransfer.\\n    /// @param encoded The byte array corresponding to the encoded message\\n    /// @return nativeTokenTransfer The parsed NativeTokenTransfer struct.\\n    function parseNativeTokenTransfer(bytes memory encoded)\\n        public\\n        pure\\n        returns (NativeTokenTransfer memory nativeTokenTransfer)\\n    {\\n        uint256 offset = 0;\\n        bytes4 prefix;\\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\\n        if (prefix != NTT_PREFIX) {\\n            revert IncorrectPrefix(prefix);\\n        }\\n\\n        // The `amount` and `decimals` fields are parsed in reverse order compared to how they are declared in the\\n        // `TrimmedAmount` struct. This is consistent with the Rust NTT implementation.\\n        uint8 numDecimals;\\n        (numDecimals, offset) = encoded.asUint8Unchecked(offset);\\n        uint64 amount;\\n        (amount, offset) = encoded.asUint64Unchecked(offset);\\n        nativeTokenTransfer.amount = packTrimmedAmount(amount, numDecimals);\\n\\n        (nativeTokenTransfer.sourceToken, offset) = encoded.asBytes32Unchecked(offset);\\n        (nativeTokenTransfer.to, offset) = encoded.asBytes32Unchecked(offset);\\n        (nativeTokenTransfer.toChain, offset) = encoded.asUint16Unchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Message emitted by Transceiver implementations.\\n    ///      Each message includes an Transceiver-specified 4-byte prefix.\\n    ///      The wire format is as follows:\\n    ///      - prefix - 4 bytes\\n    ///      - sourceNttManagerAddress - 32 bytes\\n    ///      - recipientNttManagerAddress - 32 bytes\\n    ///      - nttManagerPayloadLength - 2 bytes\\n    ///      - nttManagerPayload - `nttManagerPayloadLength` bytes\\n    ///      - transceiverPayloadLength - 2 bytes\\n    ///      - transceiverPayload - `transceiverPayloadLength` bytes\\n    struct TransceiverMessage {\\n        /// @notice Address of the NttManager contract that emitted this message.\\n        bytes32 sourceNttManagerAddress;\\n        /// @notice Address of the NttManager contract that receives this message.\\n        bytes32 recipientNttManagerAddress;\\n        /// @notice Payload provided to the Transceiver contract by the NttManager contract.\\n        bytes nttManagerPayload;\\n        /// @notice Optional payload that the transceiver can encode and use for its own message passing purposes.\\n        bytes transceiverPayload;\\n    }\\n\\n    // @notice Encodes an Transceiver message for communication between the\\n    //         NttManager and the Transceiver.\\n    // @param m The TransceiverMessage struct containing the message details.\\n    // @return encoded The byte array corresponding to the encoded message.\\n    // @custom:throw PayloadTooLong if the length of transceiverId, nttManagerPayload,\\n    //         or transceiverPayload exceeds the allowed maximum.\\n    function encodeTransceiverMessage(\\n        bytes4 prefix,\\n        TransceiverMessage memory m\\n    ) public pure returns (bytes memory encoded) {\\n        if (m.nttManagerPayload.length > type(uint16).max) {\\n            revert PayloadTooLong(m.nttManagerPayload.length);\\n        }\\n        uint16 nttManagerPayloadLength = uint16(m.nttManagerPayload.length);\\n\\n        if (m.transceiverPayload.length > type(uint16).max) {\\n            revert PayloadTooLong(m.transceiverPayload.length);\\n        }\\n        uint16 transceiverPayloadLength = uint16(m.transceiverPayload.length);\\n\\n        return abi.encodePacked(\\n            prefix,\\n            m.sourceNttManagerAddress,\\n            m.recipientNttManagerAddress,\\n            nttManagerPayloadLength,\\n            m.nttManagerPayload,\\n            transceiverPayloadLength,\\n            m.transceiverPayload\\n        );\\n    }\\n\\n    function buildAndEncodeTransceiverMessage(\\n        bytes4 prefix,\\n        bytes32 sourceNttManagerAddress,\\n        bytes32 recipientNttManagerAddress,\\n        bytes memory nttManagerMessage,\\n        bytes memory transceiverPayload\\n    ) public pure returns (TransceiverMessage memory, bytes memory) {\\n        TransceiverMessage memory transceiverMessage = TransceiverMessage({\\n            sourceNttManagerAddress: sourceNttManagerAddress,\\n            recipientNttManagerAddress: recipientNttManagerAddress,\\n            nttManagerPayload: nttManagerMessage,\\n            transceiverPayload: transceiverPayload\\n        });\\n        bytes memory encoded = encodeTransceiverMessage(prefix, transceiverMessage);\\n        return (transceiverMessage, encoded);\\n    }\\n\\n    /// @dev Parses an encoded message and extracts information into an TransceiverMessage struct.\\n    /// @param encoded The encoded bytes containing information about the TransceiverMessage.\\n    /// @return transceiverMessage The parsed TransceiverMessage struct.\\n    /// @custom:throw IncorrectPrefix if the prefix of the encoded message does not\\n    ///         match the expected prefix.\\n    function parseTransceiverMessage(\\n        bytes4 expectedPrefix,\\n        bytes memory encoded\\n    ) internal pure returns (TransceiverMessage memory transceiverMessage) {\\n        uint256 offset = 0;\\n        bytes4 prefix;\\n\\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\\n\\n        if (prefix != expectedPrefix) {\\n            revert IncorrectPrefix(prefix);\\n        }\\n\\n        (transceiverMessage.sourceNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (transceiverMessage.recipientNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        uint16 nttManagerPayloadLength;\\n        (nttManagerPayloadLength, offset) = encoded.asUint16Unchecked(offset);\\n        (transceiverMessage.nttManagerPayload, offset) =\\n            encoded.sliceUnchecked(offset, nttManagerPayloadLength);\\n        uint16 transceiverPayloadLength;\\n        (transceiverPayloadLength, offset) = encoded.asUint16Unchecked(offset);\\n        (transceiverMessage.transceiverPayload, offset) =\\n            encoded.sliceUnchecked(offset, transceiverPayloadLength);\\n\\n        // Check if the entire byte array has been processed\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Parses the payload of an Transceiver message and returns\\n    ///      the parsed NttManagerMessage struct.\\n    /// @param expectedPrefix The prefix that should be encoded in the nttManager message.\\n    /// @param payload The payload sent across the wire.\\n    function parseTransceiverAndNttManagerMessage(\\n        bytes4 expectedPrefix,\\n        bytes memory payload\\n    ) public pure returns (TransceiverMessage memory, NttManagerMessage memory) {\\n        // parse the encoded message payload from the Transceiver\\n        TransceiverMessage memory parsedTransceiverMessage =\\n            parseTransceiverMessage(expectedPrefix, payload);\\n\\n        // parse the encoded message payload from the NttManager\\n        NttManagerMessage memory parsedNttManagerMessage =\\n            parseNttManagerMessage(parsedTransceiverMessage.nttManagerPayload);\\n\\n        return (parsedTransceiverMessage, parsedNttManagerMessage);\\n    }\\n\\n    /// @dev Variable-length transceiver-specific instruction that can be passed by the caller to the nttManager.\\n    ///      The index field refers to the index of the registeredTransceiver that this instruction should be passed to.\\n    ///      The serialization format is:\\n    ///      - index - 1 byte\\n    ///      - payloadLength - 1 byte\\n    ///      - payload - `payloadLength` bytes\\n    struct TransceiverInstruction {\\n        uint8 index;\\n        bytes payload;\\n    }\\n\\n    function encodeTransceiverInstruction(TransceiverInstruction memory instruction)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (instruction.payload.length > type(uint8).max) {\\n            revert PayloadTooLong(instruction.payload.length);\\n        }\\n        uint8 payloadLength = uint8(instruction.payload.length);\\n        return abi.encodePacked(instruction.index, payloadLength, instruction.payload);\\n    }\\n\\n    function parseTransceiverInstructionUnchecked(\\n        bytes memory encoded,\\n        uint256 offset\\n    ) public pure returns (TransceiverInstruction memory instruction, uint256 nextOffset) {\\n        (instruction.index, nextOffset) = encoded.asUint8Unchecked(offset);\\n        uint8 instructionLength;\\n        (instructionLength, nextOffset) = encoded.asUint8Unchecked(nextOffset);\\n        (instruction.payload, nextOffset) = encoded.sliceUnchecked(nextOffset, instructionLength);\\n    }\\n\\n    function parseTransceiverInstructionChecked(bytes memory encoded)\\n        public\\n        pure\\n        returns (TransceiverInstruction memory instruction)\\n    {\\n        uint256 offset = 0;\\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Encode an array of multiple variable-length transceiver-specific instructions.\\n    ///      The serialization format is:\\n    ///      - instructionsLength - 1 byte\\n    ///      - `instructionsLength` number of serialized `TransceiverInstruction` types.\\n    function encodeTransceiverInstructions(TransceiverInstruction[] memory instructions)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (instructions.length > type(uint8).max) {\\n            revert PayloadTooLong(instructions.length);\\n        }\\n        uint256 instructionsLength = instructions.length;\\n\\n        bytes memory encoded;\\n        for (uint256 i = 0; i < instructionsLength; i++) {\\n            bytes memory innerEncoded = encodeTransceiverInstruction(instructions[i]);\\n            encoded = bytes.concat(encoded, innerEncoded);\\n        }\\n        return abi.encodePacked(uint8(instructionsLength), encoded);\\n    }\\n\\n    function parseTransceiverInstructions(\\n        bytes memory encoded,\\n        uint256 numRegisteredTransceivers\\n    ) public pure returns (TransceiverInstruction[] memory) {\\n        uint256 offset = 0;\\n        uint256 instructionsLength;\\n        (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\\n\\n        // We allocate an array with the length of the number of registered transceivers\\n        // This gives us the flexibility to not have to pass instructions for transceivers that\\n        // don't need them\\n        TransceiverInstruction[] memory instructions =\\n            new TransceiverInstruction[](numRegisteredTransceivers);\\n\\n        uint256 lastIndex = 0;\\n        for (uint256 i = 0; i < instructionsLength; i++) {\\n            TransceiverInstruction memory instruction;\\n            (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\\n\\n            uint8 instructionIndex = instruction.index;\\n\\n            // The instructions passed in have to be strictly increasing in terms of transceiver index\\n            if (i != 0 && instructionIndex <= lastIndex) {\\n                revert UnorderedInstructions(lastIndex, instructionIndex);\\n            }\\n\\n            // Instruction index is out of bounds\\n            if (instructionIndex >= numRegisteredTransceivers) {\\n                revert InvalidInstructionIndex(instructionIndex, numRegisteredTransceivers);\\n            }\\n\\n            lastIndex = instructionIndex;\\n\\n            instructions[instructionIndex] = instruction;\\n        }\\n\\n        encoded.checkLength(offset);\\n\\n        return instructions;\\n    }\\n\\n    struct TransceiverInit {\\n        bytes4 transceiverIdentifier;\\n        bytes32 nttManagerAddress;\\n        uint8 nttManagerMode;\\n        bytes32 tokenAddress;\\n        uint8 tokenDecimals;\\n    }\\n\\n    function encodeTransceiverInit(TransceiverInit memory init)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            init.transceiverIdentifier,\\n            init.nttManagerAddress,\\n            init.nttManagerMode,\\n            init.tokenAddress,\\n            init.tokenDecimals\\n        );\\n    }\\n\\n    function decodeTransceiverInit(bytes memory encoded)\\n        public\\n        pure\\n        returns (TransceiverInit memory init)\\n    {\\n        uint256 offset = 0;\\n        (init.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\\n        (init.nttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (init.nttManagerMode, offset) = encoded.asUint8Unchecked(offset);\\n        (init.tokenAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (init.tokenDecimals, offset) = encoded.asUint8Unchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    struct TransceiverRegistration {\\n        bytes4 transceiverIdentifier;\\n        uint16 transceiverChainId;\\n        bytes32 transceiverAddress;\\n    }\\n\\n    function encodeTransceiverRegistration(TransceiverRegistration memory registration)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            registration.transceiverIdentifier,\\n            registration.transceiverChainId,\\n            registration.transceiverAddress\\n        );\\n    }\\n\\n    function decodeTransceiverRegistration(bytes memory encoded)\\n        public\\n        pure\\n        returns (TransceiverRegistration memory registration)\\n    {\\n        uint256 offset = 0;\\n        (registration.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\\n        (registration.transceiverChainId, offset) = encoded.asUint16Unchecked(offset);\\n        (registration.transceiverAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/libraries/BytesParsing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nlibrary BytesParsing {\\n  uint256 private constant freeMemoryPtr = 0x40;\\n  uint256 private constant wordSize = 32;\\n\\n  error OutOfBounds(uint256 offset, uint256 length);\\n  error LengthMismatch(uint256 encodedLength, uint256 expectedLength);\\n  error InvalidBoolVal(uint8 val);\\n\\n  function checkBound(uint offset, uint length) internal pure {\\n    if (offset > length)\\n      revert OutOfBounds(offset, length);\\n  }\\n\\n  function checkLength(bytes memory encoded, uint256 expected) internal pure {\\n    if (encoded.length != expected)\\n      revert LengthMismatch(encoded.length, expected);\\n  }\\n\\n  function sliceUnchecked(\\n    bytes memory encoded,\\n    uint offset,\\n    uint length\\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\\n    //bail early for degenerate case\\n    if (length == 0)\\n      return (new bytes(0), offset);\\n\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, length)\\n      ret := mload(freeMemoryPtr)\\n\\n      //Explanation on how we copy data here:\\n      //  The bytes type has the following layout in memory:\\n      //    [length: 32 bytes, data: length bytes]\\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\\n      //    will be written into the length part of our `ret` slice.\\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\\n      //    overwritting those garbage bytes.\\n      let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\\n      if iszero(shift) {\\n        shift := wordSize\\n      }\\n\\n      let dest := add(ret, shift)\\n      let end := add(dest, length)\\n      for {\\n        let src := add(add(encoded, shift), offset)\\n      } lt(dest, end) {\\n        src := add(src, wordSize)\\n        dest := add(dest, wordSize)\\n      } {\\n        mstore(dest, mload(src))\\n      }\\n\\n      mstore(ret, length)\\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\\n      //  memory alignment and so we enforce the same memory alignment here.\\n      mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\\n    }\\n  }\\n\\n  function slice(\\n    bytes memory encoded,\\n    uint offset,\\n    uint length\\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asAddressUnchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (address, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\\n    return (address(ret), nextOffset);\\n  }\\n\\n  function asAddress(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (address ret, uint nextOffset) {\\n    (ret, nextOffset) = asAddressUnchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBoolUnchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bool, uint) {\\n    (uint8 val, uint nextOffset) = asUint8Unchecked(encoded, offset);\\n    if (val & 0xfe != 0)\\n      revert InvalidBoolVal(val);\\n\\n    uint cleanedVal = uint(val);\\n    bool ret;\\n    //skip 2x iszero opcode\\n    assembly (\\\"memory-safe\\\") {\\n      ret := cleanedVal\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asBool(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bool ret, uint nextOffset) {\\n    (ret, nextOffset) = asBoolUnchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n/* -------------------------------------------------------------------------------------------------\\nRemaining library code below was auto-generated by via the following js/node code:\\n\\nfor (let bytes = 1; bytes <= 32; ++bytes) {\\n  const bits = bytes*8;\\n  console.log(\\n`function asUint${bits}Unchecked(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (uint${bits} ret, uint nextOffset) {\\n  assembly (\\\"memory-safe\\\") {\\n    nextOffset := add(offset, ${bytes})\\n    ret := mload(add(encoded, nextOffset))\\n  }\\n  return (ret, nextOffset);\\n}\\n\\nfunction asUint${bits}(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (uint${bits} ret, uint nextOffset) {\\n  (ret, nextOffset) = asUint${bits}Unchecked(encoded, offset);\\n  checkBound(nextOffset, encoded.length);\\n}\\n\\nfunction asBytes${bytes}Unchecked(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (bytes${bytes}, uint) {\\n  (uint${bits} ret, uint nextOffset) = asUint${bits}Unchecked(encoded, offset);\\n  return (bytes${bytes}(ret), nextOffset);\\n}\\n\\nfunction asBytes${bytes}(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (bytes${bytes}, uint) {\\n  (uint${bits} ret, uint nextOffset) = asUint${bits}(encoded, offset);\\n  return (bytes${bytes}(ret), nextOffset);\\n}\\n`\\n  );\\n}\\n------------------------------------------------------------------------------------------------- */\\n\\n  function asUint8Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint8 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 1)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint8(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint8 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint8Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes1Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes1, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8Unchecked(encoded, offset);\\n    return (bytes1(ret), nextOffset);\\n  }\\n\\n  function asBytes1(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes1, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8(encoded, offset);\\n    return (bytes1(ret), nextOffset);\\n  }\\n\\n  function asUint16Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint16 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 2)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint16(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint16 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint16Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes2Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes2, uint) {\\n    (uint16 ret, uint nextOffset) = asUint16Unchecked(encoded, offset);\\n    return (bytes2(ret), nextOffset);\\n  }\\n\\n  function asBytes2(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes2, uint) {\\n    (uint16 ret, uint nextOffset) = asUint16(encoded, offset);\\n    return (bytes2(ret), nextOffset);\\n  }\\n\\n  function asUint24Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint24 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 3)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint24(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint24 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint24Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes3Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes3, uint) {\\n    (uint24 ret, uint nextOffset) = asUint24Unchecked(encoded, offset);\\n    return (bytes3(ret), nextOffset);\\n  }\\n\\n  function asBytes3(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes3, uint) {\\n    (uint24 ret, uint nextOffset) = asUint24(encoded, offset);\\n    return (bytes3(ret), nextOffset);\\n  }\\n\\n  function asUint32Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint32 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 4)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint32(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint32 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint32Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes4Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes4, uint) {\\n    (uint32 ret, uint nextOffset) = asUint32Unchecked(encoded, offset);\\n    return (bytes4(ret), nextOffset);\\n  }\\n\\n  function asBytes4(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes4, uint) {\\n    (uint32 ret, uint nextOffset) = asUint32(encoded, offset);\\n    return (bytes4(ret), nextOffset);\\n  }\\n\\n  function asUint40Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint40 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 5)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint40(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint40 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint40Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes5Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes5, uint) {\\n    (uint40 ret, uint nextOffset) = asUint40Unchecked(encoded, offset);\\n    return (bytes5(ret), nextOffset);\\n  }\\n\\n  function asBytes5(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes5, uint) {\\n    (uint40 ret, uint nextOffset) = asUint40(encoded, offset);\\n    return (bytes5(ret), nextOffset);\\n  }\\n\\n  function asUint48Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint48 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 6)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint48(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint48 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint48Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes6Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes6, uint) {\\n    (uint48 ret, uint nextOffset) = asUint48Unchecked(encoded, offset);\\n    return (bytes6(ret), nextOffset);\\n  }\\n\\n  function asBytes6(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes6, uint) {\\n    (uint48 ret, uint nextOffset) = asUint48(encoded, offset);\\n    return (bytes6(ret), nextOffset);\\n  }\\n\\n  function asUint56Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint56 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 7)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint56(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint56 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint56Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes7Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes7, uint) {\\n    (uint56 ret, uint nextOffset) = asUint56Unchecked(encoded, offset);\\n    return (bytes7(ret), nextOffset);\\n  }\\n\\n  function asBytes7(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes7, uint) {\\n    (uint56 ret, uint nextOffset) = asUint56(encoded, offset);\\n    return (bytes7(ret), nextOffset);\\n  }\\n\\n  function asUint64Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint64 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 8)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint64(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint64 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint64Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes8Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes8, uint) {\\n    (uint64 ret, uint nextOffset) = asUint64Unchecked(encoded, offset);\\n    return (bytes8(ret), nextOffset);\\n  }\\n\\n  function asBytes8(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes8, uint) {\\n    (uint64 ret, uint nextOffset) = asUint64(encoded, offset);\\n    return (bytes8(ret), nextOffset);\\n  }\\n\\n  function asUint72Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint72 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 9)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint72(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint72 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint72Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes9Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes9, uint) {\\n    (uint72 ret, uint nextOffset) = asUint72Unchecked(encoded, offset);\\n    return (bytes9(ret), nextOffset);\\n  }\\n\\n  function asBytes9(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes9, uint) {\\n    (uint72 ret, uint nextOffset) = asUint72(encoded, offset);\\n    return (bytes9(ret), nextOffset);\\n  }\\n\\n  function asUint80Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint80 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 10)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint80(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint80 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint80Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes10Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes10, uint) {\\n    (uint80 ret, uint nextOffset) = asUint80Unchecked(encoded, offset);\\n    return (bytes10(ret), nextOffset);\\n  }\\n\\n  function asBytes10(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes10, uint) {\\n    (uint80 ret, uint nextOffset) = asUint80(encoded, offset);\\n    return (bytes10(ret), nextOffset);\\n  }\\n\\n  function asUint88Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint88 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 11)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint88(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint88 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint88Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes11Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes11, uint) {\\n    (uint88 ret, uint nextOffset) = asUint88Unchecked(encoded, offset);\\n    return (bytes11(ret), nextOffset);\\n  }\\n\\n  function asBytes11(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes11, uint) {\\n    (uint88 ret, uint nextOffset) = asUint88(encoded, offset);\\n    return (bytes11(ret), nextOffset);\\n  }\\n\\n  function asUint96Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint96 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 12)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint96(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint96 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint96Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes12Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes12, uint) {\\n    (uint96 ret, uint nextOffset) = asUint96Unchecked(encoded, offset);\\n    return (bytes12(ret), nextOffset);\\n  }\\n\\n  function asBytes12(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes12, uint) {\\n    (uint96 ret, uint nextOffset) = asUint96(encoded, offset);\\n    return (bytes12(ret), nextOffset);\\n  }\\n\\n  function asUint104Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint104 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 13)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint104(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint104 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint104Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes13Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes13, uint) {\\n    (uint104 ret, uint nextOffset) = asUint104Unchecked(encoded, offset);\\n    return (bytes13(ret), nextOffset);\\n  }\\n\\n  function asBytes13(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes13, uint) {\\n    (uint104 ret, uint nextOffset) = asUint104(encoded, offset);\\n    return (bytes13(ret), nextOffset);\\n  }\\n\\n  function asUint112Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint112 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 14)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint112(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint112 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint112Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes14Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes14, uint) {\\n    (uint112 ret, uint nextOffset) = asUint112Unchecked(encoded, offset);\\n    return (bytes14(ret), nextOffset);\\n  }\\n\\n  function asBytes14(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes14, uint) {\\n    (uint112 ret, uint nextOffset) = asUint112(encoded, offset);\\n    return (bytes14(ret), nextOffset);\\n  }\\n\\n  function asUint120Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint120 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 15)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint120(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint120 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint120Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes15Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes15, uint) {\\n    (uint120 ret, uint nextOffset) = asUint120Unchecked(encoded, offset);\\n    return (bytes15(ret), nextOffset);\\n  }\\n\\n  function asBytes15(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes15, uint) {\\n    (uint120 ret, uint nextOffset) = asUint120(encoded, offset);\\n    return (bytes15(ret), nextOffset);\\n  }\\n\\n  function asUint128Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint128 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 16)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint128(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint128 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint128Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes16Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes16, uint) {\\n    (uint128 ret, uint nextOffset) = asUint128Unchecked(encoded, offset);\\n    return (bytes16(ret), nextOffset);\\n  }\\n\\n  function asBytes16(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes16, uint) {\\n    (uint128 ret, uint nextOffset) = asUint128(encoded, offset);\\n    return (bytes16(ret), nextOffset);\\n  }\\n\\n  function asUint136Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint136 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 17)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint136(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint136 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint136Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes17Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes17, uint) {\\n    (uint136 ret, uint nextOffset) = asUint136Unchecked(encoded, offset);\\n    return (bytes17(ret), nextOffset);\\n  }\\n\\n  function asBytes17(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes17, uint) {\\n    (uint136 ret, uint nextOffset) = asUint136(encoded, offset);\\n    return (bytes17(ret), nextOffset);\\n  }\\n\\n  function asUint144Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint144 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 18)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint144(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint144 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint144Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes18Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes18, uint) {\\n    (uint144 ret, uint nextOffset) = asUint144Unchecked(encoded, offset);\\n    return (bytes18(ret), nextOffset);\\n  }\\n\\n  function asBytes18(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes18, uint) {\\n    (uint144 ret, uint nextOffset) = asUint144(encoded, offset);\\n    return (bytes18(ret), nextOffset);\\n  }\\n\\n  function asUint152Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint152 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 19)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint152(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint152 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint152Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes19Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes19, uint) {\\n    (uint152 ret, uint nextOffset) = asUint152Unchecked(encoded, offset);\\n    return (bytes19(ret), nextOffset);\\n  }\\n\\n  function asBytes19(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes19, uint) {\\n    (uint152 ret, uint nextOffset) = asUint152(encoded, offset);\\n    return (bytes19(ret), nextOffset);\\n  }\\n\\n  function asUint160Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint160 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 20)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint160(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint160 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint160Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes20Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes20, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\\n    return (bytes20(ret), nextOffset);\\n  }\\n\\n  function asBytes20(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes20, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\\n    return (bytes20(ret), nextOffset);\\n  }\\n\\n  function asUint168Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint168 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 21)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint168(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint168 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint168Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes21Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes21, uint) {\\n    (uint168 ret, uint nextOffset) = asUint168Unchecked(encoded, offset);\\n    return (bytes21(ret), nextOffset);\\n  }\\n\\n  function asBytes21(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes21, uint) {\\n    (uint168 ret, uint nextOffset) = asUint168(encoded, offset);\\n    return (bytes21(ret), nextOffset);\\n  }\\n\\n  function asUint176Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint176 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 22)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint176(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint176 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint176Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes22Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes22, uint) {\\n    (uint176 ret, uint nextOffset) = asUint176Unchecked(encoded, offset);\\n    return (bytes22(ret), nextOffset);\\n  }\\n\\n  function asBytes22(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes22, uint) {\\n    (uint176 ret, uint nextOffset) = asUint176(encoded, offset);\\n    return (bytes22(ret), nextOffset);\\n  }\\n\\n  function asUint184Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint184 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 23)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint184(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint184 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint184Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes23Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes23, uint) {\\n    (uint184 ret, uint nextOffset) = asUint184Unchecked(encoded, offset);\\n    return (bytes23(ret), nextOffset);\\n  }\\n\\n  function asBytes23(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes23, uint) {\\n    (uint184 ret, uint nextOffset) = asUint184(encoded, offset);\\n    return (bytes23(ret), nextOffset);\\n  }\\n\\n  function asUint192Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint192 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 24)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint192(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint192 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint192Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes24Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes24, uint) {\\n    (uint192 ret, uint nextOffset) = asUint192Unchecked(encoded, offset);\\n    return (bytes24(ret), nextOffset);\\n  }\\n\\n  function asBytes24(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes24, uint) {\\n    (uint192 ret, uint nextOffset) = asUint192(encoded, offset);\\n    return (bytes24(ret), nextOffset);\\n  }\\n\\n  function asUint200Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint200 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 25)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint200(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint200 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint200Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes25Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes25, uint) {\\n    (uint200 ret, uint nextOffset) = asUint200Unchecked(encoded, offset);\\n    return (bytes25(ret), nextOffset);\\n  }\\n\\n  function asBytes25(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes25, uint) {\\n    (uint200 ret, uint nextOffset) = asUint200(encoded, offset);\\n    return (bytes25(ret), nextOffset);\\n  }\\n\\n  function asUint208Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint208 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 26)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint208(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint208 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint208Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes26Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes26, uint) {\\n    (uint208 ret, uint nextOffset) = asUint208Unchecked(encoded, offset);\\n    return (bytes26(ret), nextOffset);\\n  }\\n\\n  function asBytes26(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes26, uint) {\\n    (uint208 ret, uint nextOffset) = asUint208(encoded, offset);\\n    return (bytes26(ret), nextOffset);\\n  }\\n\\n  function asUint216Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint216 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 27)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint216(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint216 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint216Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes27Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes27, uint) {\\n    (uint216 ret, uint nextOffset) = asUint216Unchecked(encoded, offset);\\n    return (bytes27(ret), nextOffset);\\n  }\\n\\n  function asBytes27(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes27, uint) {\\n    (uint216 ret, uint nextOffset) = asUint216(encoded, offset);\\n    return (bytes27(ret), nextOffset);\\n  }\\n\\n  function asUint224Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint224 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 28)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint224(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint224 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint224Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes28Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes28, uint) {\\n    (uint224 ret, uint nextOffset) = asUint224Unchecked(encoded, offset);\\n    return (bytes28(ret), nextOffset);\\n  }\\n\\n  function asBytes28(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes28, uint) {\\n    (uint224 ret, uint nextOffset) = asUint224(encoded, offset);\\n    return (bytes28(ret), nextOffset);\\n  }\\n\\n  function asUint232Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint232 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 29)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint232(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint232 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint232Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes29Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes29, uint) {\\n    (uint232 ret, uint nextOffset) = asUint232Unchecked(encoded, offset);\\n    return (bytes29(ret), nextOffset);\\n  }\\n\\n  function asBytes29(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes29, uint) {\\n    (uint232 ret, uint nextOffset) = asUint232(encoded, offset);\\n    return (bytes29(ret), nextOffset);\\n  }\\n\\n  function asUint240Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint240 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 30)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint240(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint240 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint240Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes30Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes30, uint) {\\n    (uint240 ret, uint nextOffset) = asUint240Unchecked(encoded, offset);\\n    return (bytes30(ret), nextOffset);\\n  }\\n\\n  function asBytes30(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes30, uint) {\\n    (uint240 ret, uint nextOffset) = asUint240(encoded, offset);\\n    return (bytes30(ret), nextOffset);\\n  }\\n\\n  function asUint248Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint248 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 31)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint248(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint248 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint248Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes31Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes31, uint) {\\n    (uint248 ret, uint nextOffset) = asUint248Unchecked(encoded, offset);\\n    return (bytes31(ret), nextOffset);\\n  }\\n\\n  function asBytes31(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes31, uint) {\\n    (uint248 ret, uint nextOffset) = asUint248(encoded, offset);\\n    return (bytes31(ret), nextOffset);\\n  }\\n\\n  function asUint256Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint256 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 32)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint256(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint256 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint256Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes32Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes32, uint) {\\n    (uint256 ret, uint nextOffset) = asUint256Unchecked(encoded, offset);\\n    return (bytes32(ret), nextOffset);\\n  }\\n\\n  function asBytes32(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes32, uint) {\\n    (uint256 ret, uint nextOffset) = asUint256(encoded, offset);\\n    return (bytes32(ret), nextOffset);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/libraries/TrimmedAmount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\n/// @dev TrimmedAmount is a bit-packed representation of a token amount and its decimals.\\n/// @dev 64 bits: [0 - 64] amount\\n/// @dev 8 bits: [64 - 72] decimals\\ntype TrimmedAmount is uint72;\\n\\nusing {gt as >, lt as <, sub as -, add as +, eq as ==, min, unwrap} for TrimmedAmount global;\\n\\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\\n    return a < b ? a : b;\\n}\\n\\n/// @notice Error when the decimals of two TrimmedAmounts are not equal\\n/// @dev Selector. b9cdb6c2\\n/// @param decimals the decimals of the first TrimmedAmount\\n/// @param decimalsOther the decimals of the second TrimmedAmount\\nerror NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\\n\\nuint8 constant TRIMMED_DECIMALS = 8;\\n\\nfunction unwrap(TrimmedAmount a) pure returns (uint72) {\\n    return TrimmedAmount.unwrap(a);\\n}\\n\\nfunction packTrimmedAmount(uint64 amt, uint8 decimals) pure returns (TrimmedAmount) {\\n    // cast to u72 first to prevent overflow\\n    uint72 amount = uint72(amt);\\n    uint72 dec = uint72(decimals);\\n\\n    // shift the amount to the left 8 bits\\n    amount <<= 8;\\n\\n    return TrimmedAmount.wrap(amount | dec);\\n}\\n\\nfunction eq(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\\n    return TrimmedAmountLib.getAmount(a) == TrimmedAmountLib.getAmount(b)\\n        && TrimmedAmountLib.getDecimals(a) == TrimmedAmountLib.getDecimals(b);\\n}\\n\\nfunction checkDecimals(TrimmedAmount a, TrimmedAmount b) pure {\\n    uint8 aDecimals = TrimmedAmountLib.getDecimals(a);\\n    uint8 bDecimals = TrimmedAmountLib.getDecimals(b);\\n    if (aDecimals != bDecimals) {\\n        revert NumberOfDecimalsNotEqual(aDecimals, bDecimals);\\n    }\\n}\\n\\nfunction gt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\\n    checkDecimals(a, b);\\n\\n    return TrimmedAmountLib.getAmount(a) > TrimmedAmountLib.getAmount(b);\\n}\\n\\nfunction lt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\\n    checkDecimals(a, b);\\n\\n    return TrimmedAmountLib.getAmount(a) < TrimmedAmountLib.getAmount(b);\\n}\\n\\nfunction sub(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\\n    checkDecimals(a, b);\\n\\n    return packTrimmedAmount(\\n        TrimmedAmountLib.getAmount(a) - TrimmedAmountLib.getAmount(b),\\n        TrimmedAmountLib.getDecimals(a)\\n    );\\n}\\n\\nfunction add(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\\n    checkDecimals(a, b);\\n\\n    return packTrimmedAmount(\\n        TrimmedAmountLib.getAmount(a) + TrimmedAmountLib.getAmount(b),\\n        TrimmedAmountLib.getDecimals(b)\\n    );\\n}\\n\\nfunction min(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\\n    checkDecimals(a, b);\\n\\n    return TrimmedAmountLib.getAmount(a) < TrimmedAmountLib.getAmount(b) ? a : b;\\n}\\n\\nlibrary TrimmedAmountLib {\\n    /// @notice Error when the amount to be trimmed is greater than u64MAX.\\n    /// @dev Selector 0x08083b2a.\\n    /// @param amount The amount to be trimmed.\\n    error AmountTooLarge(uint256 amount);\\n\\n    function getAmount(TrimmedAmount a) internal pure returns (uint64) {\\n        // Extract the raw integer value from TrimmedAmount\\n        uint72 rawValue = TrimmedAmount.unwrap(a);\\n\\n        // Right shift to keep only the higher 64 bits\\n        uint64 result = uint64(rawValue >> 8);\\n        return result;\\n    }\\n\\n    function getDecimals(TrimmedAmount a) internal pure returns (uint8) {\\n        return uint8(TrimmedAmount.unwrap(a) & 0xFF);\\n    }\\n\\n    function isNull(TrimmedAmount a) internal pure returns (bool) {\\n        return (getAmount(a) == 0 && getDecimals(a) == 0);\\n    }\\n\\n    function saturatingAdd(\\n        TrimmedAmount a,\\n        TrimmedAmount b\\n    ) internal pure returns (TrimmedAmount) {\\n        checkDecimals(a, b);\\n\\n        uint256 saturatedSum;\\n        uint64 aAmount = getAmount(a);\\n        uint64 bAmount = getAmount(b);\\n        unchecked {\\n            saturatedSum = uint256(aAmount) + uint256(bAmount);\\n            saturatedSum = saturatedSum > type(uint64).max ? type(uint64).max : saturatedSum;\\n        }\\n\\n        return packTrimmedAmount(SafeCast.toUint64(saturatedSum), getDecimals(a));\\n    }\\n\\n    /// @dev scale the amount from original decimals to target decimals (base 10)\\n    function scale(\\n        uint256 amount,\\n        uint8 fromDecimals,\\n        uint8 toDecimals\\n    ) internal pure returns (uint256) {\\n        if (fromDecimals == toDecimals) {\\n            return amount;\\n        }\\n\\n        if (fromDecimals > toDecimals) {\\n            return amount / (10 ** (fromDecimals - toDecimals));\\n        } else {\\n            return amount * (10 ** (toDecimals - fromDecimals));\\n        }\\n    }\\n\\n    function shift(TrimmedAmount amount, uint8 toDecimals) internal pure returns (TrimmedAmount) {\\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\\n        return packTrimmedAmount(\\n            SafeCast.toUint64(scale(getAmount(amount), getDecimals(amount), actualToDecimals)),\\n            actualToDecimals\\n        );\\n    }\\n\\n    function max(uint8 decimals) internal pure returns (TrimmedAmount) {\\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\\n        return packTrimmedAmount(type(uint64).max, actualDecimals);\\n    }\\n\\n    /// @dev trim the amount to target decimals.\\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\\n    ///      destroyed on either side of the transfer.\\n    /// @param amt the amount to be trimmed\\n    /// @param fromDecimals the original decimals of the amount\\n    /// @param toDecimals the target decimals of the amount\\n    /// @return TrimmedAmount uint72 value type bit-packed with decimals\\n    function trim(\\n        uint256 amt,\\n        uint8 fromDecimals,\\n        uint8 toDecimals\\n    ) internal pure returns (TrimmedAmount) {\\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\\n\\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\\n        // trimming, as Solana only supports uint64 for token amts)\\n        return packTrimmedAmount(SafeCast.toUint64(amountScaled), actualToDecimals);\\n    }\\n\\n    function untrim(TrimmedAmount amt, uint8 toDecimals) internal pure returns (uint256) {\\n        uint256 deNorm = uint256(getAmount(amt));\\n        uint8 fromDecimals = getDecimals(amt);\\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\\n\\n        return amountScaled;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"wormhole-solidity-sdk/=lib/wormhole-solidity-sdk/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"prefix\",\"type\":\"bytes4\"}],\"name\":\"IncorrectPrefix\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTransceivers\",\"type\":\"uint256\"}],\"name\":\"InvalidInstructionIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"encodedLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedLength\",\"type\":\"uint256\"}],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"PayloadTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"instructionIndex\",\"type\":\"uint256\"}],\"name\":\"UnorderedInstructions\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"prefix\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"name\":\"buildAndEncodeTransceiverMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"decodeTransceiverInit\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"nttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"nttManagerMode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"tokenAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInit\",\"name\":\"init\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"decodeTransceiverRegistration\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"transceiverChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"transceiverAddress\",\"type\":\"bytes32\"}],\"internalType\":\"struct TransceiverStructs.TransceiverRegistration\",\"name\":\"registration\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"TrimmedAmount\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"bytes32\",\"name\":\"sourceToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"to\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"}],\"internalType\":\"struct TransceiverStructs.NativeTokenTransfer\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"encodeNativeTokenTransfer\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"encodeNttManagerMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"nttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"nttManagerMode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"tokenAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInit\",\"name\":\"init\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverInit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverInstruction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction[]\",\"name\":\"instructions\",\"type\":\"tuple[]\"}],\"name\":\"encodeTransceiverInstructions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"prefix\",\"type\":\"bytes4\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"transceiverChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"transceiverAddress\",\"type\":\"bytes32\"}],\"internalType\":\"struct TransceiverStructs.TransceiverRegistration\",\"name\":\"registration\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverRegistration\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"sourceChainId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"nttManagerMessageDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseNativeTokenTransfer\",\"outputs\":[{\"components\":[{\"internalType\":\"TrimmedAmount\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"bytes32\",\"name\":\"sourceToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"to\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"}],\"internalType\":\"struct TransceiverStructs.NativeTokenTransfer\",\"name\":\"nativeTokenTransfer\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseNttManagerMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"nttManagerMessage\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"expectedPrefix\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"parseTransceiverAndNttManagerMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseTransceiverInstructionChecked\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"parseTransceiverInstructionUnchecked\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nextOffset\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"numRegisteredTransceivers\",\"type\":\"uint256\"}],\"name\":\"parseTransceiverInstructions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TransceiverStructs", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}