{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/ParticleExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {Ownable2StepUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport {Multicall} from \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\nimport {WETH} from \\\"@solmate/tokens/WETH.sol\\\";\\n\\nimport {IParticleExchange} from \\\"../interfaces/IParticleExchange.sol\\\";\\nimport {ReentrancyGuard} from \\\"../libraries/security/ReentrancyGuard.sol\\\";\\nimport {MathUtils} from \\\"../libraries/math/MathUtils.sol\\\";\\nimport {Lien} from \\\"../libraries/types/Structs.sol\\\";\\nimport {Errors} from \\\"../libraries/types/Errors.sol\\\";\\n\\ncontract ParticleExchange is IParticleExchange, Ownable2StepUpgradeable, UUPSUpgradeable, ReentrancyGuard, Multicall {\\n    using Address for address payable;\\n\\n    uint256 private constant _MAX_RATE = 100_000; // 1000% APR\\n    uint256 private constant _MAX_PRICE = 1_000 ether;\\n    uint256 private constant _MAX_TREASURY_RATE = 1_000; // 10%\\n    uint256 private constant _AUCTION_DURATION = 36 hours;\\n    uint256 private constant _MIN_AUCTION_DURATION = 1 hours;\\n\\n    WETH private immutable weth;\\n\\n    uint256 private _nextLienId;\\n    uint256 private _treasuryRate;\\n    uint256 private _treasury;\\n    mapping(uint256 lienId => bytes32 lienHash) public liens;\\n    mapping(address account => uint256 balance) public accountBalance;\\n    mapping(address marketplace => bool registered) public registeredMarketplaces;\\n\\n    // required by openzeppelin UUPS module\\n    // solhint-disable-next-line no-empty-blocks\\n    function _authorizeUpgrade(address) internal override onlyOwner {}\\n\\n    constructor(address wethAddress) {\\n        weth = WETH(payable(wethAddress));\\n        _disableInitializers();\\n    }\\n\\n    function initialize() external initializer {\\n        __UUPSUpgradeable_init();\\n        __Ownable_init();\\n    }\\n\\n    /*==============================================================\\n                               Supply Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function supplyNft(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 rate\\n    ) external override nonReentrant returns (uint256 lienId) {\\n        // lienId = _supplyNft(msg.sender, collection, tokenId, price, rate);\\n        // // transfer NFT into contract\\n        // /// @dev collection.setApprovalForAll should have been called by this point\\n        // /// @dev receiver is this contract, no need to safeTransferFrom\\n        // IERC721(collection).transferFrom(msg.sender, address(this), tokenId);\\n        // return lienId;\\n    }\\n\\n    function _supplyNft(\\n        address lender,\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 rate\\n    ) internal returns (uint256 lienId) {\\n        if (price > _MAX_PRICE || rate > _MAX_RATE) {\\n            revert Errors.InvalidParameters();\\n        }\\n\\n        // create a new lien\\n        Lien memory lien = Lien({\\n            lender: lender,\\n            borrower: address(0),\\n            collection: collection,\\n            tokenId: tokenId,\\n            price: price,\\n            rate: rate,\\n            loanStartTime: 0,\\n            auctionStartTime: 0\\n        });\\n\\n        /// @dev Safety: lienId unlikely to overflow by linear increment\\n        unchecked {\\n            liens[lienId = _nextLienId++] = keccak256(abi.encode(lien));\\n        }\\n\\n        emit SupplyNFT(lienId, lender, collection, tokenId, price, rate);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function updateLoan(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 price,\\n        uint256 rate\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.lender) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.loanStartTime != 0) {\\n        //     revert Errors.LoanStarted();\\n        // }\\n        // if (price > _MAX_PRICE || rate > _MAX_RATE) {\\n        //     revert Errors.InvalidParameters();\\n        // }\\n        // liens[lienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: lien.lender,\\n        //             borrower: address(0),\\n        //             collection: lien.collection,\\n        //             tokenId: lien.tokenId,\\n        //             price: price,\\n        //             rate: rate,\\n        //             loanStartTime: 0,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // emit UpdateLoan(lienId, price, rate);\\n    }\\n\\n    /*==============================================================\\n                              Withdraw Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function withdrawNft(Lien calldata lien, uint256 lienId) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.lender) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.loanStartTime != 0) {\\n        //     /// @dev the same tokenId can be used for other lender's active loan, can't withdraw others\\n        //     revert Errors.LoanStarted();\\n        // }\\n        // // delete lien\\n        // delete liens[lienId];\\n        // // transfer NFT back to lender\\n        // /// @dev can withdraw at this point means the NFT is currently in contract without active loan\\n        // /// @dev the interest (if any) is already accrued to lender at NFT acquiring time\\n        // /// @dev use transferFrom in case the receiver does not implement onERC721Received\\n        // IERC721(lien.collection).transferFrom(address(this), msg.sender, lien.tokenId);\\n        // emit WithdrawNFT(lienId);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function withdrawEth(Lien calldata lien, uint256 lienId) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.lender) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.loanStartTime == 0) {\\n        //     revert Errors.InactiveLoan();\\n        // }\\n        // // verify that auction is concluded (i.e., liquidation condition has met)\\n        // if (lien.auctionStartTime == 0 || block.timestamp <= lien.auctionStartTime + _AUCTION_DURATION) {\\n        //     revert Errors.LiquidationHasNotReached();\\n        // }\\n        // // delete lien\\n        // delete liens[lienId];\\n        // // transfer ETH to lender, i.e., seize ETH collateral\\n        // payable(lien.lender).sendValue(lien.price);\\n        // emit WithdrawETH(lienId);\\n    }\\n\\n    /*==============================================================\\n                            Market Sell Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function sellNftToMarketPull(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 amount,\\n        address marketplace,\\n        address puller,\\n        bytes calldata tradeData\\n    ) external payable override validateLien(lien, lienId) nonReentrant {\\n        // _sellNftToMarketCheck(lien, amount, msg.sender, msg.value);\\n        // _sellNftToMarketLienUpdate(lien, lienId, amount, msg.sender);\\n        // _execSellNftToMarketPull(lien, lien.tokenId, amount, marketplace, puller, tradeData);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function sellNftToMarketPush(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 amount,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) external payable override validateLien(lien, lienId) nonReentrant {\\n        // _sellNftToMarketCheck(lien, amount, msg.sender, msg.value);\\n        // _sellNftToMarketLienUpdate(lien, lienId, amount, msg.sender);\\n        // _execSellNftToMarketPush(lien, lien.tokenId, amount, marketplace, tradeData);\\n    }\\n\\n    /**\\n     * @dev Common pre market sell checks, for both pull and push based flow\\n     */\\n    function _sellNftToMarketCheck(Lien calldata lien, uint256 amount, address msgSender, uint256 msgValue) internal {\\n        if (lien.loanStartTime != 0) {\\n            revert Errors.LoanStarted();\\n        }\\n        if (lien.lender == address(0)) {\\n            revert Errors.BidNotTaken();\\n        }\\n        /// @dev: underlying account balancing ensures balance > lien.price - (amount + msg.value) (i.e., no overspend)\\n        _balanceAccount(msgSender, lien.price, amount + msgValue);\\n    }\\n\\n    /**\\n     * @dev Common operations prior to market sell execution, used for both market sell and bid acceptance flow\\n     */\\n    function _sellNftToMarketBeforeExec(address marketplace) internal view returns (uint256) {\\n        if (!registeredMarketplaces[marketplace]) {\\n            revert Errors.UnregisteredMarketplace();\\n        }\\n        // ETH + WETH balance before NFT sell execution\\n        return address(this).balance + weth.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Pull-based sell nft to market internal execution, used for both market sell and bid acceptance flow\\n     */\\n    function _execSellNftToMarketPull(\\n        Lien memory lien,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address marketplace,\\n        address puller,\\n        bytes memory tradeData\\n    ) internal {\\n        uint256 balanceBefore = _sellNftToMarketBeforeExec(marketplace);\\n\\n        /// @dev only approve for one tokenId, preventing bulk execute attack in raw trade\\n        /// @dev puller (e.g. Seaport Conduit) may be different from marketplace (e.g. Seaport Proxy Router)\\n        IERC721(lien.collection).approve(puller, tokenId);\\n\\n        // execute raw order on registered marketplace\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = marketplace.call(tradeData);\\n        if (!success) {\\n            revert Errors.MartketplaceFailedToTrade();\\n        }\\n\\n        _sellNftToMarketAfterExec(lien, tokenId, amount, balanceBefore);\\n    }\\n\\n    /**\\n     * @dev Push-based sell nft to market internal execution, used for both market sell and bid acceptance flow\\n     */\\n    function _execSellNftToMarketPush(\\n        Lien memory lien,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address marketplace,\\n        bytes memory tradeData\\n    ) internal {\\n        uint256 balanceBefore = _sellNftToMarketBeforeExec(marketplace);\\n\\n        /// @dev directly send NFT to a marketplace router (e.g. Reservoir); based on the data,\\n        /// the router will match order and transfer back the correct amount of fund\\n        IERC721(lien.collection).safeTransferFrom(address(this), marketplace, tokenId, tradeData);\\n\\n        _sellNftToMarketAfterExec(lien, tokenId, amount, balanceBefore);\\n    }\\n\\n    /**\\n     * @dev Common operations after market sell execution, used for both market sell and bid acceptance flow\\n     */\\n    function _sellNftToMarketAfterExec(\\n        Lien memory lien,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 balanceBefore\\n    ) internal {\\n        // transform all WETH (from this trade or otherwise collected elsewhere) to ETH\\n        uint256 wethAfter = weth.balanceOf(address(this));\\n        if (wethAfter > 0) {\\n            weth.withdraw(wethAfter);\\n        }\\n\\n        // verify that the NFT in lien is sold and the balance increase is correct\\n        if (\\n            IERC721(lien.collection).ownerOf(tokenId) == address(this) ||\\n            address(this).balance - balanceBefore != amount\\n        ) {\\n            revert Errors.InvalidNFTSell();\\n        }\\n    }\\n\\n    /**\\n     * @dev Common post market sell checks, for both pull and push based flow\\n     */\\n    function _sellNftToMarketLienUpdate(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 amount,\\n        address msgSender\\n    ) internal {\\n        // update lien\\n        liens[lienId] = keccak256(\\n            abi.encode(\\n                Lien({\\n                    lender: lien.lender,\\n                    borrower: msgSender,\\n                    collection: lien.collection,\\n                    tokenId: lien.tokenId,\\n                    price: lien.price,\\n                    rate: lien.rate,\\n                    loanStartTime: block.timestamp,\\n                    auctionStartTime: 0\\n                })\\n            )\\n        );\\n\\n        emit SellMarketNFT(lienId, msgSender, amount, block.timestamp);\\n    }\\n\\n    /*==============================================================\\n                            Market Buy Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function buyNftFromMarket(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address spender,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.borrower) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.loanStartTime == 0) {\\n        //     revert Errors.InactiveLoan();\\n        // }\\n        // uint256 accruedInterest = MathUtils.calculateCurrentInterest(lien.price, lien.rate, lien.loanStartTime);\\n        // // since: lien.price = sold amount + margin\\n        // // and:   payback    = sold amount + margin - bought amount - interest\\n        // // hence: payback    = lien.price - bought amount - interest\\n        // /// @dev cannot overspend, i.e., will revert if payback to borrower < 0. Payback < 0\\n        // /// means the borrower loses all the margin, and still owes some interest. Notice that\\n        // /// this function is not payable because rational borrower won't deposit even more cost\\n        // /// to exit an already liquidated position.\\n        // uint256 payback = lien.price - amount - accruedInterest;\\n        // // accrue interest to lender\\n        // _accrueInterest(lien.lender, accruedInterest);\\n        // // payback PnL to borrower\\n        // if (payback > 0) {\\n        //     accountBalance[lien.borrower] += payback;\\n        // }\\n        // // update lien (by default, the lien is open to accept new loan)\\n        // liens[lienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: lien.lender,\\n        //             borrower: address(0),\\n        //             collection: lien.collection,\\n        //             tokenId: tokenId,\\n        //             price: lien.price,\\n        //             rate: lien.rate,\\n        //             loanStartTime: 0,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // // route trade execution to marketplace\\n        // _execBuyNftFromMarket(lien.collection, tokenId, amount, spender, marketplace, tradeData);\\n        // emit BuyMarketNFT(lienId, tokenId, amount);\\n    }\\n\\n    function _execBuyNftFromMarket(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address spender,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) internal {\\n        if (!registeredMarketplaces[marketplace]) {\\n            revert Errors.UnregisteredMarketplace();\\n        }\\n\\n        if (IERC721(collection).ownerOf(tokenId) == address(this)) {\\n            revert Errors.InvalidNFTBuy();\\n        }\\n\\n        uint256 ethBalanceBefore = address(this).balance;\\n        uint256 wethBalanceBefore = weth.balanceOf(address(this));\\n\\n        // execute raw order on registered marketplace\\n        bool success;\\n        if (spender == address(0)) {\\n            // use ETH\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success, ) = marketplace.call{value: amount}(tradeData);\\n        } else {\\n            // use WETH\\n            weth.deposit{value: amount}();\\n            weth.approve(spender, amount);\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success, ) = marketplace.call(tradeData);\\n        }\\n\\n        if (!success) {\\n            revert Errors.MartketplaceFailedToTrade();\\n        }\\n\\n        // conert back any unspent WETH to ETH\\n        uint256 wethBalance = weth.balanceOf(address(this));\\n        if (wethBalance > 0) {\\n            weth.withdraw(wethBalance);\\n        }\\n\\n        // verify that the declared NFT is acquired and the balance decrease is correct\\n        if (\\n            IERC721(collection).ownerOf(tokenId) != address(this) ||\\n            ethBalanceBefore + wethBalanceBefore - address(this).balance != amount\\n        ) {\\n            revert Errors.InvalidNFTBuy();\\n        }\\n    }\\n\\n    /*==============================================================\\n                               Swap Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function swapWithEth(\\n        Lien calldata lien,\\n        uint256 lienId\\n    ) external payable override validateLien(lien, lienId) nonReentrant {\\n        // if (lien.loanStartTime != 0) {\\n        //     revert Errors.LoanStarted();\\n        // }\\n        // if (lien.lender == address(0)) {\\n        //     revert Errors.BidNotTaken();\\n        // }\\n        // /// @dev: underlying account balancing ensures balance > lien.price - msg.value (i.e., no overspend)\\n        // _balanceAccount(msg.sender, lien.price, msg.value);\\n        // // update lien\\n        // liens[lienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: lien.lender,\\n        //             borrower: msg.sender,\\n        //             collection: lien.collection,\\n        //             tokenId: lien.tokenId,\\n        //             price: lien.price,\\n        //             rate: lien.rate,\\n        //             loanStartTime: block.timestamp,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // // transfer NFT to borrower\\n        // IERC721(lien.collection).safeTransferFrom(address(this), msg.sender, lien.tokenId);\\n        // emit SwapWithETH(lienId, msg.sender, block.timestamp);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function repayWithNft(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.borrower) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.loanStartTime == 0) {\\n        //     revert Errors.InactiveLoan();\\n        // }\\n        // // transfer fund to corresponding recipients\\n        // _execRepayWithNft(lien, lienId, tokenId);\\n        // // transfer NFT to the contract\\n        // /// @dev collection.setApprovalForAll should have been called by this point\\n        // /// @dev receiver is this contract, no need to safeTransferFrom\\n        // IERC721(lien.collection).transferFrom(msg.sender, address(this), tokenId);\\n    }\\n\\n    /// @dev unchecked function, make sure lien is valid, caller is borrower and collection is matched\\n    function _execRepayWithNft(Lien memory lien, uint256 lienId, uint256 tokenId) internal {\\n        // accrue interest to lender\\n        uint256 accruedInterest = MathUtils.calculateCurrentInterest(lien.price, lien.rate, lien.loanStartTime);\\n\\n        // pay PnL to borrower\\n        // since: lien.price = sold amount + margin\\n        // and:   payback    = sold amount + margin - interest\\n        // hence: payback    = lien.price - interest\\n        uint256 payback = lien.price - accruedInterest;\\n        if (payback > 0) {\\n            accountBalance[lien.borrower] += payback;\\n        }\\n\\n        // accrue interest to lender\\n        _accrueInterest(lien.lender, accruedInterest);\\n\\n        // update lien (by default, the lien is open to accept new loan)\\n        liens[lienId] = keccak256(\\n            abi.encode(\\n                Lien({\\n                    lender: lien.lender,\\n                    borrower: address(0),\\n                    collection: lien.collection,\\n                    tokenId: tokenId,\\n                    price: lien.price,\\n                    rate: lien.rate,\\n                    loanStartTime: 0,\\n                    auctionStartTime: 0\\n                })\\n            )\\n        );\\n\\n        emit RepayWithNFT(lienId, tokenId);\\n    }\\n\\n    /*==============================================================\\n                            Refinance Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function refinanceLoan(\\n        Lien calldata oldLien,\\n        uint256 oldLienId,\\n        Lien calldata newLien,\\n        uint256 newLienId\\n    ) external payable override validateLien(oldLien, oldLienId) validateLien(newLien, newLienId) nonReentrant {\\n        // if (msg.sender != oldLien.borrower) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (oldLien.loanStartTime == 0) {\\n        //     revert Errors.InactiveLoan();\\n        // }\\n        // if (newLien.loanStartTime != 0) {\\n        //     // cannot swap to another active loan\\n        //     revert Errors.LoanStarted();\\n        // }\\n        // if (newLien.lender == address(0)) {\\n        //     revert Errors.BidNotTaken();\\n        // }\\n        // if (oldLien.collection != newLien.collection) {\\n        //     // cannot swap to a new loan with different collection\\n        //     revert Errors.UnmatchedCollections();\\n        // }\\n        // uint256 accruedInterest = MathUtils.calculateCurrentInterest(\\n        //     oldLien.price,\\n        //     oldLien.rate,\\n        //     oldLien.loanStartTime\\n        // );\\n        // /// @dev old price + msg.value is available now, new price + interest is the need to spend\\n        // /// @dev account balancing ensures balance > new price + interest - (old price + msg.value) (i.e., no overspend)\\n        // _balanceAccount(msg.sender, newLien.price + accruedInterest, oldLien.price + msg.value);\\n        // // accrue interest to the lender\\n        // _accrueInterest(oldLien.lender, accruedInterest);\\n        // // update old lien\\n        // liens[oldLienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: oldLien.lender,\\n        //             borrower: address(0),\\n        //             collection: oldLien.collection,\\n        //             tokenId: newLien.tokenId,\\n        //             price: oldLien.price,\\n        //             rate: oldLien.rate,\\n        //             loanStartTime: 0,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // // update new lien\\n        // liens[newLienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: newLien.lender,\\n        //             borrower: oldLien.borrower,\\n        //             collection: newLien.collection,\\n        //             tokenId: newLien.tokenId,\\n        //             price: newLien.price,\\n        //             rate: newLien.rate,\\n        //             loanStartTime: block.timestamp,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // emit Refinance(oldLienId, newLienId, block.timestamp);\\n    }\\n\\n    /*==============================================================\\n                                 Bid Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function offerBid(\\n        address collection,\\n        uint256 margin,\\n        uint256 price,\\n        uint256 rate\\n    ) external payable override nonReentrant returns (uint256 lienId) {\\n        // if (price > _MAX_PRICE || rate > _MAX_RATE) {\\n        //     revert Errors.InvalidParameters();\\n        // }\\n        // // balance the account for the reest of the margin\\n        // _balanceAccount(msg.sender, margin, msg.value);\\n        // // create a new lien\\n        // Lien memory lien = Lien({\\n        //     lender: address(0),\\n        //     borrower: msg.sender,\\n        //     collection: collection,\\n        //     tokenId: margin, /// @dev: use tokenId for margin storage\\n        //     price: price,\\n        //     rate: rate,\\n        //     loanStartTime: 0,\\n        //     auctionStartTime: 0\\n        // });\\n        // /// @dev Safety: lienId unlikely to overflow by linear increment\\n        // unchecked {\\n        //     liens[lienId = _nextLienId++] = keccak256(abi.encode(lien));\\n        // }\\n        // emit OfferBid(lienId, msg.sender, collection, margin, price, rate);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function updateBid(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 margin,\\n        uint256 price,\\n        uint256 rate\\n    ) external payable validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.borrower) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.lender != address(0)) {\\n        //     /// @dev: if lender exists, an NFT is supplied, regardless of loan active or not,\\n        //     /// bid is taken and can't be updated\\n        //     revert Errors.BidTaken();\\n        // }\\n        // if (price > _MAX_PRICE || rate > _MAX_RATE) {\\n        //     revert Errors.InvalidParameters();\\n        // }\\n        // /// @dev: old margin was stored in the lien.tokenId field\\n        // /// @dev: old margin + msg.value is available now; surplus adds to balance, deficit takes from balance\\n        // _balanceAccount(msg.sender, margin, lien.tokenId + msg.value);\\n        // // update lien\\n        // liens[lienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: address(0),\\n        //             borrower: lien.borrower,\\n        //             collection: lien.collection,\\n        //             tokenId: margin, /// @dev: use tokenId for margin storage\\n        //             price: price,\\n        //             rate: rate,\\n        //             loanStartTime: 0,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // emit UpdateBid(lienId, margin, price, rate);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function cancelBid(Lien calldata lien, uint256 lienId) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.borrower) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.lender != address(0)) {\\n        //     /// @dev: if lender exists, an NFT is supplied, regardless of loan active or not,\\n        //     /// bid is taken and can't be cancelled\\n        //     revert Errors.BidTaken();\\n        // }\\n        // // return margin to borrower\\n        // /// @dev: old margin was stored in the lien.tokenId field\\n        // accountBalance[lien.borrower] += lien.tokenId;\\n        // // delete lien\\n        // delete liens[lienId];\\n        // emit CancelBid(lienId);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function acceptBidSellNftToMarketPull(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address marketplace,\\n        address puller,\\n        bytes calldata tradeData\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // _acceptBidSellNftToMarketCheck(lien, amount);\\n        // _acceptBidSellNftToMarketLienUpdate(lien, lienId, tokenId, amount, msg.sender);\\n        // // transfer NFT into contract\\n        // /// @dev collection.setApprovalForAll should have been called by this point\\n        // /// @dev receiver is this contract, no need to safeTransferFrom\\n        // IERC721(lien.collection).transferFrom(msg.sender, address(this), tokenId);\\n        // _execSellNftToMarketPull(lien, tokenId, amount, marketplace, puller, tradeData);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function acceptBidSellNftToMarketPush(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // _acceptBidSellNftToMarketCheck(lien, amount);\\n        // _acceptBidSellNftToMarketLienUpdate(lien, lienId, tokenId, amount, msg.sender);\\n        // // transfer NFT into contract\\n        // /// @dev collection.setApprovalForAll should have been called by this point\\n        // /// @dev receiver is this contract, no need to safeTransferFrom\\n        // IERC721(lien.collection).transferFrom(msg.sender, address(this), tokenId);\\n        // _execSellNftToMarketPush(lien, tokenId, amount, marketplace, tradeData);\\n    }\\n\\n    function _acceptBidSellNftToMarketCheck(Lien memory lien, uint256 amount) internal {\\n        if (lien.lender != address(0)) {\\n            /// @dev: if lender exists, an NFT is supplied, regardless of loan active or not,\\n            /// bid is taken and can't be re-accepted\\n            revert Errors.BidTaken();\\n        }\\n\\n        // transfer the surplus to the borrower\\n        /// @dev: lien.tokenId stores the margin\\n        /// @dev: revert if margin + sold amount can't cover lien.price, i.e., no overspend\\n        accountBalance[lien.borrower] += lien.tokenId + amount - lien.price;\\n    }\\n\\n    function _acceptBidSellNftToMarketLienUpdate(\\n        Lien memory lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address lender\\n    ) internal {\\n        // update lien\\n        liens[lienId] = keccak256(\\n            abi.encode(\\n                Lien({\\n                    lender: lender,\\n                    borrower: lien.borrower,\\n                    collection: lien.collection,\\n                    tokenId: tokenId,\\n                    price: lien.price,\\n                    rate: lien.rate,\\n                    loanStartTime: block.timestamp,\\n                    auctionStartTime: 0\\n                })\\n            )\\n        );\\n\\n        emit AcceptBid(lienId, lender, tokenId, amount, block.timestamp);\\n    }\\n\\n    /*==============================================================\\n                               Auction Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function startLoanAuction(\\n        Lien calldata lien,\\n        uint256 lienId\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.lender) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.loanStartTime == 0) {\\n        //     revert Errors.InactiveLoan();\\n        // }\\n        // if (lien.auctionStartTime != 0) {\\n        //     revert Errors.AuctionStarted();\\n        // }\\n        // // update lien\\n        // liens[lienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: lien.lender,\\n        //             borrower: lien.borrower,\\n        //             collection: lien.collection,\\n        //             tokenId: lien.tokenId,\\n        //             price: lien.price,\\n        //             rate: lien.rate,\\n        //             loanStartTime: lien.loanStartTime,\\n        //             auctionStartTime: block.timestamp\\n        //         })\\n        //     )\\n        // );\\n        // emit StartAuction(lienId, block.timestamp);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function stopLoanAuction(\\n        Lien calldata lien,\\n        uint256 lienId\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // if (msg.sender != lien.lender) {\\n        //     revert Errors.Unauthorized();\\n        // }\\n        // if (lien.auctionStartTime == 0) {\\n        //     revert Errors.AuctionNotStarted();\\n        // }\\n        // if (block.timestamp < lien.auctionStartTime + _MIN_AUCTION_DURATION) {\\n        //     revert Errors.AuctionEndTooSoon();\\n        // }\\n        // // update lien\\n        // liens[lienId] = keccak256(\\n        //     abi.encode(\\n        //         Lien({\\n        //             lender: lien.lender,\\n        //             borrower: lien.borrower,\\n        //             collection: lien.collection,\\n        //             tokenId: lien.tokenId,\\n        //             price: lien.price,\\n        //             rate: lien.rate,\\n        //             loanStartTime: lien.loanStartTime,\\n        //             auctionStartTime: 0\\n        //         })\\n        //     )\\n        // );\\n        // emit StopAuction(lienId);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function auctionSellNft(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId\\n    ) external override validateLien(lien, lienId) nonReentrant {\\n        // if (lien.auctionStartTime == 0) {\\n        //     revert Errors.AuctionNotStarted();\\n        // }\\n        // // transfer fund to corresponding recipients\\n        // _execAuctionSellNft(lien, lienId, tokenId, msg.sender);\\n        // // transfer NFT to the contract\\n        // /// @dev receiver is this contract, no need to safeTransferFrom\\n        // /// @dev at this point, collection.setApprovalForAll should have been called\\n        // IERC721(lien.collection).transferFrom(msg.sender, address(this), tokenId);\\n    }\\n\\n    /// @dev unchecked function, make sure lien is validated, auction is live and collection is matched\\n    function _execAuctionSellNft(Lien memory lien, uint256 lienId, uint256 tokenId, address auctionBuyer) internal {\\n        uint256 accruedInterest = MathUtils.calculateCurrentInterest(lien.price, lien.rate, lien.loanStartTime);\\n\\n        /// @dev: arithmetic revert if accruedInterest > lien.price, i.e., even 0 buyback cannot cover the interest\\n        uint256 currentAuctionPrice = MathUtils.calculateCurrentAuctionPrice(\\n            lien.price - accruedInterest,\\n            block.timestamp - lien.auctionStartTime,\\n            _AUCTION_DURATION\\n        );\\n\\n        // pay PnL to borrower\\n        uint256 payback = lien.price - currentAuctionPrice - accruedInterest;\\n        if (payback > 0) {\\n            accountBalance[lien.borrower] += payback;\\n        }\\n\\n        // pay auction price to new NFT supplier\\n        payable(auctionBuyer).sendValue(currentAuctionPrice);\\n\\n        // accrue interest to lender\\n        _accrueInterest(lien.lender, accruedInterest);\\n\\n        // update lien (by default, the lien is open to accept new loan)\\n        liens[lienId] = keccak256(\\n            abi.encode(\\n                Lien({\\n                    lender: lien.lender,\\n                    borrower: address(0),\\n                    collection: lien.collection,\\n                    tokenId: tokenId,\\n                    price: lien.price,\\n                    rate: lien.rate,\\n                    loanStartTime: 0,\\n                    auctionStartTime: 0\\n                })\\n            )\\n        );\\n\\n        emit AuctionSellNFT(lienId, auctionBuyer, tokenId, currentAuctionPrice);\\n    }\\n\\n    /*==============================================================\\n                             Push-Based Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Receiver function upon ERC721 transfer\\n     *\\n     * @dev We modify this receiver to enable \\\"push based\\\" NFT supply, where one of the following is embedded in the\\n     * data bytes that are piggy backed with the SafeTransferFrom call:\\n     * (1) the price and rate (for nft supply) (64 bytes) or\\n     * (2) lien information (for NFT repay or auction buy) (288 bytes) or\\n     * (3) lien information and market sell information (accept bid to NFT market sell) (>= 384 bytes).\\n     * This way, the lender doesn't need to additionally sign the \\\"setApprovalForAll\\\" transaction, which saves gas and\\n     * creates a better user experience.\\n     *\\n     * @param from the address which previously owned the NFT\\n     * @param tokenId the NFT identifier which is being transferred\\n     * @param data additional data with no specified format\\n     */\\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata data) external returns (bytes4) {\\n        /// @dev NFT transfer coming from buyNftFromMarket will be flagged as already enterred (re-entrancy status),\\n        /// where the NFT is matched with an existing lien already. If it proceeds (to supply), this NFT will be tied\\n        /// with two liens, which creates divergence.\\n        if (!isEntered()) {\\n            // _pushBasedNftSupply(from, tokenId, data);\\n        }\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function _pushBasedNftSupply(address from, uint256 tokenId, bytes calldata data) internal nonReentrant {\\n        /// @dev this function is external and can be called by anyone, we need to check the NFT is indeed received\\n        /// at this point to proceed, message sender is the NFT collection in nominal function call\\n        if (IERC721(msg.sender).ownerOf(tokenId) != address(this)) {\\n            revert Errors.NFTNotReceived();\\n        }\\n        // use data.length to branch different conditions\\n        if (data.length == 64) {\\n            // Conditon (1): NFT supply\\n            (uint256 price, uint256 rate) = abi.decode(data, (uint256, uint256));\\n            /// @dev the msg.sender is the NFT collection (called by safeTransferFrom's _checkOnERC721Received check)\\n            _supplyNft(from, msg.sender, tokenId, price, rate);\\n        } else if (data.length == 288) {\\n            // Conditon (2): NFT repay or auction buy\\n            (Lien memory lien, uint256 lienId) = abi.decode(data, (Lien, uint256));\\n            /// @dev equivalent to modifier validateLien, replacing calldata to memory\\n            if (liens[lienId] != keccak256(abi.encode(lien))) {\\n                revert Errors.InvalidLien();\\n            }\\n            /// @dev msg.sender is the NFT collection address\\n            if (msg.sender != lien.collection) {\\n                revert Errors.UnmatchedCollections();\\n            }\\n            if (from == lien.borrower) {\\n                /// @dev repayWithNft branch\\n                /// @dev notice that for borrower repayWithNft and auctionSellNft (at any price point) yield the same\\n                /// return, since repayNft's payback = auction's payback + auction price, and auction price goes to the\\n                /// same \\\"from\\\" (the borrower) too. Routing to repayNft is more gas efficient for one less receiver.\\n                if (lien.loanStartTime == 0) {\\n                    revert Errors.InactiveLoan();\\n                }\\n                _execRepayWithNft(lien, lienId, tokenId);\\n            } else {\\n                /// @dev auctionSellNft branch\\n                /// @dev equivalent to modifier auctionLive, replacing calldata to memory\\n                if (lien.auctionStartTime == 0) {\\n                    revert Errors.AuctionNotStarted();\\n                }\\n                /// @dev \\\"from\\\" (acution buyer) is the auction buyer address that calls safeTransferFrom\\n                _execAuctionSellNft(lien, lienId, tokenId, from);\\n            }\\n        } else if (data.length >= 384) {\\n            // Conditon (3): Accept bid to sell NFT to market\\n            /// @dev flexible data.length because tradeData can be of any non-zero length\\n            (\\n                Lien memory lien,\\n                uint256 lienId,\\n                uint256 amount,\\n                address marketplace,\\n                address puller,\\n                bytes memory tradeData\\n            ) = abi.decode(data, (Lien, uint256, uint256, address, address, bytes));\\n            /// @dev equivalent to modifier validateLien, replacing calldata to memory\\n            if (liens[lienId] != keccak256(abi.encode(lien))) {\\n                revert Errors.InvalidLien();\\n            }\\n            /// @dev msg.sender is the NFT collection address\\n            if (msg.sender != lien.collection) {\\n                revert Errors.UnmatchedCollections();\\n            }\\n            /// @dev \\\"from\\\" (nft supplier) is address that calls safeTransferFrom\\n            /// @dev zero address puller, means sell to market using push based flow\\n            if (puller == address(0)) {\\n                _acceptBidSellNftToMarketCheck(lien, amount);\\n                _acceptBidSellNftToMarketLienUpdate(lien, lienId, tokenId, amount, from);\\n                _execSellNftToMarketPush(lien, tokenId, amount, marketplace, tradeData);\\n            } else {\\n                _acceptBidSellNftToMarketCheck(lien, amount);\\n                _acceptBidSellNftToMarketLienUpdate(lien, lienId, tokenId, amount, from);\\n                _execSellNftToMarketPull(lien, tokenId, amount, marketplace, puller, tradeData);\\n            }\\n        } else {\\n            revert Errors.InvalidParameters();\\n        }\\n    }\\n\\n    /*==============================================================\\n                               Balance Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function withdrawAccountBalance() external override nonReentrant {\\n        uint256 balance = accountBalance[msg.sender];\\n        if (balance == 0) return;\\n\\n        accountBalance[msg.sender] = 0;\\n        payable(msg.sender).sendValue(balance);\\n\\n        emit WithdrawAccountBalance(msg.sender, balance);\\n    }\\n\\n    function _accrueInterest(address account, uint256 amount) internal {\\n        uint256 treasuryRate = _treasuryRate; /// @dev SLOAD once to cache, saving gas\\n        if (treasuryRate > 0) {\\n            uint256 treasuryInterest = MathUtils.calculateTreasuryProportion(amount, treasuryRate);\\n            _treasury += treasuryInterest;\\n            amount -= treasuryInterest;\\n        }\\n        accountBalance[account] += amount;\\n\\n        emit AccrueInterest(account, amount);\\n    }\\n\\n    function _balanceAccount(address account, uint256 withdraw, uint256 deposit) internal {\\n        if (withdraw > deposit) {\\n            // use account balance to cover the deposit deficit\\n            /// @dev balance - (amount - deposit) >= 0, i.e., amount <= balance + deposit (cannot overspend)\\n            accountBalance[account] -= (withdraw - deposit);\\n        } else if (deposit > withdraw) {\\n            // top up account balance with the deposit surplus\\n            accountBalance[account] += (deposit - withdraw);\\n        }\\n    }\\n\\n    /*==============================================================\\n                             Validation Logic\\n    ==============================================================*/\\n\\n    modifier validateLien(Lien calldata lien, uint256 lienId) {\\n        if (liens[lienId] != keccak256(abi.encode(lien))) {\\n            revert Errors.InvalidLien();\\n        }\\n        _;\\n    }\\n\\n    /*==============================================================\\n                               Admin Logic\\n    ==============================================================*/\\n\\n    /// @inheritdoc IParticleExchange\\n    function registerMarketplace(address marketplace) external override onlyOwner {\\n        registeredMarketplaces[marketplace] = true;\\n        emit RegisterMarketplace(marketplace);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function unregisterMarketplace(address marketplace) external override onlyOwner {\\n        registeredMarketplaces[marketplace] = false;\\n        emit UnregisterMarketplace(marketplace);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function setTreasuryRate(uint256 rate) external override onlyOwner {\\n        if (rate > _MAX_TREASURY_RATE) {\\n            revert Errors.InvalidParameters();\\n        }\\n        _treasuryRate = rate;\\n        emit UpdateTreasuryRate(rate);\\n    }\\n\\n    /// @inheritdoc IParticleExchange\\n    function withdrawTreasury(address receiver) external override onlyOwner {\\n        uint256 withdrawAmount = _treasury;\\n        if (withdrawAmount > 0) {\\n            if (receiver == address(0)) {\\n                revert Errors.InvalidParameters();\\n            }\\n            _treasury = 0;\\n            payable(receiver).sendValue(withdrawAmount);\\n            emit WithdrawTreasury(receiver, withdrawAmount);\\n        }\\n    }\\n\\n    /*==============================================================\\n                              Miscellaneous\\n    ==============================================================*/\\n\\n    // receive ETH\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH_ADDRESS() external view returns (address) {\\n        return address(weth);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IParticleExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {Lien} from \\\"../libraries/types/Structs.sol\\\";\\n\\ninterface IParticleExchange {\\n    event SupplyNFT(uint256 lienId, address lender, address collection, uint256 tokenId, uint256 price, uint256 rate);\\n\\n    event UpdateLoan(uint256 lienId, uint256 price, uint256 rate);\\n\\n    event WithdrawNFT(uint256 lienId);\\n\\n    event WithdrawETH(uint256 lienId);\\n\\n    event SellMarketNFT(uint256 lienId, address borrower, uint256 soldAmount, uint256 loanStartTime);\\n\\n    event BuyMarketNFT(uint256 lienId, uint256 tokenId, uint256 paidAmount);\\n\\n    event SwapWithETH(uint256 lienId, address borrower, uint256 loanStartTime);\\n\\n    event RepayWithNFT(uint256 lienId, uint256 tokenId);\\n\\n    event Refinance(uint256 oldLienId, uint256 newLienId, uint256 loanStartTime);\\n\\n    event OfferBid(uint256 lienId, address borrower, address collection, uint256 margin, uint256 price, uint256 rate);\\n\\n    event UpdateBid(uint256 lienId, uint256 margin, uint256 price, uint256 rate);\\n\\n    event CancelBid(uint256 lienId);\\n\\n    event AcceptBid(uint256 lienId, address lender, uint256 tokenId, uint256 soldAmount, uint256 loanStartTime);\\n\\n    event StartAuction(uint256 lienId, uint256 auctionStartTime);\\n\\n    event StopAuction(uint256 lienId);\\n\\n    event AuctionSellNFT(uint256 lienId, address supplier, uint256 tokenId, uint256 paidAmount);\\n\\n    event AccrueInterest(address account, uint256 amount);\\n\\n    event WithdrawAccountBalance(address account, uint256 amount);\\n\\n    event UpdateTreasuryRate(uint256 rate);\\n\\n    event WithdrawTreasury(address receiver, uint256 amount);\\n\\n    event RegisterMarketplace(address marketplace);\\n\\n    event UnregisterMarketplace(address marketplace);\\n\\n    /*==============================================================\\n                                Supply Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Supply an NFT to contract\\n     * @param collection The address to the NFT collection\\n     * @param tokenId The ID of the NFT being supplied\\n     * @param price The supplier specified price for NFT\\n     * @param rate The supplier specified interest rate\\n     * @return lienId newly generated lienId\\n     */\\n    function supplyNft(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 rate\\n    ) external returns (uint256 lienId);\\n\\n    /**\\n     * @notice Update Loan parameters\\n     * @param lien Reconstructed lien info\\n     * @param lienId The ID for the existing lien\\n     * @param price The supplier specified new price for NFT\\n     * @param rate The supplier specified new interest rate\\n     */\\n    function updateLoan(Lien calldata lien, uint256 lienId, uint256 price, uint256 rate) external;\\n\\n    /*==============================================================\\n                              Withdraw Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Withdraw NFT from the contract\\n     * @param lien Reconstructed lien info\\n     * @param lienId The ID for the lien being cleared\\n     */\\n    function withdrawNft(Lien calldata lien, uint256 lienId) external;\\n\\n    /**\\n     * @notice Withdraw ETH from the contract\\n     * @param lien Reconstructed lien info\\n     * @param lienId The ID for the lien being cleared\\n     */\\n    function withdrawEth(Lien calldata lien, uint256 lienId) external;\\n\\n    /**\\n     * @notice Withdraw account balance of the message sender account\\n     */\\n    function withdrawAccountBalance() external;\\n\\n    /*==============================================================\\n                               Trading Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Pull-based sell NFT to market (another contract initiates NFT transfer)\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param amount Declared ETH amount for NFT sale\\n     * @param marketplace The contract address of the marketplace (e.g. Seaport Proxy Router)\\n     * @param puller The contract address that executes the pull operation (e.g. Seaport Conduit)\\n     * @param tradeData The trade execution bytes on the marketplace\\n     */\\n    function sellNftToMarketPull(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 amount,\\n        address marketplace,\\n        address puller,\\n        bytes calldata tradeData\\n    ) external payable;\\n\\n    /**\\n     * @notice Push-based sell NFT to market (this contract initiates NFT transfer)\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param amount Declared ETH amount for NFT sale\\n     * @param marketplace The contract address of the marketplace\\n     * @param tradeData The trade execution bytes to route to the marketplace\\n     */\\n    function sellNftToMarketPush(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 amount,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) external payable;\\n\\n    /**\\n     * @notice Buy NFT from market\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param tokenId The ID of the NFT being bought\\n     * @param amount Declared ETH amount for NFT purchase\\n     * @param spender The spender address to approve WETH spending, zero address to use ETH\\n     * @param marketplace The address of the marketplace\\n     * @param tradeData The trade execution bytes on the marketplace\\n     */\\n    function buyNftFromMarket(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address spender,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) external;\\n\\n    /**\\n     * @notice Swap NFT with ETH\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     */\\n    function swapWithEth(Lien calldata lien, uint256 lienId) external payable;\\n\\n    /**\\n     * @notice Repay loan with NFT\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param tokenId The ID of the NFT being used to repay the loan\\n     */\\n    function repayWithNft(Lien calldata lien, uint256 lienId, uint256 tokenId) external;\\n\\n    /**\\n     * @notice Refinance an existing loan with a new one\\n     * @param oldLien Reconstructed old lien info\\n     * @param oldLienId The ID for the existing lien\\n     * @param newLien Reconstructed new lien info\\n     * @param newLienId The ID for the new lien\\n     */\\n    function refinanceLoan(\\n        Lien calldata oldLien,\\n        uint256 oldLienId,\\n        Lien calldata newLien,\\n        uint256 newLienId\\n    ) external payable;\\n\\n    /*==============================================================\\n                                 Bid Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Trader offers a bid for loan\\n     * @param collection The address to the NFT collection\\n     * @param margin Margin to use, should satisfy: margin <= msg.value + accountBalance[msg.sender]\\n     * @param price Bade desired price for NFT supplier\\n     * @param rate Bade interest rate for NFT supplier\\n     * @return lienId newly generated lienId\\n     */\\n    function offerBid(\\n        address collection,\\n        uint256 margin,\\n        uint256 price,\\n        uint256 rate\\n    ) external payable returns (uint256 lienId);\\n\\n    /**\\n     * @notice Trader offers a bid for loan\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param margin Margin to use, should satisfy: margin <= msg.value + accountBalance[msg.sender]\\n     * @param price Bade desired price for NFT supplier\\n     * @param rate Bade interest rate for NFT supplier\\n     */\\n    function updateBid(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 margin,\\n        uint256 price,\\n        uint256 rate\\n    ) external payable;\\n\\n    /**\\n     * @notice Trader cancels a opened bid (not yet accepted)\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     */\\n    function cancelBid(Lien calldata lien, uint256 lienId) external;\\n\\n    /**\\n     * @notice Supplier accepts a bid by supplying an NFT and pull-based sell to market\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param tokenId The ID of the NFT being supplied\\n     * @param amount Declared ETH amount for NFT sale\\n     * @param marketplace The address of the marketplace (e.g. Seaport Proxy Router)\\n     * @param puller The contract address that executes the pull operation (e.g. Seaport Conduit)\\n     * @param tradeData The trade execution bytes on the marketplace\\n     */\\n    function acceptBidSellNftToMarketPull(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address marketplace,\\n        address puller,\\n        bytes calldata tradeData\\n    ) external;\\n\\n    /**\\n     * @notice Supplier accepts a bid by supplying an NFT and push-based sell to market\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param tokenId The ID of the NFT being supplied\\n     * @param amount Declared ETH amount for NFT sale\\n     * @param marketplace The address of the marketplace\\n     * @param tradeData The trade execution bytes on the marketplace\\n     */\\n    function acceptBidSellNftToMarketPush(\\n        Lien calldata lien,\\n        uint256 lienId,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address marketplace,\\n        bytes calldata tradeData\\n    ) external;\\n\\n    /*==============================================================\\n                               Auction Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Start auction for a loan\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     */\\n    function startLoanAuction(Lien calldata lien, uint256 lienId) external;\\n\\n    /**\\n     * @notice Stop an auction for a loan\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     */\\n    function stopLoanAuction(Lien calldata lien, uint256 lienId) external;\\n\\n    /**\\n     * @notice Buy NFT from auction\\n     * @param lien Reconstructed lien info\\n     * @param lienId The lien ID\\n     * @param tokenId The ID of the NFT being bought\\n     */\\n    function auctionSellNft(Lien calldata lien, uint256 lienId, uint256 tokenId) external;\\n\\n    /*==============================================================\\n                               Admin Logic\\n    ==============================================================*/\\n\\n    /**\\n     * @notice Register a trusted marketplace address\\n     * @param marketplace The address of the marketplace\\n     */\\n    function registerMarketplace(address marketplace) external;\\n\\n    /**\\n     * @notice Unregister a marketplace address\\n     * @param marketplace The address of the marketplace\\n     */\\n    function unregisterMarketplace(address marketplace) external;\\n\\n    /**\\n     * @notice Update treasury rate\\n     * @param rate The treasury rate in bips\\n     */\\n    function setTreasuryRate(uint256 rate) external;\\n\\n    /**\\n     * @notice Withdraw treasury balance\\n     * @param receiver The address to receive the treasury balance\\n     */\\n    function withdrawTreasury(address receiver) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Adopted from OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function isEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary MathUtils {\\n    uint256 private constant _BASIS_POINTS = 10_000;\\n\\n    /**\\n     * @dev Calculate the current interest linearly accrued since the loan start time.\\n     * @param principal The principal amount of the loan in WEI\\n     * @param rateBips The yearly interest rate of the loan in bips\\n     * @param loanStartTime The timestamp at which this loan is opened\\n     * @return interest The current interest in WEI\\n     */\\n    function calculateCurrentInterest(\\n        uint256 principal,\\n        uint256 rateBips,\\n        uint256 loanStartTime\\n    ) external view returns (uint256 interest) {\\n        interest = (principal * rateBips * (block.timestamp - loanStartTime)) / (_BASIS_POINTS * 365 days);\\n    }\\n\\n    /**\\n     * @dev Calculates the current allowed auction price (increases linearly in time)\\n     * @param price The max auction buy price in WEI\\n     * @param auctionElapsed The current elapsed auction time\\n     * @param auctionDuration The block span for the auction\\n     * @return currentAuctionPrice Current allowed auction price in WEI\\n     */\\n    function calculateCurrentAuctionPrice(\\n        uint256 price,\\n        uint256 auctionElapsed,\\n        uint256 auctionDuration\\n    ) external pure returns (uint256 currentAuctionPrice) {\\n        uint256 auctionPortion = auctionElapsed > auctionDuration ? auctionDuration : auctionElapsed;\\n        currentAuctionPrice = (price * auctionPortion) / auctionDuration;\\n    }\\n\\n    /**\\n     * @dev Calculates the proportion that goes into treasury\\n     * @param interest total interest accrued in WEI\\n     * @param portionBips The treasury proportion in bips\\n     * @return treasuryAmount Amount goes into treasury in WEI\\n     */\\n    function calculateTreasuryProportion(\\n        uint256 interest,\\n        uint256 portionBips\\n    ) external pure returns (uint256 treasuryAmount) {\\n        treasuryAmount = (interest * portionBips) / _BASIS_POINTS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/types/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nstruct Lien {\\n    address lender; // NFT supplier address\\n    address borrower; // NFT trade executor address\\n    address collection; // NFT collection address\\n    uint256 tokenId; /// NFT ID  (@dev: at borrower bidding, this field is used to store margin)\\n    uint256 price; // NFT supplier's desired sold price\\n    uint256 rate; // APR in bips, _BASIS_POINTS defined in MathUtils.sol\\n    uint256 loanStartTime; // loan start block.timestamp\\n    uint256 auctionStartTime; // auction start block.timestamp\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/types/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Errors {\\n    error Unauthorized();\\n    error UnregisteredMarketplace();\\n    error InvalidParameters();\\n    error InvalidLien();\\n    error LoanStarted();\\n    error InactiveLoan();\\n    error LiquidationHasNotReached();\\n    error MartketplaceFailedToTrade();\\n    error InvalidNFTSell();\\n    error InvalidNFTBuy();\\n    error NFTNotReceived();\\n    error Overspend();\\n    error UnmatchedCollections();\\n    error BidTaken();\\n    error BidNotTaken();\\n    error AuctionStarted();\\n    error AuctionNotStarted();\\n    error AuctionEndTooSoon();\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.9._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wethAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidLien\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParameters\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"}],\"name\":\"AcceptBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"AuctionSellNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"BuyMarketNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"CancelBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"OfferBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"}],\"name\":\"Refinance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"}],\"name\":\"RegisterMarketplace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"RepayWithNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"}],\"name\":\"SellMarketNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"name\":\"StartAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"StopAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SupplyNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"}],\"name\":\"SwapWithETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"}],\"name\":\"UnregisterMarketplace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"UpdateBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"UpdateLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"UpdateTreasuryRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAccountBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"WithdrawETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"WithdrawNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTreasury\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"puller\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"name\":\"acceptBidSellNftToMarketPull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"name\":\"acceptBidSellNftToMarketPush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"auctionSellNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"name\":\"buyNftFromMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"cancelBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"liens\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"lienHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"offerBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"oldLien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"oldLienId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"newLien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"newLienId\",\"type\":\"uint256\"}],\"name\":\"refinanceLoan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"}],\"name\":\"registerMarketplace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"}],\"name\":\"registeredMarketplaces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"repayWithNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"puller\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"name\":\"sellNftToMarketPull\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"name\":\"sellNftToMarketPush\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setTreasuryRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"startLoanAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"stopLoanAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"supplyNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"swapWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"}],\"name\":\"unregisterMarketplace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAccountBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Lien\",\"name\":\"lien\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lienId\",\"type\":\"uint256\"}],\"name\":\"withdrawNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ParticleExchange", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}