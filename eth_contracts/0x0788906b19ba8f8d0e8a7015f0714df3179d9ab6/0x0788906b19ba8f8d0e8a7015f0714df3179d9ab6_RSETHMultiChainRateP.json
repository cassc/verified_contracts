{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cross-chain/RSETHMultiChainRateProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { MultiChainRateProvider } from \\\"./MultiChainRateProvider.sol\\\";\\n\\nimport { ILRTOracle } from \\\"../interfaces/ILRTOracle.sol\\\";\\n\\n/// @title rsETH multi chain rate provider\\n/// @notice Provides the current exchange rate of rsETH to various receiver contract on a different chains\\ncontract RSETHMultiChainRateProvider is MultiChainRateProvider {\\n    address public rsETHPriceOracle;\\n\\n    constructor(address _rsETHPriceOracle, address _layerZeroEndpoint) {\\n        rsETHPriceOracle = _rsETHPriceOracle;\\n\\n        rateInfo = RateInfo({\\n            tokenSymbol: \\\"rsETH\\\",\\n            tokenAddress: 0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7, // rsETH token address on ETH mainnet\\n            baseTokenSymbol: \\\"ETH\\\",\\n            baseTokenAddress: address(0) // Address 0 for native tokens\\n         });\\n\\n        layerZeroEndpoint = _layerZeroEndpoint;\\n    }\\n\\n    /// @notice Returns the latest rate from the rsETH contract\\n    function getLatestRate() public view override returns (uint256) {\\n        return ILRTOracle(rsETHPriceOracle).rsETHPrice();\\n    }\\n\\n    /// @notice Calls the getLatestRate function and returns the rate\\n    function getRate() external view returns (uint256) {\\n        return getLatestRate();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain/MultiChainRateProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport { ILayerZeroEndpoint } from \\\"../interfaces/ILayerZeroEndpoint.sol\\\";\\n\\n/// @title Multi chain rate provider. By witherblock reference: https://github.com/witherblock/gyarados\\n/// @notice Provides a rate to a multiple receiver contracts on a different chain than the one this contract is deployed\\n/// on\\n/// @dev Powered using LayerZero, all chainId(s) references are for LayerZero chainIds and not blockchain chainIds\\nabstract contract MultiChainRateProvider is Ownable, ReentrancyGuard {\\n    /// @notice Last rate updated on the provider\\n    uint256 public rate;\\n\\n    /// @notice Last time rate was updated\\n    uint256 public lastUpdated;\\n\\n    /// @notice LayerZero endpoint address\\n    address public layerZeroEndpoint;\\n\\n    /// @notice Information of which token and base token rate is being provided\\n    RateInfo public rateInfo;\\n\\n    /// @notice Rate receivers\\n    RateReceiver[] public rateReceivers;\\n\\n    struct RateReceiver {\\n        uint16 _chainId;\\n        address _contract;\\n    }\\n\\n    struct RateInfo {\\n        string tokenSymbol;\\n        address tokenAddress;\\n        string baseTokenSymbol;\\n        address baseTokenAddress;\\n    }\\n\\n    /// @notice Emitted when rate is updated\\n    /// @param newRate the rate that was updated\\n    event RateUpdated(uint256 newRate);\\n\\n    /// @notice Emitted when LayerZero Endpoint is updated\\n    /// @param newLayerZeroEndpoint the LayerZero Endpoint address that was updated\\n    event LayerZeroEndpointUpdated(address newLayerZeroEndpoint);\\n\\n    /// @notice Emitted when RateReceiver is updated\\n    /// @param newRateReceiver the RateReceiver address that was updated\\n    event RateReceiverUpdated(address newRateReceiver);\\n\\n    /// @notice Emitted when a new rate receiver is added\\n    /// @param newChainId the chainId of the rate receiver\\n    /// @param newContract the address of the rate receiver\\n    event RateReceiverAdded(uint16 newChainId, address newContract);\\n\\n    /// @notice Emitted when a rate receiver is removed\\n    /// @param oldChainId the chainId of the rate receiver\\n    /// @param oldContract the address of the rate receiver\\n    event RateReceiverRemoved(uint16 oldChainId, address oldContract);\\n\\n    /// @notice Updates the LayerZero Endpoint address\\n    /// @dev Can only be called by owner\\n    /// @param _layerZeroEndpoint the new layer zero endpoint address\\n    function updateLayerZeroEndpoint(address _layerZeroEndpoint) external onlyOwner {\\n        layerZeroEndpoint = _layerZeroEndpoint;\\n\\n        emit LayerZeroEndpointUpdated(_layerZeroEndpoint);\\n    }\\n\\n    /// @notice Adds a rate receiver\\n    /// @dev Can only be called by owner\\n    /// @param _chainId rate receiver chainId\\n    /// @param _contract rate receiver address\\n    function addRateReceiver(uint16 _chainId, address _contract) external onlyOwner {\\n        rateReceivers.push(RateReceiver({ _chainId: _chainId, _contract: _contract }));\\n\\n        emit RateReceiverAdded(_chainId, _contract);\\n    }\\n\\n    /// @notice Removes a rate receiver\\n    /// @dev Can only be called by owner\\n    /// @param _index the index of the rate receiver\\n    function removeRateReceiver(uint256 _index) external onlyOwner {\\n        // Store the rate receiver in a memory var\\n        RateReceiver memory _rateReceiverToBeRemoved = rateReceivers[_index];\\n\\n        // Get the current length of all the rate receivers\\n        uint256 rateReceiversLength = rateReceivers.length;\\n\\n        // Get the last index of the all the rate receivers\\n        uint256 lastIndex = rateReceiversLength - 1;\\n\\n        if (lastIndex != _index) {\\n            // Get the last rate receiver\\n            RateReceiver memory lastValue = rateReceivers[lastIndex];\\n\\n            // Replace the index value with the last index value\\n            rateReceivers[_index] = lastValue;\\n        }\\n\\n        rateReceivers.pop();\\n\\n        emit RateReceiverRemoved(_rateReceiverToBeRemoved._chainId, _rateReceiverToBeRemoved._contract);\\n    }\\n\\n    /// @notice Updates rate in this contract and on the receivers\\n    /// @dev This function is set to payable to pay for gas on execute lzReceive (on the receiver contract)\\n    /// on the destination chain. To compute the correct value to send check here -\\n    /// https://layerzero.gitbook.io/docs/evm-guides/code-examples/estimating-message-fees\\n    function updateRate() external payable nonReentrant {\\n        uint256 latestRate = getLatestRate();\\n\\n        rate = latestRate;\\n\\n        lastUpdated = block.timestamp;\\n\\n        bytes memory _payload = abi.encode(latestRate);\\n\\n        uint256 rateReceiversLength = rateReceivers.length;\\n\\n        for (uint256 i; i < rateReceiversLength;) {\\n            uint16 dstChainId = uint16(rateReceivers[i]._chainId);\\n\\n            bytes memory remoteAndLocalAddresses = abi.encodePacked(rateReceivers[i]._contract, address(this));\\n\\n            (uint256 estimatedFee,) = ILayerZeroEndpoint(layerZeroEndpoint).estimateFees(\\n                dstChainId, address(this), _payload, false, bytes(\\\"\\\")\\n            );\\n\\n            ILayerZeroEndpoint(layerZeroEndpoint).send{ value: estimatedFee }(\\n                dstChainId, remoteAndLocalAddresses, _payload, payable(msg.sender), address(0x0), bytes(\\\"\\\")\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit RateUpdated(rate);\\n    }\\n\\n    /// @notice Estimate the fees of sending an update to a receiver contract for a\\n    /// particular destination chain id\\n    /// @param _dstChainId desitnation chainId\\n    /// @return estimatedFee the estimated fee\\n    function estimateFees(uint16 _dstChainId) external view returns (uint256 estimatedFee) {\\n        uint256 latestRate = getLatestRate();\\n\\n        bytes memory _payload = abi.encode(latestRate);\\n\\n        (estimatedFee,) =\\n            ILayerZeroEndpoint(layerZeroEndpoint).estimateFees(_dstChainId, address(this), _payload, false, bytes(\\\"\\\"));\\n    }\\n\\n    /// @notice Estimate the fees of sending an update to all chains/receiver contracts\\n    /// @return totalEstimatedFee the total estimated fee\\n    function estimateTotalFee() external view returns (uint256 totalEstimatedFee) {\\n        uint256 latestRate = getLatestRate();\\n\\n        bytes memory _payload = abi.encode(latestRate);\\n\\n        uint256 rateReceiversLength = rateReceivers.length;\\n\\n        for (uint256 i; i < rateReceiversLength;) {\\n            uint16 dstChainId = uint16(rateReceivers[i]._chainId);\\n\\n            (uint256 estimatedFee,) = ILayerZeroEndpoint(layerZeroEndpoint).estimateFees(\\n                dstChainId, address(this), _payload, false, bytes(\\\"\\\")\\n            );\\n\\n            totalEstimatedFee += estimatedFee;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function getRateReceivers() external view returns (RateReceiver[] memory) {\\n        return rateReceivers;\\n    }\\n\\n    /// @notice Returns the latest rate\\n    function getLatestRate() public view virtual returns (uint256) { }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILRTOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface ILRTOracle {\\n    // events\\n    event AssetPriceOracleUpdate(address indexed asset, address indexed priceOracle);\\n\\n    // methods\\n    function getAssetPrice(address asset) external view returns (uint256);\\n    function assetPriceOracle(address asset) external view returns (address);\\n    function rsETHPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the\\n    // additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer\\n    // on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    )\\n        external\\n        payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint256 _gasLimit,\\n        bytes calldata _payload\\n    )\\n        external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    )\\n        external\\n        view\\n        returns (uint256 nativeFee, uint256 zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint256 _configType\\n    )\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"solidity-code-metrics/=node_modules/solidity-code-metrics/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rsETHPriceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_layerZeroEndpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLayerZeroEndpoint\",\"type\":\"address\"}],\"name\":\"LayerZeroEndpointUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"RateReceiverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"oldChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldContract\",\"type\":\"address\"}],\"name\":\"RateReceiverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRateReceiver\",\"type\":\"address\"}],\"name\":\"RateReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"RateUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"addRateReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"}],\"name\":\"estimateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"estimatedFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimateTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalEstimatedFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRateReceivers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"internalType\":\"struct MultiChainRateProvider.RateReceiver[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerZeroEndpoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"baseTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"baseTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rateReceivers\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeRateReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rsETHPriceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_layerZeroEndpoint\",\"type\":\"address\"}],\"name\":\"updateLayerZeroEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "RSETHMultiChainRateProvider", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000349a73444b1a310bae67ef67973022020d70020d00000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd675", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}