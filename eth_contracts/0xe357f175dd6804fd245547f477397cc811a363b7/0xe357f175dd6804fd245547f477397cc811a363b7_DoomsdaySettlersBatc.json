{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DoomsdaySettlersBatchReinforceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"./interfaces/ISettlersBatchable.sol\\\";\\n\\n// Requires Approval\\n//  It takes the tokens, reinforces them, and then gives them back at the end of the tx. \\n//   Sufficient msg.value must be provided. If you provide surplus msg.value, it refunds \\n//    that at the end too. If anyone other than the Settlers contract sends it ETH, it\\n//     immediately refunds it.\\n\\ncontract DoomsdaySettlersBatchReinforceV2{\\n\\n    ISettlersBatchable settlers;\\n    address immutable _setters;\\n    uint80 constant DAMAGE_FEE = 0.008 ether;\\n\\n    constructor( address __settlers){\\n        settlers = ISettlersBatchable(__settlers);\\n        _setters = __settlers;\\n    }\\n\\n    receive() external payable{\\n        if(msg.sender != _setters){\\n            payable(msg.sender).transfer(msg.value);\\n        }\\n    }\\n\\n    function multiLevelReinforce(uint32 _tokenId, uint80[4] memory _currentLevels, uint80[4] memory _extraLevels, uint80 _highest, uint80 _baseCost) external payable{\\n        _multiLevelReinforce(_tokenId,_currentLevels,_extraLevels,_highest,_baseCost);\\n\\n            require(gasleft() > 10000,\\\"gas failsafe\\\");\\n            if(address(this).balance > 0){\\n                payable(msg.sender).transfer(address(this).balance);\\n            }\\n    }\\n\\n\\n    function _multiLevelReinforce(uint32 _tokenId, uint80[4] memory _currentLevels, uint80[4] memory _extraLevels, uint80 _highest, uint80 _baseCost) private{\\n        settlers.transferFrom(msg.sender,address(this),_tokenId);\\n\\n        for(uint80 i = 1; i <= _highest; i++){\\n            bool[4] memory __resources;\\n            uint80 _cost;\\n\\n            uint80 reinforcementUnits;\\n            uint80 totalLevels;\\n\\n            for(uint j = 0; j < 4; j++){\\n                if(_extraLevels[j] >= i){\\n                    __resources[j] = true;\\n                    reinforcementUnits += uint80(2) ** _currentLevels[j];\\n                    totalLevels++;\\n\\n                    _currentLevels[j]++;\\n\\n                }\\n            }\\n\\n            _cost = reinforcementUnits * _baseCost + totalLevels * DAMAGE_FEE;\\n\\n            settlers.reinforce{value: _cost}(_tokenId,__resources);\\n\\n        }\\n\\n        settlers.transferFrom(address(this),msg.sender,_tokenId);\\n    }\\n\\n\\n    function multiTokenReinforce(uint32[] memory _tokenIds, uint80[4][] memory _currentLevels, uint80[4][] memory _extraLevels, uint8[] memory _highest, uint80 _baseCost) external payable{\\n        require(_tokenIds.length > 0,\\\"no tokens\\\");\\n        \\n        for(uint i = 0; i < _tokenIds.length; i++){\\n            _multiLevelReinforce(_tokenIds[i],_currentLevels[i],_extraLevels[i],_highest[i],_baseCost);\\n        }\\n        \\n        require(gasleft() > 10000,\\\"gas failsafe\\\");\\n        if(address(this).balance > 0){\\n            payable(msg.sender).transfer(address(this).balance);\\n        }\\n\\n    }\\n\\n\\n\\n\\n\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISettlersBatchable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\ninterface ISettlersBatchable {\\n    function totalSupply()          external view returns(uint256);\\n\\n    // function hashOf(uint32 _tokenId)  external view returns(bytes32);\\n\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    function reinforce(uint32 _tokenId, bool[4] memory _resources) external payable;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__settlers\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint80[4]\",\"name\":\"_currentLevels\",\"type\":\"uint80[4]\"},{\"internalType\":\"uint80[4]\",\"name\":\"_extraLevels\",\"type\":\"uint80[4]\"},{\"internalType\":\"uint80\",\"name\":\"_highest\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"_baseCost\",\"type\":\"uint80\"}],\"name\":\"multiLevelReinforce\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_tokenIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint80[4][]\",\"name\":\"_currentLevels\",\"type\":\"uint80[4][]\"},{\"internalType\":\"uint80[4][]\",\"name\":\"_extraLevels\",\"type\":\"uint80[4][]\"},{\"internalType\":\"uint8[]\",\"name\":\"_highest\",\"type\":\"uint8[]\"},{\"internalType\":\"uint80\",\"name\":\"_baseCost\",\"type\":\"uint80\"}],\"name\":\"multiTokenReinforce\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DoomsdaySettlersBatchReinforceV2", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000047979015bd314a4bf8fa1adfd73012384b5adbb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}