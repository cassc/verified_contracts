{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"MantleTokenMigratorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\n\\n/// @title Mantle Token Migrator V2\\n/// @author Derrick Johnson\\n/// @notice Token migration contract for the BIT to MNT token migration\\ncontract MantleTokenMigratorV2 {\\n    using SafeTransferLib for ERC20;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /// @dev The address of the BIT token contract\\n    address public immutable BIT_TOKEN_ADDRESS;\\n\\n    /// @dev The address of the MNT token contract\\n    address public immutable MNT_TOKEN_ADDRESS;\\n\\n    /// @dev The address of the treasury contract that receives defunded tokens\\n    address public treasury;\\n\\n    /// @dev The address of the owner of the contract\\n    /// @notice The owner of the contract is initially the deployer of the contract but will be transferred\\n    ///         to a multisig wallet immediately after deployment\\n    address public owner;\\n\\n    /// @dev A mapping of addresses with the ability to approve token migrations\\n    mapping(address => bool) public approvers;\\n\\n    /// @dev A mapping of addresses with the ability blacklist addresses from migration\\n    mapping(address => bool) public blacklisters;\\n\\n    /// @dev A mapping of addresses blacklisted from migration\\n    mapping(address => bool) public blacklistedAddresses;\\n\\n    /// @dev Boolean indicating if this contract is halted\\n    bool public halted;\\n\\n    /* ========== EVENTS ========== */\\n\\n    // TokenSwap Events\\n\\n    /// @dev Emitted when a user swaps BIT for MNT\\n    /// @param to The address of the user that swapped BIT for MNT\\n    /// @param amountSwapped The amount of BIT swapped and MNT received\\n    event TokensMigrated(address indexed to, uint256 amountSwapped);\\n\\n    /// @dev Emitted when a user is approved for token migration\\n    /// @param approver The address of the caller that approved the user for token migration\\n    /// @param user The address of the user that was approved for token migration\\n    /// @param amount The amount of BIT tokens approved for token migration\\n    event TokenMigrationApproved(address indexed approver, address indexed user, uint256 amount);\\n\\n    // Contract State Events\\n\\n    /// @dev Emitted when the owner of the contract is changed\\n    /// @param previousOwner The address of the previous owner of this contract\\n    /// @param newOwner The address of the new owner of this contract\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @dev Emitted when the contract is halted\\n    /// @param halter The address of the caller that halted this contract\\n    event ContractHalted(address indexed halter);\\n\\n    /// @dev Emitted when the contract is unhalted\\n    /// @param halter The address of the caller that unhalted this contract\\n    event ContractUnhalted(address indexed halter);\\n\\n    /// @dev Emitted when the treasury address is changed\\n    /// @param previousTreasury The address of the previous treasury\\n    /// @param newTreasury The address of the new treasury\\n    event TreasuryChanged(address indexed previousTreasury, address indexed newTreasury);\\n\\n    // Admin Events\\n\\n    /// @dev Emitted when non BIT/MNT tokens are swept from the contract by the owner to the recipient address\\n    /// @param token The address of the token contract that was swept\\n    /// @param recipient The address of the recipient of the swept tokens\\n    /// @param amount The amount of tokens swept\\n    event TokensSwept(address indexed token, address indexed recipient, uint256 amount);\\n\\n    /// @dev Emitted when BIT/MNT tokens are defunded from the contract by the owner to the treasury\\n    /// @param defunder The address of the defunder\\n    /// @param token The address of the token contract that was defunded\\n    /// @param amount The amount of tokens defunded\\n    event ContractDefunded(address indexed defunder, address indexed token, uint256 amount);\\n\\n    /// @dev Emitted when the Approver role is given to an address\\n    /// @param approver The address that was given the Approver role\\n    event ApproverRoleAssigned(address indexed approver);\\n\\n    /// @dev Emitted when the Approver role is revoked from an address\\n    /// @param approver The address that had the Approver role revoked\\n    event ApproverRoleRevoked(address indexed approver);\\n\\n    /// @dev Emitted when the Blacklister role is given to an address\\n    /// @param blacklister The address that was given the Blacklister role\\n    event BlacklisterRoleAssigned(address indexed blacklister);\\n\\n    /// @dev Emitted when the Blacklister role is revoked from an address\\n    /// @param blacklister The address that had the Blacklister role revoked\\n    event BlacklisterRoleRevoked(address indexed blacklister);\\n\\n    /// @dev Emitted when an address is blacklisted from migration\\n    /// @param blacklister The address of the caller that blacklisted the address\\n    /// @param blacklistedAddress The address that was blacklisted\\n    event BlacklistModified(\\n        address indexed blacklister, address indexed blacklistedAddress, bool indexed blacklistStatus\\n    );\\n\\n    /// @dev Emitted when an address is removed from the blacklist\\n    /// @param blacklister The address of the caller that removed the address from the blacklist\\n    /// @param blacklistedAddress The address that was removed from the blacklist\\n    event AddressRemovedFromBlacklist(address indexed blacklister, address indexed blacklistedAddress);\\n\\n    /* ========== ERRORS ========== */\\n\\n    /// @notice Thrown when the caller is not the owner and the function being called uses the {onlyOwner} modifier\\n    /// @param caller The address of the caller\\n    error MantleTokenMigrator_OnlyOwner(address caller);\\n\\n    /// @notice Thrown when the caller does not have the Approver role and the function being called uses the {onlyApprover} modifier\\n    /// @param caller The address of the caller\\n    error MantleTokenMigrator_OnlyApprover(address caller);\\n\\n    /// @notice Thrown when the caller does not have the Blacklist role and the function being called uses the {onlyBlacklister} modifier\\n    /// @param caller The address of the caller\\n    error MantleTokenMigrator_OnlyBlacklister(address caller);\\n\\n    /// @notice Thrown when the address being approved for token migration is blacklisted\\n    error MantleTokenMigrator_BlacklistModified(address tokenMigrator);\\n\\n    /// @notice Thrown when the contract is halted and the function being called uses the {onlyWhenNotHalted} modifier\\n    error MantleTokenMigrator_OnlyWhenNotHalted();\\n\\n    /// @notice Thrown when the input passed into the {_migrateTokens} function is zero\\n    error MantleTokenMigrator_ZeroSwap();\\n\\n    /// @notice Thrown when at least one of the inputs passed into the constructor is a zero value\\n    error MantleTokenMigrator_ImproperlyInitialized();\\n\\n    /// @notice Thrown when the {_tokenAddress} passed into the {sweepTokens} function is the BIT or MNT token address\\n    /// @param token The address of the token contract\\n    error MantleTokenMigrator_SweepNotAllowed(address token);\\n\\n    /// @notice Thrown when the {_tokenAddress} passed into the {defundContract} function is NOT the BIT or MNT token address\\n    /// @param token The address of the token contract\\n    error MantleTokenMigrator_InvalidFundingToken(address token);\\n\\n    /// @notice Thrown when the treasury is the zero address\\n    error MantleTokenMigrator_InvalidTreasury(address treasury);\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    /// @notice Modifier that checks that the caller is the owner of the contract\\n    /// @dev Throws {MantleTokenMigrator_OnlyOwner} if the caller is not the owner\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) revert MantleTokenMigrator_OnlyOwner(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Modifier that checks that the caller has the Approver role\\n    /// @dev Throws {MantleTokenMigrator_OnlyApprover} if the caller does not have the Approver role\\n    modifier onlyApprover() {\\n        if (!approvers[msg.sender]) revert MantleTokenMigrator_OnlyApprover(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Modifier that checks that the contract is not halted\\n    /// @dev Throws {MantleTokenMigrator_OnlyWhenNotHalted} if the contract is halted\\n    modifier onlyWhenNotHalted() {\\n        if (halted) revert MantleTokenMigrator_OnlyWhenNotHalted();\\n        _;\\n    }\\n\\n    /// @notice Modifier that checks that the caller has the Blacklist role\\n    /// @dev Throws {MantleTokenMigrator_OnlyBlacklister} if the caller does not have the Blacklist role\\n    modifier onlyBlacklister() {\\n        if (!blacklisters[msg.sender]) revert MantleTokenMigrator_OnlyBlacklister(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Modifier that checks that the address being approved for token migration is not blacklisted\\n    /// @dev Throws {MantleTokenMigrator_BlacklistModified} if the address is blacklisted\\n    /// @param _address The address to check\\n    modifier onlyWhenNotBlacklisted(address _address) {\\n        if (blacklistedAddresses[_address]) revert MantleTokenMigrator_BlacklistModified(_address);\\n        _;\\n    }\\n\\n    /// @notice Initializes the MantleTokenMigrator contract, setting the initial deployer as the contract owner\\n    /// @dev _bitTokenAddress, _mntTokenAddress, _tokenConversionNumerator, and _tokenConversionDenominator are immutable: they can only be set once during construction\\n    /// @dev the contract is initialized in a halted state\\n    /// @dev Requirements:\\n    ///     - all parameters must be non-zero\\n    ///     - _bitTokenAddress and _mntTokenAddress are assumed to have the same number of decimals\\n    /// @param _bitTokenAddress The address of the BIT token contract\\n    /// @param _mntTokenAddress The address of the MNT token contract\\n    /// @param _treasury The address of the treasury contract that receives defunded tokens\\n    constructor(address _bitTokenAddress, address _mntTokenAddress, address _treasury) {\\n        if (_bitTokenAddress == address(0) || _mntTokenAddress == address(0) || _treasury == address(0)) {\\n            revert MantleTokenMigrator_ImproperlyInitialized();\\n        }\\n\\n        owner = msg.sender;\\n        halted = true;\\n\\n        BIT_TOKEN_ADDRESS = _bitTokenAddress;\\n        MNT_TOKEN_ADDRESS = _mntTokenAddress;\\n\\n        treasury = _treasury;\\n    }\\n\\n    /* ========== TOKEN SWAPPING ========== */\\n\\n    /// @notice Allows an approver to approve a user for token migration and performs the migration on their behalf\\n    /// @dev emits a {TokenMigrationApproved} and {TokensMigrated} event\\n    /// @dev Requirements:\\n    ///     - The contract must not be halted\\n    ///     - The caller must have the Approver role\\n    ///     - The address being approved for token migration must not be blacklisted\\n    function approveMigrationRequest(address _addressToMigrate, uint256 _amount)\\n        external\\n        onlyWhenNotHalted\\n        onlyApprover\\n        onlyWhenNotBlacklisted(_addressToMigrate)\\n    {\\n        emit TokenMigrationApproved(msg.sender, _addressToMigrate, _amount);\\n        _migrateTokens(_addressToMigrate, _amount);\\n    }\\n\\n    /// @notice Internal function that swaps a specified amount of the caller's BIT tokens for MNT tokens\\n    /// @dev emits a {TokensMigrated} event\\n    /// @dev Requirements:\\n    ///     - The caller must have approved this contract to spend at least {_amount} of their BIT tokens\\n    ///     - The caller must have a balance of at least {_amount} of BIT tokens\\n    ///     - {_amount} must be non-zero\\n    /// @param _to The address of the user to swap tokens for\\n    /// @param _amount The amount of BIT tokens to swap\\n    function _migrateTokens(address _to, uint256 _amount) internal {\\n        if (_amount == 0) revert MantleTokenMigrator_ZeroSwap();\\n\\n        // transfer user's BIT tokens to this contract\\n        ERC20(BIT_TOKEN_ADDRESS).safeTransferFrom(_to, address(this), _amount);\\n\\n        // transfer MNT tokens to user, if there are insufficient tokens, in the contract this will revert\\n        ERC20(MNT_TOKEN_ADDRESS).safeTransfer(_to, _amount);\\n\\n        emit TokensMigrated(_to, _amount);\\n    }\\n\\n    /* ========== ADMIN UTILS ========== */\\n\\n    // Ownership Functions\\n\\n    /// @notice Transfers ownership of the contract to a new address\\n    /// @dev emits an {OwnershipTransferred} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        owner = _newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, _newOwner);\\n    }\\n\\n    // Role Assignment Functions\\n\\n    /// @notice Gives the Approver role to an address\\n    /// @dev emits an {ApproverRoleAssigned} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    /// @param _approver The address to give the Approver role to\\n    function giveApproverRole(address _approver) public onlyOwner {\\n        approvers[_approver] = true;\\n\\n        emit ApproverRoleAssigned(_approver);\\n    }\\n\\n    /// @notice Revokes the Approver role from an address\\n    /// @dev emits an {ApproverRoleRevoked} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    /// @param _approver The address to revoke the Approver role from\\n    function revokeApproverRole(address _approver) public onlyOwner {\\n        approvers[_approver] = false;\\n\\n        emit ApproverRoleRevoked(_approver);\\n    }\\n\\n    /// @notice Gives the Blacklister role to an address\\n    /// @dev emits an {BlacklisterRoleAssigned} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    /// @param _blacklister The address to give the Blacklister role to\\n    function giveBlacklisterRole(address _blacklister) public onlyOwner {\\n        blacklisters[_blacklister] = true;\\n\\n        emit BlacklisterRoleAssigned(_blacklister);\\n    }\\n\\n    /// @notice Revokes the Blacklister role from an address\\n    /// @dev emits an {BlacklisterRoleRevoked} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    /// @param _blacklister The address to revoke the Blacklist role from\\n    function revokeBlacklisterRole(address _blacklister) public onlyOwner {\\n        blacklisters[_blacklister] = false;\\n\\n        emit BlacklisterRoleRevoked(_blacklister);\\n    }\\n\\n    // Contract State Functions\\n\\n    /// @notice Blacklists an address from token migration\\n    /// @dev emits an {BlacklistModified} event\\n    /// @dev Requirements:\\n    ///     - The caller must have the Blacklister role\\n    /// @param _address The address to blacklist\\n    function blacklistAddress(address _address) public onlyBlacklister {\\n        blacklistedAddresses[_address] = true;\\n\\n        emit BlacklistModified(msg.sender, _address, true);\\n    }\\n\\n    /// @notice Removes an address from the blacklist\\n    /// @dev emits an {BlacklistModified} event\\n    /// @dev Requirements:\\n    ///     - The caller must have the Blacklister role\\n    /// @param _address The address to remove from the blacklist\\n    function removeAddressFromBlacklist(address _address) public onlyBlacklister {\\n        blacklistedAddresses[_address] = false;\\n\\n        emit BlacklistModified(msg.sender, _address, false);\\n    }\\n\\n    /// @notice Halts the contract, preventing token migrations\\n    /// @dev emits a {ContractHalted} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    function haltContract() public onlyOwner {\\n        halted = true;\\n\\n        emit ContractHalted(msg.sender);\\n    }\\n\\n    /// @notice Unhalts the contract, allowing token migrations\\n    /// @dev emits a {ContractUnhalted} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    function unhaltContract() public onlyOwner {\\n        halted = false;\\n\\n        emit ContractUnhalted(msg.sender);\\n    }\\n\\n    /// @notice Sets the treasury address\\n    /// @dev emits a {TreasuryChanged} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    function setTreasury(address _treasury) public onlyOwner {\\n        if (_treasury == address(0)) {\\n            revert MantleTokenMigrator_InvalidTreasury(_treasury);\\n        }\\n\\n        emit TreasuryChanged(treasury, _treasury);\\n\\n        treasury = _treasury;\\n    }\\n\\n    // Token Management Functions\\n\\n    /// @notice Defunds the contract by transferring a specified amount of BIT or MNT tokens to the treasury address\\n    /// @dev emits a {ContractDefunded} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    ///     - {_tokenAddress} must be either the BIT or the MNT token address\\n    ///     - The contract must have a balance of at least {_amount} of {_tokenAddress} tokens\\n    /// @param _tokenAddress The address of the token to defund\\n    /// @param _amount The amount of tokens to defund\\n    function defundContract(address _tokenAddress, uint256 _amount) public onlyOwner {\\n        if (_tokenAddress != BIT_TOKEN_ADDRESS && _tokenAddress != MNT_TOKEN_ADDRESS) {\\n            revert MantleTokenMigrator_InvalidFundingToken(_tokenAddress);\\n        }\\n\\n        // we can only defund BIT or MNT into the predefined treasury address\\n        ERC20(_tokenAddress).safeTransfer(treasury, _amount);\\n\\n        emit ContractDefunded(treasury, _tokenAddress, _amount);\\n    }\\n\\n    /// @notice Sweeps a specified amount of tokens to an arbitrary address in case of accidental token transfers\\n    /// @dev emits a {TokensSwept} event\\n    /// @dev Requirements:\\n    ///     - The caller must be the contract owner\\n    ///     - {_tokenAddress} must not the BIT or the MNT token address\\n    ///     - The contract must have a balance of at least {_amount} of {_tokenAddress} tokens\\n    /// @param _tokenAddress The address of the token to sweep\\n    /// @param _recipient The address to sweep the tokens to\\n    /// @param _amount The amount of tokens to sweep\\n    function sweepTokens(address _tokenAddress, address _recipient, uint256 _amount) public onlyOwner {\\n        // we can only sweep tokens that are not BIT or MNT to an arbitrary addres\\n        if ((_tokenAddress == BIT_TOKEN_ADDRESS) || (_tokenAddress == MNT_TOKEN_ADDRESS)) {\\n            revert MantleTokenMigrator_SweepNotAllowed(_tokenAddress);\\n        }\\n        ERC20(_tokenAddress).safeTransfer(_recipient, _amount);\\n\\n        emit TokensSwept(_tokenAddress, _recipient, _amount);\\n    }\\n}\"\r\n    },\r\n    \"solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bitTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mntTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenMigrator\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_BlacklistModified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MantleTokenMigrator_ImproperlyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_InvalidFundingToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_InvalidTreasury\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_OnlyApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_OnlyBlacklister\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MantleTokenMigrator_OnlyWhenNotHalted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MantleTokenMigrator_SweepNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MantleTokenMigrator_ZeroSwap\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklistedAddress\",\"type\":\"address\"}],\"name\":\"AddressRemovedFromBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ApproverRoleAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ApproverRoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklistedAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"blacklistStatus\",\"type\":\"bool\"}],\"name\":\"BlacklistModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterRoleAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterRoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"defunder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContractDefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"halter\",\"type\":\"address\"}],\"name\":\"ContractHalted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"halter\",\"type\":\"address\"}],\"name\":\"ContractUnhalted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenMigrationApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSwapped\",\"type\":\"uint256\"}],\"name\":\"TokensMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensSwept\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTreasury\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BIT_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MNT_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressToMigrate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveMigrationRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklistedAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklisters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"defundContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"}],\"name\":\"giveApproverRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blacklister\",\"type\":\"address\"}],\"name\":\"giveBlacklisterRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"haltContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAddressFromBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"}],\"name\":\"revokeApproverRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blacklister\",\"type\":\"address\"}],\"name\":\"revokeBlacklisterRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sweepTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unhaltContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MantleTokenMigratorV2", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001a4b46696b2bb4794eb3d4c26f1c55f9170fa4c50000000000000000000000003c3a81e81dc49a522a592e7622a7e711c06bf3540000000000000000000000009deaa906829d8cf05ff1f24663ad553cb90bf241", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}