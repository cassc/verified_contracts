{"SourceCode": "// File: solady/tokens/ERC1155.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Modern and gas efficient ERC1155 implementation.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)\r\nabstract contract ERC1155 {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The lengths of the input arrays are not the same.\r\n    error ArrayLengthsMismatch();\r\n\r\n    /// @dev Cannot mint or transfer to the zero address.\r\n    error TransferToZeroAddress();\r\n\r\n    /// @dev The recipient's balance has overflowed.\r\n    error AccountBalanceOverflow();\r\n\r\n    /// @dev Insufficient balance.\r\n    error InsufficientBalance();\r\n\r\n    /// @dev Only the token owner or an approved account can manage the tokens.\r\n    error NotOwnerNorApproved();\r\n\r\n    /// @dev Cannot safely transfer to a contract that does not implement\r\n    /// the ERC1155Receiver interface.\r\n    error TransferToNonERC1155ReceiverImplementer();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Emitted when `amount` of token `id` is transferred\r\n    /// from `from` to `to` by `operator`.\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 amount\r\n    );\r\n\r\n    /// @dev Emitted when `amounts` of token `ids` are transferred\r\n    /// from `from` to `to` by `operator`.\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] amounts\r\n    );\r\n\r\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\r\n\r\n    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`\r\n    /// is updated to `value`. This event is not used in the base contract.\r\n    /// You may need to emit this event depending on your URI logic.\r\n    ///\r\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /// @dev `keccak256(bytes(\"TransferSingle(address,address,address,uint256,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =\r\n        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;\r\n\r\n    /// @dev `keccak256(bytes(\"TransferBatch(address,address,address,uint256[],uint256[])\"))`.\r\n    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =\r\n        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;\r\n\r\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\r\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\r\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\r\n    /// ```\r\n    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))\r\n    /// ```\r\n    ///\r\n    /// The balance slot of `owner` is given by.\r\n    /// ```\r\n    ///     mstore(0x20, ownerSlotSeed)\r\n    ///     mstore(0x00, id)\r\n    ///     let balanceSlot := keccak256(0x00, 0x40)\r\n    /// ```\r\n    ///\r\n    /// The operator approval slot of `owner` is given by.\r\n    /// ```\r\n    ///     mstore(0x20, ownerSlotSeed)\r\n    ///     mstore(0x00, operator)\r\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\r\n    /// ```\r\n    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      ERC1155 METADATA                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the URI for token `id`.\r\n    ///\r\n    /// Can either return the same templated URI for all token IDs,\r\n    /// or substitute the `id` on the contract side.\r\n    ///\r\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\r\n    function uri(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          ERC1155                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the amount of `id` owned by `owner`.\r\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\r\n            mstore(0x00, id)\r\n            result := sload(keccak256(0x00, 0x40))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\r\n            mstore(0x00, operator)\r\n            result := sload(keccak256(0x0c, 0x34))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\r\n    ///\r\n    /// Emits a {ApprovalForAll} event.\r\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            operator := shr(96, shl(96, operator))\r\n            // Convert to 0 or 1.\r\n            isApproved := iszero(iszero(isApproved))\r\n            // Update the `isApproved` for (`msg.sender`, `operator`).\r\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, caller())))\r\n            mstore(0x00, operator)\r\n            sstore(keccak256(0x0c, 0x34), isApproved)\r\n            // Emit the {ApprovalForAll} event.\r\n            mstore(0x00, isApproved)\r\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `to` cannot be the zero address.\r\n    /// - `from` must have at least `amount` of `id`.\r\n    /// - If the caller is not `from`,\r\n    ///   it must be approved to manage the tokens of `from`.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\r\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\r\n            mstore(0x20, fromSlotSeed)\r\n            // Clear the upper 96 bits.\r\n            from := shr(96, fromSlotSeed)\r\n            to := shr(96, toSlotSeed)\r\n            // If the caller is not `from`, do the authorization check.\r\n            if iszero(eq(caller(), from)) {\r\n                mstore(0x00, caller())\r\n                if iszero(sload(keccak256(0x0c, 0x34))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance of `from`.\r\n            {\r\n                mstore(0x00, id)\r\n                let fromBalanceSlot := keccak256(0x00, 0x40)\r\n                let fromBalance := sload(fromBalanceSlot)\r\n                if gt(amount, fromBalance) {\r\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            }\r\n            // Increase and store the updated balance of `to`.\r\n            {\r\n                mstore(0x20, toSlotSeed)\r\n                let toBalanceSlot := keccak256(0x00, 0x40)\r\n                let toBalanceBefore := sload(toBalanceSlot)\r\n                let toBalanceAfter := add(toBalanceBefore, amount)\r\n                if lt(toBalanceAfter, toBalanceBefore) {\r\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(toBalanceSlot, toBalanceAfter)\r\n            }\r\n            // Emit a {TransferSingle} event.\r\n            {\r\n                mstore(0x20, amount)\r\n                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\r\n            }\r\n        }\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Do the {onERC1155Received} check if `to` is a smart contract.\r\n            if extcodesize(to) {\r\n                // Prepare the calldata.\r\n                let m := mload(0x40)\r\n                let onERC1155ReceivedSelector := 0xf23a6e61\r\n                mstore(m, onERC1155ReceivedSelector)\r\n                mstore(add(m, 0x20), caller())\r\n                mstore(add(m, 0x40), from)\r\n                mstore(add(m, 0x60), id)\r\n                mstore(add(m, 0x80), amount)\r\n                mstore(add(m, 0xa0), 0xa0)\r\n                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))\r\n                // Revert if the call reverts.\r\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\r\n                    if returndatasize() {\r\n                        // Bubble up the revert if the delegatecall reverts.\r\n                        returndatacopy(0x00, 0x00, returndatasize())\r\n                        revert(0x00, returndatasize())\r\n                    }\r\n                    mstore(m, 0)\r\n                }\r\n                // Load the returndata and compare it.\r\n                if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {\r\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `to` cannot be the zero address.\r\n    /// - `from` must have at least `amount` of `id`.\r\n    /// - `ids` and `amounts` must have the same length.\r\n    /// - If the caller is not `from`,\r\n    ///   it must be approved to manage the tokens of `from`.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\r\n    ///\r\n    /// Emits a {TransferBatch} event.\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(from, to, ids, amounts, data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(eq(ids.length, amounts.length)) {\r\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\r\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\r\n            mstore(0x20, fromSlotSeed)\r\n            // Clear the upper 96 bits.\r\n            from := shr(96, fromSlotSeed)\r\n            to := shr(96, toSlotSeed)\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // If the caller is not `from`, do the authorization check.\r\n            if iszero(eq(caller(), from)) {\r\n                mstore(0x00, caller())\r\n                if iszero(sload(keccak256(0x0c, 0x34))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Loop through all the `ids` and update the balances.\r\n            {\r\n                let end := shl(5, ids.length)\r\n                for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {\r\n                    let amount := calldataload(add(amounts.offset, i))\r\n                    // Subtract and store the updated balance of `from`.\r\n                    {\r\n                        mstore(0x20, fromSlotSeed)\r\n                        mstore(0x00, calldataload(add(ids.offset, i)))\r\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\r\n                        let fromBalance := sload(fromBalanceSlot)\r\n                        if gt(amount, fromBalance) {\r\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                            revert(0x1c, 0x04)\r\n                        }\r\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n                    }\r\n                    // Increase and store the updated balance of `to`.\r\n                    {\r\n                        mstore(0x20, toSlotSeed)\r\n                        let toBalanceSlot := keccak256(0x00, 0x40)\r\n                        let toBalanceBefore := sload(toBalanceSlot)\r\n                        let toBalanceAfter := add(toBalanceBefore, amount)\r\n                        if lt(toBalanceAfter, toBalanceBefore) {\r\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                            revert(0x1c, 0x04)\r\n                        }\r\n                        sstore(toBalanceSlot, toBalanceAfter)\r\n                    }\r\n                }\r\n            }\r\n            // Emit a {TransferBatch} event.\r\n            {\r\n                let m := mload(0x40)\r\n                // Copy the `ids`.\r\n                mstore(m, 0x40)\r\n                let n := add(0x20, shl(5, ids.length))\r\n                let o := add(m, 0x40)\r\n                calldatacopy(o, sub(ids.offset, 0x20), n)\r\n                // Copy the `amounts`.\r\n                mstore(add(m, 0x20), add(0x40, n))\r\n                o := add(o, n)\r\n                n := add(0x20, shl(5, amounts.length))\r\n                calldatacopy(o, sub(amounts.offset, 0x20), n)\r\n                n := sub(add(o, n), m)\r\n                // Do the emit.\r\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\r\n            }\r\n        }\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\r\n            if extcodesize(to) {\r\n                let m := mload(0x40)\r\n                // Prepare the calldata.\r\n                let onERC1155BatchReceivedSelector := 0xbc197c81\r\n                mstore(m, onERC1155BatchReceivedSelector)\r\n                mstore(add(m, 0x20), caller())\r\n                mstore(add(m, 0x40), from)\r\n                // Copy the `ids`.\r\n                mstore(add(m, 0x60), 0xa0)\r\n                let n := add(0x20, shl(5, ids.length))\r\n                let o := add(m, 0xc0)\r\n                calldatacopy(o, sub(ids.offset, 0x20), n)\r\n                // Copy the `amounts`.\r\n                let s := add(0xa0, n)\r\n                mstore(add(m, 0x80), s)\r\n                o := add(o, n)\r\n                n := add(0x20, shl(5, amounts.length))\r\n                calldatacopy(o, sub(amounts.offset, 0x20), n)\r\n                // Copy the `data`.\r\n                mstore(add(m, 0xa0), add(s, n))\r\n                o := add(o, n)\r\n                n := add(0x20, data.length)\r\n                calldatacopy(o, sub(data.offset, 0x20), n)\r\n                n := sub(add(o, n), add(m, 0x1c))\r\n                // Revert if the call reverts.\r\n                if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\r\n                    if returndatasize() {\r\n                        // Bubble up the revert if the delegatecall reverts.\r\n                        returndatacopy(0x00, 0x00, returndatasize())\r\n                        revert(0x00, returndatasize())\r\n                    }\r\n                    mstore(m, 0)\r\n                }\r\n                // Load the returndata and compare it.\r\n                if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {\r\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amounts of `ids` for `owners.\r\n    ///\r\n    /// Requirements:\r\n    /// - `owners` and `ids` must have the same length.\r\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory balances)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(eq(ids.length, owners.length)) {\r\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            balances := mload(0x40)\r\n            mstore(balances, ids.length)\r\n            let o := add(balances, 0x20)\r\n            let end := shl(5, ids.length)\r\n            mstore(0x40, add(end, o))\r\n            // Loop through all the `ids` and load the balances.\r\n            for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {\r\n                let owner := calldataload(add(owners.offset, i))\r\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\r\n                mstore(0x00, calldataload(add(ids.offset, i)))\r\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n    /// See: https://eips.ethereum.org/EIPS/eip-165\r\n    /// This function call must use less than 30000 gas.\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let s := shr(224, interfaceId)\r\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\r\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Mints `amount` of `id` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `to` cannot be the zero address.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\r\n            // Clear the upper 96 bits.\r\n            to := shr(96, toSlotSeed)\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Increase and store the updated balance of `to`.\r\n            {\r\n                mstore(0x20, toSlotSeed)\r\n                mstore(0x00, id)\r\n                let toBalanceSlot := keccak256(0x00, 0x40)\r\n                let toBalanceBefore := sload(toBalanceSlot)\r\n                let toBalanceAfter := add(toBalanceBefore, amount)\r\n                if lt(toBalanceAfter, toBalanceBefore) {\r\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(toBalanceSlot, toBalanceAfter)\r\n            }\r\n            // Emit a {TransferSingle} event.\r\n            {\r\n                mstore(0x00, id)\r\n                mstore(0x20, amount)\r\n                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, to)\r\n            }\r\n        }\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\r\n        }\r\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\r\n    }\r\n\r\n    /// @dev Mints `amounts` of `ids` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `to` cannot be the zero address.\r\n    /// - `ids` and `amounts` must have the same length.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\r\n    ///\r\n    /// Emits a {TransferBatch} event.\r\n    function _batchMint(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(eq(mload(ids), mload(amounts))) {\r\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\r\n            // Clear the upper 96 bits.\r\n            to := shr(96, toSlotSeed)\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Loop through all the `ids` and update the balances.\r\n            {\r\n                let end := shl(5, mload(ids))\r\n                for { let i := 0 } iszero(eq(i, end)) {} {\r\n                    i := add(i, 0x20)\r\n                    let amount := mload(add(amounts, i))\r\n                    // Increase and store the updated balance of `to`.\r\n                    {\r\n                        mstore(0x20, toSlotSeed)\r\n                        mstore(0x00, mload(add(ids, i)))\r\n                        let toBalanceSlot := keccak256(0x00, 0x40)\r\n                        let toBalanceBefore := sload(toBalanceSlot)\r\n                        let toBalanceAfter := add(toBalanceBefore, amount)\r\n                        if lt(toBalanceAfter, toBalanceBefore) {\r\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                            revert(0x1c, 0x04)\r\n                        }\r\n                        sstore(toBalanceSlot, toBalanceAfter)\r\n                    }\r\n                }\r\n            }\r\n            // Emit a {TransferBatch} event.\r\n            {\r\n                let m := mload(0x40)\r\n                // Copy the `ids`.\r\n                mstore(m, 0x40)\r\n                let n := add(0x20, shl(5, mload(ids)))\r\n                let o := add(m, 0x40)\r\n                pop(staticcall(gas(), 4, ids, n, o, n))\r\n                // Copy the `amounts`.\r\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\r\n                o := add(o, returndatasize())\r\n                n := add(0x20, shl(5, mload(amounts)))\r\n                pop(staticcall(gas(), 4, amounts, n, o, n))\r\n                n := sub(add(o, returndatasize()), m)\r\n                // Do the emit.\r\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, to)\r\n            }\r\n        }\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\r\n        }\r\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.\r\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\r\n        _burn(address(0), from, id, amount);\r\n    }\r\n\r\n    /// @dev Destroys `amount` of `id` from `from`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must have at least `amount` of `id`.\r\n    /// - If `by` is not the zero address, it must be either `from`,\r\n    ///   or approved to manage the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\r\n            mstore(0x20, fromSlotSeed)\r\n            // Clear the upper 96 bits.\r\n            from := shr(96, fromSlotSeed)\r\n            by := shr(96, shl(96, by))\r\n            // If `by` is not the zero address, and not equal to `from`,\r\n            // check if it is approved to manage all the tokens of `from`.\r\n            if iszero(or(iszero(by), eq(by, from))) {\r\n                mstore(0x00, by)\r\n                if iszero(sload(keccak256(0x0c, 0x34))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Decrease and store the updated balance of `from`.\r\n            {\r\n                mstore(0x00, id)\r\n                let fromBalanceSlot := keccak256(0x00, 0x40)\r\n                let fromBalance := sload(fromBalanceSlot)\r\n                if gt(amount, fromBalance) {\r\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            }\r\n            // Emit a {TransferSingle} event.\r\n            {\r\n                mstore(0x00, id)\r\n                mstore(0x20, amount)\r\n                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, 0)\r\n            }\r\n        }\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.\r\n    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\r\n        internal\r\n        virtual\r\n    {\r\n        _batchBurn(address(0), from, ids, amounts);\r\n    }\r\n\r\n    /// @dev Destroys `amounts` of `ids` from `from`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `ids` and `amounts` must have the same length.\r\n    /// - `from` must have at least `amounts` of `ids`.\r\n    /// - If `by` is not the zero address, it must be either `from`,\r\n    ///   or approved to manage the tokens of `from`.\r\n    ///\r\n    /// Emits a {TransferBatch} event.\r\n    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\r\n        internal\r\n        virtual\r\n    {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(eq(mload(ids), mload(amounts))) {\r\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\r\n            mstore(0x20, fromSlotSeed)\r\n            // Clear the upper 96 bits.\r\n            from := shr(96, fromSlotSeed)\r\n            by := shr(96, shl(96, by))\r\n            // If `by` is not the zero address, and not equal to `from`,\r\n            // check if it is approved to manage all the tokens of `from`.\r\n            if iszero(or(iszero(by), eq(by, from))) {\r\n                mstore(0x00, by)\r\n                if iszero(sload(keccak256(0x0c, 0x34))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Loop through all the `ids` and update the balances.\r\n            {\r\n                let end := shl(5, mload(ids))\r\n                for { let i := 0 } iszero(eq(i, end)) {} {\r\n                    i := add(i, 0x20)\r\n                    let amount := mload(add(amounts, i))\r\n                    // Increase and store the updated balance of `to`.\r\n                    {\r\n                        mstore(0x00, mload(add(ids, i)))\r\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\r\n                        let fromBalance := sload(fromBalanceSlot)\r\n                        if gt(amount, fromBalance) {\r\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                            revert(0x1c, 0x04)\r\n                        }\r\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n                    }\r\n                }\r\n            }\r\n            // Emit a {TransferBatch} event.\r\n            {\r\n                let m := mload(0x40)\r\n                // Copy the `ids`.\r\n                mstore(m, 0x40)\r\n                let n := add(0x20, shl(5, mload(ids)))\r\n                let o := add(m, 0x40)\r\n                pop(staticcall(gas(), 4, ids, n, o, n))\r\n                // Copy the `amounts`.\r\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\r\n                o := add(o, returndatasize())\r\n                n := add(0x20, shl(5, mload(amounts)))\r\n                pop(staticcall(gas(), 4, amounts, n, o, n))\r\n                n := sub(add(o, returndatasize()), m)\r\n                // Do the emit.\r\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, 0)\r\n            }\r\n        }\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Approve or remove the `operator` as an operator for `by`,\r\n    /// without authorization checks.\r\n    ///\r\n    /// Emits a {ApprovalForAll} event.\r\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            operator := shr(96, shl(96, operator))\r\n            // Convert to 0 or 1.\r\n            isApproved := iszero(iszero(isApproved))\r\n            // Update the `isApproved` for (`by`, `operator`).\r\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, by)))\r\n            mstore(0x00, operator)\r\n            sstore(keccak256(0x0c, 0x34), isApproved)\r\n            // Emit the {ApprovalForAll} event.\r\n            mstore(0x00, isApproved)\r\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.\r\n    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\r\n        internal\r\n        virtual\r\n    {\r\n        _safeTransfer(address(0), from, to, id, amount, data);\r\n    }\r\n\r\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `to` cannot be the zero address.\r\n    /// - `from` must have at least `amount` of `id`.\r\n    /// - If `by` is not the zero address, it must be either `from`,\r\n    ///   or approved to manage the tokens of `from`.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _safeTransfer(\r\n        address by,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\r\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\r\n            mstore(0x20, fromSlotSeed)\r\n            // Clear the upper 96 bits.\r\n            from := shr(96, fromSlotSeed)\r\n            to := shr(96, toSlotSeed)\r\n            by := shr(96, shl(96, by))\r\n            // If `by` is not the zero address, and not equal to `from`,\r\n            // check if it is approved to manage all the tokens of `from`.\r\n            if iszero(or(iszero(by), eq(by, from))) {\r\n                mstore(0x00, by)\r\n                if iszero(sload(keccak256(0x0c, 0x34))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance of `from`.\r\n            {\r\n                mstore(0x00, id)\r\n                let fromBalanceSlot := keccak256(0x00, 0x40)\r\n                let fromBalance := sload(fromBalanceSlot)\r\n                if gt(amount, fromBalance) {\r\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            }\r\n            // Increase and store the updated balance of `to`.\r\n            {\r\n                mstore(0x20, toSlotSeed)\r\n                let toBalanceSlot := keccak256(0x00, 0x40)\r\n                let toBalanceBefore := sload(toBalanceSlot)\r\n                let toBalanceAfter := add(toBalanceBefore, amount)\r\n                if lt(toBalanceAfter, toBalanceBefore) {\r\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(toBalanceSlot, toBalanceAfter)\r\n            }\r\n            // Emit a {TransferSingle} event.\r\n            {\r\n                mstore(0x20, amount)\r\n                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\r\n            }\r\n        }\r\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.\r\n    function _safeBatchTransfer(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\r\n    }\r\n\r\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `to` cannot be the zero address.\r\n    /// - `ids` and `amounts` must have the same length.\r\n    /// - `from` must have at least `amounts` of `ids`.\r\n    /// - If `by` is not the zero address, it must be either `from`,\r\n    ///   or approved to manage the tokens of `from`.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\r\n    ///\r\n    /// Emits a {TransferBatch} event.\r\n    function _safeBatchTransfer(\r\n        address by,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        if (_useBeforeTokenTransfer()) {\r\n            _beforeTokenTransfer(from, to, ids, amounts, data);\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(eq(mload(ids), mload(amounts))) {\r\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\r\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\r\n            mstore(0x20, fromSlotSeed)\r\n            // Clear the upper 96 bits.\r\n            from := shr(96, fromSlotSeed)\r\n            to := shr(96, toSlotSeed)\r\n            by := shr(96, shl(96, by))\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // If `by` is not the zero address, and not equal to `from`,\r\n            // check if it is approved to manage all the tokens of `from`.\r\n            if iszero(or(iszero(by), eq(by, from))) {\r\n                mstore(0x00, by)\r\n                if iszero(sload(keccak256(0x0c, 0x34))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Loop through all the `ids` and update the balances.\r\n            {\r\n                let end := shl(5, mload(ids))\r\n                for { let i := 0 } iszero(eq(i, end)) {} {\r\n                    i := add(i, 0x20)\r\n                    let amount := mload(add(amounts, i))\r\n                    // Subtract and store the updated balance of `from`.\r\n                    {\r\n                        mstore(0x20, fromSlotSeed)\r\n                        mstore(0x00, mload(add(ids, i)))\r\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\r\n                        let fromBalance := sload(fromBalanceSlot)\r\n                        if gt(amount, fromBalance) {\r\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                            revert(0x1c, 0x04)\r\n                        }\r\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n                    }\r\n                    // Increase and store the updated balance of `to`.\r\n                    {\r\n                        mstore(0x20, toSlotSeed)\r\n                        let toBalanceSlot := keccak256(0x00, 0x40)\r\n                        let toBalanceBefore := sload(toBalanceSlot)\r\n                        let toBalanceAfter := add(toBalanceBefore, amount)\r\n                        if lt(toBalanceAfter, toBalanceBefore) {\r\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                            revert(0x1c, 0x04)\r\n                        }\r\n                        sstore(toBalanceSlot, toBalanceAfter)\r\n                    }\r\n                }\r\n            }\r\n            // Emit a {TransferBatch} event.\r\n            {\r\n                let m := mload(0x40)\r\n                // Copy the `ids`.\r\n                mstore(m, 0x40)\r\n                let n := add(0x20, shl(5, mload(ids)))\r\n                let o := add(m, 0x40)\r\n                pop(staticcall(gas(), 4, ids, n, o, n))\r\n                // Copy the `amounts`.\r\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\r\n                o := add(o, returndatasize())\r\n                n := add(0x20, shl(5, mload(amounts)))\r\n                pop(staticcall(gas(), 4, amounts, n, o, n))\r\n                n := sub(add(o, returndatasize()), m)\r\n                // Do the emit.\r\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\r\n            }\r\n        }\r\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(from, to, ids, amounts, data);\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                    HOOKS FOR OVERRIDING                    */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.\r\n    /// The is to help the compiler avoid producing dead bytecode.\r\n    function _useBeforeTokenTransfer() internal view virtual returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @dev Hook that is called before any token transfer.\r\n    /// This includes minting and burning, as well as batched variants.\r\n    ///\r\n    /// The same hook is called on both single and batched variants.\r\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    /// @dev Override this function to return true if `_afterTokenTransfer` is used.\r\n    /// The is to help the compiler avoid producing dead bytecode.\r\n    function _useAfterTokenTransfer() internal view virtual returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @dev Hook that is called after any token transfer.\r\n    /// This includes minting and burning, as well as batched variants.\r\n    ///\r\n    /// The same hook is called on both single and batched variants.\r\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      PRIVATE HELPERS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Helper for calling the `_afterTokenTransfer` hook.\r\n    /// The is to help the compiler avoid producing dead bytecode.\r\n    function _afterTokenTransferCalldata(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) private {\r\n        if (_useAfterTokenTransfer()) {\r\n            _afterTokenTransfer(from, to, ids, amounts, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if `a` has bytecode of non-zero length.\r\n    function _hasCode(address a) private view returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := extcodesize(a) // Can handle dirty upper bits.\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.\r\n    /// Reverts if the target does not support the function correctly.\r\n    function _checkOnERC1155Received(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Prepare the calldata.\r\n            let m := mload(0x40)\r\n            let onERC1155ReceivedSelector := 0xf23a6e61\r\n            mstore(m, onERC1155ReceivedSelector)\r\n            mstore(add(m, 0x20), caller())\r\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\r\n            mstore(add(m, 0x60), id)\r\n            mstore(add(m, 0x80), amount)\r\n            mstore(add(m, 0xa0), 0xa0)\r\n            let n := mload(data)\r\n            mstore(add(m, 0xc0), n)\r\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }\r\n            // Revert if the call reverts.\r\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\r\n                if returndatasize() {\r\n                    // Bubble up the revert if the delegatecall reverts.\r\n                    returndatacopy(0x00, 0x00, returndatasize())\r\n                    revert(0x00, returndatasize())\r\n                }\r\n                mstore(m, 0)\r\n            }\r\n            // Load the returndata and compare it.\r\n            if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {\r\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.\r\n    /// Reverts if the target does not support the function correctly.\r\n    function _checkOnERC1155BatchReceived(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Prepare the calldata.\r\n            let m := mload(0x40)\r\n            let onERC1155BatchReceivedSelector := 0xbc197c81\r\n            mstore(m, onERC1155BatchReceivedSelector)\r\n            mstore(add(m, 0x20), caller())\r\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\r\n            // Copy the `ids`.\r\n            mstore(add(m, 0x60), 0xa0)\r\n            let n := add(0x20, shl(5, mload(ids)))\r\n            let o := add(m, 0xc0)\r\n            pop(staticcall(gas(), 4, ids, n, o, n))\r\n            // Copy the `amounts`.\r\n            let s := add(0xa0, returndatasize())\r\n            mstore(add(m, 0x80), s)\r\n            o := add(o, returndatasize())\r\n            n := add(0x20, shl(5, mload(amounts)))\r\n            pop(staticcall(gas(), 4, amounts, n, o, n))\r\n            // Copy the `data`.\r\n            mstore(add(m, 0xa0), add(s, returndatasize()))\r\n            o := add(o, returndatasize())\r\n            n := add(0x20, mload(data))\r\n            pop(staticcall(gas(), 4, data, n, o, n))\r\n            n := sub(add(o, returndatasize()), add(m, 0x1c))\r\n            // Revert if the call reverts.\r\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\r\n                if returndatasize() {\r\n                    // Bubble up the revert if the delegatecall reverts.\r\n                    returndatacopy(0x00, 0x00, returndatasize())\r\n                    revert(0x00, returndatasize())\r\n                }\r\n                mstore(m, 0)\r\n            }\r\n            // Load the returndata and compare it.\r\n            if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {\r\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x` in an array with a single element.\r\n    function _single(uint256 x) private pure returns (uint256[] memory result) {\r\n        assembly {\r\n            result := mload(0x40)\r\n            mstore(0x40, add(result, 0x40))\r\n            mstore(result, 1)\r\n            mstore(add(result, 0x20), x)\r\n        }\r\n    }\r\n}\r\n\r\n// File: solady/auth/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\r\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\r\n/// for compatibility, the nomenclature for the 2-step ownership handover\r\n/// may be unique to this codebase.\r\nabstract contract Ownable {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The caller is not authorized to call the function.\r\n    error Unauthorized();\r\n\r\n    /// @dev The `newOwner` cannot be the zero address.\r\n    error NewOwnerIsZeroAddress();\r\n\r\n    /// @dev The `pendingOwner` does not have a valid handover request.\r\n    error NoHandoverRequest();\r\n\r\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\r\n    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\r\n\r\n    /// @dev `bytes4(keccak256(bytes(\"NewOwnerIsZeroAddress()\")))`.\r\n    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;\r\n\r\n    /// @dev `bytes4(keccak256(bytes(\"NoHandoverRequest()\")))`.\r\n    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\r\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\r\n    /// despite it not being as lightweight as a single argument event.\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @dev An ownership handover to `pendingOwner` has been requested.\r\n    event OwnershipHandoverRequested(address indexed pendingOwner);\r\n\r\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\r\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\r\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\r\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\r\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\r\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\r\n    /// It is intentionally choosen to be a high value\r\n    /// to avoid collision with lower slots.\r\n    /// The choice of manual storage layout is to enable compatibility\r\n    /// with both regular and upgradeable contracts.\r\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\r\n\r\n    /// The ownership handover slot of `newOwner` is given by:\r\n    /// ```\r\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\r\n    ///     let handoverSlot := keccak256(0x00, 0x20)\r\n    /// ```\r\n    /// It stores the expiry timestamp of the two-step ownership handover.\r\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     INTERNAL FUNCTIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Initializes the owner directly without authorization guard.\r\n    /// This function must be called upon initialization,\r\n    /// regardless of whether the contract is upgradeable or not.\r\n    /// This is to enable generalization to both regular and upgradeable contracts,\r\n    /// and to save gas in case the initial owner is not the caller.\r\n    /// For performance reasons, this function will not check if there\r\n    /// is an existing owner.\r\n    function _initializeOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Store the new value.\r\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner directly without authorization guard.\r\n    function _setOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ownerSlot := not(_OWNER_SLOT_NOT)\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n            // Store the new value.\r\n            sstore(ownerSlot, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Throws if the sender is not the owner.\r\n    function _checkOwner() internal view virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If the caller is not the stored owner, revert.\r\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\r\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\r\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\r\n        if (newOwner == address(0)) revert NewOwnerIsZeroAddress();\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows the owner to renounce their ownership.\r\n    function renounceOwnership() public payable virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /// @dev Request a two-step ownership handover to the caller.\r\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\r\n    function requestOwnershipHandover() public payable virtual {\r\n        unchecked {\r\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Compute and set the handover slot to 1.\r\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n                mstore(0x00, caller())\r\n                sstore(keccak256(0x0c, 0x20), expires)\r\n                // Emit the {OwnershipHandoverRequested} event.\r\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\r\n    function cancelOwnershipHandover() public payable virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x20), 0)\r\n            // Emit the {OwnershipHandoverCanceled} event.\r\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\r\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\r\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            let handoverSlot := keccak256(0x0c, 0x20)\r\n            // If the handover does not exist, or has expired.\r\n            if gt(timestamp(), sload(handoverSlot)) {\r\n                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Set the handover slot to 0.\r\n            sstore(handoverSlot, 0)\r\n            // Clean the upper 96 bits.\r\n            let newOwner := shr(96, mload(0x0c))\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)\r\n            // Store the new value.\r\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   PUBLIC READ FUNCTIONS                    */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() public view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(not(_OWNER_SLOT_NOT))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\r\n    function ownershipHandoverExpiresAt(address pendingOwner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the handover slot.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            // Load the handover slot.\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\r\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\r\n        return 48 * 3600;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         MODIFIERS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Marks a function as only callable by the owner.\r\n    modifier onlyOwner() virtual {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n}\r\n\r\n// File: miladycola/cap6.sol\r\n\r\n//SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\ncontract MiladyColaCapsV2 is ERC1155, Ownable {\r\n\r\n    error AdminOnlyMint();\r\n\r\n    string public name = \"MiladyCola Caps V2\";\r\n    string public symbol = \"MCC2\";\r\n    string public _uri;\r\n    uint256 public count = 485;\r\n    address[3] public admin;\r\n\r\n    constructor() {      \r\n        _initializeOwner(msg.sender); \r\n    }\r\n\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    function setURI(string memory newuri) external onlyOwner {\r\n        _uri = newuri;\r\n    }\r\n\r\n    function setAdmin(address newAdmin, uint256 index) public onlyOwner {\r\n        admin[index] = newAdmin;\r\n    }\r\n\r\n    function mintLCaps(uint256 numberOfTokens, address player) public payable adminOnly {\r\n        uint256 _count = count;\r\n        for(uint256 i=0; i < numberOfTokens;){\r\n            _mint(player,_count,1,\"\");\r\n            unchecked {\r\n                ++_count;\r\n                ++i;\r\n            }\r\n        }\r\n        count = _count;\r\n    }\r\n    \r\n    function mintWCap(address player) public payable adminOnly {\r\n        _mint(player, 349, 1, \"\");\r\n    }\r\n\r\n    modifier adminOnly() virtual {\r\n        if(msg.sender!=admin[0] && msg.sender!=admin[1] && msg.sender!=admin[2]){revert AdminOnlyMint();}\r\n        _;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountBalanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminOnlyMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArrayLengthsMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC1155ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"mintLCaps\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"mintWCap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipHandoverValidFor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newuri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MiladyColaCapsV2", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a7adbd58931ee773956568080d46051f41aed5b65b549e2710a81cfed6c407bf"}