{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: NEW-DEX/pbmc-eth.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address dst, uint256 wad) external returns (bool);\r\n\r\n    function balanceOf(address to) external view returns (uint256);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n}\r\n\r\ncontract EthPBMCPool is Ownable{\r\n    uint256 public totalLiquidity;\r\n    IERC20 public PBMC;\r\n    address public WETH;\r\n    using SafeMath for uint256;\r\n\r\n//EVENTS\r\n  event LiquidityAdded(\r\n    address indexed provider,\r\n    uint256 amountPBMC,\r\n    uint256 amountETH\r\n);\r\n\r\nevent LiquidityRemoved(\r\n    address indexed provider,\r\n    uint256 amountPBMC,\r\n    uint256 amountUSDT,\r\n    uint256 liquidity\r\n);\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n    mapping(address => uint256) public userToMint;\r\n\r\n    constructor() {}\r\n\r\n    function setAddress(address _pbmc, address _WETH) external onlyOwner {\r\n        PBMC = IERC20(_pbmc);\r\n        WETH = _WETH;\r\n    }\r\n\r\n    bytes4 private constant SELECTOR =\r\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n    uint256 public reserveA;\r\n    uint256 public reserveB;\r\n\r\n    function safeTransferFrom(\r\n        // address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = address(PBMC).call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"safeTransferETH: ETH transfer failed\");\r\n    }\r\n\r\n    function safeTransfer(address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = address(PBMC).call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n    function addLiquidityETH(uint256 pbmcAmount, address to) external payable {\r\n        uint256 amountToken;\r\n        uint256 amountETH;\r\n\r\n        (amountToken, amountETH) = _addLiquidity(pbmcAmount, msg.value);\r\n\r\n        safeTransferFrom(msg.sender, address(this), amountToken);\r\n\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        IWETH(WETH).transfer(address(this), amountETH);\r\n\r\n        mint(to);\r\n\r\n        reserveA = PBMC.balanceOf(address(this));\r\n        reserveB = IWETH(WETH).balanceOf(address(this));\r\n\r\n        // Refund excess ETH, if any\r\n        if (msg.value > amountETH) {\r\n            // safeTransferETH(to, msg.value - amountETH);\r\n            payable(msg.sender).transfer(msg.value - amountETH);\r\n             emit LiquidityAdded(\r\n        msg.sender,\r\n        amountToken,\r\n        amountETH\r\n    );\r\n\r\n        }\r\n        \r\n        \r\n    }\r\n\r\n    function _addLiquidity(uint256 amountADesired, uint256 amountBDesired)\r\n        internal\r\n        view\r\n        returns (uint256 amountA, uint256 amountB)\r\n    {\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint256 amountBOptimal = (amountADesired * reserveB) / reserveA;\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal <= amountBDesired, \"Invalid amountb\");\r\n\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint256 amountAOptimal = (amountBDesired * reserveA) / reserveB;\r\n                require(amountAOptimal <= amountADesired, \"Invalid amountA\");\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function mint(address to) internal returns (uint256 liquidity) {\r\n        (uint256 _reserveA, uint256 _reserveB) = getReserve();\r\n        uint256 balance0 = PBMC.balanceOf(address(this));\r\n        uint256 balance1 = IWETH(WETH).balanceOf(address(this));\r\n        uint256 amount0 = balance0 - _reserveA;\r\n        uint256 amount1 = balance1 - _reserveB;\r\n\r\n        uint256 _totalLiquidity = totalLiquidity;\r\n        if (_totalLiquidity == 0) {\r\n            liquidity = sqrt(amount0 * amount1);\r\n        } else {\r\n            liquidity = min(\r\n                (amount0 * _totalLiquidity) / _reserveA,\r\n                (amount1 * _totalLiquidity) / _reserveB\r\n            );\r\n        }\r\n        require(liquidity > 0, \"INSUFFICIENT_LIQUIDITY_MINTED\");\r\n        userToMint[to] += liquidity;\r\n        totalLiquidity += liquidity;\r\n    }\r\n\r\n    function removeLiquidityETH(uint256 liquidity, address to)\r\n        public\r\n        returns (uint256 amountToken, uint256 amountETH)\r\n    {\r\n        require(userToMint[msg.sender] >=liquidity, \"INSUFFICIENT_LIQUIDITY\");\r\n        (amountToken, amountETH) = burn(liquidity);\r\n        userToMint[msg.sender] -= liquidity;\r\n        safeTransfer(to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        safeTransferETH(to, amountETH);\r\n        reserveA = PBMC.balanceOf(address(this));\r\n        reserveB = IWETH(WETH).balanceOf(address(this));\r\n\r\n         emit LiquidityRemoved(\r\n        msg.sender,\r\n        amountToken,\r\n        amountETH,\r\n        liquidity\r\n    );\r\n    }\r\n\r\n    function burn(uint liquidity) internal returns (uint256 amountToken, uint256 amountETH) {\r\n        uint256 balanceToken = PBMC.balanceOf(address(this));\r\n        uint256 balanceETH = IWETH(WETH).balanceOf(address(this));\r\n        uint256 _totalLiquidity = totalLiquidity;\r\n        amountToken = (liquidity * balanceToken) / _totalLiquidity;\r\n        amountETH = (liquidity * balanceETH) / _totalLiquidity;\r\n        require(\r\n            amountToken > 0 && amountETH > 0,\r\n            \"INSUFFICIENT_LIQUIDITY_BURNED\"\r\n        );\r\n        totalLiquidity -= liquidity;\r\n    }\r\n\r\n    function swap() internal {\r\n        {\r\n            reserveA = IERC20(PBMC).balanceOf(address(this));\r\n            reserveB = IWETH(WETH).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address to\r\n    ) external {\r\n        require(amountOut > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        (uint256 reserveIn, uint256 reserveOut) = getReserve();\r\n        require(reserveIn > 0 && reserveOut > 0, \"INSUFFICIENT_LIQUIDITY\");\r\n        uint256 numerator = (reserveIn * amountOut * 1000);\r\n        uint256 denominator = (reserveOut - amountOut) * (997);\r\n        uint256 amountIn = (numerator / denominator) + (1);\r\n        require(amountIn <= amountInMax, \"EXCESSIVE_ETH_AMOUNT\");\r\n        require(amountOut <= reserveOut, \"INSUFFICIENT LIQUIDITY\");\r\n        safeTransferFrom(msg.sender, address(this), amountIn);\r\n        IWETH(WETH).withdraw(amountOut);\r\n        safeTransferETH(to, amountOut);\r\n        swap();\r\n\r\n   \r\n    }\r\n\r\n    function swapETHForExactTokens(uint256 amountOut, address to)\r\n        external\r\n        payable\r\n    {\r\n        require(amountOut > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        (uint256 reserveOut, uint256 reserveIn) = getReserve();\r\n        require(reserveIn > 0 && reserveOut > 0, \"INSUFFICIENT_LIQUIDITY\");\r\n        \r\n        uint256 numerator = (reserveIn * amountOut * 1000);\r\n        uint256 denominator = (reserveOut - amountOut) * (997);\r\n        uint256 amountIn = (numerator / denominator) + (1);\r\n\r\n        require(amountIn <= msg.value, \"EXCESSIVE_INPUT_AMOUNT\");\r\n        require(amountOut <= reserveOut, \"INSUFFICIENT_LIQUIDITY\");\r\n\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        IWETH(WETH).transfer(address(this), amountIn);\r\n        PBMC.transfer(to, amountOut);\r\n        if (msg.value > amountIn){\r\n            safeTransferETH(msg.sender, msg.value - amountIn);\r\n        }\r\n        swap();\r\n    }\r\n\r\n    function swapExactTokensForETH(uint256 amountIn, address to) external {\r\n        require(amountIn > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\r\n        (uint256 reserveIn, uint256 reserveOut) = getReserve();\r\n        require(reserveIn > 0 && reserveOut > 0, \"INSUFFICIENT_LIQUIDITY\");\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        uint256 amountOut = numerator / denominator;\r\n        require(amountOut <= reserveOut, \"INSUFFICIENT LIQUIDITY\");\r\n        safeTransferFrom(msg.sender, address(this), amountIn);\r\n        IWETH(WETH).withdraw(amountOut);\r\n        safeTransferETH(to, amountOut);\r\n        swap();\r\n    }\r\n\r\n    function swapExactETHForTokens(address to) external payable {\r\n        require(msg.value > 0, \"INSUFFICIENT_ETH_AMOUNT\");\r\n        (uint256 reserveOut, uint256 reserveIn) = getReserve();\r\n        require(reserveIn > 0 && reserveOut > 0, \"INSUFFICIENT_LIQUIDITY\");\r\n        uint256 amountInWithFee = (msg.value).mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        uint256 amountOut = numerator / denominator;\r\n        require(amountOut <= reserveOut, \"INSUFFICIENT_LIQUIDITY\");\r\n        IWETH(WETH).deposit{value: msg.value}();\r\n        IWETH(WETH).transfer(address(this), msg.value);\r\n        PBMC.transfer(to, amountOut);\r\n        swap();\r\n    }\r\n\r\n    function getReserve()\r\n        public\r\n        view\r\n        returns (uint256 _reserveA, uint256 _reserveB)\r\n    {\r\n        _reserveA = reserveA;\r\n        _reserveB = reserveB;\r\n    }\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPBMC\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPBMC\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PBMC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pbmcAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"addLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pbmc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EthPBMCPool", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2ad804b1cfc0008e5f0cb41f5e78b836a7ae3c01c5818a1e8e10c2a59c56531a"}