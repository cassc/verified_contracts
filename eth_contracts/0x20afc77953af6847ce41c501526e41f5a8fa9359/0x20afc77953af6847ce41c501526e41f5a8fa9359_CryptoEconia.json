{"SourceCode": "/*\r\nCrypto Econia\r\nWelcome to the world of Crypto Econia, a revolutionary gaming platform powered by blockchain technology \r\nand driven by the ECONIA token. In this dynamic virtual universe, gamers will embark on a thrilling journey \r\nto build their business empires, master complex chains of production, and navigate the challenges of an \r\never-changing supply and demand landscape.\r\nTraditional gaming platforms often lack the depth and interactivity that truly engage players in a meaningful \r\nway. Crypto Econia seeks to redefine gaming by combining the excitement of a captivating gameplay experience \r\nwith the innovation of blockchain technology. By doing so, we aim to create an immersive gaming environment \r\nwhere players can not only enjoy the thrill of competition but also experience the thrill of managing a thriving \r\nvirtual economy.\r\nThrough the ECONIA token, players will have the power to shape the destiny of their in-game enterprises, \r\nstrategically maneuvering goods and resources to meet fluctuating market demands. The decentralized nature \r\nof the platform ensures transparency, fairness, and security, fostering a vibrant community of like-minded gamers \r\ncollaborating and competing in pursuit of greatness.\r\n\r\nProblem Statement\r\nTraditional gaming platforms often face several challenges that limit their potential to provide a truly immersive \r\nand rewarding experience for players. These challenges include:\r\n\r\nLack of Player Ownership: In conventional games, players do not have true ownership of in-game assets or resources. \r\nThis restricts their ability to trade or transfer assets outside the game environment and hinders the creation of a real \r\nvalue proposition.\r\nLimited Economic Interactions: Most gaming platforms have simplistic economic systems that do not adequately \r\nmimic the complexities of real-world economies. This results in shallow gameplay experiences that fail to capture \r\nthe intricacies of managing a business or navigating supply and demand dynamics.\r\nCentralized Control: Centralized gaming platforms often suffer from issues related to transparency, security, and \r\ngovernance. Players must trust a single entity to manage the game fairly, which can lead to concerns about favoritism, \r\nmanipulation, and potential disruptions to the gaming experience.\r\nLack of Incentives: Traditional games rarely reward players for their contributions to the gaming ecosystem or their \r\nactive engagement. This lack of incentives can lead to decreased player motivation and a decline in overall user retention.\r\nLimited Monetization Options: Game developers and players alike face limitations when it comes to monetizing their \r\nefforts. Many gaming platforms rely on traditional payment models, hindering the potential for a more dynamic and \r\ninclusive economy.\r\nFragmented Gaming Communities: Players often struggle to form strong communities within traditional gaming \r\nplatforms due to barriers in communication, limited collaboration opportunities, and fragmented player experiences.\r\n\r\nTo address these challenges and create a more engaging and rewarding gaming environment, Crypto Econia proposes \r\na decentralized gaming platform powered by blockchain technology and the ECONIA token. By leveraging the unique \r\ncapabilities of blockchain, Crypto Econia aims to revolutionize the gaming industry, empowering players with true \r\nownership, economic agency, and an enriched sense of community.\r\nThrough these innovative solutions, Crypto Econia seeks to redefine gaming, paving the way for a dynamic and inclusive \r\ngaming ecosystem that benefits players, developers, and the broader gaming community alike.\r\n\r\nOverview of the Gaming Platform\r\nCrypto Econia: Building Virtual Empires\r\nCrypto Econia is an immersive gaming platform designed to empower players to build their virtual empires and become \r\nmasters of a dynamic and ever-changing economy. Set in a fictional world, players will embark on a thrilling journey \r\nwhere they can unleash their entrepreneurial spirit, engage in strategic decision-making, and experience the excitement \r\nof managing their own businesses.\r\n\r\nKey Features and Gameplay Mechanics\r\nBusiness Empire Building: Players start as aspiring entrepreneurs and must strategically grow their businesses by \r\nacquiring resources, investing in production facilities, and expanding their reach in the virtual world.\r\n\r\nChains of Production: The gameplay revolves around complex chains of production, where players need to manage the \r\nentire supply chain from raw materials to finished products. Each step requires careful planning to optimize efficiency \r\nand meet market demands.\r\nMarket Dynamics: The in-game economy will simulate real-world market dynamics, including supply and demand \r\nfluctuations. Players must adapt their production strategies to match the ever-changing market conditions to maximize \r\nprofits.\r\nECONIA Token Integration: The ECONIA token is the lifeblood of the platform, serving as the primary medium of exchange \r\nwithin the gaming ecosystem. Players will use ECONIA to purchase resources, upgrade facilities, and conduct trade with \r\nother players.\r\nOwnership and Trade: Thanks to blockchain technology, players will have true ownership of in-game assets represented \r\nby non-fungible tokens (NFTs). This ownership enables players to trade assets freely with others on various marketplaces, \r\nadding a new dimension of value to the gaming experience.\r\nDecentralized Governance: Decisions regarding the development and evolution of Crypto Econia will be made through a \r\ndecentralized governance model, allowing the community to actively participate in shaping the platform's future.\r\nRewards and Incentives: Active participation and successful management of businesses will be rewarded with ECONIA \r\ntokens and other valuable in-game assets, motivating players to continually strive for success.\r\nCommunity and Collaboration: Crypto Econia fosters a vibrant community where players can interact, collaborate, and \r\ncompete in various game-related activities. Social features and communication tools will strengthen the bonds between \r\nplayers, making the gaming experience more enjoyable.\r\n\r\nThe Advantages of Crypto Econia\r\nBy integrating blockchain technology and leveraging the unique capabilities of the ECONIA token, Crypto Econia offers a \r\ntransformative gaming experience with several key advantages:\r\nTrue Ownership and Value: Players will have true ownership of their in-game assets, giving them the freedom to trade, sell, \r\nor utilize them beyond the confines of the gaming platform.\r\nEconomic Complexity: The platform's intricate supply chain and market dynamics offer a rich and challenging gaming \r\nexperience, allowing players to immerse themselves in the complexities of managing a virtual business.\r\nDecentralization and Security: The decentralized nature of the platform ensures transparency, security, and fairness, \r\neliminating concerns about centralized control and manipulation.\r\nIncentivized Gameplay: Players will be incentivized to actively engage with the platform, creating a thriving and dynamic \r\ngaming community.\r\nMonetization Opportunities: Players and developers alike will have various monetization opportunities through the trade of \r\nin-game assets and participation in the economy.\r\nCrypto Econia represents a groundbreaking fusion of gaming and blockchain technology, offering a truly novel and immersive \r\ngaming experience where players can shape their destinies, embrace economic challenges, and thrive in an ever-evolving \r\nvirtual world. Join us on this exciting journey as we redefine gaming for the future.\r\nECONIA Token: Empowering the Virtual Economy\r\nThe ECONIA token lies at the core of the Crypto Econia gaming platform, serving as the fundamental unit of value and exchange \r\nwithin the virtual economy. With its integration into the platform, the ECONIA token empowers players with new opportunities \r\nand benefits, revolutionizing the way in-game transactions, rewards, and ownership are handled.\r\n\r\nUtility of the ECONIA Token\r\nIn-Game Transactions: ECONIA serves as the primary currency for all in-game transactions, allowing players to purchase \r\nresources, upgrade facilities, and trade with other players in a seamless and efficient manner.\r\n\r\nAsset Ownership: The ECONIA token, represented as non-fungible tokens (NFTs), grants players true ownership of in-game \r\nassets. These NFTs are securely stored on the blockchain, providing players with full control and the ability to trade or transfer \r\nassets outside the gaming platform.\r\n\r\nEconomic Influence: Players can utilize their ECONIA holdings to influence supply and demand dynamics within the in-game \r\neconomy. By making strategic decisions with their tokens, players can shape the market and influence price fluctuations.\r\n\r\nRewards and Incentives: Successful gameplay, such as expanding businesses, completing challenging objectives, or contributing \r\nto the community, will be rewarded with ECONIA tokens. These rewards incentivize player engagement and foster a dynamic and \r\nthriving gaming community.\r\n\r\nGovernance Participation: Holding ECONIA tokens grants players the opportunity to participate in the decentralized governance \r\nof the Crypto Econia platform. Voting on proposed changes and decisions allows the community to actively shape the platform's \r\ndevelopment and evolution.\r\n\r\nTokenomics\r\nThe distribution and supply of the ECONIA token have been carefully designed to ensure a balanced and sustainable gaming ecosystem:\r\n\r\nInitial Token Distribution: The initial distribution of ECONIA tokens will be conducted through a fair and transparent token sale. \r\nThis process aims to include a diverse community of gamers and supporters, fostering a wide distribution of tokens.\r\n\r\nToken Supply: The total supply of ECONIA tokens will be limited to maintain scarcity and intrinsic value. This scarcity enhances the \r\ntoken's desirability and encourages a robust economy.\r\n\r\nToken Allocation: The token allocation will be distributed among various stakeholders, including players, developers, advisors, \r\nand ecosystem contributors. This diverse allocation ensures a well-balanced ecosystem with multiple vested interests.\r\n\r\nToken Burn Mechanism: A deflationary mechanism may be implemented, where a portion of transaction fees or other economic \r\nactivities could be burned, reducing the overall token supply over time and potentially increasing the value of remaining tokens.\r\n*/\r\n// SPDX-License-Identifier: None\r\n\r\npragma solidity ^0.8.2;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n   \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n  \r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n\r\n            if (returndata.length > 0) {\r\n              \r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address public _owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract CryptoEconia is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _rOwned;\r\n    mapping (address => uint256) private _tOwned;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    mapping (address => bool) private _isExcluded;\r\n    address[] private _excluded;\r\n\r\n    mapping (address => bool) private _isExcludedSender;\r\n    address[] private _excludedSender;\r\n\r\n    string  public Website = \"www.crypto-econia.com\";\r\n    string  public Total_Fee = \"9%\";\r\n    string  public Slippage = \"12%\";\r\n\r\n    string  private _NAME;\r\n    string  private _SYMBOL;\r\n    uint256 private _DECIMALS;\r\n    address private FeeAddress;\r\n\r\n    uint256 private _MAX = ~uint256(0);\r\n    uint256 private _DECIMALFACTOR;\r\n    uint256 private _GRANULARITY = 100;\r\n\r\n    uint256 private _tTotal;\r\n    uint256 private _rTotal;\r\n\r\n    uint256 private _tFeeTotal;\r\n    uint256 private _tBurnTotal;\r\n    uint256 private _tLiquidityPoolTotal;\r\n\r\n    uint256 public     _TAX_FEE;\r\n    uint256 public    _BURN_FEE;\r\n    uint256 public _LIQUIDITYPOOL_FEE;\r\n\r\n    uint256 private ORIG_TAX_FEE;\r\n    uint256 private ORIG_BURN_FEE;\r\n    uint256 private ORIG_LIQUIDITYPOOL_FEE;\r\n\r\n    address private dev;\r\n    mapping (address => bool) private _antiBot;\r\n\r\n    constructor (string memory _name, string memory _symbol, uint256 _decimals, uint256 _supply, uint256 _txFee,uint256 _burnFee,uint256 _liquiditypoolFee,address _FeeAddress,address _dev) {\r\n        _NAME = _name;\r\n        _SYMBOL = _symbol;\r\n        _DECIMALS = _decimals;\r\n        _DECIMALFACTOR = 10 ** _DECIMALS;\r\n        _tTotal =_supply * _DECIMALFACTOR;\r\n        _rTotal = (_MAX - (_MAX % _tTotal));\r\n        _TAX_FEE = _txFee* 100;\r\n        _BURN_FEE = _burnFee * 100;\r\n        _LIQUIDITYPOOL_FEE = _liquiditypoolFee* 100;\r\n        ORIG_TAX_FEE = _TAX_FEE;\r\n        ORIG_BURN_FEE = _BURN_FEE;\r\n        ORIG_LIQUIDITYPOOL_FEE = _LIQUIDITYPOOL_FEE;\r\n        FeeAddress = _FeeAddress;\r\n        dev = _dev;\r\n        _owner = msg.sender;\r\n        _rOwned[_owner] = _rTotal;\r\n\r\n    }\r\n\r\n    modifier onlyDev() {\r\n        require(dev == _msgSender(), \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _NAME;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _SYMBOL;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return uint8(_DECIMALS);\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"TOKEN20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"TOKEN20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function isExcluded(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n\r\n    function isExcludedSender(address account) public view returns (bool) {\r\n        return _isExcludedSender[account];\r\n    }\r\n\r\n    function totalFees() public view returns (uint256) {\r\n        return _tFeeTotal;\r\n    }\r\n\r\n    function totalBurn() public view returns (uint256) {\r\n        return _tBurnTotal;\r\n    }\r\n\r\n    function totalLiquidityPool() public view returns (uint256) {\r\n        return _tLiquidityPoolTotal;\r\n    }\r\n\r\n    function deliver(uint256 tAmount) public {\r\n        address sender = _msgSender();\r\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\r\n        (uint256 rAmount,,,,,,) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rTotal = _rTotal.sub(rAmount);\r\n        _tFeeTotal = _tFeeTotal.add(tAmount);\r\n    }\r\n\r\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\r\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\r\n        if (!deductTransferFee) {\r\n            (uint256 rAmount,,,,,,) = _getValues(tAmount);\r\n            return rAmount;\r\n        } else {\r\n            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\r\n            return rTransferAmount;\r\n        }\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    function excludeAccount(address account) external onlyDev() {\r\n        require(!_isExcluded[account], \"Account is already excluded\");\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n    function includeAccount(address account) external onlyDev() {\r\n        require(_isExcluded[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function antiBot(address _wallet, bool _allow) external onlyDev() {\r\n        if(_allow){\r\n            _antiBot[_wallet] = _allow;\r\n        } else {\r\n            delete _antiBot[_wallet];\r\n        }\r\n    }\r\n\r\n    function isBot(address _wallet) external view returns (bool) {\r\n        return _antiBot[_wallet];\r\n    }\r\n\r\n    function excludeAccountSender(address account) external onlyDev() {\r\n        require(!_isExcludedSender[account], \"Account is already excluded\");\r\n\r\n        _isExcludedSender[account] = true;\r\n        _excludedSender.push(account);\r\n    }\r\n\r\n    function includeAccountSender(address account) external onlyDev() {\r\n        require(_isExcludedSender[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excludedSender.length; i++) {\r\n            if (_excludedSender[i] == account) {\r\n                _excludedSender[i] = _excludedSender[_excludedSender.length - 1];\r\n                _isExcludedSender[account] = false;\r\n                _excludedSender.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setAsLiquidityPoolAccount(address account) external onlyDev() {\r\n        FeeAddress = account;\r\n    }\r\n\r\n    function updateFee(uint256 _txFee,uint256 _burnFee,uint256 _liquiditypoolFee) onlyDev() public{\r\n        require(_txFee < 100 && _burnFee < 100 && _liquiditypoolFee < 100);\r\n        _TAX_FEE = _txFee* 100;\r\n        _BURN_FEE = _burnFee * 100;\r\n        _LIQUIDITYPOOL_FEE = _liquiditypoolFee* 100;\r\n        ORIG_TAX_FEE = _TAX_FEE;\r\n        ORIG_BURN_FEE = _BURN_FEE;\r\n        ORIG_LIQUIDITYPOOL_FEE = _LIQUIDITYPOOL_FEE;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"TOKEN20: approve from the zero address\");\r\n        require(spender != address(0), \"TOKEN20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"TOKEN20: transfer from the zero address\");\r\n        require(recipient != address(0), \"TOKEN20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        require(!_antiBot[sender], \"Bot not allowed\");\r\n\r\n        bool takeFee = true;\r\n        if (FeeAddress == sender || FeeAddress == recipient || _isExcluded[recipient] || _isExcludedSender[sender]) {\r\n            takeFee = false;\r\n        }\r\n\r\n        if (!takeFee) removeAllFee();\r\n\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n            _transferFromExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n            _transferToExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n            _transferStandard(sender, recipient, amount);\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n            _transferBothExcluded(sender, recipient, amount);\r\n        } else {\r\n            _transferStandard(sender, recipient, amount);\r\n        }\r\n\r\n        if (!takeFee) restoreAllFee();\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 currentRate =  _getRate();\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);\r\n        uint256 rBurn =  tBurn.mul(currentRate);\r\n        _standardTransferContent(sender, recipient, rAmount, rTransferAmount);\r\n        _sendToLiquidityPool(tLiquidityPool, sender);\r\n        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _standardTransferContent(address sender, address recipient, uint256 rAmount, uint256 rTransferAmount) private {\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 currentRate =  _getRate();\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);\r\n        uint256 rBurn =  tBurn.mul(currentRate);\r\n        _excludedFromTransferContent(sender, recipient, tTransferAmount, rAmount, rTransferAmount);\r\n        _sendToLiquidityPool(tLiquidityPool, sender);\r\n        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _excludedFromTransferContent(address sender, address recipient, uint256 tTransferAmount, uint256 rAmount, uint256 rTransferAmount) private {\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 currentRate =  _getRate();\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);\r\n        uint256 rBurn =  tBurn.mul(currentRate);\r\n        _excludedToTransferContent(sender, recipient, tAmount, rAmount, rTransferAmount);\r\n        _sendToLiquidityPool(tLiquidityPool, sender);\r\n        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _excludedToTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 rTransferAmount) private {\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 currentRate =  _getRate();\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);\r\n        uint256 rBurn =  tBurn.mul(currentRate);\r\n        _bothTransferContent(sender, recipient, tAmount, rAmount, tTransferAmount, rTransferAmount);\r\n        _sendToLiquidityPool(tLiquidityPool, sender);\r\n        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _bothTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 tTransferAmount, uint256 rTransferAmount) private {\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 rBurn, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) private {\r\n        _rTotal = _rTotal.sub(rFee).sub(rBurn);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n        _tBurnTotal = _tBurnTotal.add(tBurn);\r\n        _tLiquidityPoolTotal = _tLiquidityPoolTotal.add(tLiquidityPool);\r\n        _tTotal = _tTotal.sub(tBurn);\r\n        emit Transfer(address(this), address(0), tBurn);\r\n    }\r\n\r\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        (uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getTBasics(tAmount, _TAX_FEE, _BURN_FEE, _LIQUIDITYPOOL_FEE);\r\n        uint256 tTransferAmount = getTTransferAmount(tAmount, tFee, tBurn, tLiquidityPool);\r\n        uint256 currentRate =  _getRate();\r\n        (uint256 rAmount, uint256 rFee) = _getRBasics(tAmount, tFee, currentRate);\r\n        uint256 rTransferAmount = _getRTransferAmount(rAmount, rFee, tBurn, tLiquidityPool, currentRate);\r\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tBurn, tLiquidityPool);\r\n    }\r\n\r\n    function _getTBasics(uint256 tAmount, uint256 taxFee, uint256 burnFee, uint256 liquiditypoolFee) private view returns (uint256, uint256, uint256) {\r\n        uint256 tFee = ((tAmount.mul(taxFee)).div(_GRANULARITY)).div(100);\r\n        uint256 tBurn = ((tAmount.mul(burnFee)).div(_GRANULARITY)).div(100);\r\n        uint256 tLiquidityPool = ((tAmount.mul(liquiditypoolFee)).div(_GRANULARITY)).div(100);\r\n        return (tFee, tBurn, tLiquidityPool);\r\n    }\r\n\r\n    function getTTransferAmount(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) private pure returns (uint256) {\r\n        return tAmount.sub(tFee).sub(tBurn).sub(tLiquidityPool);\r\n    }\r\n\r\n    function _getRBasics(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256) {\r\n        uint256 rAmount = tAmount.mul(currentRate);\r\n        uint256 rFee = tFee.mul(currentRate);\r\n        return (rAmount, rFee);\r\n    }\r\n\r\n    function _getRTransferAmount(uint256 rAmount, uint256 rFee, uint256 tBurn, uint256 tLiquidityPool, uint256 currentRate) private pure returns (uint256) {\r\n        uint256 rBurn = tBurn.mul(currentRate);\r\n        uint256 rLiquidityPool = tLiquidityPool.mul(currentRate);\r\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rBurn).sub(rLiquidityPool);\r\n        return rTransferAmount;\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply.div(tSupply);\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\r\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\r\n        }\r\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function _sendToLiquidityPool(uint256 tLiquidityPool, address sender) private {\r\n        uint256 currentRate = _getRate();\r\n        uint256 rLiquidityPool = tLiquidityPool.mul(currentRate);\r\n        _rOwned[FeeAddress] = _rOwned[FeeAddress].add(rLiquidityPool);\r\n        _tOwned[FeeAddress] = _tOwned[FeeAddress].add(tLiquidityPool);\r\n        emit Transfer(sender, FeeAddress, tLiquidityPool);\r\n    }\r\n\r\n    function removeAllFee() private {\r\n        if(_TAX_FEE == 0 && _BURN_FEE == 0 && _LIQUIDITYPOOL_FEE == 0) return;\r\n\r\n        ORIG_TAX_FEE = _TAX_FEE;\r\n        ORIG_BURN_FEE = _BURN_FEE;\r\n        ORIG_LIQUIDITYPOOL_FEE = _LIQUIDITYPOOL_FEE;\r\n\r\n        _TAX_FEE = 0;\r\n        _BURN_FEE = 0;\r\n        _LIQUIDITYPOOL_FEE = 0;\r\n    }\r\n\r\n    function restoreAllFee() private {\r\n        _TAX_FEE = ORIG_TAX_FEE;\r\n        _BURN_FEE = ORIG_BURN_FEE;\r\n        _LIQUIDITYPOOL_FEE = ORIG_LIQUIDITYPOOL_FEE;\r\n    }\r\n    \r\n    function _getTaxFee() private view returns(uint256) {\r\n        return _TAX_FEE;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquiditypoolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_FeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Slippage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Total_Fee\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Website\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BURN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LIQUIDITYPOOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"antiBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccountSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccountSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setAsLiquidityPoolAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLiquidityPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquiditypoolFee\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CryptoEconia", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000003b9aca000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001160cb99af61592caaae25f2b9b50e8c5b081909000000000000000000000000cd34deded74f5c2e570bb4273e9b13ba771f9968000000000000000000000000000000000000000000000000000000000000000d43727970746f2045636f6e696100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000645434f4e49410000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2bc2a74f0cb61b047bc24d4a6b7cf81f694cf6b5c1ed87f85458b8ec79abcbe0"}