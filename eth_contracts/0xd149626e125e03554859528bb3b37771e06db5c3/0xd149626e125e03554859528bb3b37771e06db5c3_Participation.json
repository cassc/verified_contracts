{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/fund/participation/Participation.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../vault/Vault.sol\\\";\\nimport \\\"../shares/Shares.sol\\\";\\nimport \\\"../policies/PolicyManager.sol\\\";\\nimport \\\"../hub/Spoke.sol\\\";\\nimport \\\"../accounting/Accounting.sol\\\";\\nimport \\\"../../prices/IPriceSource.sol\\\";\\nimport \\\"../../factory/Factory.sol\\\";\\nimport \\\"../../engine/AmguConsumer.sol\\\";\\nimport \\\"../../dependencies/token/IERC20.sol\\\";\\nimport \\\"../../dependencies/DSMath.sol\\\";\\nimport \\\"../../dependencies/TokenUser.sol\\\";\\n\\n/// @notice Entry and exit point for investors\\ncontract Participation is TokenUser, AmguConsumer, Spoke {\\n    event EnableInvestment (address[] asset);\\n    event DisableInvestment (address[] assets);\\n\\n    event InvestmentRequest (\\n        address indexed requestOwner,\\n        address indexed investmentAsset,\\n        uint requestedShares,\\n        uint investmentAmount\\n    );\\n\\n    event RequestExecution (\\n        address indexed requestOwner,\\n        address indexed executor,\\n        address indexed investmentAsset,\\n        uint investmentAmount,\\n        uint requestedShares\\n    );\\n\\n    event CancelRequest (\\n        address indexed requestOwner\\n    );\\n\\n    event Redemption (\\n        address indexed redeemer,\\n        address[] assets,\\n        uint[] assetQuantities,\\n        uint redeemedShares\\n    );\\n\\n    struct Request {\\n        address investmentAsset;\\n        uint investmentAmount;\\n        uint requestedShares;\\n        uint timestamp;\\n    }\\n\\n    uint constant public SHARES_DECIMALS = 18;\\n    uint constant public REQUEST_LIFESPAN = 1 days;\\n\\n    mapping (address => Request) public requests;\\n    mapping (address => bool) public investAllowed;\\n    mapping (address => bool) public hasInvested; // for information purposes only (read)\\n\\n    address[] public historicalInvestors; // for information purposes only (read)\\n\\n    constructor(address _hub, address[] memory _defaultAssets, address _registry)\\n        public\\n        Spoke(_hub)\\n    {\\n        routes.registry = _registry;\\n        _enableInvestment(_defaultAssets);\\n    }\\n\\n    receive() external payable {}\\n\\n    function _enableInvestment(address[] memory _assets) internal {\\n        for (uint i = 0; i < _assets.length; i++) {\\n            require(\\n                Registry(routes.registry).assetIsRegistered(_assets[i]),\\n                \\\"Asset not registered\\\"\\n            );\\n            investAllowed[_assets[i]] = true;\\n        }\\n        emit EnableInvestment(_assets);\\n    }\\n\\n    function enableInvestment(address[] calldata _assets) external auth {\\n        _enableInvestment(_assets);\\n    }\\n\\n    function disableInvestment(address[] calldata _assets) external auth {\\n        for (uint i = 0; i < _assets.length; i++) {\\n            investAllowed[_assets[i]] = false;\\n        }\\n        emit DisableInvestment(_assets);\\n    }\\n\\n    function hasRequest(address _who) public view returns (bool) {\\n        return requests[_who].timestamp > 0;\\n    }\\n\\n    function hasExpiredRequest(address _who) public view returns (bool) {\\n        return block.timestamp > add(requests[_who].timestamp, REQUEST_LIFESPAN);\\n    }\\n\\n    /// @notice Whether request is OK and invest delay is being respected\\n    /// @dev Request valid if price update happened since request and not expired\\n    /// @dev If no shares exist and not expired, request can be executed immediately\\n    function hasValidRequest(address _who) public view returns (bool) {\\n        IPriceSource priceSource = IPriceSource(priceSource());\\n        bool delayRespectedOrNoShares = requests[_who].timestamp < priceSource.getLastUpdate() ||\\n            Shares(routes.shares).totalSupply() == 0;\\n\\n        return hasRequest(_who) &&\\n            delayRespectedOrNoShares &&\\n            !hasExpiredRequest(_who) &&\\n            requests[_who].investmentAmount > 0 &&\\n            requests[_who].requestedShares > 0;\\n    }\\n\\n    function requestInvestment(\\n        uint requestedShares,\\n        uint investmentAmount,\\n        address investmentAsset\\n    )\\n        external\\n        notShutDown\\n        payable\\n        amguPayable(true)\\n        onlyInitialized\\n    {\\n        PolicyManager(routes.policyManager).preValidate(\\n            msg.sig,\\n            [msg.sender, address(0), address(0), investmentAsset, address(0)],\\n            [uint(0), uint(0), uint(0)],\\n            bytes32(0)\\n        );\\n        require(\\n            investAllowed[investmentAsset],\\n            \\\"Investment not allowed in this asset\\\"\\n        );\\n        safeTransferFrom(\\n            investmentAsset, msg.sender, address(this), investmentAmount\\n        );\\n        require(\\n            requests[msg.sender].timestamp == 0,\\n            \\\"Only one request can exist at a time\\\"\\n        );\\n        requests[msg.sender] = Request({\\n            investmentAsset: investmentAsset,\\n            investmentAmount: investmentAmount,\\n            requestedShares: requestedShares,\\n            timestamp: block.timestamp\\n        });\\n        PolicyManager(routes.policyManager).postValidate(\\n            msg.sig,\\n            [msg.sender, address(0), address(0), investmentAsset, address(0)],\\n            [uint(0), uint(0), uint(0)],\\n            bytes32(0)\\n        );\\n\\n        emit InvestmentRequest(\\n            msg.sender,\\n            investmentAsset,\\n            requestedShares,\\n            investmentAmount\\n        );\\n    }\\n\\n    function _cancelRequestFor(address requestOwner) internal {\\n        require(hasRequest(requestOwner), \\\"No request to cancel\\\");\\n        IPriceSource priceSource = IPriceSource(priceSource());\\n        Request memory request = requests[requestOwner];\\n        require(\\n            !priceSource.hasValidPrice(request.investmentAsset) ||\\n            hasExpiredRequest(requestOwner) ||\\n            hub.isShutDown(),\\n            \\\"No cancellation condition was met\\\"\\n        );\\n        IERC20 investmentAsset = IERC20(request.investmentAsset);\\n        uint investmentAmount = request.investmentAmount;\\n        delete requests[requestOwner];\\n        msg.sender.transfer(Registry(routes.registry).incentive());\\n        safeTransfer(address(investmentAsset), requestOwner, investmentAmount);\\n\\n        emit CancelRequest(requestOwner);\\n    }\\n\\n    /// @notice Can only cancel when no price, request expired or fund shut down\\n    /// @dev Only request owner can cancel their request\\n    function cancelRequest() external payable amguPayable(false) {\\n        _cancelRequestFor(msg.sender);\\n    }\\n\\n    function cancelRequestFor(address requestOwner)\\n        external\\n        payable\\n        amguPayable(false)\\n    {\\n        _cancelRequestFor(requestOwner);\\n    }\\n\\n    function executeRequestFor(address requestOwner)\\n        external\\n        notShutDown\\n        amguPayable(false)\\n        payable\\n    {\\n        Request memory request = requests[requestOwner];\\n        require(\\n            hasValidRequest(requestOwner),\\n            \\\"No valid request for this address\\\"\\n        );\\n\\n        FeeManager(routes.feeManager).rewardManagementFee();\\n\\n        uint totalShareCostInInvestmentAsset = Accounting(routes.accounting)\\n            .getShareCostInAsset(\\n                request.requestedShares,\\n                request.investmentAsset\\n            );\\n\\n        require(\\n            totalShareCostInInvestmentAsset <= request.investmentAmount,\\n            \\\"Invested amount too low\\\"\\n        );\\n        // send necessary amount of investmentAsset to vault\\n        safeTransfer(\\n            request.investmentAsset,\\n            routes.vault,\\n            totalShareCostInInvestmentAsset\\n        );\\n\\n        uint investmentAssetChange = sub(\\n            request.investmentAmount,\\n            totalShareCostInInvestmentAsset\\n        );\\n\\n        // return investmentAsset change to request owner\\n        if (investmentAssetChange > 0) {\\n            safeTransfer(\\n                request.investmentAsset,\\n                requestOwner,\\n                investmentAssetChange\\n            );\\n        }\\n\\n        msg.sender.transfer(Registry(routes.registry).incentive());\\n\\n        Shares(routes.shares).createFor(requestOwner, request.requestedShares);\\n        Accounting(routes.accounting).addAssetToOwnedAssets(request.investmentAsset);\\n\\n        if (!hasInvested[requestOwner]) {\\n            hasInvested[requestOwner] = true;\\n            historicalInvestors.push(requestOwner);\\n        }\\n\\n        emit RequestExecution(\\n            requestOwner,\\n            msg.sender,\\n            request.investmentAsset,\\n            request.investmentAmount,\\n            request.requestedShares\\n        );\\n        delete requests[requestOwner];\\n    }\\n\\n    function getOwedPerformanceFees(uint shareQuantity)\\n        public\\n        returns (uint remainingShareQuantity)\\n    {\\n        Shares shares = Shares(routes.shares);\\n\\n        uint totalPerformanceFee = FeeManager(routes.feeManager).performanceFeeAmount();\\n        // The denominator is augmented because performanceFeeAmount() accounts for inflation\\n        // Since shares are directly transferred, we don't need to account for inflation in this case\\n        uint performanceFeePortion = mul(\\n            totalPerformanceFee,\\n            shareQuantity\\n        ) / add(shares.totalSupply(), totalPerformanceFee);\\n        return performanceFeePortion;\\n    }\\n\\n    /// @dev \\\"Happy path\\\" (no asset throws & quantity available)\\n    /// @notice Redeem all shares and across all assets\\n    function redeem() external {\\n        uint ownedShares = Shares(routes.shares).balanceOf(msg.sender);\\n        redeemQuantity(ownedShares);\\n    }\\n\\n    /// @notice Redeem shareQuantity across all assets\\n    function redeemQuantity(uint shareQuantity) public {\\n        address[] memory assetList;\\n        assetList = Accounting(routes.accounting).getOwnedAssets();\\n        redeemWithConstraints(shareQuantity, assetList);\\n    }\\n\\n    // TODO: reconsider the scenario where the user has enough funds to force shutdown on a large trade (any way around this?)\\n    /// @dev Redeem only selected assets (used only when an asset throws)\\n    function redeemWithConstraints(uint shareQuantity, address[] memory requestedAssets) public {\\n        Shares shares = Shares(routes.shares);\\n        require(\\n            shares.balanceOf(msg.sender) >= shareQuantity &&\\n            shares.balanceOf(msg.sender) > 0,\\n            \\\"Sender does not have enough shares to fulfill request\\\"\\n        );\\n\\n        uint owedPerformanceFees = 0;\\n        if (\\n            IPriceSource(priceSource()).hasValidPrices(requestedAssets) &&\\n            msg.sender != hub.manager()\\n        ) {\\n            FeeManager(routes.feeManager).rewardManagementFee();\\n            owedPerformanceFees = getOwedPerformanceFees(shareQuantity);\\n            shares.destroyFor(msg.sender, owedPerformanceFees);\\n            shares.createFor(hub.manager(), owedPerformanceFees);\\n        }\\n        uint remainingShareQuantity = sub(shareQuantity, owedPerformanceFees);\\n\\n        address ofAsset;\\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\\n        address[] memory redeemedAssets = new address[](requestedAssets.length);\\n        // Check whether enough assets held by fund\\n        Accounting accounting = Accounting(routes.accounting);\\n        for (uint i = 0; i < requestedAssets.length; ++i) {\\n            ofAsset = requestedAssets[i];\\n            require(\\n                accounting.isInAssetList(ofAsset),\\n                \\\"Requested asset not in asset list\\\"\\n            );\\n            for (uint j = 0; j < redeemedAssets.length; j++) {\\n                require(\\n                    ofAsset != redeemedAssets[j],\\n                    \\\"Asset can only be redeemed once\\\"\\n                );\\n            }\\n            redeemedAssets[i] = ofAsset;\\n            uint quantityHeld = accounting.assetHoldings(ofAsset);\\n            if (quantityHeld == 0) continue;\\n\\n            // participant's ownership percentage of asset holdings\\n            ownershipQuantities[i] = mul(quantityHeld, remainingShareQuantity) / shares.totalSupply();\\n        }\\n\\n        shares.destroyFor(msg.sender, remainingShareQuantity);\\n\\n        // Transfer owned assets\\n        for (uint k = 0; k < requestedAssets.length; ++k) {\\n            ofAsset = requestedAssets[k];\\n            if (ownershipQuantities[k] == 0) {\\n                continue;\\n            } else {\\n                Vault(routes.vault).withdraw(ofAsset, ownershipQuantities[k]);\\n                safeTransfer(ofAsset, msg.sender, ownershipQuantities[k]);\\n            }\\n        }\\n        emit Redemption(\\n            msg.sender,\\n            requestedAssets,\\n            ownershipQuantities,\\n            remainingShareQuantity\\n        );\\n    }\\n\\n    function getHistoricalInvestors() external view returns (address[] memory) {\\n        return historicalInvestors;\\n    }\\n\\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.engine(); }\\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.mlnToken(); }\\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.priceSource(); }\\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.registry(); }\\n}\\n\\ncontract ParticipationFactory is Factory {\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance,\\n        address[] defaultAssets,\\n        address registry\\n    );\\n\\n    function createInstance(address _hub, address[] calldata _defaultAssets, address _registry)\\n        external\\n        returns (address)\\n    {\\n        address participation = address(\\n            new Participation(_hub, _defaultAssets, _registry)\\n        );\\n        childExists[participation] = true;\\n        emit NewInstance(_hub, participation, _defaultAssets, _registry);\\n        return participation;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fund/vault/Vault.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../hub/Spoke.sol\\\";\\nimport \\\"../../factory/Factory.sol\\\";\\nimport \\\"../../dependencies/TokenUser.sol\\\";\\n\\n/// @notice Dumb custody component\\ncontract Vault is TokenUser, Spoke {\\n\\n    constructor(address _hub) public Spoke(_hub) {}\\n\\n    function withdraw(address token, uint amount) external auth {\\n        safeTransfer(token, msg.sender, amount);\\n    }\\n}\\n\\ncontract VaultFactory is Factory {\\n    function createInstance(address _hub) external returns (address) {\\n        address vault = address(new Vault(_hub));\\n        childExists[vault] = true;\\n        emit NewInstance(_hub, vault);\\n        return vault;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"src/fund/shares/Shares.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../hub/Spoke.sol\\\";\\nimport \\\"../../dependencies/token/StandardToken.sol\\\";\\nimport \\\"../../factory/Factory.sol\\\";\\n\\ncontract Shares is Spoke, StandardToken {\\n    string public symbol;\\n    string public name;\\n    uint8 public decimals;\\n\\n    constructor(address _hub) public Spoke(_hub) {\\n        name = hub.name();\\n        symbol = \\\"MLNF\\\";\\n        decimals = 18;\\n    }\\n\\n    function createFor(address who, uint amount) public auth {\\n        _mint(who, amount);\\n    }\\n\\n    function destroyFor(address who, uint amount) public auth {\\n        _burn(who, amount);\\n    }\\n\\n    function transfer(address to, uint amount) public override returns (bool) {\\n        revert(\\\"Unimplemented\\\");\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\"Unimplemented\\\");\\n    }\\n\\n    function approve(address spender, uint amount) public override returns (bool) {\\n        revert(\\\"Unimplemented\\\");\\n    }\\n\\n    function increaseApproval(\\n        address spender,\\n        uint amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\"Unimplemented\\\");\\n    }\\n\\n    function decreaseApproval(\\n        address spender,\\n        uint amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\"Unimplemented\\\");\\n    }\\n}\\n\\ncontract SharesFactory is Factory {\\n    function createInstance(address _hub) external returns (address) {\\n        address shares = address(new Shares(_hub));\\n        childExists[shares] = true;\\n        emit NewInstance(_hub, shares);\\n        return shares;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"src/fund/policies/PolicyManager.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../../factory/Factory.sol\\\";\\nimport \\\"../hub/Spoke.sol\\\";\\nimport \\\"./IPolicy.sol\\\";\\n\\ncontract PolicyManager is Spoke {\\n\\n    event Registration(\\n        bytes4 indexed sig,\\n        IPolicy.Applied position,\\n        address indexed policy\\n    );\\n\\n    struct Entry {\\n        IPolicy[] pre;\\n        IPolicy[] post;\\n    }\\n\\n    mapping(bytes4 => Entry) policies;\\n\\n    constructor (address _hub) public Spoke(_hub) {}\\n\\n    function register(bytes4 sig, address _policy) public auth {\\n        IPolicy.Applied position = IPolicy(_policy).position();\\n        if (position == IPolicy.Applied.pre) {\\n            policies[sig].pre.push(IPolicy(_policy));\\n        } else if (position == IPolicy.Applied.post) {\\n            policies[sig].post.push(IPolicy(_policy));\\n        } else {\\n            revert(\\\"Only pre and post allowed\\\");\\n        }\\n        emit Registration(sig, position, _policy);\\n    }\\n\\n    function batchRegister(bytes4[] memory sig, address[] memory _policies) public auth {\\n        require(sig.length == _policies.length, \\\"Arrays lengths unequal\\\");\\n        for (uint i = 0; i < sig.length; i++) {\\n            register(sig[i], _policies[i]);\\n        }\\n    }\\n\\n    function PoliciesToAddresses(IPolicy[] storage _policies) internal view returns (address[] memory) {\\n        address[] memory res = new address[](_policies.length);\\n        for(uint i = 0; i < _policies.length; i++) {\\n            res[i] = address(_policies[i]);\\n        }\\n        return res;\\n    }\\n\\n    function getPoliciesBySig(bytes4 sig) public view returns (address[] memory, address[] memory) {\\n        return (PoliciesToAddresses(policies[sig].pre), PoliciesToAddresses(policies[sig].post));\\n    }\\n\\n    modifier isValidPolicyBySig(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) {\\n        preValidate(sig, addresses, values, identifier);\\n        _;\\n        postValidate(sig, addresses, values, identifier);\\n    }\\n\\n    modifier isValidPolicy(address[5] memory addresses, uint[3] memory values, bytes32 identifier) {\\n        preValidate(msg.sig, addresses, values, identifier);\\n        _;\\n        postValidate(msg.sig, addresses, values, identifier);\\n    }\\n\\n    function preValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\\n        validate(policies[sig].pre, sig, addresses, values, identifier);\\n    }\\n\\n    function postValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\\n        validate(policies[sig].post, sig, addresses, values, identifier);\\n    }\\n\\n    function validate(IPolicy[] storage aux, bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) internal {\\n        for(uint i = 0; i < aux.length; i++) {\\n            require(\\n                aux[i].rule(sig, addresses, values, identifier),\\n                string(abi.encodePacked(\\\"Rule evaluated to false: \\\", aux[i].identifier()))\\n            );\\n        }\\n    }\\n}\\n\\ncontract PolicyManagerFactory is Factory {\\n    function createInstance(address _hub) external returns (address) {\\n        address policyManager = address(new PolicyManager(_hub));\\n        childExists[policyManager] = true;\\n        emit NewInstance(_hub, policyManager);\\n        return policyManager;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fund/hub/Spoke.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"./Hub.sol\\\";\\nimport \\\"../../dependencies/DSAuth.sol\\\";\\n\\n/// @notice Has one Hub\\ncontract Spoke is DSAuth {\\n    Hub public hub;\\n    Hub.Routes public routes;\\n    bool public initialized;\\n\\n    modifier onlyInitialized() {\\n        require(initialized, \\\"Component not yet initialized\\\");\\n        _;\\n    }\\n\\n    modifier notShutDown() {\\n        require(!hub.isShutDown(), \\\"Hub is shut down\\\");\\n        _;\\n    }\\n\\n    constructor(address _hub) public {\\n        hub = Hub(_hub);\\n        setAuthority(hub);\\n        setOwner(address(hub)); // temporary, to allow initialization\\n    }\\n\\n    function initialize(address[11] calldata _spokes) external auth {\\n        require(msg.sender == address(hub));\\n        require(!initialized, \\\"Already initialized\\\");\\n        routes = Hub.Routes(\\n            _spokes[0],\\n            _spokes[1],\\n            _spokes[2],\\n            _spokes[3],\\n            _spokes[4],\\n            _spokes[5],\\n            _spokes[6],\\n            _spokes[7],\\n            _spokes[8],\\n            _spokes[9],\\n            _spokes[10]\\n        );\\n        initialized = true;\\n        setOwner(address(0));\\n    }\\n\\n    function engine() public view virtual returns (address) { return routes.engine; }\\n    function mlnToken() public view virtual returns (address) { return routes.mlnToken; }\\n    function priceSource() public view virtual returns (address) { return hub.priceSource(); }\\n    function version() public view virtual returns (address) { return routes.version; }\\n    function registry() public view virtual returns (address) { return routes.registry; }\\n}\\n\\n\"\r\n    },\r\n    \"src/fund/accounting/Accounting.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../../dependencies/token/StandardToken.sol\\\";\\nimport \\\"../../factory/Factory.sol\\\";\\nimport \\\"../../prices/IPriceSource.sol\\\";\\nimport \\\"../fees/FeeManager.sol\\\";\\nimport \\\"../hub/Spoke.sol\\\";\\nimport \\\"../shares/Shares.sol\\\";\\nimport \\\"../trading/ITrading.sol\\\";\\nimport \\\"../vault/Vault.sol\\\";\\nimport \\\"../../engine/AmguConsumer.sol\\\";\\n\\ncontract Accounting is AmguConsumer, Spoke {\\n\\n    event AssetAddition(address indexed asset);\\n    event AssetRemoval(address indexed asset);\\n\\n    struct Calculations {\\n        uint gav;\\n        uint nav;\\n        uint allocatedFees;\\n        uint totalSupply;\\n        uint timestamp;\\n    }\\n\\n    uint constant public MAX_OWNED_ASSETS = 20;\\n    address[] public ownedAssets;\\n    mapping (address => bool) public isInAssetList;\\n    uint public constant SHARES_DECIMALS = 18;\\n    address public NATIVE_ASSET;\\n    address public DENOMINATION_ASSET;\\n    uint public DENOMINATION_ASSET_DECIMALS;\\n    uint public DEFAULT_SHARE_PRICE;\\n    Calculations public atLastAllocation;\\n\\n    constructor(address _hub, address _denominationAsset, address _nativeAsset)\\n        public\\n        Spoke(_hub)\\n    {\\n        DENOMINATION_ASSET = _denominationAsset;\\n        NATIVE_ASSET = _nativeAsset;\\n        DENOMINATION_ASSET_DECIMALS = ERC20WithFields(DENOMINATION_ASSET).decimals();\\n        DEFAULT_SHARE_PRICE = 10 ** uint(DENOMINATION_ASSET_DECIMALS);\\n    }\\n\\n    function getOwnedAssetsLength() external view returns (uint256) {\\n        return ownedAssets.length;\\n    }\\n\\n    function getOwnedAssets() external view returns (address[] memory) {\\n        return ownedAssets;\\n    }\\n\\n    function assetHoldings(address _asset) public returns (uint256) {\\n        return add(\\n            uint256(ERC20WithFields(_asset).balanceOf(routes.vault)),\\n            ITrading(routes.trading).updateAndGetQuantityBeingTraded(_asset)\\n        );\\n    }\\n\\n    /// @dev Returns sparse array\\n    function getFundHoldings() external returns (uint[] memory, address[] memory) {\\n        uint[] memory _quantities = new uint[](ownedAssets.length);\\n        address[] memory _assets = new address[](ownedAssets.length);\\n        for (uint i = 0; i < ownedAssets.length; i++) {\\n            address ofAsset = ownedAssets[i];\\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\\n            uint quantityHeld = assetHoldings(ofAsset);\\n            _assets[i] = ofAsset;\\n            _quantities[i] = quantityHeld;\\n        }\\n        return (_quantities, _assets);\\n    }\\n\\n    function calcAssetGAV(address _queryAsset) external returns (uint) {\\n        uint queryAssetQuantityHeld = assetHoldings(_queryAsset);\\n        return IPriceSource(priceSource()).convertQuantity(\\n            queryAssetQuantityHeld, _queryAsset, DENOMINATION_ASSET\\n        );\\n    }\\n\\n    // prices are quoted in DENOMINATION_ASSET so they use denominationDecimals\\n    function calcGav() public returns (uint gav) {\\n        for (uint i = 0; i < ownedAssets.length; ++i) {\\n            address asset = ownedAssets[i];\\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimals)\\n            uint quantityHeld = assetHoldings(asset);\\n            // Dont bother with the calculations if the balance of the asset is 0\\n            if (quantityHeld == 0) {\\n                continue;\\n            }\\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\\n            gav = add(\\n                gav,\\n                IPriceSource(priceSource()).convertQuantity(\\n                    quantityHeld, asset, DENOMINATION_ASSET\\n                )\\n            );\\n        }\\n        return gav;\\n    }\\n\\n    function calcNav(uint gav, uint unclaimedFeesInDenominationAsset) public pure returns (uint) {\\n        return sub(gav, unclaimedFeesInDenominationAsset);\\n    }\\n\\n    function valuePerShare(uint totalValue, uint numShares) public pure returns (uint) {\\n        require(numShares > 0, \\\"No shares to calculate value for\\\");\\n        return (totalValue * 10 ** uint(SHARES_DECIMALS)) / numShares;\\n    }\\n\\n    function performCalculations()\\n        public\\n        returns (\\n            uint gav,\\n            uint feesInDenominationAsset,  // unclaimed amount\\n            uint feesInShares,             // unclaimed amount\\n            uint nav,\\n            uint sharePrice,\\n            uint gavPerShareNetManagementFee\\n        )\\n    {\\n        gav = calcGav();\\n        uint totalSupply = Shares(routes.shares).totalSupply();\\n        feesInShares = FeeManager(routes.feeManager).totalFeeAmount();\\n        feesInDenominationAsset = (totalSupply == 0) ?\\n            0 :\\n            mul(feesInShares, gav) / add(totalSupply, feesInShares);\\n        nav = calcNav(gav, feesInDenominationAsset);\\n\\n        // The total share supply including the value of feesInDenominationAsset, measured in shares of this fund\\n        uint totalSupplyAccountingForFees = add(totalSupply, feesInShares);\\n        sharePrice = (totalSupply > 0) ?\\n            valuePerShare(gav, totalSupplyAccountingForFees) :\\n            DEFAULT_SHARE_PRICE;\\n        gavPerShareNetManagementFee = (totalSupply > 0) ?\\n            valuePerShare(gav, add(totalSupply, FeeManager(routes.feeManager).managementFeeAmount())) :\\n            DEFAULT_SHARE_PRICE;\\n        return (gav, feesInDenominationAsset, feesInShares, nav, sharePrice, gavPerShareNetManagementFee);\\n    }\\n\\n    function calcGavPerShareNetManagementFee()\\n        public\\n        returns (uint gavPerShareNetManagementFee)\\n    {\\n        (,,,,,gavPerShareNetManagementFee) = performCalculations();\\n        return gavPerShareNetManagementFee;\\n    }\\n\\n    function getShareCostInAsset(uint _numShares, address _altAsset)\\n        external\\n        returns (uint)\\n    {\\n        uint denominationAssetQuantity = mul(\\n            _numShares,\\n            calcGavPerShareNetManagementFee()\\n        ) / 10 ** uint(SHARES_DECIMALS);\\n        return IPriceSource(priceSource()).convertQuantity(\\n            denominationAssetQuantity, DENOMINATION_ASSET, _altAsset\\n        );\\n    }\\n\\n    /// @notice Reward all fees and perform some updates\\n    /// @dev Anyone can call this\\n    function triggerRewardAllFees()\\n        external\\n        amguPayable(false)\\n        payable\\n    {\\n        updateOwnedAssets();\\n        uint256 gav;\\n        uint256 feesInDenomination;\\n        uint256 feesInShares;\\n        uint256 nav;\\n        (gav, feesInDenomination, feesInShares, nav,,) = performCalculations();\\n        uint256 totalSupply = Shares(routes.shares).totalSupply();\\n        FeeManager(routes.feeManager).rewardAllFees();\\n        atLastAllocation = Calculations({\\n            gav: gav,\\n            nav: nav,\\n            allocatedFees: feesInDenomination,\\n            totalSupply: totalSupply,\\n            timestamp: block.timestamp\\n        });\\n    }\\n\\n    /// @dev Check holdings for all assets, and adjust list\\n    function updateOwnedAssets() public {\\n        for (uint i = 0; i < ownedAssets.length; i++) {\\n            address asset = ownedAssets[i];\\n            if (\\n                assetHoldings(asset) == 0 &&\\n                !(asset == address(DENOMINATION_ASSET)) &&\\n                ITrading(routes.trading).getOpenMakeOrdersAgainstAsset(asset) == 0\\n            ) {\\n                _removeFromOwnedAssets(asset);\\n            }\\n        }\\n    }\\n\\n    function addAssetToOwnedAssets(address _asset) external auth {\\n        _addAssetToOwnedAssets(_asset);\\n    }\\n\\n    function removeFromOwnedAssets(address _asset) external auth {\\n        _removeFromOwnedAssets(_asset);\\n    }\\n\\n    /// @dev Just pass if asset already in list\\n    function _addAssetToOwnedAssets(address _asset) internal {\\n        if (isInAssetList[_asset]) { return; }\\n\\n        require(\\n            ownedAssets.length < MAX_OWNED_ASSETS,\\n            \\\"Max owned asset limit reached\\\"\\n        );\\n        isInAssetList[_asset] = true;\\n        ownedAssets.push(_asset);\\n        emit AssetAddition(_asset);\\n    }\\n\\n    /// @dev Just pass if asset not in list\\n    function _removeFromOwnedAssets(address _asset) internal {\\n        if (!isInAssetList[_asset]) { return; }\\n\\n        isInAssetList[_asset] = false;\\n        for (uint i; i < ownedAssets.length; i++) {\\n            if (ownedAssets[i] == _asset) {\\n                ownedAssets[i] = ownedAssets[ownedAssets.length - 1];\\n                ownedAssets.pop();\\n                break;\\n            }\\n        }\\n        emit AssetRemoval(_asset);\\n    }\\n\\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.engine(); }\\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.mlnToken(); }\\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.priceSource(); }\\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.registry(); }\\n}\\n\\ncontract AccountingFactory is Factory {\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance,\\n        address denominationAsset,\\n        address nativeAsset\\n    );\\n\\n    function createInstance(address _hub, address _denominationAsset, address _nativeAsset) external returns (address) {\\n        address accounting = address(new Accounting(_hub, _denominationAsset, _nativeAsset));\\n        childExists[accounting] = true;\\n        emit NewInstance(_hub, accounting, _denominationAsset, _nativeAsset);\\n        return accounting;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"src/prices/IPriceSource.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\n/// @notice Must return a value for an asset\\ninterface IPriceSource {\\n    function getQuoteAsset() external view returns (address);\\n    function getLastUpdate() external view returns (uint);\\n\\n    /// @notice Returns false if asset not applicable, or price not recent\\n    function hasValidPrice(address) external view returns (bool);\\n    function hasValidPrices(address[] calldata) external view returns (bool);\\n\\n    /// @notice Return the last known price, and when it was issued\\n    function getPrice(address _asset) external view returns (uint price, uint timestamp);\\n    function getPrices(address[] calldata _assets) external view returns (uint[] memory prices, uint[] memory timestamps);\\n\\n    /// @notice Get price info, and revert if not valid\\n    function getPriceInfo(address _asset) external view returns (uint price, uint decimals);\\n    function getInvertedPriceInfo(address ofAsset) external view returns (uint price, uint decimals);\\n\\n    function getReferencePriceInfo(address _base, address _quote) external view returns (uint referencePrice, uint decimal);\\n    function getOrderPriceInfo(address sellAsset, uint sellQuantity, uint buyQuantity) external view returns (uint orderPrice);\\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) external view returns (bool isExistent);\\n    function convertQuantity(\\n        uint fromAssetQuantity,\\n        address fromAsset,\\n        address toAsset\\n    ) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"src/factory/Factory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\n\\ncontract Factory {\\n    mapping (address => bool) public childExists;\\n\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance\\n    );\\n\\n    function isInstance(address _child) public view returns (bool) {\\n        return childExists[_child];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/engine/AmguConsumer.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../dependencies/DSMath.sol\\\";\\nimport \\\"../dependencies/token/IERC20.sol\\\";\\nimport \\\"../prices/IPriceSource.sol\\\";\\nimport \\\"../version/IVersion.sol\\\";\\nimport \\\"./IEngine.sol\\\";\\nimport \\\"../version/Registry.sol\\\";\\n\\n/// @notice Abstract contracts\\n/// @notice inherit this to pay AMGU on a function call\\nabstract contract AmguConsumer is DSMath {\\n\\n    /// @dev each of these must be implemented by the inheriting contract\\n    function engine() public view virtual returns (address);\\n    function mlnToken() public view virtual returns (address);\\n    function priceSource() public view virtual returns (address);\\n    function registry() public view virtual returns (address);\\n    event AmguPaid(address indexed payer, uint256 totalAmguPaidInEth, uint256 amguChargableGas, uint256 incentivePaid);\\n\\n    /// bool deductIncentive is used when sending extra eth beyond amgu\\n    modifier amguPayable(bool deductIncentive) {\\n        uint preGas = gasleft();\\n        _;\\n        uint postGas = gasleft();\\n\\n        uint mlnPerAmgu = IEngine(engine()).getAmguPrice();\\n        uint mlnQuantity = mul(\\n            mlnPerAmgu,\\n            sub(preGas, postGas)\\n        );\\n        address nativeAsset = Registry(registry()).nativeAsset();\\n        uint ethToPay = IPriceSource(priceSource()).convertQuantity(\\n            mlnQuantity,\\n            mlnToken(),\\n            nativeAsset\\n        );\\n        uint incentiveAmount;\\n        if (deductIncentive) {\\n            incentiveAmount = Registry(registry()).incentive();\\n        } else {\\n            incentiveAmount = 0;\\n        }\\n        require(\\n            msg.value >= add(ethToPay, incentiveAmount),\\n            \\\"Insufficent AMGU and/or incentive\\\"\\n        );\\n        IEngine(engine()).payAmguInEther.value(ethToPay)();\\n\\n        require(\\n            msg.sender.send(\\n                sub(\\n                    sub(msg.value, ethToPay),\\n                    incentiveAmount\\n                )\\n            ),\\n            \\\"Refund failed\\\"\\n        );\\n        emit AmguPaid(msg.sender, ethToPay, sub(preGas, postGas), incentiveAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dependencies/token/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n * Altered from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/ERC20.sol\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address _who) external view returns (uint256);\\n\\n  function allowance(address _owner, address _spender)\\n    external view returns (uint256);\\n\\n  function transfer(address _to, uint256 _value) external returns (bool);\\n\\n  function approve(address _spender, uint256 _value) external returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\\n/// @dev Just adds extra functions that we use elsewhere\\nabstract contract ERC20WithFields is IERC20 {\\n    string public symbol;\\n    string public name;\\n    uint8 public decimals;\\n}\\n\"\r\n    },\r\n    \"src/dependencies/DSMath.sol\": {\r\n      \"content\": \"/// DSMath.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >0.4.13;\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dependencies/TokenUser.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"./token/IERC20.sol\\\";\\nimport \\\"./DSMath.sol\\\";\\n\\n/// @notice Wrapper to ensure tokens are received\\ncontract TokenUser is DSMath {\\n    function safeTransfer(\\n        address _token,\\n        address _to,\\n        uint _value\\n    ) internal {\\n        uint receiverPreBalance = IERC20(_token).balanceOf(_to);\\n        IERC20(_token).transfer(_to, _value);\\n        uint receiverPostBalance = IERC20(_token).balanceOf(_to);\\n        require(\\n            add(receiverPreBalance, _value) == receiverPostBalance,\\n            \\\"Receiver did not receive tokens in transfer\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint _value\\n    ) internal {\\n        uint receiverPreBalance = IERC20(_token).balanceOf(_to);\\n        IERC20(_token).transferFrom(_from, _to, _value);\\n        uint receiverPostBalance = IERC20(_token).balanceOf(_to);\\n        require(\\n            add(receiverPreBalance, _value) == receiverPostBalance,\\n            \\\"Receiver did not receive tokens in transferFrom\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dependencies/token/StandardToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n * Modified from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/StandardToken.sol\\n */\\ncontract StandardToken is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) balances;\\n\\n    mapping (address => mapping (address => uint256)) allowed;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param _owner The address to query the the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public virtual override returns (bool) {\\n        require(_value <= balances[msg.sender]);\\n        require(_to != address(0));\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    * @param _spender The address which will spend the funds.\\n        * @param _value The amount of tokens to be spent.\\n        */\\n    function approve(address _spender, uint256 _value) public virtual override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Transfer tokens from one address to another\\n    * @param _from address The address which you want to send tokens from\\n    * @param _to address The address which you want to transfer to\\n    * @param _value uint256 the amount of tokens to be transferred\\n    */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        require(_value <= balances[_from]);\\n        require(_value <= allowed[_from][msg.sender]);\\n        require(_to != address(0));\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\\n    * approve should be called when allowed[_spender] == 0. To increment\\n    * allowed value is better to use this function to avoid 2 calls (and wait until\\n    * the first transaction is mined)\\n    * From MonolithDAO Token.sol\\n    * @param _spender The address which will spend the funds.\\n    * @param _addedValue The amount of tokens to increase the allowance by.\\n    */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue >= oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Internal function that mints an amount of the token and assigns it to\\n    * an account. This encapsulates the modification of balances such that the\\n    * proper events are emitted.\\n    * @param _account The account that will receive the created tokens.\\n    * @param _amount The amount that will be created.\\n     */\\n    function _mint(address _account, uint256 _amount) internal {\\n        require(_account != address(0));\\n        totalSupply_ = totalSupply_.add(_amount);\\n        balances[_account] = balances[_account].add(_amount);\\n        emit Transfer(address(0), _account, _amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param _account The account whose tokens will be burnt.\\n     * @param _amount The amount that will be burnt.\\n     */\\n    function _burn(address _account, uint256 _amount) internal {\\n        require(_account != address(0));\\n        require(_amount <= balances[_account]);\\n\\n        totalSupply_ = totalSupply_.sub(_amount);\\n        balances[_account] = balances[_account].sub(_amount);\\n        emit Transfer(_account, address(0), _amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender's allowance for said account. Uses the\\n     * internal _burn function.\\n     * @param _account The account whose tokens will be burnt.\\n     * @param _amount The amount that will be burnt.\\n     */\\n    function _burnFrom(address _account, uint256 _amount) internal {\\n        require(_amount <= allowed[_account][msg.sender]);\\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\\n        emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\\n        _burn(_account, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fund/policies/IPolicy.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\ninterface IPolicy {\\n    enum Applied { pre, post }\\n\\n    // In Trading context:\\n    // addresses: Order maker, Order taker, Order maker asset, Order taker asset, Exchange address\\n    // values: Maker token quantity, Taker token quantity, Fill Taker Quantity\\n\\n    // In Participation context:\\n    // address[0]: Investor address, address[3]: Investment asset\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool);\\n\\n    function position() external view returns (Applied);\\n    function identifier() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/fund/hub/Hub.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../../dependencies/DSGuard.sol\\\";\\nimport \\\"./Spoke.sol\\\";\\nimport \\\"../../version/Registry.sol\\\";\\n\\n/// @notice Router for communication between components\\n/// @notice Has one or more Spokes\\ncontract Hub is DSGuard {\\n\\n    event FundShutDown();\\n\\n    struct Routes {\\n        address accounting;\\n        address feeManager;\\n        address participation;\\n        address policyManager;\\n        address shares;\\n        address trading;\\n        address vault;\\n        address registry;\\n        address version;\\n        address engine;\\n        address mlnToken;\\n    }\\n\\n    Routes public routes;\\n    address public manager;\\n    address public creator;\\n    string public name;\\n    bool public isShutDown;\\n    bool public fundInitialized;\\n    uint public creationTime;\\n    mapping (address => bool) public isSpoke;\\n\\n    constructor(address _manager, string memory _name) public {\\n        creator = msg.sender;\\n        manager = _manager;\\n        name = _name;\\n        creationTime = block.timestamp;\\n    }\\n\\n    modifier onlyCreator() {\\n        require(msg.sender == creator, \\\"Only creator can do this\\\");\\n        _;\\n    }\\n\\n    function shutDownFund() external {\\n        require(msg.sender == routes.version);\\n        isShutDown = true;\\n        emit FundShutDown();\\n    }\\n\\n    function initializeAndSetPermissions(address[11] calldata _spokes) external onlyCreator {\\n        require(!fundInitialized, \\\"Fund is already initialized\\\");\\n        for (uint i = 0; i < _spokes.length; i++) {\\n            isSpoke[_spokes[i]] = true;\\n        }\\n        routes.accounting = _spokes[0];\\n        routes.feeManager = _spokes[1];\\n        routes.participation = _spokes[2];\\n        routes.policyManager = _spokes[3];\\n        routes.shares = _spokes[4];\\n        routes.trading = _spokes[5];\\n        routes.vault = _spokes[6];\\n        routes.registry = _spokes[7];\\n        routes.version = _spokes[8];\\n        routes.engine = _spokes[9];\\n        routes.mlnToken = _spokes[10];\\n\\n        Spoke(routes.accounting).initialize(_spokes);\\n        Spoke(routes.feeManager).initialize(_spokes);\\n        Spoke(routes.participation).initialize(_spokes);\\n        Spoke(routes.policyManager).initialize(_spokes);\\n        Spoke(routes.shares).initialize(_spokes);\\n        Spoke(routes.trading).initialize(_spokes);\\n        Spoke(routes.vault).initialize(_spokes);\\n\\n        permit(routes.participation, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\\n        permit(routes.trading, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\\n        permit(routes.participation, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\\n        permit(routes.participation, routes.shares, bytes4(keccak256('destroyFor(address,uint256)')));\\n        permit(routes.feeManager, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\\n        permit(routes.participation, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\\n        permit(routes.trading, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\\n        permit(routes.trading, routes.accounting, bytes4(keccak256('removeFromOwnedAssets(address)')));\\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256('rewardAllFees()')));\\n        permit(manager, routes.policyManager, bytes4(keccak256('register(bytes4,address)')));\\n        permit(manager, routes.policyManager, bytes4(keccak256('batchRegister(bytes4[],address[])')));\\n        permit(manager, routes.participation, bytes4(keccak256('enableInvestment(address[])')));\\n        permit(manager, routes.participation, bytes4(keccak256('disableInvestment(address[])')));\\n        permit(manager, routes.trading, bytes4(keccak256('addExchange(address,address)')));\\n        fundInitialized = true;\\n    }\\n\\n    function vault() external view returns (address) { return routes.vault; }\\n    function accounting() external view returns (address) { return routes.accounting; }\\n    function priceSource() external view returns (address) { return Registry(routes.registry).priceSource(); }\\n    function participation() external view returns (address) { return routes.participation; }\\n    function trading() external view returns (address) { return routes.trading; }\\n    function shares() external view returns (address) { return routes.shares; }\\n    function registry() external view returns (address) { return routes.registry; }\\n    function version() external view returns (address) { return routes.version; }\\n    function policyManager() external view returns (address) { return routes.policyManager; }\\n}\\n\\n\"\r\n    },\r\n    \"src/dependencies/DSAuth.sol\": {\r\n      \"content\": \"/// @notice Modified from DappHub (https://git.io/fpwrq)\\n\\npragma solidity 0.6.1;\\n\\nabstract contract DSAuthority {\\n    function canCall(\\n        address src, address dst, bytes4 sig\\n    ) public view virtual returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority (address indexed authority);\\n    event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority  public  authority;\\n    address      public  owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_)\\n        public\\n        auth\\n    {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_)\\n        public\\n        auth\\n    {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"ds-auth-unauthorized\\\");\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(0)) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fund/fees/FeeManager.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IFee.sol\\\";\\nimport \\\"../hub/Spoke.sol\\\";\\nimport \\\"../shares/Shares.sol\\\";\\nimport \\\"../../factory/Factory.sol\\\";\\nimport \\\"../../version/Registry.sol\\\";\\nimport \\\"../../dependencies/DSMath.sol\\\";\\nimport \\\"./IFeeManager.sol\\\";\\n\\n/// @notice Manages and allocates fees for a particular fund\\ncontract FeeManager is DSMath, Spoke {\\n\\n    event FeeReward(uint shareQuantity);\\n    event FeeRegistration(address fee);\\n\\n    struct FeeInfo {\\n        address feeAddress;\\n        uint feeRate;\\n        uint feePeriod;\\n    }\\n\\n    IFee[] public fees;\\n    mapping (address => bool) public feeIsRegistered;\\n\\n    constructor(address _hub, address _denominationAsset, address[] memory _fees, uint[] memory _rates, uint[] memory _periods, address _registry) Spoke(_hub) public {\\n        for (uint i = 0; i < _fees.length; i++) {\\n            require(\\n                Registry(_registry).isFeeRegistered(_fees[i]),\\n                \\\"Fee must be known to Registry\\\"\\n            );\\n            register(_fees[i], _rates[i], _periods[i], _denominationAsset);\\n        }\\n        if (fees.length > 0) {\\n            require(\\n                fees[0].identifier() == 0,\\n                \\\"Management fee must be at 0 index\\\"\\n            );\\n        }\\n        if (fees.length > 1) {\\n            require(\\n                fees[1].identifier() == 1,\\n                \\\"Performance fee must be at 1 index\\\"\\n            );\\n        }\\n    }\\n\\n    function register(address feeAddress, uint feeRate, uint feePeriod, address denominationAsset) internal {\\n        require(!feeIsRegistered[feeAddress], \\\"Fee already registered\\\");\\n        feeIsRegistered[feeAddress] = true;\\n        fees.push(IFee(feeAddress));\\n        IFee(feeAddress).initializeForUser(feeRate, feePeriod, denominationAsset);  // initialize state\\n        emit FeeRegistration(feeAddress);\\n    }\\n\\n    function totalFeeAmount() external returns (uint total) {\\n        for (uint i = 0; i < fees.length; i++) {\\n            total = add(total, fees[i].feeAmount());\\n        }\\n        return total;\\n    }\\n\\n    /// @dev Shares to be inflated after update state\\n    function _rewardFee(IFee fee) internal {\\n        require(feeIsRegistered[address(fee)], \\\"Fee is not registered\\\");\\n        uint rewardShares = fee.feeAmount();\\n        fee.updateState();\\n        Shares(routes.shares).createFor(hub.manager(), rewardShares);\\n        emit FeeReward(rewardShares);\\n    }\\n\\n    function _rewardAllFees() internal {\\n        for (uint i = 0; i < fees.length; i++) {\\n            _rewardFee(fees[i]);\\n        }\\n    }\\n\\n    /// @dev Used when calling from other components\\n    function rewardAllFees() public auth { _rewardAllFees(); }\\n\\n    /// @dev Convenience function; anyone can reward management fee any time\\n    /// @dev Convention that management fee is 0\\n    function rewardManagementFee() public {\\n        if (fees.length >= 1) _rewardFee(fees[0]);\\n    }\\n\\n    /// @dev Convenience function\\n    /// @dev Convention that management fee is 0\\n    function managementFeeAmount() external returns (uint) {\\n        if (fees.length < 1) return 0;\\n        return fees[0].feeAmount();\\n    }\\n\\n    /// @dev Convenience function\\n    /// @dev Convention that performace fee is 1\\n    function performanceFeeAmount() external returns (uint) {\\n        if (fees.length < 2) return 0;\\n        return fees[1].feeAmount();\\n    }\\n}\\n\\ncontract FeeManagerFactory is Factory {\\n    function createInstance(\\n        address _hub,\\n        address _denominationAsset,\\n        address[] memory _fees,\\n        uint[] memory _feeRates,\\n        uint[] memory _feePeriods,\\n        address _registry\\n    ) public returns (address) {\\n        address feeManager = address(\\n            new FeeManager(_hub, _denominationAsset, _fees, _feeRates, _feePeriods, _registry)\\n        );\\n        childExists[feeManager] = true;\\n        emit NewInstance(_hub, feeManager);\\n        return feeManager;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fund/trading/ITrading.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\npragma experimental ABIEncoderV2;\\n\\n// TODO: Restore indexed params\\n\\n/// @notice Mediation between a Fund and exchanges\\ninterface ITrading {\\n    function callOnExchange(\\n        uint exchangeIndex,\\n        string calldata methodSignature,\\n        address[8] calldata orderAddresses,\\n        uint[8] calldata orderValues,\\n        bytes[4] calldata orderData,\\n        bytes32 identifier,\\n        bytes calldata signature\\n    ) external;\\n\\n    function addOpenMakeOrder(\\n        address ofExchange,\\n        address ofSellAsset,\\n        address ofBuyAsset,\\n        address ofFeeAsset,\\n        uint orderId,\\n        uint expiryTime\\n    ) external;\\n\\n    function removeOpenMakeOrder(\\n        address ofExchange,\\n        address ofSellAsset\\n    ) external;\\n\\n    function updateAndGetQuantityBeingTraded(address _asset) external returns (uint256);\\n    function getOpenMakeOrdersAgainstAsset(address _asset) external view returns (uint256);\\n}\\n\\ninterface ITradingFactory {\\n     function createInstance(\\n        address _hub,\\n        address[] calldata _exchanges,\\n        address[] calldata _adapters,\\n        address _registry\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/version/IVersion.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\ninterface IVersion {\\n    function shutDownFund(address) external;\\n}\\n\\n\"\r\n    },\r\n    \"src/engine/IEngine.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\n\\ninterface IEngine {\\n    function payAmguInEther() external payable;\\n    function getAmguPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/version/Registry.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\nimport \\\"../dependencies/DSAuth.sol\\\";\\nimport \\\"../fund/hub/Hub.sol\\\";\\nimport \\\"../dependencies/token/IERC20.sol\\\";\\n\\ncontract Registry is DSAuth {\\n\\n    // EVENTS\\n    event AssetUpsert (\\n        address indexed asset,\\n        string name,\\n        string symbol,\\n        uint decimals,\\n        string url,\\n        uint reserveMin,\\n        uint[] standards,\\n        bytes4[] sigs\\n    );\\n\\n    event ExchangeAdapterUpsert (\\n        address indexed exchange,\\n        address indexed adapter,\\n        bool takesCustody,\\n        bytes4[] sigs\\n    );\\n\\n    event AssetRemoval (address indexed asset);\\n    event EfxWrapperRegistryChange(address indexed registry);\\n    event EngineChange(address indexed engine);\\n    event ExchangeAdapterRemoval (address indexed exchange);\\n    event IncentiveChange(uint incentiveAmount);\\n    event MGMChange(address indexed MGM);\\n    event MlnTokenChange(address indexed mlnToken);\\n    event NativeAssetChange(address indexed nativeAsset);\\n    event PriceSourceChange(address indexed priceSource);\\n    event VersionRegistration(address indexed version);\\n\\n    // TYPES\\n    struct Asset {\\n        bool exists;\\n        string name;\\n        string symbol;\\n        uint decimals;\\n        string url;\\n        uint reserveMin;\\n        uint[] standards;\\n        bytes4[] sigs;\\n    }\\n\\n    struct Exchange {\\n        bool exists;\\n        address exchangeAddress;\\n        bool takesCustody;\\n        bytes4[] sigs;\\n    }\\n\\n    struct Version {\\n        bool exists;\\n        bytes32 name;\\n    }\\n\\n    // CONSTANTS\\n    uint public constant MAX_REGISTERED_ENTITIES = 20;\\n    uint public constant MAX_FUND_NAME_BYTES = 66;\\n\\n    // FIELDS\\n    mapping (address => Asset) public assetInformation;\\n    address[] public registeredAssets;\\n\\n    // Mapping from adapter address to exchange Information (Adapters are unique)\\n    mapping (address => Exchange) public exchangeInformation;\\n    address[] public registeredExchangeAdapters;\\n\\n    mapping (address => Version) public versionInformation;\\n    address[] public registeredVersions;\\n\\n    mapping (address => bool) public isFeeRegistered;\\n\\n    mapping (address => address) public fundsToVersions;\\n    mapping (bytes32 => bool) public versionNameExists;\\n    mapping (bytes32 => address) public fundNameHashToOwner;\\n\\n\\n    uint public incentive = 10 finney;\\n    address public priceSource;\\n    address public mlnToken;\\n    address public nativeAsset;\\n    address public engine;\\n    address public ethfinexWrapperRegistry;\\n    address public MGM;\\n\\n    modifier onlyVersion() {\\n        require(\\n            versionInformation[msg.sender].exists,\\n            \\\"Only a Version can do this\\\"\\n        );\\n        _;\\n    }\\n\\n    // METHODS\\n\\n    constructor(address _postDeployOwner) public {\\n        setOwner(_postDeployOwner);\\n    }\\n\\n    // PUBLIC METHODS\\n\\n    /// @notice Whether _name has only valid characters\\n    function isValidFundName(string memory _name) public pure returns (bool) {\\n        bytes memory b = bytes(_name);\\n        if (b.length > MAX_FUND_NAME_BYTES) return false;\\n        for (uint i; i < b.length; i++){\\n            bytes1 char = b[i];\\n            if(\\n                !(char >= 0x30 && char <= 0x39) && // 9-0\\n                !(char >= 0x41 && char <= 0x5A) && // A-Z\\n                !(char >= 0x61 && char <= 0x7A) && // a-z\\n                !(char == 0x20 || char == 0x2D) && // space, dash\\n                !(char == 0x2E || char == 0x5F) && // period, underscore\\n                !(char == 0x2A) // *\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Whether _user can use _name for their fund\\n    function canUseFundName(address _user, string memory _name) public view returns (bool) {\\n        bytes32 nameHash = keccak256(bytes(_name));\\n        return (\\n            isValidFundName(_name) &&\\n            (\\n                fundNameHashToOwner[nameHash] == address(0) ||\\n                fundNameHashToOwner[nameHash] == _user\\n            )\\n        );\\n    }\\n\\n    function reserveFundName(address _owner, string calldata _name)\\n        external\\n        onlyVersion\\n    {\\n        require(canUseFundName(_owner, _name), \\\"Fund name cannot be used\\\");\\n        fundNameHashToOwner[keccak256(bytes(_name))] = _owner;\\n    }\\n\\n    function registerFund(address _fund, address _owner, string calldata _name)\\n        external\\n        onlyVersion\\n    {\\n        require(canUseFundName(_owner, _name), \\\"Fund name cannot be used\\\");\\n        fundsToVersions[_fund] = msg.sender;\\n    }\\n\\n    /// @notice Registers an Asset information entry\\n    /// @dev Pre: Only registrar owner should be able to register\\n    /// @dev Post: Address _asset is registered\\n    /// @param _asset Address of asset to be registered\\n    /// @param _name Human-readable name of the Asset\\n    /// @param _symbol Human-readable symbol of the Asset\\n    /// @param _url Url for extended information of the asset\\n    /// @param _standards Integers of EIP standards this asset adheres to\\n    /// @param _sigs Function signatures for whitelisted asset functions\\n    function registerAsset(\\n        address _asset,\\n        string calldata _name,\\n        string calldata _symbol,\\n        string calldata _url,\\n        uint _reserveMin,\\n        uint[] calldata _standards,\\n        bytes4[] calldata _sigs\\n    ) external auth {\\n        require(registeredAssets.length < MAX_REGISTERED_ENTITIES);\\n        require(!assetInformation[_asset].exists);\\n        assetInformation[_asset].exists = true;\\n        registeredAssets.push(_asset);\\n        updateAsset(\\n            _asset,\\n            _name,\\n            _symbol,\\n            _url,\\n            _reserveMin,\\n            _standards,\\n            _sigs\\n        );\\n    }\\n\\n    /// @notice Register an exchange information entry (A mapping from exchange adapter -> Exchange information)\\n    /// @dev Adapters are unique so are used as the mapping key. There may be different adapters for same exchange (0x / Ethfinex)\\n    /// @dev Pre: Only registrar owner should be able to register\\n    /// @dev Post: Address _exchange is registered\\n    /// @param _exchange Address of the exchange for the adapter\\n    /// @param _adapter Address of exchange adapter\\n    /// @param _takesCustody Whether this exchange takes custody of tokens before trading\\n    /// @param _sigs Function signatures for whitelisted exchange functions\\n    function registerExchangeAdapter(\\n        address _exchange,\\n        address _adapter,\\n        bool _takesCustody,\\n        bytes4[] calldata _sigs\\n    ) external auth {\\n        require(!exchangeInformation[_adapter].exists, \\\"Adapter already exists\\\");\\n        exchangeInformation[_adapter].exists = true;\\n        require(registeredExchangeAdapters.length < MAX_REGISTERED_ENTITIES, \\\"Exchange limit reached\\\");\\n        registeredExchangeAdapters.push(_adapter);\\n        updateExchangeAdapter(\\n            _exchange,\\n            _adapter,\\n            _takesCustody,\\n            _sigs\\n        );\\n    }\\n\\n    /// @notice Versions cannot be removed from registry\\n    /// @param _version Address of the version contract\\n    /// @param _name Name of the version\\n    function registerVersion(\\n        address _version,\\n        bytes32 _name\\n    ) external auth {\\n        require(!versionInformation[_version].exists, \\\"Version already exists\\\");\\n        require(!versionNameExists[_name], \\\"Version name already exists\\\");\\n        versionInformation[_version].exists = true;\\n        versionNameExists[_name] = true;\\n        versionInformation[_version].name = _name;\\n        registeredVersions.push(_version);\\n        emit VersionRegistration(_version);\\n    }\\n\\n    function setIncentive(uint _weiAmount) external auth {\\n        incentive = _weiAmount;\\n        emit IncentiveChange(_weiAmount);\\n    }\\n\\n    function setPriceSource(address _priceSource) external auth {\\n        priceSource = _priceSource;\\n        emit PriceSourceChange(_priceSource);\\n    }\\n\\n    function setMlnToken(address _mlnToken) external auth {\\n        mlnToken = _mlnToken;\\n        emit MlnTokenChange(_mlnToken);\\n    }\\n\\n    function setNativeAsset(address _nativeAsset) external auth {\\n        nativeAsset = _nativeAsset;\\n        emit NativeAssetChange(_nativeAsset);\\n    }\\n\\n    function setEngine(address _engine) external auth {\\n        engine = _engine;\\n        emit EngineChange(_engine);\\n    }\\n\\n    function setMGM(address _MGM) external auth {\\n        MGM = _MGM;\\n        emit MGMChange(_MGM);\\n    }\\n\\n    function setEthfinexWrapperRegistry(address _registry) external auth {\\n        ethfinexWrapperRegistry = _registry;\\n        emit EfxWrapperRegistryChange(_registry);\\n    }\\n\\n    /// @notice Updates description information of a registered Asset\\n    /// @dev Pre: Owner can change an existing entry\\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\\n    /// @param _asset Address of the asset to be updated\\n    /// @param _name Human-readable name of the Asset\\n    /// @param _symbol Human-readable symbol of the Asset\\n    /// @param _url Url for extended information of the asset\\n    function updateAsset(\\n        address _asset,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _url,\\n        uint _reserveMin,\\n        uint[] memory _standards,\\n        bytes4[] memory _sigs\\n    ) public auth {\\n        require(assetInformation[_asset].exists);\\n        Asset storage asset = assetInformation[_asset];\\n        asset.name = _name;\\n        asset.symbol = _symbol;\\n        asset.decimals = ERC20WithFields(_asset).decimals();\\n        asset.url = _url;\\n        asset.reserveMin = _reserveMin;\\n        asset.standards = _standards;\\n        asset.sigs = _sigs;\\n        emit AssetUpsert(\\n            _asset,\\n            _name,\\n            _symbol,\\n            asset.decimals,\\n            _url,\\n            _reserveMin,\\n            _standards,\\n            _sigs\\n        );\\n    }\\n\\n    function updateExchangeAdapter(\\n        address _exchange,\\n        address _adapter,\\n        bool _takesCustody,\\n        bytes4[] memory _sigs\\n    ) public auth {\\n        require(exchangeInformation[_adapter].exists, \\\"Exchange with adapter doesn't exist\\\");\\n        Exchange storage exchange = exchangeInformation[_adapter];\\n        exchange.exchangeAddress = _exchange;\\n        exchange.takesCustody = _takesCustody;\\n        exchange.sigs = _sigs;\\n        emit ExchangeAdapterUpsert(\\n            _exchange,\\n            _adapter,\\n            _takesCustody,\\n            _sigs\\n        );\\n    }\\n\\n    /// @notice Deletes an existing entry\\n    /// @dev Owner can delete an existing entry\\n    /// @param _asset address for which specific information is requested\\n    function removeAsset(\\n        address _asset,\\n        uint _assetIndex\\n    ) external auth {\\n        require(assetInformation[_asset].exists);\\n        require(registeredAssets[_assetIndex] == _asset);\\n        delete assetInformation[_asset];\\n        delete registeredAssets[_assetIndex];\\n        for (uint i = _assetIndex; i < registeredAssets.length-1; i++) {\\n            registeredAssets[i] = registeredAssets[i+1];\\n        }\\n        registeredAssets.pop();\\n        emit AssetRemoval(_asset);\\n    }\\n\\n    /// @notice Deletes an existing entry\\n    /// @dev Owner can delete an existing entry\\n    /// @param _adapter address of the adapter of the exchange that is to be removed\\n    /// @param _adapterIndex index of the exchange in array\\n    function removeExchangeAdapter(\\n        address _adapter,\\n        uint _adapterIndex\\n    ) external auth {\\n        require(exchangeInformation[_adapter].exists, \\\"Exchange with adapter doesn't exist\\\");\\n        require(registeredExchangeAdapters[_adapterIndex] == _adapter, \\\"Incorrect adapter index\\\");\\n        delete exchangeInformation[_adapter];\\n        delete registeredExchangeAdapters[_adapterIndex];\\n        for (uint i = _adapterIndex; i < registeredExchangeAdapters.length-1; i++) {\\n            registeredExchangeAdapters[i] = registeredExchangeAdapters[i+1];\\n        }\\n        registeredExchangeAdapters.pop();\\n        emit ExchangeAdapterRemoval(_adapter);\\n    }\\n\\n    function registerFees(address[] calldata _fees) external auth {\\n        for (uint i; i < _fees.length; i++) {\\n            isFeeRegistered[_fees[i]] = true;\\n        }\\n    }\\n\\n    function deregisterFees(address[] calldata _fees) external auth {\\n        for (uint i; i < _fees.length; i++) {\\n            delete isFeeRegistered[_fees[i]];\\n        }\\n    }\\n\\n    // PUBLIC VIEW METHODS\\n\\n    // get asset specific information\\n    function getName(address _asset) external view returns (string memory) {\\n        return assetInformation[_asset].name;\\n    }\\n    function getSymbol(address _asset) external view returns (string memory) {\\n        return assetInformation[_asset].symbol;\\n    }\\n    function getDecimals(address _asset) external view returns (uint) {\\n        return assetInformation[_asset].decimals;\\n    }\\n    function getReserveMin(address _asset) external view returns (uint) {\\n        return assetInformation[_asset].reserveMin;\\n    }\\n    function assetIsRegistered(address _asset) external view returns (bool) {\\n        return assetInformation[_asset].exists;\\n    }\\n    function getRegisteredAssets() external view returns (address[] memory) {\\n        return registeredAssets;\\n    }\\n    function assetMethodIsAllowed(address _asset, bytes4 _sig)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        bytes4[] memory signatures = assetInformation[_asset].sigs;\\n        for (uint i = 0; i < signatures.length; i++) {\\n            if (signatures[i] == _sig) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // get exchange-specific information\\n    function exchangeAdapterIsRegistered(address _adapter) external view returns (bool) {\\n        return exchangeInformation[_adapter].exists;\\n    }\\n    function getRegisteredExchangeAdapters() external view returns (address[] memory) {\\n        return registeredExchangeAdapters;\\n    }\\n    function getExchangeInformation(address _adapter)\\n        public\\n        view\\n        returns (address, bool)\\n    {\\n        Exchange memory exchange = exchangeInformation[_adapter];\\n        return (\\n            exchange.exchangeAddress,\\n            exchange.takesCustody\\n        );\\n    }\\n    function exchangeForAdapter(address _adapter) external view returns (address) {\\n        Exchange memory exchange = exchangeInformation[_adapter];\\n        return exchange.exchangeAddress;\\n    }\\n    function getAdapterFunctionSignatures(address _adapter)\\n        public\\n        view\\n        returns (bytes4[] memory)\\n    {\\n        return exchangeInformation[_adapter].sigs;\\n    }\\n    function adapterMethodIsAllowed(\\n        address _adapter, bytes4 _sig\\n    )\\n        external\\n        view\\n        returns (bool)\\n    {\\n        bytes4[] memory signatures = exchangeInformation[_adapter].sigs;\\n        for (uint i = 0; i < signatures.length; i++) {\\n            if (signatures[i] == _sig) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // get version and fund information\\n    function getRegisteredVersions() external view returns (address[] memory) {\\n        return registeredVersions;\\n    }\\n\\n    function isFund(address _who) external view returns (bool) {\\n        if (fundsToVersions[_who] != address(0)) {\\n            return true; // directly from a hub\\n        } else {\\n            Hub hub = Hub(Spoke(_who).hub());\\n            require(\\n                hub.isSpoke(_who),\\n                \\\"Call from either a spoke or hub\\\"\\n            );\\n            return fundsToVersions[address(hub)] != address(0);\\n        }\\n    }\\n\\n    function isFundFactory(address _who) external view returns (bool) {\\n        return versionInformation[_who].exists;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"src/dependencies/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = _a * _b;\\n    require(c / _a == _b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b <= _a);\\n    uint256 c = _a - _b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    uint256 c = _a + _b;\\n    require(c >= _a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/dependencies/DSGuard.sol\": {\r\n      \"content\": \"/// @notice Retrieved from DappHub (https://git.io/fpwMi)\\n\\npragma solidity 0.6.1;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DSGuardEvents {\\n    event LogPermit(\\n        bytes32 indexed src,\\n        bytes32 indexed dst,\\n        bytes32 indexed sig\\n    );\\n\\n    event LogForbid(\\n        bytes32 indexed src,\\n        bytes32 indexed dst,\\n        bytes32 indexed sig\\n    );\\n}\\n\\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\\n    bytes32 constant public ANY = bytes32(uint(-1));\\n\\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\\n\\n    function canCall(\\n        address src_, address dst_, bytes4 sig\\n    ) public view override returns (bool) {\\n        bytes32 src = bytes32(bytes20(src_));\\n        bytes32 dst = bytes32(bytes20(dst_));\\n\\n        return acl[src][dst][sig]\\n            || acl[src][dst][ANY]\\n            || acl[src][ANY][sig]\\n            || acl[src][ANY][ANY]\\n            || acl[ANY][dst][sig]\\n            || acl[ANY][dst][ANY]\\n            || acl[ANY][ANY][sig]\\n            || acl[ANY][ANY][ANY];\\n    }\\n\\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n        acl[src][dst][sig] = true;\\n        emit LogPermit(src, dst, sig);\\n    }\\n\\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n        acl[src][dst][sig] = false;\\n        emit LogForbid(src, dst, sig);\\n    }\\n\\n    function permit(address src, address dst, bytes32 sig) public {\\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\\n    }\\n    function forbid(address src, address dst, bytes32 sig) public {\\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\\n    }\\n\\n}\\n\\ncontract DSGuardFactory {\\n    mapping (address => bool)  public  isGuard;\\n\\n    function newGuard() public returns (DSGuard guard) {\\n        guard = new DSGuard();\\n        guard.setOwner(msg.sender);\\n        isGuard[address(guard)] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fund/fees/IFee.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\n/// @dev Exposes \\\"feeAmount\\\", which maps fund state and fee state to uint\\n/// @dev Notice that \\\"feeAmount\\\" *may* change contract state\\n/// @dev Also exposes \\\"updateState\\\", which changes fee's internal state\\ninterface IFee {\\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external;\\n    function feeAmount() external returns (uint);\\n    function updateState() external;\\n\\n    /// @notice Used to enforce a convention\\n    function identifier() external view returns (uint);\\n}\\n\\n\"\r\n    },\r\n    \"src/fund/fees/IFeeManager.sol\": {\r\n      \"content\": \"pragma solidity 0.6.1;\\n\\ninterface IFeeManagerFactory {\\n    function createInstance(\\n        address _hub,\\n        address _denominationAsset,\\n        address[] calldata _fees,\\n        uint[] calldata _feeRates,\\n        uint[] calldata _feePeriods,\\n        address _registry\\n    ) external returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_defaultAssets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmguPaidInEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amguChargableGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incentivePaid\",\"type\":\"uint256\"}],\"name\":\"AmguPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requestOwner\",\"type\":\"address\"}],\"name\":\"CancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"name\":\"DisableInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"asset\",\"type\":\"address[]\"}],\"name\":\"EnableInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requestOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investmentAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investmentAmount\",\"type\":\"uint256\"}],\"name\":\"InvestmentRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"assetQuantities\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemedShares\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requestOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investmentAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investmentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedShares\",\"type\":\"uint256\"}],\"name\":\"RequestExecution\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REQUEST_LIFESPAN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHARES_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requestOwner\",\"type\":\"address\"}],\"name\":\"cancelRequestFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"disableInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"enableInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"engine\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requestOwner\",\"type\":\"address\"}],\"name\":\"executeRequestFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHistoricalInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shareQuantity\",\"type\":\"uint256\"}],\"name\":\"getOwedPerformanceFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingShareQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"hasExpiredRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasInvested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"hasRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"hasValidRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"historicalInvestors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hub\",\"outputs\":[{\"internalType\":\"contract Hub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[11]\",\"name\":\"_spokes\",\"type\":\"address[11]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mlnToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shareQuantity\",\"type\":\"uint256\"}],\"name\":\"redeemQuantity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shareQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"requestedAssets\",\"type\":\"address[]\"}],\"name\":\"redeemWithConstraints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"investmentAsset\",\"type\":\"address\"}],\"name\":\"requestInvestment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"investmentAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"accounting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"participation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"policyManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shares\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trading\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"version\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"engine\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mlnToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Participation", "CompilerVersion": "v0.6.1+commit.e6f7d5a4", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000de9dd9db0f38b7a563b40c6e1f4eaefa96123820000000000000000000000000000000000000000000000000000000000000060000000000000000000000000b9cb55c9366a224647b7ff66252b3613185da0b90000000000000000000000000000000000000000000000000000000000000010000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000ec67005c4e498ec7f55e092bd1d35cbc47c91892000000000000000000000000960b236a07cf122663c4303350609a66a7b288c00000000000000000000000000d8775f648430679a709e98d2b0cb6250d2887ef0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd200000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000000f5d2fb29fb7d3cfee444a200298f468908cc9420000000000000000000000009f8f72aa9304c8b593d555f12ef6589cc3a579a20000000000000000000000001985365e9f78359a9b6ad760e32412f4a445e862000000000000000000000000408e41876cccdc0f92210600ef50372656052a38000000000000000000000000607f4c5bb672230e8672085532f7e901544a737500000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f498", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c8c881c31bf73e6260fa333441b2a86f898fe182daeacbdee21155d2d6683c2d"}