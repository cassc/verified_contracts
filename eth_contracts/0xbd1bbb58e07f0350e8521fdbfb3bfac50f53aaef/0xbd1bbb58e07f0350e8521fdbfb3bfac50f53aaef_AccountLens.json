{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Lens/AccountLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IAllowanceTransfer} from \\\"permit2/src/interfaces/IAllowanceTransfer.sol\\\";\\nimport {IEVC} from \\\"ethereum-vault-connector/interfaces/IEthereumVaultConnector.sol\\\";\\nimport {IRewardStreams} from \\\"reward-streams/interfaces/IRewardStreams.sol\\\";\\nimport {IEVault} from \\\"evk/EVault/IEVault.sol\\\";\\nimport {Errors} from \\\"evk/EVault/shared/Errors.sol\\\";\\nimport {Utils} from \\\"./Utils.sol\\\";\\nimport \\\"./LensTypes.sol\\\";\\n\\ncontract AccountLens is Utils {\\n    function getAccountInfo(address account, address vault) public view returns (AccountInfo memory) {\\n        AccountInfo memory result;\\n\\n        result.evcAccountInfo = getEVCAccountInfo(IEVault(vault).EVC(), account);\\n        result.vaultAccountInfo = getVaultAccountInfo(account, vault);\\n        result.accountRewardInfo = getRewardAccountInfo(account, vault);\\n\\n        return result;\\n    }\\n\\n    function getAccountEnabledVaultsInfo(address evc, address account)\\n        public\\n        view\\n        returns (AccountMultipleVaultsInfo memory)\\n    {\\n        AccountMultipleVaultsInfo memory result;\\n\\n        result.evcAccountInfo = getEVCAccountInfo(evc, account);\\n\\n        uint256 controllersLength = result.evcAccountInfo.enabledControllers.length;\\n        uint256 collateralsLength = result.evcAccountInfo.enabledCollaterals.length;\\n\\n        uint256 counter = collateralsLength;\\n        for (uint256 i = 0; i < controllersLength; ++i) {\\n            if (!IEVC(evc).isCollateralEnabled(account, result.evcAccountInfo.enabledControllers[i])) {\\n                ++counter;\\n            }\\n        }\\n\\n        result.vaultAccountInfo = new VaultAccountInfo[](counter);\\n        result.accountRewardInfo = new AccountRewardInfo[](counter);\\n\\n        for (uint256 i = 0; i < controllersLength; ++i) {\\n            result.vaultAccountInfo[i] = getVaultAccountInfo(account, result.evcAccountInfo.enabledControllers[i]);\\n            result.accountRewardInfo[i] = getRewardAccountInfo(account, result.evcAccountInfo.enabledControllers[i]);\\n        }\\n\\n        counter = controllersLength;\\n        for (uint256 i = 0; i < collateralsLength; ++i) {\\n            VaultAccountInfo memory vaultAccountInfo =\\n                getVaultAccountInfo(account, result.evcAccountInfo.enabledCollaterals[i]);\\n\\n            if (!vaultAccountInfo.isController) {\\n                result.vaultAccountInfo[counter] = vaultAccountInfo;\\n                result.accountRewardInfo[counter] =\\n                    getRewardAccountInfo(account, result.evcAccountInfo.enabledCollaterals[i]);\\n                ++counter;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function getEVCAccountInfo(address evc, address account) public view returns (EVCAccountInfo memory) {\\n        EVCAccountInfo memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.evc = evc;\\n        result.account = account;\\n        result.addressPrefix = IEVC(evc).getAddressPrefix(account);\\n        result.owner = IEVC(evc).getAccountOwner(account);\\n\\n        result.isLockdownMode = IEVC(evc).isLockdownMode(result.addressPrefix);\\n        result.isPermitDisabledMode = IEVC(evc).isPermitDisabledMode(result.addressPrefix);\\n        result.lastAccountStatusCheckTimestamp = IEVC(evc).getLastAccountStatusCheckTimestamp(account);\\n        result.enabledControllers = IEVC(evc).getControllers(account);\\n        result.enabledCollaterals = IEVC(evc).getCollaterals(account);\\n\\n        return result;\\n    }\\n\\n    function getVaultAccountInfo(address account, address vault) public view returns (VaultAccountInfo memory) {\\n        VaultAccountInfo memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.account = account;\\n        result.vault = vault;\\n\\n        (bool success, bytes memory data) = vault.staticcall(abi.encodeCall(IEVault(vault).asset, ()));\\n\\n        if (!success || data.length < 32) {\\n            return result;\\n        }\\n\\n        result.asset = abi.decode(data, (address));\\n\\n        result.assetsAccount = IEVault(result.asset).balanceOf(account);\\n        result.shares = IEVault(vault).balanceOf(account);\\n        result.assets = IEVault(vault).convertToAssets(result.shares);\\n        result.borrowed = IEVault(vault).debtOf(account);\\n\\n        result.assetAllowanceVault = IEVault(result.asset).allowance(account, vault);\\n\\n        address permit2 = IEVault(vault).permit2Address();\\n        if (permit2 != address(0)) {\\n            (result.assetAllowanceVaultPermit2, result.assetAllowanceExpirationVaultPermit2,) =\\n                IAllowanceTransfer(permit2).allowance(account, result.asset, vault);\\n\\n            result.assetAllowancePermit2 = IEVault(result.asset).allowance(account, permit2);\\n        }\\n\\n        result.balanceForwarderEnabled = IEVault(vault).balanceForwarderEnabled(account);\\n\\n        address evc = IEVault(vault).EVC();\\n        result.isController = IEVC(evc).isControllerEnabled(account, vault);\\n        result.isCollateral = IEVC(evc).isCollateralEnabled(account, vault);\\n\\n        (success, data) = vault.staticcall(abi.encodeCall(IEVault(vault).accountLiquidity, (account, false)));\\n\\n        if (success) {\\n            (result.liquidityInfo.collateralValueBorrowing, result.liquidityInfo.liabilityValue) =\\n                abi.decode(data, (uint256, uint256));\\n        } else {\\n            result.liquidityInfo.queryFailure = true;\\n            result.liquidityInfo.queryFailureReason = data;\\n        }\\n\\n        (success, data) = vault.staticcall(abi.encodeCall(IEVault(vault).accountLiquidity, (account, true)));\\n\\n        if (success) {\\n            (result.liquidityInfo.collateralValueLiquidation,) = abi.decode(data, (uint256, uint256));\\n        } else {\\n            result.liquidityInfo.queryFailure = true;\\n        }\\n\\n        (success, data) = vault.staticcall(abi.encodeCall(IEVault(vault).accountLiquidityFull, (account, false)));\\n\\n        address[] memory collaterals;\\n        uint256[] memory collateralValues;\\n        if (success) {\\n            (collaterals, collateralValues,) = abi.decode(data, (address[], uint256[], uint256));\\n\\n            result.liquidityInfo.collateralLiquidityBorrowingInfo = new CollateralLiquidityInfo[](collaterals.length);\\n\\n            for (uint256 i = 0; i < collaterals.length; ++i) {\\n                result.liquidityInfo.collateralLiquidityBorrowingInfo[i].collateral = collaterals[i];\\n                result.liquidityInfo.collateralLiquidityBorrowingInfo[i].collateralValue = collateralValues[i];\\n            }\\n        } else {\\n            result.liquidityInfo.queryFailure = true;\\n        }\\n\\n        (success, data) = vault.staticcall(abi.encodeCall(IEVault(vault).accountLiquidityFull, (account, true)));\\n\\n        if (success) {\\n            (collaterals, collateralValues,) = abi.decode(data, (address[], uint256[], uint256));\\n\\n            result.liquidityInfo.collateralLiquidityLiquidationInfo = new CollateralLiquidityInfo[](collaterals.length);\\n\\n            for (uint256 i = 0; i < collaterals.length; ++i) {\\n                result.liquidityInfo.collateralLiquidityLiquidationInfo[i].collateral = collaterals[i];\\n                result.liquidityInfo.collateralLiquidityLiquidationInfo[i].collateralValue = collateralValues[i];\\n            }\\n        } else {\\n            result.liquidityInfo.queryFailure = true;\\n        }\\n\\n        if (!result.liquidityInfo.queryFailure) {\\n            result.liquidityInfo.timeToLiquidation =\\n                _calculateTimeToLiquidation(vault, result.liquidityInfo.liabilityValue, collaterals, collateralValues);\\n        }\\n\\n        return result;\\n    }\\n\\n    function getTimeToLiquidation(address account, address vault) public view returns (int256) {\\n        address[] memory collaterals;\\n        uint256[] memory collateralValues;\\n        uint256 liabilityValue;\\n\\n        // get detailed collateral values and liability value\\n        try IEVault(vault).accountLiquidityFull(account, true) returns (\\n            address[] memory _collaterals, uint256[] memory _collateralValues, uint256 _liabilityValue\\n        ) {\\n            collaterals = _collaterals;\\n            collateralValues = _collateralValues;\\n            liabilityValue = _liabilityValue;\\n        } catch (bytes memory reason) {\\n            if (bytes4(reason) != Errors.E_NoLiability.selector) return TTL_ERROR;\\n        }\\n\\n        return _calculateTimeToLiquidation(vault, liabilityValue, collaterals, collateralValues);\\n    }\\n\\n    function getRewardAccountInfo(address account, address vault) public view returns (AccountRewardInfo memory) {\\n        AccountRewardInfo memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.account = account;\\n        result.vault = vault;\\n\\n        result.balanceTracker = IEVault(vault).balanceTrackerAddress();\\n        result.balanceForwarderEnabled = IEVault(vault).balanceForwarderEnabled(account);\\n\\n        if (result.balanceTracker == address(0)) return result;\\n\\n        result.balance = IRewardStreams(result.balanceTracker).balanceOf(account, vault);\\n\\n        address[] memory enabledRewards = IRewardStreams(result.balanceTracker).enabledRewards(account, vault);\\n        result.enabledRewardsInfo = new EnabledRewardInfo[](enabledRewards.length);\\n\\n        for (uint256 i; i < enabledRewards.length; ++i) {\\n            result.enabledRewardsInfo[i].reward = enabledRewards[i];\\n\\n            result.enabledRewardsInfo[i].earnedReward =\\n                IRewardStreams(result.balanceTracker).earnedReward(account, vault, enabledRewards[i], false);\\n\\n            result.enabledRewardsInfo[i].earnedRewardRecentIgnored =\\n                IRewardStreams(result.balanceTracker).earnedReward(account, vault, enabledRewards[i], true);\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/lib/permit2/src/interfaces/IAllowanceTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IEIP712} from \\\"./IEIP712.sol\\\";\\n\\n/// @title AllowanceTransfer\\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface IAllowanceTransfer is IEIP712 {\\n    /// @notice Thrown when an allowance on a token has expired.\\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\\n    error AllowanceExpired(uint256 deadline);\\n\\n    /// @notice Thrown when an allowance on a token has been depleted.\\n    /// @param amount The maximum amount allowed\\n    error InsufficientAllowance(uint256 amount);\\n\\n    /// @notice Thrown when too many nonces are invalidated.\\n    error ExcessiveInvalidation();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\\n    event NonceInvalidation(\\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\\n    );\\n\\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\\n    event Approval(\\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\\n    );\\n\\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\\n    event Permit(\\n        address indexed owner,\\n        address indexed token,\\n        address indexed spender,\\n        uint160 amount,\\n        uint48 expiration,\\n        uint48 nonce\\n    );\\n\\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\\n    event Lockdown(address indexed owner, address token, address spender);\\n\\n    /// @notice The permit data for a token\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice The permit message signed for a single token allowance\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice The permit message signed for multiple token allowances\\n    struct PermitBatch {\\n        // the permit data for multiple token allowances\\n        PermitDetails[] details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice The saved permissions\\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    struct PackedAllowance {\\n        // amount allowed\\n        uint160 amount;\\n        // permission expiry\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice A token spender pair.\\n    struct TokenSpenderPair {\\n        // the token the spender is approved\\n        address token;\\n        // the spender address\\n        address spender;\\n    }\\n\\n    /// @notice Details for a token transfer.\\n    struct AllowanceTransferDetails {\\n        // the owner of the token\\n        address from;\\n        // the recipient of the token\\n        address to;\\n        // the amount of the token\\n        uint160 amount;\\n        // the token to be transferred\\n        address token;\\n    }\\n\\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\\n    function allowance(address user, address token, address spender)\\n        external\\n        view\\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\\n\\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\\n    /// @param token The token to approve\\n    /// @param spender The spender address to approve\\n    /// @param amount The approved amount of the token\\n    /// @param expiration The timestamp at which the approval is no longer valid\\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\\n\\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\\n\\n    /// @notice Transfer approved tokens from one address to another\\n    /// @param from The address to transfer from\\n    /// @param to The address of the recipient\\n    /// @param amount The amount of the token to transfer\\n    /// @param token The token address to transfer\\n    /// @dev Requires the from address to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(address from, address to, uint160 amount, address token) external;\\n\\n    /// @notice Transfer approved tokens in a batch\\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\\n    /// @dev Requires the from addresses to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\\n\\n    /// @notice Enables performing a \\\"lockdown\\\" of the sender's Permit2 identity\\n    /// by batch revoking approvals\\n    /// @param approvals Array of approvals to revoke.\\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\\n\\n    /// @notice Invalidate nonces for a given (token, spender) pair\\n    /// @param token The token to invalidate nonces for\\n    /// @param spender The spender to invalidate nonces for\\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\\n}\\n\"\r\n    },\r\n    \"lib/ethereum-vault-connector/src/interfaces/IEthereumVaultConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IEVC\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Ethereum Vault Connector.\\ninterface IEVC {\\n    /// @notice A struct representing a batch item.\\n    /// @dev Each batch item represents a single operation to be performed within a checks deferred context.\\n    struct BatchItem {\\n        /// @notice The target contract to be called.\\n        address targetContract;\\n        /// @notice The account on behalf of which the operation is to be performed. msg.sender must be authorized to\\n        /// act on behalf of this account. Must be address(0) if the target contract is the EVC itself.\\n        address onBehalfOfAccount;\\n        /// @notice The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n        /// balance of the EVC contract will be forwarded. Must be 0 if the target contract is the EVC itself.\\n        uint256 value;\\n        /// @notice The encoded data which is called on the target contract.\\n        bytes data;\\n    }\\n\\n    /// @notice A struct representing the result of a batch item operation.\\n    /// @dev Used only for simulation purposes.\\n    struct BatchItemResult {\\n        /// @notice A boolean indicating whether the operation was successful.\\n        bool success;\\n        /// @notice The result of the operation.\\n        bytes result;\\n    }\\n\\n    /// @notice A struct representing the result of the account or vault status check.\\n    /// @dev Used only for simulation purposes.\\n    struct StatusCheckResult {\\n        /// @notice The address of the account or vault for which the check was performed.\\n        address checkedAddress;\\n        /// @notice A boolean indicating whether the status of the account or vault is valid.\\n        bool isValid;\\n        /// @notice The result of the check.\\n        bytes result;\\n    }\\n\\n    /// @notice Returns current raw execution context.\\n    /// @dev When checks in progress, on behalf of account is always address(0).\\n    /// @return context Current raw execution context.\\n    function getRawExecutionContext() external view returns (uint256 context);\\n\\n    /// @notice Returns an account on behalf of which the operation is being executed at the moment and whether the\\n    /// controllerToCheck is an enabled controller for that account.\\n    /// @dev This function should only be used by external smart contracts if msg.sender is the EVC. Otherwise, the\\n    /// account address returned must not be trusted.\\n    /// @dev When checks in progress, on behalf of account is always address(0). When address is zero, the function\\n    /// reverts to protect the consumer from ever relying on the on behalf of account address which is in its default\\n    /// state.\\n    /// @param controllerToCheck The address of the controller for which it is checked whether it is an enabled\\n    /// controller for the account on behalf of which the operation is being executed at the moment.\\n    /// @return onBehalfOfAccount An account that has been authenticated and on behalf of which the operation is being\\n    /// executed at the moment.\\n    /// @return controllerEnabled A boolean value that indicates whether controllerToCheck is an enabled controller for\\n    /// the account on behalf of which the operation is being executed at the moment. Always false if controllerToCheck\\n    /// is address(0).\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled);\\n\\n    /// @notice Checks if checks are deferred.\\n    /// @return A boolean indicating whether checks are deferred.\\n    function areChecksDeferred() external view returns (bool);\\n\\n    /// @notice Checks if checks are in progress.\\n    /// @return A boolean indicating whether checks are in progress.\\n    function areChecksInProgress() external view returns (bool);\\n\\n    /// @notice Checks if control collateral is in progress.\\n    /// @return A boolean indicating whether control collateral is in progress.\\n    function isControlCollateralInProgress() external view returns (bool);\\n\\n    /// @notice Checks if an operator is authenticated.\\n    /// @return A boolean indicating whether an operator is authenticated.\\n    function isOperatorAuthenticated() external view returns (bool);\\n\\n    /// @notice Checks if a simulation is in progress.\\n    /// @return A boolean indicating whether a simulation is in progress.\\n    function isSimulationInProgress() external view returns (bool);\\n\\n    /// @notice Checks whether the specified account and the other account have the same owner.\\n    /// @dev The function is used to check whether one account is authorized to perform operations on behalf of the\\n    /// other. Accounts are considered to have a common owner if they share the first 19 bytes of their address.\\n    /// @param account The address of the account that is being checked.\\n    /// @param otherAccount The address of the other account that is being checked.\\n    /// @return A boolean flag that indicates whether the accounts have the same owner.\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool);\\n\\n    /// @notice Returns the address prefix of the specified account.\\n    /// @dev The address prefix is the first 19 bytes of the account address.\\n    /// @param account The address of the account whose address prefix is being retrieved.\\n    /// @return A bytes19 value that represents the address prefix of the account.\\n    function getAddressPrefix(address account) external pure returns (bytes19);\\n\\n    /// @notice Returns the owner for the specified account.\\n    /// @dev The function returns address(0) if the owner is not registered. Registration of the owner happens on the\\n    /// initial\\n    /// interaction with the EVC that requires authentication of an owner.\\n    /// @param account The address of the account whose owner is being retrieved.\\n    /// @return owner The address of the account owner. An account owner is an EOA/smart contract which address matches\\n    /// the first 19 bytes of the account address.\\n    function getAccountOwner(address account) external view returns (address);\\n\\n    /// @notice Checks if lockdown mode is enabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for lockdown mode status.\\n    /// @return A boolean indicating whether lockdown mode is enabled.\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Checks if permit functionality is disabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for permit functionality status.\\n    /// @return A boolean indicating whether permit functionality is disabled.\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Returns the current nonce for a given address prefix and nonce namespace.\\n    /// @dev Each nonce namespace provides 256 bit nonce that has to be used sequentially. There's no requirement to use\\n    /// all the nonces for a given nonce namespace before moving to the next one which allows to use permit messages in\\n    /// a non-sequential manner.\\n    /// @param addressPrefix The address prefix for which the nonce is being retrieved.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being retrieved.\\n    /// @return nonce The current nonce for the given address prefix and nonce namespace.\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256 nonce);\\n\\n    /// @notice Returns the bit field for a given address prefix and operator.\\n    /// @dev The bit field is used to store information about authorized operators for a given address prefix. Each bit\\n    /// in the bit field corresponds to one account belonging to the same owner. If the bit is set, the operator is\\n    /// authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being retrieved.\\n    /// @param operator The address of the operator for which the bit field is being retrieved.\\n    /// @return operatorBitField The bit field for the given address prefix and operator. The bit field defines which\\n    /// accounts the operator is authorized for. It is a 256-position binary array like 0...010...0, marking the account\\n    /// positionally in a uint256. The position in the bit field corresponds to the account ID (0-255), where 0 is the\\n    /// owner account's ID.\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256 operatorBitField);\\n\\n    /// @notice Returns whether a given operator has been authorized for a given account.\\n    /// @param account The address of the account whose operator is being checked.\\n    /// @param operator The address of the operator that is being checked.\\n    /// @return authorized A boolean value that indicates whether the operator is authorized for the account.\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool authorized);\\n\\n    /// @notice Enables or disables lockdown mode for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or\\n    /// permit message.\\n    /// @param addressPrefix The address prefix for which the lockdown mode is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable lockdown mode.\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Enables or disables permit functionality for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or (by\\n    /// definition) permit message. To support permit functionality by default, note that the logic was inverted here. To\\n    /// disable  the permit functionality, one must pass true as the second argument. To enable the permit\\n    /// functionality, one must pass false as the second argument.\\n    /// @param addressPrefix The address prefix for which the permit functionality is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable the disable-permit mode.\\n    function setPermitDisabledMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Sets the nonce for a given address prefix and nonce namespace.\\n    /// @dev This function can only be called by the owner of the address prefix. Each nonce namespace provides a 256\\n    /// bit nonce that has to be used sequentially. There's no requirement to use all the nonces for a given nonce\\n    /// namespace before moving to the next one which allows the use of permit messages in a non-sequential manner. To\\n    /// invalidate signed permit messages, set the nonce for a given nonce namespace accordingly. To invalidate all the\\n    /// permit messages for a given nonce namespace, set the nonce to type(uint).max.\\n    /// @param addressPrefix The address prefix for which the nonce is being set.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being set.\\n    /// @param nonce The new nonce for the given address prefix and nonce namespace.\\n    function setNonce(bytes19 addressPrefix, uint256 nonceNamespace, uint256 nonce) external payable;\\n\\n    /// @notice Sets the bit field for a given address prefix and operator.\\n    /// @dev This function can only be called by the owner of the address prefix. Each bit in the bit field corresponds\\n    /// to one account belonging to the same owner. If the bit is set, the operator is authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being set.\\n    /// @param operator The address of the operator for which the bit field is being set. Can neither be the EVC address\\n    /// nor an address belonging to the same address prefix.\\n    /// @param operatorBitField The new bit field for the given address prefix and operator. Reverts if the provided\\n    /// value is equal to the currently stored value.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) external payable;\\n\\n    /// @notice Authorizes or deauthorizes an operator for the account.\\n    /// @dev Only the owner or authorized operator of the account can call this function. An operator is an address that\\n    /// can perform actions for an account on behalf of the owner. If it's an operator calling this function, it can\\n    /// only deauthorize itself.\\n    /// @param account The address of the account whose operator is being set or unset.\\n    /// @param operator The address of the operator that is being installed or uninstalled. Can neither be the EVC\\n    /// address nor an address belonging to the same owner as the account.\\n    /// @param authorized A boolean value that indicates whether the operator is being authorized or deauthorized.\\n    /// Reverts if the provided value is equal to the currently stored value.\\n    function setAccountOperator(address account, address operator, bool authorized) external payable;\\n\\n    /// @notice Returns an array of collaterals enabled for an account.\\n    /// @dev A collateral is a vault for which an account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account whose collaterals are being queried.\\n    /// @return An array of addresses that are enabled collaterals for the account.\\n    function getCollaterals(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a collateral is enabled for an account.\\n    /// @dev A collateral is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the collateral that is being checked.\\n    /// @return A boolean value that indicates whether the vault is an enabled collateral for the account or not.\\n    function isCollateralEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a collateral for an account.\\n    /// @dev A collaterals is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. Unless it's a duplicate,\\n    /// the collateral is added to the end of the array. There can be at most 10 unique collaterals enabled at a time.\\n    /// Account status checks are performed.\\n    /// @param account The account address for which the collateral is being enabled.\\n    /// @param vault The address being enabled as a collateral.\\n    function enableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Disables a collateral for an account.\\n    /// @dev This function does not preserve the order of collaterals in the array obtained using the getCollaterals\\n    /// function; the order may change. A collateral is a vault for which account\u2019s balances are under the control of\\n    /// the currently enabled controller vault. Only the owner or an operator of the account can call this function.\\n    /// Disabling a collateral might change the order of collaterals in the array obtained using getCollaterals\\n    /// function. Account status checks are performed.\\n    /// @param account The account address for which the collateral is being disabled.\\n    /// @param vault The address of a collateral being disabled.\\n    function disableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Swaps the position of two collaterals so that they appear switched in the array of collaterals for a\\n    /// given account obtained by calling getCollaterals function.\\n    /// @dev A collateral is a vault for which account\u2019s balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. The order of collaterals\\n    /// can be changed by specifying the indices of the two collaterals to be swapped. Indices are zero-based and must\\n    /// be in the range of 0 to the number of collaterals minus 1. index1 must be lower than index2. Account status\\n    /// checks are performed.\\n    /// @param account The address of the account for which the collaterals are being reordered.\\n    /// @param index1 The index of the first collateral to be swapped.\\n    /// @param index2 The index of the second collateral to be swapped.\\n    function reorderCollaterals(address account, uint8 index1, uint8 index2) external payable;\\n\\n    /// @notice Returns an array of enabled controllers for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over the account's\\n    /// balances in enabled collaterals vaults. A user can have multiple controllers during a call execution, but at\\n    /// most one can be selected when the account status check is performed.\\n    /// @param account The address of the account whose controllers are being queried.\\n    /// @return An array of addresses that are the enabled controllers for the account.\\n    function getControllers(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a controller is enabled for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the controller that is being checked.\\n    /// @return A boolean value that indicates whether the vault is enabled controller for the account or not.\\n    function isControllerEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults. Only the owner or an operator of the account can call this function.\\n    /// Unless it's a duplicate, the controller is added to the end of the array. Transiently, there can be at most 10\\n    /// unique controllers enabled at a time, but at most one can be enabled after the outermost checks-deferrable\\n    /// call concludes. Account status checks are performed.\\n    /// @param account The address for which the controller is being enabled.\\n    /// @param vault The address of the controller being enabled.\\n    function enableController(address account, address vault) external payable;\\n\\n    /// @notice Disables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults. Only the vault itself can call this function. Disabling a controller\\n    /// might change the order of controllers in the array obtained using getControllers function. Account status checks\\n    /// are performed.\\n    /// @param account The address for which the calling controller is being disabled.\\n    function disableController(address account) external payable;\\n\\n    /// @notice Executes signed arbitrary data by self-calling into the EVC.\\n    /// @dev Low-level call function is used to execute the arbitrary data signed by the owner or the operator on the\\n    /// EVC contract. During that call, EVC becomes msg.sender.\\n    /// @param signer The address signing the permit message (ECDSA) or verifying the permit message signature\\n    /// (ERC-1271). It's also the owner or the operator of all the accounts for which authentication will be needed\\n    /// during the execution of the arbitrary data call.\\n    /// @param sender The address of the msg.sender which is expected to execute the data signed by the signer. If\\n    /// address(0) is passed, the msg.sender is ignored.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being used.\\n    /// @param nonce The nonce for the given account and nonce namespace. A valid nonce value is considered to be the\\n    /// value currently stored and can take any value between 0 and type(uint256).max - 1.\\n    /// @param deadline The timestamp after which the permit is considered expired.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is self-called on the EVC contract.\\n    /// @param signature The signature of the data signed by the signer.\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external payable;\\n\\n    /// @notice Calls into a target contract as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred. If the target contract\\n    /// is msg.sender, msg.sender is called back with the calldata provided and the context set up according to the\\n    /// account provided. If the target contract is not msg.sender, only the owner or the operator of the account\\n    /// provided can call this function.\\n    /// @dev This function can be used to recover the remaining value from the EVC contract.\\n    /// @param targetContract The address of the contract to be called.\\n    /// @param onBehalfOfAccount  If the target contract is msg.sender, the address of the account which will be set\\n    /// in the context. It assumes msg.sender has authenticated the account themselves. If the target contract is\\n    /// not msg.sender, the address of the account for which it is checked whether msg.sender is authorized to act\\n    /// on behalf of.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target contract.\\n    /// @return result The result of the call.\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice For a given account, calls into one of the enabled collateral vaults from the currently enabled\\n    /// controller vault as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred as long as the contract\\n    /// is enabled as a collateral of the account and the msg.sender is the only enabled controller of the account.\\n    /// @param targetCollateral The collateral address to be called.\\n    /// @param onBehalfOfAccount The address of the account for which it is checked whether msg.sender is authorized to\\n    /// act on behalf.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target collateral.\\n    /// @return result The result of the call.\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev The authentication rules for each batch item are the same as for the call function.\\n    /// @param items An array of batch items to be executed.\\n    function batch(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function always reverts as it's only used for simulation purposes. This function cannot be called\\n    /// within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    function batchRevert(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function does not modify state and should only be used for simulation purposes. This function cannot\\n    /// be called within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    /// @return batchItemsResult An array of batch item results for each item.\\n    /// @return accountsStatusCheckResult An array of account status check results for each account.\\n    /// @return vaultsStatusCheckResult An array of vault status check results for each vault.\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        );\\n\\n    /// @notice Retrieves the timestamp of the last successful account status check performed for a specific account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @dev The account status check is considered to be successful if it calls into the selected controller vault and\\n    /// obtains expected magic value. This timestamp does not change if the account status is considered valid when no\\n    /// controller enabled. When consuming, one might need to ensure that the account status check is not deferred at\\n    /// the moment.\\n    /// @param account The address of the account for which the last status check timestamp is being queried.\\n    /// @return The timestamp of the last status check as a uint256.\\n    function getLastAccountStatusCheckTimestamp(address account) external view returns (uint256);\\n\\n    /// @notice Checks whether the status check is deferred for a given account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param account The address of the account for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isAccountStatusCheckDeferred(address account) external view returns (bool);\\n\\n    /// @notice Checks the status of an account and reverts if it is not valid.\\n    /// @dev If checks deferred, the account is added to the set of accounts to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique accounts added to the set at a time. Account status\\n    /// check is performed by calling into the selected controller vault and passing the array of currently enabled\\n    /// collaterals. If controller is not selected, the account is always considered valid.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Forgives previously deferred account status check.\\n    /// @dev Account address is removed from the set of addresses for which status checks are deferred. This function\\n    /// can only be called by the currently enabled controller of a given account. Depending on the vault\\n    /// implementation, may be needed in the liquidation flow.\\n    /// @param account The address of the account for which the status check is forgiven.\\n    function forgiveAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Checks whether the status check is deferred for a given vault.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param vault The address of the vault for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool);\\n\\n    /// @notice Checks the status of a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the vault is added to the set of vaults to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique vaults added to the set at a time. This function can\\n    /// only be called by the vault itself.\\n    function requireVaultStatusCheck() external payable;\\n\\n    /// @notice Forgives previously deferred vault status check.\\n    /// @dev Vault address is removed from the set of addresses for which status checks are deferred. This function can\\n    /// only be called by the vault itself.\\n    function forgiveVaultStatusCheck() external payable;\\n\\n    /// @notice Checks the status of an account and a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the account and the vault are added to the respective sets of accounts and vaults to be\\n    /// checked at the end of the outermost checks-deferrable call. Account status check is performed by calling into\\n    /// selected controller vault and passing the array of currently enabled collaterals. If controller is not selected,\\n    /// the account is always considered valid. This function can only be called by the vault itself.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountAndVaultStatusCheck(address account) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/reward-streams/src/interfaces/IRewardStreams.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IBalanceTracker.sol\\\";\\n\\n/// @title IRewardStreams\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface for Reward Streams distributor contract.\\ninterface IRewardStreams {\\n    function EPOCH_DURATION() external view returns (uint256);\\n    function MAX_EPOCHS_AHEAD() external view returns (uint256);\\n    function MAX_DISTRIBUTION_LENGTH() external view returns (uint256);\\n    function MAX_REWARDS_ENABLED() external view returns (uint256);\\n    function registerReward(address rewarded, address reward, uint48 startEpoch, uint128[] calldata rewardAmounts) external;\\n    function updateReward(address rewarded, address reward, address recipient) external returns (uint256);\\n    function claimReward(address rewarded, address reward, address recipient, bool ignoreRecentReward) external returns (uint256);\\n    function enableReward(address rewarded, address reward) external returns (bool);\\n    function disableReward(address rewarded, address reward, bool forfeitRecentReward) external returns (bool);\\n    function earnedReward(address account, address rewarded, address reward, bool ignoreRecentReward) external view returns (uint256);\\n    function enabledRewards(address account, address rewarded) external view returns (address[] memory);\\n    function isRewardEnabled(address account, address rewarded, address reward) external view returns (bool);\\n    function balanceOf(address account, address rewarded) external view returns (uint256);\\n    function rewardAmount(address rewarded, address reward) external view returns (uint256);\\n    function totalRewardedEligible(address rewarded, address reward) external view returns (uint256);\\n    function totalRewardRegistered(address rewarded, address reward) external view returns (uint256);\\n    function totalRewardClaimed(address rewarded, address reward) external view returns (uint256);\\n    function rewardAmount(address rewarded, address reward, uint48 epoch) external view returns (uint256);\\n    function currentEpoch() external view returns (uint48);\\n    function getEpoch(uint48 timestamp) external view returns (uint48);\\n    function getEpochStartTimestamp(uint48 epoch) external view returns (uint48);\\n    function getEpochEndTimestamp(uint48 epoch) external view returns (uint48);\\n}\\n\\n/// @title ITrackingRewardStreams\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface for Tracking Reward Streams. Extends `IRewardStreams` and `IBalanceTracker`.\\ninterface ITrackingRewardStreams is IRewardStreams, IBalanceTracker {}\\n\\n/// @title IStakingRewardStreams\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface for Staking Reward Streams. Extends `IRewardStreams` with staking functionality.\\ninterface IStakingRewardStreams is IRewardStreams {\\n    function stake(address rewarded, uint256 amount) external;\\n    function unstake(address rewarded, uint256 amount, address recipient, bool forfeitRecentReward) external;\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/IEVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport {IVault as IEVCVault} from \\\"ethereum-vault-connector/interfaces/IVault.sol\\\";\\n\\n// Full interface of EVault and all it's modules\\n\\n/// @title IInitialize\\n/// @notice Interface of the initialization module of EVault\\ninterface IInitialize {\\n    /// @notice Initialization of the newly deployed proxy contract\\n    /// @param proxyCreator Account which created the proxy or should be the initial governor\\n    function initialize(address proxyCreator) external;\\n}\\n\\n/// @title IERC20\\n/// @notice Interface of the EVault's Initialize module\\ninterface IERC20 {\\n    /// @notice Vault share token (eToken) name, ie \\\"Euler Vault: DAI\\\"\\n    /// @return The name of the eToken\\n    function name() external view returns (string memory);\\n\\n    /// @notice Vault share token (eToken) symbol, ie \\\"eDAI\\\"\\n    /// @return The symbol of the eToken\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Decimals, the same as the asset's or 18 if the asset doesn't implement `decimals()`\\n    /// @return The decimals of the eToken\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Sum of all eToken balances\\n    /// @return The total supply of the eToken\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Balance of a particular account, in eTokens\\n    /// @param account Address to query\\n    /// @return The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieve the current allowance\\n    /// @param holder The account holding the eTokens\\n    /// @param spender Trusted address\\n    /// @return The allowance from holder for spender\\n    function allowance(address holder, address spender) external view returns (uint256);\\n\\n    /// @notice Transfer eTokens to another address\\n    /// @param to Recipient account\\n    /// @param amount In shares.\\n    /// @return True if transfer succeeded\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfer eTokens from one address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @param amount In shares\\n    /// @return True if transfer succeeded\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Allow spender to access an amount of your eTokens\\n    /// @param spender Trusted address\\n    /// @param amount Use max uint for \\\"infinite\\\" allowance\\n    /// @return True if approval succeeded\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\n/// @title IToken\\n/// @notice Interface of the EVault's Token module\\ninterface IToken is IERC20 {\\n    /// @notice Transfer the full eToken balance of an address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @return True if transfer succeeded\\n    function transferFromMax(address from, address to) external returns (bool);\\n}\\n\\n/// @title IERC4626\\n/// @notice Interface of an ERC4626 vault\\ninterface IERC4626 {\\n    /// @notice Vault's underlying asset\\n    /// @return The vault's underlying asset\\n    function asset() external view returns (address);\\n\\n    /// @notice Total amount of managed assets, cash and borrows\\n    /// @return The total amount of assets\\n    function totalAssets() external view returns (uint256);\\n\\n    /// @notice Calculate amount of assets corresponding to the requested shares amount\\n    /// @param shares Amount of shares to convert\\n    /// @return The amount of assets\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Calculate amount of shares corresponding to the requested assets amount\\n    /// @param assets Amount of assets to convert\\n    /// @return The amount of shares\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user can deposit\\n    /// @param account Address to query\\n    /// @return The max amount of assets the account can deposit\\n    function maxDeposit(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of shares that would be created by depositing assets\\n    /// @param assets Amount of assets deposited\\n    /// @return Amount of shares received\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user can mint\\n    /// @param account Address to query\\n    /// @return The max amount of shares the account can mint\\n    function maxMint(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of assets that would be required to mint requested amount of shares\\n    /// @param shares Amount of shares to be minted\\n    /// @return Required amount of assets\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user is allowed to withdraw\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of assets the owner is allowed to withdraw\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of shares that will be burned when withdrawing requested amount of assets\\n    /// @param assets Amount of assets withdrawn\\n    /// @return Amount of shares burned\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user is allowed to redeem for assets\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of shares the owner is allowed to redeem\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of assets that will be transferred when redeeming requested amount of shares\\n    /// @param shares Amount of shares redeemed\\n    /// @return Amount of assets transferred\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from sender to the vault pool in return for shares\\n    /// @param amount Amount of assets to deposit (use max uint256 for full underlying token balance)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Deposit will round down the amount of assets that are converted to shares. To prevent losses consider using\\n    /// mint instead.\\n    function deposit(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from sender to the vault pool in return for requested amount of shares\\n    /// @param amount Amount of shares to be minted\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of assets deposited\\n    function mint(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from the vault and decrease account's shares balance\\n    /// @param amount Amount of assets to withdraw\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn\\n    /// @return Amount of shares burned\\n    function withdraw(uint256 amount, address receiver, address owner) external returns (uint256);\\n\\n    /// @notice Burn requested shares and transfer corresponding underlying tokens from the vault to the receiver\\n    /// @param amount Amount of shares to burn (use max uint256 to burn full owner balance)\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn.\\n    /// @return Amount of assets transferred\\n    function redeem(uint256 amount, address receiver, address owner) external returns (uint256);\\n}\\n\\n/// @title IVault\\n/// @notice Interface of the EVault's Vault module\\ninterface IVault is IERC4626 {\\n    /// @notice Balance of the fees accumulator, in shares\\n    /// @return The accumulated fees in shares\\n    function accumulatedFees() external view returns (uint256);\\n\\n    /// @notice Balance of the fees accumulator, in underlying units\\n    /// @return The accumulated fees in asset units\\n    function accumulatedFeesAssets() external view returns (uint256);\\n\\n    /// @notice Address of the original vault creator\\n    /// @return The address of the creator\\n    function creator() external view returns (address);\\n\\n    /// @notice Creates shares for the receiver, from excess asset balances of the vault (not accounted for in `cash`)\\n    /// @param amount Amount of assets to claim (use max uint256 to claim all available assets)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Could be used as an alternative deposit flow in certain scenarios. E.g. swap directly to the vault, call\\n    /// `skim` to claim deposit.\\n    function skim(uint256 amount, address receiver) external returns (uint256);\\n}\\n\\n/// @title IBorrowing\\n/// @notice Interface of the EVault's Borrowing module\\ninterface IBorrowing {\\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\\n    /// @return The total borrows in asset units\\n    function totalBorrows() external view returns (uint256);\\n\\n    /// @notice Sum of all outstanding debts, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @return The total borrows in internal debt precision\\n    function totalBorrowsExact() external view returns (uint256);\\n\\n    /// @notice Balance of vault assets as tracked by deposits/withdrawals and borrows/repays\\n    /// @return The amount of assets the vault tracks as current direct holdings\\n    function cash() external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units\\n    /// @param account Address to query\\n    /// @return The debt of the account in asset units\\n    function debtOf(address account) external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @param account Address to query\\n    /// @return The debt of the account in internal precision\\n    function debtOfExact(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate for an asset\\n    /// @return The interest rate in yield-per-second, scaled by 10**27\\n    function interestRate() external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate accumulator for an asset\\n    /// @return An opaque accumulator that increases as interest is accrued\\n    function interestAccumulator() external view returns (uint256);\\n\\n    /// @notice Returns an address of the sidecar DToken\\n    /// @return The address of the DToken\\n    function dToken() external view returns (address);\\n\\n    /// @notice Transfer underlying tokens from the vault to the sender, and increase sender's debt\\n    /// @param amount Amount of assets to borrow (use max uint256 for all available tokens)\\n    /// @param receiver Account receiving the borrowed tokens\\n    /// @return Amount of assets borrowed\\n    function borrow(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from the sender to the vault, and decrease receiver's debt\\n    /// @param amount Amount of debt to repay in assets (use max uint256 for full debt)\\n    /// @param receiver Account holding the debt to be repaid\\n    /// @return Amount of assets repaid\\n    function repay(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Pay off liability with shares (\\\"self-repay\\\")\\n    /// @param amount In asset units (use max uint256 to repay the debt in full or up to the available deposit)\\n    /// @param receiver Account to remove debt from by burning sender's shares\\n    /// @return shares Amount of shares burned\\n    /// @return debt Amount of debt removed in assets\\n    /// @dev Equivalent to withdrawing and repaying, but no assets are needed to be present in the vault\\n    /// @dev Contrary to a regular `repay`, if account is unhealthy, the repay amount must bring the account back to\\n    /// health, or the operation will revert during account status check\\n    function repayWithShares(uint256 amount, address receiver) external returns (uint256 shares, uint256 debt);\\n\\n    /// @notice Take over debt from another account\\n    /// @param amount Amount of debt in asset units (use max uint256 for all the account's debt)\\n    /// @param from Account to pull the debt from\\n    /// @dev Due to internal debt precision accounting, the liability reported on either or both accounts after\\n    /// calling `pullDebt` may not match the `amount` requested precisely\\n    function pullDebt(uint256 amount, address from) external;\\n\\n    /// @notice Request a flash-loan. A onFlashLoan() callback in msg.sender will be invoked, which must repay the loan\\n    /// to the main Euler address prior to returning.\\n    /// @param amount In asset units\\n    /// @param data Passed through to the onFlashLoan() callback, so contracts don't need to store transient data in\\n    /// storage\\n    function flashLoan(uint256 amount, bytes calldata data) external;\\n\\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs\\n    /// vault status\\n    function touch() external;\\n}\\n\\n/// @title ILiquidation\\n/// @notice Interface of the EVault's Liquidation module\\ninterface ILiquidation {\\n    /// @notice Checks to see if a liquidation would be profitable, without actually doing anything\\n    /// @param liquidator Address that will initiate the liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @return maxRepay Max amount of debt that can be repaid, in asset units\\n    /// @return maxYield Yield in collateral corresponding to max allowed amount of debt to be repaid, in collateral\\n    /// balance (shares for vaults)\\n    function checkLiquidation(address liquidator, address violator, address collateral)\\n        external\\n        view\\n        returns (uint256 maxRepay, uint256 maxYield);\\n\\n    /// @notice Attempts to perform a liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @param repayAssets The amount of underlying debt to be transferred from violator to sender, in asset units (use\\n    /// max uint256 to repay the maximum possible amount). Meant as slippage check together with `minYieldBalance`\\n    /// @param minYieldBalance The minimum acceptable amount of collateral to be transferred from violator to sender, in\\n    /// collateral balance units (shares for vaults).  Meant as slippage check together with `repayAssets`\\n    /// @dev If `repayAssets` is set to max uint256 it is assumed the caller will perform their own slippage checks to\\n    /// make sure they are not taking on too much debt. This option is mainly meant for smart contract liquidators\\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance) external;\\n}\\n\\n/// @title IRiskManager\\n/// @notice Interface of the EVault's RiskManager module\\ninterface IRiskManager is IEVCVault {\\n    /// @notice Retrieve account's total liquidity\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collateralValue Total risk adjusted value of all collaterals in unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidity(address account, bool liquidation)\\n        external\\n        view\\n        returns (uint256 collateralValue, uint256 liabilityValue);\\n\\n    /// @notice Retrieve account's liquidity per collateral\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collaterals Array of collaterals enabled\\n    /// @return collateralValues Array of risk adjusted collateral values corresponding to items in collaterals array.\\n    /// In unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidityFull(address account, bool liquidation)\\n        external\\n        view\\n        returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue);\\n\\n    /// @notice Release control of the account on EVC if no outstanding debt is present\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account and reverts if account is not healthy\\n    /// @param account The address of the account to be checked\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkAccountStatus(address account, address[] calldata collaterals) external view returns (bytes4);\\n\\n    /// @notice Checks the status of the vault and reverts if caps are exceeded\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkVaultStatus() external returns (bytes4);\\n}\\n\\n/// @title IBalanceForwarder\\n/// @notice Interface of the EVault's BalanceForwarder module\\ninterface IBalanceForwarder {\\n    /// @notice Retrieve the address of rewards contract, tracking changes in account's balances\\n    /// @return The balance tracker address\\n    function balanceTrackerAddress() external view returns (address);\\n\\n    /// @notice Retrieves boolean indicating if the account opted in to forward balance changes to the rewards contract\\n    /// @param account Address to query\\n    /// @return True if balance forwarder is enabled\\n    function balanceForwarderEnabled(address account) external view returns (bool);\\n\\n    /// @notice Enables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can enable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the current account's balance\\n    function enableBalanceForwarder() external;\\n\\n    /// @notice Disables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can disable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the account's balance of 0\\n    function disableBalanceForwarder() external;\\n}\\n\\n/// @title IGovernance\\n/// @notice Interface of the EVault's Governance module\\ninterface IGovernance {\\n    /// @notice Retrieves the address of the governor\\n    /// @return The governor address\\n    function governorAdmin() external view returns (address);\\n\\n    /// @notice Retrieves address of the governance fee receiver\\n    /// @return The fee receiver address\\n    function feeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves the interest fee in effect for the vault\\n    /// @return Amount of interest that is redirected as a fee, as a fraction scaled by 1e4\\n    function interestFee() external view returns (uint16);\\n\\n    /// @notice Looks up an asset's currently configured interest rate model\\n    /// @return Address of the interest rate contract or address zero to indicate 0% interest\\n    function interestRateModel() external view returns (address);\\n\\n    /// @notice Retrieves the ProtocolConfig address\\n    /// @return The protocol config address\\n    function protocolConfigAddress() external view returns (address);\\n\\n    /// @notice Retrieves the protocol fee share\\n    /// @return A percentage share of fees accrued belonging to the protocol, in 1e4 scale\\n    function protocolFeeShare() external view returns (uint256);\\n\\n    /// @notice Retrieves the address which will receive protocol's fees\\n    /// @notice The protocol fee receiver address\\n    function protocolFeeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves supply and borrow caps in AmountCap format\\n    /// @return supplyCap The supply cap in AmountCap format\\n    /// @return borrowCap The borrow cap in AmountCap format\\n    function caps() external view returns (uint16 supplyCap, uint16 borrowCap);\\n\\n    /// @notice Retrieves the borrow LTV of the collateral, which is used to determine if the account is healthy during\\n    /// account status checks.\\n    /// @param collateral The address of the collateral to query\\n    /// @return Borrowing LTV in 1e4 scale\\n    function LTVBorrow(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves the current liquidation LTV, which is used to determine if the account is eligible for\\n    /// liquidation\\n    /// @param collateral The address of the collateral to query\\n    /// @return Liquidation LTV in 1e4 scale\\n    function LTVLiquidation(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves LTV configuration for the collateral\\n    /// @param collateral Collateral asset\\n    /// @return borrowLTV The current value of borrow LTV for originating positions\\n    /// @return liquidationLTV The value of fully converged liquidation LTV\\n    /// @return initialLiquidationLTV The initial value of the liquidation LTV, when the ramp began\\n    /// @return targetTimestamp The timestamp when the liquidation LTV is considered fully converged\\n    /// @return rampDuration The time it takes for the liquidation LTV to converge from the initial value to the fully\\n    /// converged value\\n    function LTVFull(address collateral)\\n        external\\n        view\\n        returns (\\n            uint16 borrowLTV,\\n            uint16 liquidationLTV,\\n            uint16 initialLiquidationLTV,\\n            uint48 targetTimestamp,\\n            uint32 rampDuration\\n        );\\n\\n    /// @notice Retrieves a list of collaterals with configured LTVs\\n    /// @return List of asset collaterals\\n    /// @dev Returned assets could have the ltv disabled (set to zero)\\n    function LTVList() external view returns (address[] memory);\\n\\n    /// @notice Retrieves the maximum liquidation discount\\n    /// @return The maximum liquidation discount in 1e4 scale\\n    /// @dev The default value, which is zero, is deliberately bad, as it means there would be no incentive to liquidate\\n    /// unhealthy users. The vault creator must take care to properly select the limit, given the underlying and\\n    /// collaterals used.\\n    function maxLiquidationDiscount() external view returns (uint16);\\n\\n    /// @notice Retrieves liquidation cool-off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @return The liquidation cool off time in seconds\\n    function liquidationCoolOffTime() external view returns (uint16);\\n\\n    /// @notice Retrieves a hook target and a bitmask indicating which operations call the hook target\\n    /// @return hookTarget Address of the hook target contract\\n    /// @return hookedOps Bitmask with operations that should call the hooks. See Constants.sol for a list of operations\\n    function hookConfig() external view returns (address hookTarget, uint32 hookedOps);\\n\\n    /// @notice Retrieves a bitmask indicating enabled config flags\\n    /// @return Bitmask with config flags enabled\\n    function configFlags() external view returns (uint32);\\n\\n    /// @notice Address of EthereumVaultConnector contract\\n    /// @return The EVC address\\n    function EVC() external view returns (address);\\n\\n    /// @notice Retrieves a reference asset used for liquidity calculations\\n    /// @return The address of the reference asset\\n    function unitOfAccount() external view returns (address);\\n\\n    /// @notice Retrieves the address of the oracle contract\\n    /// @return The address of the oracle\\n    function oracle() external view returns (address);\\n\\n    /// @notice Retrieves the Permit2 contract address\\n    /// @return The address of the Permit2 contract\\n    function permit2Address() external view returns (address);\\n\\n    /// @notice Splits accrued fees balance according to protocol fee share and transfers shares to the governor fee\\n    /// receiver and protocol fee receiver\\n    function convertFees() external;\\n\\n    /// @notice Set a new governor address\\n    /// @param newGovernorAdmin The new governor address\\n    /// @dev Set to zero address to renounce privileges and make the vault non-governed\\n    function setGovernorAdmin(address newGovernorAdmin) external;\\n\\n    /// @notice Set a new governor fee receiver address\\n    /// @param newFeeReceiver The new fee receiver address\\n    function setFeeReceiver(address newFeeReceiver) external;\\n\\n    /// @notice Set a new LTV config\\n    /// @param collateral Address of collateral to set LTV for\\n    /// @param borrowLTV New borrow LTV, for assessing account's health during account status checks, in 1e4 scale\\n    /// @param liquidationLTV New liquidation LTV after ramp ends in 1e4 scale\\n    /// @param rampDuration Ramp duration in seconds\\n    function setLTV(address collateral, uint16 borrowLTV, uint16 liquidationLTV, uint32 rampDuration) external;\\n\\n    /// @notice Set a new maximum liquidation discount\\n    /// @param newDiscount New maximum liquidation discount in 1e4 scale\\n    /// @dev If the discount is zero (the default), the liquidators will not be incentivized to liquidate unhealthy\\n    /// accounts\\n    function setMaxLiquidationDiscount(uint16 newDiscount) external;\\n\\n    /// @notice Set a new liquidation cool off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @param newCoolOffTime The new liquidation cool off time in seconds\\n    /// @dev Setting cool off time to zero allows liquidating the account in the same block as the last successful\\n    /// account status check\\n    function setLiquidationCoolOffTime(uint16 newCoolOffTime) external;\\n\\n    /// @notice Set a new interest rate model contract\\n    /// @param newModel The new IRM address\\n    /// @dev If the new model reverts, perhaps due to governor error, the vault will silently use a zero interest\\n    /// rate. Governor should make sure the new interest rates are computed as expected.\\n    function setInterestRateModel(address newModel) external;\\n\\n    /// @notice Set a new hook target and a new bitmap indicating which operations should call the hook target.\\n    /// Operations are defined in Constants.sol.\\n    /// @param newHookTarget The new hook target address. Use address(0) to simply disable hooked operations\\n    /// @param newHookedOps Bitmask with the new hooked operations\\n    /// @dev All operations are initially disabled in a newly created vault. The vault creator must set their\\n    /// own configuration to make the vault usable\\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) external;\\n\\n    /// @notice Set new bitmap indicating which config flags should be enabled. Flags are defined in Constants.sol\\n    /// @param newConfigFlags Bitmask with the new config flags\\n    function setConfigFlags(uint32 newConfigFlags) external;\\n\\n    /// @notice Set new supply and borrow caps in AmountCap format\\n    /// @param supplyCap The new supply cap in AmountCap fromat\\n    /// @param borrowCap The new borrow cap in AmountCap fromat\\n    function setCaps(uint16 supplyCap, uint16 borrowCap) external;\\n\\n    /// @notice Set a new interest fee\\n    /// @param newFee The new interest fee\\n    function setInterestFee(uint16 newFee) external;\\n}\\n\\n/// @title IEVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface of the EVault, an EVC enabled lending vault\\ninterface IEVault is\\n    IInitialize,\\n    IToken,\\n    IVault,\\n    IBorrowing,\\n    ILiquidation,\\n    IRiskManager,\\n    IBalanceForwarder,\\n    IGovernance\\n{\\n    /// @notice Fetch address of the `Initialize` module\\n    function MODULE_INITIALIZE() external view returns (address);\\n    /// @notice Fetch address of the `Token` module\\n    function MODULE_TOKEN() external view returns (address);\\n    /// @notice Fetch address of the `Vault` module\\n    function MODULE_VAULT() external view returns (address);\\n    /// @notice Fetch address of the `Borrowing` module\\n    function MODULE_BORROWING() external view returns (address);\\n    /// @notice Fetch address of the `Liquidation` module\\n    function MODULE_LIQUIDATION() external view returns (address);\\n    /// @notice Fetch address of the `RiskManager` module\\n    function MODULE_RISKMANAGER() external view returns (address);\\n    /// @notice Fetch address of the `BalanceForwarder` module\\n    function MODULE_BALANCE_FORWARDER() external view returns (address);\\n    /// @notice Fetch address of the `Governance` module\\n    function MODULE_GOVERNANCE() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Errors\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Contract implementing EVault's custom errors\\ncontract Errors {\\n    error E_Initialized();\\n    error E_ProxyMetadata();\\n    error E_SelfTransfer();\\n    error E_InsufficientAllowance();\\n    error E_InsufficientCash();\\n    error E_InsufficientAssets();\\n    error E_InsufficientBalance();\\n    error E_InsufficientDebt();\\n    error E_FlashLoanNotRepaid();\\n    error E_Reentrancy();\\n    error E_OperationDisabled();\\n    error E_OutstandingDebt();\\n    error E_AmountTooLargeToEncode();\\n    error E_DebtAmountTooLargeToEncode();\\n    error E_RepayTooMuch();\\n    error E_TransientState();\\n    error E_SelfLiquidation();\\n    error E_ControllerDisabled();\\n    error E_CollateralDisabled();\\n    error E_ViolatorLiquidityDeferred();\\n    error E_LiquidationCoolOff();\\n    error E_ExcessiveRepayAmount();\\n    error E_MinYield();\\n    error E_BadAddress();\\n    error E_ZeroAssets();\\n    error E_ZeroShares();\\n    error E_Unauthorized();\\n    error E_CheckUnauthorized();\\n    error E_NotSupported();\\n    error E_EmptyError();\\n    error E_BadBorrowCap();\\n    error E_BadSupplyCap();\\n    error E_BadCollateral();\\n    error E_AccountLiquidity();\\n    error E_NoLiability();\\n    error E_NotController();\\n    error E_BadFee();\\n    error E_SupplyCapExceeded();\\n    error E_BorrowCapExceeded();\\n    error E_InvalidLTVAsset();\\n    error E_NoPriceOracle();\\n    error E_ConfigAmountTooLargeToEncode();\\n    error E_BadAssetReceiver();\\n    error E_BadSharesOwner();\\n    error E_BadSharesReceiver();\\n    error E_BadMaxLiquidationDiscount();\\n    error E_LTVBorrow();\\n    error E_LTVLiquidation();\\n    error E_NotHookTarget();\\n}\\n\"\r\n    },\r\n    \"src/Lens/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IEVault} from \\\"evk/EVault/IEVault.sol\\\";\\nimport {RPow} from \\\"evk/EVault/shared/lib/RPow.sol\\\";\\n\\nabstract contract Utils {\\n    uint256 internal constant SECONDS_PER_YEAR = 365.2425 * 86400;\\n    uint256 internal constant ONE = 1e27;\\n    uint256 internal constant CONFIG_SCALE = 1e4;\\n    uint256 internal constant TTL_HS_ACCURACY = ONE / 1e4;\\n    int256 internal constant TTL_COMPUTATION_MIN = 0;\\n    int256 internal constant TTL_COMPUTATION_MAX = 400 * 1 days;\\n    int256 public constant TTL_INFINITY = type(int256).max;\\n    int256 public constant TTL_MORE_THAN_ONE_YEAR = type(int256).max - 1;\\n    int256 public constant TTL_LIQUIDATION = -1;\\n    int256 public constant TTL_ERROR = -2;\\n\\n    function _strEq(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n\\n    /// @dev for tokens like MKR which return bytes32 on name() or symbol()\\n    function _getStringOrBytes32(address contractAddress, bytes4 selector) internal view returns (string memory) {\\n        (bool success, bytes memory result) = contractAddress.staticcall(abi.encodeWithSelector(selector));\\n\\n        return (success && result.length != 0)\\n            ? result.length == 32 ? string(abi.encodePacked(result)) : abi.decode(result, (string))\\n            : \\\"\\\";\\n    }\\n\\n    function _getDecimals(address contractAddress) internal view returns (uint8) {\\n        (bool success, bytes memory data) =\\n            contractAddress.staticcall(abi.encodeCall(IEVault(contractAddress).decimals, ()));\\n\\n        return success && data.length >= 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    function _computeSupplySPY(uint256 borrowSPY, uint256 cash, uint256 borrows, uint256 interestFee)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 totalAssets = cash + borrows;\\n        return totalAssets == 0 ? 0 : borrowSPY * borrows * (CONFIG_SCALE - interestFee) / totalAssets / CONFIG_SCALE;\\n    }\\n\\n    function _computeAPYs(uint256 borrowSPY, uint256 supplySPY)\\n        internal\\n        pure\\n        returns (uint256 borrowAPY, uint256 supplyAPY)\\n    {\\n        bool overflowBorrow;\\n        bool overflowSupply;\\n        (borrowAPY, overflowBorrow) = RPow.rpow(borrowSPY + ONE, SECONDS_PER_YEAR, ONE);\\n        (supplyAPY, overflowSupply) = RPow.rpow(supplySPY + ONE, SECONDS_PER_YEAR, ONE);\\n\\n        if (overflowBorrow || overflowSupply) return (0, 0);\\n\\n        borrowAPY -= ONE;\\n        supplyAPY -= ONE;\\n    }\\n\\n    function _calculateTimeToLiquidation(\\n        address liabilityVault,\\n        uint256 liabilityValue,\\n        address[] memory collaterals,\\n        uint256[] memory collateralValues\\n    ) internal view returns (int256) {\\n        // if there's no liability, time to liquidation is infinite\\n        if (liabilityValue == 0) return TTL_INFINITY;\\n\\n        // get borrow interest rate\\n        uint256 liabilitySPY;\\n        {\\n            (bool success, bytes memory data) =\\n                liabilityVault.staticcall(abi.encodeCall(IEVault(liabilityVault).interestRate, ()));\\n\\n            if (success && data.length >= 32) {\\n                liabilitySPY = abi.decode(data, (uint256));\\n            }\\n        }\\n\\n        // get individual collateral interest rates and total collateral value\\n        uint256[] memory collateralSPYs = new uint256[](collaterals.length);\\n        uint256 collateralValue;\\n        for (uint256 i = 0; i < collaterals.length; ++i) {\\n            address collateral = collaterals[i];\\n\\n            (bool success, bytes memory data) =\\n                collateral.staticcall(abi.encodeCall(IEVault(collateral).interestRate, ()));\\n\\n            uint256 borrowSPY;\\n            if (success && data.length >= 32) {\\n                borrowSPY = abi.decode(data, (uint256));\\n            }\\n\\n            if (borrowSPY > 0) {\\n                collateralSPYs[i] = _computeSupplySPY(\\n                    borrowSPY,\\n                    IEVault(collateral).cash(),\\n                    IEVault(collateral).totalBorrows(),\\n                    IEVault(collateral).interestFee()\\n                );\\n            }\\n\\n            collateralValue += collateralValues[i];\\n        }\\n\\n        // if liability is greater than or equal to collateral, the account is eligible for liquidation right away\\n        if (liabilityValue >= collateralValue) return TTL_LIQUIDATION;\\n\\n        // if there's no borrow interest rate, time to liquidation is infinite\\n        if (liabilitySPY == 0) return TTL_INFINITY;\\n\\n        int256 minTTL = TTL_COMPUTATION_MIN;\\n        int256 maxTTL = TTL_COMPUTATION_MAX;\\n        int256 ttl;\\n\\n        // calculate time to liquidation using binary search\\n        while (true) {\\n            ttl = minTTL + (maxTTL - minTTL) / 2;\\n\\n            // break if the search range is too small\\n            if (maxTTL <= minTTL + 1 days) break;\\n            if (ttl < 1 days) break;\\n\\n            // calculate the liability interest accrued\\n            uint256 liabilityInterest;\\n            {\\n                (uint256 multiplier, bool overflow) = RPow.rpow(liabilitySPY + ONE, uint256(ttl), ONE);\\n\\n                if (overflow) return TTL_ERROR;\\n\\n                liabilityInterest = liabilityValue * multiplier / ONE - liabilityValue;\\n            }\\n\\n            // calculate the collaterals interest accrued\\n            uint256 collateralInterest;\\n            for (uint256 i = 0; i < collaterals.length; ++i) {\\n                (uint256 multiplier, bool overflow) = RPow.rpow(collateralSPYs[i] + ONE, uint256(ttl), ONE);\\n\\n                if (overflow) return TTL_ERROR;\\n\\n                collateralInterest = collateralValues[i] * multiplier / ONE - collateralValues[i];\\n            }\\n\\n            // calculate the health factor\\n            uint256 hs = (collateralValue + collateralInterest) * ONE / (liabilityValue + liabilityInterest);\\n\\n            // if the collateral interest accrues fater than the liability interest, the account should never be\\n            // liquidated\\n            if (collateralInterest >= liabilityInterest) return TTL_INFINITY;\\n\\n            // if the health factor is within the acceptable range, return the time to liquidation\\n            if (hs >= ONE && hs - ONE <= TTL_HS_ACCURACY) break;\\n            if (hs < ONE && ONE - hs <= TTL_HS_ACCURACY) break;\\n\\n            // adjust the search range\\n            if (hs >= ONE) minTTL = ttl + 1 days;\\n            else maxTTL = ttl - 1 days;\\n        }\\n\\n        return ttl > int256(SECONDS_PER_YEAR) ? TTL_MORE_THAN_ONE_YEAR : int256(ttl) / 1 days;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Lens/LensTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nstruct AccountInfo {\\n    EVCAccountInfo evcAccountInfo;\\n    VaultAccountInfo vaultAccountInfo;\\n    AccountRewardInfo accountRewardInfo;\\n}\\n\\nstruct AccountMultipleVaultsInfo {\\n    EVCAccountInfo evcAccountInfo;\\n    VaultAccountInfo[] vaultAccountInfo;\\n    AccountRewardInfo[] accountRewardInfo;\\n}\\n\\nstruct EVCAccountInfo {\\n    uint256 timestamp;\\n    address evc;\\n    address account;\\n    bytes19 addressPrefix;\\n    address owner;\\n    bool isLockdownMode;\\n    bool isPermitDisabledMode;\\n    uint256 lastAccountStatusCheckTimestamp;\\n    address[] enabledControllers;\\n    address[] enabledCollaterals;\\n}\\n\\nstruct VaultAccountInfo {\\n    uint256 timestamp;\\n    address account;\\n    address vault;\\n    address asset;\\n    uint256 assetsAccount;\\n    uint256 shares;\\n    uint256 assets;\\n    uint256 borrowed;\\n    uint256 assetAllowanceVault;\\n    uint256 assetAllowanceVaultPermit2;\\n    uint256 assetAllowanceExpirationVaultPermit2;\\n    uint256 assetAllowancePermit2;\\n    bool balanceForwarderEnabled;\\n    bool isController;\\n    bool isCollateral;\\n    AccountLiquidityInfo liquidityInfo;\\n}\\n\\nstruct AccountLiquidityInfo {\\n    bool queryFailure;\\n    bytes queryFailureReason;\\n    int256 timeToLiquidation;\\n    uint256 liabilityValue;\\n    uint256 collateralValueBorrowing;\\n    uint256 collateralValueLiquidation;\\n    CollateralLiquidityInfo[] collateralLiquidityBorrowingInfo;\\n    CollateralLiquidityInfo[] collateralLiquidityLiquidationInfo;\\n}\\n\\nstruct CollateralLiquidityInfo {\\n    address collateral;\\n    uint256 collateralValue;\\n}\\n\\nstruct VaultInfoSimple {\\n    uint256 timestamp;\\n    address vault;\\n    string vaultName;\\n    string vaultSymbol;\\n    uint256 vaultDecimals;\\n    address asset;\\n    uint256 assetDecimals;\\n    address unitOfAccount;\\n    uint256 unitOfAccountDecimals;\\n    uint256 totalShares;\\n    uint256 totalCash;\\n    uint256 totalBorrowed;\\n    uint256 totalAssets;\\n    address oracle;\\n    address governorAdmin;\\n    VaultInterestRateModelInfo irmInfo;\\n    LTVInfo[] collateralLTVInfo;\\n    AssetPriceInfo liabilityPriceInfo;\\n    AssetPriceInfo[] collateralPriceInfo;\\n    OracleDetailedInfo oracleInfo;\\n    AssetPriceInfo backupAssetPriceInfo;\\n    OracleDetailedInfo backupAssetOracleInfo;\\n}\\n\\nstruct VaultInfoFull {\\n    uint256 timestamp;\\n    address vault;\\n    string vaultName;\\n    string vaultSymbol;\\n    uint256 vaultDecimals;\\n    address asset;\\n    string assetName;\\n    string assetSymbol;\\n    uint256 assetDecimals;\\n    address unitOfAccount;\\n    string unitOfAccountName;\\n    string unitOfAccountSymbol;\\n    uint256 unitOfAccountDecimals;\\n    uint256 totalShares;\\n    uint256 totalCash;\\n    uint256 totalBorrowed;\\n    uint256 totalAssets;\\n    uint256 accumulatedFeesShares;\\n    uint256 accumulatedFeesAssets;\\n    address governorFeeReceiver;\\n    address protocolFeeReceiver;\\n    uint256 protocolFeeShare;\\n    uint256 interestFee;\\n    uint256 hookedOperations;\\n    uint256 configFlags;\\n    uint256 supplyCap;\\n    uint256 borrowCap;\\n    uint256 maxLiquidationDiscount;\\n    uint256 liquidationCoolOffTime;\\n    address dToken;\\n    address oracle;\\n    address interestRateModel;\\n    address hookTarget;\\n    address evc;\\n    address protocolConfig;\\n    address balanceTracker;\\n    address permit2;\\n    address creator;\\n    address governorAdmin;\\n    VaultInterestRateModelInfo irmInfo;\\n    LTVInfo[] collateralLTVInfo;\\n    AssetPriceInfo liabilityPriceInfo;\\n    AssetPriceInfo[] collateralPriceInfo;\\n    OracleDetailedInfo oracleInfo;\\n    AssetPriceInfo backupAssetPriceInfo;\\n    OracleDetailedInfo backupAssetOracleInfo;\\n}\\n\\nstruct LTVInfo {\\n    address collateral;\\n    uint256 borrowLTV;\\n    uint256 liquidationLTV;\\n    uint256 initialLiquidationLTV;\\n    uint256 targetTimestamp;\\n    uint256 rampDuration;\\n}\\n\\nstruct AssetPriceInfo {\\n    bool queryFailure;\\n    bytes queryFailureReason;\\n    uint256 timestamp;\\n    address oracle;\\n    address asset;\\n    address unitOfAccount;\\n    uint256 amountIn;\\n    uint256 amountOutMid;\\n    uint256 amountOutBid;\\n    uint256 amountOutAsk;\\n}\\n\\nstruct VaultInterestRateModelInfo {\\n    bool queryFailure;\\n    bytes queryFailureReason;\\n    address vault;\\n    address interestRateModel;\\n    InterestRateInfo[] interestRateInfo;\\n}\\n\\nstruct InterestRateInfo {\\n    uint256 cash;\\n    uint256 borrows;\\n    uint256 borrowSPY;\\n    uint256 supplySPY;\\n    uint256 borrowAPY;\\n    uint256 supplyAPY;\\n}\\n\\nstruct KinkInterestRateModelInfo {\\n    address interestRateModel;\\n    uint256 baseRate;\\n    uint256 slope1;\\n    uint256 slope2;\\n    uint256 kink;\\n}\\n\\nstruct AccountRewardInfo {\\n    uint256 timestamp;\\n    address account;\\n    address vault;\\n    address balanceTracker;\\n    bool balanceForwarderEnabled;\\n    uint256 balance;\\n    EnabledRewardInfo[] enabledRewardsInfo;\\n}\\n\\nstruct EnabledRewardInfo {\\n    address reward;\\n    uint256 earnedReward;\\n    uint256 earnedRewardRecentIgnored;\\n}\\n\\nstruct VaultRewardInfo {\\n    uint256 timestamp;\\n    address vault;\\n    address reward;\\n    string rewardName;\\n    string rewardSymbol;\\n    uint8 rewardDecimals;\\n    address balanceTracker;\\n    uint256 epochDuration;\\n    uint256 currentEpoch;\\n    uint256 totalRewardedEligible;\\n    uint256 totalRewardRegistered;\\n    uint256 totalRewardClaimed;\\n    RewardAmountInfo[] epochInfoPrevious;\\n    RewardAmountInfo[] epochInfoUpcoming;\\n}\\n\\nstruct RewardAmountInfo {\\n    uint256 epoch;\\n    uint256 epochStart;\\n    uint256 epochEnd;\\n    uint256 rewardAmount;\\n}\\n\\nstruct OracleDetailedInfo {\\n    address oracle;\\n    string name;\\n    bytes oracleInfo;\\n}\\n\\nstruct EulerRouterInfo {\\n    address governor;\\n    address fallbackOracle;\\n    address[] resolvedOracles;\\n    OracleDetailedInfo fallbackOracleInfo;\\n    OracleDetailedInfo[] resolvedOraclesInfo;\\n}\\n\\nstruct ChainlinkOracleInfo {\\n    address base;\\n    address quote;\\n    address feed;\\n    string feedDescription;\\n    uint256 maxStaleness;\\n}\\n\\nstruct ChronicleOracleInfo {\\n    address base;\\n    address quote;\\n    address feed;\\n    uint256 maxStaleness;\\n}\\n\\nstruct LidoOracleInfo {\\n    address base;\\n    address quote;\\n}\\n\\nstruct PythOracleInfo {\\n    address pyth;\\n    address base;\\n    address quote;\\n    bytes32 feedId;\\n    uint256 maxStaleness;\\n    uint256 maxConfWidth;\\n}\\n\\nstruct RedstoneCoreOracleInfo {\\n    address base;\\n    address quote;\\n    bytes32 feedId;\\n    uint8 feedDecimals;\\n    uint256 maxStaleness;\\n    uint208 cachePrice;\\n    uint48 cachePriceTimestamp;\\n}\\n\\nstruct UniswapV3OracleInfo {\\n    address tokenA;\\n    address tokenB;\\n    address pool;\\n    uint24 fee;\\n    uint32 twapWindow;\\n}\\n\\nstruct CrossAdapterInfo {\\n    address base;\\n    address cross;\\n    address quote;\\n    address oracleBaseCross;\\n    address oracleCrossQuote;\\n    OracleDetailedInfo oracleBaseCrossInfo;\\n    OracleDetailedInfo oracleCrossQuoteInfo;\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/lib/permit2/src/interfaces/IEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IEIP712 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/reward-streams/src/interfaces/IBalanceTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IBalanceTracker\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Provides an interface for tracking the balance of accounts.\\ninterface IBalanceTracker {\\n    /// @notice Executes the balance tracking hook for an account.\\n    /// @dev This function must be called with the current balance of the account when enabling the balance forwarding\\n    /// for it. This function must be called with 0 balance of the account when disabling the balance forwarding for it.\\n    /// This function allows to be called on zero balance transfers, when the newAccountBalance is the same as the\\n    /// previous one. To prevent DOS attacks, forfeitRecentReward should be used appropriately.\\n    /// @param account The account address to execute the hook for.\\n    /// @param newAccountBalance The new balance of the account.\\n    /// @param forfeitRecentReward Whether to forfeit the most recent reward and not update the accumulator.\\n    function balanceTrackerHook(address account, uint256 newAccountBalance, bool forfeitRecentReward) external;\\n}\\n\"\r\n    },\r\n    \"lib/ethereum-vault-connector/src/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Vault for the purpose of integration with the Ethereum Vault\\n/// Connector.\\ninterface IVault {\\n    /// @notice Disables a controller (this vault) for the authenticated account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults. User calls this function in order for the vault to disable itself\\n    /// for the account if the conditions are met (i.e. user has repaid debt in full). If the conditions are not met,\\n    /// the function reverts.\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account.\\n    /// @dev This function must only deliberately revert if the account status is invalid. If this function reverts due\\n    /// to any other reason, it may render the account unusable with possibly no way to recover funds.\\n    /// @param account The address of the account to be checked.\\n    /// @param collaterals The array of enabled collateral addresses to be considered for the account status check.\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkAccountStatus(\\n        address account,\\n        address[] calldata collaterals\\n    ) external view returns (bytes4 magicValue);\\n\\n    /// @notice Checks the status of the vault.\\n    /// @dev This function must only deliberately revert if the vault status is invalid. If this function reverts due to\\n    /// any other reason, it may render some accounts unusable with possibly no way to recover funds.\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkVaultStatus() external returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/lib/RPow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @custom:security-contact security@euler.xyz\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n/// @author Modified by Euler Labs (https://www.eulerlabs.com/) to return an `overflow` bool instead of reverting\\nlibrary RPow {\\n    /// @dev If overflow is true, an overflow occurred and the value of z is undefined\\n    function rpow(uint256 x, uint256 n, uint256 scalar) internal pure returns (uint256 z, bool overflow) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Bail if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        overflow := 1\\n                        break\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Bail if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        overflow := 1\\n                        break\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Bail if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                overflow := 1\\n                                break\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Bail if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            overflow := 1\\n                            break\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ethereum-vault-connector/=lib/ethereum-vault-connector/src/\",\r\n      \"evc/=lib/ethereum-vault-connector/src/\",\r\n      \"evk/=lib/euler-vault-kit/src/\",\r\n      \"evk-test/=lib/euler-vault-kit/test/\",\r\n      \"euler-price-oracle/=lib/euler-price-oracle/src/\",\r\n      \"euler-price-oracle-test/=lib/euler-price-oracle/test/\",\r\n      \"fee-flow/=lib/fee-flow/src/\",\r\n      \"reward-streams/=lib/reward-streams/src/\",\r\n      \"@openzeppelin/contracts/utils/math/=lib/euler-price-oracle/lib/openzeppelin-contracts/contracts/utils/math/\",\r\n      \"@chainlink/=lib/euler-price-oracle/node_modules/@chainlink/\",\r\n      \"@eth-optimism/=lib/euler-price-oracle/node_modules/@eth-optimism/contracts/\",\r\n      \"@pyth/=lib/euler-price-oracle/lib/pyth-sdk-solidity/\",\r\n      \"@redstone-finance/=lib/euler-price-oracle/node_modules/@redstone-finance/\",\r\n      \"@redstone/evm-connector/=lib/euler-price-oracle/lib/redstone-oracles-monorepo/packages/evm-connector/contracts/\",\r\n      \"@solady/=lib/euler-price-oracle/lib/solady/src/\",\r\n      \"@uniswap/v3-core/=lib/euler-price-oracle/lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/\",\r\n      \"ds-test/=lib/fee-flow/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"euler-vault-kit/=lib/euler-vault-kit/src/\",\r\n      \"forge-gas-snapshot/=lib/euler-vault-kit/lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\r\n      \"openzeppelin/=lib/ethereum-vault-connector/lib/openzeppelin-contracts/contracts/\",\r\n      \"permit2/=lib/euler-vault-kit/lib/permit2/\",\r\n      \"pyth-sdk-solidity/=lib/euler-price-oracle/lib/pyth-sdk-solidity/\",\r\n      \"redstone-oracles-monorepo/=lib/euler-price-oracle/lib/\",\r\n      \"solady/=lib/euler-price-oracle/lib/solady/src/\",\r\n      \"solmate/=lib/fee-flow/lib/solmate/src/\",\r\n      \"v3-core/=lib/euler-price-oracle/lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"TTL_ERROR\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TTL_INFINITY\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TTL_LIQUIDATION\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TTL_MORE_THAN_ONE_YEAR\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"evc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountEnabledVaultsInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"evc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes19\",\"name\":\"addressPrefix\",\"type\":\"bytes19\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLockdownMode\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPermitDisabledMode\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastAccountStatusCheckTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"enabledControllers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"enabledCollaterals\",\"type\":\"address[]\"}],\"internalType\":\"struct EVCAccountInfo\",\"name\":\"evcAccountInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetsAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceVaultPermit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceExpirationVaultPermit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowancePermit2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"balanceForwarderEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"timeToLiquidation\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"liabilityValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValueBorrowing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValueLiquidation\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralLiquidityInfo[]\",\"name\":\"collateralLiquidityBorrowingInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralLiquidityInfo[]\",\"name\":\"collateralLiquidityLiquidationInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountLiquidityInfo\",\"name\":\"liquidityInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct VaultAccountInfo[]\",\"name\":\"vaultAccountInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balanceTracker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"balanceForwarderEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedRewardRecentIgnored\",\"type\":\"uint256\"}],\"internalType\":\"struct EnabledRewardInfo[]\",\"name\":\"enabledRewardsInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountRewardInfo[]\",\"name\":\"accountRewardInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountMultipleVaultsInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"evc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes19\",\"name\":\"addressPrefix\",\"type\":\"bytes19\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLockdownMode\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPermitDisabledMode\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastAccountStatusCheckTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"enabledControllers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"enabledCollaterals\",\"type\":\"address[]\"}],\"internalType\":\"struct EVCAccountInfo\",\"name\":\"evcAccountInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetsAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceVaultPermit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceExpirationVaultPermit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowancePermit2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"balanceForwarderEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"timeToLiquidation\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"liabilityValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValueBorrowing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValueLiquidation\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralLiquidityInfo[]\",\"name\":\"collateralLiquidityBorrowingInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralLiquidityInfo[]\",\"name\":\"collateralLiquidityLiquidationInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountLiquidityInfo\",\"name\":\"liquidityInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct VaultAccountInfo\",\"name\":\"vaultAccountInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balanceTracker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"balanceForwarderEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedRewardRecentIgnored\",\"type\":\"uint256\"}],\"internalType\":\"struct EnabledRewardInfo[]\",\"name\":\"enabledRewardsInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountRewardInfo\",\"name\":\"accountRewardInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct AccountInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"evc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getEVCAccountInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"evc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes19\",\"name\":\"addressPrefix\",\"type\":\"bytes19\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLockdownMode\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPermitDisabledMode\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastAccountStatusCheckTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"enabledControllers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"enabledCollaterals\",\"type\":\"address[]\"}],\"internalType\":\"struct EVCAccountInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getRewardAccountInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balanceTracker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"balanceForwarderEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedRewardRecentIgnored\",\"type\":\"uint256\"}],\"internalType\":\"struct EnabledRewardInfo[]\",\"name\":\"enabledRewardsInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountRewardInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getTimeToLiquidation\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getVaultAccountInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetsAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceVaultPermit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowanceExpirationVaultPermit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAllowancePermit2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"balanceForwarderEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"timeToLiquidation\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"liabilityValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValueBorrowing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValueLiquidation\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralLiquidityInfo[]\",\"name\":\"collateralLiquidityBorrowingInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralLiquidityInfo[]\",\"name\":\"collateralLiquidityLiquidationInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AccountLiquidityInfo\",\"name\":\"liquidityInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct VaultAccountInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AccountLens", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}