{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SubscriptionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract SubscriptionManager is AccessControl, ReentrancyGuard {\\n  /**\\n   * @dev Struct to store information about promo codes.\\n   * @param _address The address associated with the promo code.\\n   * @param commissionRate The commission rate for the promo code.\\n   * @param discountRate The discount rate provided by the promo code.\\n   * @param deadline The expiration time of the promo code.\\n   */\\n  struct PromoCode {\\n    address _address;\\n    uint commissionRate;\\n    uint discountRate;\\n    uint deadline;\\n  }\\n\\n  /**\\n   * @dev Emitted when a subscription is updated.\\n   * @param id The ID of the subscription.\\n   * @param _address The address of the subscriber.\\n   * @param duration The duration of the subscription.\\n   * @param deadline The deadline of the subscription.\\n   */\\n  event UpdateSubscription(\\n    uint indexed id,\\n    address indexed _address,\\n    int duration,\\n    uint deadline\\n  );\\n\\n  /**\\n   * @dev Emitted when a promo code is added.\\n   * @param _address The address associated with the promo code.\\n   * @param name The name of the promo code.\\n   * @param commissionRate The commission rate for the promo code.\\n   * @param discountRate The discount rate provided by the promo code.\\n   * @param deadline The expiration time of the promo code.\\n   */\\n  event PromoCodeAddition(\\n    address indexed _address,\\n    string name,\\n    uint commissionRate,\\n    uint discountRate,\\n    uint deadline\\n  );\\n\\n  /**\\n   * @dev Emitted when a subscription is created.\\n   * @param id The ID of the subscription.\\n   * @param subscriber The address of the subscriber.\\n   * @param duration The duration of the subscription.\\n   * @param cost The cost of the subscription.\\n   * @param deadline The deadline of the subscription.\\n   */\\n  event Subscription(\\n    uint indexed id,\\n    address indexed subscriber,\\n    uint duration,\\n    uint cost,\\n    uint deadline\\n  );\\n\\n  /**\\n   * @dev Emitted when a subscription is created with a promo code.\\n   * @param id The ID of the subscription.\\n   * @param subscriber The address of the subscriber.\\n   * @param promoCode The name of the promo code used.\\n   * @param duration The duration of the subscription.\\n   * @param cost The cost of the subscription after applying the promo code discount.\\n   * @param deadline The deadline of the subscription.\\n   */\\n  event SubscriptionWithPromoCode(\\n    uint indexed id,\\n    address indexed subscriber,\\n    string indexed promoCode,\\n    uint duration,\\n    uint cost,\\n    uint deadline\\n  );\\n\\n  /**\\n   * @dev Error thrown when an invalid plan duration is provided.\\n   * @param duration The invalid duration that was provided.\\n   */\\n  error InvalidPlan(uint duration);\\n\\n  /**\\n   * @dev Error thrown when an empty promo code is used.\\n   */\\n  error EmptyPromoCode();\\n\\n  /**\\n   * @dev Error thrown when trying to add a promo code that already exists.\\n   * @param promoCode The name of the promo code that already exists.\\n   */\\n  error PromoCodeAlreadyExists(string promoCode);\\n\\n  /**\\n   * @dev Error thrown when an invalid promo code is used.\\n   * @param promoCode The name of the promo code that is invalid.\\n   */\\n  error InvalidPromoCode(string promoCode);\\n\\n  /**\\n   * @dev Error thrown when a promo code is used past its expiration date.\\n   * @param promoCode The name of the expired promo code.\\n   */\\n  error ExpiredPromoCode(string promoCode);\\n\\n  /**\\n   * @dev Error thrown when the provided plans are invalid.\\n   */\\n  error InvalidPlans();\\n\\n  /**\\n   * @dev Error thrown when a transfer of Ether fails.\\n   */\\n  error EtherTransferFailed();\\n\\n  /**\\n   * @dev Error thrown when the funds provided for a subscription are incorrect.\\n   */\\n  error IncorrectFunds();\\n\\n  // Role identifier for moderators\\n  bytes32 public constant MODERATOR_ROLE = keccak256(\\\"MODERATOR_ROLE\\\");\\n\\n  // Multiplier used for rate calculations. 10000 corresponds to 100% in Basis Point System (BPS)\\n  uint private constant RATE_MULTIPLIER = 10000;\\n\\n  // Address where collected subscription funds will be sent\\n  address payable private _treasuryAddress;\\n\\n  // Array storing durations of all subscription plans\\n  uint[] private _planDurations;\\n\\n  // Array storing costs of all subscription plans\\n  uint[] private _planCosts;\\n\\n  // Mapping from subscription plan duration to its cost\\n  mapping(uint => uint) private _plans; // duration => cost\\n\\n  // Mapping from subscription id to its deadline\\n  mapping(uint256 => uint) private _subscriptions; // id => deadline\\n\\n  // Mapping from promo code name to its details\\n  mapping(string => PromoCode) private _promoCodes; // name => promo code\\n\\n  /**\\n   * @dev Sets up the subscription manager contract with initial configuration.\\n   * @param treasuryAddress The address where collected funds will be sent.\\n   * @param planDurations An array of durations for the subscription plans.\\n   * @param planCosts An array of costs for the subscription plans.\\n   */\\n  constructor(\\n    address payable treasuryAddress,\\n    uint[] memory planDurations,\\n    uint[] memory planCosts\\n  ) {\\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Assigns the deployer the default admin role\\n    _treasuryAddress = treasuryAddress; // Sets the treasury address where funds will be collected\\n\\n    // Loop through the provided plan durations and costs to initialize the plans\\n    uint length = planDurations.length;\\n    for (uint i = 0; i < length; i++) {\\n      uint duration = planDurations[i];\\n      _plans[duration] = planCosts[i]; // Maps the duration to its cost\\n      _planDurations.push(duration); // Stores the duration in an array for retrieval\\n      _planCosts.push(planCosts[i]); // Stores the cost in an array for retrieval\\n    }\\n  }\\n\\n  // Public View Methods\\n\\n  /**\\n   * @dev Returns the durations and costs of all subscription plans.\\n   *\\n   * @return Two arrays containing the durations and costs of all subscription plans.\\n   */\\n  function plans() public view returns (uint[] memory, uint[] memory) {\\n    return (_planDurations, _planCosts);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the treasury wallet.\\n   *\\n   * @return The address of the treasury wallet.\\n   */\\n  function treasuryWallet() public view returns (address) {\\n    return _treasuryAddress;\\n  }\\n\\n  /**\\n   * @dev Returns the cost of a subscription plan for a given duration.\\n   *\\n   * @param duration The duration of the subscription plan.\\n   * @return The cost of the subscription plan.\\n   */\\n  function planCost(uint duration) public view returns (uint) {\\n    return _plans[duration];\\n  }\\n\\n  /**\\n   * @dev Returns the deadline of a subscription for a given ID.\\n   *\\n   * @param _id The ID of the subscription.\\n   * @return The deadline of the subscription.\\n   */\\n  function subscriptionDeadline(uint256 _id) public view returns (uint) {\\n    return _subscriptions[_id];\\n  }\\n\\n  /**\\n   * @dev Returns the promo code for a given name.\\n   *\\n   * @param name The name of the promo code.\\n   * @return The promo code.\\n   */\\n  function promoCode(string memory name) public view returns (PromoCode memory) {\\n    return _promoCodes[name];\\n  }\\n\\n  /**\\n   * @dev Checks if a subscription is active for a given ID.\\n   *\\n   * @param _id The ID of the subscription.\\n   * @return True if the subscription is active, false otherwise.\\n   */\\n  function subscriptionActive(uint _id) public view returns (bool) {\\n    return _subscriptions[_id] > block.timestamp;\\n  }\\n\\n  // Moderator Actions\\n\\n  /**\\n   * @dev Updates the subscription plans.\\n   * This function first validates the input arrays, then clears the existing plans, and finally sets up the new plans.\\n   * Emits an {InvalidPlans} event if the input arrays are not of the same length or if any duration is zero.\\n   *\\n   * Requirements:\\n   * - The caller must have the `MODERATOR_ROLE`.\\n   * - The `durations` and `costs` arrays must have the same length.\\n   * - No duration can be zero.\\n   *\\n   * @param durations An array of durations for the new plans.\\n   * @param costs An array of costs for the new plans.\\n   */\\n  function updatePlans(\\n    uint[] calldata durations,\\n    uint[] calldata costs\\n  ) public onlyRole(MODERATOR_ROLE) {\\n    // Check if the lengths of the input arrays match\\n    if (durations.length != costs.length) revert InvalidPlans();\\n    // Clear the existing plans\\n    for (uint i = 0; i < _planDurations.length; i++) {\\n      delete _plans[_planDurations[i]];\\n    }\\n    // Set up the new plans\\n    for (uint i = 0; i < durations.length; i++) {\\n      // Check if any duration is zero\\n      if (durations[i] == 0) revert InvalidPlans();\\n      _plans[durations[i]] = costs[i];\\n    }\\n    // Update the storage arrays with the new plans\\n    _planDurations = durations;\\n    _planCosts = costs;\\n  }\\n\\n  /**\\n   * @dev Adds a new subscription or extends an existing one for a given ID and duration.\\n   * Emits an {UpdateSubscription} event indicating the update.\\n   *\\n   * Requirements:\\n   * - The caller must have the `MODERATOR_ROLE`.\\n   *\\n   * @param _id The ID of the subscription to add or extend.\\n   * @param duration The duration in days to add to the subscription's deadline.\\n   */\\n  function addSubscription(uint _id, uint duration) public onlyRole(MODERATOR_ROLE) {\\n    uint deadline = _updateDeadline(_id, duration);\\n    emit UpdateSubscription(_id, msg.sender, int(duration), deadline);\\n  }\\n\\n  /**\\n   * @dev Subtracts a given duration from an existing subscription's deadline.\\n   * Emits an {UpdateSubscription} event indicating the update.\\n   *\\n   * Requirements:\\n   * - The caller must have the `MODERATOR_ROLE`.\\n   *\\n   * @param _id The ID of the subscription to subtract the duration from.\\n   * @param duration The duration in days to subtract from the subscription's deadline.\\n   */\\n  function subtractSubscription(\\n    uint _id,\\n    uint duration\\n  ) public onlyRole(MODERATOR_ROLE) {\\n    uint newDeadline = _subscriptions[_id] - duration * 1 days;\\n    _subscriptions[_id] = newDeadline;\\n    emit UpdateSubscription(_id, msg.sender, -int(duration), newDeadline);\\n  }\\n\\n  /**\\n   * @dev Sets a new promo code or updates an existing one.\\n   * Emits a {PromoCodeAddition} event indicating the addition or update of a promo code.\\n   *\\n   * Requirements:\\n   * - The caller must have the `MODERATOR_ROLE`.\\n   * - The `name` cannot be an empty string.\\n   * - A promo code with the same `name` must not already exist.\\n   *\\n   * @param _address The address associated with the promo code.\\n   * @param name The name of the promo code.\\n   * @param commissionRate The commission rate for the promo code.\\n   * @param discountRate The discount rate for the promo code.\\n   * @param duration The duration in days for which the promo code is valid.\\n   */\\n  function setPromoCode(\\n    address _address,\\n    string memory name,\\n    uint commissionRate,\\n    uint discountRate,\\n    uint duration\\n  ) public onlyRole(MODERATOR_ROLE) {\\n    // Ensure the promo code name is not empty\\n    if (bytes(name).length == 0) revert EmptyPromoCode();\\n    // Ensure the promo code does not already exist\\n    if (_promoCodes[name]._address != address(0)) revert PromoCodeAlreadyExists(name);\\n\\n    // Calculate the deadline for the promo code based on the current block timestamp and the given duration\\n    uint deadline = block.timestamp + duration * 1 days;\\n\\n    // Create or update the promo code in the mapping with the provided details\\n    PromoCode storage _promoCode = _promoCodes[name];\\n    _promoCode._address = _address;\\n    _promoCode.commissionRate = commissionRate;\\n    _promoCode.discountRate = discountRate;\\n    _promoCode.deadline = deadline;\\n\\n    // Emit an event to log the addition or update of the promo code\\n    emit PromoCodeAddition(_address, name, commissionRate, discountRate, deadline);\\n  }\\n\\n  // Subscriber Actions\\n\\n  /**\\n   * @dev Allows a user to subscribe to a plan.\\n   * The cost of the plan is determined by the `duration` parameter and must be paid in full.\\n   * The payment is sent to the treasury address.\\n   * Emits a {Subscription} event upon successful subscription.\\n   *\\n   * Requirements:\\n   * - The plan associated with the `duration` must be valid.\\n   * - The `msg.value` must equal the cost of the plan.\\n   * - The transaction must not be reentrant.\\n   *\\n   * @param _id The ID of the subscription plan.\\n   * @param duration The duration of the subscription plan.\\n   */\\n  function subscribe(uint _id, uint duration) public payable nonReentrant {\\n    // Determine the cost of the subscription plan based on the duration\\n    uint cost = _plans[duration];\\n    // Revert the transaction if the plan is invalid (cost is 0)\\n    if (cost == 0) revert InvalidPlan(duration);\\n    // Revert the transaction if the funds sent do not match the cost of the plan\\n    if (msg.value != cost) revert IncorrectFunds();\\n    // Attempt to transfer the cost to the treasury address\\n    (bool sentToTreasury, ) = _treasuryAddress.call{value: cost}(\\\"\\\");\\n    // Revert the transaction if the transfer fails\\n    if (!sentToTreasury) {\\n      revert EtherTransferFailed();\\n    }\\n\\n    // Update the subscription deadline for the user\\n    uint deadline = _updateDeadline(_id, duration);\\n\\n    // Emit an event to log the new subscription\\n    emit Subscription(_id, msg.sender, duration, cost, deadline);\\n  }\\n\\n  /**\\n   * @dev Allows a user to subscribe to a plan using a promo code.\\n   * The cost of the plan is determined by the `duration` parameter and must be paid in full.\\n   * The payment is sent to the treasury address and the promoter of the promo code.\\n   * Emits a {SubscriptionWithPromoCode} event upon successful subscription.\\n   *\\n   * Requirements:\\n   * - The plan associated with the `duration` must be valid.\\n   * - The `msg.value` must equal the discounted cost of the plan.\\n   * - The transaction must not be reentrant.\\n   * - The promo code must be valid and not expired.\\n   *\\n   * @param _id The ID of the subscription plan.\\n   * @param duration The duration of the subscription plan.\\n   * @param promoCodeName The name of the promo code.\\n   */\\n  function subscribeWithPromoCode(\\n    uint _id,\\n    uint duration,\\n    string memory promoCodeName\\n  ) public payable nonReentrant {\\n    // Determine the cost of the subscription plan based on the duration\\n    uint cost = _plans[duration];\\n    // Revert the transaction if the plan is invalid (cost is 0)\\n    if (cost == 0) revert InvalidPlan(duration);\\n\\n    // Fetch the promo code details\\n    PromoCode memory _promoCode = _promoCodes[promoCodeName];\\n    // Revert the transaction if the promo code is invalid (address is 0)\\n    if (_promoCode._address == address(0)) revert InvalidPromoCode(promoCodeName);\\n    // Revert the transaction if the promo code is expired\\n    if (_promoCode.deadline < block.timestamp) revert ExpiredPromoCode(promoCodeName);\\n\\n    // Calculate the discounted cost based on the promo code discount rate\\n    uint discountedCost = cost - (cost * _promoCode.discountRate) / RATE_MULTIPLIER;\\n\\n    // Revert the transaction if the funds sent do not match the discounted cost of the plan\\n    if (msg.value != discountedCost) revert IncorrectFunds();\\n    uint balance = discountedCost;\\n\\n    // Calculate the amount to be sent to the promoter based on the promo code commission rate\\n    uint promoCodeAmount = (balance * _promoCode.commissionRate) / RATE_MULTIPLIER;\\n    balance -= promoCodeAmount;\\n\\n    // Attempt to transfer the promo code amount to the promoter address\\n    (bool sentToPromoter, ) = _promoCode._address.call{value: promoCodeAmount}(\\\"\\\");\\n    // Revert the transaction if the transfer fails\\n    if (!sentToPromoter) {\\n      revert EtherTransferFailed();\\n    }\\n    // After sending to the promoter, send the rest to the treasury\\n    (bool sentToTreasury, ) = _treasuryAddress.call{value: balance}(\\\"\\\");\\n    // Revert the transaction if the transfer fails\\n    if (!sentToTreasury) {\\n      revert EtherTransferFailed();\\n    }\\n\\n    // Update the subscription deadline for the user\\n    uint deadline = _updateDeadline(_id, duration);\\n\\n    // Emit an event to log the new subscription with a promo code\\n    emit SubscriptionWithPromoCode(\\n      _id,\\n      msg.sender,\\n      promoCodeName,\\n      duration,\\n      discountedCost,\\n      deadline\\n    );\\n  }\\n\\n  // Private Methods\\n\\n  /**\\n   * @dev Updates the subscription deadline for a given subscription ID.\\n   * If the current deadline is 0 or has passed, the new deadline is set to the current block timestamp plus the duration.\\n   * If the current deadline has not passed, the new deadline is set to the current deadline plus the duration.\\n   * The duration is expected to be in days.\\n   *\\n   * @param _id The ID of the subscription to update.\\n   * @param duration The duration to add to the current deadline, in days.\\n   * @return The new deadline timestamp.\\n   */\\n  function _updateDeadline(uint _id, uint duration) private returns (uint) {\\n    uint currentDeadline = _subscriptions[_id];\\n    uint newDeadline;\\n\\n    if (currentDeadline == 0 || block.timestamp > currentDeadline) {\\n      newDeadline = block.timestamp + duration * 1 days;\\n    } else {\\n      newDeadline = currentDeadline + duration * 1 days;\\n    }\\n\\n    _subscriptions[_id] = newDeadline;\\n\\n    return newDeadline;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"planDurations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"planCosts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmptyPromoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EtherTransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"promoCode\",\"type\":\"string\"}],\"name\":\"ExpiredPromoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"InvalidPlan\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPlans\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"promoCode\",\"type\":\"string\"}],\"name\":\"InvalidPromoCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"promoCode\",\"type\":\"string\"}],\"name\":\"PromoCodeAlreadyExists\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discountRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"PromoCodeAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"Subscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"promoCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"SubscriptionWithPromoCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"duration\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"UpdateSubscription\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MODERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"addSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"planCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"promoCode\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SubscriptionManager.PromoCode\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setPromoCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"promoCodeName\",\"type\":\"string\"}],\"name\":\"subscribeWithPromoCode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"subscriptionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"subscriptionDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"subtractSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"durations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"costs\",\"type\":\"uint256[]\"}],\"name\":\"updatePlans\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SubscriptionManager", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002e640f9994d7d63a9eced7e4100bf6018d4a48a6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000005a00000000000000000000000000000000000000000000000000000000000000b400000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000214e8348c4f0000000000000000000000000000000000000000000000000000053444835ec580000000000000000000000000000000000000000000000000000853a0d2313c0000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}