{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract Treasury {\r\n    address public owner;\r\n    IERC20 public PING; // Add the PING token reference\r\n    mapping(address => bool) public hasClaimed;\r\n    bool public isClaimActive = false;\r\n\r\n    /// @notice Ensures that the caller is the owner of the contract.\r\n    /// @dev Throws an error if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the contract owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Ensures that the claim functionality is currently active.\r\n    /// @dev Throws an error if the claim functionality is paused.\r\n    modifier claimIsActive() {\r\n        require(isClaimActive, \"Claiming is currently paused\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Initializes the contract and sets the owner to the deployer.\r\n    /// @dev Sets the initial owner of the contract to the address that deploys it.\r\n    constructor(address _PINGAddress) { // Add the PING token address as a constructor parameter\r\n        owner = msg.sender;\r\n        PING = IERC20(_PINGAddress); // Initialize the PING token reference\r\n    }\r\n\r\n    /// @notice Allows a user to claim using the owner's signature.\r\n    /// @dev Uses EIP-712 typed data and ecrecover to verify the owner's signature.\r\n    /// Throws an error if the user has already claimed or if the signature is invalid.\r\n    /// @param v Recovery id of the signature.\r\n    /// @param r First output of the ECDSA signature.\r\n    /// @param s Second output of the ECDSA signature.\r\n    function claim(uint256 amount, uint8 v, bytes32 r, bytes32 s) external claimIsActive {\r\n        require(!hasClaimed[msg.sender], \"Already claimed\");\r\n\r\n        bytes32 message = keccak256(abi.encodePacked(msg.sender, amount));\r\n        bytes32 ethSignedMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\r\n\r\n        address signer = ecrecover(ethSignedMessage, v, r, s);\r\n        require(signer == owner, \"Invalid signature\");\r\n\r\n        hasClaimed[msg.sender] = true;\r\n\r\n        // Transfer the SWIFT tokens\r\n        PING.transfer(msg.sender, amount);\r\n    }\r\n\r\n\r\n    /// @notice Allows the owner to toggle the claim functionality on or off.\r\n    /// @dev Toggles the state of the `isClaimActive` variable.\r\n    function toggleClaim() external onlyOwner {\r\n        isClaimActive = !isClaimActive;\r\n    }\r\n\r\n    /// @notice Allows the owner to withdraw any ERC20 tokens from the contract.\r\n    /// @dev Transfers the full balance of the specified ERC20 token to the owner.\r\n    /// Throws an error if the transfer fails.\r\n    /// @param tokenAddress The address of the ERC20 token to withdraw.\r\n    function withdrawTokens(address tokenAddress) external onlyOwner {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(owner, balance), \"Transfer failed\");\r\n    }\r\n\r\n    /// @notice Allows the owner to withdraw any ETH from the contract.\r\n    /// @dev Transfers the full ETH balance of the contract to the owner.\r\n    function withdrawETH() external onlyOwner {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_PINGAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PING\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClaimActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Treasury", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ee521d9bf3467d7193b7413122d2cb05c6dae256", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3c1aa1a89da2acfde7b54388fc69150129389f8ab705857a7638df64c3916f29"}