{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (Address.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\r\\n     */\\r\\n    error AddressInsufficientBalance(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev There\\u0027s no code at `target` (it is not a contract).\\r\\n     */\\r\\n    error AddressEmptyCode(address target);\\r\\n\\r\\n    /**\\r\\n     * @dev A call to an address target failed. The target may have reverted.\\r\\n     */\\r\\n    error FailedInnerCall();\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        if (address(this).balance \\u003c amount) {\\r\\n            revert AddressInsufficientBalance(address(this));\\r\\n        }\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        if (!success) {\\r\\n            revert FailedInnerCall();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\r\\n     * up by this function (like regular Solidity function calls). However, if\\r\\n     * the call reverted with no returned reason, this function reverts with a\\r\\n     * {FailedInnerCall} error.\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        if (address(this).balance \\u003c value) {\\r\\n            revert AddressInsufficientBalance(address(this));\\r\\n        }\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\r\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\r\\n     * unsuccessful call.\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (!success) {\\r\\n            _revert(returndata);\\r\\n        } else {\\r\\n            // only check if target is a contract if the call was successful and the return data is empty\\r\\n            // otherwise we already know that it was a contract\\r\\n            if (returndata.length == 0 \\u0026\\u0026 target.code.length == 0) {\\r\\n                revert AddressEmptyCode(target);\\r\\n            }\\r\\n            return returndata;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\\u0027t, either by bubbling the\\r\\n     * revert reason or with a default {FailedInnerCall} error.\\r\\n     */\\r\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\r\\n        if (!success) {\\r\\n            _revert(returndata);\\r\\n        } else {\\r\\n            return returndata;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\r\\n     */\\r\\n    function _revert(bytes memory returndata) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length \\u003e 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert FailedInnerCall();\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.1) (Context.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n}\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (ECDSA.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    enum RecoverError {\\r\\n        NoError,\\r\\n        InvalidSignature,\\r\\n        InvalidSignatureLength,\\r\\n        InvalidSignatureS\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The signature derives the `address(0)`.\\r\\n     */\\r\\n    error ECDSAInvalidSignature();\\r\\n\\r\\n    /**\\r\\n     * @dev The signature has an invalid length.\\r\\n     */\\r\\n    error ECDSAInvalidSignatureLength(uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev The signature has an S value that is in the upper half order.\\r\\n     */\\r\\n    error ECDSAInvalidSignatureS(bytes32 s);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\r\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\r\\n     * and a bytes32 providing additional information about the error.\\r\\n     *\\r\\n     * If no error is returned, then the address can be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\r\\n     *\\r\\n     * Documentation for signature generation:\\r\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\r\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\r\\n     */\\r\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\r\\n        if (signature.length == 65) {\\r\\n            bytes32 r;\\r\\n            bytes32 s;\\r\\n            uint8 v;\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        } else {\\r\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\r\\n     *\\r\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\r\\n     */\\r\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\r\\n        unchecked {\\r\\n            bytes32 s = vs \\u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\r\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\r\\n            uint8 v = uint8((uint256(vs) \\u003e\\u003e 255) + 27);\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address, RecoverError, bytes32) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (301): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\r\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\r\\n        }\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        if (signer == address(0)) {\\r\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\r\\n        }\\r\\n\\r\\n        return (signer, RecoverError.NoError, bytes32(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\r\\n     */\\r\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\r\\n        if (error == RecoverError.NoError) {\\r\\n            return; // no error: do nothing\\r\\n        } else if (error == RecoverError.InvalidSignature) {\\r\\n            revert ECDSAInvalidSignature();\\r\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\r\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\r\\n        } else if (error == RecoverError.InvalidSignatureS) {\\r\\n            revert ECDSAInvalidSignatureS(errorArg);\\r\\n        }\\r\\n    }\\r\\n}\"},\"GemsClaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\r\\nimport { SafeERC20 } from \\\"./SafeERC20.sol\\\";\\r\\nimport { Ownable, Ownable2Step } from \\\"./Ownable2Step.sol\\\";\\r\\nimport { MerkleProof } from \\\"./MerkleProof.sol\\\";\\r\\nimport { ECDSA } from \\\"./ECDSA.sol\\\";\\r\\nimport { MessageHashUtils } from \\\"./MessageHashUtils.sol\\\";\\r\\nimport { ReentrancyGuard } from \\\"./ReentrancyGuard.sol\\\";\\r\\n\\r\\nimport { IGemsNFT } from \\\"./IGemsNFT.sol\\\";\\r\\n\\r\\n/// @title GemsClaims contract\\r\\n/// @notice Implements the claiming of Gems Token and NFT\\r\\n/// @dev The claims contract allows you to claim gems tokens and nfts\\r\\ncontract GemsClaims is Ownable2Step, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /// Max length of the array\\r\\n    uint8 private constant MAX_LENGTH = 6;\\r\\n\\r\\n    /// The address of gems token\\r\\n    IERC20 public immutable GEMS;\\r\\n\\r\\n    /// The address of gems nft contract\\r\\n    IGemsNFT public immutable gemsNFT;\\r\\n\\r\\n    /// The address will distribute gems tokens\\r\\n    address public gemsWallet;\\r\\n\\r\\n    /// @notice The address of signerWallet\\r\\n    address public signerWallet;\\r\\n\\r\\n    /// @notice The tokens root of the tree\\r\\n    bytes32 public root;\\r\\n\\r\\n    /// @notice Gives info of user\\u0027s gems token claim\\r\\n    mapping(address =\\u003e bool) public isClaimed;\\r\\n\\r\\n    /// @notice Gives info about address\\u0027s permission\\r\\n    mapping(address =\\u003e bool) public blacklistAddress;\\r\\n\\r\\n    /// @dev Emitted when address of gems wallet is updated\\r\\n    event GemsWalletUpdated(address indexed prevAddress, address indexed newAddress);\\r\\n\\r\\n    /// @dev Emitted when gems token are claimed\\r\\n    event Claimed(address indexed by, uint256 gemsAmount, uint256[] indexed ids, uint256[] indexed quantity);\\r\\n\\r\\n    /// @dev Emitted when address of signer is updated\\r\\n    event SignerUpdated(address indexed oldSigner, address indexed newSigner);\\r\\n\\r\\n    /// @dev Emitted when blacklist access of address is updated\\r\\n    event BlacklistUpdated(address indexed which, bool indexed accessNow);\\r\\n\\r\\n    /// @dev Emitted when merkle root is updated\\r\\n    event RootUpdated(bytes32 indexed oldRoot, bytes32 indexed newRoot);\\r\\n\\r\\n    /// @notice Thrown when address is blacklisted\\r\\n    error Blacklisted();\\r\\n\\r\\n    /// @notice Thrown when updating an address with zero address\\r\\n    error ZeroAddress();\\r\\n\\r\\n    /// @notice Thrown when root value is zero\\r\\n    error InvalidRoot();\\r\\n\\r\\n    /// @notice Thrown when Merkle proof is invalid\\r\\n    error InvalidProof();\\r\\n\\r\\n    /// @notice Thrown when tokens are already claimed\\r\\n    error AlreadyClaimed();\\r\\n\\r\\n    /// @notice Thrown when trying to mint nft Id greater than 5\\r\\n    error InvalidNftType();\\r\\n\\r\\n    /// @notice Thrown when two array lengths does not match\\r\\n    error ArrayLengthMismatch();\\r\\n\\r\\n    /// @notice Thrown when updating with the same value as previously stored\\r\\n    error IdenticalValue();\\r\\n\\r\\n    /// @notice Thrown when Sign is invalid\\r\\n    error InvalidSignature();\\r\\n\\r\\n    /// @notice Restricts when updating wallet/contract address to zero address\\r\\n    modifier checkAddressZero(address which) {\\r\\n        if (which == address(0)) {\\r\\n            revert ZeroAddress();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Confirms whether the user is blacklisted\\r\\n    modifier notBlackListed(address user) {\\r\\n        if (blacklistAddress[user]) {\\r\\n            revert Blacklisted();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Constructor\\r\\n    /// @param gemsToken The address of gems token\\r\\n    /// @param gemsNFTAddress The address of gems nft contract\\r\\n    /// @param owner The address of the owner wallet\\r\\n    /// @param gemsWalletAddress The address of the wallet that which transfer tokens\\r\\n    /// @param signerAddress The address of the signer wallet\\r\\n    /// @param merkleRoot The merkle root of the tree\\r\\n    constructor(\\r\\n        IERC20 gemsToken,\\r\\n        IGemsNFT gemsNFTAddress,\\r\\n        address owner,\\r\\n        address gemsWalletAddress,\\r\\n        address signerAddress,\\r\\n        bytes32 merkleRoot\\r\\n    ) Ownable(owner) {\\r\\n        if (\\r\\n            address(gemsToken) == address(0) ||\\r\\n            address(gemsNFTAddress) == address(0) ||\\r\\n            gemsWalletAddress == address(0) ||\\r\\n            signerAddress == address(0)\\r\\n        ) {\\r\\n            revert ZeroAddress();\\r\\n        }\\r\\n\\r\\n        if (merkleRoot == bytes32(0)) {\\r\\n            revert InvalidRoot();\\r\\n        }\\r\\n\\r\\n        GEMS = gemsToken;\\r\\n        gemsNFT = gemsNFTAddress;\\r\\n        gemsWallet = gemsWalletAddress;\\r\\n        signerWallet = signerAddress;\\r\\n        root = merkleRoot;\\r\\n    }\\r\\n\\r\\n    /// @notice Claims gems tokens and nfts only when `claimNFT` is true\\r\\n    /// @param amountToClaim The gems token amount to claim\\r\\n    /// @param merkleProof The merkleProof is valid if and only if the rebuilt hash matches the root of the tree\\r\\n    /// @param ids The token ids that will be minted to `to`\\r\\n    /// @param quantity The amount of nfts that will be minted to `to`\\r\\n    /// @param claimNFT The user want to claim nft or not\\r\\n    /// @param v The `v` signature parameter\\r\\n    /// @param r The `r` signature parameter\\r\\n    /// @param s The `s` signature parameter\\r\\n    function claimGems(\\r\\n        uint256 amountToClaim,\\r\\n        bytes32[] calldata merkleProof,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata quantity,\\r\\n        bool claimNFT,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external nonReentrant notBlackListed(msg.sender) {\\r\\n        if (isClaimed[msg.sender]) {\\r\\n            revert AlreadyClaimed();\\r\\n        }\\r\\n\\r\\n        _verifySign(amountToClaim, ids, quantity, v, r, s);\\r\\n\\r\\n        if (ids.length != quantity.length) {\\r\\n            revert ArrayLengthMismatch();\\r\\n        }\\r\\n\\r\\n        if (ids.length \\u003e MAX_LENGTH) {\\r\\n            revert InvalidNftType();\\r\\n        }\\r\\n\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amountToClaim, ids, quantity));\\r\\n        bool success = MerkleProof.verify(merkleProof, root, leaf);\\r\\n\\r\\n        if (!success) {\\r\\n            revert InvalidProof();\\r\\n        }\\r\\n\\r\\n        isClaimed[msg.sender] = true;\\r\\n\\r\\n\\r\\n        if (claimNFT \\u0026\\u0026 ids.length \\u003e 0) {\\r\\n            gemsNFT.mint(msg.sender, ids, quantity);\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /// @notice Changes gems wallet to a new address\\r\\n    /// @param newGemsWallet The address of the new gems wallet\\r\\n    function changeGemsWallet(address newGemsWallet) external checkAddressZero(newGemsWallet) onlyOwner {\\r\\n        address oldWallet = gemsWallet;\\r\\n\\r\\n        if (oldWallet == newGemsWallet) {\\r\\n            revert IdenticalValue();\\r\\n        }\\r\\n\\r\\n        emit GemsWalletUpdated({ prevAddress: oldWallet, newAddress: newGemsWallet });\\r\\n\\r\\n        gemsWallet = newGemsWallet;\\r\\n    }\\r\\n\\r\\n    /// @notice Changes signer wallet address\\r\\n    /// @param newSigner The address of the new signer wallet\\r\\n    function changeSigner(address newSigner) external checkAddressZero(newSigner) onlyOwner {\\r\\n        address oldSigner = signerWallet;\\r\\n\\r\\n        if (oldSigner == newSigner) {\\r\\n            revert IdenticalValue();\\r\\n        }\\r\\n\\r\\n        emit SignerUpdated({ oldSigner: oldSigner, newSigner: newSigner });\\r\\n\\r\\n        signerWallet = newSigner;\\r\\n    }\\r\\n\\r\\n    /// @notice Changes the access of any address in contract interaction\\r\\n    /// @param which The address for which access is updated\\r\\n    /// @param access The access decision of `which` address\\r\\n    function updateBlackListedUser(address which, bool access) external checkAddressZero(which) onlyOwner {\\r\\n        bool oldAccess = blacklistAddress[which];\\r\\n\\r\\n        if (oldAccess == access) {\\r\\n            revert IdenticalValue();\\r\\n        }\\r\\n\\r\\n        emit BlacklistUpdated({ which: which, accessNow: access });\\r\\n\\r\\n        blacklistAddress[which] = access;\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the merkle root with a new value\\r\\n    /// @param newRoot The new merkle root\\r\\n    function updateRoot(bytes32 newRoot) external onlyOwner {\\r\\n        bytes32 oldRoot = root;\\r\\n\\r\\n        if (oldRoot == newRoot) {\\r\\n            revert IdenticalValue();\\r\\n        }\\r\\n\\r\\n        if (newRoot == bytes32(0)) {\\r\\n            revert InvalidRoot();\\r\\n        }\\r\\n\\r\\n        emit RootUpdated({ oldRoot: oldRoot, newRoot: newRoot });\\r\\n\\r\\n        root = newRoot;\\r\\n    }\\r\\n\\r\\n    /// @notice The helper function which verifies signature, signed by signerWallet, reverts if Invalid\\r\\n    function _verifySign(\\r\\n        uint256 gemsTokenAmount,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata quantity,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) private view {\\r\\n        bytes32 encodedMessageHash = keccak256(abi.encodePacked(msg.sender, gemsTokenAmount, ids, quantity));\\r\\n\\r\\n        if (signerWallet != ECDSA.recover(MessageHashUtils.toEthSignedMessageHash(encodedMessageHash), v, r, s)) {\\r\\n            revert InvalidSignature();\\r\\n        }\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\r\\n     * caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\"},\"IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account\\u0027s ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\\u0027t\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n *\\r\\n * ==== Security Considerations\\r\\n *\\r\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\r\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\r\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\r\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\r\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\r\\n * generally recommended is:\\r\\n *\\r\\n * ```solidity\\r\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\r\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\r\\n *     doThing(..., value);\\r\\n * }\\r\\n *\\r\\n * function doThing(..., uint256 value) public {\\r\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\r\\n *     ...\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\r\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\r\\n * {SafeERC20-safeTransferFrom}).\\r\\n *\\r\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\r\\n * contracts should have entry points that don\\u0027t rely on permit.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\\u0027s tokens,\\r\\n     * given ``owner``\\u0027s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``\\u0027s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     *\\r\\n     * CAUTION: See Security Considerations above.\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``\\u0027s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\"},\"IGemsNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.25;\\r\\n\\r\\ninterface IGemsNFT {\\r\\n    /// @notice Mint nfts to the user\\r\\n    /// @param to The address to which nfts will be minted, it will be non-zero address\\r\\n    /// @param ids The token ids that will be minted to `to`\\r\\n    /// @param quantity The amount of nfts that will be minted to `to`\\r\\n    function mint(address to, uint256[] memory ids, uint256[] memory quantity) external;\\r\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (Math.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Muldiv operation overflow.\\r\\n     */\\r\\n    error MathOverflowedMulDiv();\\r\\n\\r\\n    enum Rounding {\\r\\n        Floor, // Toward negative infinity\\r\\n        Ceil, // Toward positive infinity\\r\\n        Trunc, // Toward zero\\r\\n        Expand // Away from zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a \\u0026 b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\r\\n     * of rounding towards zero.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (b == 0) {\\r\\n            // Guarantee the same behavior as in a regular Solidity division.\\r\\n            return a / b;\\r\\n        }\\r\\n\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\r\\n     * denominator == 0.\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\r\\n     * Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\r\\n                // The surrounding unchecked block does not change this fact.\\r\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            if (denominator \\u003c= prod1) {\\r\\n                revert MathOverflowedMulDiv();\\r\\n            }\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\r\\n            // Always \\u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            uint256 twos = denominator \\u0026 (0 - denominator);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\\u0027s lifting lemma, this also\\r\\n            // works in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don\\u0027t need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (unsignedRoundsUp(rounding) \\u0026\\u0026 mulmod(x, y, denominator) \\u003e 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\r\\n     * towards zero.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.\\u0027s \\\"Hacker\\u0027s Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) \\u003c= a \\u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) \\u003c= a \\u003c 2**(log2(a) + 1)`\\r\\n        // \u2192 `sqrt(2**k) \\u003c= sqrt(a) \\u003c sqrt(2**(k+1))`\\r\\n        // \u2192 `2**(k/2) \\u003c= sqrt(a) \\u003c 2**((k+1)/2) \\u003c= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 \\u003c\\u003c (log2(a) \\u003e\\u003e 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton\\u0027s method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 result * result \\u003c a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value \\u003e\\u003e 128 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 64 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 32 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 16 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 8 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 4 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 2 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 1 \\u003e 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c result \\u003c value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value \\u003e= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 10 ** result \\u003c value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value \\u003e\\u003e 128 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 64 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 32 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 16 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 8 \\u003e 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c (result \\u003c\\u003c 3) \\u003c value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\r\\n     */\\r\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\r\\n        return uint8(rounding) % 2 == 1;\\r\\n    }\\r\\n}\"},\"MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (MerkleProof.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev These functions deal with verification of Merkle Tree proofs.\\r\\n *\\r\\n * The tree and the proofs can be generated using our\\r\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\r\\n * You will find a quickstart guide in the readme.\\r\\n *\\r\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\r\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\r\\n * This is because the concatenation of a sorted pair of internal nodes in\\r\\n * the Merkle tree could be reinterpreted as a leaf value.\\r\\n * OpenZeppelin\\u0027s JavaScript library generates Merkle trees that are safe\\r\\n * against this attack out of the box.\\r\\n */\\r\\nlibrary MerkleProof {\\r\\n    /**\\r\\n     *@dev The multiproof provided is not valid.\\r\\n     */\\r\\n    error MerkleProofInvalidMultiproof();\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\r\\n     * defined by `root`. For this, a `proof` must be provided, containing\\r\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\r\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProof(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {verify}\\r\\n     */\\r\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProofCalldata(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\r\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\r\\n     * hash matches the root of the tree. When processing the proof, the pairs\\r\\n     * of leafs \\u0026 pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processProof}\\r\\n     */\\r\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\r\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function multiProofVerify(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {multiProofVerify}\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function multiProofVerifyCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\r\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\r\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\r\\n     * respectively.\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\r\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\r\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\r\\n     */\\r\\n    function processMultiProof(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the Merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        if (leavesLen + proofLen != totalHashes + 1) {\\r\\n            revert MerkleProofInvalidMultiproof();\\r\\n        }\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\\u0027s \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i \\u003c totalHashes; i++) {\\r\\n            bytes32 a = leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes \\u003e 0) {\\r\\n            if (proofPos != proofLen) {\\r\\n                revert MerkleProofInvalidMultiproof();\\r\\n            }\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen \\u003e 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function processMultiProofCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the Merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        if (leavesLen + proofLen != totalHashes + 1) {\\r\\n            revert MerkleProofInvalidMultiproof();\\r\\n        }\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\\u0027s \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i \\u003c totalHashes; i++) {\\r\\n            bytes32 a = leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes \\u003e 0) {\\r\\n            if (proofPos != proofLen) {\\r\\n                revert MerkleProofInvalidMultiproof();\\r\\n            }\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen \\u003e 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sorts the pair (a, b) and hashes the result.\\r\\n     */\\r\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\r\\n        return a \\u003c b ? _efficientHash(a, b) : _efficientHash(b, a);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\\u0027t allocate or expand memory.\\r\\n     */\\r\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, a)\\r\\n            mstore(0x20, b)\\r\\n            value := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n}\"},\"MessageHashUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (MessageHashUtils.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Strings} from \\\"./Strings.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\r\\n *\\r\\n * The library provides methods for generating a hash of a message that conforms to the\\r\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\r\\n * specifications.\\r\\n */\\r\\nlibrary MessageHashUtils {\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\r\\n     * `0x45` (`personal_sign` messages).\\r\\n     *\\r\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\r\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\r\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\r\\n     *\\r\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\r\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\r\\n     * be re-hashed.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\r\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\r\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\r\\n     * `0x45` (`personal_sign` messages).\\r\\n     *\\r\\n     * The digest is calculated by prefixing an arbitrary `message` with\\r\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\r\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\r\\n     * `0x00` (data with intended validator).\\r\\n     *\\r\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\r\\n     * `validator` address. Then hashing the result.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\r\\n     *\\r\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\r\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\r\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let ptr := mload(0x40)\\r\\n            mstore(ptr, hex\\\"19_01\\\")\\r\\n            mstore(add(ptr, 0x02), domainSeparator)\\r\\n            mstore(add(ptr, 0x22), structHash)\\r\\n            digest := keccak256(ptr, 0x42)\\r\\n        }\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Context} from \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is set to the address provided by the deployer. This can\\r\\n * later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address initialOwner) {\\r\\n        if (initialOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"},\"Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (Ownable2Step.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\r\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available all functions\\r\\n * from parent (Ownable).\\r\\n */\\r\\nabstract contract Ownable2Step is Ownable {\\r\\n    address private _pendingOwner;\\r\\n\\r\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the pending owner.\\r\\n     */\\r\\n    function pendingOwner() public view virtual returns (address) {\\r\\n        return _pendingOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\r\\n        _pendingOwner = newOwner;\\r\\n        emit OwnershipTransferStarted(owner(), newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual override {\\r\\n        delete _pendingOwner;\\r\\n        super._transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The new owner accepts the ownership transfer.\\r\\n     */\\r\\n    function acceptOwnership() public virtual {\\r\\n        address sender = _msgSender();\\r\\n        if (pendingOwner() != sender) {\\r\\n            revert OwnableUnauthorizedAccount(sender);\\r\\n        }\\r\\n        _transferOwnership(sender);\\r\\n    }\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant NOT_ENTERED = 1;\\r\\n    uint256 private constant ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    /**\\r\\n     * @dev Unauthorized reentrant call.\\r\\n     */\\r\\n    error ReentrancyGuardReentrantCall();\\r\\n\\r\\n    constructor() {\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\r\\n        if (_status == ENTERED) {\\r\\n            revert ReentrancyGuardReentrantCall();\\r\\n        }\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == ENTERED;\\r\\n    }\\r\\n}\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\r\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\r\\nimport {Address} from \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    /**\\r\\n     * @dev An operation with an ERC20 token failed.\\r\\n     */\\r\\n    error SafeERC20FailedOperation(address token);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failed `decreaseAllowance` request.\\r\\n     */\\r\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\r\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the calling contract\\u0027s allowance toward `spender` by `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n        forceApprove(token, spender, oldAllowance + value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the calling contract\\u0027s allowance toward `spender` by `requestedDecrease`. If `token` returns no\\r\\n     * value, non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\r\\n        unchecked {\\r\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\r\\n            if (currentAllowance \\u003c requestedDecrease) {\\r\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\r\\n            }\\r\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set the calling contract\\u0027s allowance toward `spender` to `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\r\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\r\\n     */\\r\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\r\\n\\r\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\r\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\r\\n            _callOptionalReturn(token, approvalCall);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data);\\r\\n        if (returndata.length != 0 \\u0026\\u0026 !abi.decode(returndata, (bool))) {\\r\\n            revert SafeERC20FailedOperation(address(token));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     *\\r\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\r\\n     */\\r\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\r\\n        // and not revert is the subcall reverts.\\r\\n\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        return success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))) \\u0026\\u0026 address(token).code.length \\u003e 0;\\r\\n    }\\r\\n}\"},\"SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (SignedMath.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard signed math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary SignedMath {\\r\\n    /**\\r\\n     * @dev Returns the largest of two signed numbers.\\r\\n     */\\r\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a \\u003e b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two signed numbers.\\r\\n     */\\r\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two signed numbers without overflow.\\r\\n     * The result is rounded towards zero.\\r\\n     */\\r\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Formula from the book \\\"Hacker\\u0027s Delight\\\"\\r\\n        int256 x = (a \\u0026 b) + ((a ^ b) \\u003e\\u003e 1);\\r\\n        return x + (int256(uint256(x) \\u003e\\u003e 255) \\u0026 (a ^ b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the absolute unsigned value of a signed value.\\r\\n     */\\r\\n    function abs(int256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // must be unchecked in order to support `n = type(int256).min`\\r\\n            return uint256(n \\u003e= 0 ? n : -n);\\r\\n        }\\r\\n    }\\r\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (Strings.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Math} from \\\"./Math.sol\\\";\\r\\nimport {SignedMath} from \\\"./SignedMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev The `value` string doesn\\u0027t fit in the specified `length`.\\r\\n     */\\r\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\r\\n        return string.concat(value \\u003c 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        uint256 localValue = value;\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n            buffer[i] = HEX_DIGITS[localValue \\u0026 0xf];\\r\\n            localValue \\u003e\\u003e= 4;\\r\\n        }\\r\\n        if (localValue != 0) {\\r\\n            revert StringsInsufficientHexLength(value, length);\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\r\\n     * representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the two strings are equal.\\r\\n     */\\r\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\r\\n        return bytes(a).length == bytes(b).length \\u0026\\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"gemsToken\",\"type\":\"address\"},{\"internalType\":\"contract IGemsNFT\",\"name\":\"gemsNFTAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gemsWalletAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Blacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdenticalValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNftType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"which\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"accessNow\",\"type\":\"bool\"}],\"name\":\"BlacklistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gemsAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"quantity\",\"type\":\"uint256[]\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"GemsWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"oldRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"RootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldSigner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"SignerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GEMS\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklistAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGemsWallet\",\"type\":\"address\"}],\"name\":\"changeGemsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToClaim\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantity\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"claimNFT\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claimGems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemsNFT\",\"outputs\":[{\"internalType\":\"contract IGemsNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemsWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"updateBlackListedUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GemsClaims", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003010ccb5419f1ef26d40a7cd3f0d707a0fa127dc000000000000000000000000ac045c00f16bd3571daa5631fad5cdf8ac6d9acb000000000000000000000000574197bdf0f7c3b68732a2c07a9b653f0bf21bae000000000000000000000000f260948d66e6be1e685335e2ff7490ec79145eab000000000000000000000000fd90fd4d1199fbb6f9f0fff72e63ead9f7de67edb8bbf07614c793392e844dc6704b99008e4c11c1fc27df2aad836bbda3973d84", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1d601f698e30abeb266488170f8c3ad047bc2598b5144692f58a792b6510e2d0"}