{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FukushimaFishData.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\ncontract FukushimaFishData {\\n\\n    error TokenNotInitiated();\\n\\n    uint8 constant CELESTIAL_FLAG = 0x01;\\n    uint8 constant BONUS_FLAG = 0x02;\\n\\n    enum AuraLevel {\\n        NONE, // 0\\n        LOW,   // 1\\n        MED, // 2\\n        HIGH, // 3\\n        OVERFLOWING // 4\\n    }\\n\\n\\n    address public owner;\\n\\n    mapping(AuraLevel => uint256) auraDailyYields;\\n\\n    // Uint256 encoded Token Metadata\\n    mapping(uint256 => uint256) _metadata;\\n    \\n    mapping(address => bool) _admin;\\n\\n    // // 0.054 $AURA / day\\n    // uint256 constant NONE = 0.054 ether;\\n\\n    // // 0.304 $AURA / day\\n    // uint256 constant LOW = 0.304 ether;\\n\\n    // // 0.75 $AURA / day\\n    // uint256 constant MED = 0.75 ether;\\n\\n    // // 3 $AURA / day\\n    // uint256 constant HIGH = 3 ether;\\n\\n    // // 10 $AURA / day\\n    // uint256 constant OVERFLOWING = 10 ether;\\n\\n    // // 20 $AURA / day\\n    uint256 public BONUS = 20 ether;\\n\\n    constructor() {\\n        auraDailyYields[AuraLevel.NONE] = 0.054 ether;\\n        auraDailyYields[AuraLevel.LOW] = 0.304 ether;\\n        auraDailyYields[AuraLevel.MED] = 0.75 ether;\\n        auraDailyYields[AuraLevel.HIGH] = 3 ether;\\n        auraDailyYields[AuraLevel.OVERFLOWING] = 10 ether; \\n\\n        owner = msg.sender;\\n        _admin[msg.sender] = true;\\n    }\\n\\n    function hasFlag(uint256 flags, uint256 flag) internal pure returns(bool) {\\n        return (flags & flag) != 0;\\n    }\\n\\n\\n    modifier onlyAdmin() {\\n        require(_admin[msg.sender]);\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address to) external onlyOwner {\\n        owner = to;\\n    }\\n\\n    function setAdmin(address addr, bool status) external onlyOwner {\\n        _admin[addr] = status;\\n    }\\n\\n    function setBonus(uint256 bonusAmount) external onlyOwner {\\n        BONUS = bonusAmount;\\n    }\\n\\n    /**\\n     * Updates a given aura level\\n     * \\n     * @param auraLevel the level to update\\n     * @param amount  the amount for the given level\\n     */\\n    function updateYield(AuraLevel auraLevel, uint256 amount) external onlyOwner {\\n            auraDailyYields[auraLevel] = amount;\\n    }\\n\\n    uint256 constant REACTOR_MODIFIER = 0x01;\\n\\n    bytes32 public rootHash;\\n\\n\\n    function importData(bytes32 root) external onlyAdmin {\\n        rootHash = root;\\n    }\\n\\n\\n    function isCelestial(uint256 tokenId) external view returns (bool) {\\n        uint256 metadata = _metadata[tokenId];\\n         if (metadata == 0) revert TokenNotInitiated();\\n         (,,uint16 flags) = decode(metadata);\\n         return hasFlag(flags, CELESTIAL_FLAG);\\n    }\\n\\n    function getAuraYieldForToken(uint256 tokenId) external view returns (uint256) {\\n        uint256 metadata = _metadata[tokenId];\\n        // no token will ever be encoded as 0\\n        if (metadata == 0) revert TokenNotInitiated();\\n\\n        (, uint16 level, uint16 flags) = decode(metadata);\\n\\n        uint256 baseYield = auraDailyYields[AuraLevel(level)]; \\n\\n        if (hasFlag(flags, BONUS_FLAG)) {\\n            baseYield += BONUS;\\n        }\\n\\n        return baseYield;\\n    }\\n\\n\\n    function decode(uint256 encoded) internal pure returns(uint16 token, uint16 level, uint16 flags) {\\n        token = uint16(encoded);\\n        level = uint16(encoded >> 16);\\n        flags = uint16(encoded >> 32);\\n    }\\n\\n    function isTokenInitiated(uint256 tokenId) external view returns(bool) { \\n        return _metadata[tokenId] != 0;\\n    }  \\n\\n    function initTokenData(\\n        uint256 encoded,\\n        uint256 path,\\n        bytes32[] calldata proof\\n    ) external  {\\n        // validates the merkle tree\\n        bytes32 leaf = keccak256(abi.encode(encoded));\\n\\n        for (uint256 i; i < proof.length; i++) {\\n            // check if the path is odd and inverse the hash\\n            if (path & 1 == 1) {\\n                leaf = keccak256(abi.encodePacked(leaf, proof[i]));\\n            } else {\\n                leaf = keccak256(abi.encodePacked(proof[i], leaf));\\n            }\\n\\n            path /= 2;\\n        }\\n        \\n        require(leaf == rootHash, \\\"invalid proof.\\\");\\n\\n        // after verifying the encoded information is legit, set it\\n        (uint16 tokenId,,) = decode(encoded);\\n        _metadata[tokenId] = encoded;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc721a/=node_modules/erc721a/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"operator-filter-registry/=node_modules/operator-filter-registry/\",\r\n      \"solmate/=node_modules/solmate/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TokenNotInitiated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BONUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuraYieldForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"importData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"encoded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"initTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isCelestial\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenInitiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"setBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FukushimaFishData.AuraLevel\",\"name\":\"auraLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FukushimaFishData", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}