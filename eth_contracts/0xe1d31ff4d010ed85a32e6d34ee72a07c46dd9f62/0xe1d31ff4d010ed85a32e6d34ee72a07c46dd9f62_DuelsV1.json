{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DuelsV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\ncontract DuelsV1 is Initializable {\\n  enum ResultVote { NotVoted, First, Second, Draw }\\n\\n  address public arbiter;\\n  uint8 public commissionPercent;\\n  uint public minimalBet;\\n\\n  struct Game {\\n    address host;\\n    address player2;\\n    uint bet;\\n    uint timeStart;\\n    uint playPeriod;  \\n    bool started;\\n    bool closed;\\n    bool disagreement;\\n    ResultVote hostVote;\\n    ResultVote player2Vote;\\n  }\\n\\n  Game[] public games;\\n\\n  event Created(uint id);\\n  event Joined(uint id, address player2);\\n  event SlotFreed(uint id);\\n  event Cancel(uint id);\\n  event Start(uint id, address player2);\\n  event Victory(uint id, address winner);\\n  event Draw(uint id);\\n  event Disagreement(uint id);\\n\\n  function initialize(uint _minimalBet, uint8 _commissionPercent) public initializer {\\n    require(_commissionPercent <= 100, \\\"Procent can not be greater then 100\\\");\\n    arbiter = msg.sender;\\n    commissionPercent = _commissionPercent;\\n    minimalBet = _minimalBet;\\n  }\\n\\n  function createGame(uint _playPeriod) external payable {\\n    require(msg.value >= minimalBet, 'Your bet is too small');\\n    games.push(Game(\\n      msg.sender,\\n      address(0), \\n      msg.value,\\n      0, \\n      _playPeriod,\\n      false,\\n      false,\\n      false,\\n      ResultVote.NotVoted,\\n      ResultVote.NotVoted\\n    ));\\n    emit Created(games.length-1);\\n  }\\n\\n  function join(uint _gameIndex) external payable {\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\");\\n    // read game instance from storage once for reducing its cost\\n    Game memory game = games[_gameIndex];\\n    require(game.player2 == address(0), \\\"Slot is already taken\\\");\\n    require(msg.value >= game.bet, \\\"Your bet amount is insufficient\\\");\\n    games[_gameIndex].player2 = msg.sender;\\n    emit Joined(_gameIndex, msg.sender);\\n  }\\n\\n  function excludePlayer2(uint _gameIndex) external {\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\");\\n    Game memory game = games[_gameIndex];\\n    require(\\n      msg.sender == game.host || msg.sender == game.player2, \\n      \\\"You are not participator\\\"\\n    );\\n    require(game.player2 != address(0), \\\"Second player has not joined yet\\\");\\n    require(!game.started, \\\"Game has already been started\\\");\\n    (bool s,) = game.player2.call{value: game.bet}(\\\"\\\");\\n    require(s);\\n    games[_gameIndex].player2 = address(0);\\n    emit SlotFreed(_gameIndex);\\n  }\\n\\n  function cancel(uint _gameIndex) external {\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\");\\n    Game memory game = games[_gameIndex];\\n    require(msg.sender == game.host, \\\"You are not game host\\\");\\n    require(!game.started, \\\"Game has already been started\\\");\\n    // return all bets to players, close game\\n    if (game.player2 != address(0)) {\\n      (bool s2,) = game.player2.call{value: game.bet}(\\\"\\\");\\n      require(s2);\\n    }\\n    (bool s,) = game.host.call{value: game.bet}(\\\"\\\");\\n    require(s);\\n\\n    games[_gameIndex].closed = true;\\n    emit Cancel(_gameIndex);\\n  }\\n\\n  function start(uint _gameIndex) external {\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\");\\n    Game memory game = games[_gameIndex];\\n    require(msg.sender == game.host, \\\"You are not game host\\\");\\n    require(game.player2 != address(0), \\\"Second player has not joined yet\\\");\\n    game.started = true;\\n    game.timeStart = block.timestamp;\\n    // writing to storage\\n    games[_gameIndex] = game;\\n    emit Start(_gameIndex, game.player2);\\n  }\\n\\n  function voteResult(uint _gameIndex, ResultVote _place) external {\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\"); \\n    require(\\n      _place == ResultVote.First || _place == ResultVote.Second || _place == ResultVote.Draw,\\n      \\\"Invalid vote value\\\"\\n    );\\n    Game memory game = games[_gameIndex];\\n    require(\\n      msg.sender == game.host || msg.sender == game.player2,\\n      \\\"You are not participator\\\"\\n    );\\n    require(game.started, \\\"Game has not been started yet\\\");\\n    require(!game.closed, \\\"Game was closed\\\");\\n\\n    // set vote\\n    if (msg.sender == game.host) {\\n      games[_gameIndex].hostVote = _place;\\n      game.hostVote = _place;\\n    }\\n    else {\\n      games[_gameIndex].player2Vote = _place;\\n      game.player2Vote = _place;\\n    }\\n\\n    // both players voted\\n    if (game.hostVote != ResultVote.NotVoted && game.player2Vote != ResultVote.NotVoted) {\\n      if (game.hostVote == ResultVote.First && game.player2Vote == ResultVote.Second) {\\n        if (game.disagreement) games[_gameIndex].disagreement = false;\\n        _rewardTheWinner(_gameIndex, game, game.host);\\n      }\\n      else if (game.hostVote == ResultVote.Second && game.player2Vote == ResultVote.First) {\\n        if (game.disagreement) games[_gameIndex].disagreement = false;\\n        _rewardTheWinner(_gameIndex, game, game.player2);\\n      }\\n      else if (game.hostVote == ResultVote.Draw && game.player2Vote == ResultVote.Draw) {\\n        if (game.disagreement) games[_gameIndex].disagreement = false;\\n        _callDraw(_gameIndex, game);\\n      }\\n      else {\\n        games[_gameIndex].disagreement = true;\\n        emit Disagreement(_gameIndex);\\n      }\\n    }\\n\\n    // if playPeriod is over and other player not voted - any vote accepts as source of truth\\n    else if (block.timestamp > game.timeStart + game.playPeriod\\n        && (game.hostVote == ResultVote.NotVoted || game.player2Vote == ResultVote.NotVoted)) {\\n      if (_place == ResultVote.First) {\\n        _rewardTheWinner(_gameIndex, game, msg.sender);\\n      }\\n      else if (_place == ResultVote.Second) {\\n        _rewardTheWinner(_gameIndex, game, msg.sender == game.host ? game.player2 : game.host);\\n      }\\n      else {\\n        _callDraw(_gameIndex, game);\\n      }\\n    }\\n  }\\n\\n  function forceAppointWinner(uint _gameIndex, address _winner) external onlyArbiter {\\n    // arbiter apoint winner if there is disagreement of places taken\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\");\\n    Game memory game = games[_gameIndex];\\n    require(game.disagreement, \\\"Players did not reached a disagreement\\\");\\n    require(game.host == _winner || game.player2 == _winner, \\\"Address must be player in this game\\\");\\n    _rewardTheWinner(_gameIndex, game, _winner);\\n  }\\n\\n  function _rewardTheWinner(uint _gameIndex, Game memory game, address _winner) internal {\\n    require(!game.closed, \\\"Game has already been closed\\\");\\n    uint commission = game.bet * 2 * commissionPercent / 100;\\n    (bool s,) = arbiter.call{value: commission}(\\\"\\\");\\n    require(s);\\n\\n    uint prizeFund = game.bet * 2 - commission; \\n    (s,) = _winner.call{value: prizeFund}(\\\"\\\");\\n    require(s);\\n\\n    games[_gameIndex].closed = true;\\n    emit Victory(_gameIndex, _winner);\\n  }\\n\\n  function forceDraw(uint _gameIndex) external onlyArbiter {\\n    require(games.length > _gameIndex, \\\"Game was not created yet\\\");\\n    Game memory game = games[_gameIndex];\\n    require(game.disagreement, \\\"Players did not reached a disagreement\\\");\\n    _callDraw(_gameIndex, game);\\n  }\\n\\n  function _callDraw(uint _gameIndex, Game memory game) internal {\\n    require(!game.closed, \\\"Game has already been closed\\\");\\n    uint commission = game.bet * 2 * commissionPercent / 100;\\n    (bool s,) = arbiter.call{value: commission}(\\\"\\\");\\n    require(s);\\n\\n    uint prizeFund = game.bet * 2 - commission;\\n      \\n    (s,) = game.player2.call{value: prizeFund / 2}(\\\"\\\");\\n    require(s);\\n    (s,) = game.host.call{value: prizeFund / 2}(\\\"\\\");\\n    require(s);\\n\\n    games[_gameIndex].closed = true;\\n    emit Draw(_gameIndex);\\n  }\\n\\n  function setArbiter(address _arbiter) external onlyArbiter {\\n    arbiter = _arbiter;\\n  }\\n  function setMinimalBet(uint _minimalBet) external onlyArbiter {\\n    minimalBet = _minimalBet;\\n  }\\n  function setCommissionPercent(uint8 _commissionPercent) public onlyArbiter {\\n    require(_commissionPercent <= 100, \\\"Procent can not be greater then 100\\\");\\n    commissionPercent = _commissionPercent;\\n  }\\n\\n  modifier onlyArbiter {\\n    require(msg.sender == arbiter, \\\"You are not arbiter\\\");\\n    _;\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Disagreement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Draw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"}],\"name\":\"Joined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"SlotFreed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"}],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"Victory\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"arbiter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_playPeriod\",\"type\":\"uint256\"}],\"name\":\"createGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"excludePlayer2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"forceAppointWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"forceDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playPeriod\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"started\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"closed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disagreement\",\"type\":\"bool\"},{\"internalType\":\"enum DuelsV1.ResultVote\",\"name\":\"hostVote\",\"type\":\"uint8\"},{\"internalType\":\"enum DuelsV1.ResultVote\",\"name\":\"player2Vote\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimalBet\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_commissionPercent\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimalBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbiter\",\"type\":\"address\"}],\"name\":\"setArbiter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_commissionPercent\",\"type\":\"uint8\"}],\"name\":\"setCommissionPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimalBet\",\"type\":\"uint256\"}],\"name\":\"setMinimalBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum DuelsV1.ResultVote\",\"name\":\"_place\",\"type\":\"uint8\"}],\"name\":\"voteResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DuelsV1", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}