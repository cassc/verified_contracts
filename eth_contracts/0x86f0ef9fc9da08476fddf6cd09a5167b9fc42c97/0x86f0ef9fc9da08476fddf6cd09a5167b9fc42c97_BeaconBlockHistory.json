{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BeaconBlockHistory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2024\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport \\\"./BeaconBlockHistoryBase.sol\\\";\\nimport \\\"./lib/Propogate.sol\\\";\\nimport \\\"./interfaces/IBlockHistory.sol\\\";\\nimport \\\"./interfaces/IBeaconBlockHistory.sol\\\";\\n\\n/**\\n * @title BeaconBlockHistory\\n * @author Theori, Inc.\\n * @notice BeaconBlockHistory allows trustless and cheap verification of any\\n *         post-Dencun historical beacon block root. Since the beacon blocks\\n *         contain the execution block headers, this also enables verifying\\n *         those execution block hashes.\\n *\\n * @notice By propogating some queries to Relic's original BlockHistory contract,\\n *         this contract enables cheap verification of *all* execution block hashes\\n *         back to genesis.\\n *\\n * @dev This works by leveraging the native beacon block hash oracle contract introduced\\n *      in EIP-4788: https://eips.ethereum.org/EIPS/eip-4788#block-structure-and-validity.\\n *\\n *      Recent blocks (< 8191 slots old) can be accessed by directly querying the oracle.\\n *      Then, using an SSZ merkle proof of the `BeaconState.historical_summaries` elements,\\n *      we can verifiably access beacon block root since the Capella hardfork.\\n *\\n *      To reduce redundancy, this contract supports caching each value of the\\n *      `historical_sumaries` list. Given this cached root, block proofs can be generated\\n *      using only `BeaconBlock` roots (and data), which are easily accessible.\\n *\\n *      Execution block information can then be verified with merkle proofs of\\n *      the `BeaconBlock.body.execution_payload.block_{number,hash}` fields.\\n */\\ncontract BeaconBlockHistory is AccessControl, BeaconBlockHistoryBase, IBlockHistory, IBeaconBlockHistory {\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant QUERY_ROLE = keccak256(\\\"QUERY_ROLE\\\");\\n\\n    /// @dev address of the reliquary, immutable\\n    address public immutable reliquary;\\n\\n    /// @dev mapping of precomitted execution block hashes\\n    mapping(uint256 => bytes32) private precomittedBlockHashes;\\n\\n    /// @dev the blockHistory which stores the data before the Dencnun fork\\n    address public immutable preDencunBlockHistory;\\n\\n    /// @dev the address of the beacon oracle contract on this network\\n    address public immutable beaconOracleContract;\\n\\n    /// @dev the first block number handled by this contract\\n    uint256 public immutable UPGRADE_BLOCK;\\n\\n    event PrecomittedBlock(uint256 indexed blockNum, bytes32 blockHash);\\n\\n    /// @dev types of block proofs supported by this and prior contracts\\n    enum ProofType {\\n        Merkle, // legacy, not supported in this contract\\n        SNARK,  // legacy, not supported in this contract\\n        Precomitted,\\n        Beacon\\n    }\\n\\n    constructor(\\n        address _reliquary,\\n        address _preDencunBlockHistory,\\n        address _beaconOracleContract,\\n        uint256 _CAPELLA_SLOT,\\n        uint256 _DENEB_SLOT,\\n        uint256 _UPGRADE_BLOCK\\n    ) BeaconBlockHistoryBase(_CAPELLA_SLOT, _DENEB_SLOT) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _setupRole(ADMIN_ROLE, msg.sender);\\n        _setupRole(QUERY_ROLE, msg.sender);\\n\\n        reliquary = _reliquary;\\n        preDencunBlockHistory = _preDencunBlockHistory;\\n        beaconOracleContract = _beaconOracleContract;\\n        UPGRADE_BLOCK = _UPGRADE_BLOCK;\\n    }\\n\\n    /**\\n     * @notice Checks if the block is a valid precomitted block.\\n     *\\n     * @param hash the alleged block hash\\n     * @param num the block number\\n     */\\n    function _validPrecomittedBlock(bytes32 hash, uint256 num) internal view returns (bool) {\\n        bytes32 stored = precomittedBlockHashes[num];\\n        return stored != bytes32(0) && stored == hash;\\n    }\\n\\n    /**\\n     * @notice Determines if the block is accessible via the BLOCKHASH opcode\\n     *\\n     * @param num the block number\\n     */\\n    function _isBlockhashEVMAccessible(uint256 num) internal view returns (bool) {\\n        return num < block.number && block.number - num <= 256;\\n    }\\n\\n    /**\\n     * @notice Checks if the block is a current block (defined as being\\n     *         accessible in the EVM, i.e. <= 256 blocks old) and that the hash\\n     *         is correct.\\n     *\\n     * @param hash the alleged block hash\\n     * @param num the block number\\n     * @return the validity\\n     */\\n    function _validCurrentBlock(bytes32 hash, uint256 num) internal view returns (bool) {\\n        // the block hash must be accessible in the EVM and match\\n        return _isBlockhashEVMAccessible(num) && (blockhash(num) == hash);\\n    }\\n\\n    function _storeCommittedBlock(uint256 blockNum, bytes32 blockHash) internal {\\n        require(blockHash != bytes32(0), \\\"invalid blockhash\\\");\\n        precomittedBlockHashes[blockNum] = blockHash;\\n        emit PrecomittedBlock(blockNum, blockHash);\\n    }\\n\\n    /**\\n     * @notice commits to a recent execution block header\\n     * @notice reverts if the blockhash is not natively accessible\\n     *\\n     * @param blockNum the block number to commit\\n     */\\n    function commitRecent(uint256 blockNum) external {\\n        require(_isBlockhashEVMAccessible(blockNum), \\\"target block not in EVM\\\");\\n        _storeCommittedBlock(blockNum, blockhash(blockNum));\\n    }\\n\\n    /**\\n     * @dev queries the oracle for a beacon block root\\n     * @dev the returned root will be the parent of the block at the given timestamp\\n     */\\n    function _queryBeaconRootOracle(\\n        uint256 nextBlockTimestamp\\n    ) internal view returns (bytes32 blockRoot) {\\n        address oracle = beaconOracleContract;\\n        assembly {\\n            mstore(0, nextBlockTimestamp)\\n            let success := staticcall(gas(), oracle, 0, 0x20, 0, 0x20)\\n            switch success\\n            case 0 {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                blockRoot := mload(0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev uses the oracle to query for a beacon block root\\n     */\\n    function _verifyOracleBlockRoot(\\n        bytes calldata rawProof\\n    ) internal view returns (bytes32 blockRoot) {\\n        OracleBlockRootProof calldata proof = _castOracleBlockRootProof(rawProof);\\n        // if no summary proof is provided, use the oracle to access a recent block root\\n        blockRoot = _queryBeaconRootOracle(proof.timestamp);\\n    }\\n\\n    /**\\n     * @dev implements beacon block root verification for L1\\n     * @dev supports all proof types, including oracle queries\\n     */\\n    function _verifyBeaconBlockRoot(\\n        bytes calldata proof\\n    ) internal override view returns (bytes32 blockRoot) {\\n        BeaconProofType typ;\\n        (typ, proof) = parseBeaconProofType(proof);\\n\\n        if (typ == BeaconProofType.Summary) {\\n            return _verifySummaryBlockRoot(proof);\\n        } else if (typ == BeaconProofType.Oracle) {\\n            return _verifyOracleBlockRoot(proof);\\n        } else if (typ == BeaconProofType.Relative) {\\n            return _verifyRelativeBlockRoot(proof);\\n        } else if (typ == BeaconProofType.Header) {\\n            return _verifyHeaderBlockRoot(proof);\\n        } else {\\n            revert(\\\"unsupported proof type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice verifies a beacon block root\\n     * @param proof the proof of the beacon blcok\\n     * @return blockRoot the `BeaconBlock` root\\n     */\\n    function verifyBeaconBlockRoot(\\n        bytes calldata proof\\n    ) external view onlyRole(QUERY_ROLE) returns (bytes32 blockRoot) {\\n        blockRoot = _verifyBeaconBlockRoot(proof);\\n    }\\n\\n    /**\\n     * @notice Parses a proof type and proof from the encoded proof\\n     *\\n     * @param encodedProof the encoded proof\\n     * @return typ the proof type\\n     * @return proof the remaining encoded proof\\n     */\\n    function parseProofType(bytes calldata encodedProof)\\n        internal\\n        pure\\n        returns (ProofType typ, bytes calldata proof)\\n    {\\n        require(encodedProof.length > 0, \\\"cannot parse proof type\\\");\\n        typ = ProofType(uint8(encodedProof[0]));\\n        proof = encodedProof[1:];\\n    }\\n\\n    /**\\n     * @notice Checks if an execution block hash is valid. A proof is required unless\\n     *         the block is current (accesible in the EVM) or precomitted.\\n     * @notice if the target block is before the Dencun fork, the query will be propogated\\n     *         to the pre-Dencun BlockHistory contract.\\n     *\\n     * @param hash the hash to check\\n     * @param num the block number for the alleged hash\\n     * @param proof the proof (if needed)\\n     * @return the validity\\n     */\\n    function _validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) internal override view returns (bool) {\\n        // if attempting to verify an unhandled block,\\n        // propogate the call to the legacy BlockHistory\\n        if (num < UPGRADE_BLOCK) {\\n            Propogate.staticcall(preDencunBlockHistory); // does not return\\n        }\\n        require(num < block.number, \\\"given block is current or future block\\\");\\n\\n        if (_validCurrentBlock(hash, num)) {\\n            return true;\\n        }\\n\\n        ProofType typ;\\n        (typ, proof) = parseProofType(proof);\\n        if (typ == ProofType.Precomitted) {\\n            return _validPrecomittedBlock(hash, num);\\n        } else if (typ == ProofType.Beacon) {\\n            return _validBlockHashWithBeacon(hash, num, proof);\\n        } else {\\n            revert(\\\"unsupported proof type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a block hash is correct. A proof is required unless the\\n     *         block is current (accesible in the EVM) or precomitted.\\n     *         Reverts if proof is invalid.\\n     *\\n     * @param hash the hash to check\\n     * @param num the block number for the alleged hash\\n     * @param proof the merkle witness or SNARK proof (if needed)\\n     */\\n    function validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) external view returns (bool) {\\n        // optimization: check if sender is reliquary first,\\n        // so we don't touch storage in the typical path\\n        require(msg.sender == reliquary || hasRole(QUERY_ROLE, msg.sender));\\n        return _validBlockHash(hash, num, proof);\\n    }\\n\\n    function getBlockSummary(uint256 slot) external view returns (bytes32 result) {\\n        require(hasRole(QUERY_ROLE, msg.sender) || msg.sender == address(0));\\n        result = _getBlockSummary(slot);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BeaconBlockHistoryBase.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2024\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./lib/SSZ.sol\\\";\\nimport \\\"./lib/CoreTypes.sol\\\";\\n\\n/**\\n * @title BeaconBlockHistoryBase\\n * @author Theori, Inc.\\n * @notice BeaconBlockHistoryBase implements common logic for Beacon block verification.\\n *\\n * @notice Logic which is specific to L1 or L2 is implemented in subcontracts.\\n */\\nabstract contract BeaconBlockHistoryBase {\\n    uint256 private constant SLOTS_PER_HISTORICAL_ROOT = 1 << 13;\\n\\n    /// @dev A mapping from slot number to the\\n    //       `historical_summary.block_summary_root`\\n    mapping(uint256 => bytes32) private blockSummaries;\\n\\n    /// @dev the slot of the Capella fork on this network\\n    uint256 public immutable CAPELLA_SLOT;\\n\\n    /// @dev the slot of the Dencun fork on this network\\n    uint256 public immutable DENEB_SLOT;\\n\\n    event ImportBlockSummary(uint256 indexed slot, bytes32 summary);\\n\\n    /// @dev types of beacon block proofs\\n    enum BeaconProofType {\\n        Oracle,\\n        Summary,\\n        Relative,\\n        Header\\n    }\\n\\n    /// @dev a proof of a `HistoricalSummary.block_summary_root` at some slot\\n    struct HistoricalBlockSummaryProof {\\n        bytes beaconBlockProof;\\n        bytes32[] slotProof;\\n        bytes32[] stateRootProof;\\n        uint256 blockSummaryIndex;\\n        bytes32[] blockSummaryProof;\\n    }\\n\\n    /// @dev a proof that a particular beacon block root is valid by reference to a historical summary\\n    struct SummaryBlockRootProof {\\n        /// @dev the proof to verify block summary\\n        bytes summaryProof;\\n        /// @dev the index of the slot in the summary\\n        uint256 index;\\n        /// @dev the summary merkle proof\\n        bytes32[] indexProof;\\n    }\\n\\n    /// @dev a proof that a particular beacon block root is valid by querying the oracle\\n    struct OracleBlockRootProof {\\n        /// @dev the timestamp to query the oracle with\\n        uint256 timestamp;\\n    }\\n\\n    /// @dev a proof that a particular beacon block root is valid by reference to `BeaconState.block_roots`\\n    ///      at some other beacon block\\n    struct RelativeBlockRootProof {\\n        /// @dev the proof of the base block root\\n        bytes baseProof;\\n        /// @dev the proof the base block's state root\\n        bytes32[] stateRootProof;\\n        /// @dev the index in the `block_roots` buffer\\n        uint256 index;\\n        /// @dev the proof of the entry in the state's `block_roots` vector\\n        bytes32[] relativeRootProof;\\n    }\\n\\n    /// @dev a proof that a particular beacon block root is valid by reference to the\\n    ///      `parent_beacon_block_root` field of a verifiable execution block header\\n    struct HeaderBlockRootProof {\\n        /// @dev the raw execution block header\\n        bytes header;\\n        /// @dev the proof of the header's validity (if needed)\\n        bytes proof;\\n    }\\n\\n    /// @dev a proof that a particular execution block is valid\\n    struct ExecutionBlockProof {\\n        /// @dev the proof of the beacon block\\n        bytes beaconProof;\\n        /// @dev the proof of the block's slot\\n        bytes32[] slotProof;\\n        /// @dev the proof of the exeuction payload in the beacon block\\n        bytes32[] payloadProof;\\n    }\\n\\n    constructor(\\n        uint256 _CAPELLA_SLOT,\\n        uint256 _DENEB_SLOT\\n    ) {\\n        CAPELLA_SLOT = _CAPELLA_SLOT;\\n        DENEB_SLOT = _DENEB_SLOT;\\n    }\\n\\n    function _castHistoricalBlockSummaryProof(\\n        bytes calldata rawProof\\n    ) internal pure returns (HistoricalBlockSummaryProof calldata proof) {\\n        assembly {\\n            proof := rawProof.offset\\n        }\\n    }\\n\\n    function _castOracleBlockRootProof(\\n        bytes calldata rawProof\\n    ) internal pure returns (OracleBlockRootProof calldata proof) {\\n        assembly {\\n            proof := rawProof.offset\\n        }\\n    }\\n\\n    function _castSummaryBlockRootProof(\\n        bytes calldata rawProof\\n    ) internal pure returns (SummaryBlockRootProof calldata proof) {\\n        assembly {\\n            proof := rawProof.offset\\n        }\\n    }\\n\\n    function _castRelativeBlockRootProof(\\n        bytes calldata rawProof\\n    ) internal pure returns (RelativeBlockRootProof calldata proof) {\\n        assembly {\\n            proof := rawProof.offset\\n        }\\n    }\\n\\n    function _castHeaderBlockRootProof(\\n        bytes calldata rawProof\\n    ) internal pure returns (HeaderBlockRootProof calldata proof) {\\n        assembly {\\n            proof := rawProof.offset\\n        }\\n    }\\n\\n    function _castExecutionBlockProof(\\n        bytes calldata rawProof\\n    ) internal pure returns (ExecutionBlockProof calldata proof) {\\n        assembly {\\n            proof := rawProof.offset\\n        }\\n    }\\n\\n    /**\\n     * @notice verifies and caches a `HistoricalSummary` root at some beacon block\\n     * @param proof the proof required to access the root\\n     * @dev requires the slot to be aligned to SLOTS_PER_HISTORICAL_ROOT\\n     */\\n    function cacheBlockSummary(bytes calldata proof) external {\\n        (uint256 slot, bytes32 blockSummary) = _verifyBlockSummary(proof);\\n        blockSummaries[slot] = blockSummary;\\n        emit ImportBlockSummary(slot, blockSummary);\\n    }\\n\\n    /**\\n     * @notice returns a cached block summary\\n     * @param slot the slot for the summary\\n     */\\n    function _getBlockSummary(uint256 slot) internal view returns (bytes32 result) {\\n        result = blockSummaries[slot];\\n    }\\n\\n    /**\\n     * @dev either accesses a cached historical block summary or verifies a proof of one\\n     * @dev If verifying a proof, it first verifies that a beacon block root is valid, and then\\n     *      verifies the SSZ proof of `BeaconState.historical_summaries[idx].block_summary_root`.\\n     * @return slot the slot number of this historical summary\\n     * @return blockSummary the block summary root\\n     */\\n    function _verifyBlockSummary(\\n        bytes calldata rawProof\\n    ) internal view returns (uint256 slot, bytes32 blockSummary) {\\n        // check if the proof references a cached summary\\n        if (rawProof.length == 32) {\\n            // load the cached summary\\n            slot = uint256(bytes32(rawProof));\\n            blockSummary = blockSummaries[slot];\\n            require(blockSummary != bytes32(0), \\\"block summary not cached\\\");\\n        } else {\\n            HistoricalBlockSummaryProof calldata proof = _castHistoricalBlockSummaryProof(rawProof);\\n\\n            // first verify a beacon block root\\n            bytes32 blockRoot = _verifyBeaconBlockRoot(proof.beaconBlockProof);\\n            uint256 baseSlot = SSZ.verifyBlockSlot(proof.slotProof, blockRoot);\\n\\n            // now access the block's state root\\n            bytes32 stateRoot = SSZ.verifyBlockStateRoot(proof.stateRootProof, blockRoot);\\n\\n            // finally, extract the block summary field from the target state\\n            blockSummary = SSZ.verifyHistoricalBlockSummary(\\n                proof.blockSummaryProof,\\n                proof.blockSummaryIndex,\\n                stateRoot\\n            );\\n\\n            // compute the slot for this summary - note that summaries started at Capella\\n            slot = CAPELLA_SLOT + SLOTS_PER_HISTORICAL_ROOT * (proof.blockSummaryIndex + 1);\\n\\n            // ensure the base slot actually contains this summary\\n            require(baseSlot >= slot, \\\"index out of bounds\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev uses a beacon block summary proof to verify a block root\\n     */\\n    function _verifySummaryBlockRoot(\\n        bytes calldata rawProof\\n    ) internal view returns (bytes32 blockRoot) {\\n        SummaryBlockRootProof calldata proof = _castSummaryBlockRootProof(rawProof);\\n        // otherwise use a block summary to access the block root\\n        (uint256 baseSlot, bytes32 blockSummary) = _verifyBlockSummary(proof.summaryProof);\\n        assert(baseSlot % SLOTS_PER_HISTORICAL_ROOT == 0);\\n\\n        uint256 index = proof.index;\\n        require(index < SLOTS_PER_HISTORICAL_ROOT, \\\"invalid index\\\");\\n        blockRoot = SSZ.verifySummaryIndex(\\n            proof.indexProof,\\n            index,\\n            blockSummary\\n        );\\n    }\\n\\n    /**\\n     * @dev uses the `block_roots` vector of another accessible block root\\n     */\\n    function _verifyRelativeBlockRoot(\\n        bytes calldata rawProof\\n    ) internal view returns (bytes32 blockRoot) {\\n        RelativeBlockRootProof calldata proof = _castRelativeBlockRootProof(rawProof);\\n\\n        // first verify the base block root\\n        blockRoot = _verifyBeaconBlockRoot(proof.baseProof);\\n\\n        // now access the base block's state root\\n        bytes32 stateRoot = SSZ.verifyBlockStateRoot(proof.stateRootProof, blockRoot);\\n\\n        uint256 index = proof.index;\\n        require(index < SLOTS_PER_HISTORICAL_ROOT, \\\"block_roots index out of bounds\\\");\\n\\n        // verify the target block root relative to the base block root\\n        blockRoot = SSZ.verifyRelativeBlockRoot(\\n            proof.relativeRootProof,\\n            index,\\n            stateRoot\\n        );\\n        require(blockRoot != bytes32(0), \\\"invalid blockRoot proven\\\");\\n    }\\n\\n    /**\\n     * @dev uses the `parent_beacon_block_root` field of a verifiable execution header\\n     *      to verify a beacon block root\\n     */\\n    function _verifyHeaderBlockRoot(\\n        bytes calldata rawProof\\n    ) internal view returns (bytes32 blockRoot) {\\n        HeaderBlockRootProof calldata proof = _castHeaderBlockRootProof(rawProof);\\n\\n        // hash and parse the provided header\\n        bytes32 blockHash = keccak256(proof.header);\\n        CoreTypes.BlockHeaderData memory header = CoreTypes.parseBlockHeader(proof.header);\\n\\n        require(\\n            _validBlockHash(blockHash, header.Number, proof.proof),\\n            \\\"block hash not valid\\\"\\n        );\\n\\n        blockRoot = header.ParentBeaconBlockRoot;\\n        require(blockRoot != bytes32(0), \\\"header does not contain parent_beacon_block_root\\\");\\n    }\\n\\n\\n    /**\\n     * @dev verifies an execution layer block hash using SSZ merkle proofs.\\n     */\\n    function _verifyELBlockData(\\n        bytes calldata rawProof\\n    ) internal view returns (bytes32 blockHash, uint256 blockNum) {\\n        ExecutionBlockProof calldata proof = _castExecutionBlockProof(rawProof);\\n\\n        // verify the beacon block root is valid\\n        bytes32 blockRoot = _verifyBeaconBlockRoot(proof.beaconProof);\\n\\n        // verify the block slot number to determine which hardfork it's from\\n        uint256 slot = SSZ.verifyBlockSlot(proof.slotProof, blockRoot);\\n        require(slot >= CAPELLA_SLOT, \\\"slot is before capella fork\\\");\\n        bool isCapella = slot < DENEB_SLOT;\\n\\n        // verify the execution header data within it\\n        (blockHash, blockNum) = SSZ.verifyExecutionPayloadFields(\\n            proof.payloadProof,\\n            blockRoot,\\n            isCapella\\n        );\\n    }\\n\\n    /**\\n     * @dev verifies an execution layer block hash using SSZ merkle proofs.\\n     *      Returns true if the data is valid. May either revert or return\\n     *      false if the proof is invalid.\\n     */\\n    function _validBlockHashWithBeacon(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata rawProof\\n    ) internal view returns (bool) {\\n        (bytes32 blockHash, uint256 blockNum) = _verifyELBlockData(rawProof);\\n        // return whether it matches the query\\n        return hash == blockHash && num == blockNum;\\n    }\\n\\n    /**\\n     * @notice Parses a beacon proof type and proof from the encoded proof\\n     *\\n     * @param encodedProof the encoded proof\\n     * @return typ the proof type\\n     * @return proof the remaining encoded proof\\n     */\\n    function parseBeaconProofType(bytes calldata encodedProof)\\n        internal\\n        pure\\n        returns (BeaconProofType typ, bytes calldata proof)\\n    {\\n        require(encodedProof.length > 0, \\\"cannot parse beacon proof type\\\");\\n        typ = BeaconProofType(uint8(encodedProof[0]));\\n        proof = encodedProof[1:];\\n    }\\n\\n    function _verifyBeaconBlockRoot(\\n        bytes calldata proof\\n    ) internal virtual view returns (bytes32 blockRoot);\\n\\n    /**\\n     * @notice Checks if an execution block hash is valid.\\n     *\\n     * @param hash the hash to check\\n     * @param num the block number for the alleged hash\\n     * @param proof the merkle witness or SNARK proof (if needed)\\n     * @return the validity\\n     */\\n    function _validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) internal virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBeaconBlockHistory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IBlockHistory.sol\\\";\\n\\n/**\\n * @title Beacon Block history provider\\n * @author Theori, Inc.\\n * @notice IBeaconBlockHistory provides a way to verify beacon block roots as well as execution block hashes\\n */\\n\\ninterface IBeaconBlockHistory is IBlockHistory {\\n    function UPGRADE_BLOCK() external view returns (uint256 blockNum);\\n\\n    /**\\n     * @notice verifies a beacon block root\\n     * @param proof the proof of the beacon blcok\\n     * @return blockRoot the `BeaconBlock` root\\n     */\\n    function verifyBeaconBlockRoot(\\n        bytes calldata proof\\n    ) external view returns (bytes32 blockRoot);\\n\\n    /**\\n     * @notice gets the cached block summary for the given slot (if it exists)\\n     * @param slot the slot number to query\\n     * @return result the cached block summary (or bytes32(0) if it is not cached)\\n     */\\n    function getBlockSummary(uint256 slot) external view returns (bytes32 result);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBlockHistory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Block history provider\\n * @author Theori, Inc.\\n * @notice IBlockHistory provides a way to verify a blockhash\\n */\\n\\ninterface IBlockHistory {\\n    /**\\n     * @notice Determine if the given hash corresponds to the given block\\n     * @param hash the hash if the block in question\\n     * @param num the number of the block in question\\n     * @param proof any witness data required to prove the block hash is\\n     *        correct (such as a Merkle or SNARK proof)\\n     * @return boolean indicating if the block hash can be verified correct\\n     */\\n    function validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BytesCalldata.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.13;\\n\\n// custom bytes calldata pointer storing (length | offset) in one word,\\n// also allows calldata pointers to be stored in memory\\ntype BytesCalldata is uint256;\\n\\nusing BytesCalldataOps for BytesCalldata global;\\n\\n// can't introduce global using .. for non UDTs\\n// each consumer should add the following line:\\nusing BytesCalldataOps for bytes;\\n\\n/**\\n * @author Theori, Inc\\n * @title BytesCalldataOps\\n * @notice Common operations for bytes calldata, implemented for both the builtin\\n *         type and our BytesCalldata type. These operations are heavily optimized\\n *         and omit safety checks, so this library should only be used when memory\\n *         safety is not a security issue.\\n */\\nlibrary BytesCalldataOps {\\n    function length(BytesCalldata bc) internal pure returns (uint256 result) {\\n        assembly {\\n            result := shr(128, shl(128, bc))\\n        }\\n    }\\n\\n    function offset(BytesCalldata bc) internal pure returns (uint256 result) {\\n        assembly {\\n            result := shr(128, bc)\\n        }\\n    }\\n\\n    function convert(BytesCalldata bc) internal pure returns (bytes calldata value) {\\n        assembly {\\n            value.offset := shr(128, bc)\\n            value.length := shr(128, shl(128, bc))\\n        }\\n    }\\n\\n    function convert(bytes calldata inp) internal pure returns (BytesCalldata bc) {\\n        assembly {\\n            bc := or(shl(128, inp.offset), inp.length)\\n        }\\n    }\\n\\n    function slice(\\n        BytesCalldata bc,\\n        uint256 start,\\n        uint256 len\\n    ) internal pure returns (BytesCalldata result) {\\n        assembly {\\n            result := shl(128, add(shr(128, bc), start)) // add to the offset and clear the length\\n            result := or(result, len) // set the new length\\n        }\\n    }\\n\\n    function slice(\\n        bytes calldata value,\\n        uint256 start,\\n        uint256 len\\n    ) internal pure returns (bytes calldata result) {\\n        assembly {\\n            result.offset := add(value.offset, start)\\n            result.length := len\\n        }\\n    }\\n\\n    function prefix(BytesCalldata bc, uint256 len) internal pure returns (BytesCalldata result) {\\n        assembly {\\n            result := shl(128, shr(128, bc)) // clear out the length\\n            result := or(result, len) // set it to the new length\\n        }\\n    }\\n\\n    function prefix(bytes calldata value, uint256 len)\\n        internal\\n        pure\\n        returns (bytes calldata result)\\n    {\\n        assembly {\\n            result.offset := value.offset\\n            result.length := len\\n        }\\n    }\\n\\n    function suffix(BytesCalldata bc, uint256 start) internal pure returns (BytesCalldata result) {\\n        assembly {\\n            result := add(bc, shl(128, start)) // add to the offset\\n            result := sub(result, start) // subtract from the length\\n        }\\n    }\\n\\n    function suffix(bytes calldata value, uint256 start)\\n        internal\\n        pure\\n        returns (bytes calldata result)\\n    {\\n        assembly {\\n            result.offset := add(value.offset, start)\\n            result.length := sub(value.length, start)\\n        }\\n    }\\n\\n    function split(BytesCalldata bc, uint256 start)\\n        internal\\n        pure\\n        returns (BytesCalldata, BytesCalldata)\\n    {\\n        return (prefix(bc, start), suffix(bc, start));\\n    }\\n\\n    function split(bytes calldata value, uint256 start)\\n        internal\\n        pure\\n        returns (bytes calldata, bytes calldata)\\n    {\\n        return (prefix(value, start), suffix(value, start));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CoreTypes.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./BytesCalldata.sol\\\";\\nimport \\\"./RLP.sol\\\";\\n\\n/**\\n * @title CoreTypes\\n * @author Theori, Inc.\\n * @notice Data types and parsing functions for core types, including block headers\\n *         and account data.\\n */\\nlibrary CoreTypes {\\n    using BytesCalldataOps for bytes;\\n    struct BlockHeaderData {\\n        bytes32 ParentHash;\\n        address Coinbase;\\n        bytes32 Root;\\n        bytes32 TxHash;\\n        bytes32 ReceiptHash;\\n        uint256 Number;\\n        uint256 GasLimit;\\n        uint256 GasUsed;\\n        uint256 Time;\\n        bytes32 MixHash;\\n        uint256 BaseFee;\\n        bytes32 WithdrawalsHash;\\n        uint256 BlobGasUsed;\\n        uint256 ExcessBlobGas;\\n        bytes32 ParentBeaconBlockRoot;\\n    }\\n\\n    struct AccountData {\\n        uint256 Nonce;\\n        uint256 Balance;\\n        bytes32 StorageRoot;\\n        bytes32 CodeHash;\\n    }\\n\\n    struct LogData {\\n        address Address;\\n        bytes32[] Topics;\\n        bytes Data;\\n    }\\n\\n    struct WithdrawalData {\\n        uint256 Index;\\n        uint256 ValidatorIndex;\\n        address Address;\\n        uint256 AmountInGwei;\\n    }\\n\\n    function parseHash(bytes calldata buf) internal pure returns (bytes32 result, uint256 offset) {\\n        uint256 value;\\n        (value, offset) = RLP.parseUint(buf);\\n        result = bytes32(value);\\n    }\\n\\n    function parseAddress(bytes calldata buf)\\n        internal\\n        pure\\n        returns (address result, uint256 offset)\\n    {\\n        uint256 value;\\n        (value, offset) = RLP.parseUint(buf);\\n        result = address(uint160(value));\\n    }\\n\\n    function parseBlockHeader(bytes calldata header)\\n        internal\\n        pure\\n        returns (BlockHeaderData memory data)\\n    {\\n        (uint256 listSize, uint256 offset) = RLP.parseList(header);\\n        header = header.slice(offset, listSize);\\n\\n        (data.ParentHash, offset) = parseHash(header); // ParentHash\\n        header = header.suffix(offset);\\n        header = RLP.skip(header); // UncleHash\\n        (data.Coinbase, offset) = parseAddress(header); // Coinbase\\n        header = header.suffix(offset);\\n        (data.Root, offset) = parseHash(header); // Root\\n        header = header.suffix(offset);\\n        (data.TxHash, offset) = parseHash(header); // TxHash\\n        header = header.suffix(offset);\\n        (data.ReceiptHash, offset) = parseHash(header); // ReceiptHash\\n        header = header.suffix(offset);\\n        header = RLP.skip(header); // Bloom\\n        header = RLP.skip(header); // Difficulty\\n        (data.Number, offset) = RLP.parseUint(header); // Number\\n        header = header.suffix(offset);\\n        (data.GasLimit, offset) = RLP.parseUint(header); // GasLimit\\n        header = header.suffix(offset);\\n        (data.GasUsed, offset) = RLP.parseUint(header); // GasUsed\\n        header = header.suffix(offset);\\n        (data.Time, offset) = RLP.parseUint(header); // Time\\n        header = header.suffix(offset);\\n        header = RLP.skip(header); // Extra\\n        (data.MixHash, offset) = parseHash(header); // MixHash\\n        header = header.suffix(offset);\\n        header = RLP.skip(header); // Nonce\\n\\n        if (header.length > 0) {\\n            (data.BaseFee, offset) = RLP.parseUint(header); // BaseFee\\n            header = header.suffix(offset);\\n        }\\n\\n        if (header.length > 0) {\\n            (data.WithdrawalsHash, offset) = parseHash(header); // WithdrawalsHash\\n            header = header.suffix(offset);\\n        }\\n\\n        if (header.length > 0) {\\n            (data.BlobGasUsed, offset) = RLP.parseUint(header); // BlobGasUsed\\n            header = header.suffix(offset);\\n        }\\n\\n        if (header.length > 0) {\\n            (data.ExcessBlobGas, offset) = RLP.parseUint(header); // ExcessBlobGas\\n            header = header.suffix(offset);\\n        }\\n\\n        if (header.length > 0) {\\n            (data.ParentBeaconBlockRoot, offset) = parseHash(header); // ParentBeaconBlockRoot\\n            header = header.suffix(offset);\\n        }\\n    }\\n\\n    function getBlockHeaderHashAndSize(bytes calldata header)\\n        internal\\n        pure\\n        returns (bytes32 blockHash, uint256 headerSize)\\n    {\\n        (uint256 listSize, uint256 offset) = RLP.parseList(header);\\n        unchecked {\\n            headerSize = offset + listSize;\\n        }\\n        blockHash = keccak256(header.prefix(headerSize));\\n    }\\n\\n    function parseAccount(bytes calldata account) internal pure returns (AccountData memory data) {\\n        (, uint256 offset) = RLP.parseList(account);\\n        account = account.suffix(offset);\\n\\n        (data.Nonce, offset) = RLP.parseUint(account); // Nonce\\n        account = account.suffix(offset);\\n        (data.Balance, offset) = RLP.parseUint(account); // Balance\\n        account = account.suffix(offset);\\n        (data.StorageRoot, offset) = parseHash(account); // StorageRoot\\n        account = account.suffix(offset);\\n        (data.CodeHash, offset) = parseHash(account); // CodeHash\\n        account = account.suffix(offset);\\n    }\\n\\n    function parseLog(bytes calldata log) internal pure returns (LogData memory data) {\\n        (, uint256 offset) = RLP.parseList(log);\\n        log = log.suffix(offset);\\n\\n        uint256 tmp;\\n        (tmp, offset) = RLP.parseUint(log); // Address\\n        data.Address = address(uint160(tmp));\\n        log = log.suffix(offset);\\n\\n        (tmp, offset) = RLP.parseList(log); // Topics\\n        bytes calldata topics = log.slice(offset, tmp);\\n        log = log.suffix(offset + tmp);\\n\\n        require(topics.length % 33 == 0);\\n        data.Topics = new bytes32[](tmp / 33);\\n        uint256 i = 0;\\n        while (topics.length > 0) {\\n            (data.Topics[i], offset) = parseHash(topics);\\n            topics = topics.suffix(offset);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        (data.Data, ) = RLP.splitBytes(log);\\n    }\\n\\n    function extractLog(bytes calldata receiptValue, uint256 logIdx)\\n        internal\\n        pure\\n        returns (LogData memory)\\n    {\\n        // support EIP-2718: Currently all transaction types have the same\\n        // receipt RLP format, so we can just skip the receipt type byte\\n        if (receiptValue[0] < 0x80) {\\n            receiptValue = receiptValue.suffix(1);\\n        }\\n\\n        (, uint256 offset) = RLP.parseList(receiptValue);\\n        receiptValue = receiptValue.suffix(offset);\\n\\n        // pre EIP-658, receipts stored an intermediate state root in this field\\n        // post EIP-658, the field is a tx status (0 for failure, 1 for success)\\n        uint256 statusOrIntermediateRoot;\\n        (statusOrIntermediateRoot, offset) = RLP.parseUint(receiptValue);\\n        require(statusOrIntermediateRoot != 0, \\\"tx did not succeed\\\");\\n        receiptValue = receiptValue.suffix(offset);\\n\\n        receiptValue = RLP.skip(receiptValue); // GasUsed\\n        receiptValue = RLP.skip(receiptValue); // LogsBloom\\n\\n        uint256 length;\\n        (length, offset) = RLP.parseList(receiptValue); // Logs\\n        receiptValue = receiptValue.slice(offset, length);\\n\\n        // skip the earlier logs\\n        for (uint256 i = 0; i < logIdx; i++) {\\n            require(receiptValue.length > 0, \\\"log index does not exist\\\");\\n            receiptValue = RLP.skip(receiptValue);\\n        }\\n\\n        return parseLog(receiptValue);\\n    }\\n\\n    function parseWithdrawal(bytes calldata withdrawal)\\n        internal\\n        pure\\n        returns (WithdrawalData memory data)\\n    {\\n        (, uint256 offset) = RLP.parseList(withdrawal);\\n        withdrawal = withdrawal.suffix(offset);\\n\\n        (data.Index, offset) = RLP.parseUint(withdrawal); // Index\\n        withdrawal = withdrawal.suffix(offset);\\n        (data.ValidatorIndex, offset) = RLP.parseUint(withdrawal); // ValidatorIndex\\n        withdrawal = withdrawal.suffix(offset);\\n        (data.Address, offset) = parseAddress(withdrawal); // Address\\n        withdrawal = withdrawal.suffix(offset);\\n        (data.AmountInGwei, offset) = RLP.parseUint(withdrawal); // Amount\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MerkleTree.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Merkle Tree\\n * @author Theori, Inc.\\n * @notice Gas optimized SHA256 Merkle tree code.\\n */\\nlibrary MerkleTree {\\n    /**\\n     * @notice performs one merkle combination of two node hashes\\n     */\\n    function combine(bytes32 left, bytes32 right) internal view returns (bytes32 result) {\\n        assembly {\\n            mstore(0, left)\\n            mstore(0x20, right)\\n            // compute sha256\\n            if iszero(staticcall(gas(), 0x2, 0x0, 0x40, 0x0, 0x20)) {\\n                revert(0, 0)\\n            }\\n            result := mload(0)\\n        }\\n    }\\n\\n    /**\\n     * @notice computes a SHA256 merkle root of the provided hashes, in place\\n     * @param temp the mutable array of hashes\\n     * @return the merkle root hash\\n     */\\n    function computeRoot(bytes32[] memory temp) internal view returns (bytes32) {\\n        uint256 count = temp.length;\\n        assembly {\\n            // repeat until we arrive at one root hash\\n            for {\\n\\n            } gt(count, 1) {\\n\\n            } {\\n                let dataElementLocation := add(temp, 0x20)\\n                let hashElementLocation := add(temp, 0x20)\\n                for {\\n                    let i := 0\\n                } lt(i, count) {\\n                    i := add(i, 2)\\n                } {\\n                    if iszero(\\n                        staticcall(gas(), 0x2, hashElementLocation, 0x40, dataElementLocation, 0x20)\\n                    ) {\\n                        revert(0, 0)\\n                    }\\n                    dataElementLocation := add(dataElementLocation, 0x20)\\n                    hashElementLocation := add(hashElementLocation, 0x40)\\n                }\\n                count := shr(1, count)\\n            }\\n        }\\n        return temp[0];\\n    }\\n\\n    /**\\n     * @notice compute the root of the merkle tree according to the proof\\n     * @param index the index of the node to check\\n     * @param leaf the leaf to check\\n     * @param proofHashes the proof, i.e. the sequence of siblings from the\\n     *        node to root\\n     */\\n    function proofRoot(\\n        uint256 index,\\n        bytes32 leaf,\\n        bytes32[] calldata proofHashes\\n    ) internal view returns (bytes32 result) {\\n        assembly {\\n            result := leaf\\n            let start := proofHashes.offset\\n            let end := add(start, mul(proofHashes.length, 0x20))\\n            for {\\n                let ptr := start\\n            } lt(ptr, end) {\\n                ptr := add(ptr, 0x20)\\n            } {\\n                let proofHash := calldataload(ptr)\\n\\n                // use scratch space (0x0 - 0x40) for hash input\\n                switch and(index, 1)\\n                case 0 {\\n                    mstore(0x0, result)\\n                    mstore(0x20, proofHash)\\n                }\\n                case 1 {\\n                    mstore(0x0, proofHash)\\n                    mstore(0x20, result)\\n                }\\n\\n                // compute sha256\\n                if iszero(staticcall(gas(), 0x2, 0x0, 0x40, 0x0, 0x20)) {\\n                    revert(0, 0)\\n                }\\n                result := mload(0x0)\\n\\n                index := shr(1, index)\\n            }\\n        }\\n        require(index == 0, \\\"invalid index for proof\\\");\\n    }\\n\\n    /**\\n     * @notice compute the root of the merkle tree containing the given leaf\\n     *         at index 0 and default values for all other leaves\\n     * @param depth the depth of the tree\\n     * @param leaf the non-default leaf\\n     * @param defaultLeaf the default leaf for all other positions\\n     */\\n    function rootWithDefault(\\n        uint256 depth,\\n        bytes32 leaf,\\n        bytes32 defaultLeaf\\n    ) internal view returns (bytes32 result) {\\n        assembly {\\n            result := leaf\\n            // the default value will live at 0x20 and be updated each iteration\\n            mstore(0x20, defaultLeaf)\\n            for { } depth { depth := sub(depth, 1) } {\\n                // compute sha256 of result || default\\n                mstore(0x0, result)\\n                if iszero(staticcall(gas(), 0x2, 0x0, 0x40, 0x0, 0x20)) {\\n                    revert(0, 0)\\n                }\\n                result := mload(0x0)\\n                if iszero(depth) {\\n                    break\\n                }\\n\\n                // compute sha256 of default || default\\n                mstore(0x0, mload(0x20))\\n                if iszero(staticcall(gas(), 0x2, 0x0, 0x40, 0x20, 0x20)) {\\n                    revert(0, 0)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice check if a hash is in the merkle tree for rootHash\\n     * @param rootHash the merkle root\\n     * @param index the index of the node to check\\n     * @param hash the hash to check\\n     * @param proofHashes the proof, i.e. the sequence of siblings from the\\n     *        node to root\\n     */\\n    function validProof(\\n        bytes32 rootHash,\\n        uint256 index,\\n        bytes32 hash,\\n        bytes32[] calldata proofHashes\\n    ) internal view returns (bool result) {\\n        return rootHash == proofRoot(index, hash, proofHashes);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Proofs.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\n/*\\n * @author Theori, Inc.\\n */\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nuint256 constant BASE_PROOF_SIZE = 34;\\nuint256 constant SUBPROOF_LIMBS_SIZE = 16;\\n\\nstruct RecursiveProof {\\n    uint256[BASE_PROOF_SIZE] base;\\n    uint256[SUBPROOF_LIMBS_SIZE] subproofLimbs;\\n    uint256[] inputs;\\n}\\n\\nstruct SignedRecursiveProof {\\n    RecursiveProof inner;\\n    bytes signature;\\n}\\n\\n/**\\n * @notice recover the signer of the proof\\n * @param proof the SignedRecursiveProof\\n * @return the address of the signer\\n */\\nfunction getProofSigner(SignedRecursiveProof calldata proof) pure returns (address) {\\n    bytes32 msgHash = keccak256(\\n        abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", \\\"32\\\", hashProof(proof.inner))\\n    );\\n    return ECDSA.recover(msgHash, proof.signature);\\n}\\n\\n/**\\n * @notice hash the contents of a RecursiveProof\\n * @param proof the RecursiveProof\\n * @return result a 32-byte digest of the proof\\n */\\nfunction hashProof(RecursiveProof calldata proof) pure returns (bytes32 result) {\\n    uint256[] calldata inputs = proof.inputs;\\n    assembly {\\n        let ptr := mload(0x40)\\n        let contigLen := mul(0x20, add(BASE_PROOF_SIZE, SUBPROOF_LIMBS_SIZE))\\n        let inputsLen := mul(0x20, inputs.length)\\n        calldatacopy(ptr, proof, contigLen)\\n        calldatacopy(add(ptr, contigLen), inputs.offset, inputsLen)\\n        result := keccak256(ptr, add(contigLen, inputsLen))\\n    }\\n}\\n\\n/**\\n * @notice reverse the byte order of a uint256\\n * @param input the input value\\n * @return v the byte-order reversed value\\n */\\nfunction byteReverse(uint256 input) pure returns (uint256 v) {\\n    v = input;\\n\\n    uint256 MASK08 = 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\\n    uint256 MASK16 = 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000;\\n    uint256 MASK32 = 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000;\\n    uint256 MASK64 = 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000;\\n\\n    // swap bytes\\n    v = ((v & MASK08) >> 8) | ((v & (~MASK08)) << 8);\\n\\n    // swap 2-byte long pairs\\n    v = ((v & MASK16) >> 16) | ((v & (~MASK16)) << 16);\\n\\n    // swap 4-byte long pairs\\n    v = ((v & MASK32) >> 32) | ((v & (~MASK32)) << 32);\\n\\n    // swap 8-byte long pairs\\n    v = ((v & MASK64) >> 64) | ((v & (~MASK64)) << 64);\\n\\n    // swap 16-byte long pairs\\n    v = (v >> 128) | (v << 128);\\n}\\n\\n/**\\n * @notice reads a 32-byte hash from its little-endian word-encoded form\\n * @param words the hash words\\n * @return the hash\\n */\\nfunction readHashWords(uint256[] calldata words) pure returns (bytes32) {\\n    uint256 mask = 0xffffffffffffffff;\\n    uint256 result = (words[0] & mask);\\n    result |= (words[1] & mask) << 0x40;\\n    result |= (words[2] & mask) << 0x80;\\n    result |= (words[3] & mask) << 0xc0;\\n    return bytes32(byteReverse(result));\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Propogate.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nlibrary Propogate {\\n    /**\\n    * @notice propogates the current calldata to the destination\\n    *         via a staticcall() and returns or reverts accordingly\\n    * @dev this is much cheaper than manually building the calldata again\\n    */\\n    function staticcall(address destination) internal view {\\n        assembly {\\n            // we are not returning to solidity, so we can take ownership of all memory\\n            calldatacopy(0, 0, calldatasize())\\n            let success := staticcall(gas(), destination, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            // Depending on the success, either revert or return\\n            switch success\\n            case 0 {\\n                // End execution and revert state changes\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                // Return data with length of size at pointers position\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RLP.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title RLP\\n * @author Theori, Inc.\\n * @notice Gas optimized RLP parsing code. Note that some parsing logic is\\n *         duplicated because helper functions are oddly expensive.\\n */\\nlibrary RLP {\\n    function parseUint(bytes calldata buf) internal pure returns (uint256 result, uint256 size) {\\n        assembly {\\n            // check that we have at least one byte of input\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            // ensure it's a not a long string or list (> 0xB7)\\n            // also ensure it's not a short string longer than 32 bytes (> 0xA0)\\n            if gt(kind, 0xA0) {\\n                revert(0, 0)\\n            }\\n\\n            switch lt(kind, 0x80)\\n            case true {\\n                // small single byte\\n                result := kind\\n                size := 1\\n            }\\n            case false {\\n                // short string\\n                size := sub(kind, 0x80)\\n\\n                // ensure it's not reading out of bounds\\n                if lt(buf.length, size) {\\n                    revert(0, 0)\\n                }\\n\\n                switch eq(size, 32)\\n                case true {\\n                    // if it's exactly 32 bytes, read it from calldata\\n                    result := calldataload(add(buf.offset, 1))\\n                }\\n                case false {\\n                    // if it's < 32 bytes, we've already read it from calldata\\n                    result := shr(shl(3, sub(32, size)), shl(8, first32))\\n                }\\n                size := add(size, 1)\\n            }\\n        }\\n    }\\n\\n    function nextSize(bytes calldata buf) internal pure returns (uint256 size) {\\n        assembly {\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            switch lt(kind, 0x80)\\n            case true {\\n                // small single byte\\n                size := 1\\n            }\\n            case false {\\n                switch lt(kind, 0xB8)\\n                case true {\\n                    // short string\\n                    size := add(1, sub(kind, 0x80))\\n                }\\n                case false {\\n                    switch lt(kind, 0xC0)\\n                    case true {\\n                        // long string\\n                        let lengthSize := sub(kind, 0xB7)\\n\\n                        // ensure that we don't overflow\\n                        if gt(lengthSize, 31) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // ensure that we don't read out of bounds\\n                        if lt(buf.length, lengthSize) {\\n                            revert(0, 0)\\n                        }\\n                        size := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                        size := add(size, add(1, lengthSize))\\n                    }\\n                    case false {\\n                        switch lt(kind, 0xF8)\\n                        case true {\\n                            // short list\\n                            size := add(1, sub(kind, 0xC0))\\n                        }\\n                        case false {\\n                            let lengthSize := sub(kind, 0xF7)\\n\\n                            // ensure that we don't overflow\\n                            if gt(lengthSize, 31) {\\n                                revert(0, 0)\\n                            }\\n                            // ensure that we don't read out of bounds\\n                            if lt(buf.length, lengthSize) {\\n                                revert(0, 0)\\n                            }\\n                            size := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                            size := add(size, add(1, lengthSize))\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function skip(bytes calldata buf) internal pure returns (bytes calldata) {\\n        uint256 size = RLP.nextSize(buf);\\n        assembly {\\n            buf.offset := add(buf.offset, size)\\n            buf.length := sub(buf.length, size)\\n        }\\n        return buf;\\n    }\\n\\n    function parseList(bytes calldata buf)\\n        internal\\n        pure\\n        returns (uint256 listSize, uint256 offset)\\n    {\\n        assembly {\\n            // check that we have at least one byte of input\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            // ensure it's a list\\n            if lt(kind, 0xC0) {\\n                revert(0, 0)\\n            }\\n\\n            switch lt(kind, 0xF8)\\n            case true {\\n                // short list\\n                listSize := sub(kind, 0xC0)\\n                offset := 1\\n            }\\n            case false {\\n                // long list\\n                let lengthSize := sub(kind, 0xF7)\\n\\n                // ensure that we don't overflow\\n                if gt(lengthSize, 31) {\\n                    revert(0, 0)\\n                }\\n                // ensure that we don't read out of bounds\\n                if lt(buf.length, lengthSize) {\\n                    revert(0, 0)\\n                }\\n                listSize := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                offset := add(lengthSize, 1)\\n            }\\n        }\\n    }\\n\\n    function splitBytes(bytes calldata buf)\\n        internal\\n        pure\\n        returns (bytes calldata result, bytes calldata rest)\\n    {\\n        uint256 offset;\\n        uint256 size;\\n        assembly {\\n            // check that we have at least one byte of input\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            // ensure it's a not list\\n            if gt(kind, 0xBF) {\\n                revert(0, 0)\\n            }\\n\\n            switch lt(kind, 0x80)\\n            case true {\\n                // small single byte\\n                offset := 0\\n                size := 1\\n            }\\n            case false {\\n                switch lt(kind, 0xB8)\\n                case true {\\n                    // short string\\n                    offset := 1\\n                    size := sub(kind, 0x80)\\n                }\\n                case false {\\n                    // long string\\n                    let lengthSize := sub(kind, 0xB7)\\n\\n                    // ensure that we don't overflow\\n                    if gt(lengthSize, 31) {\\n                        revert(0, 0)\\n                    }\\n                    // ensure we don't read out of bounds\\n                    if lt(buf.length, lengthSize) {\\n                        revert(0, 0)\\n                    }\\n                    size := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                    offset := add(lengthSize, 1)\\n                }\\n            }\\n\\n            result.offset := add(buf.offset, offset)\\n            result.length := size\\n\\n            let end := add(offset, size)\\n            rest.offset := add(buf.offset, end)\\n            rest.length := sub(buf.length, end)\\n        }\\n    }\\n\\n    function encodeUint(uint256 value) internal pure returns (bytes memory) {\\n        // allocate our result bytes\\n        bytes memory result = new bytes(33);\\n\\n        if (value == 0) {\\n            // store length = 1, value = 0x80\\n            assembly {\\n                mstore(add(result, 1), 0x180)\\n            }\\n            return result;\\n        }\\n\\n        if (value < 128) {\\n            // store length = 1, value = value\\n            assembly {\\n                mstore(add(result, 1), or(0x100, value))\\n            }\\n            return result;\\n        }\\n\\n        if (value > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n            // length 33, prefix 0xa0 followed by value\\n            assembly {\\n                mstore(add(result, 1), 0x21a0)\\n                mstore(add(result, 33), value)\\n            }\\n            return result;\\n        }\\n\\n        if (value > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n            // length 32, prefix 0x9f followed by value\\n            assembly {\\n                mstore(add(result, 1), 0x209f)\\n                mstore(add(result, 33), shl(8, value))\\n            }\\n            return result;\\n        }\\n\\n        assembly {\\n            let length := 1\\n            for {\\n                let min := 0x100\\n            } lt(sub(min, 1), value) {\\n                min := shl(8, min)\\n            } {\\n                length := add(length, 1)\\n            }\\n\\n            let bytesLength := add(length, 1)\\n\\n            // bytes length field\\n            let hi := shl(mul(bytesLength, 8), bytesLength)\\n\\n            // rlp encoding of value\\n            let lo := or(shl(mul(length, 8), add(length, 0x80)), value)\\n\\n            mstore(add(result, bytesLength), or(hi, lo))\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SSZ.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./MerkleTree.sol\\\";\\n\\nimport {byteReverse} from \\\"./Proofs.sol\\\";\\n\\n/**\\n * @title  SSZ\\n * @author Theori, Inc.\\n * @notice Selected SSZ merkle verification code for Beacon chain data structures\\n *\\n * @dev    The indices hardcoded in this contract are primarily for the Dencun hardfork.\\n *         One exception is verifying execution payload fields, where Capella is also\\n *         supported. Also, this contract uses raw merkle indices rather than the\\n *         \\\"generalized indices\\\" specified in SSZ.\\n *\\n */\\nlibrary SSZ {\\n    // the total proof length for a historical block summaries proof\\n    uint256 constant HISTORICAL_SUMMARIES_TREE_DEPTH = 24;\\n\\n    // the total proof length for a historical block summaries proof\\n    uint256 constant HISTORICAL_BLOCK_SUMMARIES_PROOF_LENGTH = 32;\\n\\n    // index of the block_roots merkle root relative to a block root\\n    uint256 constant STATE_ROOT_INDEX = 3;\\n\\n    // index of the block_roots field relative to a state root\\n    uint256 constant BLOCK_ROOTS_INDEX = 5;\\n\\n    // index of the historical_summaries field relative to a state root\\n    uint256 constant HISTORICAL_SUMMARIES_INDEX = 27;\\n\\n    // index of the slot value relative to a block root\\n    uint256 constant SLOT_INDEX = 0;\\n\\n    // index of the execution payload relative to a block root\\n    uint256 constant EXECUTION_PAYLOAD_INDEX = 73;\\n\\n    // index of the block number in the left subtree of the execution payload\\n    uint256 constant BLOCK_NUMBER_LEFT_SUBTREE_INDEX = 6;\\n\\n    // index of the block hash in the right subtree of the execution payload\\n    uint256 constant BLOCK_HASH_RIGHT_SUBTREE_INDEX = 4;\\n\\n    /**\\n     * @notice verify an SSZ merkle proof for `BeaconBlock.body.execution_payload.block_{number,hash}`\\n     */\\n    function verifyExecutionPayloadFields(\\n        bytes32[] calldata proof,\\n        bytes32 blockRoot,\\n        bool isCapella\\n    ) internal view returns (bytes32 blockHash, uint256 blockNumber) {\\n        if (isCapella) {\\n            require(proof.length == 15, \\\"invalid proof length\\\");\\n        } else {\\n            require(proof.length == 16, \\\"invalid proof length\\\");\\n        }\\n        blockHash = proof[0];\\n        bytes32 blockNumberAsHash = proof[1];\\n        bytes32 rightSubtreeRoot = MerkleTree.proofRoot(\\n            BLOCK_HASH_RIGHT_SUBTREE_INDEX,\\n            blockHash,\\n            proof[2:5]\\n        );\\n        bytes32 leftSubtreeRoot = MerkleTree.proofRoot(\\n            BLOCK_NUMBER_LEFT_SUBTREE_INDEX,\\n            blockNumberAsHash,\\n            proof[5:8]\\n        );\\n        bytes32 executionPayloadSubtreeRoot = MerkleTree.combine(leftSubtreeRoot, rightSubtreeRoot);\\n        // if in capella, we're already at the execution payload root\\n        // otherwise, we need one extra proof node\\n        bytes32 computedRoot = MerkleTree.proofRoot(\\n            isCapella ? EXECUTION_PAYLOAD_INDEX : EXECUTION_PAYLOAD_INDEX << 1,\\n            executionPayloadSubtreeRoot,\\n            proof[8:]\\n        );\\n        require(computedRoot == blockRoot, \\\"invalid execution proof\\\");\\n\\n        blockNumber = byteReverse(uint256(blockNumberAsHash));\\n    }\\n\\n    /**\\n     * @notice verify an SSZ merkle proof for `BeaconBlock.state_root`\\n     */\\n    function verifyBlockStateRoot(\\n        bytes32[] calldata proof,\\n        bytes32 blockRoot\\n    ) internal view returns (bytes32 stateRoot) {\\n        require(proof.length == 4, \\\"invalid proof length\\\");\\n        stateRoot = proof[0];\\n        bytes32 computedRoot = MerkleTree.proofRoot(STATE_ROOT_INDEX, stateRoot, proof[1:]);\\n        require(computedRoot == blockRoot, \\\"invalid stateRoot proof\\\");\\n    }\\n\\n    /**\\n     * @notice verify an SSZ merkle proof for `BeaconBlock.slot`\\n     */\\n    function verifyBlockSlot(\\n        bytes32[] calldata proof,\\n        bytes32 blockRoot\\n    ) internal view returns (uint256 slot) {\\n        require(proof.length == 4, \\\"invalid proof length\\\");\\n        bytes32 slotAsHash = proof[0];\\n        bytes32 computedRoot = MerkleTree.proofRoot(SLOT_INDEX, slotAsHash, proof[1:]);\\n        require(computedRoot == blockRoot, \\\"invalid slot proof\\\");\\n        slot = byteReverse(uint256(slotAsHash));\\n        require(slot <= type(uint64).max, \\\"invalid slot value\\\");\\n    }\\n\\n    /**\\n     * @notice verifies `state.historical_summaries[index].block_summary_root`\\n     */\\n    function verifyHistoricalBlockSummary(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        bytes32 stateRoot\\n    ) internal view returns (bytes32 historicalBlockSummary) {\\n        // proof length is an upper bound in this case, see below\\n        require(proof.length <= HISTORICAL_BLOCK_SUMMARIES_PROOF_LENGTH, \\\"proof too long\\\");\\n\\n        historicalBlockSummary = proof[0];\\n        bytes32 historicalSummary = MerkleTree.combine(historicalBlockSummary, proof[1]);\\n        bytes32[] calldata topProof = proof[2:8];\\n\\n        bytes32 intermediate = MerkleTree.proofRoot(\\n            index,\\n            historicalSummary,\\n            proof[8:]\\n        );\\n\\n        // any missing proof nodes are implicit \\\"default\\\" values on the right side of the tree\\n        uint256 numImplicitNodes = HISTORICAL_BLOCK_SUMMARIES_PROOF_LENGTH - proof.length;\\n\\n        // compute the defaultValue for our current depth\\n        bytes32 defaultValue = bytes32(0);\\n        for (uint256 i = 0; i < HISTORICAL_SUMMARIES_TREE_DEPTH - numImplicitNodes; i++) {\\n            defaultValue = MerkleTree.combine(defaultValue, defaultValue);\\n        }\\n\\n        // compute the historical_summaries data root assuming default value\\n        bytes32 listDataRoot = MerkleTree.rootWithDefault(\\n            numImplicitNodes,\\n            intermediate,\\n            defaultValue\\n        );\\n\\n        // finally, compute the overall state root\\n        bytes32 computedRoot = MerkleTree.proofRoot(\\n            HISTORICAL_SUMMARIES_INDEX << 1, // one extra proof node on the right for the list length\\n            listDataRoot,\\n            topProof\\n        );\\n        require(computedRoot == stateRoot, \\\"invalid summary proof\\\");\\n    }\\n\\n    /**\\n     * @notice verifies `state.block_roots[index]`\\n     */\\n    function verifyRelativeBlockRoot(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        bytes32 stateRoot\\n    ) internal view returns (bytes32 blockRoot) {\\n        require(proof.length == 19, \\\"invalid proof length\\\");\\n        blockRoot = proof[0];\\n        bytes32 vectorRoot = MerkleTree.proofRoot(\\n            index,\\n            blockRoot,\\n            proof[1:14]\\n        );\\n        bytes32 computedRoot = MerkleTree.proofRoot(\\n            BLOCK_ROOTS_INDEX,\\n            vectorRoot,\\n            proof[14:]\\n        );\\n        require(computedRoot == stateRoot, \\\"invalid relative proof\\\");\\n    }\\n\\n    /**\\n     * @notice verify an SSZ merkle proof for a Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\\n     * @dev intended to be used with block summaries, i.e. `BeaconState.block_roots`\\n     */\\n    function verifySummaryIndex(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        bytes32 summaryRoot\\n    ) internal view returns (bytes32 blockRoot) {\\n        require(proof.length == 14, \\\"invalid proof length\\\");\\n        blockRoot = proof[0];\\n        bytes32 computedRoot = MerkleTree.proofRoot(index, blockRoot, proof[1:]);\\n        require(computedRoot == summaryRoot, \\\"invalid summary proof\\\");\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reliquary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_preDencunBlockHistory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beaconOracleContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_CAPELLA_SLOT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_DENEB_SLOT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UPGRADE_BLOCK\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"summary\",\"type\":\"bytes32\"}],\"name\":\"ImportBlockSummary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"PrecomittedBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAPELLA_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DENEB_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUERY_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beaconOracleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"cacheBlockSummary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"commitRecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getBlockSummary\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preDencunBlockHistory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reliquary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"validBlockHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"verifyBeaconBlockRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BeaconBlockHistory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000005e4de6bb8c6824f29c44bd3473d44da120387d0800000000000000000000000075d6ac4fd8b578d6fde72a02f8a00189208dcc3a000000000000000000000000000f3df6d732807ef1319fb7b8bb8522d0beac0200000000000000000000000000000000000000000000000000000000005ec000000000000000000000000000000000000000000000000000000000000083a0000000000000000000000000000000000000000000000000000000000001286000", "EVMVersion": "london", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}