{"SourceCode": "# @version 0.3.10\r\n\r\n\"\"\"\r\n@title Zharta Renting Vault Contract\r\n@author [Zharta](https://zharta.io/)\r\n@notice This contract is the vault implementation for the LOTM Renting Protocol.\r\n@dev This is the implementation contract for each vault, which is deployed as a minimal proxy (ERC1167) by `RentingV3.vy` and accepts only calls from it. This contract holds the assets (NFTs) ) but does not store any information regarding the token, so pre-conditions must be validated by the caller (`RentingV3.vy`). It implement the functions required for token delegation and staking.\r\nDelegations are performed by warm.xyz HotWalletProxy.\r\n\"\"\"\r\n\r\n# Interfaces\r\n\r\nfrom vyper.interfaces import ERC20 as IERC20\r\nfrom vyper.interfaces import ERC721 as IERC721\r\n\r\ninterface IDelegationRegistry:\r\n    def getHotWallet(cold_wallet: address) -> address: view\r\n    def setHotWallet(hot_wallet_address: address, expiration_timestamp: uint256, lock_hot_wallet_address: bool): nonpayable\r\n    def setExpirationTimestamp(expiration_timestamp: uint256): nonpayable\r\n\r\n\r\n# Structs\r\n\r\nstruct SingleNft:\r\n    tokenId: uint32\r\n    amount: uint224\r\n\r\n\r\n# Global Variables\r\n\r\ncaller: public(address)\r\npayment_token: public(immutable(IERC20))\r\nnft_contract: public(immutable(IERC721))\r\ndelegation_registry: public(immutable(IDelegationRegistry))\r\n\r\n\r\n##### EXTERNAL METHODS - WRITE #####\r\n\r\n@payable\r\n@external\r\ndef __init__(\r\n    _payment_token_addr: address,\r\n    _nft_contract_addr: address,\r\n    _delegation_registry_addr: address,\r\n):\r\n\r\n    \"\"\"\r\n    @dev Sets up the contract by initializing the payment token, NFT contract, delegation registry and staking contract addresses.\r\n    @param _payment_token_addr The address of the payment token contract.\r\n    @param _nft_contract_addr The address of the NFT contract.\r\n    @param _delegation_registry_addr The address of the delegation registry contract.\r\n    \"\"\"\r\n\r\n    assert _payment_token_addr != empty(address), \"payment token addr not set\"\r\n    assert _nft_contract_addr != empty(address), \"nft contract addr not set\"\r\n    assert _delegation_registry_addr != empty(address), \"delegation addr not set\"\r\n\r\n    payment_token = IERC20(_payment_token_addr)\r\n    nft_contract = IERC721(_nft_contract_addr)\r\n    delegation_registry = IDelegationRegistry(_delegation_registry_addr)\r\n\r\n\r\n# Functions\r\n\r\n@external\r\ndef initialise():\r\n\r\n    \"\"\"\r\n    @notice Initialize a vault contract, setting the caller as the contract deployer.\r\n    @dev Ensures that the vault is not already initialized.\r\n    \"\"\"\r\n\r\n    assert self.caller == empty(address), \"already initialised\"\r\n    self.caller = msg.sender\r\n\r\n\r\n@external\r\ndef deposit(token_id: uint256, nft_owner: address, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Deposit an NFT into the vault and optionaly sets up delegation.\r\n    @dev Transfers the NFT from the owner to the vault and optionally sets up delegation.\r\n    @param token_id The id of the NFT to be deposited.\r\n    @param nft_owner The address of the NFT owner.\r\n    @param delegate The address to delegate the NFT to. If empty no delegation is done.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.caller, \"not caller\"\r\n\r\n    nft_contract.safeTransferFrom(nft_owner, self, token_id, b\"\")\r\n\r\n    if delegate != empty(address):\r\n        self._delegate_to_wallet(delegate, max_value(uint256))\r\n\r\n\r\n@external\r\ndef withdraw(token_id: uint256, wallet: address):\r\n\r\n    \"\"\"\r\n    @notice Withdraw an NFT from the vault and transfer it to the wallet.\r\n    @dev Transfers the NFT from the vault to the wallet and clears the delegation.\r\n    @param token_id The id of the NFT to be withdrawn.\r\n    @param wallet The address of the wallet to receive the NFT.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    nft_contract.safeTransferFrom(self, wallet, token_id, b\"\")\r\n    self._delegate_to_wallet(empty(address), 0)\r\n\r\n\r\n@external\r\ndef delegate_to_wallet(delegate: address, expiration: uint256):\r\n\r\n    \"\"\"\r\n    @notice Delegate the NFT to a wallet.\r\n    @dev Delegates the NFT to the given address.\r\n    @param delegate The address to delegate the NFT to.\r\n    @param expiration The expiration timestamp for the delegation.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    self._delegate_to_wallet(delegate, expiration)\r\n\r\n\r\n@external\r\ndef staking_deposit(sender: address, amount: uint256, token_id: uint256, staking_addr: address, pool_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Deposit the payment token into the staking contract.\r\n    @dev Deposits the payment token into the staking contract.\r\n    @param sender The address of the payment token sender.\r\n    @param amount The amount of the payment token to deposit.\r\n    @param token_id The id of the NFT supporting the deposit, which must be deposited in the vault.\r\n    @param staking_addr The address of the staking contract.\r\n    @param pool_method_id The method id of the staking pool deposit function.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    self._staking_deposit(sender, amount, token_id, staking_addr, pool_method_id)\r\n\r\n\r\n@external\r\ndef staking_withdraw(wallet: address, amount: uint256, token_id: uint256, staking_addr: address, pool_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Withdraw the payment token from the staking contract.\r\n    @dev Withdraws the payment token from the staking contract.\r\n    @param wallet The address of the wallet to receive the payment token.\r\n    @param amount The amount of the payment token to withdraw.\r\n    @param token_id The id of the NFT supporting the withdrawal, which must be deposited in the vault.\r\n    @param staking_addr The address of the staking contract.\r\n    @param pool_method_id The method id of the staking pool withdraw function.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    self._staking_withdraw(wallet, amount, token_id, staking_addr, pool_method_id)\r\n\r\n\r\n@external\r\ndef staking_claim(wallet: address, token_id: uint256, staking_addr: address, pool_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Claim the staking rewards.\r\n    @dev Claims the staking rewards.\r\n    @param wallet The address of the wallet to receive the staking rewards.\r\n    @param token_id The id of the NFT supporting the claim, which must be deposited in the vault.\r\n    @param staking_addr The address of the staking contract.\r\n    @param pool_method_id The method id of the staking pool claim function.\r\n    \"\"\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    self._staking_claim(wallet, token_id, staking_addr, pool_method_id)\r\n\r\n\r\n@external\r\ndef staking_compound(token_id: uint256, staking_addr: address, pool_claim_method_id: bytes4, pool_deposit_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Compound the staking rewards.\r\n    @dev Compounds the staking rewards by claiming and depositing them. No validations are performed regarding staking limits or minimal deposit amounts.\r\n    @param token_id The id of the NFT supporting the compound, which must be deposited in the vault.\r\n    @param staking_addr The address of the staking contract.\r\n    @param pool_claim_method_id The method id of the staking pool claim function.\r\n    @param pool_deposit_method_id The method id of the staking pool deposit function.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    self._staking_claim(self, token_id, staking_addr, pool_claim_method_id)\r\n    self._staking_deposit(self, payment_token.balanceOf(self), token_id, staking_addr, pool_deposit_method_id)\r\n\r\n\r\n@view\r\n@external\r\ndef onERC721Received(_operator: address, _from: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\r\n\r\n    \"\"\"\r\n    @notice ERC721 token receiver callback.\r\n    @dev Returns the ERC721 receiver callback selector.\r\n    @param _operator The address which called `safeTransferFrom` function.\r\n    @param _from The address which previously owned the token.\r\n    @param _tokenId The NFT identifier which is being transferred.\r\n    @param _data Additional data with no specified format.\r\n    @return The ERC721 receiver callback selector.\r\n    \"\"\"\r\n\r\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\r\n\r\n\r\n@internal\r\ndef _delegate_to_wallet(delegate: address, expiration: uint256):\r\n    if delegation_registry.getHotWallet(self) == delegate:\r\n        delegation_registry.setExpirationTimestamp(expiration)\r\n    else:\r\n        delegation_registry.setHotWallet(delegate, expiration, False)\r\n\r\n\r\n@internal\r\ndef _staking_deposit(wallet: address, amount: uint256, token_id: uint256, staking_addr: address, pool_method_id: bytes4):\r\n    payment_token.approve(staking_addr, amount)\r\n\r\n    nfts: DynArray[SingleNft, 1] = [SingleNft({tokenId: convert(token_id, uint32), amount: convert(amount, uint224)})]\r\n    raw_call(staking_addr, concat(pool_method_id, _abi_encode(nfts)))\r\n\r\n\r\n@internal\r\ndef _staking_withdraw(wallet: address, amount: uint256, token_id: uint256, staking_addr: address, pool_method_id: bytes4):\r\n\r\n    nfts: DynArray[SingleNft, 1] = [SingleNft({tokenId: convert(token_id, uint32), amount: convert(amount, uint224)})]\r\n    raw_call(staking_addr, concat(pool_method_id, _abi_encode(nfts, wallet)))\r\n\r\n\r\n@internal\r\ndef _staking_claim(wallet: address, token_id: uint256, staking_addr: address, pool_method_id: bytes4):\r\n\r\n    nfts: DynArray[uint256, 1] = [token_id]\r\n    raw_call(staking_addr, concat(pool_method_id, _abi_encode(nfts, wallet)))", "ABI": "[{\"stateMutability\":\"payable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_payment_token_addr\",\"type\":\"address\"},{\"name\":\"_nft_contract_addr\",\"type\":\"address\"},{\"name\":\"_delegation_registry_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialise\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_to_wallet\",\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"staking_deposit\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"staking_addr\",\"type\":\"address\"},{\"name\":\"pool_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"staking_withdraw\",\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"staking_addr\",\"type\":\"address\"},{\"name\":\"pool_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"staking_claim\",\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"staking_addr\",\"type\":\"address\"},{\"name\":\"pool_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"staking_compound\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"staking_addr\",\"type\":\"address\"},{\"name\":\"pool_claim_method_id\",\"type\":\"bytes4\"},{\"name\":\"pool_deposit_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"onERC721Received\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"caller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"payment_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_contract\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Zharta Renting Vault Contract", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000004d224452801aced8b2f0aebe155379bb5d594381000000000000000000000000790b2cf29ed4f310bf7641f013c65d4560d28371000000000000000000000000c3aa9bc72bd623168860a1e5c6a4530d3d80456c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}