{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AphraToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.10;\\n\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\n\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n} // OZ: MerkleProof\\n\\n/// @notice Modern and gas-optimized ERC-20 + EIP-2612 implementation with COMP-style governance\\n/// @author Modified from Solmate (https://raw.githubusercontent.com/lexDAO/Kali/main/contracts/KaliDAOtoken.sol)\\n/// License-Identifier: AGPL-3.0-only\\nabstract contract DAOToken {\\n    /* ///////////////////////////////////////////////////////////////\\n    EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\n    error NoArrayParity();\\n\\n    error SignatureExpired();\\n\\n    error NullAddress();\\n\\n    error InvalidNonce();\\n\\n    error NotDetermined();\\n\\n    error InvalidSignature();\\n\\n    error Uint32max();\\n\\n    error Uint96max();\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public constant decimals = 18;\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    ERC- 20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    EIP - 2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\\n\\n    uint256 internal INITIAL_CHAIN_ID;\\n\\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    DAO STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n    keccak256('Delegation(address delegatee,uint256 nonce,uint256 deadline)');\\n\\n    mapping(address => address) internal _delegates;\\n\\n    mapping(address => mapping(uint256 => Checkpoint)) public checkpoints;\\n\\n    mapping(address => uint256) public numCheckpoints;\\n\\n    struct Checkpoint {\\n        uint32 fromTimestamp;\\n        uint96 votes;\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _init(\\n        string memory name_,\\n        string memory symbol_\\n    ) internal virtual {\\n        name = name_;\\n\\n        symbol = symbol_;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n\\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    ERC - 20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        _moveDelegates(delegates(msg.sender), delegates(to), amount);\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max)\\n            allowance[from][msg.sender] -= amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        _moveDelegates(delegates(from), delegates(to), amount);\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    EIP - 2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) revert SignatureExpired();\\n\\n        // cannot realistically overflow on human timescales\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    '\\\\x19\\\\x01',\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            if (recoveredAddress == address(0) || recoveredAddress != owner) revert InvalidSignature();\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\\n    }\\n\\n    function _computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n        keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256('1'),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    DAO LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function delegates(address delegator) public view virtual returns (address) {\\n        address current = _delegates[delegator];\\n\\n        return current == address(0) ? delegator : current;\\n    }\\n\\n    function getCurrentVotes(address account) public view virtual returns (uint256) {\\n        // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\\n        unchecked {\\n            uint256 nCheckpoints = numCheckpoints[account];\\n\\n            return nCheckpoints != 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n        }\\n    }\\n\\n    function delegate(address delegatee) public virtual {\\n        _delegate(msg.sender, delegatee);\\n    }\\n\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) revert SignatureExpired();\\n\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, deadline));\\n\\n        bytes32 digest = keccak256(abi.encodePacked('\\\\x19\\\\x01', DOMAIN_SEPARATOR(), structHash));\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n\\n        if (signatory == address(0)) revert NullAddress();\\n\\n        // cannot realistically overflow on human timescales\\n        unchecked {\\n            if (nonce != nonces[signatory]++) revert InvalidNonce();\\n        }\\n\\n        _delegate(signatory, delegatee);\\n    }\\n\\n    function getPriorVotes(address account, uint256 timestamp) public view virtual returns (uint96) {\\n        if (block.timestamp <= timestamp) revert NotDetermined();\\n\\n        uint256 nCheckpoints = numCheckpoints[account];\\n\\n        if (nCheckpoints == 0) return 0;\\n\\n        // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\\n        unchecked {\\n            if (checkpoints[account][nCheckpoints - 1].fromTimestamp <= timestamp)\\n                return checkpoints[account][nCheckpoints - 1].votes;\\n\\n            if (checkpoints[account][0].fromTimestamp > timestamp) return 0;\\n\\n            uint256 lower;\\n\\n            // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\\n            uint256 upper = nCheckpoints - 1;\\n\\n            while (upper > lower) {\\n                // this is safe from underflow because `upper` ceiling is provided\\n                uint256 center = upper - (upper - lower) / 2;\\n\\n                Checkpoint memory cp = checkpoints[account][center];\\n\\n                if (cp.fromTimestamp == timestamp) {\\n                    return cp.votes;\\n                } else if (cp.fromTimestamp < timestamp) {\\n                    lower = center;\\n                } else {\\n                    upper = center - 1;\\n                }\\n            }\\n\\n            return checkpoints[account][lower].votes;\\n\\n        }\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal virtual {\\n        address currentDelegate = delegates(delegator);\\n\\n        _delegates[delegator] = delegatee;\\n\\n        _moveDelegates(currentDelegate, delegatee, balanceOf[delegator]);\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n    }\\n\\n    function _moveDelegates(\\n        address srcRep,\\n        address dstRep,\\n        uint256 amount\\n    ) internal virtual {\\n        if (srcRep != dstRep && amount != 0)\\n            if (srcRep != address(0)) {\\n                uint256 srcRepNum = numCheckpoints[srcRep];\\n\\n                uint256 srcRepOld = srcRepNum != 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n\\n                uint256 srcRepNew = srcRepOld - amount;\\n\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n        if (dstRep != address(0)) {\\n            uint256 dstRepNum = numCheckpoints[dstRep];\\n\\n            uint256 dstRepOld = dstRepNum != 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n\\n            uint256 dstRepNew = dstRepOld + amount;\\n\\n            _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint256 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    ) internal virtual {\\n        unchecked {\\n            // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\\n            if (nCheckpoints != 0 && checkpoints[delegatee][nCheckpoints - 1].fromTimestamp == block.timestamp) {\\n                checkpoints[delegatee][nCheckpoints - 1].votes = _safeCastTo96(newVotes);\\n            } else {\\n                checkpoints[delegatee][nCheckpoints] = Checkpoint(_safeCastTo32(block.timestamp), _safeCastTo96(newVotes));\\n\\n                // cannot realistically overflow on human timescales\\n                numCheckpoints[delegatee] = nCheckpoints + 1;\\n            }\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    MINT / BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        _moveDelegates(address(0), delegates(to), amount);\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // cannot underflow because a user's balance\\n        // will never be larger than the total supply\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        _moveDelegates(delegates(from), address(0), amount);\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    function burn(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    SAFECAST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeCastTo32(uint256 x) internal pure virtual returns (uint32) {\\n        if (x > type(uint32).max) revert Uint32max();\\n\\n        return uint32(x);\\n    }\\n\\n    function _safeCastTo96(uint256 x) internal pure virtual returns (uint96) {\\n        if (x > type(uint96).max) revert Uint96max();\\n\\n        return uint96(x);\\n    }\\n}\\n\\ncontract AphraToken is DAOToken {\\n\\n    /// ============ Immutable storage ============\\n\\n    bytes32 public immutable merkleRoot;\\n\\n    /// ============ Mutable storage ============\\n\\n    mapping(address => bool) public hasClaimed;\\n\\n    address public minter;\\n\\n    uint256 public mintingAllowedAfter;\\n\\n    uint32 public constant minimumTimeBetweenMints = 1 days * 365;\\n\\n    uint8 public constant mintCap = 3;\\n\\n    /// ============ Errors ============\\n    error NotMinter();\\n    error NoMintYet();\\n    error MintCapExceeded(uint256 maxAllowed, uint256 mintAttempt);\\n\\n\\n    error AlreadyClaimed();\\n    error NotInMerkle();\\n\\n    event MinterChanged(address indexed minter, address indexed newMinter);\\n    event Claim(address indexed to, uint256 amount);\\n\\n    constructor(bytes32 merkleRoot_,\\n                address minter_,\\n                uint256 mintingAllowedAfter_\\n    ) {\\n        _init(\\\"Aphra Finance\\\", \\\"APHRA\\\");\\n        merkleRoot = merkleRoot_;\\n        minter = minter_;\\n        mintingAllowedAfter = mintingAllowedAfter_;\\n        emit MinterChanged(address(0), minter);\\n    }\\n\\n    function setMinter(address newMinter_) external {\\n        if (msg.sender != minter) revert NotMinter();\\n        minter = newMinter_;\\n        emit MinterChanged(newMinter_, minter);\\n    }\\n\\n    function mint(uint256 rawAmount) external {\\n        if (msg.sender != minter) revert NotMinter();\\n        if (block.timestamp <= mintingAllowedAfter) revert NoMintYet();\\n        // record the mint\\n        mintingAllowedAfter = block.timestamp + minimumTimeBetweenMints;\\n        uint256 mintableBalance = ((totalSupply * mintCap) / 100);\\n        // mint the amount\\n        if (rawAmount > mintableBalance) revert MintCapExceeded(mintableBalance, rawAmount);\\n        // mint the amount\\n        _mint(minter, rawAmount);\\n    }\\n\\n    function claim(address to, uint256 amount, bytes32[] calldata proof) external {\\n        // Throw if address has already claimed tokens\\n        if (hasClaimed[to]) revert AlreadyClaimed();\\n\\n        // Verify merkle proof, or revert if not in tree\\n        bytes32 leaf = keccak256(abi.encodePacked(to, amount));\\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\\n        if (!isValidLeaf) revert NotInMerkle();\\n\\n        // Set address to claimed\\n        hasClaimed[to] = true;\\n\\n        // Mint tokens to address\\n        _mint(to, amount);\\n\\n        // Emit claim event\\n        emit Claim(to, amount);\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintingAllowedAfter_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAttempt\",\"type\":\"uint256\"}],\"name\":\"MintCapExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoArrayParity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoMintYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDetermined\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInMerkle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMinter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Uint32max\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Uint96max\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTimeBetweenMints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingAllowedAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMinter_\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AphraToken", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "70a85e9e58cf7fab1406e94c0602a039da1b454d3b5ca2a51dea6001b6320d4d0000000000000000000000002101a22a8a6f2b60ef36013effcef56893cea9830000000000000000000000000000000000000000000000000000000063d31400", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}