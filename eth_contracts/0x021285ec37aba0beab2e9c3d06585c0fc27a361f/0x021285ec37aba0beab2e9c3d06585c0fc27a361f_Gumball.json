{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"TokenB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"TokenA.sol\\\";\\n\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u00e2\u2020\u2019 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u00e2\u2020\u2019 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u00e2\u20ac\u2122s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\nlibrary ERC721Utils {\\n    /**\\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC721-onERC721Received}\\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\\n     *\\n     * The acceptance call is not executed and treated as a no-op if the target address is doesn't contain code (i.e. an EOA).\\n     * Otherwise, the recipient must implement {IERC721Receiver-onERC721Received} and return the acceptance magic value to accept\\n     * the transfer.\\n     */\\n    function checkOnERC721Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length > 0) {\\n            try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\\n                if (retval != IERC721Receiver.onERC721Received.selector) {\\n                    // Token rejected\\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-IERC721Receiver implementer\\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    mapping(uint256 tokenId => address) private _owners;\\n\\n    mapping(address owner => uint256) private _balances;\\n\\n    mapping(uint256 tokenId => address) private _tokenApprovals;\\n\\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ERC721InvalidOwner(address(0));\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return _requireOwned(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\\n        _requireOwned(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual {\\n        _approve(to, tokenId, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        _requireOwned(tokenId);\\n\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        address previousOwner = _update(to, tokenId, _msgSender());\\n        if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\\n        transferFrom(from, to, tokenId);\\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     *\\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\\n     */\\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\\n     * particular (ignoring whether it is owned by `owner`).\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            spender != address(0) &&\\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\\n     * the `spender` for the specific `tokenId`.\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\\n        if (!_isAuthorized(owner, spender, tokenId)) {\\n            if (owner == address(0)) {\\n                revert ERC721NonexistentToken(tokenId);\\n            } else {\\n                revert ERC721InsufficientApproval(spender, tokenId);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\\n     *\\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\\n     * remain consistent with one another.\\n     */\\n    function _increaseBalance(address account, uint128 value) internal virtual {\\n        unchecked {\\n            _balances[account] += value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\\n        address from = _ownerOf(tokenId);\\n\\n        // Perform (optional) operator check\\n        if (auth != address(0)) {\\n            _checkAuthorized(from, auth, tokenId);\\n        }\\n\\n        // Execute the update\\n        if (from != address(0)) {\\n            // Clear approval. No need to re-authorize or emit the Approval event\\n            _approve(address(0), tokenId, address(0), false);\\n\\n            unchecked {\\n                _balances[from] -= 1;\\n            }\\n        }\\n\\n        if (to != address(0)) {\\n            unchecked {\\n                _balances[to] += 1;\\n            }\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        return from;\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner != address(0)) {\\n            revert ERC721InvalidSender(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        address previousOwner = _update(address(0), tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        } else if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - `to` cannot be the zero address.\\n     * - `from` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\\n        _safeTransfer(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth) internal {\\n        _approve(to, tokenId, auth, true);\\n    }\\n\\n    /**\\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\\n     * emitted in the context of transfers.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\\n        // Avoid reading the owner unless necessary\\n        if (emitEvent || auth != address(0)) {\\n            address owner = _requireOwned(tokenId);\\n\\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\\n                revert ERC721InvalidApprover(auth);\\n            }\\n\\n            if (emitEvent) {\\n                emit Approval(owner, to, tokenId);\\n            }\\n        }\\n\\n        _tokenApprovals[tokenId] = to;\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Requirements:\\n     * - operator can't be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC721InvalidOperator(operator);\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\\n     * Returns the owner.\\n     *\\n     * Overrides to ownership logic should be done to {_ownerOf}.\\n     */\\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n        return owner;\\n    }\\n}\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\\n\\n    uint256[] private _allTokens;\\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev An `owner`'s token query was out of bounds for `index`.\\n     *\\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\\n     */\\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\\n\\n    /**\\n     * @dev Batch mint is not allowed.\\n     */\\n    error ERC721EnumerableForbiddenBatchMint();\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\\n        if (index >= balanceOf(owner)) {\\n            revert ERC721OutOfBoundsIndex(owner, index);\\n        }\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\\n        if (index >= totalSupply()) {\\n            revert ERC721OutOfBoundsIndex(address(0), index);\\n        }\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_update}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\\n        address previousOwner = super._update(to, tokenId, auth);\\n\\n        if (previousOwner == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (previousOwner != to) {\\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (previousOwner != to) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n\\n        return previousOwner;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = balanceOf(to) - 1;\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = balanceOf(from);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n\\n    /**\\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\\n     */\\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\\n        if (amount > 0) {\\n            revert ERC721EnumerableForbiddenBatchMint();\\n        }\\n        super._increaseBalance(account, amount);\\n    }\\n}\\n\\ncontract Gumball is ERC721Enumerable, ERC721Receiver {\\n\\n    address public owner;\\n    address public gumballCoinAddress = 0xa72332aF4a7efBCE221903e7A09175BE64F0400d;\\n    address public authorizedResolver;\\n    uint256 public tokenCount;\\n\\n    string public imageURL;\\n\\n    enum GumballState {\\n        NOTMINTED,\\n        MINTED,\\n        INITIALIZED,\\n        ACTIVATED,\\n        RESOLVED\\n    }\\n\\n    mapping(uint256 => mapping(uint256 => uint256)) public gumballTypeToDropTableSlotOdds; //Number used to determine if the rolled number hit this prize\\n    mapping(uint256 => mapping(uint256 => uint256)) public gumballTypeToDropTableSlotWinnings; //Number used for winnings in % to the 10,000\\n    mapping(uint256 => uint256) public gumballTypeToDropTable;\\n    mapping(uint256 => uint256) public gumballType;\\n    mapping(uint256 => uint256) public gumballTypeStaticWinnings;\\n    mapping(uint256 => GumballState) public gumballState;\\n    mapping(uint256 => address) public gumballActivatedBy;\\n\\n    event GumballActivated(uint256 gumballID);\\n    event GumballMinted(uint256 gumballID);\\n    event GumballResolved(uint256 gumballID,uint256 winningsPercent, uint256 winnings, bytes32 seed);\\n    event GumballInitialized(uint256 gumballID, bytes32 seed, uint256 gumballType);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"only owner\\\");\\n        _;\\n    }\\n    modifier onlyResolver() {\\n        require(msg.sender == authorizedResolver, \\\"only resolver\\\");\\n        _;\\n    }\\n\\n    constructor( )\\n        ERC721(\\\"Gumball\\\", \\\"GUMBALL\\\")\\n    {\\n        owner = msg.sender;\\n        authorizedResolver = msg.sender;\\n    }\\n\\n    function giveOwnership(address _address) external onlyOwner{\\n        require(_address != address(0),\\\"Cant renounce this contract\\\");\\n        owner = _address;\\n    }\\n\\n    function setGumballAddress(address _addy) external onlyOwner{\\n        gumballCoinAddress = _addy;\\n    }\\n    function setNewAuthorizer(address _addy) external onlyResolver{\\n        authorizedResolver = _addy;\\n    }\\n\\n    function setImageUrl(string memory url) external onlyOwner{\\n        imageURL = url;\\n    }\\n\\n    function updateGumballTable(uint256 _gumballType,uint256[] memory _winningsOdds, uint256[] memory _winningsAmount) external onlyOwner{\\n        require(_winningsOdds.length == _winningsAmount.length,\\\"Lists need to be the same length.\\\");\\n        for(uint256 i = 0; i < _winningsOdds.length; i++){\\n            gumballTypeToDropTableSlotOdds[_gumballType][i] = _winningsOdds[i];\\n            gumballTypeToDropTableSlotWinnings[_gumballType][i] = _winningsAmount[i];\\n        }\\n    }\\n    function updateTypeToTable(uint256[] memory _types, uint256[] memory _tableIds) external onlyOwner{\\n        require(_types.length == _tableIds.length,\\\"Lists need to be the same length.\\\");\\n        for(uint256 i = 0; i < _tableIds.length; i++){\\n            gumballTypeToDropTable[_types[i]] = _tableIds[i];\\n        }\\n    }\\n    function updateTypeStaticWinnings(uint256[] memory _gumballType, uint256[] memory _winningsAmount) external onlyOwner{\\n        require(_gumballType.length == _winningsAmount.length,\\\"Lists need to be the same length.\\\");\\n        for(uint256 i = 0; i < _winningsAmount.length; i++){\\n            gumballTypeStaticWinnings[_gumballType[i]] = _winningsAmount[i];\\n        }\\n    }\\n\\n\\n    receive() external payable {\\n\\n    }\\n\\n    function getBalance() public view returns(uint256){\\n        return address(this).balance;\\n    }\\n    function getBalanceOfAddress(address _addy) public view returns(uint256){\\n        return _addy.balance;\\n    }  \\n\\n    function getWinnings(uint256 _gumballType, uint256 _rolledNumber) public view returns(uint256){\\n        uint256 index = 0;\\n        while(true){\\n            if(_rolledNumber <=  gumballTypeToDropTableSlotOdds[_gumballType][index]){\\n                return gumballTypeToDropTableSlotWinnings[_gumballType][index];\\n            } else {\\n                index++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    function initializeGumball(uint256[] memory _gumballID, bytes32[] memory _seedsList , uint256[] memory _typesList) external onlyResolver {\\n        require(_gumballID.length == _seedsList.length && _gumballID.length == _typesList.length,\\\"Lists need to be the same length.\\\");\\n        for(uint256 i = 0; i < _gumballID.length; i++){\\n            uint256 tempId = _gumballID[i];\\n            require(gumballState[tempId] == GumballState.MINTED,\\\"This gumball needs to be in the MINTED state to be initialized.\\\");\\n            gumballState[tempId] = GumballState.INITIALIZED;\\n            emit GumballInitialized(tempId,_seedsList[i], _typesList[i]);\\n            gumballType[tempId] = _typesList[i];\\n        }\\n    }\\n\\n    function resolveGumball(uint256[] memory _gumballID, bytes32[] memory _seedsList) external onlyResolver {\\n        require(_gumballID.length == _seedsList.length,\\\"Lists need to be the same length.\\\");\\n        for(uint256 i = 0; i < _gumballID.length; i++){\\n            uint256 tempId = _gumballID[i];\\n            require(gumballState[tempId] == GumballState.ACTIVATED,\\\"This gumball needs to be in the ACTIVATED state to be resolved.\\\");\\n            gumballState[tempId] = GumballState.RESOLVED;\\n            uint256 rolledNumber = uint256(bytes32(keccak256(abi.encodePacked(_seedsList[i]))));\\n            uint256 winnings = getWinnings(gumballTypeToDropTable[gumballType[tempId]], rolledNumber % 100000);\\n            uint256 winningsETH = (address(this).balance / 10000) * winnings;\\n            address winner = gumballActivatedBy[tempId];\\n            emit GumballResolved(tempId,winnings,winningsETH,_seedsList[i]);\\n            payable(winner).transfer(winningsETH);\\n        }\\n    }\\n\\n    function claimStaticGumballs(uint256[] memory _gumballID) external {\\n        for(uint256 i = 0; i < _gumballID.length; i++){\\n            require(ownerOf(_gumballID[i]) == msg.sender,\\\"You do not own this gumball.\\\");\\n            require(gumballState[_gumballID[i]] == GumballState.INITIALIZED,\\\"This gumball needs to be in the INITIALIZED state to be activated.\\\");\\n            uint256 typeStaticWinnings = gumballTypeStaticWinnings[gumballType[_gumballID[i]]];\\n            require( typeStaticWinnings > 0,\\\"This gumball does not have static winnings and cannot be activated.\\\");\\n            safeTransferFrom(msg.sender,address(this),_gumballID[i]);\\n            gumballState[_gumballID[i]] = GumballState.RESOLVED;\\n            emit GumballActivated(_gumballID[i]);\\n            uint256 winningsETH = (address(this).balance / 10000) * typeStaticWinnings;\\n            emit GumballResolved(_gumballID[i],typeStaticWinnings,winningsETH,bytes32(0));\\n            payable(msg.sender).transfer(winningsETH);\\n        }\\n    }\\n\\n    function activateGumball(uint256[] memory _gumballID) external {\\n        for(uint256 i = 0; i < _gumballID.length; i++){\\n            require(ownerOf(_gumballID[i]) == msg.sender,\\\"You do not own this gumball.\\\");\\n            require(gumballState[_gumballID[i]] == GumballState.INITIALIZED,\\\"This gumball needs to be in the INITIALIZED state to be activated.\\\");\\n            require(gumballTypeStaticWinnings[gumballType[_gumballID[i]]] == 0,\\\"This gumball has static winnings and cannot be activated.\\\");\\n            safeTransferFrom(msg.sender,address(this),_gumballID[i]);\\n            gumballState[_gumballID[i]] = GumballState.ACTIVATED;\\n            gumballActivatedBy[_gumballID[i]] = msg.sender;\\n            emit GumballActivated(_gumballID[i]);\\n        }\\n    }\\n\\n    function claimGumball(uint256[] memory _coinID) external {\\n        //In order to mint, the coin IDS must be transfered into this contract\\n        ERC_X gumballCoin = ERC_X(gumballCoinAddress);\\n        uint256 balanceBefore = gumballCoin.balanceOf(address(this));\\n        uint256 tokensNeededForSuccess = _coinID.length * (1 * 10 ** 18); // 1 Coin, 18 decimals, is the UNITS for the 1155 tokens\\n\\n        for(uint256 i = 0; i < _coinID.length; i++){\\n            gumballCoin.safeTransferFrom(msg.sender,address(this),_coinID[i],1,\\\"\\\");\\n            _mint(msg.sender, tokenCount);\\n            gumballState[tokenCount] = GumballState.MINTED;\\n            emit GumballMinted(tokenCount);\\n            tokenCount++;\\n        }\\n\\n        require(gumballCoin.balanceOf(address(this)) - balanceBefore == tokensNeededForSuccess,\\\"Failed to receive tokens required.\\\");\\n\\n    }\\n\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n    function getAttributeData(uint256 _gumballType) public view returns(string memory){\\n        return   string(\\n                    abi.encodePacked(\\n                        '{ \\\"trait_type\\\":\\\"Gumball Type\\\",\\\"value\\\":\\\"',\\n                        uint2str(_gumballType),\\n                        '\\\"',\\n                        \\\"}\\\"\\n                    )\\n                );\\n    }\\n\\n\\n    function withdraw() external onlyOwner{\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function withdrawTokens(address _tokenAddress) external onlyOwner{\\n        IERC20 token = IERC20(_tokenAddress);\\n        token.transfer(payable(msg.sender), token.balanceOf(_tokenAddress));\\n    }\\n\\n    function withdrawGumballs(uint256[] memory _coinID) external onlyOwner{\\n        ERC_X gumballCoin = ERC_X(gumballCoinAddress);\\n        for(uint256 i = 0; i < _coinID.length; i++){\\n            gumballCoin.safeTransferFrom(address(this),msg.sender,_coinID[i],1,\\\"\\\");\\n        }\\n    }\\n\\n    function withdrawamount(uint256 _amount) external onlyOwner {\\n        payable(owner).transfer(_amount);\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override(ERC721)\\n        returns (string memory)\\n    {\\n\\n        uint256  _gumballType = gumballType[tokenId];\\n            return\\n                string.concat(\\n                    \\\"data:application/json;utf8,\\\",\\n                string(\\n                    abi.encodePacked(\\n                        '{ \\\"name\\\": \\\"GUMBALL #',\\n                        uint2str(tokenId),\\n                        '\\\",\\\"attributes\\\": [',\\n                        getAttributeData(_gumballType),\\n                        \\\"]\\\",\\n                        ',\\\"image\\\" : \\\"',\\n                        imageURL,\\n                        '%28',\\n                        uint2str(_gumballType),\\n                        \\\"%29.png\\\",\\n                        ' \\\",\\\"external_url\\\": \\\"gumball.gg\\\",\\\"description\\\":\\\"Claim this Gum Ball to get a share of the Prize Pool.\\\"',\\n                        \\\"}\\\"\\n                    )\\n                )\\n            );\\n    }\\n}\"\r\n    },\r\n    \"TokenA.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2024-02-11\\n*/\\n\\n//Inspired by all the great work out there from ERC20, 404, 721, 721a, 721Psi, 1155, 1155Delta\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.24;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n    error ERC20InvalidSender(address sender);\\n    error ERC20InvalidReceiver(address receiver);\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n    error ERC20InvalidApprover(address approver);\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\\ninterface IERCX {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * Cannot burn from the zero address.\\n     */\\n    error BurnFromZeroAddress();\\n\\n    /**\\n     * Cannot burn from the address that doesn't owne the token.\\n     */\\n    error BurnFromNonOnwerAddress();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from` or the `amount` is not 1.\\n     */\\n    error TransferFromIncorrectOwnerOrInvalidAmount();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC1155Receiver interface.\\n     */\\n    error TransferToNonERC1155ReceiverImplementer();\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The length of input arraies is not matching.\\n     */\\n    error InputLengthMistmatch();\\n\\n    function isOwnerOf(address account, uint256 id) external view returns(bool);\\n}\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n\\nabstract contract ERC721Receiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721Receiver.onERC721Received.selector;\\n    }\\n}\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\n\\n/// @notice Library for bit twiddling and boolean operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\\nlibrary LibBit {\\n    /*\u00c2\u00b4:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0\u00e2\u20ac\u00a2.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:*/\\n    /*                  BIT TWIDDLING OPERATIONS                  */\\n    /*.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4+\u00cb\u0161.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4\u00e2\u20ac\u00a2*.+\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b4*.\u00c2\u00b4\u00e2\u20ac\u00a2*.\u00e2\u20ac\u00a2\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4:\u00e2\u20ac\u00a2\u00cb\u0161\u00c2\u00b0.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4+\u00c2\u00b0.\u00e2\u20ac\u00a2*/\\n\\n    /// @dev Find last set.\\n    /// Returns the index of the most significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    function fls(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\n        }\\n    }\\n\\n    /// @dev Count leading zeros.\\n    /// Returns the number of zeros preceding the most significant one bit.\\n    /// If `x` is zero, returns 256.\\n    function clz(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\\n        }\\n    }\\n\\n    /// @dev Find first set.\\n    /// Returns the index of the least significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    /// Equivalent to `ctz` (count trailing zeros), which gives\\n    /// the number of zeros following the least significant one bit.\\n    function ffs(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Isolate the least significant bit.\\n            let b := and(x, add(not(x), 1))\\n\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\\n        }\\n    }\\n\\n    /// @dev Returns the number of set bits in `x`.\\n    function popCount(uint256 x) internal pure returns (uint256 c) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let isMax := eq(x, max)\\n            x := sub(x, and(shr(1, x), div(max, 3)))\\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\\n            x := and(add(x, shr(4, x)), div(max, 17))\\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\\n        }\\n    }\\n\\n    /// @dev Returns whether `x` is a power of 2.\\n    function isPo2(uint256 x) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `x && !(x & (x - 1))`.\\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the bit level.\\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n        uint256 m1 = m0 ^ (m0 << 2);\\n        uint256 m2 = m1 ^ (m1 << 1);\\n        r = reverseBytes(x);\\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\\n    }\\n\\n    /// @dev Returns `x` reversed at the byte level.\\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == 0) >> 192);\\n            uint256 m1 = m0 ^ (m0 << 32);\\n            uint256 m2 = m1 ^ (m1 << 16);\\n            uint256 m3 = m2 ^ (m2 << 8);\\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\\n            r = (r >> 128) | (r << 128);\\n        }\\n    }\\n\\n    /*\u00c2\u00b4:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0\u00e2\u20ac\u00a2.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:*/\\n    /*                     BOOLEAN OPERATIONS                     */\\n    /*.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4+\u00cb\u0161.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4\u00e2\u20ac\u00a2*.+\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b4*.\u00c2\u00b4\u00e2\u20ac\u00a2*.\u00e2\u20ac\u00a2\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4:\u00e2\u20ac\u00a2\u00cb\u0161\u00c2\u00b0.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4+\u00c2\u00b0.\u00e2\u20ac\u00a2*/\\n\\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\\n    // Non-zero values are true, zero is false.\\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\\n    // Usually, if not always, the bool result of a regular Solidity expression,\\n    // or the argument of a public/external function will be a clean bool.\\n    // You can usually use the raw variants for more performance.\\n    // If uncertain, test (best with exact compiler settings).\\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\\n\\n    /// @dev Returns `x & y`. Inputs must be clean.\\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x & y`.\\n    function and(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`. Inputs must be clean.\\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`.\\n    function or(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\\n    function rawToUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := b\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0.\\n    function toUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := iszero(iszero(b))\\n        }\\n    }\\n}\\n\\n/// @notice Library for storage of packed unsigned booleans.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\\nlibrary LibBitmap {\\n    /*\u00c2\u00b4:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0\u00e2\u20ac\u00a2.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4+\u00cb\u0161.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4\u00e2\u20ac\u00a2*.+\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b4*.\u00c2\u00b4\u00e2\u20ac\u00a2*.\u00e2\u20ac\u00a2\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4:\u00e2\u20ac\u00a2\u00cb\u0161\u00c2\u00b0.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4+\u00c2\u00b0.\u00e2\u20ac\u00a2*/\\n\\n    /// @dev The constant returned when a bitmap scan does not find a result.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00c2\u00b4:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0\u00e2\u20ac\u00a2.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4+\u00cb\u0161.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4\u00e2\u20ac\u00a2*.+\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b4*.\u00c2\u00b4\u00e2\u20ac\u00a2*.\u00e2\u20ac\u00a2\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4:\u00e2\u20ac\u00a2\u00cb\u0161\u00c2\u00b0.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4+\u00c2\u00b0.\u00e2\u20ac\u00a2*/\\n\\n    /// @dev A bitmap in storage.\\n    struct Bitmap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00c2\u00b4:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0\u00e2\u20ac\u00a2.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:\u00cb\u0161.\u00c2\u00b0*.\u00cb\u0161\u00e2\u20ac\u00a2\u00c2\u00b4.\u00c2\u00b0:\u00c2\u00b0\u00e2\u20ac\u00a2.\u00c2\u00b0+.*\u00e2\u20ac\u00a2\u00c2\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4+\u00cb\u0161.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4\u00e2\u20ac\u00a2*.+\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b4*.\u00c2\u00b4\u00e2\u20ac\u00a2*.\u00e2\u20ac\u00a2\u00c2\u00b0.\u00e2\u20ac\u00a2\u00c2\u00b0:\u00c2\u00b0.\u00c2\u00b4:\u00e2\u20ac\u00a2\u00cb\u0161\u00c2\u00b0.*\u00c2\u00b0.\u00cb\u0161:*.\u00c2\u00b4+\u00c2\u00b0.\u00e2\u20ac\u00a2*/\\n\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\\n        // Both cost the same amount of gas, but the former allows the returned value\\n        // to be reused without cleaning the upper bits.\\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            isSet := b\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to true.\\n    function set(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to false.\\n    function unset(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n\\n    /// @dev Flips the bit at `index` in `bitmap`.\\n    /// Returns the boolean result of the flipped bit.\\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let shift := and(index, 0xff)\\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\\n            // It makes sense to return the `newIsSet`,\\n            // as it allow us to skip an additional warm `sload`,\\n            // and it costs minimal gas (about 15),\\n            // which may be optimized away if the returned value is unused.\\n            newIsSet := and(1, shr(shift, storageValue))\\n            sstore(storageSlot, storageValue)\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let storageValue := sload(storageSlot)\\n            let shift := and(index, 0xff)\\n            sstore(\\n                storageSlot,\\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), max)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\\n        }\\n    }\\n\\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), 0)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(\\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns number of set bits within a range by\\n    /// scanning `amount` of bits starting from the bit at `start`.\\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\\n        internal\\n        view\\n        returns (uint256 count)\\n    {\\n        unchecked {\\n            uint256 bucket = start >> 8;\\n            uint256 shift = start & 0xff;\\n            if (!(amount + shift < 257)) {\\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\\n                amount = (amount + shift) & 0xff;\\n                shift = 0;\\n                for (++bucket; bucket != bucketEnd; ++bucket) {\\n                    count += LibBit.popCount(bitmap.map[bucket]);\\n                }\\n            }\\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\\n        }\\n    }\\n\\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\\n    /// If no set bit is found, returns `NOT_FOUND`.\\n    function findLastSet(Bitmap storage bitmap, uint256 before)\\n        internal\\n        view\\n        returns (uint256 setBitIndex)\\n    {\\n        uint256 bucket;\\n        uint256 bucketBits;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            setBitIndex := not(0)\\n            bucket := shr(8, before)\\n            mstore(0x00, bucket)\\n            mstore(0x20, bitmap.slot)\\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\\n            if iszero(or(bucketBits, iszero(bucket))) {\\n                for {} 1 {} {\\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\\n                    mstore(0x00, bucket)\\n                    bucketBits := sload(keccak256(0x00, 0x40))\\n                    if or(bucketBits, iszero(bucket)) { break }\\n                }\\n            }\\n        }\\n        if (bucketBits != 0) {\\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\\n            }\\n        }\\n    }\\n}\\n\\ncontract ERCX is Context, ERC165, IERC1155, IERC1155MetadataURI, IERCX, IERC20Metadata, IERC20Errors, Ownable {\\n\\n    using Address for address;\\n    using LibBitmap for LibBitmap.Bitmap;\\n\\n    error InvalidQueryRange();\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // Mapping from accout to owned tokens\\n    mapping(address => LibBitmap.Bitmap) internal _owned;\\n    \\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // NFT Approval\\n    mapping(uint256 => address) public getApproved;\\n\\n    //Token balances\\n    mapping(address => uint256) internal _balances;\\n\\n    //Token allowances\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n    \\n    // Token name\\n    string public name;\\n\\n    // Token symbol\\n    string public symbol;\\n\\n    // Decimals for supply\\n    uint8 public immutable decimals;\\n\\n    // Total ERC20 supply\\n    uint256 public immutable totalSupply;\\n\\n    // Tokens Per NFT\\n    uint256 public immutable decimalFactor;\\n    uint256 public immutable tokensPerNFT;\\n\\n    // Don't mint for these wallets\\n    mapping(address => bool) public whitelist;\\n\\n    // Easy Launch - auto-whitelist first transfer which is probably the LP\\n    uint256 public easyLaunch = 10;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_, string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalNativeSupply, uint256 _tokensPerNFT) Ownable(msg.sender) {\\n        _setURI(uri_);\\n        _currentIndex = _startTokenId();\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        decimalFactor = 10 ** decimals;\\n        tokensPerNFT = _tokensPerNFT * decimalFactor;\\n        totalSupply = _totalNativeSupply * decimalFactor;\\n        whitelist[msg.sender] = false;\\n        _balances[msg.sender] = totalSupply;\\n        emit Transfer(address(0), msg.sender, totalSupply);\\n    }\\n\\n    /** @notice Initialization function to set pairs / etc\\n     *  saving gas by avoiding mint / burn on unnecessary targets\\n     */\\n    function setWhitelist(address target, bool state) public virtual onlyOwner {\\n        whitelist[target] = state;\\n    }\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal pure virtual returns (uint256) {\\n        return 1;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view returns (uint256) {\\n        return _nextTokenId() - _startTokenId();\\n    }\\n\\n    /**\\n     * @dev Returns true if the account owns the `id` token.\\n     */\\n    function isOwnerOf(address account, uint256 id) public view virtual override returns(bool) {\\n        return _owned[account].get(id);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            interfaceId == type(IERCX).interfaceId ||\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f || // ERC165 interface ID for ERC721Metadata.\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev Returns the number of tokens owned by `owner`.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Returns the number of nfts owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function balanceOf(address owner, uint256 start, uint256 stop) public view virtual returns (uint256) {\\n        return _owned[owner].popCount(start, stop - start);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        if(account == address(0)) {\\n            revert BalanceQueryForZeroAddress();\\n        }\\n        if(_owned[account].get(id)) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }   \\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        if(accounts.length != ids.length) {\\n            revert InputLengthMistmatch();\\n        }\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        if(from == _msgSender() || isApprovedForAll(from, _msgSender())){\\n            _safeTransferFrom(from, to, id, amount, data, true);\\n        } else {\\n            revert TransferCallerNotOwnerNorApproved();\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        if(!(from == _msgSender() || isApprovedForAll(from, _msgSender()))) {\\n            revert TransferCallerNotOwnerNorApproved();\\n        }\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `amount` cannot be zero.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data,\\n        bool check\\n    ) internal virtual {\\n        if(to == address(0)) {\\n            revert TransferToZeroAddress();\\n        }\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n\\n        _beforeTokenTransfer(operator, from, to, ids);\\n\\n        if(amount == 1 && _owned[from].get(id)) {\\n            _owned[from].unset(id);\\n            _owned[to].set(id);\\n            _transfer(from, to, tokensPerNFT, false);\\n        } else {\\n            revert TransferFromIncorrectOwnerOrInvalidAmount();\\n        }\\n\\n        uint256 toMasked;\\n        uint256 fromMasked;\\n        assembly {\\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            toMasked := and(to, _BITMASK_ADDRESS)\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\n            // Emit the `Transfer` event.\\n            log4(\\n                0, // Start of data (0, since no data).\\n                0, // End of data (0, since no data).\\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                fromMasked, // `from`.\\n                toMasked, // `to`.\\n                amount // `tokenId`.\\n            )\\n        }\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids);\\n\\n        if(check)\\n            _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if(ids.length != amounts.length) {\\n            revert InputLengthMistmatch();\\n        }\\n\\n        if(to == address(0)) {\\n            revert TransferToZeroAddress();\\n        }\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            if(amount == 1 && _owned[from].get(id)) {\\n                _owned[from].unset(id);\\n                _owned[to].set(id);\\n            } else {\\n                revert TransferFromIncorrectOwnerOrInvalidAmount();\\n            }\\n        }\\n        _transfer(from, to, tokensPerNFT * ids.length, false);\\n\\n        uint256 toMasked;\\n        uint256 fromMasked;\\n        uint256 end = ids.length + 1;\\n\\n        // Use assembly to loop and emit the `Transfer` event for gas savings.\\n        // The duplicated `log4` removes an extra check and reduces stack juggling.\\n        // The assembly, together with the surrounding Solidity code, have been\\n        // delicately arranged to nudge the compiler into producing optimized opcodes.\\n        assembly {\\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\n            toMasked := and(to, _BITMASK_ADDRESS)\\n            // Emit the `Transfer` event.\\n            log4(\\n                0, // Start of data (0, since no data).\\n                0, // End of data (0, since no data).\\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                fromMasked, // `from`.\\n                toMasked, // `to`.\\n                mload(add(ids, 0x20)) // `tokenId`.\\n            )\\n\\n            // The `iszero(eq(,))` check ensures that large values of `quantity`\\n            // that overflows uint256 will make the loop run out of gas.\\n            // The compiler will optimize the `iszero` away for performance.\\n            for {\\n                let arrayId := 2\\n            } iszero(eq(arrayId, end)) {\\n                arrayId := add(arrayId, 1)\\n            } {\\n                // Emit the `Transfer` event. Similar to above.\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, toMasked, mload(add(ids, mul(0x20, arrayId))))\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    function _mint(\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        _mint(to, amount, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens, and assigns them to `to`.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `amount` cannot be zero.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n       (uint256[] memory ids, uint256[] memory amounts) =  _mintWithoutCheck(to, amount);\\n\\n        uint256 end = _currentIndex;\\n        _doSafeBatchTransferAcceptanceCheck(_msgSender(), address(0), to, ids, amounts, data);\\n        if (_currentIndex != end) revert();\\n    }\\n\\n    function _mintWithoutCheck(\\n        address to,\\n        uint256 amount\\n    ) internal virtual returns(uint256[] memory ids, uint256[] memory amounts) {\\n\\n        if(to == address(0)) {\\n            revert MintToZeroAddress();\\n        }\\n        if(amount == 0) {\\n            revert MintZeroQuantity();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        ids = new uint256[](amount);\\n        amounts = new uint256[](amount);\\n        uint256 startTokenId = _nextTokenId();\\n\\n        unchecked {\\n            require(type(uint256).max - amount >= startTokenId);\\n            for(uint256 i = 0; i < amount; i++) {\\n                ids[i] = startTokenId + i;\\n                amounts[i] = 1;\\n            }\\n        }\\n        \\n        _beforeTokenTransfer(operator, address(0), to, ids);\\n\\n        _owned[to].setBatch(startTokenId, amount);\\n        _currentIndex += amount;\\n\\n        uint256 toMasked;\\n        uint256 end = startTokenId + amount;\\n\\n        assembly {\\n            toMasked := and(to, _BITMASK_ADDRESS)\\n            log4(\\n                0,\\n                0,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                0,\\n                toMasked,\\n                startTokenId\\n            )\\n\\n            for {\\n                let tokenId := add(startTokenId, 1)\\n            } iszero(eq(tokenId, end)) {\\n                tokenId := add(tokenId, 1)\\n            } {\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n            }\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids);\\n\\n    }\\n\\n    /**\\n     * @dev Destroys token of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have the token of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id\\n    ) internal virtual {\\n        if(from == address(0)){\\n            revert BurnFromZeroAddress();\\n        }\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids);\\n\\n        if(!_owned[from].get(id)) {\\n            revert BurnFromNonOnwerAddress();\\n        }\\n\\n        _owned[from].unset(id);\\n\\n        uint256 fromMasked;\\n        assembly {\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\n            log4(\\n                0,\\n                0,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                fromMasked,\\n                0,\\n                id\\n            )\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, 1);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids);\\n    }\\n\\n    /**\\n     * @dev Destroys tokens of token types in `ids` from `from`\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have the token of token types in `ids`.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids\\n    ) internal virtual {\\n        if(from == address(0)){\\n            revert BurnFromZeroAddress();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        uint256[] memory amounts = new uint256[](ids.length);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids);\\n\\n        unchecked {\\n            for(uint256 i = 0; i < ids.length; i++) {\\n                amounts[i] = 1;\\n                uint256 id = ids[i];\\n                if(!_owned[from].get(id)) {\\n                    revert BurnFromNonOnwerAddress();\\n                }\\n                _owned[from].unset(id);\\n            }\\n        }\\n\\n        uint256 fromMasked;\\n        uint256 end = ids.length + 1;\\n\\n        assembly {\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\n            log4(\\n                0,\\n                0,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                fromMasked,\\n                0,\\n                mload(add(ids, 0x20))\\n            )\\n\\n            for {\\n                let arrayId := 2\\n            } iszero(eq(arrayId, end)) {\\n                arrayId := add(arrayId, 1)\\n            } {\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, 0, mload(add(ids, mul(0x20, arrayId))))\\n            }\\n        }\\n        \\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids);\\n\\n    }\\n\\n    function _burnBatch(\\n        address from,\\n        uint256 amount\\n    ) internal virtual {\\n        if(from == address(0)){\\n            revert BurnFromZeroAddress();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        uint256 searchFrom = _nextTokenId();\\n\\n        uint256[] memory amounts = new uint256[](amount);\\n        uint256[] memory ids = new uint256[](amount);\\n\\n        unchecked {\\n            for(uint256 i = 0; i < amount; i++) {\\n                amounts[i] = 1;\\n                uint256 id = _owned[from].findLastSet(searchFrom);\\n                ids[i] = id;\\n                _owned[from].unset(id);\\n                searchFrom = id;\\n            }\\n        }\\n\\n        //technically after, but we didn't have the IDs then\\n        _beforeTokenTransfer(operator, from, address(0), ids);\\n\\n        uint256 fromMasked;\\n        uint256 end = amount + 1;\\n\\n        assembly {\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\n            log4(\\n                0,\\n                0,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                fromMasked,\\n                0,\\n                mload(add(ids, 0x20))\\n            )\\n\\n            for {\\n                let arrayId := 2\\n            } iszero(eq(arrayId, end)) {\\n                arrayId := add(arrayId, 1)\\n            } {\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, 0, mload(add(ids, mul(0x20, arrayId))))\\n            }\\n        }\\n\\n        if(amount == 1)\\n            emit TransferSingle(operator, from, address(0), ids[0], 1);\\n        else\\n            emit TransferBatch(operator, from, address(0), ids, amounts);\\n        \\n\\n        _afterTokenTransfer(operator, from, address(0), ids);\\n\\n    }\\n\\n\\n     /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            if (IERC165(to).supportsInterface(type(IERC1155).interfaceId)) {\\n                try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                    if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                        revert TransferToNonERC1155ReceiverImplementer();\\n                    }\\n                } catch Error(string memory reason) {\\n                    revert(reason);\\n                } catch {\\n                    revert TransferToNonERC1155ReceiverImplementer();\\n                }\\n            }\\n            else {\\n                try ERC721Receiver(to).onERC721Received(operator, from, id, data) returns (bytes4 response) {\\n                    if (response != ERC721Receiver.onERC721Received.selector) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } catch Error(string memory reason) {\\n                    revert(reason);\\n                } catch {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                }\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert TransferToNonERC1155ReceiverImplementer();\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert TransferToNonERC1155ReceiverImplementer();\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory array) {\\n        array = new uint256[](1);\\n        array[0] = element;\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = msg.sender;\\n        _transfer(owner, to, value, true);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = msg.sender;\\n        if (value < _nextTokenId() && value > 0) {\\n\\n            if(!isOwnerOf(owner, value)) {\\n                revert ERC20InvalidSender(owner);\\n            }\\n\\n            getApproved[value] = spender;\\n\\n            emit Approval(owner, spender, value);\\n        } else {\\n            _approve(owner, spender, value);\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Function for mixed transfers\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        if (value < _nextTokenId()) {\\n            if(!_owned[from].get(value)) {\\n                revert ERC20InvalidSpender(from);\\n            }    \\n\\n            if (\\n                msg.sender != from &&\\n                !isApprovedForAll(from, msg.sender) &&\\n                msg.sender != getApproved[value]\\n            ) {\\n                revert ERC20InvalidSpender(msg.sender);\\n            }\\n\\n            _transfer(from, to, tokensPerNFT, false);\\n\\n            delete getApproved[value];\\n\\n            _safeTransferFrom(from, to, value, 1, \\\"\\\", false);\\n\\n        } else {\\n            _spendAllowance(from, msg.sender, value);\\n            _transfer(from, to, value, true);\\n        }\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value, bool mint) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value, mint);\\n    }\\n\\n    function _update(address from, address to, uint256 value, bool mint) internal virtual {\\n        uint256 fromBalance = _balances[from];\\n        if (fromBalance < value) {\\n            revert ERC20InsufficientBalance(from, fromBalance, value);\\n        }\\n\\n        unchecked {\\n            // Overflow not possible: value <= fromBalance <= totalSupply.\\n            _balances[from] -=  value;\\n\\n            // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n            _balances[to] += value;\\n        }\\n        uint256 toBalance = _balances[to];\\n        emit Transfer(from, to, value);\\n\\n        if(mint) {\\n            // Skip burn for certain addresses to save gas\\n            bool wlf = whitelist[from];\\n            if (!wlf) {\\n                uint256 tokens_to_burn = (fromBalance / tokensPerNFT) - ((fromBalance - value) / tokensPerNFT);\\n                if(tokens_to_burn > 0)\\n                    _burnBatch(from, tokens_to_burn);\\n            }\\n\\n            // Skip minting for certain addresses to save gas\\n            if (!whitelist[to]) {\\n                if(easyLaunch == 1 && wlf && from == owner()) {\\n                    //auto-initialize first (assumed) LP\\n                    whitelist[to] = true;\\n                    easyLaunch = 2;\\n                } else {\\n                    uint256 tokens_to_mint = (toBalance  / tokensPerNFT) - ((toBalance - value) / tokensPerNFT);\\n                    if(tokens_to_mint > 0)\\n                        _mintWithoutCheck(to, tokens_to_mint);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC1155DelataQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) public view virtual returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            \\n            \\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            \\n            // Set `stop = min(stop, stopLimit)`.\\n            uint256 stopLimit = _nextTokenId();\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n\\n            uint256 tokenIdsLength;\\n            if(start < stop) {\\n                tokenIdsLength = balanceOf(owner, start, stop);\\n            } else {\\n                tokenIdsLength = 0;\\n            }\\n            \\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n\\n            LibBitmap.Bitmap storage bmap = _owned[owner];\\n            \\n            for ((uint256 i, uint256 tokenIdsIdx) = (start, 0); tokenIdsIdx != tokenIdsLength; ++i) {\\n                if(bmap.get(i) ) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC1155DeltaQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) public view virtual returns (uint256[] memory) {\\n        if(_totalMinted() == 0) {\\n            return new uint256[](0);\\n        }\\n        return tokensOfOwnerIn(owner, _startTokenId(), _nextTokenId());\\n    }\\n}\\n\\n\\ncontract ERC_X is ERCX {\\n    using Strings for uint256;\\n\\n    string public baseTokenURI;\\n    string public dataURI;\\n\\n    uint8 private constant _decimals = 18;\\n    uint256 private constant _totalTokens = 10000;\\n    uint256 private constant _tokensPerNFT = 1;\\n    string private constant _name = \\\"Gumball Machine\\\";\\n    string private constant _ticker = \\\"GUM\\\";\\n\\n    uint256 public maxWallet;\\n    bool public transferDelay = false;\\n    mapping (address => uint256) private delayTimer;\\n\\n    constructor() ERCX(\\\"\\\", _name, _ticker, _decimals, _totalTokens, _tokensPerNFT) {\\n        dataURI = \\\"https://brown-premier-mollusk-514.mypinata.cloud/ipfs/QmSvFBnE22Y29Ga6Ukjj4G6JnkrwcuZbQtgdmChheuEtv2\\\";\\n        maxWallet = (_totalTokens * 10 ** _decimals) * 100 / 100;\\n    }\\n\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids\\n    ) internal override {\\n        if(!whitelist[to]) {\\n            require(_balances[to] <= maxWallet, \\\"Transfer exceeds maximum wallet\\\");\\n            if (transferDelay) {\\n                require(delayTimer[tx.origin] < block.number,\\\"Only one transfer per block allowed.\\\");\\n                delayTimer[tx.origin] = block.number;\\n\\n                require(address(to).code.length == 0 && address(tx.origin).code.length == 0, \\\"Contract trading restricted at launch\\\");\\n            }\\n        }\\n        \\n        super._afterTokenTransfer(operator, from, to, ids);\\n    }\\n\\n    function setDataURI(string memory _dataURI) public onlyOwner {\\n        dataURI = _dataURI;\\n    }\\n\\n    function toggleDelay() external onlyOwner {\\n        transferDelay = !transferDelay;\\n    }\\n\\n    function setMaxWallet(uint256 percent) external onlyOwner {\\n        maxWallet = totalSupply * percent / 100;\\n    }\\n\\n\\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\\n        baseTokenURI = _tokenURI;\\n    }\\n\\n    function setURI(string memory newuri) external onlyOwner {\\n        _setURI(newuri);\\n    }\\n\\n    \\n\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n    function tokenURI(uint256 id) public view returns (string memory) {\\n\\n            return\\n                string.concat(\\n                    \\\"data:application/json;utf8,\\\",\\n                string(\\n                    abi.encodePacked(\\n                        '{ \\\"name\\\": \\\"Gumball #',\\n                        uint2str(id),\\n                        '\\\",\\\"image\\\" : \\\"',\\n                        dataURI,\\n                        ' \\\",\\\"external_url\\\": \\\"gumball.gg\\\",\\\"description\\\":\\\"Use this token to claim your gumball.\\\"',\\n                        \\\"}\\\"\\n                    )\\n                )\\n            );\\n        \\n    }\\n    function uri(uint256 id) public view override returns (string memory) {\\n        return tokenURI(id);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"TokenB.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gumballID\",\"type\":\"uint256\"}],\"name\":\"GumballActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gumballID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gumballType\",\"type\":\"uint256\"}],\"name\":\"GumballInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gumballID\",\"type\":\"uint256\"}],\"name\":\"GumballMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gumballID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningsPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"GumballResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_gumballID\",\"type\":\"uint256[]\"}],\"name\":\"activateGumball\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorizedResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_coinID\",\"type\":\"uint256[]\"}],\"name\":\"claimGumball\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_gumballID\",\"type\":\"uint256[]\"}],\"name\":\"claimStaticGumballs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gumballType\",\"type\":\"uint256\"}],\"name\":\"getAttributeData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"getBalanceOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gumballType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rolledNumber\",\"type\":\"uint256\"}],\"name\":\"getWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"giveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballActivatedBy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gumballCoinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballState\",\"outputs\":[{\"internalType\":\"enum Gumball.GumballState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballTypeStaticWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballTypeToDropTable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballTypeToDropTableSlotOdds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gumballTypeToDropTableSlotWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imageURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_gumballID\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_seedsList\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_typesList\",\"type\":\"uint256[]\"}],\"name\":\"initializeGumball\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_gumballID\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_seedsList\",\"type\":\"bytes32[]\"}],\"name\":\"resolveGumball\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setGumballAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"name\":\"setImageUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setNewAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gumballType\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_winningsOdds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_winningsAmount\",\"type\":\"uint256[]\"}],\"name\":\"updateGumballTable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_gumballType\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_winningsAmount\",\"type\":\"uint256[]\"}],\"name\":\"updateTypeStaticWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_types\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tableIds\",\"type\":\"uint256[]\"}],\"name\":\"updateTypeToTable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_coinID\",\"type\":\"uint256[]\"}],\"name\":\"withdrawGumballs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawamount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Gumball", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}