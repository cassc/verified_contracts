{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/AaveCLRobotOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAaveCLRobotOperator} from '../interfaces/IAaveCLRobotOperator.sol';\\nimport {IInitializableRobotOperator} from '../interfaces/IInitializableRobotOperator.sol';\\nimport {IKeeperRegistrar} from '../interfaces/IKeeperRegistrar.sol';\\nimport {IKeeperRegistry} from '../interfaces/IKeeperRegistry.sol';\\nimport {IERC20} from 'solidity-utils/contracts/oz-common/interfaces/IERC20.sol';\\nimport {SafeERC20} from 'solidity-utils/contracts/oz-common/SafeERC20.sol';\\nimport {OwnableWithGuardian} from 'solidity-utils/contracts/access-control/OwnableWithGuardian.sol';\\nimport {Initializable} from 'solidity-utils/contracts/transparent-proxy/Initializable.sol';\\nimport {EnumerableSet} from 'solidity-utils/contracts/oz-common/EnumerableSet.sol';\\n\\n/**\\n * @title AaveCLRobotOperator\\n * @author BGD Labs\\n * @dev Operator contract to perform admin actions on the automation keepers.\\n *      The contract can register keepers, cancel it, pause it, withdraw excess link,\\n *      refill the keeper, configure the keeper.\\n */\\ncontract AaveCLRobotOperator is OwnableWithGuardian, Initializable, IAaveCLRobotOperator {\\n  using SafeERC20 for IERC20;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n\\n  // stores the keepers registered which are not in cancelled state by the operator contract.\\n  EnumerableSet.UintSet internal _keepers;\\n\\n  mapping(uint256 id => KeeperInfo) internal _keepersInfo;\\n\\n  address internal _keeperRegistry;\\n  address internal _keeperRegistrar;\\n  address internal _linkToken;\\n  address internal _linkWithdrawAddress;\\n\\n  /// @inheritdoc IInitializableRobotOperator\\n  function initialize(\\n    address keeperRegistry,\\n    address keeperRegistrar,\\n    address linkWithdrawAddress,\\n    address operatorOwner,\\n    address operatorGuardian\\n  ) external initializer {\\n    _keeperRegistry = keeperRegistry;\\n    _keeperRegistrar = keeperRegistrar;\\n    _linkWithdrawAddress = linkWithdrawAddress;\\n    _linkToken = IKeeperRegistry(_keeperRegistry).getLinkAddress();\\n    _transferOwnership(operatorOwner);\\n    _updateGuardian(operatorGuardian);\\n    emit Initialized(keeperRegistry, keeperRegistrar, linkWithdrawAddress, operatorOwner, operatorGuardian);\\n  }\\n\\n  /// @notice In order to fund the keeper we need to approve the Link token amount to this contract\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function register(\\n    string memory name,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    uint96 amountToFund,\\n    uint8 triggerType,\\n    bytes memory triggerConfig\\n  ) external onlyOwner returns (uint256) {\\n    IERC20(_linkToken).safeTransferFrom(msg.sender, address(this), amountToFund);\\n\\n    IKeeperRegistrar.RegistrationParams memory params = IKeeperRegistrar.RegistrationParams({\\n      name: name, // name of the keeper to register\\n      encryptedEmail: '', // encryptedEmail to send alerts to, unused\\n      upkeepContract: upkeepContract, // address of the upkeep contract\\n      gasLimit: gasLimit, // max gasLimit which can be used for an performUpkeep action\\n      adminAddress: address(this), // admin of the keeper is set to this address of AaveCLRobotOperator\\n      triggerType: triggerType, // 0 for conditional type keeper, 1 for log type\\n      checkData: '', // checkData of the keeper which get passed to the checkUpkeep, unused\\n      triggerConfig: triggerConfig, // configuration for log type keeper, else unused\\n      offchainConfig: '', // unused\\n      amount: amountToFund // amount of link to fund the keeper with\\n    });\\n\\n    IERC20(_linkToken).forceApprove(_keeperRegistrar, amountToFund);\\n    uint256 id = IKeeperRegistrar(_keeperRegistrar).registerUpkeep(params);\\n\\n    if (id != 0) {\\n      _keepersInfo[id].upkeep = upkeepContract;\\n      _keepersInfo[id].name = name;\\n      _keepers.add(id);\\n\\n      emit KeeperRegistered(id, upkeepContract, amountToFund);\\n\\n      return id;\\n    } else {\\n      revert('AUTO_APPROVE_DISABLED');\\n    }\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function cancel(uint256 id) external onlyOwner {\\n    IKeeperRegistry(_keeperRegistry).cancelUpkeep(id);\\n    _keepers.remove(id);\\n\\n    emit KeeperCancelled(id, _keepersInfo[id].upkeep);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function withdrawLink(uint256 id) external {\\n    IKeeperRegistry(_keeperRegistry).withdrawFunds(id, _linkWithdrawAddress);\\n    emit LinkWithdrawn(id, _keepersInfo[id].upkeep, _linkWithdrawAddress);\\n  }\\n\\n  /// @notice In order to refill the keeper we need to approve the Link token amount to this contract\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function refillKeeper(uint256 id, uint96 amount) external {\\n    IERC20(_linkToken).safeTransferFrom(msg.sender, address(this), amount);\\n    IERC20(_linkToken).forceApprove(_keeperRegistry, amount);\\n    IKeeperRegistry(_keeperRegistry).addFunds(id, amount);\\n    emit KeeperRefilled(id, msg.sender, amount);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function pause(uint256 id) external onlyOwnerOrGuardian {\\n    IKeeperRegistry(_keeperRegistry).pauseUpkeep(id);\\n    emit KeeperPaused(id);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function unpause(uint256 id) external onlyOwnerOrGuardian {\\n    IKeeperRegistry(_keeperRegistry).unpauseUpkeep(id);\\n    emit KeeperUnpaused(id);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function migrate(address newRegistry, address newRegistrar) external onlyOwner {\\n    IKeeperRegistry(_keeperRegistry).migrateUpkeeps(_keepers.values(), newRegistry);\\n\\n    setRegistry(newRegistry);\\n    setRegistrar(newRegistrar);\\n    emit KeepersMigrated(_keepers.values(), newRegistry, newRegistrar);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setGasLimit(uint256 id, uint32 gasLimit) external onlyOwnerOrGuardian {\\n    IKeeperRegistry(_keeperRegistry).setUpkeepGasLimit(id, gasLimit);\\n    emit GasLimitSet(id, _keepersInfo[id].upkeep, gasLimit);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setTriggerConfig(uint256 id, bytes calldata triggerConfig) external onlyOwnerOrGuardian {\\n    IKeeperRegistry(_keeperRegistry).setUpkeepTriggerConfig(id, triggerConfig);\\n    emit TriggerConfigSet(id);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setWithdrawAddress(address withdrawAddress) external onlyOwner {\\n    _linkWithdrawAddress = withdrawAddress;\\n    emit WithdrawAddressSet(withdrawAddress);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setRegistry(address newRegistry) public onlyOwner {\\n    _keeperRegistry = newRegistry;\\n    emit KeeperRegistrySet(newRegistry);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setRegistrar(address newRegistrar) public onlyOwner {\\n    _keeperRegistrar = newRegistrar;\\n    emit KeeperRegistrarSet(newRegistrar);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getWithdrawAddress() external view returns (address) {\\n    return _linkWithdrawAddress;\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getKeeperInfo(uint256 id) external view returns (KeeperInfo memory) {\\n    return _keepersInfo[id];\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function isPaused(uint256 id) external view returns (bool) {\\n    return IKeeperRegistry(_keeperRegistry).getUpkeep(id).paused;\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getRegistry() public view returns (address) {\\n    return _keeperRegistry;\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getRegistrar() public view returns (address) {\\n    return _keeperRegistrar;\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getKeepersList() public view returns (uint256[] memory) {\\n    return _keepers.values();\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getLinkToken() external view returns (address) {\\n    return _linkToken;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAaveCLRobotOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IInitializableRobotOperator} from './IInitializableRobotOperator.sol';\\n\\n/**\\n * @title IAaveCLRobotOperator\\n * @author BGD Labs\\n * @notice Defines the interface for the robot operator contract to perform admin actions on the automation keepers.\\n **/\\ninterface IAaveCLRobotOperator is IInitializableRobotOperator {\\n  /**\\n   * @dev Emitted when a keeper is registered using the operator contract.\\n   * @param id id of the keeper registered.\\n   * @param upkeep address of the keeper contract.\\n   * @param amount amount of link the keeper has been registered with.\\n   */\\n  event KeeperRegistered(uint256 indexed id, address indexed upkeep, uint96 indexed amount);\\n\\n  /**\\n   * @dev Emitted when a keeper is cancelled using the operator contract.\\n   * @param id id of the keeper cancelled.\\n   * @param upkeep address of the keeper contract.\\n   */\\n  event KeeperCancelled(uint256 indexed id, address indexed upkeep);\\n\\n  /**\\n   * @dev Emitted when a keeper is already cancelled, and link is being withdrawn using the operator contract.\\n   * @param id id of the keeper to withdraw link from.\\n   * @param upkeep address of the keeper contract.\\n   * @param to address where link needs to be withdrawn to.\\n   */\\n  event LinkWithdrawn(uint256 indexed id, address indexed upkeep, address indexed to);\\n\\n  /**\\n   * @dev Emitted when a keeper is refilled using the operator contract.\\n   * @param id id of the keeper which has been refilled.\\n   * @param from address which refilled the keeper.\\n   * @param amount amount of link which has been refilled for the keeper.\\n   */\\n  event KeeperRefilled(uint256 indexed id, address indexed from, uint96 indexed amount);\\n\\n  /**\\n   * @dev Emitted when a keeper is paused using the operator contract.\\n   * @param id id of the keeper which has been paused.\\n   */\\n  event KeeperPaused(uint256 indexed id);\\n\\n  /**\\n   * @dev Emitted when a keeper is unpaused using the operator contract.\\n   * @param id id of the keeper which has been unpaused.\\n   */\\n  event KeeperUnpaused(uint256 indexed id);\\n\\n  /**\\n   * @dev Emitted when the link withdraw address has been changed of the keeper.\\n   * @param newWithdrawAddress address of the new withdraw address where link will be withdrawn to.\\n   */\\n  event WithdrawAddressSet(address indexed newWithdrawAddress);\\n\\n  /**\\n   * @dev Emitted when gas limit is configured using the operator contract.\\n   * @param id id of the keeper for which gas limit has been configured.\\n   * @param upkeep address of the keeper contract.\\n   * @param gasLimit max gas limit which has been configured for the keeper.\\n   */\\n  event GasLimitSet(uint256 indexed id, address indexed upkeep, uint32 indexed gasLimit);\\n\\n  /**\\n   * @dev Emitted when trigger config is configured for a log type robot using the operator contract.\\n   * @param id id of the keeper for which trigger config has been configured.\\n   */\\n  event TriggerConfigSet(uint256 indexed id);\\n\\n  /**\\n   * @dev Emitted when a new chainlink keeper registry is set on the operator contract.\\n   * @param newKeeperRegistry address of the new chainlink keeper registry contract.\\n   */\\n  event KeeperRegistrySet(address indexed newKeeperRegistry);\\n\\n  /**\\n   * @dev Emitted when a new chainlink keeper registrar is set on the operator contract.\\n   * @param newKeeperRegistrar address of the new chainlink keeper registrar contract.\\n   */\\n  event KeeperRegistrarSet(address indexed newKeeperRegistrar);\\n\\n  /**\\n   * @dev Emitted when a the keepers are migrated to a new chainlink keeper registry contract.\\n   * @param ids array of ids all the chainlink keepers to migrate.\\n   * @param newKeeperRegistry address of the new chainlink keeper registry contract to migrate to.\\n   * @param newKeeperRegistrar address of the new chainlink keeper registrar contract associated with the registry.\\n   */\\n  event KeepersMigrated(\\n    uint256[] indexed ids,\\n    address indexed newKeeperRegistry,\\n    address indexed newKeeperRegistrar\\n  );\\n\\n  /**\\n   * @notice holds the keeper info registered via the operator.\\n   * @param upkeep address of the keeper contract registered.\\n   * @param name name of the registered keeper.\\n   */\\n  struct KeeperInfo {\\n    address upkeep;\\n    string name;\\n  }\\n\\n  /**\\n   * @notice method called by owner to register the automation robot keeper.\\n   * @param name name of keeper.\\n   * @param upkeepContract upkeepContract of the keeper.\\n   * @param gasLimit max gasLimit which the chainlink automation node can execute for the automation.\\n   * @param amountToFund amount of link to fund the keeper with.\\n   * @param triggerType type of robot keeper to register, 0 for conditional and 1 for event log based.\\n   * @param triggerConfig encoded trigger config for event log based robots, unused for conditional type robots.\\n   * @return chainlink id for the registered keeper.\\n   **/\\n  function register(\\n    string memory name,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    uint96 amountToFund,\\n    uint8 triggerType,\\n    bytes memory triggerConfig\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice method called to refill the keeper.\\n   * @param id - id of the chainlink registered keeper to refill.\\n   * @param amount - amount of LINK to refill the keeper with.\\n   **/\\n  function refillKeeper(uint256 id, uint96 amount) external;\\n\\n  /**\\n   * @notice method called by the owner to cancel the automation robot keeper.\\n   * @param id - id of the chainlink registered keeper to cancel.\\n   **/\\n  function cancel(uint256 id) external;\\n\\n  /**\\n   * @notice method called permissionlessly to withdraw link of automation robot keeper to the withdraw address.\\n   *         this method should only be called after the automation robot keeper is cancelled.\\n   * @param id - id of the chainlink registered keeper to withdraw funds of.\\n   **/\\n  function withdrawLink(uint256 id) external;\\n\\n  /**\\n   * @notice method called by the owner to migrate the keepers to a newer version of chainlink automation.\\n   * @param newRegistry address of the new chainlink registry to migrate the keepers to.\\n   * @param newRegistrar address of the new associated chainlink registrar of the new registry.\\n   **/\\n  function migrate(address newRegistry, address newRegistrar) external;\\n\\n  /**\\n   * @notice method called by owner / robot guardian to pause the upkeep robot keeper.\\n   * @param id - id of the chainlink registered keeper to pause.\\n   **/\\n  function pause(uint256 id) external;\\n\\n  /**\\n   * @notice method called by owner / robot guardian to unpause the upkeep robot keeper.\\n   * @param id - id of the chainlink registered keeper to unpause.\\n   **/\\n  function unpause(uint256 id) external;\\n\\n  /**\\n   * @notice method to check if the keeper is paused or not.\\n   * @param id - id of the chainlink registered keeper to check.\\n   * @return true if the keeper is paused, false otherwise.\\n   **/\\n  function isPaused(uint256 id) external returns (bool);\\n\\n  /**\\n   * @notice method called by owner / robot guardian to set the max gasLimit of upkeep robot keeper.\\n   * @param id - id of the chainlink registered keeper to set the gasLimit.\\n   * @param gasLimit max gasLimit which the chainlink automation node can execute.\\n   **/\\n  function setGasLimit(uint256 id, uint32 gasLimit) external;\\n\\n  /**\\n   * @notice method called by owner to set the withdraw address when withdrawing excess link from the automation robot keeeper.\\n   * @param withdrawAddress withdraw address to withdaw link to.\\n   **/\\n  function setWithdrawAddress(address withdrawAddress) external;\\n\\n  /**\\n   * @notice method called by owner / guardian to set the trigger configuration for event log type robots.\\n   * @param id - id of the chainlink registered keeper to set the trigger config.\\n   * @param triggerConfig encoded data containing the configuration\\n   *        Ex:\\n   *        abi.encode(\\n   *          address contractAddress, (address that will be emitting the log)\\n   *          uint8 filterSelector, (denoting which topics apply to filter ex 000, 101, 111...only last 3 bits apply)\\n   *          bytes32 topic0, (signature of the emitted event)\\n   *          bytes32 topic1, (filter on indexed topic 1)\\n   *          bytes32 topic2, (filter on indexed topic 2)\\n   *          bytes32 topic3 (filter on indexed topic 3)\\n   *        );\\n   **/\\n  function setTriggerConfig(uint256 id, bytes calldata triggerConfig) external;\\n\\n  /**\\n   * @notice method called by owner to set the address of chainlink keeper registry contract.\\n   * @param newRegistry address of the new chainlink keeper registry contract to set.\\n   */\\n  function setRegistry(address newRegistry) external;\\n\\n  /**\\n   * @notice method called by owner to set the address of chainlink keeper registrar contract.\\n   * @param newRegistrar address of the new chainlink keeper registrar contract to set.\\n   */\\n  function setRegistrar(address newRegistrar) external;\\n\\n  /**\\n   * @notice method to get the withdraw address for the robot operator contract.\\n   * @return withdraw address to send excess link to.\\n   **/\\n  function getWithdrawAddress() external view returns (address);\\n\\n  /**\\n   * @notice method to get the keeper information registered via the operator.\\n   * @param id - id of the chainlink registered keeper.\\n   * @return Struct containing the following information about the keeper:\\n   *         - uint256 chainlink id of the registered keeper.\\n   *         - string name of the registered keeper.\\n   **/\\n  function getKeeperInfo(uint256 id) external view returns (KeeperInfo memory);\\n\\n  /**\\n   * @notice method to get the address of chainlink keeper registry contract.\\n   * @return keeper registry address.\\n   */\\n  function getRegistry() external returns (address);\\n\\n  /**\\n   * @notice method to get the address of chainlink keeper registrar contract.\\n   * @return keeper registrar address.\\n   */\\n  function getRegistrar() external returns (address);\\n\\n  /**\\n   * @notice method to get the address of ERC-677 link token.\\n   * @return link token address.\\n   */\\n  function getLinkToken() external returns (address);\\n\\n  /**\\n   * @notice method to get of all the ids of keepers registered by the robot operator which have not been cancelled.\\n   * @return array of registered keeper ids.\\n   */\\n  function getKeepersList() external returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IInitializableRobotOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IInitializableRobotOperator\\n * @author BGD Labs\\n * @notice Interface for the initialize function on AaveCLRobotOperator\\n **/\\ninterface IInitializableRobotOperator {\\n  /**\\n   * @dev Emitted when a AaveCLRobotOperator is initialized\\n   * @param keeperRegistry address of the chainlink registry.\\n   * @param keeperRegistrar address of the chainlink registrar.\\n   * @param linkWithdrawAddress withdrawal address of the operator contract.\\n   * @param operatorOwner owner of the operator contract.\\n   * @param operatorGuardian guardian of the operator contract.\\n   **/\\n  event Initialized(\\n    address keeperRegistry,\\n    address keeperRegistrar,\\n    address linkWithdrawAddress,\\n    address operatorOwner,\\n    address operatorGuardian\\n  );\\n\\n  /**\\n   * @dev Initializes the AaveCLRobotOperator\\n   * @param keeperRegistry address of the chainlink registry.\\n   * @param keeperRegistrar address of the chainlink registrar.\\n   * @param linkWithdrawAddress withdrawal address to send the exccess link after cancelling the keeper.\\n   * @param operatorOwner address to set as the owner of the operator contract.\\n   * @param operatorGuardian address to set as the guardian of the operator contract.\\n   */\\n  function initialize(\\n    address keeperRegistry,\\n    address keeperRegistrar,\\n    address linkWithdrawAddress,\\n    address operatorOwner,\\n    address operatorGuardian\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKeeperRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IKeeperRegistrar {\\n  struct RegistrationParams {\\n    string name;\\n    bytes encryptedEmail;\\n    address upkeepContract;\\n    uint32 gasLimit;\\n    address adminAddress;\\n    uint8 triggerType;\\n    bytes checkData;\\n    bytes triggerConfig;\\n    bytes offchainConfig;\\n    uint96 amount;\\n  }\\n\\n  /**\\n   * DISABLED: No auto approvals, all new upkeeps should be approved manually.\\n   * ENABLED_SENDER_ALLOWLIST: Auto approvals for allowed senders subject to max allowed. Manual for rest.\\n   * ENABLED_ALL: Auto approvals for all new upkeeps subject to max allowed.\\n   */\\n  enum AutoApproveType {\\n    DISABLED,\\n    ENABLED_SENDER_ALLOWLIST,\\n    ENABLED_ALL\\n  }\\n\\n  function setTriggerConfig(\\n    uint8 triggerType,\\n    AutoApproveType autoApproveType,\\n    uint32 autoApproveMaxAllowed\\n  ) external;\\n\\n  function setAutoApproveAllowedSender(address senderAddress, bool allowed) external;\\n\\n  function registerUpkeep(RegistrationParams calldata requestParams) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKeeperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IKeeperRegistry {\\n  struct OnchainConfig {\\n    uint32 paymentPremiumPPB;\\n    uint32 flatFeeMicroLink;\\n    uint32 checkGasLimit;\\n    uint24 stalenessSeconds;\\n    uint16 gasCeilingMultiplier;\\n    uint96 minUpkeepSpend;\\n    uint32 maxPerformGas;\\n    uint32 maxCheckDataSize;\\n    uint32 maxPerformDataSize;\\n    uint32 maxRevertDataSize;\\n    uint256 fallbackGasPrice;\\n    uint256 fallbackLinkPrice;\\n    address transcoder;\\n    address[] registrars;\\n    address upkeepPrivilegeManager;\\n  }\\n\\n  struct State {\\n    uint32 nonce;\\n    uint96 ownerLinkBalance;\\n    uint256 expectedLinkBalance;\\n    uint96 totalPremium;\\n    uint256 numUpkeeps;\\n    uint32 configCount;\\n    uint32 latestConfigBlockNumber;\\n    bytes32 latestConfigDigest;\\n    uint32 latestEpoch;\\n    bool paused;\\n  }\\n\\n  struct UpkeepInfo {\\n    address target;\\n    uint32 performGas;\\n    bytes checkData;\\n    uint96 balance;\\n    address admin;\\n    uint64 maxValidBlocknumber;\\n    uint32 lastPerformedBlockNumber;\\n    uint96 amountSpent;\\n    bool paused;\\n    bytes offchainConfig;\\n  }\\n\\n  function addFunds(uint256 id, uint96 amount) external;\\n\\n  function cancelUpkeep(uint256 id) external;\\n\\n  function registerUpkeep(\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    uint8 triggerType,\\n    bytes memory checkData,\\n    bytes memory triggerConfig,\\n    bytes memory offchainConfig\\n  ) external returns (uint256 id);\\n\\n  function registerUpkeep(\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    bytes memory checkData,\\n    bytes memory offchainConfig\\n  ) external returns (uint256 id);\\n\\n  function setUpkeepTriggerConfig(uint256 id, bytes memory triggerConfig) external;\\n\\n  function getBalance(uint256 id) external view returns (uint96 balance);\\n\\n  function getForwarder(uint256 upkeepID) external view returns (address);\\n\\n  function getLinkAddress() external view returns (address);\\n\\n  function getState()\\n    external\\n    view\\n    returns (\\n      State memory state,\\n      OnchainConfig memory config,\\n      address[] memory signers,\\n      address[] memory transmitters,\\n      uint8 f\\n    );\\n\\n  function getTriggerType(uint256 upkeepId) external pure returns (uint8);\\n\\n  function getUpkeep(uint256 id) external view returns (UpkeepInfo memory upkeepInfo);\\n\\n  function getUpkeepTriggerConfig(uint256 upkeepId) external view returns (bytes memory);\\n\\n  function pauseUpkeep(uint256 id) external;\\n\\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\\n\\n  function unpauseUpkeep(uint256 id) external;\\n\\n  function upkeepVersion() external pure returns (uint8);\\n\\n  function withdrawFunds(uint256 id, address to) external;\\n\\n  function migrateUpkeeps(uint256[] calldata upkeepIDs, address destination) external;\\n\\n  function transferUpkeepAdmin(uint256 id, address proposed) external;\\n\\n  function acceptUpkeepAdmin(uint256 id) external;\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/a035b235b4f2c9af4ba88edc4447f02e37f8d124\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n// Modified From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/00cbf5a236564c3b7aacdad1f378cae22d890ca6\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"./interfaces/IERC20Permit.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  /**\\n   * @dev An operation with an ERC20 token failed.\\n     */\\n  error SafeERC20FailedOperation(address token);\\n\\n  /**\\n   * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n  error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n  }\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n  }\\n\\n  /**\\n   * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    forceApprove(token, spender, oldAllowance + value);\\n  }\\n\\n  /**\\n   * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n    unchecked {\\n      uint256 currentAllowance = token.allowance(address(this), spender);\\n      if (currentAllowance < requestedDecrease) {\\n        revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n      }\\n      forceApprove(token, spender, currentAllowance - requestedDecrease);\\n    }\\n  }\\n\\n  /**\\n   * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n  function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n    bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n    if (!_callOptionalReturnBool(token, approvalCall)) {\\n      _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n      _callOptionalReturn(token, approvalCall);\\n    }\\n  }\\n\\n  /**\\n   * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    if (nonceAfter != nonceBefore + 1) {\\n      revert SafeERC20FailedOperation(address(token));\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data);\\n    if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n      revert SafeERC20FailedOperation(address(token));\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n  function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n    // and not revert is the subcall reverts.\\n\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/access-control/OwnableWithGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\nimport {IWithGuardian} from './interfaces/IWithGuardian.sol';\\nimport {Ownable} from '../oz-common/Ownable.sol';\\n\\nabstract contract OwnableWithGuardian is Ownable, IWithGuardian {\\n  address private _guardian;\\n\\n  constructor() {\\n    _updateGuardian(_msgSender());\\n  }\\n\\n  modifier onlyGuardian() {\\n    _checkGuardian();\\n    _;\\n  }\\n\\n  modifier onlyOwnerOrGuardian() {\\n    _checkOwnerOrGuardian();\\n    _;\\n  }\\n\\n  function guardian() public view override returns (address) {\\n    return _guardian;\\n  }\\n\\n  /// @inheritdoc IWithGuardian\\n  function updateGuardian(address newGuardian) external override onlyOwnerOrGuardian {\\n    _updateGuardian(newGuardian);\\n  }\\n\\n  /**\\n   * @dev method to update the guardian\\n   * @param newGuardian the new guardian address\\n   */\\n  function _updateGuardian(address newGuardian) internal {\\n    address oldGuardian = _guardian;\\n    _guardian = newGuardian;\\n    emit GuardianUpdated(oldGuardian, newGuardian);\\n  }\\n\\n  function _checkGuardian() internal view {\\n    require(guardian() == _msgSender(), 'ONLY_BY_GUARDIAN');\\n  }\\n\\n  function _checkOwnerOrGuardian() internal view {\\n    require(_msgSender() == owner() || _msgSender() == guardian(), 'ONLY_BY_OWNER_OR_GUARDIAN');\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/transparent-proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n * @dev OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\\n *\\n * BGD Labs adaptations:\\n * - Added a constructor disabling initialization for implementation contracts\\n * - Linting\\n */\\n\\npragma solidity ^0.8.2;\\n\\nimport '../oz-common/Address.sol';\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   * @custom:oz-retyped-from bool\\n   */\\n  uint8 private _initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private _initializing;\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n   */\\n  event Initialized(uint8 version);\\n\\n  /**\\n   * @dev OPINIONATED. Generally is not a good practise to allow initialization of implementations\\n   */\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n   */\\n  modifier initializer() {\\n    bool isTopLevelCall = !_initializing;\\n    require(\\n      (isTopLevelCall && _initialized < 1) ||\\n        (!Address.isContract(address(this)) && _initialized == 1),\\n      'Initializable: contract is already initialized'\\n    );\\n    _initialized = 1;\\n    if (isTopLevelCall) {\\n      _initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      _initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n   * used to initialize parent contracts.\\n   *\\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\\n   * initialization.\\n   *\\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n   * a contract, executing them in the right order is up to the developer or operator.\\n   */\\n  modifier reinitializer(uint8 version) {\\n    require(\\n      !_initializing && _initialized < version,\\n      'Initializable: contract is already initialized'\\n    );\\n    _initialized = version;\\n    _initializing = true;\\n    _;\\n    _initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n   */\\n  modifier onlyInitializing() {\\n    require(_initializing, 'Initializable: contract is not initializing');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n   * through proxies.\\n   */\\n  function _disableInitializers() internal virtual {\\n    require(!_initializing, 'Initializable: contract is initializing');\\n    if (_initialized < type(uint8).max) {\\n      _initialized = type(uint8).max;\\n      emit Initialized(type(uint8).max);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/54b3f14346da01ba0d159114b399197fea8b7cda\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position of the value in the `values` array, plus 1 because index 0\\n    // means a value is not in the set.\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We read and store the value's index to prevent multiple reads from the same storage slot\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (lastIndex != toDeleteIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the last value to the index where the value to delete is\\n        set._values[toDeleteIndex] = lastValue;\\n        // Update the index for the moved value\\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the index for the deleted slot\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/commit/00cbf5a236564c3b7aacdad1f378cae22d890ca6\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, 'Address: low-level call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data\\n  ) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n   *\\n   * _Available since v4.8._\\n   */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), 'Address: call to non-contract');\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason or using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/access-control/interfaces/IWithGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface IWithGuardian {\\n  /**\\n   * @dev Event emitted when guardian gets updated\\n   * @param oldGuardian address of previous guardian\\n   * @param newGuardian address of the new guardian\\n   */\\n  event GuardianUpdated(address oldGuardian, address newGuardian);\\n\\n  /**\\n   * @dev get guardian address;\\n   */\\n  function guardian() external view returns (address);\\n\\n  /**\\n   * @dev method to update the guardian\\n   * @param newGuardian the new guardian address\\n   */\\n  function updateGuardian(address newGuardian) external;\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\\n\\npragma solidity ^0.8.0;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"chainlink/=lib/chainlink/contracts/\",\r\n      \"openzeppelin-contracts/=lib/aave-governance-v3/lib/openzeppelin-contracts/\",\r\n      \"aave-governance-v3/=lib/aave-governance-v3/\",\r\n      \"aave-address-book/=lib/aave-address-book/src/\",\r\n      \"aave-delivery-infrastructure/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/src/\",\r\n      \"solidity-utils/=lib/solidity-utils/src/\",\r\n      \"aave-token-v3/=lib/aave-governance-v3/lib/aave-token-v3/src/\",\r\n      \"aave-helpers/=lib/aave-helpers/src/\",\r\n      \"@aave/core-v3/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"@aave/periphery-v3/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"@openzeppelin/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/lib/openzeppelin-contracts/\",\r\n      \"aave-delivery-infrastructure-scripts/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/scripts/\",\r\n      \"aave-token-v2/=lib/aave-governance-v3/lib/aave-token-v3/lib/aave-token-v2/contracts/\",\r\n      \"aave-v3-core/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"aave-v3-periphery/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/aave-governance-v3/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"fx-portal/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/lib/fx-portal/contracts/\",\r\n      \"governance-crosschain-bridges/=lib/aave-helpers/lib/governance-crosschain-bridges/\",\r\n      \"hyperlane-monorepo/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/lib/hyperlane-monorepo/\",\r\n      \"nitro-contracts/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/lib/nitro-contracts/src/\",\r\n      \"openzeppelin/=lib/aave-governance-v3/lib/openzeppelin-contracts/contracts/\",\r\n      \"solidity-examples/=lib/aave-governance-v3/lib/aave-delivery-infrastructure/lib/solidity-examples/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"GasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGuardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"GuardianUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeperRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeperRegistrar\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"linkWithdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operatorOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operatorGuardian\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"}],\"name\":\"KeeperCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"KeeperPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"KeeperRefilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"KeeperRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newKeeperRegistrar\",\"type\":\"address\"}],\"name\":\"KeeperRegistrarSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newKeeperRegistry\",\"type\":\"address\"}],\"name\":\"KeeperRegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"KeeperUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newKeeperRegistry\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newKeeperRegistrar\",\"type\":\"address\"}],\"name\":\"KeepersMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LinkWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TriggerConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWithdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getKeeperInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct IAaveCLRobotOperator.KeeperInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeepersList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLinkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeperRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeperRegistrar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkWithdrawAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operatorOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operatorGuardian\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newRegistrar\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"refillKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"upkeepContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"amountToFund\",\"type\":\"uint96\"},{\"internalType\":\"uint8\",\"name\":\"triggerType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"triggerConfig\",\"type\":\"bytes\"}],\"name\":\"register\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistrar\",\"type\":\"address\"}],\"name\":\"setRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"triggerConfig\",\"type\":\"bytes\"}],\"name\":\"setTriggerConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"updateGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AaveCLRobotOperator", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}