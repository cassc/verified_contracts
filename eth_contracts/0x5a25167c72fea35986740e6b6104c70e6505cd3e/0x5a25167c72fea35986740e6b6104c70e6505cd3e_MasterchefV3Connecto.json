{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/connectors/MasterchefV3Connector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721Enumerable.sol\\\";\\nimport \\\"../interfaces/IFarmConnector.sol\\\";\\nimport \\\"../interfaces/ILiquidityConnector.sol\\\";\\nimport \\\"../interfaces/external/uniswap/INonfungiblePositionManager.sol\\\";\\nimport \\\"../interfaces/external/IMasterchefV3.sol\\\";\\n\\nstruct MasterchefV3ExtraData {\\n    uint256 tokenId;\\n    bool isIncrease;\\n    uint128 maxAmount0;\\n    uint128 maxAmount1;\\n}\\n\\ncontract MasterchefV3Connector is IFarmConnector, ILiquidityConnector {\\n    error SickleNftBalanceError(); //0x50a182e0\\n\\n    function deposit(\\n        address target,\\n        address token,\\n        bytes memory extraData\\n    ) external payable override {\\n        // MasterchefV3 deposits use onERC721Received\\n        MasterchefV3ExtraData memory data =\\n            abi.decode(extraData, (MasterchefV3ExtraData));\\n\\n        if (!data.isIncrease) {\\n            if (IERC721(token).balanceOf(address(this)) != 1) {\\n                revert SickleNftBalanceError();\\n            }\\n            uint256 tokenId =\\n                IERC721Enumerable(token).tokenOfOwnerByIndex(address(this), 0);\\n\\n            IERC721(token)\\n                // only deposit if its not a IncreaseLiquidity\\n                .safeTransferFrom(address(this), target, tokenId);\\n        }\\n    }\\n\\n    function withdraw(\\n        address target,\\n        uint256, // amount\\n        bytes memory extraData\\n    ) external override {\\n        MasterchefV3ExtraData memory data =\\n            abi.decode(extraData, (MasterchefV3ExtraData));\\n        IMasterchefV3(target).withdraw(data.tokenId, address(this));\\n    }\\n\\n    function claim(address target, bytes memory extraData) external override {\\n        MasterchefV3ExtraData memory data =\\n            abi.decode(extraData, (MasterchefV3ExtraData));\\n        IMasterchefV3(target).harvest(data.tokenId, address(this));\\n        if (data.maxAmount0 > 0 || data.maxAmount1 > 0) {\\n            INonfungiblePositionManager.CollectParams memory params =\\n            INonfungiblePositionManager.CollectParams({\\n                tokenId: data.tokenId,\\n                recipient: address(this),\\n                amount0Max: data.maxAmount0,\\n                amount1Max: data.maxAmount1\\n            });\\n            INonfungiblePositionManager(target).collect(params);\\n        }\\n    }\\n\\n    function addLiquidity(AddLiquidityData memory addLiquidityData)\\n        external\\n        payable\\n        override\\n    {\\n        MasterchefV3ExtraData memory extraData =\\n            abi.decode(addLiquidityData.extraData, (MasterchefV3ExtraData));\\n\\n        INonfungiblePositionManager.IncreaseLiquidityParams memory params =\\n        INonfungiblePositionManager.IncreaseLiquidityParams({\\n            tokenId: extraData.tokenId,\\n            amount0Desired: addLiquidityData.desiredAmounts[0],\\n            amount1Desired: addLiquidityData.desiredAmounts[1],\\n            amount0Min: addLiquidityData.minAmounts[0],\\n            amount1Min: addLiquidityData.minAmounts[1],\\n            deadline: block.timestamp + 1\\n        });\\n\\n        INonfungiblePositionManager(addLiquidityData.router).increaseLiquidity(\\n            params\\n        );\\n    }\\n\\n    function removeLiquidity(RemoveLiquidityData memory)\\n        external\\n        pure\\n        override\\n    {\\n        revert(\\\"MasterchefV3 does not support removing liquidity\\\");\\n    }\\n\\n    function swapExactTokensForTokens(SwapData memory)\\n        external\\n        payable\\n        override\\n    {\\n        revert(\\\"MasterchefV3 does not support swapping\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\"\r\n    },\r\n    \"contracts/interfaces/IFarmConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IFarmConnector {\\n    function deposit(\\n        address target,\\n        address token,\\n        bytes memory extraData\\n    ) external payable;\\n\\n    function withdraw(\\n        address target,\\n        uint256 amount,\\n        bytes memory extraData\\n    ) external;\\n\\n    function claim(address target, bytes memory extraData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct AddLiquidityData {\\n    address router;\\n    address lpToken;\\n    address[] tokens;\\n    uint256[] desiredAmounts;\\n    uint256[] minAmounts;\\n    bytes extraData;\\n}\\n\\nstruct RemoveLiquidityData {\\n    address router;\\n    address lpToken;\\n    address[] tokens;\\n    uint256 lpAmountIn;\\n    uint256[] minAmountsOut;\\n    bytes extraData;\\n}\\n\\nstruct SwapData {\\n    address router;\\n    uint256 amountIn;\\n    uint256 minAmountOut;\\n    address tokenIn;\\n    bytes extraData;\\n}\\n\\ninterface ILiquidityConnector {\\n    function addLiquidity(AddLiquidityData memory addLiquidityData)\\n        external\\n        payable;\\n\\n    function removeLiquidity(RemoveLiquidityData memory removeLiquidityData)\\n        external;\\n\\n    function swapExactTokensForTokens(SwapData memory swapData)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/uniswap/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface INonfungiblePositionManager {\\n    struct IncreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    struct DecreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint128 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    struct CollectParams {\\n        uint256 tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function increaseLiquidity(IncreaseLiquidityParams memory params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1, uint256 liquidity);\\n\\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function mint(MintParams memory params)\\n        external\\n        payable\\n        returns (uint256 tokenId, uint256 amount0, uint256 amount1);\\n\\n    function collect(CollectParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function burn(uint256 tokenId) external payable;\\n\\n    function positions(uint256 tokenId)\\n        external\\n        view\\n        returns (\\n            uint96 nonce,\\n            address operator,\\n            address token0,\\n            address token1,\\n            uint24 fee,\\n            int24 tickLower,\\n            int24 tickUpper,\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IMasterchefV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMasterchefV3 {\\n    function harvest(\\n        uint256 _tokenId,\\n        address _to\\n    ) external returns (uint256 reward);\\n    function withdraw(\\n        uint256 _tokenId,\\n        address _to\\n    ) external returns (uint256 reward);\\n    function pendingCake(uint256 _tokenId)\\n        external\\n        view\\n        returns (uint256 reward);\\n    function nonfungiblePositionManager() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"SickleNftBalanceError\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"desiredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AddLiquidityData\",\"name\":\"addLiquidityData\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lpAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct RemoveLiquidityData\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapData\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MasterchefV3Connector", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}