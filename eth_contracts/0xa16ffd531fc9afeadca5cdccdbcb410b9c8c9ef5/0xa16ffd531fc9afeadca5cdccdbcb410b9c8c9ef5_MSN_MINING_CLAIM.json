{"SourceCode": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: contracts/MSN_MINING_CLAIM.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract MSN_MINING_CLAIM {\r\n    address public msn_contract_address;\r\n    uint256 public mining_claim_base;\r\n\r\n    //mining\r\n    address public miner_signer;\r\n    uint256 public mining_start_timestamp;\r\n    uint256 public miner_total_claimed; //total tokens claimed by all miners in the past\r\n    mapping(uint256 => uint256) private mining_sig_amount_map; // mining claim signature id => amount\r\n\r\n    //sum(claim rate)*1000 for mining in each year\r\n    uint256[10] public mining_claim_years_limit = [\r\n        50,\r\n        95,\r\n        135,\r\n        170,\r\n        200,\r\n        225,\r\n        245,\r\n        260,\r\n        270,\r\n        275\r\n    ];\r\n\r\n    address public contract_owner;\r\n    modifier onlyContractOwner() {\r\n        require(msg.sender == contract_owner, \"Only contractOwner\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _msn_contract_addr,\r\n        uint256 _mining_claim_base,\r\n        uint256 _mining_start_time\r\n    ) {\r\n        msn_contract_address = _msn_contract_addr;\r\n        mining_claim_base = _mining_claim_base;\r\n        contract_owner = msg.sender;\r\n        mining_start_timestamp = _mining_start_time;\r\n    }\r\n\r\n    function check_amount_from_signature(uint256 sig_id)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return mining_sig_amount_map[sig_id];\r\n    }\r\n\r\n    function transfer_msn_to_owner(uint256 amount) public onlyContractOwner {\r\n        bool result = IERC20(msn_contract_address).transfer(\r\n            contract_owner,\r\n            amount\r\n        );\r\n        require(result == true, \"transfer error\");\r\n    }\r\n\r\n    // sum of all the tokens can be claimed currently\r\n    function mining_claim_limit() public view returns (uint256) {\r\n        uint256 past_years_num = past_years();\r\n        uint256 past_days_num = past_days();\r\n\r\n        /////////past years total limit //////////////\r\n        uint256 past_years_claim_limit = 0;\r\n        if (past_years_num == 0) {\r\n            //keeps past_years_claim_limit 0\r\n        } else if (past_years_num < 10)\r\n            past_years_claim_limit =\r\n                (mining_claim_years_limit[past_years_num - 1] *\r\n                    mining_claim_base) /\r\n                1000;\r\n        else {\r\n            past_years_claim_limit =\r\n                (mining_claim_years_limit[9] * mining_claim_base) /\r\n                1000;\r\n        }\r\n\r\n        /////////this year total limit /////////////////////\r\n        uint256 claim_ratio_this_year = 0;\r\n        if (past_years_num == 0) {\r\n            claim_ratio_this_year = mining_claim_years_limit[past_years_num];\r\n        } else if (past_years_num < 10) {\r\n            claim_ratio_this_year =\r\n                mining_claim_years_limit[past_years_num] -\r\n                mining_claim_years_limit[past_years_num - 1];\r\n        } else {\r\n            //keeps claim_ratio_this_year 0\r\n        }\r\n\r\n        uint256 this_year_claim_limit = ((past_days_num +\r\n            1 -\r\n            365 *\r\n            past_years_num) *\r\n            mining_claim_base *\r\n            claim_ratio_this_year) /\r\n            365 /\r\n            1000;\r\n\r\n        ///////////////////////////////////////////////////\r\n        return past_years_claim_limit + this_year_claim_limit;\r\n    }\r\n\r\n    event Set_miner_signer_log(address addr);\r\n\r\n    function set_miner_signer(address _new_signer) external onlyContractOwner {\r\n        require(address(_new_signer) != address(0)); \r\n        miner_signer = _new_signer;\r\n        emit Set_miner_signer_log(_new_signer);\r\n    }\r\n\r\n    /**\r\n     * Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n     * @dev Recover signer address from a message by using his signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory sig)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        //Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    function check_claim_sig(\r\n        uint256 sig_id,\r\n        uint256 amount,\r\n        bytes memory sig\r\n    ) private view {\r\n        bytes32 hash = keccak256(abi.encodePacked(sig_id, msg.sender, amount));\r\n        address msg_signer = recover(hash, sig);\r\n        require(msg_signer == miner_signer, \"signature error\");\r\n    }\r\n\r\n    function miner_claim(\r\n        uint256 signature_id,\r\n        uint256 amount,\r\n        bytes memory signature\r\n    ) public {\r\n        require(amount > 0, \"claim amount should be bigger then 0\");\r\n\r\n        require(mining_sig_amount_map[signature_id] == 0, \"repeated claim\");\r\n        mining_sig_amount_map[signature_id] = amount;\r\n\r\n        uint256 after_add = miner_total_claimed + amount;\r\n        require(after_add <= mining_claim_limit(), \"mining over limit\");\r\n        miner_total_claimed = after_add;\r\n\r\n        check_claim_sig(signature_id, amount, signature);\r\n\r\n        //transfer\r\n        bool result = IERC20(msn_contract_address).transfer(msg.sender, amount);\r\n        require(result == true, \"transfer error\");\r\n    }\r\n\r\n    function forbid_claim(uint256 signature_id) public onlyContractOwner {\r\n        require(mining_sig_amount_map[signature_id] == 0, \"already claimed\");\r\n        mining_sig_amount_map[signature_id] = 1;\r\n    }\r\n\r\n\r\n    //how many years passed since initial deployed\r\n    function past_years() public view returns (uint256) {\r\n        return (block.timestamp - mining_start_timestamp) / 365 days;\r\n    }\r\n\r\n    //how many days passed since initial deployed\r\n    function past_days() public view returns (uint256) {\r\n        return (block.timestamp - mining_start_timestamp) / 1 days;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msn_contract_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mining_claim_base\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mining_start_time\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Set_miner_signer_log\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sig_id\",\"type\":\"uint256\"}],\"name\":\"check_amount_from_signature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contract_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"signature_id\",\"type\":\"uint256\"}],\"name\":\"forbid_claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"signature_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"miner_claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miner_signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miner_total_claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mining_claim_base\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mining_claim_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mining_claim_years_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mining_start_timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msn_contract_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"past_days\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"past_years\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_signer\",\"type\":\"address\"}],\"name\":\"set_miner_signer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer_msn_to_owner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MSN_MINING_CLAIM", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000aa247c0d81b83812e1abf8bab078e4540d87e3fb00000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000000000000000000000000000000000000065d7f14a", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://06d4017afb91b4327b5d8ccc04140b52fbaf19eb87570c86a5696f2b4121dd49"}