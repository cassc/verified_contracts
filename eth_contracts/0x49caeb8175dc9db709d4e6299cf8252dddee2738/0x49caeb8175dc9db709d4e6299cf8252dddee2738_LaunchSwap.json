{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/IEthrunes.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IEthrunes is IERC1155 {\r\n\r\n  function transfer(\r\n    address to,\r\n    uint256 id,\r\n    uint256 amount,\r\n    bytes memory data\r\n  ) external payable;\r\n\r\n  function batchTransfer(\r\n    address to,\r\n    uint256[] memory ids,\r\n    uint256[] memory amounts,\r\n    bytes memory data\r\n  ) external payable;\r\n\r\n  function deploy2(\r\n    string calldata tick,\r\n    uint8 decimals,\r\n    uint256 supply,\r\n    address to\r\n  ) external payable;\r\n\r\n  function tokens(uint160 _id) external view returns(\r\n    uint160 id,\r\n    uint8 decimals,\r\n    uint256 supply,\r\n    uint256 limit,\r\n    string memory tick\r\n  );\r\n\r\n  function totalSupply(uint256 id) external view returns (uint256);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.8.1\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/TransferHelper.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/LaunchSwap.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\n\r\ncontract LaunchSwap is ReentrancyGuard, ERC1155Receiver {\r\n  error InvalidSender();\r\n  error InvalidCall();\r\n  error NotSupportBatchReceivedCallback();\r\n  error PoolAlreadyCreated();\r\n  error ExceedLimitPerBuy();\r\n  error ExceedLimitPerSell();\r\n  error InsufficientAmountOut();\r\n  error InsufficientAmountIn();\r\n  error LessThanAmountOutMin();\r\n  error Expired();\r\n  error InitialPriceTooLow();\r\n  error InvalidTotalSupply();\r\n  error TotalSupplyMustBeEven();\r\n  error ZeroAmountIn();\r\n  error InvalidRecipient();\r\n  error InvalidFeeRate();\r\n\r\n  struct Pool {\r\n    uint256 reserve0;\r\n    uint256 reserve1;\r\n    uint256 halfReserve;\r\n    uint256 price;\r\n    uint256 limitPerBuy;\r\n    uint256 limitPerSell;\r\n    uint256 fee;\r\n    address creator;\r\n    uint256 creatorFees;\r\n  }\r\n\r\n  uint256 public accProtocolFees;\r\n  uint16 public protocolFee = 20; // 20% for creator and service\r\n  address public ethrunes;\r\n  address feeRecipient;\r\n  address dev;\r\n\r\n  mapping (uint160 => Pool) public pools;\r\n  mapping (uint256 => bool) public feeTiers;\r\n  \r\n\r\n  event CreatePool(address indexed creator, uint160 indexed id, uint256 amount, uint256 price, uint256 fee);\r\n  event Buy(uint160 indexed id, uint256 amountInEth, uint256 amountOut);\r\n  event Sell(uint160 indexed id, uint256 amountIn, uint256 amountOutEth);\r\n\r\n  constructor(address _ethrunes, address _feeRecipient) {\r\n    ethrunes = _ethrunes;\r\n    feeRecipient = _feeRecipient;\r\n    dev = msg.sender;\r\n    feeTiers[300] = true;\r\n    feeTiers[200] = true;\r\n    feeTiers[100] = true;\r\n    feeTiers[50] = true;\r\n    feeTiers[30] = true;\r\n  }\r\n\r\n  modifier checkDeadline(uint256 deadline) {\r\n    if(deadline < block.timestamp) revert Expired();\r\n    _;\r\n  }\r\n\r\n  function _createPool(\r\n    uint160 id,\r\n    uint256 amount,\r\n    uint256 price,\r\n    uint256 limitPerBuy,\r\n    uint256 limitPerSell,\r\n    uint256 fee,\r\n    address creator\r\n  ) internal {\r\n    Pool storage pool = pools[id];\r\n    if(pool.reserve1 != 0) revert PoolAlreadyCreated();\r\n    uint256 supply = IEthrunes(ethrunes).totalSupply(id);\r\n    if(amount != supply) revert InvalidTotalSupply();\r\n    if(!feeTiers[fee]) revert InvalidFeeRate();\r\n    if(amount / 2 * 2 != amount) revert TotalSupplyMustBeEven();\r\n\r\n    pool.reserve0 = 0;\r\n    pool.reserve1 = amount;\r\n    pool.halfReserve = amount / 2;\r\n    pool.price = price;\r\n    pool.limitPerBuy = limitPerBuy;\r\n    pool.limitPerSell = limitPerSell;\r\n    pool.fee = fee;\r\n    pool.creator = creator;\r\n\r\n    if(pool.halfReserve * pool.price / 1e18 == 0) revert InitialPriceTooLow();\r\n\r\n    emit CreatePool(creator, id, amount, price, fee);\r\n  }\r\n\r\n\r\n  function buy(\r\n    uint160 id, \r\n    uint256 amountOut, \r\n    uint256 deadline,\r\n    address recipient\r\n  ) external payable checkDeadline(deadline) nonReentrant returns(uint256) {\r\n    if(msg.value == 0) revert ZeroAmountIn();\r\n    Pool storage pool = pools[id];\r\n    if(pool.limitPerBuy > 0 && amountOut > pool.limitPerBuy) revert ExceedLimitPerBuy();\r\n    if(amountOut >= pool.reserve1) revert InsufficientAmountOut();\r\n\r\n    uint256 buyAmount;\r\n    uint256 swapAmount;\r\n\r\n    if(pool.reserve1 > pool.halfReserve) {\r\n      uint256 maxBuyAmount = pool.reserve1 - pool.halfReserve;\r\n      if(maxBuyAmount >= amountOut) {\r\n        buyAmount = amountOut;\r\n      } else {\r\n        swapAmount = amountOut - maxBuyAmount;\r\n        buyAmount = maxBuyAmount;\r\n      }\r\n    } else {\r\n      swapAmount = amountOut;\r\n    }\r\n\r\n    uint256 amountIn;\r\n\r\n    if(buyAmount > 0) {\r\n      amountIn = pool.price * buyAmount / 1e18;\r\n      pool.reserve0 += amountIn;\r\n      pool.reserve1 -= buyAmount;\r\n    }\r\n\r\n    if(swapAmount > 0) {\r\n      if(swapAmount >= pool.reserve1) revert InsufficientAmountOut();\r\n\r\n      uint256 numerator =  swapAmount * pool.reserve0;\r\n      uint256 denominator = pool.reserve1 - swapAmount;\r\n\r\n      uint256 swapAmountIn = numerator / denominator + 1;\r\n\r\n      uint256 feeAmount = swapAmountIn * pool.fee / 10000;\r\n\r\n      uint256 _protocolFees = feeAmount * protocolFee / 100;\r\n      uint256 _creatorFee = _protocolFees * 75 / 100;\r\n      uint256 providerFees = feeAmount - _protocolFees;\r\n\r\n      accProtocolFees += (_protocolFees - _creatorFee);\r\n\r\n      pool.creatorFees += _creatorFee;\r\n      pool.reserve0 += swapAmountIn;\r\n      pool.reserve1 -= swapAmount;\r\n      pool.price += (providerFees * 1e18 / pool.halfReserve);\r\n\r\n      amountIn += (swapAmountIn + feeAmount);\r\n    }\r\n\r\n    if(msg.value < amountIn) revert InsufficientAmountIn();\r\n\r\n    bytes memory data;\r\n    if(recipient == address(0x0) || recipient == msg.sender) {\r\n      recipient = msg.sender;\r\n    } else {\r\n      data = abi.encode(msg.sender);\r\n    }\r\n    IEthrunes(ethrunes).transfer(recipient, id, amountOut, data);\r\n\r\n    uint256 refund = msg.value - amountIn;\r\n\r\n    // refund\r\n    if(refund > 0) {\r\n      TransferHelper.safeTransferETH(msg.sender, refund);\r\n    }\r\n\r\n    emit Buy(id, amountIn, amountOut);\r\n\r\n    return amountIn;\r\n  }\r\n\r\n  function _sell(\r\n    uint160 id, \r\n    address to,\r\n    uint256 amountIn, \r\n    uint256 amountOutMin, \r\n    uint256 deadline\r\n  ) internal checkDeadline(deadline) nonReentrant {\r\n    Pool storage pool = pools[id];\r\n    if(to == address(0x0)) revert InvalidRecipient();\r\n    if(amountIn == 0) revert ZeroAmountIn();\r\n\r\n    if(pool.limitPerSell > 0 && amountIn > pool.limitPerSell) revert ExceedLimitPerSell();\r\n\r\n    uint256 sellAmount;\r\n    uint256 swapAmount;\r\n\r\n    if(pool.reserve1 >= pool.halfReserve) {\r\n      sellAmount = amountIn;\r\n    } else {\r\n      uint256 maxSwapAmount = pool.halfReserve - pool.reserve1;\r\n      if(maxSwapAmount >= amountIn) {\r\n        swapAmount = amountIn;\r\n      } else {\r\n        swapAmount = maxSwapAmount;\r\n        sellAmount = amountIn - maxSwapAmount;\r\n      }\r\n    }\r\n\r\n    uint256 amountOut;\r\n    if(swapAmount > 0) {\r\n      uint256 numerator =  swapAmount * pool.reserve0;\r\n      uint256 denominator = pool.reserve1 + swapAmount;\r\n      amountOut = numerator / denominator - 1;\r\n\r\n      uint256 feeAmount = amountOut * pool.fee / 10000;\r\n\r\n      uint256 _protocolFees = feeAmount * protocolFee / 100;\r\n      uint256 _creatorFee = _protocolFees * 75 / 100;\r\n\r\n      uint256 providerFees = feeAmount - _protocolFees;\r\n\r\n      accProtocolFees += (_protocolFees - _creatorFee);\r\n\r\n      pool.creatorFees += _creatorFee;\r\n      pool.reserve0 -= amountOut;\r\n      pool.reserve1 += swapAmount;\r\n\r\n      pool.price += providerFees * 1e18 / pool.halfReserve;\r\n\r\n      amountOut -= feeAmount;\r\n    }\r\n\r\n    if(pool.reserve1 == pool.halfReserve) {\r\n      pool.reserve0 = pool.price * pool.halfReserve / 1e18;\r\n    }\r\n\r\n    if(sellAmount > 0) {\r\n      uint256 sellValue = sellAmount * pool.price / 1e18;\r\n      pool.reserve0 -= sellValue;\r\n      pool.reserve1 += sellAmount;\r\n      amountOut += sellValue;\r\n    }\r\n\r\n    if(amountOut < amountOutMin) revert LessThanAmountOutMin();\r\n\r\n    TransferHelper.safeTransferETH(to, amountOut);\r\n\r\n    emit Sell(id, amountIn, amountOut);\r\n  }\r\n\r\n\r\n  function setFeeRecipient(address _feeRecipient) external {\r\n    require(msg.sender == dev);\r\n    feeRecipient = _feeRecipient;\r\n  }\r\n\r\n  function setFeeTier(uint256 tier, bool b) external {\r\n    require(tier <= 1000);\r\n    require(msg.sender == dev);\r\n    feeTiers[tier] = b;\r\n  }\r\n\r\n  function withdrawProtocolFees() external nonReentrant {\r\n    uint256 fees = accProtocolFees;\r\n    accProtocolFees = 0;\r\n    TransferHelper.safeTransferETH(feeRecipient, fees);\r\n  }\r\n\r\n  function withdrawCreatorFees(uint160 id) external nonReentrant {\r\n    Pool storage pool = pools[id];\r\n    uint256 fees = pool.creatorFees;\r\n    pool.creatorFees = 0;\r\n    TransferHelper.safeTransferETH(pool.creator, fees);\r\n  }\r\n\r\n  function onERC1155Received(\r\n    address operator,\r\n    address from,\r\n    uint256 id,\r\n    uint256 amount,\r\n    bytes calldata data\r\n  ) public override returns (bytes4) {\r\n    if(msg.sender != ethrunes) revert InvalidSender();\r\n    uint8 command = uint8(data[0]);\r\n    // sell\r\n    if(command == 1) {\r\n      address recipient;\r\n      uint256 amountOutMin;\r\n      uint256 deadline;\r\n      assembly {\r\n        recipient := calldataload(add(data.offset, 0x1))\r\n        amountOutMin := calldataload(add(data.offset, 0x21))\r\n        deadline := calldataload(add(data.offset, 0x41))\r\n      }\r\n      _sell(uint160(id), recipient, amount, amountOutMin, deadline);\r\n\r\n    } else if(command == 2) { // createPool\r\n      uint256 price;\r\n      uint256 limitPerBuy;\r\n      uint256 limitPerSell;\r\n      uint256 fee;\r\n      address creator;\r\n      assembly {\r\n        price := calldataload(add(data.offset, 0x1))\r\n        limitPerBuy := calldataload(add(data.offset, 0x21))\r\n        limitPerSell := calldataload(add(data.offset, 0x41))\r\n        fee := calldataload(add(data.offset, 0x61))\r\n        creator := calldataload(add(data.offset, 0x81))\r\n      }\r\n\r\n      _createPool(\r\n        uint160(id), \r\n        amount,\r\n        price,\r\n        limitPerBuy,\r\n        limitPerSell,\r\n        fee,\r\n        creator\r\n      );\r\n    } else {\r\n      revert InvalidCall();\r\n    }\r\n\r\n    return this.onERC1155Received.selector;\r\n  }\r\n\r\n  function onERC1155BatchReceived(\r\n    address,\r\n    address,\r\n    uint256[] calldata,\r\n    uint256[] calldata,\r\n    bytes calldata\r\n  ) public override returns (bytes4) {\r\n    revert NotSupportBatchReceivedCallback();\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ethrunes\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExceedLimitPerBuy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedLimitPerSell\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialPriceTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAmountIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAmountOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFeeRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTotalSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LessThanAmountOutMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSupportBatchReceivedCallback\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyMustBeEven\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmountIn\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint160\",\"name\":\"id\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint160\",\"name\":\"id\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"CreatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint160\",\"name\":\"id\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOutEth\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accProtocolFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"id\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethrunes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeTiers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"halfReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitPerBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitPerSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"creatorFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tier\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setFeeTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"id\",\"type\":\"uint160\"}],\"name\":\"withdrawCreatorFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LaunchSwap", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000326490a8f5dcaeaa4a2ad9ea902990c5b0834d9b000000000000000000000000830b7791fbfa34ac8eaadd15e1f74b702c8af0eb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eef08eb6b3bf291e804fbcd4ddd750b960133476104574bcfc704efad99a325d"}