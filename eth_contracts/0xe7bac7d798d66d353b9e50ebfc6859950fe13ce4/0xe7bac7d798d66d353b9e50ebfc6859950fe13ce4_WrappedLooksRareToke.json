{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/WrappedLooksRareToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {LowLevelERC20Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\\\";\\nimport {ITransferManager} from \\\"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC4626} from \\\"@openzeppelin/contracts/interfaces/IERC4626.sol\\\";\\n\\nimport {IStakingRewards} from \\\"./interfaces/IStakingRewards.sol\\\";\\n\\n/**\\n * @title WrappedLooksRareToken\\n * @notice WrappedLooksRareToken is a LOOKS wrapper that is used for staking and auto-compounding.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract WrappedLooksRareToken is ERC20, LowLevelERC20Transfer {\\n    /**\\n     * @notice The cooldown period for unwrap requests.\\n     */\\n    uint256 public constant UNWRAP_REQUEST_COOLDOWN = 1 weeks;\\n\\n    /**\\n     * @notice The amount after fee for instant unwrap in basis points.\\n     */\\n    uint256 public constant INSTANT_UNWRAP_AMOUNT_AFTER_FEE_IN_BASIS_POINTS = 9_500;\\n\\n    /**\\n     * @notice The LOOKS token address.\\n     */\\n    address public immutable LOOKS;\\n\\n    /**\\n     * @notice The transfer manager to handle LOOKS approvals and transfers.\\n     */\\n    ITransferManager public immutable TRANSFER_MANAGER;\\n\\n    /**\\n     * @dev The deployer of the contract. Only used for initialization.\\n     */\\n    address private immutable DEPLOYER;\\n\\n    /**\\n     * @notice A unwrap request.\\n     * @param amount The amount of LOOKS to unwrap.\\n     * @param timestamp The timestamp of the unwrap request.\\n     */\\n    struct UnwrapRequest {\\n        uint216 amount;\\n        uint40 timestamp;\\n    }\\n\\n    mapping(address requester => UnwrapRequest) public unwrapRequests;\\n\\n    /**\\n     * @notice The staking rewards contract.\\n     */\\n    IStakingRewards public stakingRewards;\\n\\n    /**\\n     * @notice The auto-compounder contract.\\n     */\\n    IERC4626 public autoCompounder;\\n\\n    /**\\n     * @notice Whether the contract has been initialized. Initialize cannot be called twice.\\n     */\\n    bool private initialized;\\n\\n    event Wrapped(address indexed wrapper, uint256 amount);\\n    event Initialized(address _stakingRewards, address _autoCompounder);\\n    event Staked(address indexed staker, uint256 amount);\\n    event AutoCompounded(address indexed staker, uint256 amount);\\n    event UnwrapRequestSubmitted(address indexed requester, uint256 amount);\\n    event UnwrapRequestCancelled(address indexed requester, uint256 amount);\\n    event UnwrapRequestCompleted(address indexed requester, uint256 amount);\\n    event InstantUnwrap(address indexed requester, uint256 amount);\\n\\n    error WrappedLooksRareToken__AlreadyInitialized();\\n    error WrappedLooksRareToken__InsufficientBalance();\\n    error WrappedLooksRareToken__InvalidAddress();\\n    error WrappedLooksRareToken__NoUnwrapRequest();\\n    error WrappedLooksRareToken__OngoingUnwrapRequest();\\n    error WrappedLooksRareToken__TooEarlyToCompleteUnwrapRequest();\\n    error WrappedLooksRareToken__Unauthorized();\\n\\n    /**\\n     * @param looks LooksRare token\\n     * @param transferManager Transfer manager\\n     */\\n    constructor(address looks, address transferManager) ERC20(\\\"Wrapped LooksRare Token\\\", \\\"wLOOKS\\\") {\\n        LOOKS = looks;\\n        TRANSFER_MANAGER = ITransferManager(transferManager);\\n        DEPLOYER = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Set staking rewards and auto-compounder. Can only be called once.\\n     * @param _stakingRewards Staking rewards\\n     * @param _autoCompounder Auto-compounder\\n     */\\n    function initialize(address _stakingRewards, address _autoCompounder) external {\\n        if (msg.sender != DEPLOYER) {\\n            revert WrappedLooksRareToken__Unauthorized();\\n        }\\n\\n        if (initialized) {\\n            revert WrappedLooksRareToken__AlreadyInitialized();\\n        }\\n\\n        initialized = true;\\n\\n        stakingRewards = IStakingRewards(_stakingRewards);\\n        autoCompounder = IERC4626(_autoCompounder);\\n\\n        emit Initialized(_stakingRewards, _autoCompounder);\\n    }\\n\\n    /**\\n     * @notice Wrap LOOKS to receive wLOOKS\\n     * @param amount Wrap amount\\n     */\\n    function wrap(uint256 amount) external {\\n        TRANSFER_MANAGER.transferERC20(LOOKS, msg.sender, address(this), amount);\\n        _mint(msg.sender, amount);\\n\\n        emit Wrapped(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Wrap LOOKS and deposit wLOOKS straight into StakingRewards\\n     * @param amount Wrap amount\\n     */\\n    function wrapAndStake(uint256 amount) external {\\n        TRANSFER_MANAGER.transferERC20(LOOKS, msg.sender, address(this), amount);\\n        _mint(address(this), amount);\\n        _approve(address(this), address(stakingRewards), amount);\\n        stakingRewards.stakeOnBehalf(amount, msg.sender);\\n\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Wrap LOOKS and deposit wLOOKS straight into AutoCompounder\\n     * @param amount Wrap amount\\n     */\\n    function wrapAndAutoCompound(uint256 amount) external {\\n        TRANSFER_MANAGER.transferERC20(LOOKS, msg.sender, address(this), amount);\\n        _mint(address(this), amount);\\n        _approve(address(this), address(autoCompounder), amount);\\n        autoCompounder.deposit(amount, msg.sender);\\n\\n        emit AutoCompounded(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Submit unwrap request\\n     * @param amount Unwrap amount\\n     */\\n    function submitUnwrapRequest(uint216 amount) external {\\n        if (balanceOf(msg.sender) < amount) {\\n            revert WrappedLooksRareToken__InsufficientBalance();\\n        }\\n\\n        if (unwrapRequests[msg.sender].timestamp != 0) {\\n            revert WrappedLooksRareToken__OngoingUnwrapRequest();\\n        }\\n\\n        _burn(msg.sender, amount);\\n\\n        unwrapRequests[msg.sender] = UnwrapRequest({amount: amount, timestamp: uint40(block.timestamp)});\\n\\n        emit UnwrapRequestSubmitted(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Complete unwrap request to receive LOOKS\\n     */\\n    function completeUnwrapRequest() external {\\n        uint256 requestedAt = unwrapRequests[msg.sender].timestamp;\\n        if (requestedAt == 0) {\\n            revert WrappedLooksRareToken__NoUnwrapRequest();\\n        }\\n\\n        unchecked {\\n            if (requestedAt + UNWRAP_REQUEST_COOLDOWN > block.timestamp) {\\n                revert WrappedLooksRareToken__TooEarlyToCompleteUnwrapRequest();\\n            }\\n        }\\n\\n        uint256 amount = unwrapRequests[msg.sender].amount;\\n\\n        unwrapRequests[msg.sender].amount = 0;\\n        unwrapRequests[msg.sender].timestamp = 0;\\n\\n        _executeERC20DirectTransfer(LOOKS, msg.sender, amount);\\n\\n        emit UnwrapRequestCompleted(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Cancel unwrap request and get back wLOOKS\\n     */\\n    function cancelUnwrapRequest() external {\\n        uint256 requestedAt = unwrapRequests[msg.sender].timestamp;\\n        if (requestedAt == 0) {\\n            revert WrappedLooksRareToken__NoUnwrapRequest();\\n        }\\n\\n        uint256 amount = unwrapRequests[msg.sender].amount;\\n\\n        unwrapRequests[msg.sender].amount = 0;\\n        unwrapRequests[msg.sender].timestamp = 0;\\n\\n        _mint(msg.sender, amount);\\n\\n        emit UnwrapRequestCancelled(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Unwrap LOOKS instantly. 5% of the unwrap amount is burned.\\n     * @param amount Unwrap amount\\n     */\\n    function instantUnwrap(uint256 amount) external {\\n        if (balanceOf(msg.sender) < amount) {\\n            revert WrappedLooksRareToken__InsufficientBalance();\\n        }\\n\\n        _burn(msg.sender, amount);\\n\\n        uint256 transferAmount = (amount * INSTANT_UNWRAP_AMOUNT_AFTER_FEE_IN_BASIS_POINTS) / 10_000;\\n        _executeERC20DirectTransfer(LOOKS, msg.sender, transferAmount);\\n        unchecked {\\n            _executeERC20DirectTransfer(LOOKS, 0x000000000000000000000000000000000000dEaD, amount - transferAmount);\\n        }\\n\\n        emit InstantUnwrap(msg.sender, amount);\\n    }\\n\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        if (to == address(this)) {\\n            revert WrappedLooksRareToken__InvalidAddress();\\n        }\\n        return super.transfer(to, value);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\\n        if (to == address(this)) {\\n            revert WrappedLooksRareToken__InvalidAddress();\\n        }\\n        return super.transferFrom(from, to, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"../interfaces/generic/IERC20.sol\\\";\\n\\n// Errors\\nimport {ERC20TransferFail, ERC20TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC20Transfer\\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC20Transfer {\\n    /**\\n     * @notice Execute ERC20 transferFrom\\n     * @param currency Currency address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFromFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFromFail();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC20 (direct) transfer\\n     * @param currency Currency address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n// Enums\\nimport {TokenType} from \\\"../enums/TokenType.sol\\\";\\n\\n/**\\n * @title ITransferManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface ITransferManager {\\n    /**\\n     * @notice This struct is only used for transferBatchItemsAcrossCollections.\\n     * @param tokenAddress Token address\\n     * @param tokenType 0 for ERC721, 1 for ERC1155\\n     * @param itemIds Array of item ids to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    struct BatchTransferItem {\\n        address tokenAddress;\\n        TokenType tokenType;\\n        uint256[] itemIds;\\n        uint256[] amounts;\\n    }\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are granted by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsGranted(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are revoked by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsRemoved(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if a new operator is added to the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorAllowed(address operator);\\n\\n    /**\\n     * @notice It is emitted if an operator is removed from the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorRemoved(address operator);\\n\\n    /**\\n     * @notice It is returned if the operator to approve has already been approved by the user.\\n     */\\n    error OperatorAlreadyApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the operator to revoke has not been previously approved by the user.\\n     */\\n    error OperatorNotApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is already allowed by the owner.\\n     * @dev This error can only be returned for owner operations.\\n     */\\n    error OperatorAlreadyAllowed();\\n\\n    /**\\n     * @notice It is returned if the operator to approve is not in the global allowlist defined by the owner.\\n     * @dev This error can be returned if the user tries to grant approval to an operator address not in the\\n     *      allowlist or if the owner tries to remove the operator from the global allowlist.\\n     */\\n    error OperatorNotAllowed();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is invalid.\\n     *         For a transfer called to be valid, the operator must be in the global allowlist and\\n     *         approved by the 'from' user.\\n     */\\n    error TransferCallerInvalid();\\n\\n    /**\\n     * @notice This function transfers ERC20 tokens.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount amount\\n     */\\n    function transferERC20(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     */\\n    function transferItemERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     */\\n    function transferItemsERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     * @param amount Amount\\n     */\\n    function transferItemERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     * @dev It does not allow batch transferring if from = msg.sender since native function should be used.\\n     */\\n    function transferItemsERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items across an array of tokens that can be ERC20, ERC721 and ERC1155.\\n     * @param items Array of BatchTransferItem\\n     * @param from Sender address\\n     * @param to Recipient address\\n     */\\n    function transferBatchItemsAcrossCollections(\\n        BatchTransferItem[] calldata items,\\n        address from,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @notice This function allows a user to grant approvals for an array of operators.\\n     *         Users cannot grant approvals if the operator is not allowed by this contract's owner.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be globally allowed to be approved.\\n     */\\n    function grantApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows a user to revoke existing approvals for an array of operators.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be approved at the user level to be revoked.\\n     */\\n    function revokeApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows an operator to be added for the shared transfer system.\\n     *         Once the operator is allowed, users can grant NFT approvals to this operator.\\n     * @param operator Operator address to allow\\n     * @dev Only callable by owner.\\n     */\\n    function allowOperator(address operator) external;\\n\\n    /**\\n     * @notice This function allows the user to remove an operator for the shared transfer system.\\n     * @param operator Operator address to remove\\n     * @dev Only callable by owner.\\n     */\\n    function removeOperator(address operator) external;\\n\\n    /**\\n     * @notice This returns whether the user has approved the operator address.\\n     * The first address is the user and the second address is the operator.\\n     */\\n    function hasUserApprovedOperator(address user, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title IStakingRewardsFunctions\\n/// @notice Interface for the staking rewards contract that interact with the `RewardsDistributor` contract\\ninterface IStakingRewardsFunctions {\\n    function notifyRewardAmount(uint256 reward) external;\\n\\n    function recoverERC20(address tokenAddress, address to, uint256 tokenAmount) external;\\n\\n    function setNewRewardsDistribution(address newRewardsDistribution) external;\\n}\\n\\n/// @title IStakingRewards\\n/// @notice Previous interface with additionnal getters for public variables\\ninterface IStakingRewards is IStakingRewardsFunctions {\\n    function periodFinish() external view returns (uint256);\\n\\n    function rewardToken() external view returns (IERC20);\\n\\n    function getReward() external;\\n\\n    function stake(uint256 amount) external;\\n\\n    function withdraw(uint256 amount) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function earned(address account) external view returns (uint256);\\n\\n    function stakeOnBehalf(uint256 amount, address staker) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the ETH transfer fails.\\n */\\nerror ETHTransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 approval fails.\\n */\\nerror ERC20ApprovalFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transfer fails.\\n */\\nerror ERC20TransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transferFrom fails.\\n */\\nerror ERC20TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC721 transferFrom fails.\\n */\\nerror ERC721TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\\n */\\nerror ERC1155SafeTransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\\n */\\nerror ERC1155SafeBatchTransferFromFail();\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the call recipient is not a contract.\\n */\\nerror NotAContract();\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-transfer-manager/contracts/enums/TokenType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nenum TokenType {\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@looksrare/=node_modules/@looksrare/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@uniswap/=node_modules/@uniswap/\",\r\n      \"base64-sol/=node_modules/base64-sol/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"solmate/=node_modules/solmate/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 888888\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"looks\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transferManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__NoUnwrapRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__OngoingUnwrapRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__TooEarlyToCompleteUnwrapRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedLooksRareToken__Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AutoCompounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_stakingRewards\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_autoCompounder\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InstantUnwrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapRequestCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapRequestCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapRequestSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Wrapped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INSTANT_UNWRAP_AMOUNT_AFTER_FEE_IN_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOOKS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_MANAGER\",\"outputs\":[{\"internalType\":\"contract ITransferManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNWRAP_REQUEST_COOLDOWN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoCompounder\",\"outputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUnwrapRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeUnwrapRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingRewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_autoCompounder\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"instantUnwrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewards\",\"outputs\":[{\"internalType\":\"contract IStakingRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint216\",\"name\":\"amount\",\"type\":\"uint216\"}],\"name\":\"submitUnwrapRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"unwrapRequests\",\"outputs\":[{\"internalType\":\"uint216\",\"name\":\"amount\",\"type\":\"uint216\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrapAndAutoCompound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrapAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WrappedLooksRareToken", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "888888", "ConstructorArguments": "000000000000000000000000f4d2888d29d722226fafa5d9b24f9164c092421e00000000000000000000000000000000000ea4af05656c17b90f4d64add29e1d", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}