{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/shared/ChecksummedAddress.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: \u00a9 2022 Dai Foundation <www.daifoundation.org>\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.6.12;\\n\\n/**\\n * Adapted from: https://ethereum.stackexchange.com/a/63953/1244\\n\\n * @dev This contract provides a set of pure functions for computing the EIP-55\\n * checksum of an account in formats friendly to both off-chain and on-chain\\n * callers, as well as for checking if a given string hex representation of an\\n * address has a valid checksum. These helper functions could also be repurposed\\n * as a library that extends the `address` type.\\n */\\nlibrary ChecksummedAddress {\\n    /**\\n     * @dev Get a checksummed string hex representation of an input address.\\n     * @param input address The input to get the checksum for.\\n     * @return The checksummed input string in ASCII format. Note that leading\\n     * \\\"0x\\\" is not included.\\n     */\\n    function toChecksum(address input) external pure returns (string memory) {\\n        // call internal function for converting an input to a checksummed string.\\n        return _toChecksumString(input);\\n    }\\n\\n    /**\\n     * @dev Get a fixed-size array of whether or not each character in an input\\n     * will be capitalized in the checksum.\\n     * @param input address The input to get the checksum capitalization\\n     * information for.\\n     * @return A fixed-size array of booleans that signify if each character or\\n     * \\\"nibble\\\" of the hex encoding of the address will be capitalized by the\\n     * checksum.\\n     */\\n    function getChecksumCapitalizedCharacters(address input) external pure returns (bool[40] memory) {\\n        // call internal function for computing characters capitalized in checksum.\\n        return _toChecksumCapsFlags(input);\\n    }\\n\\n    /**\\n     * @dev Determine whether a string hex representation of an input address\\n     * matches the ERC-55 checksum of that address.\\n     * @param inputChecksum string The checksummed input string in ASCII\\n     * format. Note that a leading \\\"0x\\\" MUST NOT be included.\\n     * @return A boolean signifying whether or not the checksum is valid.\\n     */\\n    function isChecksumValid(string calldata inputChecksum) external pure returns (bool) {\\n        // call internal function for validating checksum strings.\\n        return _isChecksumValid(inputChecksum);\\n    }\\n\\n    function _toChecksumString(address input) internal pure returns (string memory) {\\n        // convert the input argument from address to bytes.\\n        bytes20 data = bytes20(input);\\n\\n        // create an in-memory fixed-size bytes array.\\n        bytes memory asciiBytes = new bytes(40);\\n\\n        // declare variable types.\\n        uint8 b;\\n        uint8 leftNibble;\\n        uint8 rightNibble;\\n        bool leftCaps;\\n        bool rightCaps;\\n        uint8 asciiOffset;\\n\\n        // get the capitalized characters in the actual checksum.\\n        bool[40] memory caps = _toChecksumCapsFlags(input);\\n\\n        // iterate over bytes, processing left and right nibble in each iteration.\\n        for (uint256 i = 0; i < data.length; i++) {\\n            // locate the byte and extract each nibble.\\n            b = uint8(uint160(data) / (2**(8 * (19 - i))));\\n            leftNibble = b / 16;\\n            rightNibble = b - 16 * leftNibble;\\n\\n            // locate and extract each capitalization status.\\n            leftCaps = caps[2 * i];\\n            rightCaps = caps[2 * i + 1];\\n\\n            // get the offset from nibble value to ascii character for left nibble.\\n            asciiOffset = _getAsciiOffset(leftNibble, leftCaps);\\n\\n            // add the converted character to the byte array.\\n            asciiBytes[2 * i] = bytes1(leftNibble + asciiOffset);\\n\\n            // get the offset from nibble value to ascii character for right nibble.\\n            asciiOffset = _getAsciiOffset(rightNibble, rightCaps);\\n\\n            // add the converted character to the byte array.\\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + asciiOffset);\\n        }\\n\\n        return string(asciiBytes);\\n    }\\n\\n    function _toChecksumCapsFlags(address input) internal pure returns (bool[40] memory characterCapitalized) {\\n        // convert the address to bytes.\\n        bytes20 a = bytes20(input);\\n\\n        // hash the address (used to calculate checksum).\\n        bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));\\n\\n        // declare variable types.\\n        uint8 leftNibbleAddress;\\n        uint8 rightNibbleAddress;\\n        uint8 leftNibbleHash;\\n        uint8 rightNibbleHash;\\n\\n        // iterate over bytes, processing left and right nibble in each iteration.\\n        for (uint256 i; i < a.length; i++) {\\n            // locate the byte and extract each nibble for the address and the hash.\\n            rightNibbleAddress = uint8(a[i]) % 16;\\n            leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;\\n            rightNibbleHash = uint8(b[i]) % 16;\\n            leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;\\n\\n            characterCapitalized[2 * i] = (leftNibbleAddress > 9 && leftNibbleHash > 7);\\n            characterCapitalized[2 * i + 1] = (rightNibbleAddress > 9 && rightNibbleHash > 7);\\n        }\\n    }\\n\\n    function _isChecksumValid(string memory provided) internal pure returns (bool) {\\n        // convert the provided string into input type.\\n        address input = _toAddress(provided);\\n\\n        // return false in the event the input conversion returned null address.\\n        if (input == address(0)) {\\n            // ensure that provided address is not also the null address first.\\n            bytes memory b = bytes(provided);\\n            for (uint256 i; i < b.length; i++) {\\n                if (b[i] != hex\\\"30\\\") {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        // get the capitalized characters in the actual checksum.\\n        string memory actual = _toChecksumString(input);\\n\\n        // compare provided string to actual checksum string to test for validity.\\n        return (keccak256(abi.encodePacked(actual)) == keccak256(abi.encodePacked(provided)));\\n    }\\n\\n    function _getAsciiOffset(uint8 nibble, bool caps) internal pure returns (uint8 offset) {\\n        // to convert to ascii characters, add 48 to 0-9, 55 to A-F, & 87 to a-f.\\n        if (nibble < 10) {\\n            offset = 48;\\n        } else if (caps) {\\n            offset = 55;\\n        } else {\\n            offset = 87;\\n        }\\n    }\\n\\n    function _toAddress(string memory input) internal pure returns (address inputAddress) {\\n        // convert the input argument from address to bytes.\\n        bytes memory inputBytes = bytes(input);\\n\\n        // create a new fixed-size byte array for the ascii bytes of the address.\\n        bytes memory inputAddressBytes = new bytes(20);\\n\\n        // declare variable types.\\n        uint8 b;\\n        uint8 nibble;\\n        uint8 asciiOffset;\\n\\n        // only proceed if the provided string has a length of 40.\\n        if (inputBytes.length == 40) {\\n            for (uint256 i; i < 40; i++) {\\n                // get the byte in question.\\n                b = uint8(inputBytes[i]);\\n\\n                // ensure that the byte is a valid ascii character (0-9, A-F, a-f)\\n                if (b < 48) return address(0);\\n                if (57 < b && b < 65) return address(0);\\n                if (70 < b && b < 97) return address(0);\\n                if (102 < b) return address(0); //bytes(hex\\\"\\\");\\n\\n                // find the offset from ascii encoding to the nibble representation.\\n                if (b < 65) {\\n                    // 0-9\\n                    asciiOffset = 48;\\n                } else if (70 < b) {\\n                    // a-f\\n                    asciiOffset = 87;\\n                } else {\\n                    // A-F\\n                    asciiOffset = 55;\\n                }\\n\\n                // store left nibble on even iterations, then store byte on odd ones.\\n                if (i % 2 == 0) {\\n                    nibble = b - asciiOffset;\\n                } else {\\n                    inputAddressBytes[(i - 1) / 2] = (bytes1(16 * nibble + (b - asciiOffset)));\\n                }\\n            }\\n\\n            // pack up the fixed-size byte array and cast it to inputAddress.\\n            bytes memory packed = abi.encodePacked(inputAddressBytes);\\n            assembly {\\n                inputAddress := mload(add(packed, 20))\\n            }\\n        }\\n    }\\n\\n    // based on https://ethereum.stackexchange.com/a/56499/48410\\n    function _toAsciiString(bytes20 data) internal pure returns (string memory) {\\n        // create an in-memory fixed-size bytes array.\\n        bytes memory asciiBytes = new bytes(40);\\n\\n        // declare variable types.\\n        uint8 b;\\n        uint8 leftNibble;\\n        uint8 rightNibble;\\n\\n        // iterate over bytes, processing left and right nibble in each iteration.\\n        for (uint256 i = 0; i < data.length; i++) {\\n            // locate the byte and extract each nibble.\\n            b = uint8(uint160(data) / (2**(8 * (19 - i))));\\n            leftNibble = b / 16;\\n            rightNibble = b - 16 * leftNibble;\\n\\n            // to convert to ascii characters, add 48 to 0-9 and 87 to a-f.\\n            asciiBytes[2 * i] = bytes1(leftNibble + (leftNibble < 10 ? 48 : 87));\\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + (rightNibble < 10 ? 48 : 87));\\n        }\\n\\n        return string(asciiBytes);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"clipper-mom/=lib/dss-exec-lib/lib/clipper-mom/src/\",\r\n      \"ds-auth/=lib/ds-token/lib/ds-auth/src/\",\r\n      \"ds-math/=lib/ds-math/src/\",\r\n      \"ds-note/=lib/ds-value/lib/ds-thing/lib/ds-note/src/\",\r\n      \"ds-pause/=lib/dss-gem-joins/lib/dss-deploy/lib/ds-pause/src/\",\r\n      \"ds-proxy/=lib/dss-exec-lib/lib/ds-proxy/src/\",\r\n      \"ds-stop/=lib/dss-exec-lib/lib/osm-mom/lib/osm/lib/ds-stop/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"ds-thing/=lib/ds-value/lib/ds-thing/src/\",\r\n      \"ds-token/=lib/ds-token/src/\",\r\n      \"ds-value/=lib/ds-value/src/\",\r\n      \"dss-auto-line/=lib/dss-exec-lib/lib/dss-auto-line/src/\",\r\n      \"dss-chain-log/=lib/mip21-toolkit/lib/dss-chain-log/src/\",\r\n      \"dss-deploy/=lib/dss-gem-joins/lib/dss-deploy/src/\",\r\n      \"dss-direct-deposit/=lib/dss-exec-lib/lib/dss-direct-deposit/src/\",\r\n      \"dss-exec-lib/=lib/dss-exec-lib/src/\",\r\n      \"dss-gem-joins/=lib/dss-gem-joins/src/\",\r\n      \"dss-interfaces/=lib/dss-interfaces/src/\",\r\n      \"dss-lerp/=lib/dss-exec-lib/lib/dss-lerp/src/\",\r\n      \"dss-psm/=lib/mip21-toolkit/lib/dss-psm/src/\",\r\n      \"dss/=lib/dss/src/\",\r\n      \"esm/=lib/dss-gem-joins/lib/dss-deploy/lib/esm/src/\",\r\n      \"flipper-mom/=lib/dss-exec-lib/lib/flipper-mom/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"forward-proxy/=lib/forward-proxy/src/\",\r\n      \"ilk-registry/=lib/mip21-toolkit/lib/ilk-registry/src/\",\r\n      \"median/=lib/dss-exec-lib/lib/median/src/\",\r\n      \"mip21-toolkit/=lib/mip21-toolkit/src/\",\r\n      \"mkr-authority/=lib/dss-exec-lib/lib/mkr-authority/src/\",\r\n      \"osm-mom/=lib/dss-exec-lib/lib/osm-mom/src/\",\r\n      \"osm/=lib/dss-exec-lib/lib/osm-mom/lib/osm/src/\",\r\n      \"univ2-lp-oracle/=lib/dss-exec-lib/lib/univ2-lp-oracle/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"src/shared/ChecksummedAddress.sol\": {\r\n        \"ChecksummedAddress\": \"0x99482c6f92b560c006339e6af3e1b9ec4c10a5a0\"\r\n      },\r\n      \"src/shared/SolidityTypeConversions.sol\": {\r\n        \"SolidityTypeConversions\": \"0x04b90997da0af09866d7731210dc03da802d7113\"\r\n      },\r\n      \"src/shared/Strings.sol\": {\r\n        \"Strings\": \"0x0fd098fc12df47fad57c1d4d0fcec3fa9fb0b1fd\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"}],\"name\":\"getChecksumCapitalizedCharacters\",\"outputs\":[{\"internalType\":\"bool[40]\",\"name\":\"\",\"type\":\"bool[40]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"inputChecksum\",\"type\":\"string\"}],\"name\":\"isChecksumValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"}],\"name\":\"toChecksum\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "ChecksummedAddress", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}