{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n\n\n\ncontract MainnetAaveV3Addresses {\n    address internal constant AAVE_REWARDS_CONTROLLER_ADDRESS = 0x8164Cc65827dcFe994AB23944CBC90e0aa80bFcb;\n    address internal constant DEFAULT_AAVE_MARKET = 0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e;\n    address internal constant AAVE_ORACLE_V3 = 0x54586bE62E3c3580375aE3723C145253060Ca0C2;\n\n}\n\n\n\n\ninterface IAaveProtocolDataProvider {\n    /**\n     * @notice Returns the user data in a reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @param user The address of the user\n     * @return currentATokenBalance The current AToken balance of the user\n     * @return currentStableDebt The current stable debt of the user\n     * @return currentVariableDebt The current variable debt of the user\n     * @return principalStableDebt The principal stable debt of the user\n     * @return scaledVariableDebt The scaled variable debt of the user\n     * @return stableBorrowRate The stable borrow rate of the user\n     * @return liquidityRate The liquidity rate of the reserve\n     * @return stableRateLastUpdated The timestamp of the last update of the user stable rate\n     * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false\n     *         otherwise\n     **/\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n    function getSiloedBorrowing(address asset) external view returns (bool);\t\n}\n\n\n\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n\n\n\n\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   **/\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   **/\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   **/\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   **/\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   **/\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   **/\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   **/\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   **/\n  function setPoolDataProvider(address newDataProvider) external;\n}\n\n\n\n\n\ninterface IPoolV3 {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   **/\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   **/\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   **/\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   **/\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   **/\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   **/\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   **/\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   **/\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   **/\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the reserves\n   **/\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   **/\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   **/\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   **/\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n}\n\n\n\n\n\ninterface IL2PoolV3 is IPoolV3{\n  /**\n   * @notice Calldata efficient wrapper of the supply function on behalf of the caller\n   * @param args Arguments for the supply function packed in one bytes32\n   *    96 bits       16 bits         128 bits      16 bits\n   * | 0-padding | referralCode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function supply(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the supplyWithPermit function on behalf of the caller\n   * @param args Arguments for the supply function packed in one bytes32\n   *    56 bits    8 bits         32 bits           16 bits         128 bits      16 bits\n   * | 0-padding | permitV | shortenedDeadline | referralCode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @param r The R parameter of ERC712 permit sig\n   * @param s The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    bytes32 args,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the withdraw function, withdrawing to the caller\n   * @param args Arguments for the withdraw function packed in one bytes32\n   *    112 bits       128 bits      16 bits\n   * | 0-padding | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function withdraw(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the borrow function, borrowing on behalf of the caller\n   * @param args Arguments for the borrow function packed in one bytes32\n   *    88 bits       16 bits             8 bits                 128 bits       16 bits\n   * | 0-padding | referralCode | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function borrow(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the repay function, repaying on behalf of the caller\n   * @param args Arguments for the repay function packed in one bytes32\n   *    104 bits             8 bits               128 bits       16 bits\n   * | 0-padding | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @return The final amount repaid\n   */\n  function repay(bytes32 args) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the repayWithPermit function, repaying on behalf of the caller\n   * @param args Arguments for the repayWithPermit function packed in one bytes32\n   *    64 bits    8 bits        32 bits                   8 bits               128 bits       16 bits\n   * | 0-padding | permitV | shortenedDeadline | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @param r The R parameter of ERC712 permit sig\n   * @param s The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    bytes32 args,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the repayWithATokens function\n   * @param args Arguments for the repayWithATokens function packed in one bytes32\n   *    104 bits             8 bits               128 bits       16 bits\n   * | 0-padding | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @return The final amount repaid\n   */\n  function repayWithATokens(bytes32 args) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the swapBorrowRateMode function\n   * @param args Arguments for the swapBorrowRateMode function packed in one bytes32\n   *    232 bits            8 bits             16 bits\n   * | 0-padding | shortenedInterestRateMode | assetId |\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function swapBorrowRateMode(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the rebalanceStableBorrowRate function\n   * @param args Arguments for the rebalanceStableBorrowRate function packed in one bytes32\n   *    80 bits      160 bits     16 bits\n   * | 0-padding | user address | assetId |\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function rebalanceStableBorrowRate(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the setUserUseReserveAsCollateral function\n   * @param args Arguments for the setUserUseReserveAsCollateral function packed in one bytes32\n   *    239 bits         1 bit       16 bits\n   * | 0-padding | useAsCollateral | assetId |\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function setUserUseReserveAsCollateral(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the liquidationCall function\n   * @param args1 part of the arguments for the liquidationCall function packed in one bytes32\n   *    64 bits      160 bits       16 bits         16 bits\n   * | 0-padding | user address | debtAssetId | collateralAssetId |\n   * @param args2 part of the arguments for the liquidationCall function packed in one bytes32\n   *    127 bits       1 bit             128 bits\n   * | 0-padding | receiveAToken | shortenedDebtToCover |\n   * @dev the shortenedDebtToCover is cast to 256 bits at decode time,\n   * if type(uint128).max the value will be expanded to type(uint256).max\n   */\n  function liquidationCall(bytes32 args1, bytes32 args2) external;\n}\n\n\n\n\n\n\ncontract AaveV3Helper is MainnetAaveV3Addresses {\n    \n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    \n    \n    /// @notice Returns the lending pool contract of the specified market\n    function getLendingPool(address _market) internal virtual view returns (IL2PoolV3) {\n        return IL2PoolV3(IPoolAddressesProvider(_market).getPool());\n    }\n\n    /// @notice Fetch the data provider for the specified market\n    function getDataProvider(address _market) internal virtual view returns (IAaveProtocolDataProvider) {\n        return\n            IAaveProtocolDataProvider(\n                IPoolAddressesProvider(_market).getPoolDataProvider()\n            );\n    }\n\n    function boolToBytes(bool x) internal virtual pure returns (bytes1 r) {\n       return x ? bytes1(0x01) : bytes1(0x00);\n    }\n\n    function bytesToBool(bytes1 x) internal virtual pure returns (bool r) {\n        return x != bytes1(0x00);\n    }\n    \n    function getWholeDebt(address _market, address _tokenAddr, uint _borrowType, address _debtOwner) internal virtual view returns (uint256 debt) {\n        uint256 STABLE_ID = 1;\n        uint256 VARIABLE_ID = 2;\n\n        IAaveProtocolDataProvider dataProvider = getDataProvider(_market);\n        (, uint256 borrowsStable, uint256 borrowsVariable, , , , , , ) =\n            dataProvider.getUserReserveData(_tokenAddr, _debtOwner);\n\n        if (_borrowType == STABLE_ID) {\n            debt = borrowsStable;\n        } else if (_borrowType == VARIABLE_ID) {\n            debt = borrowsVariable;\n        }\n    }\n}\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\n\ncontract AaveV3RatioHelper is DSMath, MainnetAaveV3Addresses {\n   function getSafetyRatio(address _market, address _user) public view returns (uint256) {\n        IPoolV3 lendingPool = IPoolV3(IPoolAddressesProvider(_market).getPool());\n        (, uint256 totalDebtETH, uint256 availableBorrowsETH, , , ) = lendingPool\n            .getUserAccountData(_user);\n        if (totalDebtETH == 0) return uint256(0);\n        return wdiv(totalDebtETH + availableBorrowsETH, totalDebtETH);\n    }\n    /// @notice Calculated the ratio of coll/debt for an aave user\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _user Address of the user\n    function getRatio(address _market, address _user) public view returns (uint256) {\n        // For each asset the account is in\n        return getSafetyRatio(_market, _user);\n    }\n}\n\n\n\n\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   **/\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   **/\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n\n\n\n\n\ninterface IAaveV3Oracle is IPriceOracleGetter {\n    /**\n     * @dev Emitted after the base currency is set\n     * @param baseCurrency The base currency of used for price quotes\n     * @param baseCurrencyUnit The unit of the base currency\n     */\n    event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n    /**\n     * @dev Emitted after the price source of an asset is updated\n     * @param asset The address of the asset\n     * @param source The price source of the asset\n     */\n    event AssetSourceUpdated(address indexed asset, address indexed source);\n\n    /**\n     * @dev Emitted after the address of fallback oracle is updated\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    event FallbackOracleUpdated(address indexed fallbackOracle);\n\n    /**\n     * @notice Returns the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Sets or replaces price sources of assets\n     * @param assets The addresses of the assets\n     * @param sources The addresses of the price sources\n     */\n    function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n    /**\n     * @notice Sets the fallback oracle\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    function setFallbackOracle(address fallbackOracle) external;\n\n    /**\n     * @notice Returns a list of prices from a list of assets addresses\n     * @param assets The list of assets addresses\n     * @return The prices of the given assets\n     */\n    function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n    /**\n     * @notice Returns the address of the source for an asset address\n     * @param asset The address of the asset\n     * @return The address of the source\n     */\n    function getSourceOfAsset(address asset) external view returns (address);\n\n    /**\n     * @notice Returns the address of the fallback oracle\n     * @return The address of the fallback oracle\n     */\n    function getFallbackOracle() external view returns (address);\n}\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\n\nabstract contract IWETH {\n    function allowance(address, address) public virtual view returns (uint256);\n\n    function balanceOf(address) public virtual view returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool);\n\n    function deposit() public payable virtual;\n\n    function withdraw(uint256) public virtual;\n}\n\n\n\n\n\nlibrary Address {\n    //insufficient balance\n    error InsufficientBalance(uint256 available, uint256 required);\n    //unable to send value, recipient may have reverted\n    error SendingValueFail();\n    //insufficient balance for call\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\n    //call to non-contract\n    error NonContractCall();\n    \n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        uint256 balance = address(this).balance;\n        if (balance < amount){\n            revert InsufficientBalance(balance, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!(success)){\n            revert SendingValueFail();\n        }\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        uint256 balance = address(this).balance;\n        if (balance < value){\n            revert InsufficientBalanceForCall(balance, value);\n        }\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        if (!(isContract(target))){\n            revert NonContractCall();\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\n\n\n\n\nlibrary TokenUtils {\n    using SafeERC20 for IERC20;\n\n    address public constant WSTETH_ADDR = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant STETH_ADDR = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    function approveToken(\n        address _tokenAddr,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_tokenAddr == ETH_ADDR) return;\n\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\n        }\n    }\n\n    function pullTokensIfNeeded(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // handle max uint amount\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, _from);\n        }\n\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        }\n\n        return _amount;\n    }\n\n    function withdrawTokens(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, address(this));\n        }\n\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\n            if (_token != ETH_ADDR) {\n                IERC20(_token).safeTransfer(_to, _amount);\n            } else {\n                (bool success, ) = _to.call{value: _amount}(\"\");\n                require(success, \"Eth send fail\");\n            }\n        }\n\n        return _amount;\n    }\n\n    function depositWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).deposit{value: _amount}();\n    }\n\n    function withdrawWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).withdraw(_amount);\n    }\n\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\n        if (_tokenAddr == ETH_ADDR) {\n            return _acc.balance;\n        } else {\n            return IERC20(_tokenAddr).balanceOf(_acc);\n        }\n    }\n\n    function getTokenDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return IERC20(_token).decimals();\n    }\n}\n\n\n\n\ninterface IPriceOracleSentinel {\n  /**\n   * @dev Emitted after the sequencer oracle is updated\n   * @param newSequencerOracle The new sequencer oracle\n   */\n  event SequencerOracleUpdated(address newSequencerOracle);\n\n  /**\n   * @dev Emitted after the grace period is updated\n   * @param newGracePeriod The new grace period value\n   */\n  event GracePeriodUpdated(uint256 newGracePeriod);\n\n  /**\n   * @notice Returns true if the `borrow` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `borrow` operation is allowed, false otherwise.\n   */\n  function isBorrowAllowed() external view returns (bool);\n\n  /**\n   * @notice Returns true if the `liquidation` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `liquidation` operation is allowed, false otherwise.\n   */\n  function isLiquidationAllowed() external view returns (bool);\n\n  /**\n   * @notice Updates the address of the sequencer oracle\n   * @param newSequencerOracle The address of the new Sequencer Oracle to use\n   */\n  function setSequencerOracle(address newSequencerOracle) external;\n\n  /**\n   * @notice Updates the duration of the grace period\n   * @param newGracePeriod The value of the new grace period duration\n   */\n  function setGracePeriod(uint256 newGracePeriod) external;\n\n  /**\n   * @notice Returns the SequencerOracle\n   * @return The address of the sequencer oracle contract\n   */\n  function getSequencerOracle() external view returns (address);\n\n  /**\n   * @notice Returns the grace period\n   * @return The duration of the grace period\n   */\n  function getGracePeriod() external view returns (uint256);\n}\n\n\n\n\n\n\n\n\n\ncontract AaveV3View is AaveV3Helper, AaveV3RatioHelper {\n    uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n    uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n    uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n\n    \n    uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n    uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n    uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n    uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n    uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n    uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n    uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n\n    using TokenUtils for address;\n\n    struct LoanData {\n        address user;\n        uint128 ratio;\n        uint256 eMode;\n        address[] collAddr;\n        bool[] enabledAsColl;\n        address[] borrowAddr;\n        uint256[] collAmounts;\n        uint256[] borrowStableAmounts;\n        uint256[] borrowVariableAmounts;\n        // emode category data\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        address priceSource;\n        string label;\n    }\n\n    struct UserToken {\n        address token;\n        uint256 balance;\n        uint256 borrowsStable;\n        uint256 borrowsVariable;\n        uint256 stableBorrowRate;\n        bool enabledAsCollateral;\n    }\n\n    struct TokenInfo {\n        address aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 collateralFactor;\n        uint256 price;\n    }\n\n    struct TokenInfoFull {\n        address aTokenAddress; //pool.config\n        address underlyingTokenAddress; //pool.config\n        uint16 assetId;\n        uint256 supplyRate; //pool.config\n        uint256 borrowRateVariable; //pool.config\n        uint256 borrowRateStable; //pool.config\n        uint256 totalSupply; //total supply\n        uint256 availableLiquidity; //reserveData.liq rate\n        uint256 totalBorrow; // total supply of both debt assets\n        uint256 totalBorrowVar;\n        uint256 totalBorrowStab;\n        uint256 collateralFactor; //pool.config\n        uint256 liquidationRatio; //pool.config\n        uint256 price; //oracle\n        uint256 supplyCap; //pool.config\n        uint256 borrowCap; //pool.config\n        uint256 emodeCategory; //pool.config\n        uint256 debtCeilingForIsolationMode; //pool.config 212-251\n        uint256 isolationModeTotalDebt; //pool.isolationModeTotalDebt\n        bool usageAsCollateralEnabled; //usageAsCollateralEnabled = liquidationThreshold > 0;\n        bool borrowingEnabled; //pool.config\n        bool stableBorrowRateEnabled; //pool.config\n        bool isolationModeBorrowingEnabled; //pool.config\n        bool isSiloedForBorrowing; //AaveProtocolDataProvider.getSiloedBorrowing\n        uint256 eModeCollateralFactor; //pool.getEModeCategoryData.ltv\n        bool isFlashLoanEnabled;\n        // emode category data\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        address priceSource;\n        string label;\n        bool isActive;\n        bool isPaused;\n        bool isFrozen;\n    }\n\n    function getHealthFactor(address _market, address _user)\n        public\n        view\n        returns (uint256 healthFactor)\n    {\n        IPoolV3 lendingPool = getLendingPool(_market);\n\n        (, , , , , healthFactor) = lendingPool.getUserAccountData(_user);\n    }\n\n    /// @notice Fetches Aave prices for tokens\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokens Arr. of tokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address _market, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory prices)\n    {\n        address priceOracleAddress = IPoolAddressesProvider(_market).getPriceOracle();\n        prices = IAaveV3Oracle(priceOracleAddress).getAssetsPrices(_tokens);\n    }\n\n    /// @notice Calculated the ratio of coll/debt for an aave user\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address _market, address[] memory _users)\n        public\n        view\n        returns (uint256[] memory ratios)\n    {\n        ratios = new uint256[](_users.length);\n\n        for (uint256 i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_market, _users[i]);\n        }\n    }\n\n    /// @notice Fetches Aave collateral factors for tokens\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address _market, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory collFactors)\n    {\n        IPoolV3 lendingPool = getLendingPool(_market);\n        collFactors = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            DataTypes.ReserveConfigurationMap memory config = lendingPool.getConfiguration(\n                _tokens[i]\n            );\n            collFactors[i] = getReserveFactor(config);\n        }\n    }\n\n    function getTokenBalances(\n        address _market,\n        address _user,\n        address[] memory _tokens\n    ) public view returns (UserToken[] memory userTokens) {\n        IPoolV3 lendingPool = getLendingPool(_market);\n        userTokens = new UserToken[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(_tokens[i]);\n            userTokens[i].balance = reserveData.aTokenAddress.getBalance(_user);\n            userTokens[i].borrowsStable = reserveData.stableDebtTokenAddress.getBalance(_user);\n            userTokens[i].borrowsVariable = reserveData.variableDebtTokenAddress.getBalance(_user);\n            userTokens[i].stableBorrowRate = reserveData.currentStableBorrowRate;\n            DataTypes.UserConfigurationMap memory map = lendingPool.getUserConfiguration(_user);\n            userTokens[i].enabledAsCollateral = isUsingAsCollateral(map, reserveData.id);\n        }\n    }\n\n    /// @notice Information about reserves\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokenAddresses Array of tokens addresses\n    /// @return tokens Array of reserves information\n    function getTokensInfo(address _market, address[] memory _tokenAddresses)\n        public\n        view\n        returns (TokenInfo[] memory tokens)\n    {\n        IPoolV3 lendingPool = getLendingPool(_market);\n        tokens = new TokenInfo[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; i++) {\n            DataTypes.ReserveConfigurationMap memory config = lendingPool.getConfiguration(\n                _tokenAddresses[i]\n            );\n            uint256 collFactor = config.data & ~LTV_MASK;\n            DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n                _tokenAddresses[i]\n            );\n            address aTokenAddr = reserveData.aTokenAddress;\n            address priceOracleAddress = IPoolAddressesProvider(_market).getPriceOracle();\n            uint256 price = IAaveV3Oracle(priceOracleAddress).getAssetPrice(_tokenAddresses[i]);\n            tokens[i] = TokenInfo({\n                aTokenAddress: aTokenAddr,\n                underlyingTokenAddress: _tokenAddresses[i],\n                collateralFactor: collFactor,\n                price: price\n            });\n        }\n    }\n\n    function getTokenInfoFull(address _market, address _tokenAddr)\n        public\n        view\n        returns (TokenInfoFull memory _tokenInfo)\n    {\n        IPoolV3 lendingPool = getLendingPool(_market);\n\n        DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(_tokenAddr);\n        DataTypes.ReserveConfigurationMap memory config = lendingPool.getConfiguration(_tokenAddr);\n\n        uint256 totalVariableBorrow = IERC20(reserveData.variableDebtTokenAddress).totalSupply();\n        uint256 totalStableBorrow = IERC20(reserveData.stableDebtTokenAddress).totalSupply();\n\n\n        uint256 eMode = getEModeCategory(config);\n        DataTypes.EModeCategory memory categoryData = lendingPool.getEModeCategoryData(uint8(eMode));\n\n        (bool isActive, bool isFrozen, , , bool isPaused) = getFlags(config);\n\n        _tokenInfo = TokenInfoFull({\n            aTokenAddress: reserveData.aTokenAddress,\n            underlyingTokenAddress: _tokenAddr,\n            assetId: reserveData.id,\n            supplyRate: reserveData.currentLiquidityRate,\n            borrowRateVariable: reserveData.currentVariableBorrowRate,\n            borrowRateStable: reserveData.currentStableBorrowRate,\n            totalSupply: IERC20(reserveData.aTokenAddress).totalSupply(),\n            availableLiquidity: _tokenAddr.getBalance(reserveData.aTokenAddress),\n            totalBorrow: totalVariableBorrow + totalStableBorrow,\n            totalBorrowVar: totalVariableBorrow,\n            totalBorrowStab: totalStableBorrow,\n            collateralFactor: getLtv(config),\n            liquidationRatio: getLiquidationThreshold(config),\n            price: getAssetPrice(_market, _tokenAddr),\n            supplyCap: getSupplyCap(config),\n            borrowCap: getBorrowCap(config),\n            emodeCategory: eMode,\n            usageAsCollateralEnabled: getLiquidationThreshold(config) > 0,\n            borrowingEnabled: getBorrowingEnabled(config),\n            stableBorrowRateEnabled: getStableRateBorrowingEnabled(config),\n            isolationModeBorrowingEnabled: getBorrowableInIsolation(config),\n            debtCeilingForIsolationMode: getDebtCeiling(config),\n            isolationModeTotalDebt: reserveData.isolationModeTotalDebt,\n            isSiloedForBorrowing: isSiloedForBorrowing(_market, _tokenAddr),\n            eModeCollateralFactor: getEModeCollateralFactor(uint8(getEModeCategory(config)), lendingPool),\n            isFlashLoanEnabled: getFlashLoanEnabled(config),\n            ltv: categoryData.ltv,\n            liquidationThreshold: categoryData.liquidationThreshold,\n            liquidationBonus: categoryData.liquidationBonus,\n            priceSource: categoryData.priceSource,\n            label: categoryData.label,\n            isActive: isActive,\n            isPaused: isPaused,\n            isFrozen: isFrozen\n        });\n    }\n\n    /// @notice Information about reserves\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokenAddresses Array of token addresses\n    /// @return tokens Array of reserves information\n    function getFullTokensInfo(address _market, address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n            tokens[i] = getTokenInfoFull(_market, _tokenAddresses[i]);\n        }\n    }\n\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _market, address _user) public view returns (LoanData memory data) {\n        IPoolV3 lendingPool = getLendingPool(_market);\n        address[] memory reserveList = lendingPool.getReservesList();\n        uint256 eMode = lendingPool.getUserEMode(_user);\n        \n        DataTypes.EModeCategory memory categoryData = lendingPool.getEModeCategoryData(uint8(eMode));\n        \n        data = LoanData({\n            eMode: eMode,\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](reserveList.length),\n            enabledAsColl: new bool[](reserveList.length),\n            borrowAddr: new address[](reserveList.length),\n            collAmounts: new uint[](reserveList.length),\n            borrowStableAmounts: new uint[](reserveList.length),\n            borrowVariableAmounts: new uint[](reserveList.length),\n            ltv: categoryData.ltv,\n            liquidationThreshold: categoryData.liquidationThreshold,\n            liquidationBonus: categoryData.liquidationBonus,\n            priceSource: categoryData.priceSource,\n            label: categoryData.label\n        });\n\n        uint64 collPos = 0;\n        uint64 borrowPos = 0;\n\n        for (uint256 i = 0; i < reserveList.length; i++) {\n            address reserve = reserveList[i];\n            uint256 price = getAssetPrice(_market, reserve);\n            DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(reserve);\n            {\n                uint256 aTokenBalance = reserveData.aTokenAddress.getBalance(_user);\n                if (aTokenBalance > 0) {\n                    data.collAddr[collPos] = reserve;\n                    data.enabledAsColl[collPos] = isUsingAsCollateral(lendingPool.getUserConfiguration(_user), reserveData.id);\n                    uint256 userTokenBalanceEth = (aTokenBalance * price) / (10 ** (reserve.getTokenDecimals()));\n                    data.collAmounts[collPos] = userTokenBalanceEth;\n                    collPos++;\n                }\n            }\n            \n            // Sum up debt in Usd\n            uint256 borrowsStable = reserveData.stableDebtTokenAddress.getBalance(_user);\n            if (borrowsStable > 0) {\n                uint256 userBorrowBalanceEth = (borrowsStable * price) / (10 ** (reserve.getTokenDecimals()));\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowStableAmounts[borrowPos] = userBorrowBalanceEth;\n            }\n\n            // Sum up debt in Usd\n            uint256 borrowsVariable = reserveData.variableDebtTokenAddress.getBalance(_user);\n            if (borrowsVariable > 0) {\n                uint256 userBorrowBalanceEth = (borrowsVariable * price) / (10 ** (reserve.getTokenDecimals()));\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowVariableAmounts[borrowPos] = userBorrowBalanceEth;\n            }\n            if (borrowsStable > 0 || borrowsVariable > 0) {\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_market, _user));\n\n        return data;\n    }\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address _market, address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_market, _users[i]);\n        }\n    }\n\n    function getLtv(DataTypes.ReserveConfigurationMap memory self) public pure returns (uint256) {\n        return self.data & ~LTV_MASK;\n    }\n\n    function getReserveFactor(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n    }\n\n    function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\n        internal\n        pure\n        returns (bool)\n    {\n        unchecked {\n            return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;\n        }\n    }\n\n    function getLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n    }\n\n    function getAssetPrice(address _market, address _tokenAddr)\n        public\n        view\n        returns (uint256 price)\n    {\n        address priceOracleAddress = IPoolAddressesProvider(_market).getPriceOracle();\n        price = IAaveV3Oracle(priceOracleAddress).getAssetPrice(_tokenAddr);\n    }\n\n    function getBorrowCap(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n    }\n\n    function getSupplyCap(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n    }\n\n    function getEModeCategory(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n    }\n\n    function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (bool)\n    {\n        return (self.data & ~BORROWING_MASK) != 0;\n    }\n\n    function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (bool)\n    {\n        return (self.data & ~STABLE_BORROWING_MASK) != 0;\n    }\n\n    function getBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (bool)\n    {\n        return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n    }\n\n    /**\n    * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n    * @param self The reserve configuration\n    * @return The debt ceiling (0 = isolation mode disabled)\n    **/\n    function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n    }\n\n    function isSiloedForBorrowing(address _market, address _tokenAddr) internal view returns (bool){\n        IAaveProtocolDataProvider dataProvider = getDataProvider(_market);\n        return dataProvider.getSiloedBorrowing(_tokenAddr);\n    }\n\n    function getEModeCollateralFactor(uint256 emodeCategory, IPoolV3 lendingPool) public view returns (uint16){\n        DataTypes.EModeCategory memory categoryData = lendingPool.getEModeCategoryData(uint8(emodeCategory));\n        return categoryData.ltv;\n    }\n\n    function getFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n    }\n\n    /**\n     * @notice Gets the configuration flags of the reserve\n     * @param self The reserve configuration\n     * @return The state flag representing active\n     * @return The state flag representing frozen\n     * @return The state flag representing borrowing enabled\n     * @return The state flag representing stableRateBorrowing enabled\n     * @return The state flag representing paused\n     */\n    function getFlags(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool, bool, bool, bool, bool) {\n        uint256 dataLocal = self.data;\n\n        return (\n        (dataLocal & ~ACTIVE_MASK) != 0,\n        (dataLocal & ~FROZEN_MASK) != 0,\n        (dataLocal & ~BORROWING_MASK) != 0,\n        (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n        (dataLocal & ~PAUSED_MASK) != 0\n        );\n    }\n\n    function isBorrowAllowed(address _market) public view returns (bool) {\n        address priceOracleSentinelAddress = IPoolAddressesProvider(_market).getPriceOracleSentinel();\n        return (priceOracleSentinelAddress == address(0) || IPriceOracleSentinel(priceOracleSentinelAddress).isBorrowAllowed());\n    }\n\n}\n", "ABI": "[{\"inputs\":[],\"name\":\"AAVE_REFERRAL_CODE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getCollFactors\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"collFactors\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"emodeCategory\",\"type\":\"uint256\"},{\"internalType\":\"contract IPoolV3\",\"name\":\"lendingPool\",\"type\":\"address\"}],\"name\":\"getEModeCollateralFactor\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getFullTokensInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"assetId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateStable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVar\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowStab\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emodeCategory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtCeilingForIsolationMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"isolationModeTotalDebt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"stableBorrowRateEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isolationModeBorrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSiloedForBorrowing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"eModeCollateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFlashLoanEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"ltv\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationBonus\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceSource\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"}],\"internalType\":\"struct AaveV3View.TokenInfoFull[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getHealthFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLoanData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"eMode\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"collAddr\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"enabledAsColl\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"borrowAddr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowStableAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowVariableAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"ltv\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationBonus\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceSource\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"internalType\":\"struct AaveV3View.LoanData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"getLoanDataArr\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"eMode\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"collAddr\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"enabledAsColl\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"borrowAddr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowStableAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowVariableAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"ltv\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationBonus\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceSource\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"internalType\":\"struct AaveV3View.LoanData[]\",\"name\":\"loans\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"getLtv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"getRatios\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ratios\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getSafetyRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getTokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowsStable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowsVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabledAsCollateral\",\"type\":\"bool\"}],\"internalType\":\"struct AaveV3View.UserToken[]\",\"name\":\"userTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getTokenInfoFull\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"assetId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateStable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVar\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowStab\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emodeCategory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtCeilingForIsolationMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"isolationModeTotalDebt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"stableBorrowRateEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isolationModeBorrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSiloedForBorrowing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"eModeCollateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFlashLoanEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"ltv\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationBonus\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"priceSource\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"}],\"internalType\":\"struct AaveV3View.TokenInfoFull\",\"name\":\"_tokenInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getTokensInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct AaveV3View.TokenInfo[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"isBorrowAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AaveV3View", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}