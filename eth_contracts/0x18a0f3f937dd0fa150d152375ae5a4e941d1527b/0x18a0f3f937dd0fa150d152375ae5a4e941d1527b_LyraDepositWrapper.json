{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/helpers/LyraDepositWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\nimport {ISocketVault} from \\\"../interfaces/ISocketVault.sol\\\";\\nimport {ILightAccountFactory} from \\\"../interfaces/ILightAccountFactory.sol\\\";\\n\\n/**\\n * @title  LyraDepositWrapper\\n * @dev    Helper contract to wrap ETH into L2 WETH, or deposit any token to L2 smart contract wallet address\\n */\\ncontract LyraDepositWrapper {\\n    ///@dev L2 USDC address.\\n    address public immutable weth;\\n\\n    ///@dev Light Account factory address.\\n    address public constant lightAccountFactory = 0x000000893A26168158fbeaDD9335Be5bC96592E2;\\n\\n    constructor(address _weth) {\\n        weth = _weth;\\n    }\\n\\n    /**\\n     * @notice Wrap ETH into WETH and deposit to Lyra Chain via socket vault\\n     */\\n    function depositETHToLyra(address socketVault, bool isSCW, uint256 gasLimit, address connector) external payable {\\n        uint256 socketFee = ISocketVault(socketVault).getMinFees(connector, gasLimit);\\n\\n        uint256 depositAmount = msg.value - socketFee;\\n\\n        IWETH(weth).deposit{value: depositAmount}();\\n        IERC20(weth).approve(socketVault, type(uint256).max);\\n\\n        address recipient = _getL2Receiver(isSCW);\\n\\n        ISocketVault(socketVault).depositToAppChain{value: socketFee}(recipient, depositAmount, gasLimit, connector);\\n    }\\n\\n    /**\\n     * @notice Deposit any token to Lyra Chain via socket vault.\\n     * @dev This function help calculate L2 smart wallet addresses for users\\n     */\\n    function depositToLyra(\\n        address token,\\n        address socketVault,\\n        bool isSCW,\\n        uint256 amount,\\n        uint256 gasLimit,\\n        address connector\\n    ) external payable {\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\n        IERC20(token).approve(socketVault, type(uint256).max);\\n\\n        address recipient = _getL2Receiver(isSCW);\\n\\n        ISocketVault(socketVault).depositToAppChain{value: msg.value}(recipient, amount, gasLimit, connector);\\n    }\\n\\n    /**\\n     * @notice Return the receiver address on L2\\n     */\\n    function _getL2Receiver(bool isScwWallet) internal view returns (address) {\\n        if (isScwWallet) {\\n            return ILightAccountFactory(lightAccountFactory).getAddress(msg.sender, 0);\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISocketVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\ninterface ISocketVault {\\n    function depositToAppChain(address receiver_, uint256 amount_, uint256 msgGasLimit_, address connector_)\\n        external\\n        payable;\\n\\n    function __token() external view returns (address);\\n\\n    function getMinFees(address connector, uint256 minGasLimit) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILightAccountFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface ILightAccountFactory {\\n    /**\\n     * @notice Create an account, and return its address.\\n     * Returns the address even if the account is already deployed.\\n     * @dev During UserOperation execution, this method is called only if the account is not deployed.\\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation.\\n     * @param owner The owner of the account to be created\\n     * @param salt A salt, which can be changed to create multiple accounts with the same owner\\n     * @return ret The address of either the newly deployed account or an existing account with this owner and salt\\n     */\\n    function createAccount(address owner, uint256 salt) external returns (address ret);\\n\\n    /**\\n     * @notice Calculate the counterfactual address of this account as it would be returned by createAccount()\\n     * @param owner The owner of the account to be created\\n     * @param salt A salt, which can be changed to create multiple accounts with the same owner\\n     * @return The address of the account that would be created with createAccount()\\n     */\\n    function getAddress(address owner, uint256 salt) external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"relay-context-contracts/=lib/relay-context-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"socketVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSCW\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"depositETHToLyra\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"socketVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSCW\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"depositToLyra\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lightAccountFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LyraDepositWrapper", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b0d419648160dbf66f804445469b0f5031d6bc2712e7878f7c23ec7858d7c628"}