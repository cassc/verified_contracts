{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract Errors {\\n    error OwnerContract__AlreadyInitialized();\\n    error Helpers__NotOwner();\\n    error Helpers__NotRebalancer();\\n    error Helpers__InvalidParams();\\n    error Helpers__Reentrant();\\n    error WeethStrategyContract__MaxLeveraged();\\n    error WeethStrategyContract__SupplyCapReached();\\n    error WeethStrategyContract__NoBorrowingAvailability();\\n    error WeethStrategyContract__PosExceededRatio();\\n    error WeethStrategyContract__MinAvailabilityNotReached();\\n}\\n\"\r\n    },\r\n    \"contracts/events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract Events {\\n    event LogSetOwner(address owner);\\n\\n    event LogUpdateOwner(address oldOwner, address newOwner);\\n\\n    event LogSetVaultDSA(address vaultDSA);\\n\\n    event LogDSASpell(\\n        address indexed to,\\n        bytes data,\\n        uint256 value,\\n        uint256 operation\\n    );\\n\\n    // @notice emitted when addDSAAuth function is called by auth\\n    event LogAddDSAAuthority(address indexed newAuthority);\\n\\n    /// @notice Emitted when rebalancer is added or removed.\\n    event LogUpdateRebalancer(\\n        address indexed rebalancer,\\n        bool indexed isRebalancer\\n    );\\n\\n    /// @notice Emitted when max pos ratio is updated.\\n    event LogUpdateMaxRatio(\\n        uint256 indexed maxPosRatioBefore,\\n        uint256 indexed maxPosRatioAfter\\n    );\\n\\n    /// @notice Emitted when DSA is leveraged.\\n    event LogLeverage(\\n        uint256 indexed wETHCollAmount,\\n        uint256 indexed wETHBorrowAmount,\\n        uint256 indexed currentPosRatio\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Errors} from \\\"./errors.sol\\\";\\nimport {Events} from \\\"./events.sol\\\";\\nimport {Variables} from \\\"./variables.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\ncontract Helpers is Errors, Events, Variables {\\n    /***********************************|\\n    |              MODIFIERS            |\\n    |__________________________________*/\\n\\n    /// @dev Reverts if msg.sender is not owner or enabled rebalance.\\n    modifier onlyRebalancer() {\\n        if (!(isRebalancer[msg.sender] || owner == msg.sender)) {\\n            revert Helpers__NotRebalancer();\\n        }\\n        _;\\n    }\\n\\n    /// @dev Reverts if msg.sender is not owner.\\n    modifier onlyOwner() {\\n        if (owner != msg.sender) {\\n            revert Helpers__NotOwner();\\n        }\\n        _;\\n    }\\n\\n    /// @dev reentrancy gaurd.\\n    modifier nonReentrant() {\\n        if (_status == 2) revert Helpers__Reentrant();\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n\\n    /***********************************|\\n    |             DSA HELPERS           |\\n    |__________________________________*/\\n\\n    /**\\n     * @dev Admin Spell function\\n     * @param to_ target address\\n     * @param calldata_ function calldata\\n     * @param value_ function msg.value\\n     * @param operation_ .call or .delegate. (0 => .call, 1 => .delegateCall)\\n     */\\n    function spell(\\n        address to_,\\n        bytes memory calldata_,\\n        uint256 value_,\\n        uint256 operation_\\n    ) external payable onlyOwner {\\n        if (operation_ == 0) {\\n            // .call\\n            Address.functionCallWithValue(\\n                to_,\\n                calldata_,\\n                value_,\\n                \\\"spell: .call failed\\\"\\n            );\\n        } else if (operation_ == 1) {\\n            // .delegateCall\\n            Address.functionDelegateCall(\\n                to_,\\n                calldata_,\\n                \\\"spell: .delegateCall failed\\\"\\n            );\\n        } else {\\n            revert(\\\"no operation\\\");\\n        }\\n        emit LogDSASpell(to_, calldata_, value_, operation_);\\n    }\\n\\n    /**\\n     * @dev Admin function to add auth on DSA\\n     * @param auth_ new auth address for DSA\\n     */\\n    function addDSAAuth(address auth_) external onlyOwner {\\n        string[] memory targets_ = new string[](1);\\n        bytes[] memory calldata_ = new bytes[](1);\\n        targets_[0] = \\\"AUTHORITY-A\\\";\\n        calldata_[0] = abi.encodeWithSignature(\\\"add(address)\\\", auth_);\\n        vaultDSA.cast(targets_, calldata_, address(this));\\n\\n        emit LogAddDSAAuthority(auth_);\\n    }\\n\\n    /**\\n     * @dev Returns current position ratio\\n     */\\n    function getPositionRatio()\\n        public\\n        view\\n        returns (\\n            uint256 weETHAmount_,\\n            uint256 eETHAmount_,\\n            uint256 wethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        weETHAmount_ = IERC20(A_WEETH_ADDRESS).balanceOf(address(vaultDSA));\\n        eETHAmount_ = IWEETH(WEETH_ADDRESS).getEETHByWeETH(weETHAmount_);\\n        wethAmount_ = IERC20(D_WETH_ADDRESS).balanceOf(address(vaultDSA));\\n\\n        ratio_ = eETHAmount_ == 0 ? 0 : (wethAmount_ * 1e6) / eETHAmount_;\\n    }\\n\\n    function wethReserveData()\\n        public\\n        view\\n        returns (uint256 availableLiquidity_)\\n    {\\n        (\\n            ,\\n            ,\\n            uint256 totalATokens_,\\n            uint256 totalStableDebt_,\\n            uint256 totalVariableDebt_,\\n            ,\\n            ,\\n            ,\\n            ,\\n            ,\\n            ,\\n\\n        ) = AAVE_V3_DATA_PROVIDER.getReserveData(WETH_ADDRESS);\\n\\n        availableLiquidity_ =\\n            totalATokens_ -\\n            totalStableDebt_ -\\n            totalVariableDebt_;\\n    }\\n\\n    function getWeETHData()\\n        public\\n        view\\n        returns (uint256 weETHSupplyCap_, uint256 weETHSupplied_)\\n    {\\n        // In token amounts, not wei\\n        (, uint256 weETHSupplyCapTokens_) = AAVE_V3_DATA_PROVIDER\\n            .getReserveCaps(WEETH_ADDRESS);\\n\\n        weETHSupplyCap_ = weETHSupplyCapTokens_ * 1e18;\\n\\n        weETHSupplied_ = IERC20(A_WEETH_ADDRESS).totalSupply();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IInstaIndex {\\n    function build(\\n        address owner_,\\n        uint256 accountVersion_,\\n        address origin_\\n    ) external returns (address account_);\\n}\\n\\ninterface IDSA {\\n    function cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32);\\n}\\n\\ninterface IProxy {\\n    function owner() external view returns (address);\\n}\\n\\ninterface IWEETH {\\n    /// @notice Fetches the amount of eEth respective to the amount of weEth sent in\\n    /// @param _weETHAmount amount sent in\\n    /// @return The total amount for the number of shares sent in\\n    function getEETHByWeETH(\\n        uint256 _weETHAmount\\n    ) external view returns (uint256);\\n}\\n\\ninterface IAaveV3ProtocolDataProvider {\\n    function getReserveConfigurationData(\\n        address asset\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 decimals,\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            uint256 reserveFactor,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive,\\n            bool isFrozen\\n        );\\n\\n    function getReserveData(\\n        address asset\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 unbacked,\\n            uint256 accruedToTreasuryScaled,\\n            uint256 totalAToken,\\n            uint256 totalStableDebt,\\n            uint256 totalVariableDebt,\\n            uint256 liquidityRate,\\n            uint256 variableBorrowRate,\\n            uint256 stableBorrowRate,\\n            uint256 averageStableBorrowRate,\\n            uint256 liquidityIndex,\\n            uint256 variableBorrowIndex,\\n            uint40 lastUpdateTimestamp\\n        );\\n\\n    function getReserveCaps(\\n        address asset\\n    ) external view returns (uint256 borrowCap, uint256 supplyCap);\\n}\\n\\ninterface IAaveV3Governance {\\n    function executeProposal(uint256 proposalId) external;\\n}\\n\\ninterface IAaveV3PayloadsController {\\n    function executePayload(uint40 payloadId) external payable;\\n}\"\r\n    },\r\n    \"contracts/main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Helpers} from \\\"./helpers.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract OwnerContract is Helpers {\\n    /// @notice Initializes the contract owner.\\n    function setOwner(address owner_) public {\\n        if (_status != 0) {\\n            revert OwnerContract__AlreadyInitialized();\\n        }\\n        owner = owner_;\\n\\n        _status = 1;\\n        emit LogSetOwner(owner_);\\n    }\\n\\n    /// @notice Updates the current owner.\\n    function updateOwner(address owner_) public onlyOwner {\\n        address oldOwner_ = owner;\\n        owner = owner_;\\n        emit LogUpdateOwner(oldOwner_, owner_);\\n    }\\n\\n    /// @notice Sets the vault DSA address.\\n    function setVaultDSA(address vaultDSA_) public onlyOwner {\\n        vaultDSA = IDSA(vaultDSA_);\\n        emit LogSetVaultDSA(vaultDSA_);\\n    }\\n\\n    /// @notice Enables and disables rebalancers.\\n    function updateRebalancer(\\n        address rebalancer_,\\n        bool isRebalancer_\\n    ) public onlyOwner {\\n        isRebalancer[rebalancer_] = isRebalancer_;\\n        emit LogUpdateRebalancer(rebalancer_, isRebalancer_);\\n    }\\n\\n    /// @notice Update maximum ratio allowed by the position.\\n    /// Note Sent value should be scaled by 1e4. i.e. 100% = 1e6\\n    function updateMaxPosRatio(uint256 maxPosRatio_) public onlyOwner {\\n        uint256 oldRatio_ = maxPosRatio;\\n        maxPosRatio = maxPosRatio_;\\n\\n        emit LogUpdateMaxRatio(oldRatio_, maxPosRatio_);\\n    }\\n}\\n\\ncontract WeethStrategyContract is OwnerContract {\\n\\n    constructor() {\\n        // Setting vault status as open and other configs.\\n        setOwner(0xF27D8028e5E2573637874BDaa4f5DDf92b708f63);\\n        // Manually setting up as all these functions are called by onlyOwner.\\n        // setVaultDSA\\n        vaultDSA = IDSA(0xD2c2D8D34dB094947919d7d0c3a5cd57883aA50c);\\n        // updateRebalancer\\n        isRebalancer[0xad5A93B6A6baA3D9bf7a5E28d63d0E25c165bcAA] = true;\\n        isRebalancer[0x10F37Ceb965B477bA09d23FF725E0a0f1cdb83a5] = true;\\n        // updateMaxPosRatio\\n        maxPosRatio = 920000;\\n    }\\n\\n    // Helper struct for leverage\\n    struct LeverageHelper {\\n        uint256 spellIndex;\\n        uint256 spellsLength;\\n        string[] targets;\\n        bytes[] calldatas;\\n        uint256 WEETHSupplyCap;\\n        uint256 WEETHSupplyAave;\\n        uint256 wethAvailableLiquidity;\\n        uint256 wethDSABal;\\n        uint256 leverageFactor;\\n    }\\n\\n    /// @notice Function to run leverage of weETH <> eth.\\n    /// Internally factors in the weETH supply availability and wETH borrow availability.\\n    function leverage() external onlyRebalancer nonReentrant {\\n        try IAaveV3PayloadsController(AAVE_V3_PAYLOADS_CONTROLLER).executePayload(118) {} catch { \\n            // Error intentionally ignored\\n        }\\n\\n        try IAaveV3Governance(AAVE_V3_GOVERNANCE).executeProposal(95) {} catch { \\n            // Error intentionally ignored\\n        }\\n\\n        LeverageHelper memory lev_;\\n\\n        (, uint256 posEETH_, uint256 posWeth_, uint256 currentRatio_) = getPositionRatio();\\n\\n        if (currentRatio_ >= maxPosRatio) {\\n            revert WeethStrategyContract__MaxLeveraged();\\n        }\\n\\n        // WEETH\\n        (lev_.WEETHSupplyCap, lev_.WEETHSupplyAave) = getWeETHData();\\n        // WETH\\n        lev_.wethAvailableLiquidity = wethReserveData();\\n\\n        uint256 WEETHSupplyAaveWithBuffer_ = lev_.WEETHSupplyAave + 1e18;\\n\\n        // Check if the supply cap is reached with a buffer of 1e18\\n        if (WEETHSupplyAaveWithBuffer_ > lev_.WEETHSupplyCap) {\\n            revert WeethStrategyContract__SupplyCapReached();\\n        }\\n\\n        /// @dev Calculate the flash amount in weETH and weth.\\n        uint256 supplyAvailableInWEETH_ = lev_.WEETHSupplyCap -\\n            WEETHSupplyAaveWithBuffer_;\\n        // Supply of WEETH available in Aave (expressed in terms of WETH).\\n        uint256 supplyAvailableInWeth_ = IWEETH(WEETH_ADDRESS).getEETHByWeETH(\\n            supplyAvailableInWEETH_\\n        );\\n\\n        if (supplyAvailableInWeth_ < MIN_LIMIT_AVAILABILITY) {\\n            revert WeethStrategyContract__MinAvailabilityNotReached();\\n        }\\n        \\n        lev_.wethDSABal = IERC20(WETH_ADDRESS).balanceOf(address(vaultDSA));\\n        lev_.leverageFactor = 1e6 / (1e6 - maxPosRatio);\\n        uint256 wethFlashAmount_;\\n\\n        if(posWeth_ > 0) {\\n            uint256 colCoveringDebt_ = ((posWeth_ * 1e6) / maxPosRatio);\\n            uint256 colIdle_ = (posEETH_ - colCoveringDebt_) + lev_.wethDSABal;\\n            uint256 newDebtBorrow_ = colIdle_ * (lev_.leverageFactor - 1);\\n\\n            wethFlashAmount_ =\\n                supplyAvailableInWeth_ > newDebtBorrow_ \\n                ? newDebtBorrow_ \\n                : supplyAvailableInWeth_;\\n        } else {\\n            uint256 wethFlashAmount1_ = supplyAvailableInWeth_ - lev_.wethDSABal;\\n            uint256 wethFlashAmount2_ = (lev_.leverageFactor * lev_.wethDSABal) - lev_.wethDSABal;\\n            \\n            wethFlashAmount_ = wethFlashAmount1_ < wethFlashAmount2_\\n                ? wethFlashAmount1_\\n                : wethFlashAmount2_;\\n        }\\n\\n        if (lev_.wethAvailableLiquidity < wethFlashAmount_) {\\n            revert WeethStrategyContract__NoBorrowingAvailability();\\n        }\\n\\n        /*\\n         * Mint eeth with wETH\\n         * Wrap eeth to weETH\\n         * Deposit weETH to Aave V3\\n         * Borrow wETH\\n         * Flashpayback wETH\\n         */\\n        lev_.spellsLength = 5;\\n\\n        lev_.targets = new string[](lev_.spellsLength);\\n        lev_.calldatas = new bytes[](lev_.spellsLength);\\n\\n        /***********************************|\\n        |         MINT EETH WITH WETH       |\\n        |__________________________________*/\\n\\n        lev_.targets[lev_.spellIndex] = \\\"EETH-A\\\";\\n        lev_.calldatas[lev_.spellIndex] = abi.encodeWithSignature(\\n            \\\"depositWeth(uint256,uint256,uint256)\\\",\\n            type(uint256).max, // Deposit all the WETH flashloan amount to mint eETH.\\n            0,\\n            0\\n        );\\n        lev_.spellIndex++;\\n\\n        /***********************************|\\n        |              WRAP EETH            |\\n        |__________________________________*/\\n\\n        lev_.targets[lev_.spellIndex] = \\\"WEETH-A\\\";\\n        lev_.calldatas[lev_.spellIndex] = abi.encodeWithSignature(\\n            \\\"deposit(uint256,uint256,uint256)\\\",\\n            type(uint256).max, // Wrap all the eETH amount.\\n            0,\\n            0\\n        );\\n        lev_.spellIndex++;\\n\\n        /***********************************|\\n        |       DEPOSIT WEETH TO AAVE V3    |\\n        |__________________________________*/\\n\\n        lev_.targets[lev_.spellIndex] = \\\"AAVE-V3-A\\\";\\n        lev_.calldatas[lev_.spellIndex] = abi.encodeWithSignature(\\n            \\\"deposit(address,uint256,uint256,uint256)\\\",\\n            WEETH_ADDRESS,\\n            type(uint256).max, // Deposit all the weETH to Aave V3\\n            0,\\n            0\\n        );\\n        lev_.spellIndex++;\\n\\n        /***********************************|\\n        |             BORROW WETH           |\\n        |__________________________________*/\\n\\n        lev_.targets[lev_.spellIndex] = \\\"AAVE-V3-A\\\";\\n        lev_.calldatas[lev_.spellIndex] = abi.encodeWithSignature(\\n            \\\"borrow(address,uint256,uint256,uint256,uint256)\\\",\\n            WETH_ADDRESS,\\n            wethFlashAmount_,\\n            2,\\n            0,\\n            0\\n        );\\n        lev_.spellIndex++;\\n\\n        /***********************************|\\n        |         FLASHPAYBACK WETH         |\\n        |__________________________________*/\\n\\n        lev_.targets[lev_.spellIndex] = \\\"INSTAPOOL-D\\\";\\n        lev_.calldatas[lev_.spellIndex] = abi.encodeWithSignature(\\n            \\\"flashPayback(address,uint256,uint256,uint256)\\\",\\n            WETH_ADDRESS,\\n            wethFlashAmount_,\\n            0,\\n            0\\n        );\\n        lev_.spellIndex++;\\n\\n        bytes memory encodedFlashData_ = abi.encode(\\n            lev_.targets,\\n            lev_.calldatas\\n        );\\n\\n        /***********************************|\\n        |           FLASHLOAN WETH          |\\n        |__________________________________*/\\n        string[] memory flashTarget = new string[](1);\\n        bytes[] memory flashCalldata = new bytes[](1);\\n        flashTarget[0] = \\\"INSTAPOOL-D\\\";\\n        flashCalldata[0] = abi.encodeWithSignature(\\n            \\\"flashBorrowAndCast(address,uint256,uint256,bytes,bytes)\\\",\\n            WETH_ADDRESS,\\n            wethFlashAmount_,\\n            10,\\n            encodedFlashData_,\\n            \\\"0x\\\"\\n        );\\n\\n        vaultDSA.cast(flashTarget, flashCalldata, address(this));\\n\\n        (, uint256 currentEETHCol_, , uint256 currentPosRatio_) = getPositionRatio();\\n\\n        if (currentPosRatio_ > maxPosRatio) {\\n            revert WeethStrategyContract__PosExceededRatio();\\n        }\\n\\n        emit LogLeverage(currentEETHCol_, wethFlashAmount_, currentPosRatio_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/variables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract ConstantVariables {\\n    IInstaIndex internal constant INSTA_INDEX_CONTRACT =\\n        IInstaIndex(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\\n\\n    address internal constant WEETH_ADDRESS =\\n        0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\\n\\n    address internal constant WETH_ADDRESS =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    address internal constant A_WEETH_ADDRESS =\\n        0xBdfa7b7893081B35Fb54027489e2Bc7A38275129;\\n\\n    address internal constant D_WETH_ADDRESS =\\n        0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;\\n    \\n    address internal constant AAVE_V3_GOVERNANCE =\\n        0x9AEE0B04504CeF83A65AC3f0e838D0593BCb2BC7;\\n\\n    address internal constant AAVE_V3_PAYLOADS_CONTROLLER =\\n        0xdAbad81aF85554E9ae636395611C58F7eC1aAEc5;\\n\\n    // 100 min weETH availability\\n    uint256 internal constant MIN_LIMIT_AVAILABILITY = 100000000000000000000;\\n\\n    IAaveV3ProtocolDataProvider internal constant AAVE_V3_DATA_PROVIDER =\\n        IAaveV3ProtocolDataProvider(0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3);\\n}\\n\\ncontract Variables is ConstantVariables {\\n    // 0: closed; 1: open\\n    uint256 internal _status;\\n\\n    address public owner;\\n\\n    IDSA public vaultDSA;\\n\\n    /// @notice mapping to store allowed rebalancers\\n    ///         modifiable by auth\\n    mapping(address => bool) public isRebalancer;\\n\\n    /// @notice max ratio that the position can reach after leverage.\\n    uint256 public maxPosRatio;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Helpers__InvalidParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__NotRebalancer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerContract__AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WeethStrategyContract__MaxLeveraged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WeethStrategyContract__MinAvailabilityNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WeethStrategyContract__NoBorrowingAvailability\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WeethStrategyContract__PosExceededRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WeethStrategyContract__SupplyCapReached\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"LogAddDSAAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operation\",\"type\":\"uint256\"}],\"name\":\"LogDSASpell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"wETHCollAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"wETHBorrowAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentPosRatio\",\"type\":\"uint256\"}],\"name\":\"LogLeverage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultDSA\",\"type\":\"address\"}],\"name\":\"LogSetVaultDSA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxPosRatioBefore\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxPosRatioAfter\",\"type\":\"uint256\"}],\"name\":\"LogUpdateMaxRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogUpdateOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isRebalancer\",\"type\":\"bool\"}],\"name\":\"LogUpdateRebalancer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auth_\",\"type\":\"address\"}],\"name\":\"addDSAAuth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPositionRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weETHAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eETHAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeETHData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weETHSupplyCap_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weETHSupplied_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRebalancer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPosRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultDSA_\",\"type\":\"address\"}],\"name\":\"setVaultDSA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldata_\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operation_\",\"type\":\"uint256\"}],\"name\":\"spell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPosRatio_\",\"type\":\"uint256\"}],\"name\":\"updateMaxPosRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rebalancer_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRebalancer_\",\"type\":\"bool\"}],\"name\":\"updateRebalancer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultDSA\",\"outputs\":[{\"internalType\":\"contract IDSA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethReserveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableLiquidity_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WeethStrategyContract", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}