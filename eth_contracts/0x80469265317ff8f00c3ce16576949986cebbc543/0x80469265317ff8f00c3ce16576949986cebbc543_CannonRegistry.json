{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@synthetixio/core-contracts/contracts/errors/AccessError.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title Library for access related errors.\\n */\\nlibrary AccessError {\\n    /**\\n     * @dev Thrown when an address tries to perform an unauthorized action.\\n     * @param addr The address that attempts the action.\\n     */\\n    error Unauthorized(address addr);\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/errors/AddressError.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title Library for address related errors.\\n */\\nlibrary AddressError {\\n    /**\\n     * @dev Thrown when a zero address was passed as a function parameter (0x0000000000000000000000000000000000000000).\\n     */\\n    error ZeroAddress();\\n\\n    /**\\n     * @dev Thrown when an address representing a contract is expected, but no code is found at the address.\\n     * @param contr The address that was expected to be a contract.\\n     */\\n    error NotAContract(address contr);\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/errors/ChangeError.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title Library for change related errors.\\n */\\nlibrary ChangeError {\\n    /**\\n     * @dev Thrown when a change is expected but none is detected.\\n     */\\n    error NoChange();\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title Contract for facilitating ownership by a single address.\\n */\\ninterface IOwnable {\\n    /**\\n     * @notice Thrown when an address tries to accept ownership but has not been nominated.\\n     * @param addr The address that is trying to accept ownership.\\n     */\\n    error NotNominated(address addr);\\n\\n    /**\\n     * @notice Emitted when an address has been nominated.\\n     * @param newOwner The address that has been nominated.\\n     */\\n    event OwnerNominated(address newOwner);\\n\\n    /**\\n     * @notice Emitted when the owner of the contract has changed.\\n     * @param oldOwner The previous owner of the contract.\\n     * @param newOwner The new owner of the contract.\\n     */\\n    event OwnerChanged(address oldOwner, address newOwner);\\n\\n    /**\\n     * @notice Allows a nominated address to accept ownership of the contract.\\n     * @dev Reverts if the caller is not nominated.\\n     */\\n    function acceptOwnership() external;\\n\\n    /**\\n     * @notice Allows the current owner to nominate a new owner.\\n     * @dev The nominated owner will have to call `acceptOwnership` in a separate transaction in order to finalize the action and become the new contract owner.\\n     * @param newNominatedOwner The address that is to become nominated.\\n     */\\n    function nominateNewOwner(address newNominatedOwner) external;\\n\\n    /**\\n     * @notice Allows a nominated owner to reject the nomination.\\n     */\\n    function renounceNomination() external;\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the current nominated owner of the contract.\\n     * @dev Only one address can be nominated at a time.\\n     */\\n    function nominatedOwner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/interfaces/IUUPSImplementation.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title Contract to be used as the implementation of a Universal Upgradeable Proxy Standard (UUPS) proxy.\\n *\\n * Important: A UUPS proxy requires its upgradeability functions to be in the implementation as opposed to the proxy. This means that if the proxy is upgraded to an implementation that does not support this interface, it will no longer be upgradeable.\\n */\\ninterface IUUPSImplementation {\\n    /**\\n     * @notice Thrown when an incoming implementation will not be able to receive future upgrades.\\n     */\\n    error ImplementationIsSterile(address implementation);\\n\\n    /**\\n     * @notice Thrown intentionally when testing future upgradeability of an implementation.\\n     */\\n    error UpgradeSimulationFailed();\\n\\n    /**\\n     * @notice Emitted when the implementation of the proxy has been upgraded.\\n     * @param self The address of the proxy whose implementation was upgraded.\\n     * @param implementation The address of the proxy's new implementation.\\n     */\\n    event Upgraded(address indexed self, address implementation);\\n\\n    /**\\n     * @notice Allows the proxy to be upgraded to a new implementation.\\n     * @param newImplementation The address of the proxy's new implementation.\\n     * @dev Will revert if `newImplementation` is not upgradeable.\\n     * @dev The implementation of this function needs to be protected by some sort of access control such as `onlyOwner`.\\n     */\\n    function upgradeTo(address newImplementation) external;\\n\\n    /**\\n     * @notice Function used to determine if a new implementation will be able to receive future upgrades in `upgradeTo`.\\n     * @param newImplementation The address of the new implementation being tested for future upgradeability.\\n     * @dev This function will always revert, but will revert with different error messages. The function `upgradeTo` uses this error to determine the future upgradeability of the implementation in question.\\n     */\\n    function simulateUpgradeTo(address newImplementation) external;\\n\\n    /**\\n     * @notice Retrieves the current implementation of the proxy.\\n     * @return The address of the current implementation.\\n     */\\n    function getImplementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\nimport \\\"./OwnableStorage.sol\\\";\\nimport \\\"../interfaces/IOwnable.sol\\\";\\nimport \\\"../errors/AddressError.sol\\\";\\nimport \\\"../errors/ChangeError.sol\\\";\\n\\n/**\\n * @title Contract for facilitating ownership by a single address.\\n * See IOwnable.\\n */\\ncontract Ownable is IOwnable {\\n    /**\\n     * @inheritdoc IOwnable\\n     */\\n    function acceptOwnership() public override {\\n        OwnableStorage.Data storage store = OwnableStorage.load();\\n\\n        address currentNominatedOwner = store.nominatedOwner;\\n        if (msg.sender != currentNominatedOwner) {\\n            revert NotNominated(msg.sender);\\n        }\\n\\n        emit OwnerChanged(store.owner, currentNominatedOwner);\\n        store.owner = currentNominatedOwner;\\n\\n        store.nominatedOwner = address(0);\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnable\\n     */\\n    function nominateNewOwner(address newNominatedOwner) public override onlyOwnerIfSet {\\n        OwnableStorage.Data storage store = OwnableStorage.load();\\n\\n        if (newNominatedOwner == address(0)) {\\n            revert AddressError.ZeroAddress();\\n        }\\n\\n        if (newNominatedOwner == store.nominatedOwner) {\\n            revert ChangeError.NoChange();\\n        }\\n\\n        store.nominatedOwner = newNominatedOwner;\\n        emit OwnerNominated(newNominatedOwner);\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnable\\n     */\\n    function renounceNomination() external override {\\n        OwnableStorage.Data storage store = OwnableStorage.load();\\n\\n        if (store.nominatedOwner != msg.sender) {\\n            revert NotNominated(msg.sender);\\n        }\\n\\n        store.nominatedOwner = address(0);\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnable\\n     */\\n    function owner() external view override returns (address) {\\n        return OwnableStorage.load().owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnable\\n     */\\n    function nominatedOwner() external view override returns (address) {\\n        return OwnableStorage.load().nominatedOwner;\\n    }\\n\\n    /**\\n     * @dev Reverts if the caller is not the owner.\\n     */\\n    modifier onlyOwner() {\\n        OwnableStorage.onlyOwner();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the caller is not the owner, except if it is not set yet.\\n     */\\n    modifier onlyOwnerIfSet() {\\n        address theOwner = OwnableStorage.getOwner();\\n\\n        // if owner is set then check if msg.sender is the owner\\n        if (theOwner != address(0)) {\\n            OwnableStorage.onlyOwner();\\n        }\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\nimport \\\"../errors/AccessError.sol\\\";\\n\\nlibrary OwnableStorage {\\n    bytes32 private constant _SLOT_OWNABLE_STORAGE =\\n        keccak256(abi.encode(\\\"io.synthetix.core-contracts.Ownable\\\"));\\n\\n    struct Data {\\n        bool initialized;\\n        address owner;\\n        address nominatedOwner;\\n    }\\n\\n    function load() internal pure returns (Data storage store) {\\n        bytes32 s = _SLOT_OWNABLE_STORAGE;\\n        assembly {\\n            store.slot := s\\n        }\\n    }\\n\\n    function onlyOwner() internal view {\\n        if (msg.sender != getOwner()) {\\n            revert AccessError.Unauthorized(msg.sender);\\n        }\\n    }\\n\\n    function getOwner() internal view returns (address) {\\n        return OwnableStorage.load().owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/proxy/ProxyStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\ncontract ProxyStorage {\\n    bytes32 private constant _SLOT_PROXY_STORAGE =\\n        keccak256(abi.encode(\\\"io.synthetix.core-contracts.Proxy\\\"));\\n\\n    struct ProxyStore {\\n        address implementation;\\n        bool simulatingUpgrade;\\n    }\\n\\n    function _proxyStore() internal pure returns (ProxyStore storage store) {\\n        bytes32 s = _SLOT_PROXY_STORAGE;\\n        assembly {\\n            store.slot := s\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\nimport \\\"../interfaces/IUUPSImplementation.sol\\\";\\nimport \\\"../errors/AddressError.sol\\\";\\nimport \\\"../errors/ChangeError.sol\\\";\\nimport \\\"../utils/AddressUtil.sol\\\";\\nimport \\\"./ProxyStorage.sol\\\";\\n\\nabstract contract UUPSImplementation is IUUPSImplementation, ProxyStorage {\\n    /**\\n     * @inheritdoc IUUPSImplementation\\n     */\\n    function simulateUpgradeTo(address newImplementation) public override {\\n        ProxyStore storage store = _proxyStore();\\n\\n        store.simulatingUpgrade = true;\\n\\n        address currentImplementation = store.implementation;\\n        store.implementation = newImplementation;\\n\\n        (bool rollbackSuccessful, ) = newImplementation.delegatecall(\\n            abi.encodeCall(this.upgradeTo, (currentImplementation))\\n        );\\n\\n        if (!rollbackSuccessful || _proxyStore().implementation != currentImplementation) {\\n            revert UpgradeSimulationFailed();\\n        }\\n\\n        store.simulatingUpgrade = false;\\n\\n        // solhint-disable-next-line reason-string\\n        revert();\\n    }\\n\\n    /**\\n     * @inheritdoc IUUPSImplementation\\n     */\\n    function getImplementation() external view override returns (address) {\\n        return _proxyStore().implementation;\\n    }\\n\\n    function _upgradeTo(address newImplementation) internal virtual {\\n        if (newImplementation == address(0)) {\\n            revert AddressError.ZeroAddress();\\n        }\\n\\n        if (!AddressUtil.isContract(newImplementation)) {\\n            revert AddressError.NotAContract(newImplementation);\\n        }\\n\\n        ProxyStore storage store = _proxyStore();\\n\\n        if (newImplementation == store.implementation) {\\n            revert ChangeError.NoChange();\\n        }\\n\\n        if (!store.simulatingUpgrade && _implementationIsSterile(newImplementation)) {\\n            revert ImplementationIsSterile(newImplementation);\\n        }\\n\\n        store.implementation = newImplementation;\\n\\n        emit Upgraded(address(this), newImplementation);\\n    }\\n\\n    function _implementationIsSterile(\\n        address candidateImplementation\\n    ) internal virtual returns (bool) {\\n        (bool simulationReverted, bytes memory simulationResponse) = address(this).delegatecall(\\n            abi.encodeCall(this.simulateUpgradeTo, (candidateImplementation))\\n        );\\n\\n        return\\n            !simulationReverted &&\\n            keccak256(abi.encodePacked(simulationResponse)) ==\\n            keccak256(abi.encodePacked(UpgradeSimulationFailed.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/AddressUtil.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\nlibrary AddressUtil {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * Utilities that convert numeric types avoiding silent overflows.\\n */\\nimport \\\"./SafeCast/SafeCastU32.sol\\\";\\nimport \\\"./SafeCast/SafeCastI32.sol\\\";\\nimport \\\"./SafeCast/SafeCastI24.sol\\\";\\nimport \\\"./SafeCast/SafeCastU56.sol\\\";\\nimport \\\"./SafeCast/SafeCastI56.sol\\\";\\nimport \\\"./SafeCast/SafeCastU64.sol\\\";\\nimport \\\"./SafeCast/SafeCastI128.sol\\\";\\nimport \\\"./SafeCast/SafeCastI256.sol\\\";\\nimport \\\"./SafeCast/SafeCastU128.sol\\\";\\nimport \\\"./SafeCast/SafeCastU160.sol\\\";\\nimport \\\"./SafeCast/SafeCastU256.sol\\\";\\nimport \\\"./SafeCast/SafeCastAddress.sol\\\";\\nimport \\\"./SafeCast/SafeCastBytes32.sol\\\";\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastAddress.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastAddress {\\n    function toBytes32(address x) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(x)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastBytes32.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastBytes32 {\\n    function toAddress(bytes32 x) internal pure returns (address) {\\n        return address(uint160(uint256(x)));\\n    }\\n\\n    function toUint(bytes32 x) internal pure returns (uint) {\\n        return uint(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI128.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastI128 {\\n    error OverflowInt128ToUint128();\\n    error OverflowInt128ToInt32();\\n\\n    function toUint(int128 x) internal pure returns (uint128) {\\n        // ----------------<==============o==============>-----------------\\n        // ----------------xxxxxxxxxxxxxxxo===============>----------------\\n        if (x < 0) {\\n            revert OverflowInt128ToUint128();\\n        }\\n\\n        return uint128(x);\\n    }\\n\\n    function to256(int128 x) internal pure returns (int256) {\\n        return int256(x);\\n    }\\n\\n    function to32(int128 x) internal pure returns (int32) {\\n        // ----------------<==============o==============>-----------------\\n        // ----------------xxxxxxxxxxxx<==o==>xxxxxxxxxxxx-----------------\\n        if (x < int(type(int32).min) || x > int(type(int32).max)) {\\n            revert OverflowInt128ToInt32();\\n        }\\n\\n        return int32(x);\\n    }\\n\\n    function zero() internal pure returns (int128) {\\n        return int128(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI24.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastI24 {\\n    function to256(int24 x) internal pure returns (int256) {\\n        return int256(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI256.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastI256 {\\n    error OverflowInt256ToUint256();\\n    error OverflowInt256ToInt128();\\n    error OverflowInt256ToInt24();\\n\\n    function to128(int256 x) internal pure returns (int128) {\\n        // ----<==========================o===========================>----\\n        // ----xxxxxxxxxxxx<==============o==============>xxxxxxxxxxxxx----\\n        if (x < int256(type(int128).min) || x > int256(type(int128).max)) {\\n            revert OverflowInt256ToInt128();\\n        }\\n\\n        return int128(x);\\n    }\\n\\n    function to24(int256 x) internal pure returns (int24) {\\n        // ----<==========================o===========================>----\\n        // ----xxxxxxxxxxxxxxxxxxxx<======o=======>xxxxxxxxxxxxxxxxxxxx----\\n        if (x < int256(type(int24).min) || x > int256(type(int24).max)) {\\n            revert OverflowInt256ToInt24();\\n        }\\n\\n        return int24(x);\\n    }\\n\\n    function toUint(int256 x) internal pure returns (uint256) {\\n        // ----<==========================o===========================>----\\n        // ----xxxxxxxxxxxxxxxxxxxxxxxxxxxo===============================>\\n        if (x < 0) {\\n            revert OverflowInt256ToUint256();\\n        }\\n\\n        return uint256(x);\\n    }\\n\\n    function zero() internal pure returns (int256) {\\n        return int256(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI32.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastI32 {\\n    error OverflowInt32ToUint32();\\n\\n    function toUint(int32 x) internal pure returns (uint32) {\\n        // ----------------------<========o========>----------------------\\n        // ----------------------xxxxxxxxxo=========>----------------------\\n        if (x < 0) {\\n            revert OverflowInt32ToUint32();\\n        }\\n\\n        return uint32(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI56.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastI56 {\\n    error OverflowInt56ToInt24();\\n\\n    function to24(int56 x) internal pure returns (int24) {\\n        // ----------------------<========o========>-----------------------\\n        // ----------------------xxx<=====o=====>xxx-----------------------\\n        if (x < int(type(int24).min) || x > int(type(int24).max)) {\\n            revert OverflowInt56ToInt24();\\n        }\\n\\n        return int24(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU128.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastU128 {\\n    error OverflowUint128ToInt128();\\n\\n    function to256(uint128 x) internal pure returns (uint256) {\\n        return uint256(x);\\n    }\\n\\n    function toInt(uint128 x) internal pure returns (int128) {\\n        // -------------------------------o===============>----------------\\n        // ----------------<==============o==============>x----------------\\n        if (x > uint128(type(int128).max)) {\\n            revert OverflowUint128ToInt128();\\n        }\\n\\n        return int128(x);\\n    }\\n\\n    function toBytes32(uint128 x) internal pure returns (bytes32) {\\n        return bytes32(uint256(x));\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU160.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastU160 {\\n    function to256(uint160 x) internal pure returns (uint256) {\\n        return uint256(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU256.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastU256 {\\n    error OverflowUint256ToUint128();\\n    error OverflowUint256ToInt256();\\n    error OverflowUint256ToUint64();\\n    error OverflowUint256ToUint32();\\n    error OverflowUint256ToUint160();\\n\\n    function to128(uint256 x) internal pure returns (uint128) {\\n        // -------------------------------o===============================>\\n        // -------------------------------o===============>xxxxxxxxxxxxxxxx\\n        if (x > type(uint128).max) {\\n            revert OverflowUint256ToUint128();\\n        }\\n\\n        return uint128(x);\\n    }\\n\\n    function to64(uint256 x) internal pure returns (uint64) {\\n        // -------------------------------o===============================>\\n        // -------------------------------o======>xxxxxxxxxxxxxxxxxxxxxxxxx\\n        if (x > type(uint64).max) {\\n            revert OverflowUint256ToUint64();\\n        }\\n\\n        return uint64(x);\\n    }\\n\\n    function to32(uint256 x) internal pure returns (uint32) {\\n        // -------------------------------o===============================>\\n        // -------------------------------o===>xxxxxxxxxxxxxxxxxxxxxxxxxxxx\\n        if (x > type(uint32).max) {\\n            revert OverflowUint256ToUint32();\\n        }\\n\\n        return uint32(x);\\n    }\\n\\n    function to160(uint256 x) internal pure returns (uint160) {\\n        // -------------------------------o===============================>\\n        // -------------------------------o==================>xxxxxxxxxxxxx\\n        if (x > type(uint160).max) {\\n            revert OverflowUint256ToUint160();\\n        }\\n\\n        return uint160(x);\\n    }\\n\\n    function toBytes32(uint256 x) internal pure returns (bytes32) {\\n        return bytes32(x);\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256) {\\n        // -------------------------------o===============================>\\n        // ----<==========================o===========================>xxxx\\n        if (x > uint256(type(int256).max)) {\\n            revert OverflowUint256ToInt256();\\n        }\\n\\n        return int256(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU32.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastU32 {\\n    error OverflowUint32ToInt32();\\n\\n    function toInt(uint32 x) internal pure returns (int32) {\\n        // -------------------------------o=========>----------------------\\n        // ----------------------<========o========>x----------------------\\n        if (x > uint32(type(int32).max)) {\\n            revert OverflowUint32ToInt32();\\n        }\\n\\n        return int32(x);\\n    }\\n\\n    function to256(uint32 x) internal pure returns (uint256) {\\n        return uint256(x);\\n    }\\n\\n    function to56(uint32 x) internal pure returns (uint56) {\\n        return uint56(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU56.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastU56 {\\n    error OverflowUint56ToInt56();\\n\\n    function toInt(uint56 x) internal pure returns (int56) {\\n        // -------------------------------o=========>----------------------\\n        // ----------------------<========o========>x----------------------\\n        if (x > uint56(type(int56).max)) {\\n            revert OverflowUint56ToInt56();\\n        }\\n\\n        return int56(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU64.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\n/**\\n * @title See SafeCast.sol.\\n */\\nlibrary SafeCastU64 {\\n    error OverflowUint64ToInt64();\\n\\n    function toInt(uint64 x) internal pure returns (int64) {\\n        // -------------------------------o=========>----------------------\\n        // ----------------------<========o========>x----------------------\\n        if (x > uint64(type(int64).max)) {\\n            revert OverflowUint64ToInt64();\\n        }\\n\\n        return int64(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@synthetixio/core-contracts/contracts/utils/SetUtil.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11 <0.9.0;\\n\\nimport \\\"./SafeCast.sol\\\";\\n\\nlibrary SetUtil {\\n    using SafeCastAddress for address;\\n    using SafeCastBytes32 for bytes32;\\n    using SafeCastU256 for uint256;\\n\\n    // ----------------------------------------\\n    // Uint support\\n    // ----------------------------------------\\n\\n    struct UintSet {\\n        Bytes32Set raw;\\n    }\\n\\n    function add(UintSet storage set, uint value) internal {\\n        add(set.raw, value.toBytes32());\\n    }\\n\\n    function remove(UintSet storage set, uint value) internal {\\n        remove(set.raw, value.toBytes32());\\n    }\\n\\n    function replace(UintSet storage set, uint value, uint newValue) internal {\\n        replace(set.raw, value.toBytes32(), newValue.toBytes32());\\n    }\\n\\n    function contains(UintSet storage set, uint value) internal view returns (bool) {\\n        return contains(set.raw, value.toBytes32());\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint) {\\n        return length(set.raw);\\n    }\\n\\n    function valueAt(UintSet storage set, uint position) internal view returns (uint) {\\n        return valueAt(set.raw, position).toUint();\\n    }\\n\\n    function positionOf(UintSet storage set, uint value) internal view returns (uint) {\\n        return positionOf(set.raw, value.toBytes32());\\n    }\\n\\n    function values(UintSet storage set) internal view returns (uint[] memory) {\\n        bytes32[] memory store = values(set.raw);\\n        uint[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // ----------------------------------------\\n    // Address support\\n    // ----------------------------------------\\n\\n    struct AddressSet {\\n        Bytes32Set raw;\\n    }\\n\\n    function add(AddressSet storage set, address value) internal {\\n        add(set.raw, value.toBytes32());\\n    }\\n\\n    function remove(AddressSet storage set, address value) internal {\\n        remove(set.raw, value.toBytes32());\\n    }\\n\\n    function replace(AddressSet storage set, address value, address newValue) internal {\\n        replace(set.raw, value.toBytes32(), newValue.toBytes32());\\n    }\\n\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return contains(set.raw, value.toBytes32());\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint) {\\n        return length(set.raw);\\n    }\\n\\n    function valueAt(AddressSet storage set, uint position) internal view returns (address) {\\n        return valueAt(set.raw, position).toAddress();\\n    }\\n\\n    function positionOf(AddressSet storage set, address value) internal view returns (uint) {\\n        return positionOf(set.raw, value.toBytes32());\\n    }\\n\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = values(set.raw);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // ----------------------------------------\\n    // Core bytes32 support\\n    // ----------------------------------------\\n\\n    error PositionOutOfBounds();\\n    error ValueNotInSet();\\n    error ValueAlreadyInSet();\\n\\n    struct Bytes32Set {\\n        bytes32[] _values;\\n        mapping(bytes32 => uint) _positions; // Position zero is never used.\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value) internal {\\n        if (contains(set, value)) {\\n            revert ValueAlreadyInSet();\\n        }\\n\\n        set._values.push(value);\\n        set._positions[value] = set._values.length;\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value) internal {\\n        uint position = set._positions[value];\\n        if (position == 0) {\\n            revert ValueNotInSet();\\n        }\\n\\n        uint index = position - 1;\\n        uint lastIndex = set._values.length - 1;\\n\\n        // If the element being deleted is not the last in the values,\\n        // move the last element to its position.\\n        if (index != lastIndex) {\\n            bytes32 lastValue = set._values[lastIndex];\\n\\n            set._values[index] = lastValue;\\n            set._positions[lastValue] = position;\\n        }\\n\\n        // Remove the last element in the values.\\n        set._values.pop();\\n        delete set._positions[value];\\n    }\\n\\n    function replace(Bytes32Set storage set, bytes32 value, bytes32 newValue) internal {\\n        if (!contains(set, value)) {\\n            revert ValueNotInSet();\\n        }\\n\\n        if (contains(set, newValue)) {\\n            revert ValueAlreadyInSet();\\n        }\\n\\n        uint position = set._positions[value];\\n        delete set._positions[value];\\n\\n        uint index = position - 1;\\n\\n        set._values[index] = newValue;\\n        set._positions[newValue] = position;\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint) {\\n        return set._values.length;\\n    }\\n\\n    function valueAt(Bytes32Set storage set, uint position) internal view returns (bytes32) {\\n        if (position == 0 || position > set._values.length) {\\n            revert PositionOutOfBounds();\\n        }\\n\\n        uint index = position - 1;\\n\\n        return set._values[index];\\n    }\\n\\n    function positionOf(Bytes32Set storage set, bytes32 value) internal view returns (uint) {\\n        if (!contains(set, value)) {\\n            revert ValueNotInSet();\\n        }\\n\\n        return set._positions[value];\\n    }\\n\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CannonRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {SetUtil} from \\\"@synthetixio/core-contracts/contracts/utils/SetUtil.sol\\\";\\nimport {OwnedUpgradable} from \\\"./OwnedUpgradable.sol\\\";\\nimport {EfficientStorage} from \\\"./EfficientStorage.sol\\\";\\nimport {ERC2771Context} from \\\"./ERC2771Context.sol\\\";\\nimport {IOptimismL1Sender} from \\\"./IOptimismL1Sender.sol\\\";\\nimport {IOptimismL2Receiver} from \\\"./IOptimismL2Receiver.sol\\\";\\n\\ncontract CannonRegistry is EfficientStorage, OwnedUpgradable {\\n  IOptimismL1Sender private constant _OPTIMISM_MESSENGER = IOptimismL1Sender(0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1);\\n  IOptimismL2Receiver private constant _OPTIMISM_RECEIVER = IOptimismL2Receiver(0x4200000000000000000000000000000000000007);\\n\\n  using SetUtil for SetUtil.Bytes32Set;\\n\\n  error Unauthorized();\\n  error InvalidUrl(string url);\\n  error InvalidName(bytes32 name);\\n  error InvalidTags();\\n  error PackageNotFound();\\n  error FeeRequired(uint256 amount);\\n  error WrongChain();\\n\\n  event PackageRegistered(bytes32 indexed name, address registrant);\\n  event PackageOwnerNominated(bytes32 indexed name, address currentOwner, address nominatedOwner);\\n  event PackageOwnerChanged(bytes32 indexed name, address owner);\\n  event PackagePublish(\\n    bytes32 indexed name,\\n    bytes32 indexed tag,\\n    bytes32 indexed variant,\\n    string deployUrl,\\n    string metaUrl,\\n    address owner\\n  );\\n  event PackageUnpublish(bytes32 indexed name, bytes32 indexed tag, bytes32 indexed variant, address owner);\\n  event PackageVerify(bytes32 indexed name, address indexed verifier);\\n  event PackageUnverify(bytes32 indexed name, address indexed verifier);\\n\\n  uint256 public constant MIN_PACKAGE_NAME_LENGTH = 3;\\n  uint256 public publishFee = 0 wei;\\n  uint256 public registerFee = 0 wei;\\n\\n  function validatePackageName(bytes32 _name) public pure returns (bool) {\\n    // each character must be in the supported charset\\n\\n    for (uint256 i = 0; i < 32; i++) {\\n      if (_name[i] == bytes1(0)) {\\n        // must be long enough\\n        if (i < MIN_PACKAGE_NAME_LENGTH) {\\n          return false;\\n        }\\n\\n        // last character cannot be `-`\\n        if (_name[i - 1] == \\\"-\\\") {\\n          return false;\\n        }\\n\\n        break;\\n      }\\n\\n      // must be in valid character set\\n      if (\\n        (_name[i] < \\\"0\\\" || _name[i] > \\\"9\\\") &&\\n        (_name[i] < \\\"a\\\" || _name[i] > \\\"z\\\") &&\\n        // first character cannot be `-`\\n        (i == 0 || _name[i] != \\\"-\\\")\\n      ) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  function setFees(uint256 _publishFee, uint256 _registerFee) external onlyOwner {\\n    publishFee = _publishFee;\\n    registerFee = _registerFee;\\n  }\\n\\n  function publish(\\n    bytes32 _packageName,\\n    bytes32 _variant,\\n    bytes32[] memory _packageTags,\\n    string memory _packageDeployUrl,\\n    string memory _packageMetaUrl\\n  ) external payable {\\n    if (msg.value != publishFee) {\\n      revert FeeRequired(publishFee);\\n    }\\n\\n    if (_packageTags.length == 0 || _packageTags.length > 5) {\\n      revert InvalidTags();\\n    }\\n\\n    if (bytes(_packageDeployUrl).length == 0) {\\n      revert InvalidUrl(_packageDeployUrl);\\n    }\\n\\n    Package storage _p = _store().packages[_packageName];\\n    address sender = ERC2771Context.msgSender();\\n\\n    if (!_canPublishPackage(_p, sender)) {\\n      revert Unauthorized();\\n    }\\n\\n    bytes16 packageDeployString = bytes16(_writeString(_packageDeployUrl));\\n    bytes16 packageMetaString = bytes16(_writeString(_packageMetaUrl));\\n\\n    bytes32 _firstTag = _packageTags[0];\\n    _p.deployments[_firstTag][_variant] = CannonDeployInfo({deploy: packageDeployString, meta: packageMetaString});\\n    CannonDeployInfo storage _deployInfo = _p.deployments[_firstTag][_variant];\\n    emit PackagePublish(_packageName, _firstTag, _variant, _packageDeployUrl, _packageMetaUrl, sender);\\n\\n    if (_packageTags.length > 1) {\\n      for (uint256 i = 1; i < _packageTags.length; i++) {\\n        bytes32 _tag = _packageTags[i];\\n        _p.deployments[_tag][_variant] = _deployInfo;\\n\\n        emit PackagePublish(_packageName, _tag, _variant, _packageDeployUrl, _packageMetaUrl, sender);\\n      }\\n    }\\n  }\\n\\n  function unpublish(bytes32 _packageName, bytes32 _variant, bytes32[] memory _packageTags) external {\\n    Package storage _p = _store().packages[_packageName];\\n    address sender = ERC2771Context.msgSender();\\n\\n    if (!_canPublishPackage(_p, sender)) {\\n      revert Unauthorized();\\n    }\\n\\n    for (uint256 i = 0; i < _packageTags.length; i++) {\\n      bytes32 _tag = _packageTags[i];\\n      _p.deployments[_tag][_variant] = CannonDeployInfo({deploy: \\\"\\\", meta: \\\"\\\"});\\n\\n      emit PackageUnpublish(_packageName, _tag, _variant, sender);\\n    }\\n  }\\n\\n  function setPackageOwnership(bytes32 _packageName, address _owner) external payable {\\n    Package storage _p = _store().packages[_packageName];\\n    address sender = ERC2771Context.msgSender();\\n\\n    if (sender == address(_OPTIMISM_RECEIVER)) {\\n      _checkCrossDomainSender();\\n    } else if (block.chainid == 1) {\\n      address owner = _p.owner;\\n      // we cannot change owner if its already owned and the nominated owner is incorrect\\n      if (owner != address(0) && (sender != _owner || _owner != _p.nominatedOwner)) {\\n        revert Unauthorized();\\n      }\\n\\n      // package new or old check\\n      if (owner == address(0) && msg.value != registerFee) {\\n        revert FeeRequired(registerFee);\\n      } else if (owner == address(0)) {\\n        emit PackageRegistered(_packageName, sender);\\n      }\\n\\n      // name must be valid in order to register package\\n      if (owner == address(0) && !validatePackageName(_packageName)) {\\n        revert InvalidName(_packageName);\\n      }\\n\\n      _OPTIMISM_MESSENGER.sendMessage(\\n        address(this),\\n        abi.encodeWithSelector(this.setPackageOwnership.selector, _packageName, _owner),\\n        200000\\n      );\\n    } else {\\n      revert Unauthorized();\\n    }\\n\\n    _p.owner = _owner;\\n    _p.additionalDeployersLength = 0;\\n    _p.nominatedOwner = address(0);\\n\\n    emit PackageOwnerChanged(_packageName, _owner);\\n  }\\n\\n  function setAdditionalPublishers(bytes32 _packageName, address[] memory _additionalDeployers) external {\\n    Package storage _p = _store().packages[_packageName];\\n    address owner = _p.owner;\\n\\n    if (ERC2771Context.msgSender() == address(_OPTIMISM_RECEIVER)) {\\n      _checkCrossDomainSender();\\n    } else if (block.chainid == 1) {\\n      if (owner != ERC2771Context.msgSender()) {\\n        revert Unauthorized();\\n      }\\n\\n      _OPTIMISM_MESSENGER.sendMessage(\\n        address(this),\\n        abi.encodeWithSelector(this.setAdditionalPublishers.selector, _packageName, _additionalDeployers),\\n        uint32(30000 * _additionalDeployers.length + 200000)\\n      );\\n    } else {\\n      revert Unauthorized();\\n    }\\n\\n    for (uint256 i = 0; i < _additionalDeployers.length; i++) {\\n      _p.additionalDeployers[i] = _additionalDeployers[i];\\n    }\\n\\n    _p.additionalDeployersLength = _additionalDeployers.length;\\n  }\\n\\n  function getAdditionalPublishers(bytes32 _packageName) external view returns (address[] memory additionalDeployers) {\\n    Package storage _p = _store().packages[_packageName];\\n    additionalDeployers = new address[](_p.additionalDeployersLength);\\n\\n    for (uint256 i = 0; i < additionalDeployers.length; i++) {\\n      additionalDeployers[i] = _p.additionalDeployers[i];\\n    }\\n  }\\n\\n  function nominatePackageOwner(bytes32 _packageName, address _newPackageOwner) external {\\n    Package storage _p = _store().packages[_packageName];\\n    address owner = _p.owner;\\n    address sender = ERC2771Context.msgSender();\\n\\n    if (owner != sender) {\\n      revert Unauthorized();\\n    }\\n\\n    _p.nominatedOwner = _newPackageOwner;\\n    emit PackageOwnerNominated(_packageName, sender, _newPackageOwner);\\n  }\\n\\n  function verifyPackage(bytes32 _packageName) external {\\n    if (_store().packages[_packageName].owner == address(0)) {\\n      revert PackageNotFound();\\n    }\\n\\n    emit PackageVerify(_packageName, ERC2771Context.msgSender());\\n  }\\n\\n  function unverifyPackage(bytes32 _packageName) external {\\n    if (_store().packages[_packageName].owner == address(0)) {\\n      revert PackageNotFound();\\n    }\\n\\n    emit PackageUnverify(_packageName, ERC2771Context.msgSender());\\n  }\\n\\n  function getPackageOwner(bytes32 _packageName) external view returns (address) {\\n    return _store().packages[_packageName].owner;\\n  }\\n\\n  function getPackageNominatedOwner(bytes32 _packageName) external view returns (address) {\\n    return _store().packages[_packageName].nominatedOwner;\\n  }\\n\\n  function getPackageUrl(\\n    bytes32 _packageName,\\n    bytes32 _packageVersionName,\\n    bytes32 _packageVariant\\n  ) external view returns (string memory) {\\n    string memory v = _store().strings[\\n      _store().packages[_packageName].deployments[_packageVersionName][_packageVariant].deploy\\n    ];\\n\\n    return v;\\n  }\\n\\n  function getPackageMeta(\\n    bytes32 _packageName,\\n    bytes32 _packageVersionName,\\n    bytes32 _packageVariant\\n  ) external view returns (string memory) {\\n    string memory v = _store().strings[\\n      _store().packages[_packageName].deployments[_packageVersionName][_packageVariant].meta\\n    ];\\n\\n    return v;\\n  }\\n\\n  function _canPublishPackage(Package storage _package, address _publisher) internal view returns (bool) {\\n    if (_package.owner == _publisher) return true;\\n\\n    uint256 additionalDeployersLength = _package.additionalDeployersLength;\\n    for (uint256 i = 0; i < additionalDeployersLength; i++) {\\n      if (_package.additionalDeployers[i] == _publisher) return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  function _checkCrossDomainSender() internal {\\n    // we can only receive change ownership requests from our counterpart on mainnnet\\n    if (_OPTIMISM_RECEIVER.xDomainMessageSender() != address(this)) {\\n      revert Unauthorized();\\n    }\\n  }\\n\\n  function _writeString(string memory str) internal returns (bytes32) {\\n    bytes16 k = bytes16(keccak256(bytes(str)));\\n\\n    if (bytes(_store().strings[k]).length == 0) {\\n      _store().strings[k] = str;\\n    }\\n\\n    return k;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/EfficientStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract EfficientStorage {\\n  bytes32 private constant _SLOT_CANNON_REGISTRY_STORAGE = keccak256(abi.encode(\\\"usecannon.cannon.registry.efficient\\\"));\\n\\n  struct Store {\\n    mapping(bytes16 => string) strings;\\n    mapping(bytes32 => Package) packages;\\n    mapping(address => bool) verifiers;\\n  }\\n\\n  struct Package {\\n    mapping(bytes32 => mapping(bytes32 => CannonDeployInfo)) deployments;\\n    address owner;\\n    address nominatedOwner;\\n    uint256 additionalDeployersLength;\\n    mapping(uint256 => address) additionalDeployers;\\n  }\\n\\n  struct CannonDeployInfo {\\n    bytes16 deploy;\\n    bytes16 meta;\\n  }\\n\\n  function _store() internal pure returns (Store storage store) {\\n    bytes32 s = _SLOT_CANNON_REGISTRY_STORAGE;\\n\\n    assembly {\\n      store.slot := s\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/* solhint-disable meta-transactions/no-msg-sender */\\n/* solhint-disable meta-transactions/no-msg-data */\\n\\nlibrary ERC2771Context {\\n  // This is the trusted-multicall-forwarder. The address is constant due to CREATE2.\\n  address private constant _TRUSTED_FORWARDER = 0xE2C5658cC5C448B48141168f3e475dF8f65A1e3e;\\n\\n  function msgSender() internal view returns (address sender) {\\n    if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n      }\\n    } else {\\n      return msg.sender;\\n    }\\n  }\\n\\n  function msgData() internal view returns (bytes calldata) {\\n    if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\\n      return msg.data[:msg.data.length - 20];\\n    } else {\\n      return msg.data;\\n    }\\n  }\\n\\n  function isTrustedForwarder(address forwarder) internal pure returns (bool) {\\n    return forwarder == _TRUSTED_FORWARDER;\\n  }\\n\\n  function trustedForwarder() internal pure returns (address) {\\n    return _TRUSTED_FORWARDER;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/IOptimismL1Sender.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IOptimismL1Sender {\\n  function sendMessage(address _target, bytes memory _message, uint32 _minGasLimit) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IOptimismL2Receiver.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IOptimismL2Receiver {\\n  function xDomainMessageSender() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/OwnedUpgradable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Ownable} from \\\"@synthetixio/core-contracts/contracts/ownership/Ownable.sol\\\";\\nimport {UUPSImplementation} from \\\"@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol\\\";\\n\\ncontract OwnedUpgradable is Ownable, UUPSImplementation {\\n  function upgradeTo(address _newImplementation) public override onlyOwner {\\n    _upgradeTo(_newImplementation);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeRequired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ImplementationIsSterile\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"InvalidName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTags\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"name\":\"InvalidUrl\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoChange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contr\",\"type\":\"address\"}],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NotNominated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PackageNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpgradeSimulationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongChain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PackageOwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"}],\"name\":\"PackageOwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"variant\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"deployUrl\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metaUrl\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PackagePublish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"}],\"name\":\"PackageRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"variant\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PackageUnpublish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"PackageUnverify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"PackageVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_PACKAGE_NAME_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"}],\"name\":\"getAdditionalPublishers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"additionalDeployers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_packageVersionName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_packageVariant\",\"type\":\"bytes32\"}],\"name\":\"getPackageMeta\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"}],\"name\":\"getPackageNominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"}],\"name\":\"getPackageOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_packageVersionName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_packageVariant\",\"type\":\"bytes32\"}],\"name\":\"getPackageUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newNominatedOwner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newPackageOwner\",\"type\":\"address\"}],\"name\":\"nominatePackageOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_variant\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_packageTags\",\"type\":\"bytes32[]\"},{\"internalType\":\"string\",\"name\":\"_packageDeployUrl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_packageMetaUrl\",\"type\":\"string\"}],\"name\":\"publish\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publishFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"_additionalDeployers\",\"type\":\"address[]\"}],\"name\":\"setAdditionalPublishers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_publishFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_registerFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setPackageOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"simulateUpgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_variant\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_packageTags\",\"type\":\"bytes32[]\"}],\"name\":\"unpublish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"}],\"name\":\"unverifyPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"validatePackageName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packageName\",\"type\":\"bytes32\"}],\"name\":\"verifyPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CannonRegistry", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}