{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0; \r\n\r\nlibrary Strings {\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n// Interface for interacting with the CryptoPunksMarket contract\r\ninterface ICryptoPunksMarket {\r\n    function punkIndexToAddress(uint256 punkIndex) external view returns (address);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\n// PunkedCoins contract inheriting from ERC165 for interface detection and Ownable for ownership management\r\ncontract PunkedCoins is ERC165, Ownable {\r\n    // External interface used for interacting with the CryptoPunksMarket contract\r\n    ICryptoPunksMarket private _cryptoPunksMarket;\r\n    \r\n    // Constants defining key parameters for ERC721 interface IDs\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    \r\n    uint256 private constant _MASTER_BALANCE = 10000;           // Total supply of master tokens (inherited from CryptoPunks) \r\n    uint256 private constant _MINT_COOLDOWN = 30 days;          // Cooldown period between minting actions\r\n    uint256 private constant _PRICE_INCREMENT = 0.02 ether;     // Price increment for unsealing tokens\r\n\r\n    string private _gateway;        // Base URI for token metadata\r\n    string private _masterCID;      // Content identifier for Mater token metadata\r\n    string private _sealedCID;      // Content identifier for sealed Mater token metadata\r\n    string private _instanceCID;    // Content identifier for individual token metadata\r\n\r\n    uint256 private _currentIndex = 10000;      // Tracks the current token index for minting\r\n    uint256 private _unsealPrice = 0.1 ether;   // Initial price to unseal a token\r\n\r\n    mapping(uint256 => address) private _tokenOwner;                            // Token ID to owner address\r\n    mapping(address => uint256) private _ownedTokensCount;                      // Owner address to token count\r\n    mapping(uint256 => address) private _tokenApprovals;                        // Token ID to approved address\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;    // Owner to operator approvals\r\n    mapping(uint256 => uint256) private _tokenMaster;                           // Token ID to its master token ID\r\n    mapping(uint256 => uint256) private _lastMintTime;                          // Token ID to last mint time for cooldown management\r\n    mapping(uint256 => bool) private _sealed;                                   // Token ID to sealed status\r\n\r\n    // Events for marketplace synchronization\r\n    event Locked(uint256 tokenId);\r\n    event MetadataUpdate(uint256 _tokenId);\r\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\r\n\r\n    // Event for logging all Ether transactions within the contract\r\n    event EtherTransaction(address indexed sender, address indexed receiver, uint256 amount, string transactionType);\r\n\r\n    // ERC721 events\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    // Contract constructor\r\n    constructor(address _cryptoPunksMarketAddress) {\r\n        _cryptoPunksMarket = ICryptoPunksMarket(_cryptoPunksMarketAddress);\r\n    }\r\n\r\n    // Administrative functions\r\n    function setGateway(string memory newGateway) public onlyOwner {\r\n        _gateway = newGateway;\r\n    }\r\n\r\n    function setCID(string memory masterCID, string memory sealedCID, string memory instanceCID) public onlyOwner {\r\n        _masterCID = masterCID;\r\n        _sealedCID = sealedCID;\r\n        _instanceCID = instanceCID;\r\n    }\r\n\r\n    function broadcastBatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId) public onlyOwner {\r\n        emit BatchMetadataUpdate(fromTokenId, toTokenId);\r\n    }  \r\n\r\n    function initOwnershipStatus(uint256 fromTokenId, uint256 toTokenId) public onlyOwner {\r\n        require(isMaster(toTokenId), \"Non existent token\");        \r\n        for (uint256 tokenId = fromTokenId; tokenId <= toTokenId; tokenId++) {\r\n            emit Transfer(address(0), address(0), tokenId);\r\n        }\r\n    }\r\n\r\n    // ERC721, ERC721Metadata\r\n    function name() public pure returns (string memory) {\r\n        return \"Punked Coin\";\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return \"PCN\";\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _ownedTokensCount[owner] + _cryptoPunksMarket.balanceOf(owner) ;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address owner) {\r\n        if (isMaster(tokenId))\r\n            owner =  _ownerOfMaster(tokenId);\r\n        else\r\n            owner = _tokenOwner[tokenId];\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n        require(isMaster(tokenId) || _exists(tokenId), \"Non existent token\");\r\n\r\n        string memory cid;\r\n        if (isMaster(tokenId)) {\r\n            cid = _sealed[tokenId] ? _sealedCID : _masterCID;\r\n        } else {\r\n            cid = _instanceCID;\r\n        }\r\n\r\n        string memory template = isMaster(tokenId) ? Strings.toString(tokenId) : Strings.toString(_tokenMaster[tokenId]);\r\n\r\n        return string(abi.encodePacked(_gateway, cid, \"/\", template, \".json\"));\r\n    }\r\n\r\n    // Token approval and transfer\r\n    function approve(address to, uint256 tokenId) public {\r\n        require(!isMaster(tokenId), \"Cannot approve master\");\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"Approval to current owner\");\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"Caller is not owner nor approved for all\");\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(!isMaster(tokenId), \"Cannot approve master\");\r\n        require(_exists(tokenId), \"Non existent token\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public {\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        _transfer(from, to, tokenId);        \r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"Transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    // Emits events to simulate the minting process for Master tokens.\r\n    // This method is used for external platforms to recognize token ownership without altering any state.\r\n    function broadcastCoinOwnershipStatus(uint256 tokenId) public {\r\n        require(isMaster(tokenId), \"Token is not master\");        \r\n\r\n        // Emit a Transfer event from a 0 address to the owner to mimic the minting process\r\n        emit Transfer(address(0), _ownerOfMaster(tokenId), tokenId);\r\n        // Emit the Locked event to indicate that the token is not tradable on marketplaces.\r\n        emit Locked(tokenId);\r\n    }    \r\n\r\n    // Minting and sealing\r\n    function mint(uint256 masterId) external {\r\n        require(canMint(masterId), \"Can not be minted\");\r\n        require(_ownerOfMaster(masterId) == _msgSender(), \"Caller is not the owner\");\r\n        require(!_isContract(_msgSender()), \"Only EOAs can mint\");\r\n\r\n        _mint(_msgSender(), _currentIndex);\r\n        _tokenMaster[_currentIndex] = masterId;\r\n        _lastMintTime[masterId] = block.timestamp;\r\n\r\n        unchecked {\r\n            _currentIndex += 1;\r\n        }        \r\n\r\n        // Seal master on every 5th token or 25% randomness\r\n        _sealed[masterId] = _currentIndex % 5 == 0 || _random() % 4 == 0;\r\n        emit MetadataUpdate(masterId);\r\n    }\r\n\r\n    function unseal(uint256 tokenId) public payable {\r\n        require(_sealed[tokenId], \"Token is not sealed\");\r\n        require(msg.value == _unsealPrice, \"Exact payment required\"); \r\n        require(!_isContract(_msgSender()), \"Only EOAs can unseal\");\r\n\r\n        // Unseal the token\r\n        _sealed[tokenId] = false;\r\n        unchecked {\r\n            _unsealPrice += _PRICE_INCREMENT;\r\n        }\r\n\r\n        emit MetadataUpdate(_tokenMaster[_currentIndex]);\r\n        emit EtherTransaction(msg.sender, address(this), msg.value, \"Unsealed\");        \r\n    }    \r\n\r\n    function unsealPrice() public view returns (uint256) {\r\n        return _unsealPrice;\r\n    }    \r\n\r\n    function canMint(uint256 masterId) public view returns (bool) {\r\n        return !isSealed(masterId) && block.timestamp >= getNextMintTime(masterId);\r\n    }\r\n        \r\n    function isMaster(uint256 tokenId) public pure returns (bool) {\r\n        return tokenId < _MASTER_BALANCE;\r\n    }  \r\n\r\n    function isSealed(uint256 masterId) public view returns (bool) {\r\n        require(isMaster(masterId), \"Invalid masterId\");\r\n        return _sealed[masterId];\r\n    }    \r\n\r\n    function getNextMintTime(uint256 masterId) public view returns (uint256) {\r\n        return _lastMintTime[masterId] + _MINT_COOLDOWN;\r\n    }\r\n\r\n    // Private and internal utility functions\r\n    function _ownerOfMaster(uint256 masterId) private view returns (address) {\r\n        // Obtain the owner address from the CryptoPunksMarket contract\r\n        return _cryptoPunksMarket.punkIndexToAddress(masterId);\r\n    }\r\n\r\n    function _exists(uint256 tokenId) private view returns (bool) {\r\n        return _tokenOwner[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"Non existent token\");\r\n\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"Mint to the zero address\");\r\n        require(!_exists(tokenId), \"Token already minted\");\r\n\r\n        unchecked {\r\n            _ownedTokensCount[to] += 1;\r\n        }\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n        emit MetadataUpdate(tokenId);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 tokenId) internal {\r\n        require(!isMaster(tokenId), \"Cannot transfer master\");\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Caller is not owner nor approved\");        \r\n        require(ownerOf(tokenId) == from, \"Transfer from incorrect owner\");\r\n\r\n        // Clear approvals from the previous owner\r\n        approve(address(0), tokenId);\r\n\r\n        unchecked {\r\n            _ownedTokensCount[from] -= 1;\r\n            _ownedTokensCount[to] += 1;\r\n        }\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n\r\n    function _isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }    \r\n\r\n    function _random() private view returns (uint) {\r\n        return uint(keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 1), _msgSender())));\r\n    }\r\n\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\r\n        if (_isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"Transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Withdrawal function for contract owner\r\n    function withdrawAll() public onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        require(amount > 0, \"No Ether left to withdraw\");\r\n\r\n        (bool success, ) = owner().call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n \r\n        emit EtherTransaction(address(this), owner(), amount, \"Withdrawal\");\r\n    }     \r\n\r\n    // Fallback and receive functions\r\n    receive() external payable {\r\n        emit EtherTransaction(msg.sender, address(this), msg.value, \"Received\");\r\n    }\r\n\r\n    fallback() external payable {\r\n        emit EtherTransaction(msg.sender, address(this), msg.value, \"Received\");\r\n    }\r\n\r\n    // ERC165 Compliance\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return interfaceId == _INTERFACE_ID_ERC721\r\n            || interfaceId == _INTERFACE_ID_ERC721_METADATA\r\n            || super.supportsInterface(interfaceId);\r\n    }\t\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cryptoPunksMarketAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"BatchMetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transactionType\",\"type\":\"string\"}],\"name\":\"EtherTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"}],\"name\":\"broadcastBatchMetadataUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"broadcastCoinOwnershipStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"masterId\",\"type\":\"uint256\"}],\"name\":\"canMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"masterId\",\"type\":\"uint256\"}],\"name\":\"getNextMintTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"}],\"name\":\"initOwnershipStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isMaster\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"masterId\",\"type\":\"uint256\"}],\"name\":\"isSealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"masterId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"masterCID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sealedCID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"instanceCID\",\"type\":\"string\"}],\"name\":\"setCID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newGateway\",\"type\":\"string\"}],\"name\":\"setGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unseal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unsealPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PunkedCoins", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b47e3cd837ddf8e4c57f05d70ab865de6e193bbb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f8bcd2607a4feccf268974aae94433c07fbf593b52fd018d8dd47fb60427d81c"}