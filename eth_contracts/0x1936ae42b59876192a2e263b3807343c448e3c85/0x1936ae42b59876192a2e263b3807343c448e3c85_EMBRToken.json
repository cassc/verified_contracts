{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/EMBR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\r\\nimport \\\"solmate/auth/Owned.sol\\\";\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\nimport \\\"./PersonalEmbrVester.sol\\\";\\r\\nimport \\\"./PresaleManager.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract EMBRToken is ERC20, Owned {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint public buy_tax = 5;\\r\\n    uint public sell_tax = 5;\\r\\n    uint public preventSwapBefore = 10;\\r\\n    uint public buyCount = 0;\\r\\n    uint public swapThreshold = 100_000 * 10**18;\\r\\n    uint public inSwap = 1; // 1 = false, 2 = true. Saves gas cuz changing from non zero to non zero is cheaper than changing zero to non zero.\\r\\n    mapping(address => bool) public lps;\\r\\n    mapping(address => bool) public routers;\\r\\n    mapping(address => bool) public excludedFromFee;\\r\\n    address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address public uniRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    uint public maxTx = 1_000_000 * 10**18;\\r\\n    uint public maxHolding = 1_000_000 * 10**18;\\r\\n\\r\\n    uint public isTradingEnabled = 1;\\r\\n\\r\\n    mapping(address => bool) public excludedAntiWhales;\\r\\n\\r\\n    constructor() ERC20(\\\"Ember\\\", \\\"EMBR\\\", 18) Owned(msg.sender) {\\r\\n        excludedAntiWhales[address(this)] = true;\\r\\n        excludedAntiWhales[msg.sender] = true;\\r\\n\\r\\n\\r\\n        // uni router 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\r\\n        routers[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = true;\\r\\n        allowance[address(this)][0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = type(uint256).max;\\r\\n        excludedAntiWhales[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = true;\\r\\n\\r\\n        super._mint(msg.sender, 9_000_000 * 10**18);\\r\\n    }\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        inSwap = 2;\\r\\n        _;\\r\\n        inSwap = 1;\\r\\n    }\\r\\n\\r\\n    function setMaxTx(uint amount) onlyOwner external {\\r\\n        maxTx = amount;\\r\\n    }\\r\\n\\r\\n    function setMaxHolding(uint amount) onlyOwner external {\\r\\n        maxHolding = amount;\\r\\n    }\\r\\n\\r\\n    function excludeWhale(address addy) onlyOwner external {\\r\\n        excludedAntiWhales[addy] = true;\\r\\n    }\\r\\n\\r\\n    function setUniRouter(address newRouter) onlyOwner external {\\r\\n        uniRouter = newRouter;\\r\\n    }\\r\\n\\r\\n    function setAmm(address lp) onlyOwner external {\\r\\n        lps[lp] = true;\\r\\n        excludedAntiWhales[lp] = true;\\r\\n    }\\r\\n\\r\\n    function setRouter(address router) onlyOwner external {\\r\\n        routers[router] = true;\\r\\n        allowance[address(this)][router] = type(uint256).max;\\r\\n        excludedAntiWhales[router] = true;\\r\\n    }\\r\\n\\r\\n    function excludeFromFee(address addy) onlyOwner external {\\r\\n        excludedFromFee[addy] = true;\\r\\n    }\\r\\n\\r\\n    function setPreventSwapBefore(uint counter) onlyOwner external {\\r\\n        preventSwapBefore = counter;\\r\\n    }\\r\\n\\r\\n    function setSwapThreshold(uint newThreshold) onlyOwner external {\\r\\n        swapThreshold = newThreshold;\\r\\n    }\\r\\n\\r\\n    function setSellTax(uint newTax) onlyOwner external {\\r\\n        sell_tax = newTax;\\r\\n    }\\r\\n\\r\\n    function setBuyTax(uint newTax) onlyOwner external {\\r\\n        buy_tax = newTax;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\r\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) private {\\r\\n        require(isTradingEnabled == 2 || tx.origin == owner, \\\"trading isnt live\\\");\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        require(maxTx >= amount || excludedAntiWhales[from], \\\"max tx limit\\\");\\r\\n\\r\\n        uint256 taxAmount = 0;\\r\\n        if (from != owner && to != owner && tx.origin != owner) {\\r\\n            bool isSelling;\\r\\n            if (lps[from] &&\\r\\n                !routers[to] &&\\r\\n                !excludedFromFee[to]) {\\r\\n                    buyCount++;\\r\\n                    taxAmount = amount\\r\\n                    .mul(buy_tax)\\r\\n                    .div(100);\\r\\n            }\\r\\n\\r\\n            if (lps[to] && from != address(this)) {\\r\\n                isSelling = true;\\r\\n                taxAmount = amount\\r\\n                .mul(sell_tax)\\r\\n                .div(100);\\r\\n            }\\r\\n\\r\\n            uint256 contractTokenBalance = balanceOf[address(this)];\\r\\n            if (\\r\\n                inSwap == 1 &&\\r\\n                isSelling &&\\r\\n                contractTokenBalance > swapThreshold &&\\r\\n                buyCount > preventSwapBefore\\r\\n            ) {\\r\\n                swapTokensForEth(contractTokenBalance);\\r\\n                uint256 contractETHBalance = address(this).balance;\\r\\n                if (contractETHBalance > 0.1 ether) {\\r\\n                    payable(owner).transfer(contractETHBalance);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (taxAmount > 0) {\\r\\n            balanceOf[address(this)] = balanceOf[address(this)].add(taxAmount);\\r\\n            emit Transfer(from, address(this), taxAmount);\\r\\n        }\\r\\n\\r\\n        balanceOf[from] = balanceOf[from].sub(amount);\\r\\n        balanceOf[to] = balanceOf[to].add(amount.sub(taxAmount));\\r\\n\\r\\n        require(balanceOf[to] <= maxHolding || excludedAntiWhales[to] || tx.origin == owner, \\\"max holding limit\\\");\\r\\n        emit Transfer(from, to, amount.sub(taxAmount));\\r\\n    }\\r\\n\\r\\n    function enableTrading() onlyOwner external {\\r\\n        isTradingEnabled = 2;\\r\\n    }\\r\\n\\r\\n    function claimTaxes() onlyOwner external {\\r\\n        uint256 contractTokenBalance = balanceOf[address(this)];\\r\\n        balanceOf[address(this)] -= contractTokenBalance;\\r\\n        balanceOf[owner] += contractTokenBalance;\\r\\n        emit Transfer(address(this), owner, contractTokenBalance);\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint amount) private lockTheSwap {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = weth;\\r\\n        IUniswapV2Router01(uniRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 0, path, address(this), 99999999999999999999);\\r\\n    }\\r\\n\\r\\n    function mint(uint amount) onlyOwner external {\\r\\n        super._mint(owner, amount);\\r\\n    }\\r\\n\\r\\n    receive() external payable { }\\r\\n\\r\\n    function withdraw() onlyOwner external {\\r\\n        (bool sent,) = owner.call{value: address(this).balance}(\\\"\\\");\\r\\n        require(sent, \\\"Failed to send Ether\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\r\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\r\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\r\\nabstract contract ERC20 {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            METADATA STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              ERC20 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping(address => uint256) public balanceOf;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) public allowance;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            EIP-2612 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\r\\n\\r\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\r\\n\\r\\n    mapping(address => uint256) public nonces;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals\\r\\n    ) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n\\r\\n        INITIAL_CHAIN_ID = block.chainid;\\r\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               ERC20 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\r\\n        allowance[msg.sender][spender] = amount;\\r\\n\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\r\\n        balanceOf[msg.sender] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(msg.sender, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\r\\n\\r\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\r\\n\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             EIP-2612 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\r\\n\\r\\n        // Unchecked because the only math done is incrementing\\r\\n        // the owner's nonce which cannot realistically overflow.\\r\\n        unchecked {\\r\\n            address recoveredAddress = ecrecover(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"\\\\x19\\\\x01\\\",\\r\\n                        DOMAIN_SEPARATOR(),\\r\\n                        keccak256(\\r\\n                            abi.encode(\\r\\n                                keccak256(\\r\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\r\\n                                ),\\r\\n                                owner,\\r\\n                                spender,\\r\\n                                value,\\r\\n                                nonces[owner]++,\\r\\n                                deadline\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                v,\\r\\n                r,\\r\\n                s\\r\\n            );\\r\\n\\r\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\r\\n\\r\\n            allowance[recoveredAddress][spender] = value;\\r\\n        }\\r\\n\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\r\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n                    keccak256(bytes(name)),\\r\\n                    keccak256(\\\"1\\\"),\\r\\n                    block.chainid,\\r\\n                    address(this)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                        INTERNAL MINT/BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mint(address to, uint256 amount) internal virtual {\\r\\n        totalSupply += amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), to, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address from, uint256 amount) internal virtual {\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot underflow because a user's balance\\r\\n        // will never be larger than the total supply.\\r\\n        unchecked {\\r\\n            totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Simple single owner authorization mixin.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\r\\nabstract contract Owned {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            OWNERSHIP STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner() virtual {\\r\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             OWNERSHIP LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        owner = newOwner;\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\n// https://uniswap.org/docs/v2/smart-contracts/router01/\\r\\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol implementation\\r\\n// UniswapV2Router01 is deployed at 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a on the Ethereum mainnet, and the Ropsten, Rinkeby, G\u00f6rli, and Kovan testnets\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n      address tokenA,\\r\\n      address tokenB,\\r\\n      uint amountADesired,\\r\\n      uint amountBDesired,\\r\\n      uint amountAMin,\\r\\n      uint amountBMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n  function addLiquidityETH(\\r\\n      address token,\\r\\n      uint amountTokenDesired,\\r\\n      uint amountTokenMin,\\r\\n      uint amountETHMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n  function removeLiquidity(\\r\\n      address tokenA,\\r\\n      address tokenB,\\r\\n      uint liquidity,\\r\\n      uint amountAMin,\\r\\n      uint amountBMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n  function removeLiquidityETH(\\r\\n      address token,\\r\\n      uint liquidity,\\r\\n      uint amountTokenMin,\\r\\n      uint amountETHMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function removeLiquidityWithPermit(\\r\\n      address tokenA,\\r\\n      address tokenB,\\r\\n      uint liquidity,\\r\\n      uint amountAMin,\\r\\n      uint amountBMin,\\r\\n      address to,\\r\\n      uint deadline,\\r\\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETHWithPermit(\\r\\n      address token,\\r\\n      uint liquidity,\\r\\n      uint amountTokenMin,\\r\\n      uint amountETHMin,\\r\\n      address to,\\r\\n      uint deadline,\\r\\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function swapExactTokensForTokens(\\r\\n      uint amountIn,\\r\\n      uint amountOutMin,\\r\\n      address[] calldata path,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapTokensForExactTokens(\\r\\n      uint amountOut,\\r\\n      uint amountInMax,\\r\\n      address[] calldata path,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      payable\\r\\n      returns (uint[] memory amounts);\\r\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      returns (uint[] memory amounts);\\r\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      returns (uint[] memory amounts);\\r\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      payable\\r\\n      returns (uint[] memory amounts);\\r\\n\\r\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    },\r\n    \"src/PersonalEmbrVester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"./EMBR.sol\\\";\\r\\n\\r\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\r\\n\\r\\ncontract PersonalVester {\\r\\n    // This is set in constructor\\r\\n    address public claimer;\\r\\n    EMBRToken public embr;\\r\\n    uint public vestingTime;\\r\\n    uint public cliff;\\r\\n    uint public totalTokens;\\r\\n\\r\\n    // This is set in startVest()\\r\\n    uint public startingTime;\\r\\n\\r\\n    uint public totalClaimed;\\r\\n\\r\\n    uint256 public precision = 10e9;\\r\\n\\r\\n    constructor(uint _totalTokens, uint _vestingTime, uint _cliff, address _claimer){\\r\\n        totalTokens = _totalTokens;\\r\\n        vestingTime = _vestingTime;\\r\\n        cliff = _cliff;\\r\\n        claimer = _claimer;\\r\\n        // this contract is only deployed by embr\\r\\n        // embr = EMBRToken(msg.sender);\\r\\n    }\\r\\n\\r\\n    // This function is only called by esEMBR contract. esEMBR also calls claim for this user.\\r\\n    function startVest() external {\\r\\n        require(msg.sender == address(embr), \\\"caller must be embr contract\\\");\\r\\n        startingTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function claim() public returns (uint256) {\\r\\n        require(msg.sender == claimer, \\\"invalid caller\\\");\\r\\n        require(startingTime != 0, \\\"vesting is not started\\\");\\r\\n        require(block.timestamp > startingTime + cliff, \\\"cliff not reached!\\\");\\r\\n\\r\\n        uint passedTime = block.timestamp - startingTime;\\r\\n        if (passedTime > vestingTime) passedTime = vestingTime;\\r\\n\\r\\n        uint totalClaimableTokens = totalTokens * precision * passedTime / vestingTime / precision;\\r\\n        uint toClaim = totalClaimableTokens - totalClaimed;\\r\\n\\r\\n        totalClaimed += toClaim;\\r\\n\\r\\n        embr.transfer(msg.sender, toClaim);\\r\\n\\r\\n        return toClaim;\\r\\n    }\\r\\n\\r\\n    function claimable() external view returns (uint256) {\\r\\n        if (startingTime == 0) return 0;\\r\\n        if (block.timestamp < startingTime + cliff) return 0;\\r\\n        uint passedTime = block.timestamp - startingTime;\\r\\n        if (passedTime > vestingTime) passedTime = vestingTime;\\r\\n\\r\\n        uint totalClaimableTokens = totalTokens * precision * passedTime / vestingTime / precision;\\r\\n        uint toClaim = totalClaimableTokens - totalClaimed;\\r\\n        return toClaim;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/PresaleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"solmate/auth/Owned.sol\\\";\\r\\nimport \\\"./IEMBR.sol\\\";\\r\\nimport \\\"solady/src/utils/ECDSA.sol\\\";\\r\\n\\r\\nusing ECDSA for bytes32;\\r\\n\\r\\ncontract EMBRPresale is Owned {\\r\\n    IEMBRToken public ember_token;\\r\\n\\r\\n    uint public total_commited_eth;\\r\\n    uint public hard_cap = 500.01 ether;\\r\\n\\r\\n    uint public precision = 10**21;\\r\\n\\r\\n    uint public commit_start;\\r\\n    uint public commit_length;\\r\\n\\r\\n    mapping(address => uint) public commited_amount;\\r\\n    mapping(address => uint) public claimed;\\r\\n\\r\\n    uint public vesting_start;\\r\\n    uint public cliff_period = 14 days;\\r\\n    uint public vesting_period = 90 days;\\r\\n\\r\\n    uint public PRICE_PER_TOKEN = 0.00016667 ether;\\r\\n\\r\\n    address public claimSigner;\\r\\n\\r\\n    event Commit(address indexed from, uint commit_amount, uint total_commitment);\\r\\n\\r\\n    constructor(address _claimSigner, uint _commitStart, uint _commitLength) Owned(msg.sender) {\\r\\n        claimSigner = _claimSigner;\\r\\n\\r\\n        commit_start = _commitStart;\\r\\n        commit_length = _commitLength;\\r\\n    }\\r\\n\\r\\n    function commit(bytes memory signature, uint min_allocation, uint max_allocation) payable public {\\r\\n        require(block.timestamp >= commit_start, \\\"Sale is not live yet\\\");\\r\\n        require(block.timestamp < (commit_start + commit_length), \\\"Sale already ended\\\");\\r\\n\\r\\n        require(msg.value > 0, \\\"Commitment amount too low\\\");\\r\\n\\r\\n        // Verify signature & allocation size\\r\\n        bytes32 hashed = keccak256(abi.encodePacked(msg.sender, min_allocation, max_allocation));\\r\\n        bytes32 message = ECDSA.toEthSignedMessageHash(hashed);\\r\\n        address recovered_address = ECDSA.recover(message, signature);\\r\\n        require(recovered_address == claimSigner, \\\"Invalid signer\\\");\\r\\n\\r\\n        uint user_commited_amount = commited_amount[msg.sender];\\r\\n        require(user_commited_amount >= min_allocation || msg.value >= min_allocation, \\\"Minimum presale commitment not met\\\");\\r\\n\\r\\n        uint allocation_available = max_allocation - user_commited_amount;\\r\\n\\r\\n        uint leftFromHardCap = hard_cap - total_commited_eth;\\r\\n        if (leftFromHardCap < allocation_available) allocation_available = leftFromHardCap;\\r\\n\\r\\n        require(allocation_available > 0, \\\"No more allocation left\\\");\\r\\n\\r\\n        uint commit_amount = msg.value;\\r\\n\\r\\n        // If the user is trying to commit more than they have allocated, refund the difference and proceed\\r\\n        if (msg.value > allocation_available) {\\r\\n            uint leftover = msg.value - allocation_available;\\r\\n\\r\\n            (bool sent,) = msg.sender.call{value: leftover}(\\\"\\\");\\r\\n            require(sent, \\\"Failed to send Ether\\\");\\r\\n\\r\\n            commit_amount -= leftover;\\r\\n        }\\r\\n\\r\\n        commited_amount[msg.sender] += commit_amount;\\r\\n        total_commited_eth += commit_amount;\\r\\n\\r\\n        emit Commit(msg.sender, commit_amount, commited_amount[msg.sender]);\\r\\n    }\\r\\n\\r\\n    function claim() external returns (uint) {\\r\\n        require(vesting_start != 0, \\\"vesting hasnt started yet bro\\\");\\r\\n        require(block.timestamp >= vesting_start + cliff_period, \\\"You can only start claiming after cliff period\\\");\\r\\n\\r\\n        uint passedTime = block.timestamp - vesting_start;\\r\\n        if (passedTime > vesting_period) passedTime = vesting_period;\\r\\n\\r\\n        uint totalUserTokens = commited_amount[msg.sender] * 10**18 / PRICE_PER_TOKEN;\\r\\n        uint totalClaimableTokens = totalUserTokens * precision * passedTime / vesting_period / precision;\\r\\n        uint toClaim = totalClaimableTokens - claimed[msg.sender];\\r\\n\\r\\n        claimed[msg.sender] += toClaim;\\r\\n\\r\\n        ember_token.mintWithAllowance(toClaim, msg.sender);\\r\\n\\r\\n        return toClaim;\\r\\n    }\\r\\n\\r\\n    function claimable() external view returns (uint) {\\r\\n        if (vesting_start == 0) return 0;\\r\\n        if (block.timestamp < vesting_start + cliff_period) return 0;\\r\\n\\r\\n        uint passedTime = block.timestamp - vesting_start;\\r\\n        if (passedTime > vesting_period) passedTime = vesting_period;\\r\\n\\r\\n        uint totalUserTokens = commited_amount[msg.sender] * 10**18 / PRICE_PER_TOKEN;\\r\\n        uint totalClaimableTokens = totalUserTokens * precision * passedTime / vesting_period / precision;\\r\\n        uint toClaim = totalClaimableTokens - claimed[msg.sender];\\r\\n\\r\\n        return toClaim;\\r\\n    }\\r\\n\\r\\n    function withdraw() onlyOwner external {\\r\\n        (bool sent,) = owner.call{value: address(this).balance}(\\\"\\\");\\r\\n        require(sent, \\\"Failed to send Ether\\\");\\r\\n    }\\r\\n\\r\\n    function startVesting() onlyOwner external {\\r\\n        vesting_start = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function setEmbr(address embr) onlyOwner external {\\r\\n        ember_token = IEMBRToken(embr);\\r\\n    }\\r\\n\\r\\n    function setCommitInfo(uint startTs, uint length) onlyOwner external {\\r\\n        commit_start = startTs;\\r\\n        commit_length = length;\\r\\n    }\\r\\n\\r\\n    function setHardCap(uint new_hardcap) onlyOwner external {\\r\\n        hard_cap = new_hardcap;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\r\\n    // uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b <= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    c = a + b;\\r\\n    assert(c >= a);\\r\\n    return c;\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"src/IEMBR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\ninterface IEMBRToken {\\r\\n    function mint_allowance(address addy) external returns (uint);\\r\\n    function mintWithAllowance(uint amount, address receiver) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solady/src/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Gas optimized ECDSA wrapper.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\r\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\r\\nlibrary ECDSA {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The signature is invalid.\\r\\n    error InvalidSignature();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The number which `s` must be less than in order for\\r\\n    /// the signature to be non-malleable.\\r\\n    bytes32 private constant _MALLEABILITY_THRESHOLD_PLUS_ONE =\\r\\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                    RECOVERY OPERATIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // Note: as of Solady version 0.0.68, these functions will\\r\\n    // revert upon recovery failure for more safety by default.\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the `signature`.\\r\\n    ///\\r\\n    /// This function does NOT accept EIP-2098 short form signatures.\\r\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\r\\n    /// short form signatures instead.\\r\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\r\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\r\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    and(\\r\\n                        // If the signature is exactly 65 bytes in length.\\r\\n                        eq(mload(signature), 65),\\r\\n                        // If `s` in lower half order, such that the signature is not malleable.\\r\\n                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)\\r\\n                    ), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x00, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            result := mload(0x00)\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the `signature`.\\r\\n    ///\\r\\n    /// This function does NOT accept EIP-2098 short form signatures.\\r\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\r\\n    /// short form signatures instead.\\r\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\r\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    and(\\r\\n                        // If the signature is exactly 65 bytes in length.\\r\\n                        eq(signature.length, 65),\\r\\n                        // If `s` in lower half order, such that the signature is not malleable.\\r\\n                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)\\r\\n                    ), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x00, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            result := mload(0x00)\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\r\\n    ///\\r\\n    /// This function only accepts EIP-2098 short form signatures.\\r\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\r\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    // If `s` in lower half order, such that the signature is not malleable.\\r\\n                    lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x00, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            result := mload(0x00)\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the signature defined by `v`, `r`, `s`.\\r\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, and(v, 0xff))\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, s)\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    // If `s` in lower half order, such that the signature is not malleable.\\r\\n                    lt(s, _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x00, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            result := mload(0x00)\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   TRY-RECOVER OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // WARNING!\\r\\n    // These functions will NOT revert upon recovery failure.\\r\\n    // Instead, they will return the zero address upon recovery failure.\\r\\n    // It is critical that the returned address is NEVER compared against\\r\\n    // a zero address (e.g. an uninitialized address variable).\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the `signature`.\\r\\n    ///\\r\\n    /// This function does NOT accept EIP-2098 short form signatures.\\r\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\r\\n    /// short form signatures instead.\\r\\n    function tryRecover(bytes32 hash, bytes memory signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\r\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\r\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    and(\\r\\n                        // If the signature is exactly 65 bytes in length.\\r\\n                        eq(mload(signature), 65),\\r\\n                        // If `s` in lower half order, such that the signature is not malleable.\\r\\n                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)\\r\\n                    ), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the `signature`.\\r\\n    ///\\r\\n    /// This function does NOT accept EIP-2098 short form signatures.\\r\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\r\\n    /// short form signatures instead.\\r\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\r\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    and(\\r\\n                        // If the signature is exactly 65 bytes in length.\\r\\n                        eq(signature.length, 65),\\r\\n                        // If `s` in lower half order, such that the signature is not malleable.\\r\\n                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)\\r\\n                    ), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\r\\n    ///\\r\\n    /// This function only accepts EIP-2098 short form signatures.\\r\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\r\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    // If `s` in lower half order, such that the signature is not malleable.\\r\\n                    lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the signature defined by `v`, `r`, `s`.\\r\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, and(v, 0xff))\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, s)\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    // If `s` in lower half order, such that the signature is not malleable.\\r\\n                    lt(s, _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     HASHING OPERATIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\r\\n    /// This produces a hash corresponding to the one signed with the\\r\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\r\\n    /// JSON-RPC method as part of EIP-191.\\r\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\r\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\r\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\r\\n    /// This produces a hash corresponding to the one signed with the\\r\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\r\\n    /// JSON-RPC method as part of EIP-191.\\r\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\r\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let sLength := mload(s)\\r\\n            let o := 0x20\\r\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\r\\n            mstore(0x00, 0x00)\\r\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\r\\n            for { let temp := sLength } 1 {} {\\r\\n                o := sub(o, 1)\\r\\n                mstore8(o, add(48, mod(temp, 10)))\\r\\n                temp := div(temp, 10)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\r\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\r\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\r\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\r\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\r\\n            mstore(s, sLength) // Restore the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   EMPTY CALLDATA HELPERS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns an empty calldata bytes.\\r\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            signature.length := 0\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"excludeWhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedAntiWhales\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHolding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preventSwapBefore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"setAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"setBuyTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxHolding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"setPreventSwapBefore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"setSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setUniRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EMBRToken", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}