{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title UniswapV2LP Burner\r\n@notice Burns LP Tokens into Underlying\r\n\"\"\"\r\n\r\ninterface ERC20:\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\ninterface wrappedERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def burn(_to: address): nonpayable\r\n    def token0() -> address: view\r\n    def token1() -> address: view\r\n\r\ninterface Proxy:\r\n    def burners(_coin: address) -> address: view\r\n\r\n\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nPROXY: public(immutable(Proxy))\r\n\r\nis_killed: public(bool)\r\nkilled_coin: public(HashMap[address, bool])\r\n\r\nowner: public(address)\r\nemergency_owner: public(address)\r\nfuture_owner: public(address)\r\nfuture_emergency_owner: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_proxy: Proxy, _owner: address, _emergency_owner: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _proxy Owner of admin fees\r\n    @param _owner Owner address. Can kill the contract.\r\n    @param _emergency_owner Emergency owner address. Can kill the contract.\r\n    \"\"\"\r\n    PROXY = _proxy\r\n    self.owner = _owner\r\n    self.emergency_owner = _emergency_owner\r\n\r\n\r\n@internal\r\ndef _burn(_coin: wrappedERC20, _amount: uint256):\r\n    \"\"\"\r\n    @notice Burn implementation\r\n    \"\"\"\r\n    assert not self.is_killed and not self.killed_coin[_coin.address], \"Is killed\"\r\n\r\n    # Safe (w.r.t. spot price) to burn:\r\n    # x * y = k^2, p = x / y = (x / k)^2\r\n    # r * (x + x1 + p * (y - y1)) =\r\n    # r * (x + x1 + p * k^2 / (x + x1)) =\r\n    # r * (x + x1 + x^2 / (x + x1)) >=\r\n    # r * ( 2 * x ) =\r\n    # r * (x + p * y)\r\n    _coin.transfer(_coin.address, _amount)\r\n    _coin.burn(PROXY.address)\r\n\r\n\r\n@external\r\ndef burn(_coin: wrappedERC20) -> bool:\r\n    \"\"\"\r\n    @notice Unwrap `_coin`\r\n    @param _coin Address of the coin being unwrapped\r\n    @return bool Success, remained for compatibility\r\n    \"\"\"\r\n    amount: uint256 = _coin.balanceOf(msg.sender)\r\n    if amount != 0:\r\n        _coin.transferFrom(msg.sender, self, amount)\r\n\r\n    amount = _coin.balanceOf(self)\r\n\r\n    if amount != 0:\r\n        self._burn(_coin, amount)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burn_amount(_coin: wrappedERC20, _amount_to_burn: uint256):\r\n    \"\"\"\r\n    @notice Burn a specific quantity of `_coin`\r\n    @dev Useful when the total amount to burn is so large that it fails\r\n    @param _coin Address of the coin being converted\r\n    @param _amount_to_burn Amount of the coin to burn\r\n    \"\"\"\r\n    amount: uint256 = _coin.balanceOf(PROXY.address)\r\n    if amount != 0 and PROXY.burners(_coin.address) == self:\r\n        _coin.transferFrom(PROXY.address, self, amount)\r\n\r\n    amount = _coin.balanceOf(self)\r\n    assert amount >= _amount_to_burn, \"Insufficient balance\"\r\n\r\n    self._burn(_coin, _amount_to_burn)\r\n\r\n\r\n@external\r\n@pure\r\ndef burns_to(_coin: wrappedERC20) -> DynArray[address, 8]:\r\n    \"\"\"\r\n    @notice Get resulting coins of burning `_coin`\r\n    @param _coin Coin to burn\r\n    \"\"\"\r\n    return [_coin.token0(), _coin.token1()]\r\n\r\n\r\n@external\r\ndef recover_balance(_coin: ERC20, _amount: uint256=max_value(uint256)):\r\n    \"\"\"\r\n    @notice Recover ERC20 tokens or Ether from this contract\r\n    @dev Tokens are sent to proxy\r\n    @param _coin Token address\r\n    @param _amount Amount to recover\r\n    \"\"\"\r\n    amount: uint256 = _amount\r\n    if _coin.address == ETH_ADDRESS:\r\n        if amount == max_value(uint256):\r\n            amount = self.balance\r\n        raw_call(PROXY.address, b\"\", value=amount)\r\n    else:\r\n        if amount == max_value(uint256):\r\n            amount = _coin.balanceOf(self)\r\n        _coin.transfer(PROXY.address, amount)  # do not need safe transfer\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool, _coin: address=empty(address)):\r\n    \"\"\"\r\n    @notice Stop a contract or specific coin to be burnt\r\n    @dev Executable only via owner or emergency owner\r\n    @param _is_killed Boolean value to set\r\n    @param _coin Coin to stop from burning, ZERO_ADDRESS to kill all coins (by default)\r\n    \"\"\"\r\n    assert msg.sender in [self.owner, self.emergency_owner], \"Only owner\"\r\n\r\n    if _coin == empty(address):\r\n        self.is_killed = _is_killed\r\n    else:\r\n        self.killed_coin[_coin] = _is_killed\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address) -> bool:\r\n    \"\"\"\r\n    @notice Commit a transfer of ownership\r\n    @dev Must be accepted by the new owner via `accept_transfer_ownership`\r\n    @param _future_owner New owner address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"Only owner\"\r\n    self.future_owner = _future_owner\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership() -> bool:\r\n    \"\"\"\r\n    @notice Accept a transfer of ownership\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner, \"Only owner\"\r\n    self.owner = msg.sender\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef commit_transfer_emergency_ownership(_future_owner: address) -> bool:\r\n    \"\"\"\r\n    @notice Commit a transfer of emergency ownership\r\n    @dev Must be accepted by the new owner via `accept_transfer_emergency_ownership`\r\n    @param _future_owner New owner address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.emergency_owner, \"Only owner\"\r\n    self.future_emergency_owner = _future_owner\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef accept_transfer_emergency_ownership() -> bool:\r\n    \"\"\"\r\n    @notice Accept a transfer of emergency ownership\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.future_emergency_owner, \"Only owner\"\r\n    self.emergency_owner = msg.sender\r\n\r\n    return True", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_emergency_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn_amount\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_amount_to_burn\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"burns_to\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover_balance\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover_balance\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"},{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_emergency_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_emergency_ownership\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"PROXY\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"killed_coin\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"emergency_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_emergency_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "UniswapV2LP Burner", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000ecb456ea5365865ebab8a2661b0c503410e9b34700000000000000000000000040907540d8a6c65c637785e8f8b742ae6b0b9968000000000000000000000000467947ee34af926cf1dcac093870f613c96b1e0c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}