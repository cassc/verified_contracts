{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ERC721A/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport './IERC721A.sol';\\r\\n\\r\\n/**\\r\\n * @dev Interface of ERC721 token receiver.\\r\\n */\\r\\ninterface ERC721A__IERC721Receiver {\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC721A\\r\\n *\\r\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\r\\n * Non-Fungible Token Standard, including the Metadata extension.\\r\\n * Optimized for lower gas during batch mints.\\r\\n *\\r\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\r\\n * starting from `_startTokenId()`.\\r\\n *\\r\\n * Assumptions:\\r\\n *\\r\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\r\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\r\\n */\\r\\ncontract ERC721A is IERC721A {\\r\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\r\\n    struct TokenApprovalRef {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                           CONSTANTS\\r\\n    // =============================================================\\r\\n\\r\\n    // Mask of an entry in packed address data.\\r\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\r\\n\\r\\n    // The bit position of `numberMinted` in packed address data.\\r\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\r\\n\\r\\n    // The bit position of `numberBurned` in packed address data.\\r\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\r\\n\\r\\n    // The bit position of `aux` in packed address data.\\r\\n    uint256 private constant _BITPOS_AUX = 192;\\r\\n\\r\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\r\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\r\\n\\r\\n    // The bit position of `startTimestamp` in packed ownership.\\r\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\r\\n\\r\\n    // The bit mask of the `burned` bit in packed ownership.\\r\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\r\\n\\r\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\r\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\r\\n\\r\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\r\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\r\\n\\r\\n    // The bit position of `extraData` in packed ownership.\\r\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\r\\n\\r\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\r\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\r\\n\\r\\n    // The mask of the lower 160 bits for addresses.\\r\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\r\\n\\r\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\r\\n    // This limit is to prevent overflows on the address data entries.\\r\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\r\\n    // is required to cause an overflow, which is unrealistic.\\r\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\r\\n\\r\\n    // The `Transfer` event signature is given by:\\r\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    // =============================================================\\r\\n    //                            STORAGE\\r\\n    // =============================================================\\r\\n\\r\\n    // The next token ID to be minted.\\r\\n    uint256 private _currentIndex;\\r\\n\\r\\n    // The number of tokens burned.\\r\\n    uint256 private _burnCounter;\\r\\n\\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    // Mapping from token ID to ownership details\\r\\n    // An empty struct value does not necessarily mean the token is unowned.\\r\\n    // See {_packedOwnershipOf} implementation for details.\\r\\n    //\\r\\n    // Bits Layout:\\r\\n    // - [0..159]   `addr`\\r\\n    // - [160..223] `startTimestamp`\\r\\n    // - [224]      `burned`\\r\\n    // - [225]      `nextInitialized`\\r\\n    // - [232..255] `extraData`\\r\\n    mapping(uint256 => uint256) private _packedOwnerships;\\r\\n\\r\\n    // Mapping owner address to address data.\\r\\n    //\\r\\n    // Bits Layout:\\r\\n    // - [0..63]    `balance`\\r\\n    // - [64..127]  `numberMinted`\\r\\n    // - [128..191] `numberBurned`\\r\\n    // - [192..255] `aux`\\r\\n    mapping(address => uint256) private _packedAddressData;\\r\\n\\r\\n    // Mapping from token ID to approved address.\\r\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    // =============================================================\\r\\n    //                          CONSTRUCTOR\\r\\n    // =============================================================\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _currentIndex = _startTokenId();\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                   TOKEN COUNTING OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the starting token ID.\\r\\n     * To change the starting token ID, please override this function.\\r\\n     */\\r\\n    function _startTokenId() internal view virtual returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the next token ID to be minted.\\r\\n     */\\r\\n    function _nextTokenId() internal view virtual returns (uint256) {\\r\\n        return _currentIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens in existence.\\r\\n     * Burned tokens will reduce the count.\\r\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\r\\n        // more than `_currentIndex - _startTokenId()` times.\\r\\n        unchecked {\\r\\n            return _currentIndex - _burnCounter - _startTokenId();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total amount of tokens minted in the contract.\\r\\n     */\\r\\n    function _totalMinted() internal view virtual returns (uint256) {\\r\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\r\\n        // and it is initialized to `_startTokenId()`.\\r\\n        unchecked {\\r\\n            return _currentIndex - _startTokenId();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens burned.\\r\\n     */\\r\\n    function _totalBurned() internal view virtual returns (uint256) {\\r\\n        return _burnCounter;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                    ADDRESS DATA OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in `owner`'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\r\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\r\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the number of tokens minted by `owner`.\\r\\n     */\\r\\n    function _numberMinted(address owner) internal view returns (uint256) {\\r\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\r\\n     */\\r\\n    function _numberBurned(address owner) internal view returns (uint256) {\\r\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\r\\n     */\\r\\n    function _getAux(address owner) internal view returns (uint64) {\\r\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\r\\n     * If there are multiple variables, please pack them into a uint64.\\r\\n     */\\r\\n    function _setAux(address owner, uint64 aux) internal virtual {\\r\\n        uint256 packed = _packedAddressData[owner];\\r\\n        uint256 auxCasted;\\r\\n        // Cast `aux` with assembly to avoid redundant masking.\\r\\n        assembly {\\r\\n            auxCasted := aux\\r\\n        }\\r\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\r\\n        _packedAddressData[owner] = packed;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC165\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        // The interface IDs are constants representing the first 4 bytes\\r\\n        // of the XOR of all function selectors in the interface.\\r\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\r\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\r\\n        return\\r\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\r\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\r\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                        IERC721Metadata\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\r\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\r\\n     * by default, it can be overridden in child contracts.\\r\\n     */\\r\\n    function _baseURI() internal view virtual returns (string memory) {\\r\\n        return '';\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                     OWNERSHIPS OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\r\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\r\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\r\\n     */\\r\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\r\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\r\\n     */\\r\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\r\\n        return _unpackedOwnership(_packedOwnerships[index]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\r\\n     */\\r\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\r\\n        if (_packedOwnerships[index] == 0) {\\r\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the packed ownership data of `tokenId`.\\r\\n     */\\r\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\r\\n        uint256 curr = tokenId;\\r\\n\\r\\n        unchecked {\\r\\n            if (_startTokenId() <= curr)\\r\\n                if (curr < _currentIndex) {\\r\\n                    uint256 packed = _packedOwnerships[curr];\\r\\n                    // If not burned.\\r\\n                    if (packed & _BITMASK_BURNED == 0) {\\r\\n                        // Invariant:\\r\\n                        // There will always be an initialized ownership slot\\r\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\r\\n                        // before an unintialized ownership slot\\r\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\r\\n                        // Hence, `curr` will not underflow.\\r\\n                        //\\r\\n                        // We can directly compare the packed value.\\r\\n                        // If the address is zero, packed will be zero.\\r\\n                        while (packed == 0) {\\r\\n                            packed = _packedOwnerships[--curr];\\r\\n                        }\\r\\n                        return packed;\\r\\n                    }\\r\\n                }\\r\\n        }\\r\\n        revert OwnerQueryForNonexistentToken();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\r\\n     */\\r\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\r\\n        ownership.addr = address(uint160(packed));\\r\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\r\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\r\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Packs ownership data into a single uint256.\\r\\n     */\\r\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\r\\n        assembly {\\r\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n            owner := and(owner, _BITMASK_ADDRESS)\\r\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\r\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\r\\n     */\\r\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\r\\n        // For branchless setting of the `nextInitialized` flag.\\r\\n        assembly {\\r\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\r\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                      APPROVAL OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the\\r\\n     * zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\r\\n        address owner = ownerOf(tokenId);\\r\\n\\r\\n        if (_msgSenderERC721A() != owner)\\r\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\r\\n                revert ApprovalCallerNotOwnerNorApproved();\\r\\n            }\\r\\n\\r\\n        _tokenApprovals[tokenId].value = to;\\r\\n        emit Approval(owner, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\r\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\r\\n\\r\\n        return _tokenApprovals[tokenId].value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\r\\n     * for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\r\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted. See {_mint}.\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\r\\n        return\\r\\n            _startTokenId() <= tokenId &&\\r\\n            tokenId < _currentIndex && // If within bounds,\\r\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\r\\n     */\\r\\n    function _isSenderApprovedOrOwner(\\r\\n        address approvedAddress,\\r\\n        address owner,\\r\\n        address msgSender\\r\\n    ) private pure returns (bool result) {\\r\\n        assembly {\\r\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n            owner := and(owner, _BITMASK_ADDRESS)\\r\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\r\\n            // `msgSender == owner || msgSender == approvedAddress`.\\r\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\r\\n     */\\r\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\r\\n    {\\r\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\r\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\r\\n        assembly {\\r\\n            approvedAddressSlot := tokenApproval.slot\\r\\n            approvedAddress := sload(approvedAddressSlot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                      TRANSFER OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable virtual override {\\r\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\r\\n\\r\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\r\\n\\r\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\r\\n\\r\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\r\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\r\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\r\\n\\r\\n        // Clear approvals from the previous owner.\\r\\n        assembly {\\r\\n            if approvedAddress {\\r\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\r\\n                sstore(approvedAddressSlot, 0)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\r\\n        unchecked {\\r\\n            // We can directly increment and decrement the balances.\\r\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\r\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the next owner.\\r\\n            // - `startTimestamp` to the timestamp of transfering.\\r\\n            // - `burned` to `false`.\\r\\n            // - `nextInitialized` to `true`.\\r\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\r\\n                to,\\r\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\r\\n            );\\r\\n\\r\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\r\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\r\\n                uint256 nextTokenId = tokenId + 1;\\r\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\r\\n                if (_packedOwnerships[nextTokenId] == 0) {\\r\\n                    // If the next slot is within bounds.\\r\\n                    if (nextTokenId != _currentIndex) {\\r\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\r\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n        _afterTokenTransfers(from, to, tokenId, 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable virtual override {\\r\\n        safeTransferFrom(from, to, tokenId, '');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) public payable virtual override {\\r\\n        transferFrom(from, to, tokenId);\\r\\n        if (to.code.length != 0)\\r\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\r\\n                revert TransferToNonERC721ReceiverImplementer();\\r\\n            }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\r\\n     * are about to be transferred. This includes minting.\\r\\n     * And also called before burning one token.\\r\\n     *\\r\\n     * `startTokenId` - the first token ID to be transferred.\\r\\n     * `quantity` - the amount to be transferred.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _beforeTokenTransfers(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 startTokenId,\\r\\n        uint256 quantity\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\r\\n     * have been transferred. This includes minting.\\r\\n     * And also called after one token has been burned.\\r\\n     *\\r\\n     * `startTokenId` - the first token ID to be transferred.\\r\\n     * `quantity` - the amount to be transferred.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _afterTokenTransfers(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 startTokenId,\\r\\n        uint256 quantity\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\r\\n     *\\r\\n     * `from` - Previous owner of the given token ID.\\r\\n     * `to` - Target address that will receive the token.\\r\\n     * `tokenId` - Token ID to be transferred.\\r\\n     * `_data` - Optional data to send along with the call.\\r\\n     *\\r\\n     * Returns whether the call correctly returned the expected magic value.\\r\\n     */\\r\\n    function _checkContractOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) private returns (bool) {\\r\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\r\\n            bytes4 retval\\r\\n        ) {\\r\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\r\\n        } catch (bytes memory reason) {\\r\\n            if (reason.length == 0) {\\r\\n                revert TransferToNonERC721ReceiverImplementer();\\r\\n            } else {\\r\\n                assembly {\\r\\n                    revert(add(32, reason), mload(reason))\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                        MINT OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * Emits a {Transfer} event for each mint.\\r\\n     */\\r\\n    function _mint(address to, uint256 quantity) internal virtual {\\r\\n        uint256 startTokenId = _currentIndex;\\r\\n        if (quantity == 0) revert MintZeroQuantity();\\r\\n\\r\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n\\r\\n        // Overflows are incredibly unrealistic.\\r\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\r\\n        // `tokenId` has a maximum limit of 2**256.\\r\\n        unchecked {\\r\\n            // Updates:\\r\\n            // - `balance += quantity`.\\r\\n            // - `numberMinted += quantity`.\\r\\n            //\\r\\n            // We can directly add to the `balance` and `numberMinted`.\\r\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the owner.\\r\\n            // - `startTimestamp` to the timestamp of minting.\\r\\n            // - `burned` to `false`.\\r\\n            // - `nextInitialized` to `quantity == 1`.\\r\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\r\\n                to,\\r\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\r\\n            );\\r\\n\\r\\n            uint256 toMasked;\\r\\n            uint256 end = startTokenId + quantity;\\r\\n\\r\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\r\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\r\\n            // The assembly, together with the surrounding Solidity code, have been\\r\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\r\\n            assembly {\\r\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n                toMasked := and(to, _BITMASK_ADDRESS)\\r\\n                // Emit the `Transfer` event.\\r\\n                log4(\\r\\n                    0, // Start of data (0, since no data).\\r\\n                    0, // End of data (0, since no data).\\r\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\r\\n                    0, // `address(0)`.\\r\\n                    toMasked, // `to`.\\r\\n                    startTokenId // `tokenId`.\\r\\n                )\\r\\n\\r\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\r\\n                // that overflows uint256 will make the loop run out of gas.\\r\\n                // The compiler will optimize the `iszero` away for performance.\\r\\n                for {\\r\\n                    let tokenId := add(startTokenId, 1)\\r\\n                } iszero(eq(tokenId, end)) {\\r\\n                    tokenId := add(tokenId, 1)\\r\\n                } {\\r\\n                    // Emit the `Transfer` event. Similar to above.\\r\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\r\\n                }\\r\\n            }\\r\\n            if (toMasked == 0) revert MintToZeroAddress();\\r\\n\\r\\n            _currentIndex = end;\\r\\n        }\\r\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * This function is intended for efficient minting only during contract creation.\\r\\n     *\\r\\n     * It emits only one {ConsecutiveTransfer} as defined in\\r\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\r\\n     * instead of a sequence of {Transfer} event(s).\\r\\n     *\\r\\n     * Calling this function outside of contract creation WILL make your contract\\r\\n     * non-compliant with the ERC721 standard.\\r\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\r\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * Emits a {ConsecutiveTransfer} event.\\r\\n     */\\r\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\r\\n        uint256 startTokenId = _currentIndex;\\r\\n        if (to == address(0)) revert MintToZeroAddress();\\r\\n        if (quantity == 0) revert MintZeroQuantity();\\r\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\r\\n\\r\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n\\r\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\r\\n        unchecked {\\r\\n            // Updates:\\r\\n            // - `balance += quantity`.\\r\\n            // - `numberMinted += quantity`.\\r\\n            //\\r\\n            // We can directly add to the `balance` and `numberMinted`.\\r\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the owner.\\r\\n            // - `startTimestamp` to the timestamp of minting.\\r\\n            // - `burned` to `false`.\\r\\n            // - `nextInitialized` to `quantity == 1`.\\r\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\r\\n                to,\\r\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\r\\n            );\\r\\n\\r\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\r\\n\\r\\n            _currentIndex = startTokenId + quantity;\\r\\n        }\\r\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * See {_mint}.\\r\\n     *\\r\\n     * Emits a {Transfer} event for each mint.\\r\\n     */\\r\\n    function _safeMint(\\r\\n        address to,\\r\\n        uint256 quantity,\\r\\n        bytes memory _data\\r\\n    ) internal virtual {\\r\\n        _mint(to, quantity);\\r\\n\\r\\n        unchecked {\\r\\n            if (to.code.length != 0) {\\r\\n                uint256 end = _currentIndex;\\r\\n                uint256 index = end - quantity;\\r\\n                do {\\r\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\r\\n                        revert TransferToNonERC721ReceiverImplementer();\\r\\n                    }\\r\\n                } while (index < end);\\r\\n                // Reentrancy protection.\\r\\n                if (_currentIndex != end) revert();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\r\\n     */\\r\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\r\\n        _safeMint(to, quantity, '');\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                        BURN OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\r\\n     */\\r\\n    function _burn(uint256 tokenId) internal virtual {\\r\\n        _burn(tokenId, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `tokenId`.\\r\\n     * The approval is cleared when the token is burned.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\r\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\r\\n\\r\\n        address from = address(uint160(prevOwnershipPacked));\\r\\n\\r\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\r\\n\\r\\n        if (approvalCheck) {\\r\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\r\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\r\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\r\\n        }\\r\\n\\r\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\r\\n\\r\\n        // Clear approvals from the previous owner.\\r\\n        assembly {\\r\\n            if approvedAddress {\\r\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\r\\n                sstore(approvedAddressSlot, 0)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\r\\n        unchecked {\\r\\n            // Updates:\\r\\n            // - `balance -= 1`.\\r\\n            // - `numberBurned += 1`.\\r\\n            //\\r\\n            // We can directly decrement the balance, and increment the number burned.\\r\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\r\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the last owner.\\r\\n            // - `startTimestamp` to the timestamp of burning.\\r\\n            // - `burned` to `true`.\\r\\n            // - `nextInitialized` to `true`.\\r\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\r\\n                from,\\r\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\r\\n            );\\r\\n\\r\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\r\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\r\\n                uint256 nextTokenId = tokenId + 1;\\r\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\r\\n                if (_packedOwnerships[nextTokenId] == 0) {\\r\\n                    // If the next slot is within bounds.\\r\\n                    if (nextTokenId != _currentIndex) {\\r\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\r\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), tokenId);\\r\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\r\\n\\r\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\r\\n        unchecked {\\r\\n            _burnCounter++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                     EXTRA DATA OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Directly sets the extra data for the ownership data `index`.\\r\\n     */\\r\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\r\\n        uint256 packed = _packedOwnerships[index];\\r\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\r\\n        uint256 extraDataCasted;\\r\\n        // Cast `extraData` with assembly to avoid redundant masking.\\r\\n        assembly {\\r\\n            extraDataCasted := extraData\\r\\n        }\\r\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\r\\n        _packedOwnerships[index] = packed;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\r\\n     * Intended to be overridden by the cosumer contract.\\r\\n     *\\r\\n     * `previousExtraData` - the value of `extraData` before transfer.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _extraData(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint24 previousExtraData\\r\\n    ) internal view virtual returns (uint24) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the next extra data for the packed ownership data.\\r\\n     * The returned result is shifted into position.\\r\\n     */\\r\\n    function _nextExtraData(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 prevOwnershipPacked\\r\\n    ) private view returns (uint256) {\\r\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\r\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                       OTHER OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\r\\n     *\\r\\n     * If you are writing GSN compatible contracts, you need to override this function.\\r\\n     */\\r\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\r\\n     */\\r\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\r\\n        assembly {\\r\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\r\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\r\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\r\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\r\\n            let m := add(mload(0x40), 0xa0)\\r\\n            // Update the free memory pointer to allocate.\\r\\n            mstore(0x40, m)\\r\\n            // Assign the `str` to the end.\\r\\n            str := sub(m, 0x20)\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end of the memory to calculate the length later.\\r\\n            let end := str\\r\\n\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            // prettier-ignore\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := sub(str, 1)\\r\\n                // Write the character to the pointer.\\r\\n                // The ASCII index of the '0' character is 48.\\r\\n                mstore8(str, add(48, mod(temp, 10)))\\r\\n                // Keep dividing `temp` until zero.\\r\\n                temp := div(temp, 10)\\r\\n                // prettier-ignore\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            let length := sub(end, str)\\r\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\r\\n            str := sub(str, 0x20)\\r\\n            // Store the length.\\r\\n            mstore(str, length)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Interface of ERC721A.\\r\\n */\\r\\ninterface IERC721A {\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error ApprovalQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * Cannot query the balance for the zero address.\\r\\n     */\\r\\n    error BalanceQueryForZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * Cannot mint to the zero address.\\r\\n     */\\r\\n    error MintToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The quantity of tokens minted must be more than zero.\\r\\n     */\\r\\n    error MintZeroQuantity();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error OwnerQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token must be owned by `from`.\\r\\n     */\\r\\n    error TransferFromIncorrectOwner();\\r\\n\\r\\n    /**\\r\\n     * Cannot safely transfer to a contract that does not implement the\\r\\n     * ERC721Receiver interface.\\r\\n     */\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /**\\r\\n     * Cannot transfer to the zero address.\\r\\n     */\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error URIQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\r\\n     */\\r\\n    error MintERC2309QuantityExceedsLimit();\\r\\n\\r\\n    /**\\r\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\r\\n     */\\r\\n    error OwnershipNotInitializedForExtraData();\\r\\n\\r\\n    // =============================================================\\r\\n    //                            STRUCTS\\r\\n    // =============================================================\\r\\n\\r\\n    struct TokenOwnership {\\r\\n        // The address of the owner.\\r\\n        address addr;\\r\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\r\\n        uint64 startTimestamp;\\r\\n        // Whether the token has been burned.\\r\\n        bool burned;\\r\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\r\\n        uint24 extraData;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                         TOKEN COUNTERS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens in existence.\\r\\n     * Burned tokens will reduce the count.\\r\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC165\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC721\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables\\r\\n     * (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in `owner`'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\r\\n     * checking first that contract recipients are aware of the ERC721 protocol\\r\\n     * to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move\\r\\n     * this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\r\\n     * whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the\\r\\n     * zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\r\\n     * for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    // =============================================================\\r\\n    //                        IERC721Metadata\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    // =============================================================\\r\\n    //                           IERC2309\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\r\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\r\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\r\\n     *\\r\\n     * See {_mintERC2309} for more details.\\r\\n     */\\r\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport './IERC721AQueryable.sol';\\r\\nimport '../ERC721A.sol';\\r\\n\\r\\n/**\\r\\n * @title ERC721AQueryable.\\r\\n *\\r\\n * @dev ERC721A subclass with convenience query functions.\\r\\n */\\r\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\r\\n    /**\\r\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\r\\n     *\\r\\n     * If the `tokenId` is out of bounds:\\r\\n     *\\r\\n     * - `addr = address(0)`\\r\\n     * - `startTimestamp = 0`\\r\\n     * - `burned = false`\\r\\n     * - `extraData = 0`\\r\\n     *\\r\\n     * If the `tokenId` is burned:\\r\\n     *\\r\\n     * - `addr = <Address of owner before token was burned>`\\r\\n     * - `startTimestamp = <Timestamp when token was burned>`\\r\\n     * - `burned = true`\\r\\n     * - `extraData = <Extra data when token was burned>`\\r\\n     *\\r\\n     * Otherwise:\\r\\n     *\\r\\n     * - `addr = <Address of owner>`\\r\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\r\\n     * - `burned = false`\\r\\n     * - `extraData = <Extra data at start of ownership>`\\r\\n     */\\r\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\r\\n        TokenOwnership memory ownership;\\r\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\r\\n            return ownership;\\r\\n        }\\r\\n        ownership = _ownershipAt(tokenId);\\r\\n        if (ownership.burned) {\\r\\n            return ownership;\\r\\n        }\\r\\n        return _ownershipOf(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\r\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\r\\n     */\\r\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\r\\n        external\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (TokenOwnership[] memory)\\r\\n    {\\r\\n        unchecked {\\r\\n            uint256 tokenIdsLength = tokenIds.length;\\r\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\r\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\r\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\r\\n            }\\r\\n            return ownerships;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an array of token IDs owned by `owner`,\\r\\n     * in the range [`start`, `stop`)\\r\\n     * (i.e. `start <= tokenId < stop`).\\r\\n     *\\r\\n     * This function allows for tokens to be queried if the collection\\r\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `start < stop`\\r\\n     */\\r\\n    function tokensOfOwnerIn(\\r\\n        address owner,\\r\\n        uint256 start,\\r\\n        uint256 stop\\r\\n    ) external view virtual override returns (uint256[] memory) {\\r\\n        unchecked {\\r\\n            if (start >= stop) revert InvalidQueryRange();\\r\\n            uint256 tokenIdsIdx;\\r\\n            uint256 stopLimit = _nextTokenId();\\r\\n            // Set `start = max(start, _startTokenId())`.\\r\\n            if (start < _startTokenId()) {\\r\\n                start = _startTokenId();\\r\\n            }\\r\\n            // Set `stop = min(stop, stopLimit)`.\\r\\n            if (stop > stopLimit) {\\r\\n                stop = stopLimit;\\r\\n            }\\r\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\r\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\r\\n            // to cater for cases where `balanceOf(owner)` is too big.\\r\\n            if (start < stop) {\\r\\n                uint256 rangeLength = stop - start;\\r\\n                if (rangeLength < tokenIdsMaxLength) {\\r\\n                    tokenIdsMaxLength = rangeLength;\\r\\n                }\\r\\n            } else {\\r\\n                tokenIdsMaxLength = 0;\\r\\n            }\\r\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\r\\n            if (tokenIdsMaxLength == 0) {\\r\\n                return tokenIds;\\r\\n            }\\r\\n            // We need to call `explicitOwnershipOf(start)`,\\r\\n            // because the slot at `start` may not be initialized.\\r\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\r\\n            address currOwnershipAddr;\\r\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\r\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\r\\n            if (!ownership.burned) {\\r\\n                currOwnershipAddr = ownership.addr;\\r\\n            }\\r\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\r\\n                ownership = _ownershipAt(i);\\r\\n                if (ownership.burned) {\\r\\n                    continue;\\r\\n                }\\r\\n                if (ownership.addr != address(0)) {\\r\\n                    currOwnershipAddr = ownership.addr;\\r\\n                }\\r\\n                if (currOwnershipAddr == owner) {\\r\\n                    tokenIds[tokenIdsIdx++] = i;\\r\\n                }\\r\\n            }\\r\\n            // Downsize the array to fit.\\r\\n            assembly {\\r\\n                mstore(tokenIds, tokenIdsIdx)\\r\\n            }\\r\\n            return tokenIds;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an array of token IDs owned by `owner`.\\r\\n     *\\r\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\r\\n     * It is meant to be called off-chain.\\r\\n     *\\r\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\r\\n     * multiple smaller scans if the collection is large enough to cause\\r\\n     * an out-of-gas error (10K collections should be fine).\\r\\n     */\\r\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\r\\n        unchecked {\\r\\n            uint256 tokenIdsIdx;\\r\\n            address currOwnershipAddr;\\r\\n            uint256 tokenIdsLength = balanceOf(owner);\\r\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\r\\n            TokenOwnership memory ownership;\\r\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\r\\n                ownership = _ownershipAt(i);\\r\\n                if (ownership.burned) {\\r\\n                    continue;\\r\\n                }\\r\\n                if (ownership.addr != address(0)) {\\r\\n                    currOwnershipAddr = ownership.addr;\\r\\n                }\\r\\n                if (currOwnershipAddr == owner) {\\r\\n                    tokenIds[tokenIdsIdx++] = i;\\r\\n                }\\r\\n            }\\r\\n            return tokenIds;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport '../IERC721A.sol';\\r\\n\\r\\n/**\\r\\n * @dev Interface of ERC721AQueryable.\\r\\n */\\r\\ninterface IERC721AQueryable is IERC721A {\\r\\n    /**\\r\\n     * Invalid query range (`start` >= `stop`).\\r\\n     */\\r\\n    error InvalidQueryRange();\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\r\\n     *\\r\\n     * If the `tokenId` is out of bounds:\\r\\n     *\\r\\n     * - `addr = address(0)`\\r\\n     * - `startTimestamp = 0`\\r\\n     * - `burned = false`\\r\\n     * - `extraData = 0`\\r\\n     *\\r\\n     * If the `tokenId` is burned:\\r\\n     *\\r\\n     * - `addr = <Address of owner before token was burned>`\\r\\n     * - `startTimestamp = <Timestamp when token was burned>`\\r\\n     * - `burned = true`\\r\\n     * - `extraData = <Extra data when token was burned>`\\r\\n     *\\r\\n     * Otherwise:\\r\\n     *\\r\\n     * - `addr = <Address of owner>`\\r\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\r\\n     * - `burned = false`\\r\\n     * - `extraData = <Extra data at start of ownership>`\\r\\n     */\\r\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\r\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\r\\n     */\\r\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an array of token IDs owned by `owner`,\\r\\n     * in the range [`start`, `stop`)\\r\\n     * (i.e. `start <= tokenId < stop`).\\r\\n     *\\r\\n     * This function allows for tokens to be queried if the collection\\r\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `start < stop`\\r\\n     */\\r\\n    function tokensOfOwnerIn(\\r\\n        address owner,\\r\\n        uint256 start,\\r\\n        uint256 stop\\r\\n    ) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an array of token IDs owned by `owner`.\\r\\n     *\\r\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\r\\n     * It is meant to be called off-chain.\\r\\n     *\\r\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\r\\n     * multiple smaller scans if the collection is large enough to cause\\r\\n     * an out-of-gas error (10K collections should be fine).\\r\\n     */\\r\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IAccessControl.sol\\\";\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\nimport \\\"../utils/Strings.sol\\\";\\r\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module that allows children to implement role-based access\\r\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\r\\n * members except through off-chain means by accessing the contract event logs. Some\\r\\n * applications may benefit from on-chain enumerability, for those cases see\\r\\n * {AccessControlEnumerable}.\\r\\n *\\r\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\r\\n * in the external API and be unique. The best way to achieve this is by\\r\\n * using `public constant` hash digests:\\r\\n *\\r\\n * ```\\r\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\r\\n * ```\\r\\n *\\r\\n * Roles can be used to represent a set of permissions. To restrict access to a\\r\\n * function call, use {hasRole}:\\r\\n *\\r\\n * ```\\r\\n * function foo() public {\\r\\n *     require(hasRole(MY_ROLE, msg.sender));\\r\\n *     ...\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\r\\n * {revokeRole} functions. Each role has an associated admin role, and only\\r\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\r\\n *\\r\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\r\\n * that only accounts with this role will be able to grant or revoke other\\r\\n * roles. More complex role relationships can be created by using\\r\\n * {_setRoleAdmin}.\\r\\n *\\r\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\r\\n * grant and revoke this role. Extra precautions should be taken to secure\\r\\n * accounts that have been granted it.\\r\\n */\\r\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\r\\n    struct RoleData {\\r\\n        mapping(address => bool) members;\\r\\n        bytes32 adminRole;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 => RoleData) private _roles;\\r\\n\\r\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\r\\n     * with a standardized message including the required role.\\r\\n     *\\r\\n     * The format of the revert reason is given by the following regular expression:\\r\\n     *\\r\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\r\\n     *\\r\\n     * _Available since v4.1._\\r\\n     */\\r\\n    modifier onlyRole(bytes32 role) {\\r\\n        _checkRole(role);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\r\\n        return _roles[role].members[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\r\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\r\\n     *\\r\\n     * Format of the revert message is described in {_checkRole}.\\r\\n     *\\r\\n     * _Available since v4.6._\\r\\n     */\\r\\n    function _checkRole(bytes32 role) internal view virtual {\\r\\n        _checkRole(role, _msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with a standard message if `account` is missing `role`.\\r\\n     *\\r\\n     * The format of the revert reason is given by the following regular expression:\\r\\n     *\\r\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\r\\n     */\\r\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\r\\n        if (!hasRole(role, account)) {\\r\\n            revert(\\r\\n                string(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"AccessControl: account \\\",\\r\\n                        Strings.toHexString(account),\\r\\n                        \\\" is missing role \\\",\\r\\n                        Strings.toHexString(uint256(role), 32)\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\r\\n        return _roles[role].adminRole;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     *\\r\\n     * May emit a {RoleGranted} event.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     *\\r\\n     * May emit a {RoleRevoked} event.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     *\\r\\n     * May emit a {RoleRevoked} event.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) public virtual override {\\r\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\r\\n     * checks on the calling account.\\r\\n     *\\r\\n     * May emit a {RoleGranted} event.\\r\\n     *\\r\\n     * [WARNING]\\r\\n     * ====\\r\\n     * This function should only be called from the constructor when setting\\r\\n     * up the initial roles for the system.\\r\\n     *\\r\\n     * Using this function in any other way is effectively circumventing the admin\\r\\n     * system imposed by {AccessControl}.\\r\\n     * ====\\r\\n     *\\r\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\r\\n     */\\r\\n    function _setupRole(bytes32 role, address account) internal virtual {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\r\\n     *\\r\\n     * Emits a {RoleAdminChanged} event.\\r\\n     */\\r\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\r\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\r\\n        _roles[role].adminRole = adminRole;\\r\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * Internal function without access restriction.\\r\\n     *\\r\\n     * May emit a {RoleGranted} event.\\r\\n     */\\r\\n    function _grantRole(bytes32 role, address account) internal virtual {\\r\\n        if (!hasRole(role, account)) {\\r\\n            _roles[role].members[account] = true;\\r\\n            emit RoleGranted(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * Internal function without access restriction.\\r\\n     *\\r\\n     * May emit a {RoleRevoked} event.\\r\\n     */\\r\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\r\\n        if (hasRole(role, account)) {\\r\\n            _roles[role].members[account] = false;\\r\\n            emit RoleRevoked(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\r\\n */\\r\\ninterface IAccessControl {\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {AccessControl-_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the NFT Royalty Standard.\\r\\n *\\r\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\r\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\r\\n *\\r\\n * _Available since v4.5._\\r\\n */\\r\\ninterface IERC2981 is IERC165 {\\r\\n    /**\\r\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\r\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\r\\n     */\\r\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\r\\n        external\\r\\n        view\\r\\n        returns (address receiver, uint256 royaltyAmount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\r\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\r\\n *\\r\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\r\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\r\\n *\\r\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\r\\n * fee is specified in basis points by default.\\r\\n *\\r\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\r\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\r\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\r\\n *\\r\\n * _Available since v4.5._\\r\\n */\\r\\nabstract contract ERC2981 is IERC2981, ERC165 {\\r\\n    struct RoyaltyInfo {\\r\\n        address receiver;\\r\\n        uint96 royaltyFraction;\\r\\n    }\\r\\n\\r\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\r\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\r\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IERC2981\\r\\n     */\\r\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\r\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\r\\n\\r\\n        if (royalty.receiver == address(0)) {\\r\\n            royalty = _defaultRoyaltyInfo;\\r\\n        }\\r\\n\\r\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\r\\n\\r\\n        return (royalty.receiver, royaltyAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\r\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\r\\n     * override.\\r\\n     */\\r\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\r\\n        return 10000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `receiver` cannot be the zero address.\\r\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\r\\n     */\\r\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\r\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\r\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\r\\n\\r\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes default royalty information.\\r\\n     */\\r\\n    function _deleteDefaultRoyalty() internal virtual {\\r\\n        delete _defaultRoyaltyInfo;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `receiver` cannot be the zero address.\\r\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\r\\n     */\\r\\n    function _setTokenRoyalty(\\r\\n        uint256 tokenId,\\r\\n        address receiver,\\r\\n        uint96 feeNumerator\\r\\n    ) internal virtual {\\r\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\r\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\r\\n\\r\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Resets royalty information for the token id back to the global default.\\r\\n     */\\r\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\r\\n        delete _tokenRoyaltyInfo[tokenId];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./math/Math.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    enum Rounding {\\r\\n        Down, // Toward negative infinity\\r\\n        Up, // Toward infinity\\r\\n        Zero // Toward zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds up instead\\r\\n     * of rounding down.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\r\\n     * with further edits by Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod0 := mul(x, y)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            require(denominator > prod1);\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n            // See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n            uint256 twos = denominator & (~denominator + 1);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n            // in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 denominator,\\r\\n        Rounding rounding\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10**64) {\\r\\n                value /= 10**64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10**32) {\\r\\n                value /= 10**32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10**16) {\\r\\n                value /= 10**16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10**8) {\\r\\n                value /= 10**8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10**4) {\\r\\n                value /= 10**4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10**2) {\\r\\n                value /= 10**2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10**1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n *\\r\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\r\\n * all math on `uint256` and `int256` and then downcasting.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\r\\n        return int256(value);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\r\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\r\\n/**\\r\\n * @title  DefaultOperatorFilterer\\r\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\r\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\r\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\r\\n *         will be locked to the options set during construction.\\r\\n */\\r\\n\\r\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\r\\n    /// @dev The constructor that is called when the contract is being deployed.\\r\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IOperatorFilterRegistry {\\r\\n    /**\\r\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\r\\n     *         true if supplied registrant address is not registered.\\r\\n     */\\r\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\r\\n     */\\r\\n    function register(address registrant) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\r\\n     */\\r\\n    function registerAndSubscribe(address registrant, address subscription) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\r\\n     *         address without subscribing.\\r\\n     */\\r\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\r\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\r\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\r\\n     */\\r\\n    function unregister(address addr) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\r\\n     */\\r\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\r\\n     */\\r\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\r\\n     */\\r\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\r\\n     */\\r\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\r\\n     *         subscription if present.\\r\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\r\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\r\\n     *         used.\\r\\n     */\\r\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\r\\n     */\\r\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Get the subscription address of a given registrant, if any.\\r\\n     */\\r\\n    function subscriptionOf(address addr) external returns (address registrant);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the set of addresses subscribed to a given registrant.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function subscribers(address registrant) external returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\r\\n     */\\r\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\r\\n     */\\r\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\r\\n     */\\r\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\r\\n     */\\r\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\r\\n     */\\r\\n    function filteredOperators(address addr) external returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\r\\n     *         its subscription.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\r\\n     *         its subscription.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if an address has registered\\r\\n     */\\r\\n    function isRegistered(address addr) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\r\\n     */\\r\\n    function codeHashOf(address addr) external returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\r\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\r\\n/**\\r\\n * @title  OperatorFilterer\\r\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\r\\n *         registrant's entries in the OperatorFilterRegistry.\\r\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\r\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\r\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\r\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\r\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\r\\n *         will be locked to the options set during construction.\\r\\n */\\r\\n\\r\\nabstract contract OperatorFilterer {\\r\\n    /// @dev Emitted when an operator is not allowed.\\r\\n    error OperatorNotAllowed(address operator);\\r\\n\\r\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\r\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\r\\n\\r\\n    /// @dev The constructor that is called when the contract is being deployed.\\r\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\r\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\r\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\r\\n        // order for the modifier to filter addresses.\\r\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\r\\n            if (subscribe) {\\r\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\r\\n            } else {\\r\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\r\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\r\\n                } else {\\r\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A helper function to check if an operator is allowed.\\r\\n     */\\r\\n    modifier onlyAllowedOperator(address from) virtual {\\r\\n        // Allow spending tokens from addresses with balance\\r\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\r\\n        // from an EOA.\\r\\n        if (from != msg.sender) {\\r\\n            _checkFilterOperator(msg.sender);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A helper function to check if an operator approval is allowed.\\r\\n     */\\r\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\r\\n        _checkFilterOperator(operator);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A helper function to check if an operator is allowed.\\r\\n     */\\r\\n    function _checkFilterOperator(address operator) internal view virtual {\\r\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\r\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\r\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\r\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\r\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\r\\n                revert OperatorNotAllowed(operator);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\r\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\r\\n\"\r\n    },\r\n    \"src/AuctionEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n/* \\r\\nStages of the auction\\r\\n\\r\\nNOT_STARTED - initial stage, before bidding is allowed\\r\\nACTIVE - bids are allowed, the auction is active\\r\\nBIDDING_CLOSED - bids are closed, the price needs to be set\\r\\nCLAIMS_AND_REFUNDS - bidders can claim their winnings and receive any refunds\\r\\nREVEALS_OPEN - claims and refunds are still active, additionally\\r\\n               owners of pods are now able to reveal their pod\\r\\n */\\r\\nenum AuctionStage {\\r\\n    NOT_STARTED,\\r\\n    ACTIVE,\\r\\n    BIDDING_CLOSED,\\r\\n    CLAIMS_AND_REFUNDS,\\r\\n    REVEALS_OPEN\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENCED\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface XDroidsInterface {\\r\\n    function mintFromXPod(address to) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/XPodsAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENCED\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\r\\nimport \\\"erc721a/contracts/extensions/ERC721AQueryable.sol\\\";\\r\\nimport \\\"erc721a/contracts/IERC721A.sol\\\";\\r\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./AuctionEnums.sol\\\";\\r\\n\\r\\ncontract XPodsAuction is\\r\\n    DefaultOperatorFilterer,\\r\\n    ERC721AQueryable,\\r\\n    ReentrancyGuard,\\r\\n    AccessControl,\\r\\n    ERC2981,\\r\\n    Ownable\\r\\n{\\r\\n    using Math for uint256;\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    bytes32 public constant SUPPORT_ROLE = keccak256(\\\"SUPPORT\\\");\\r\\n\\r\\n    // initial stage\\r\\n    AuctionStage public stage;\\r\\n\\r\\n    // the maximum pods that can be minted by this contract\\r\\n    uint256 public constant MAX_SUPPLY = 20;\\r\\n\\r\\n    // the maximum pods that can be minted to the team by the support role\\r\\n    uint256 public constant MAX_TEAM_MINT = 10;\\r\\n\\r\\n    // this applies only during auction distribution of items own\\r\\n    uint256 public constant MAX_PODS_WIN_PER_WALLET = 1;\\r\\n\\r\\n    // the current minimum bid\\r\\n    uint256 public minimumBid = 0.1 ether;\\r\\n\\r\\n    // counter for the pods minted to the team\\r\\n    uint256 public podsMintedToTeam;\\r\\n\\r\\n    // the amount of funds already withdrawhn by the owner for pod sales\\r\\n    uint256 public podSalesWithdrawnByOwner;\\r\\n\\r\\n    // the base URI for the metadata\\r\\n    string public baseURI;\\r\\n\\r\\n    // the URI for the contract level metadata\\r\\n    // @dev see https://docs.opensea.io/docs/contract-level-metadata\\r\\n    string public contractMetadataURI;\\r\\n\\r\\n    // the address of the XDroids contract\\r\\n    address public xDroidsContractAddress;\\r\\n\\r\\n    // uint120 is 15 bytes, therefore the whole struct is 31 bytes\\r\\n    // this improves gas perfomance of claim and bid by quite a large margin\\r\\n    struct User {\\r\\n        // cumulative sum of ETH bids\\r\\n        uint120 totalBid;\\r\\n        // whether or not the user has claimed already\\r\\n        // @dev 1 byte\\r\\n        bool claimed;\\r\\n        // total funds refunded to the user\\r\\n        uint120 refundedFunds;\\r\\n    }\\r\\n\\r\\n    // users bids and refunds\\r\\n    mapping(address => User) public userData;\\r\\n\\r\\n    // the price as computed by the binary search algorithm\\r\\n    // it get set after the bidding is closed\\r\\n    uint256 public price;\\r\\n\\r\\n    /**\\r\\n     * EVENTS\\r\\n     */\\r\\n    event Bid(\\r\\n        address bidder,\\r\\n        uint256 bidAmount,\\r\\n        uint256 bidderTotal,\\r\\n        uint256 bucketTotal\\r\\n    );\\r\\n\\r\\n    // when a bidder is refunded\\r\\n    event RefundSent(address recipient, uint256 value);\\r\\n\\r\\n    // when a pod is exchanged for an XDroid\\r\\n    event XDroidRevealed(address owner, uint256 droidTokenId, uint256 burnedPodTokenId);\\r\\n\\r\\n    event XDroidContractSet(address contractAddress);\\r\\n    event AuctionStarted();\\r\\n    event MinimumBidChanged(uint256 newMinBid);\\r\\n    event AuctionEnded();\\r\\n    event PriceSet(uint256 newPrice);\\r\\n    event ClaimsAndRefundsStarted();\\r\\n    event RevealsOpen();\\r\\n    event FundsWithdrawn(address recipient, uint256 amount);\\r\\n    event MintedToTeam(address recipient, uint256 podsCount);\\r\\n    event BaseURISet(string baseURI);\\r\\n    event RoyaltyChanged(address receiver, uint96 feeNumerator);\\r\\n\\r\\n    // when a user claims their pods and/or refunds\\r\\n    event Claimed(address recipient, uint256 totalBid, uint256 podsWon, uint256 refund);\\r\\n\\r\\n    /**\\r\\n     * ERRORS\\r\\n     */\\r\\n    error WithdrawToNullAddress();\\r\\n    error RefundToNullAddress();\\r\\n    error NoClaimsDuringBiddingStage();\\r\\n    error StageMustBeClaimsAndRefunds(AuctionStage currentStage);\\r\\n    error MinBidMustBeGreaterThanZero(uint256 minBidInput);\\r\\n    error PriceIsLowerThanTheMinBid(uint256 priceInput, uint256 minBid);\\r\\n    error PriceMustBeSet();\\r\\n    error FinalPriceMustMatchSetPrice();\\r\\n    error CannotWithdrawBeforeClaimsStage(AuctionStage currentStage);\\r\\n    error NoClaimsAllowedInCurrentStage(AuctionStage currentStage);\\r\\n    error BidLowerThanMinimum(uint256 bid, uint256 minBid);\\r\\n    error AuctionMustNotBeStarted();\\r\\n    error StageMustBeBiddingClosed(AuctionStage currentStage);\\r\\n    error AuctionMustBeActive(AuctionStage currentStage);\\r\\n    error NullAddressParameter(string paramName);\\r\\n    error XDroidChangeAfterAuctionStarted();\\r\\n    error WithdrawFailed(address recipient, uint256 amount);\\r\\n    error RefundFailed(address recipient, uint256 amount);\\r\\n    error AlreadyRefunded(address recipient);\\r\\n    error AlreadyClaimed(address claimaint);\\r\\n    error RevealsNotOpenYet();\\r\\n    error TokenNotMinted(uint256 tokenId);\\r\\n    error MustBeTokenOwner(address wallet, uint256 tokenId);\\r\\n    error ExceedsMaxTeamMint(uint256 requestedPods, uint256 maxPods);\\r\\n    error ZeroBids(address user);\\r\\n    error NotEnoughPodsSold();\\r\\n    error BaseURICannotBeEmpty();\\r\\n    error XDroidContractNotSet();\\r\\n    error NoFundsToWithdraw();\\r\\n\\r\\n    constructor() ERC721A(\\\"X Pods\\\", \\\"X-POD\\\") {\\r\\n        // set up roles\\r\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\r\\n        _setupRole(SUPPORT_ROLE, msg.sender);\\r\\n\\r\\n        // set the default royalty to 7.5%\\r\\n        _setDefaultRoyalty(msg.sender, 750);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice begin the auction\\r\\n     */\\r\\n    function startAuction() external onlyRole(SUPPORT_ROLE) {\\r\\n        if (stage != AuctionStage.NOT_STARTED) {\\r\\n            revert AuctionMustNotBeStarted();\\r\\n        }\\r\\n\\r\\n        // the XDroid contract must be known and set before the auction starts\\r\\n        if (xDroidsContractAddress == address(0)) {\\r\\n            revert XDroidContractNotSet();\\r\\n        }\\r\\n\\r\\n        stage = AuctionStage.ACTIVE;\\r\\n\\r\\n        emit AuctionStarted();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A wallet with the support role starts the claims and refund stage\\r\\n     * if the price in Wei was not set correctly, there's a chance the claims and refunds\\r\\n     * will start with the wrong price and then the will be no way of rectifying this mistake\\r\\n     * therefore the price @param finalPrice must be sent again here to confirm the price\\r\\n     */\\r\\n    function startClaimsAndRefunds(uint256 finalPrice) external onlyRole(SUPPORT_ROLE) {\\r\\n        // storage to memory\\r\\n        AuctionStage stageMem = stage;\\r\\n\\r\\n        // revert if the stage is not \\\"bidding closed\\\"\\r\\n        if (stageMem != AuctionStage.BIDDING_CLOSED) {\\r\\n            revert StageMustBeBiddingClosed(stageMem);\\r\\n        }\\r\\n\\r\\n        uint256 priceMem = price;\\r\\n        if (priceMem == 0) {\\r\\n            revert PriceMustBeSet();\\r\\n        }\\r\\n\\r\\n        if (finalPrice != priceMem) {\\r\\n            revert FinalPriceMustMatchSetPrice();\\r\\n        }\\r\\n\\r\\n        emit ClaimsAndRefundsStarted();\\r\\n        stage = AuctionStage.CLAIMS_AND_REFUNDS;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @notice determine whether the stage is after the bidding stage\\r\\n     */\\r\\n    function stageIsAfterBidding(AuctionStage stageMem) public pure returns (bool) {\\r\\n        return\\r\\n            stageMem == AuctionStage.CLAIMS_AND_REFUNDS ||\\r\\n            stageMem == AuctionStage.REVEALS_OPEN;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A wallet with the support role starts the reveals stage\\r\\n     */\\r\\n    function startReveals() external onlyRole(SUPPORT_ROLE) {\\r\\n        // storage to memory\\r\\n        AuctionStage _stage = stage;\\r\\n        if (_stage != AuctionStage.CLAIMS_AND_REFUNDS) {\\r\\n            revert StageMustBeClaimsAndRefunds(_stage);\\r\\n        }\\r\\n\\r\\n        emit RevealsOpen();\\r\\n        stage = AuctionStage.REVEALS_OPEN;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice end the auction.\\r\\n     */\\r\\n    function endAuction() external onlyRole(SUPPORT_ROLE) {\\r\\n        // storage to memory\\r\\n        AuctionStage _stage = stage;\\r\\n\\r\\n        if (_stage != AuctionStage.ACTIVE) {\\r\\n            revert AuctionMustBeActive(_stage);\\r\\n        }\\r\\n\\r\\n        stage = AuctionStage.BIDDING_CLOSED;\\r\\n\\r\\n        emit AuctionEnded();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice place a bid in ETH or add to your existing bid. Calling this\\r\\n     *   multiple times will increase your bid amount. All bids placed are final\\r\\n     *   and cannot be reversed.\\r\\n     */\\r\\n    function bid() external payable {\\r\\n        // storage to memory\\r\\n        AuctionStage _stage = stage;\\r\\n        if (stage != AuctionStage.ACTIVE) {\\r\\n            revert AuctionMustBeActive(_stage);\\r\\n        }\\r\\n\\r\\n        User memory bidder = userData[msg.sender]; // user into memory\\r\\n\\r\\n        uint256 minBid = minimumBid; // storage to memory\\r\\n        // bidder.totalBid is uint216\\r\\n        uint256 totalUserBid = bidder.totalBid;\\r\\n\\r\\n        // increment the bid of the user\\r\\n        totalUserBid += msg.value;\\r\\n\\r\\n        // if their new total bid is less than the current minimum bid\\r\\n        // revert with an error\\r\\n        // note: we don't validate the current incoming bid increment against\\r\\n        // the minimum bid, the requirement is bid (0 iniitally) + increment < minimim bid\\r\\n        // rather than increment < minimum bid\\r\\n        if (totalUserBid < minBid) {\\r\\n            revert BidLowerThanMinimum(totalUserBid, minBid);\\r\\n        }\\r\\n\\r\\n        bidder.totalBid = SafeCast.toUint120(totalUserBid);\\r\\n        emit Bid(msg.sender, msg.value, totalUserBid, address(this).balance);\\r\\n\\r\\n        // reassign\\r\\n        userData[msg.sender] = bidder;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice set the minimum contribution required to place a bid\\r\\n     * @dev set this price in wei, not eth!\\r\\n     * @param newMinimumBid new price, set in wei\\r\\n     */\\r\\n    function setMinimumBid(uint256 newMinimumBid) external onlyRole(SUPPORT_ROLE) {\\r\\n        if (newMinimumBid == 0) {\\r\\n            revert MinBidMustBeGreaterThanZero(newMinimumBid);\\r\\n        }\\r\\n\\r\\n        emit MinimumBidChanged(newMinimumBid);\\r\\n        minimumBid = newMinimumBid;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice set the clearing price after all bids have been placed.\\r\\n     * @dev set this price in wei, not eth!\\r\\n     * @param newPrice new price, set in wei\\r\\n     */\\r\\n    function setPrice(uint256 newPrice) external onlyRole(SUPPORT_ROLE) {\\r\\n        AuctionStage stageMem = stage; // storage to memory\\r\\n        if (stageMem != AuctionStage.BIDDING_CLOSED) {\\r\\n            revert StageMustBeBiddingClosed(stageMem);\\r\\n        }\\r\\n\\r\\n        uint256 minBid = minimumBid; // storage to memory\\r\\n        if (newPrice < minBid) {\\r\\n            revert PriceIsLowerThanTheMinBid(newPrice, minBid);\\r\\n        }\\r\\n        price = newPrice;\\r\\n        emit PriceSet(newPrice);\\r\\n    }\\r\\n\\r\\n    function remainingSupply() public view returns (uint256) {\\r\\n        return MAX_SUPPLY - MAX_TEAM_MINT - _totalMinted();\\r\\n    }\\r\\n\\r\\n    // function hasMoreSupplyFor(uint256 numberOfTokens) internal view returns (bool) {\\r\\n    //     return remainingSupply() >= numberOfTokens;\\r\\n    // }\\r\\n\\r\\n    /**\\r\\n     * @dev handles all minting.\\r\\n     * @param to address to mint tokens to.\\r\\n     * @param numberOfTokens number of tokens to mint.\\r\\n     */\\r\\n    function _internalMint(address to, uint256 numberOfTokens) internal {\\r\\n        _safeMint(to, numberOfTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev overriding from ERC721: start at the 1st token instead of 0\\r\\n     */\\r\\n    function _startTokenId() internal pure override returns (uint256) {\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev calculate the reufund for a bid and a price\\r\\n     * @param userBid total bid\\r\\n     * @param _price final price\\r\\n     */\\r\\n    function _refundAmount(\\r\\n        uint256 userBid,\\r\\n        uint256 _price\\r\\n    ) internal pure returns (uint256) {\\r\\n        // @dev taking the whole part only from the division and limiting to\\r\\n        // the max pods number that can be won\\r\\n        uint256 podsWon = Math.min(userBid / _price, MAX_PODS_WIN_PER_WALLET);\\r\\n\\r\\n        // the refund is the difference between the bid and the price\\r\\n        // to pay for the pods\\r\\n        return userBid - (podsWon * _price);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice send refund to an address. Refunds are unsuccessful bids or\\r\\n     * an address's remaining eth after all their tokens have been paid for.\\r\\n     * @dev can only be called after the price has been set\\r\\n     * @param to the address to refund to\\r\\n     */\\r\\n    function sendRefund(address to) public onlyRole(SUPPORT_ROLE) {\\r\\n        if (to == address(0)) {\\r\\n            revert RefundToNullAddress();\\r\\n        }\\r\\n\\r\\n        uint256 priceMem = price; // storage to memory\\r\\n        if (priceMem == 0) {\\r\\n            revert PriceMustBeSet();\\r\\n        }\\r\\n\\r\\n        User memory user = userData[to]; // get user data in memory\\r\\n\\r\\n        if (user.refundedFunds > 0) {\\r\\n            revert AlreadyRefunded(to);\\r\\n        }\\r\\n\\r\\n        uint256 refundValue = _refundAmount(user.totalBid, priceMem);\\r\\n\\r\\n        if (refundValue > 0) {\\r\\n            emit RefundSent(msg.sender, refundValue);\\r\\n\\r\\n            user.refundedFunds = SafeCast.toUint120(refundValue);\\r\\n            // reassign\\r\\n            // @dev this is the only write, hence inside the if statement\\r\\n            userData[to] = user;\\r\\n\\r\\n            // send the refund\\r\\n            (bool success, ) = to.call{value: refundValue}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                revert RefundFailed(to, refundValue);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice send refunds to a batch of addresses.\\r\\n     * @param addresses array of addresses to refund.\\r\\n     */\\r\\n    function sendRefundBatch(\\r\\n        address[] calldata addresses\\r\\n    ) external onlyRole(SUPPORT_ROLE) {\\r\\n        for (uint256 i; i < addresses.length; ++i) {\\r\\n            sendRefund(addresses[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice for claiming pods and refunds\\r\\n     */\\r\\n    function claim() public nonReentrant {\\r\\n        _internalClaim(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice claim tokens and refund for an address.\\r\\n     * @dev it is needed, since the withdraw function only allows to withdraw\\r\\n     * funds for claimed pods\\r\\n     * @param receiver the address to claim tokens for.\\r\\n     */\\r\\n    function claimOnBehalfOf(address receiver) external onlyRole(SUPPORT_ROLE) {\\r\\n        _internalClaim(receiver);\\r\\n    }\\r\\n\\r\\n    function claimOnBehalfOfBatch(\\r\\n        address[] calldata addresses\\r\\n    ) external onlyRole(SUPPORT_ROLE) {\\r\\n        for (uint256 i; i < addresses.length; ++i) {\\r\\n            _internalClaim(addresses[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice claim function to be used both by the user and by the support role\\r\\n     * @dev used by claim() and claimOnBehalfOf()\\r\\n     * @param claimant the address to claim tokens for.\\r\\n     */\\r\\n    function _internalClaim(address claimant) internal {\\r\\n        if (claimant == address(0)) {\\r\\n            revert NullAddressParameter(\\\"claimant\\\");\\r\\n        }\\r\\n\\r\\n        // early revert if the auction is not in the right stage\\r\\n        AuctionStage stageMem = stage; // memory\\r\\n        if (!stageIsAfterBidding(stageMem)) {\\r\\n            revert NoClaimsAllowedInCurrentStage(stageMem);\\r\\n        }\\r\\n\\r\\n        // read user in memory\\r\\n        User memory user = userData[claimant]; // get user data\\r\\n\\r\\n        if (user.claimed) {\\r\\n            revert AlreadyClaimed(claimant);\\r\\n        }\\r\\n\\r\\n        uint256 userTotalBid = user.totalBid;\\r\\n\\r\\n        if (userTotalBid == 0) {\\r\\n            revert ZeroBids(claimant);\\r\\n        }\\r\\n\\r\\n        // determine the split between tokens and refund\\r\\n        // limit to the maximum tokens a wallet can win in the auction\\r\\n        uint256 priceMem = price;\\r\\n        uint256 mintAmount = Math.min(userTotalBid / priceMem, MAX_PODS_WIN_PER_WALLET);\\r\\n\\r\\n        // the user may have been already refunded by the support role\\r\\n        uint256 refund = 0;\\r\\n        if (user.refundedFunds == 0) {\\r\\n            // if the user has not been refunded, calculate the refund\\r\\n            // as the reamining amount from the bid afrer the tokens won have been paid for\\r\\n            refund += userTotalBid - (mintAmount * priceMem);\\r\\n        }\\r\\n\\r\\n        // if the contribution is not enough for any mints, simply exit\\r\\n        if (mintAmount > 0) {\\r\\n            uint256 supplyLeft = remainingSupply();\\r\\n\\r\\n            // if the supply is less than the mint amount won\\r\\n            if (supplyLeft < mintAmount) {\\r\\n                // refund the remaining amount for any items which cannot be minted\\r\\n                uint256 refundablePods = mintAmount - supplyLeft;\\r\\n\\r\\n                // mint only the remaining items from the supply\\r\\n                mintAmount = supplyLeft;\\r\\n\\r\\n                // refund the difference\\r\\n                // @dev cannot be 0 since price is not 0 and\\r\\n                // the above if statment leads to refundablePods being at least 1\\r\\n                refund += refundablePods * price;\\r\\n            }\\r\\n\\r\\n            // the mintAmount is adjusted for supply above,\\r\\n            // hence it can be 0 again if no supply has been left\\r\\n            if (mintAmount > 0) {\\r\\n                _internalMint(claimant, mintAmount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Claimed(claimant, userTotalBid, mintAmount, refund);\\r\\n        user.claimed = true;\\r\\n\\r\\n        // send the refund\\r\\n        if (refund > 0) {\\r\\n            emit RefundSent(claimant, refund);\\r\\n            user.refundedFunds += SafeCast.toUint120(refund);\\r\\n\\r\\n            (bool success, ) = claimant.call{value: refund}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                revert RefundFailed(claimant, refund);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // reassign changes back to storage\\r\\n        userData[claimant] = user;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice reveal a pod to mint an XDroid\\r\\n     * @param tokenId the token ID of the pod to reveal\\r\\n     */\\r\\n    function revealPod(uint256 tokenId) external nonReentrant returns (uint256) {\\r\\n        if (stage != AuctionStage.REVEALS_OPEN) {\\r\\n            revert RevealsNotOpenYet();\\r\\n        }\\r\\n\\r\\n        if (!_exists(tokenId)) {\\r\\n            revert TokenNotMinted(tokenId);\\r\\n        }\\r\\n\\r\\n        if (ownerOf(tokenId) != msg.sender) {\\r\\n            revert MustBeTokenOwner(msg.sender, tokenId);\\r\\n        }\\r\\n\\r\\n        // droids contract interface set\\r\\n        XDroidsInterface xdroidsContract = XDroidsInterface(xDroidsContractAddress);\\r\\n\\r\\n        // get a droid in exchange\\r\\n        uint256 droidId = xdroidsContract.mintFromXPod(msg.sender);\\r\\n\\r\\n        // emit reveal event\\r\\n        emit XDroidRevealed(msg.sender, droidId, tokenId);\\r\\n\\r\\n        // burning the pod after minting a droid to ensure that pods are not\\r\\n        // burned prematurely if anything fails in the transaction\\r\\n        _burn(tokenId, false);\\r\\n\\r\\n        return droidId; // Return the minted ID\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice read the bid of the user\\r\\n     * @param bidder address of the bidder\\r\\n     */\\r\\n    function bidOf(address bidder) external view returns (uint216) {\\r\\n        User memory user = userData[bidder];\\r\\n        return user.totalBid;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice mint reserved tokens for the team\\r\\n     * @param n number of tokens to mint\\r\\n     * @param to address to mint to\\r\\n     */\\r\\n    function mintToTeam(uint256 n, address to) external onlyRole(SUPPORT_ROLE) {\\r\\n        if (podsMintedToTeam + n > MAX_TEAM_MINT) {\\r\\n            revert ExceedsMaxTeamMint(podsMintedToTeam + n, MAX_TEAM_MINT);\\r\\n        }\\r\\n        podsMintedToTeam += n;\\r\\n        _internalMint(to, n);\\r\\n\\r\\n        emit MintedToTeam(to, n);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets the base uri for {_baseURI}\\r\\n     */\\r\\n    function setBaseURI(string calldata newBaseURI) external onlyRole(SUPPORT_ROLE) {\\r\\n        if (bytes(newBaseURI).length == 0) {\\r\\n            revert BaseURICannotBeEmpty();\\r\\n        }\\r\\n\\r\\n        baseURI = newBaseURI;\\r\\n        emit BaseURISet(newBaseURI);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev override from ERC721A\\r\\n     */\\r\\n    function _baseURI() internal view override returns (string memory) {\\r\\n        return baseURI;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets the contract address of the X Droids contract\\r\\n     */\\r\\n    function setXDroidsContract(\\r\\n        address xDroidsContractAddress_\\r\\n    ) external onlyRole(SUPPORT_ROLE) {\\r\\n        if (xDroidsContractAddress_ == address(0)) {\\r\\n            revert NullAddressParameter(\\\"xDroidsContractAddress\\\");\\r\\n        }\\r\\n\\r\\n        if (stage != AuctionStage.NOT_STARTED) {\\r\\n            revert XDroidChangeAfterAuctionStarted();\\r\\n        }\\r\\n\\r\\n        emit XDroidContractSet(xDroidsContractAddress_);\\r\\n        xDroidsContractAddress = xDroidsContractAddress_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraw function for the owner\\r\\n     * Since only pod sales funds can be withdrawn at any time\\r\\n     * and users' funds need to be protected, this is marked as nonReentrant\\r\\n     */\\r\\n    function withdraw(address payable receiver) external onlyOwner nonReentrant {\\r\\n        // allow the owner to withdraw the balance for any minted pods\\r\\n        AuctionStage stageMem = stage;\\r\\n        if (!stageIsAfterBidding(stageMem)) {\\r\\n            revert CannotWithdrawBeforeClaimsStage(stageMem);\\r\\n        }\\r\\n\\r\\n        // all minted pods so far\\r\\n        uint256 mintCount = _totalMinted();\\r\\n\\r\\n        uint256 withdrawablePodsSales = mintCount - podsMintedToTeam;\\r\\n\\r\\n        if (withdrawablePodsSales < 1) {\\r\\n            revert NotEnoughPodsSold();\\r\\n        }\\r\\n\\r\\n        // substract any funds already withdrawn by the owner\\r\\n        uint256 funds = (withdrawablePodsSales * price) - podSalesWithdrawnByOwner;\\r\\n\\r\\n        if (funds == 0) {\\r\\n            revert NoFundsToWithdraw();\\r\\n        }\\r\\n\\r\\n        // emit the withdraw event\\r\\n        emit FundsWithdrawn(receiver, funds);\\r\\n\\r\\n        // increment the funds withdrawn by the owner\\r\\n        podSalesWithdrawnByOwner += funds;\\r\\n\\r\\n        // send the funds to the receiver\\r\\n        (bool success, ) = receiver.call{value: funds}(\\\"\\\");\\r\\n        if (!success) {\\r\\n            revert WithdrawFailed(receiver, funds);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ////////////////\\r\\n    // ERC2981 royalty standard\\r\\n    ////////////////\\r\\n    /**\\r\\n     * @dev See {ERC2981-_setDefaultRoyalty}.\\r\\n     */\\r\\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyOwner {\\r\\n        _setDefaultRoyalty(receiver, feeNumerator);\\r\\n\\r\\n        emit RoyaltyChanged(receiver, feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {ERC2981-_deleteDefaultRoyalty}.\\r\\n     */\\r\\n    function deleteDefaultRoyalty() external onlyOwner {\\r\\n        _deleteDefaultRoyalty();\\r\\n    }\\r\\n\\r\\n    function contractURI() public view returns (string memory) {\\r\\n        return contractMetadataURI;\\r\\n    }\\r\\n\\r\\n    function setContractURI(string calldata newURI) external onlyOwner {\\r\\n        contractMetadataURI = newURI;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(\\r\\n        bytes4 interfaceId\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override(AccessControl, ERC2981, IERC721A, ERC721A)\\r\\n        returns (bool)\\r\\n    {\\r\\n        return super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    ////////////////\\r\\n    // overrides for using OpenSea's OperatorFilter to filter out platforms which are know to not enforce\\r\\n    // creator earnings\\r\\n    ////////////////\\r\\n    function setApprovalForAll(\\r\\n        address operator,\\r\\n        bool approved\\r\\n    ) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\r\\n        super.setApprovalForAll(operator, approved);\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address operator,\\r\\n        uint256 tokenId\\r\\n    ) public payable override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\\r\\n        super.approve(operator, tokenId);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) {\\r\\n        super.transferFrom(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) {\\r\\n        super.safeTransferFrom(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory data\\r\\n    ) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) {\\r\\n        super.safeTransferFrom(from, to, tokenId, data);\\r\\n    }\\r\\n    //////////\\r\\n    // end of OpenSea DefaultOperatorFilter overrides\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/operator-filter-registry/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a/=lib/ERC721A/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/operator-filter-registry/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"operator-filter-registry/=lib/operator-filter-registry/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimaint\",\"type\":\"address\"}],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"AlreadyRefunded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"currentStage\",\"type\":\"uint8\"}],\"name\":\"AuctionMustBeActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionMustNotBeStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseURICannotBeEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"}],\"name\":\"BidLowerThanMinimum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"currentStage\",\"type\":\"uint8\"}],\"name\":\"CannotWithdrawBeforeClaimsStage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestedPods\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPods\",\"type\":\"uint256\"}],\"name\":\"ExceedsMaxTeamMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FinalPriceMustMatchSetPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minBidInput\",\"type\":\"uint256\"}],\"name\":\"MinBidMustBeGreaterThanZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"MustBeTokenOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"currentStage\",\"type\":\"uint8\"}],\"name\":\"NoClaimsAllowedInCurrentStage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoClaimsDuringBiddingStage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoFundsToWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughPodsSold\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"paramName\",\"type\":\"string\"}],\"name\":\"NullAddressParameter\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"}],\"name\":\"PriceIsLowerThanTheMinBid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceMustBeSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefundToNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RevealsNotOpenYet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"currentStage\",\"type\":\"uint8\"}],\"name\":\"StageMustBeBiddingClosed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"currentStage\",\"type\":\"uint8\"}],\"name\":\"StageMustBeClaimsAndRefunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenNotMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawToNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"XDroidChangeAfterAuctionStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"XDroidContractNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ZeroBids\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidderTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bucketTotal\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"podsWon\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ClaimsAndRefundsStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinBid\",\"type\":\"uint256\"}],\"name\":\"MinimumBidChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"podsCount\",\"type\":\"uint256\"}],\"name\":\"MintedToTeam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RefundSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RevealsOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"RoyaltyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"XDroidContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"droidTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnedPodTokenId\",\"type\":\"uint256\"}],\"name\":\"XDroidRevealed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PODS_WIN_PER_WALLET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TEAM_MINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPORT_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"bidOf\",\"outputs\":[{\"internalType\":\"uint216\",\"name\":\"\",\"type\":\"uint216\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimOnBehalfOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"claimOnBehalfOfBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractMetadataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deleteDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"explicitOwnershipOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"explicitOwnershipsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mintToTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podSalesWithdrawnByOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podsMintedToTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"revealPod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sendRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"sendRefundBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumBid\",\"type\":\"uint256\"}],\"name\":\"setMinimumBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xDroidsContractAddress_\",\"type\":\"address\"}],\"name\":\"setXDroidsContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum AuctionStage\",\"name\":\"stageMem\",\"type\":\"uint8\"}],\"name\":\"stageIsAfterBidding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"finalPrice\",\"type\":\"uint256\"}],\"name\":\"startClaimsAndRefunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startReveals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"uint120\",\"name\":\"totalBid\",\"type\":\"uint120\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint120\",\"name\":\"refundedFunds\",\"type\":\"uint120\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xDroidsContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XPodsAuction", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}