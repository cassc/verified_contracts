{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MultiTokens/MultiTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * DAppCrypto\\r\\n * GitHub Website: https://dappcrypto.github.io/\\r\\n * GitHub: https://github.com/dappcrypto\\r\\n */\\r\\n\\r\\n/**\\r\\n * MultiTokens allows you to create simple tokens v2\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SimpleToken.sol\\\";\\r\\nimport \\\"./Wallet.sol\\\";\\r\\nimport \\\"./TaxCreationBlock.sol\\\";\\r\\n\\r\\ninterface iSimpleToken {\\r\\n    function initToken(string memory t_name, string memory t_symbol, uint8 t_decimals, uint256 t_totalSupply, address addressOwner) external returns (bool);\\r\\n}\\r\\n\\r\\ncontract MultiTokens is Wallet, TaxCreationBlock {\\r\\n\\r\\n    event NewContractTokenDeployed(address indexed newContractTokenAddress, uint256 indexed numberToken);\\r\\n\\r\\n    uint256 public amountTokens = 0;\\r\\n    uint256 public version=2;\\r\\n\\r\\n    // mappingTokensContracts[addressContractToken] = numberToken.\\r\\n    mapping(address => uint256) public mappingTokensContracts;\\r\\n\\r\\n    struct TokenData {\\r\\n        uint256 numberToken;\\r\\n        uint256 timeToken;\\r\\n        address addressContractToken;\\r\\n        string sTextData;\\r\\n    }\\r\\n    // mappingTokensData[numberToken] = TokenData\\r\\n    mapping(uint256 => TokenData) public mappingTokensData;\\r\\n\\r\\n    function getVersion() public view returns (uint256) {\\r\\n        return version;\\r\\n    }\\r\\n\\r\\n    function getNumberToken(address _aToken) public view returns (uint256) {\\r\\n        return mappingTokensContracts[_aToken];\\r\\n    }\\r\\n\\r\\n    function getTokenAllData(uint256 _numberToken, address _addressAccount, address _addressSpender) public view returns (uint256[] memory, address[] memory, bool[] memory, string[] memory) {\\r\\n        uint256[] memory uintArr = new uint256[](40);\\r\\n        address[] memory addressArr = new address[](40);\\r\\n        bool[] memory boolArr = new bool[](40);\\r\\n        string[] memory stringArr = new string[](40);\\r\\n\\r\\n        if(mappingTokensData[_numberToken].numberToken==0){\\r\\n            return (uintArr, addressArr, boolArr, stringArr);\\r\\n        }\\r\\n\\r\\n        (uintArr, addressArr, stringArr) = getTokenInfo(mappingTokensData[_numberToken].addressContractToken, _addressAccount, _addressSpender);\\r\\n\\r\\n        // uintArr\\r\\n        uintArr[10] = mappingTokensData[_numberToken].numberToken;\\r\\n        uintArr[11] = mappingTokensData[_numberToken].timeToken;\\r\\n        uintArr[12] = version;\\r\\n\\r\\n        // addressArr\\r\\n        addressArr[10] = mappingTokensData[_numberToken].addressContractToken;\\r\\n\\r\\n        stringArr[10] = mappingTokensData[_numberToken].sTextData;\\r\\n\\r\\n        return (uintArr, addressArr, boolArr, stringArr);\\r\\n    }\\r\\n\\r\\n    function getTokenInfo(address _addressToken, address _addressAccount, address addressSpender) public view returns (uint256[] memory, address[] memory, string[] memory) {\\r\\n        uint256[] memory uintArr = new uint256[](40);\\r\\n        address[] memory addressArr = new address[](40);\\r\\n        string[] memory stringArr = new string[](40);\\r\\n\\r\\n        // uintArr\\r\\n        uintArr[0] = IERC20(_addressToken).decimals();\\r\\n        uintArr[1] = IERC20(_addressToken).totalSupply();\\r\\n\\r\\n        uintArr[2] = IERC20(_addressToken).balanceOf(_addressAccount);\\r\\n        uintArr[3] = IERC20(_addressToken).allowance(_addressAccount, addressSpender);\\r\\n\\r\\n        // addressArr\\r\\n        addressArr[0] = IERC20(_addressToken).owner();\\r\\n\\r\\n        // stringArr\\r\\n        stringArr[0] = IERC20(_addressToken).name();\\r\\n        stringArr[1] = IERC20(_addressToken).symbol();\\r\\n\\r\\n\\r\\n        return (uintArr, addressArr, stringArr);\\r\\n    }\\r\\n\\r\\n    function getTokenAllDataByContract(address _addressContractToken, address _addressOwner, address _addressSpender) public view returns (uint256[] memory, address[] memory, bool[] memory, string[] memory) {\\r\\n        uint256 _numberToken = mappingTokensContracts[_addressContractToken];\\r\\n        return getTokenAllData(_numberToken, _addressOwner, _addressSpender);\\r\\n    }\\r\\n\\r\\n    function editTextData(uint256 _numberToken, string memory _sTextData) payable public {\\r\\n        sendTaxCreation();\\r\\n        require(IERC20(mappingTokensData[_numberToken].addressContractToken).owner() == msg.sender, \\\"only owner\\\");\\r\\n        mappingTokensData[_numberToken].sTextData = _sTextData;\\r\\n    }\\r\\n\\r\\n    function deployContractToken(string memory t_name, string memory t_symbol, uint8 t_decimals, uint256 t_totalSupply, address addressOwner, string memory _sTextData) payable public {\\r\\n        sendTaxCreation();\\r\\n\\r\\n        amountTokens++;\\r\\n\\r\\n        SimpleToken SimpleToken1 = new SimpleToken();\\r\\n        address addressContractToken = address(SimpleToken1);\\r\\n\\r\\n        iSimpleToken(addressContractToken).initToken(t_name, t_symbol, t_decimals, t_totalSupply, addressOwner);\\r\\n\\r\\n        mappingTokensContracts[addressContractToken] = amountTokens;\\r\\n\\r\\n        mappingTokensData[amountTokens].timeToken = block.timestamp;\\r\\n        mappingTokensData[amountTokens].numberToken = amountTokens;\\r\\n        mappingTokensData[amountTokens].addressContractToken = addressContractToken;\\r\\n        mappingTokensData[amountTokens].sTextData = _sTextData;\\r\\n\\r\\n        emit NewContractTokenDeployed(addressContractToken, amountTokens);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/TaxCreationBlock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * DAppCrypto\\r\\n * GitHub Website: https://dappcrypto.github.io/\\r\\n * GitHub: https://github.com/dappcrypto\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract TaxCreationBlock is Ownable {\\r\\n    uint256 public taxCreation = 10000000000000000; // 0.01\\r\\n    address public taxCreationAddress = address(this); // 0.01\\r\\n\\r\\n    function setTaxCreation(uint256 _amountTax) public onlyOwner {\\r\\n        taxCreation = _amountTax;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    function setTaxCreationAddress(address _addressTax) public onlyOwner {\\r\\n        taxCreationAddress = _addressTax;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    function sendTaxCreation() payable public {\\r\\n        require(msg.value >= taxCreation, \\\"taxCreation error\\\");\\r\\n        if(taxCreationAddress!=address(this)){\\r\\n            payable(taxCreationAddress).transfer(taxCreation);\\r\\n        }\\r\\n        return;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/Wallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * DAppCrypto\\r\\n * GitHub Website: https://dappcrypto.github.io/\\r\\n * GitHub: https://github.com/dappcrypto\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract Wallet is Ownable {\\r\\n    receive() external payable {}\\r\\n    fallback() external payable {}\\r\\n\\r\\n    // Transfer Eth\\r\\n    function transferEth(address _to, uint256 _amount) public onlyOwner {\\r\\n        (bool sent, ) = _to.call{value: _amount}(\\\"\\\");\\r\\n        require(sent, \\\"Failed to send Ether\\\");\\r\\n    }\\r\\n\\r\\n    // Transfer Tokens\\r\\n    function transferTokens(address addressToken, address _to, uint256 _amount) public onlyOwner {\\r\\n        IERC20 contractToken = IERC20(addressToken);\\r\\n        contractToken.transfer(_to, _amount);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/SimpleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * SimpleToken is a simple token contract without cheating\\r\\n * This contract contains the minimum functions required for the token to operate.\\r\\n * Read Contract: _decimals, decimals, _name, name, _symbol, symbol, allowance, balanceOf, getOwner, totalSupply, owner.\\r\\n * Write Contract: transfer, transferFrom, approve, decreaseAllowance, increaseAllowance.\\r\\n * Write Contract, only for owner: renounceOwnership, transferOwnership.\\r\\n * Token created using DAppCrypto https://dappcrypto.github.io/\\r\\n */\\r\\n\\r\\n /**\\r\\n * Important! Always check liquidity lock before investing\\r\\n * Important! Always check if the token address is available in DAppCrypto https://dappcrypto.github.io/\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract SimpleToken is Ownable, IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    bool private initializeToken = false;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    uint8 public _decimals;\\r\\n    string public _symbol;\\r\\n    string public _name;\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    // Token initialization is only available once\\r\\n    function initToken(string memory t_name, string memory t_symbol, uint8 t_decimals, uint256 t_totalSupply, address addressOwner) public onlyOwner returns (bool) {\\r\\n        require(initializeToken == false, \\\"The token is already initialized\\\");\\r\\n        initializeToken = true;\\r\\n\\r\\n        _name = t_name;\\r\\n        _symbol = t_symbol;\\r\\n        _decimals = t_decimals;\\r\\n        _totalSupply = t_totalSupply;\\r\\n        _balances[addressOwner] = _totalSupply;\\r\\n\\r\\n        transferOwnership(addressOwner);\\r\\n\\r\\n        emit Transfer(address(0), addressOwner, _totalSupply);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function owner() external view returns (address) {\\r\\n        return getOwner();\\r\\n    }\\r\\n\\r\\n    function decimals() external view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function name() external view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address addressOwner, address spender) external view returns (uint256) {\\r\\n        return _allowances[addressOwner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"Transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"Decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\r\\n        require(amount <= _balances[sender], \\\"Transfer amount exceeds balance\\\");\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address addressOwner, address spender, uint256 amount) internal {\\r\\n        require(addressOwner != address(0), \\\"Approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"Approve to the zero address\\\");\\r\\n\\r\\n        _allowances[addressOwner][spender] = amount;\\r\\n        emit Approval(addressOwner, spender, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * contract Ownable\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function getOwner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"onlyOwner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * interface IERC20\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function owner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * Library for mathematical operations\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n// @dev Wrappers over Solidity's arithmetic operations with added overflow * checks.\\r\\nlibrary SafeMath {\\r\\n    // Counterpart to Solidity's `+` operator.\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `-` operator.\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `-` operator.\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `*` operator.\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `/` operator.\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `/` operator.\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `%` operator.\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    // Counterpart to Solidity's `%` operator.\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MultiTokens/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * abstract contract Context\\r\\n */\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    //constructor () { }\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newContractTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"numberToken\",\"type\":\"uint256\"}],\"name\":\"NewContractTokenDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"amountTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"t_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"t_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"t_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"t_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addressOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_sTextData\",\"type\":\"string\"}],\"name\":\"deployContractToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberToken\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_sTextData\",\"type\":\"string\"}],\"name\":\"editTextData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aToken\",\"type\":\"address\"}],\"name\":\"getNumberToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addressAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressSpender\",\"type\":\"address\"}],\"name\":\"getTokenAllData\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressContractToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressSpender\",\"type\":\"address\"}],\"name\":\"getTokenAllDataByContract\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressSpender\",\"type\":\"address\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mappingTokensContracts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mappingTokensData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addressContractToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"sTextData\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendTaxCreation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountTax\",\"type\":\"uint256\"}],\"name\":\"setTaxCreation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressTax\",\"type\":\"address\"}],\"name\":\"setTaxCreationAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxCreation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxCreationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MultiTokens", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8d41954c993dd40568171606202c4c7653dfc4f929e43cb7083d750f2ccd1545"}