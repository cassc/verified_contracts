{"SourceCode": "// File: contracts/libs/SSTORE2.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Read and write to persistent storage at a fraction of the cost.\r\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\r\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\r\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\r\nlibrary SSTORE2 {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev We skip the first byte as it's a STOP opcode,\r\n    /// which ensures the contract can't be called.\r\n    uint256 internal constant DATA_OFFSET = 1;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Unable to deploy the storage contract.\r\n    error DeploymentFailed();\r\n\r\n    /// @dev The storage contract address is invalid.\r\n    error InvalidPointer();\r\n\r\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\r\n    error ReadOutOfBounds();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         WRITE LOGIC                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\r\n    function write(bytes memory data) internal returns (address pointer) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let originalDataLength := mload(data)\r\n\r\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\r\n            let dataSize := add(originalDataLength, DATA_OFFSET)\r\n\r\n            /**\r\n             * ------------------------------------------------------------------------------+\r\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\r\n             * ------------------------------------------------------------------------------|\r\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\r\n             * 80          | DUP1            | codeSize codeSize       |                     |\r\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\r\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\r\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\r\n             * 3D          | RETURNDATASZIE  | 0 codeSize              | [0..codeSize): code |\r\n             * F3          | RETURN          |                         | [0..codeSize): code |\r\n             * 00          | STOP            |                         |                     |\r\n             * ------------------------------------------------------------------------------+\r\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\r\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\r\n             */\r\n            mstore(\r\n                data,\r\n                or(\r\n                    0x61000080600a3d393df300,\r\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\r\n                    shl(0x40, dataSize)\r\n                )\r\n            )\r\n\r\n            // Deploy a new contract with the generated creation code.\r\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\r\n\r\n            // If `pointer` is zero, revert.\r\n            if iszero(pointer) {\r\n                // Store the function selector of `DeploymentFailed()`.\r\n                mstore(0x00, 0x30116425)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Restore original length of the variable size `data`.\r\n            mstore(data, originalDataLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\r\n    /// and returns its deterministic address.\r\n    function writeDeterministic(bytes memory data, bytes32 salt)\r\n        internal\r\n        returns (address pointer)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let originalDataLength := mload(data)\r\n            let dataSize := add(originalDataLength, DATA_OFFSET)\r\n\r\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\r\n\r\n            // Deploy a new contract with the generated creation code.\r\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\r\n\r\n            // If `pointer` is zero, revert.\r\n            if iszero(pointer) {\r\n                // Store the function selector of `DeploymentFailed()`.\r\n                mstore(0x00, 0x30116425)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Restore original length of the variable size `data`.\r\n            mstore(data, originalDataLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\r\n    /// Used for mining vanity addresses with create2crunch.\r\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let originalDataLength := mload(data)\r\n            let dataSize := add(originalDataLength, DATA_OFFSET)\r\n\r\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\r\n\r\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\r\n\r\n            // Restore original length of the variable size `data`.\r\n            mstore(data, originalDataLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the address of the storage contract for `data`\r\n    /// deployed with `salt` by `deployer`.\r\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\r\n        internal\r\n        pure\r\n        returns (address predicted)\r\n    {\r\n        bytes32 hash = initCodeHash(data);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and store the bytecode hash.\r\n            mstore8(0x00, 0xff) // Write the prefix.\r\n            mstore(0x35, hash)\r\n            mstore(0x01, shl(96, deployer))\r\n            mstore(0x15, salt)\r\n            predicted := keccak256(0x00, 0x55)\r\n            // Restore the part of the free memory pointer that has been overwritten.\r\n            mstore(0x35, 0)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         READ LOGIC                         */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\r\n    function read(address pointer) internal view returns (bytes memory data) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let pointerCodesize := extcodesize(pointer)\r\n            if iszero(pointerCodesize) {\r\n                // Store the function selector of `InvalidPointer()`.\r\n                mstore(0x00, 0x11052bb4)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Offset all indices by 1 to skip the STOP opcode.\r\n            let size := sub(pointerCodesize, DATA_OFFSET)\r\n\r\n            // Get the pointer to the free memory and allocate\r\n            // enough 32-byte words for the data and the length of the data,\r\n            // then copy the code to the allocated memory.\r\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\r\n            data := mload(0x40)\r\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\r\n            mstore(data, size)\r\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\r\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\r\n    /// from the byte at `start`, to the end of the data stored.\r\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let pointerCodesize := extcodesize(pointer)\r\n            if iszero(pointerCodesize) {\r\n                // Store the function selector of `InvalidPointer()`.\r\n                mstore(0x00, 0x11052bb4)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // If `!(pointer.code.size > start)`, reverts.\r\n            // This also handles the case where `start + DATA_OFFSET` overflows.\r\n            if iszero(gt(pointerCodesize, start)) {\r\n                // Store the function selector of `ReadOutOfBounds()`.\r\n                mstore(0x00, 0x84eb0dd1)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\r\n\r\n            // Get the pointer to the free memory and allocate\r\n            // enough 32-byte words for the data and the length of the data,\r\n            // then copy the code to the allocated memory.\r\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\r\n            data := mload(0x40)\r\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\r\n            mstore(data, size)\r\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\r\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\r\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\r\n    function read(address pointer, uint256 start, uint256 end)\r\n        internal\r\n        view\r\n        returns (bytes memory data)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let pointerCodesize := extcodesize(pointer)\r\n            if iszero(pointerCodesize) {\r\n                // Store the function selector of `InvalidPointer()`.\r\n                mstore(0x00, 0x11052bb4)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\r\n            // This also handles the cases where\r\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\r\n            if iszero(\r\n                and(\r\n                    gt(pointerCodesize, end), // Within bounds.\r\n                    iszero(gt(start, end)) // Valid range.\r\n                )\r\n            ) {\r\n                // Store the function selector of `ReadOutOfBounds()`.\r\n                mstore(0x00, 0x84eb0dd1)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let size := sub(end, start)\r\n\r\n            // Get the pointer to the free memory and allocate\r\n            // enough 32-byte words for the data and the length of the data,\r\n            // then copy the code to the allocated memory.\r\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\r\n            data := mload(0x40)\r\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\r\n            mstore(data, size)\r\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\r\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\r\n        }\r\n    }\r\n}\r\n// File: contracts/DataStore.sol\r\n\r\n\r\npragma solidity ^0.8.21;\r\n\r\n\r\ncontract DataStore {\r\n    event DataLocation(address pointer);\r\n\r\n    function save(bytes calldata data) external {\r\n        address location = SSTORE2.write(data);\r\n        emit DataLocation(location);\r\n    }\r\n    function read(address location) external view returns (bytes memory){\r\n        return SSTORE2.read(location);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"DataLocation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"location\",\"type\":\"address\"}],\"name\":\"read\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"save\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DataStore", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4c3bd812d8b9eafaf90b65eae104d8a575a61bc4abb08a90f59a973bf356dfc2"}