{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DividendsPairStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IUniswapV2Factory} from \\\"v2-core/interfaces/IUniswapV2Factory.sol\\\";\\nimport {IUniswapV2Router02} from \\\"v2-periphery/interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Pair} from \\\"v2-core/interfaces/IUniswapV2Pair.sol\\\";\\nimport {IERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IDividendsPairStaking} from \\\"./interfaces/IDividendsPairStaking.sol\\\";\\n\\n/**\\n * Twitter: https://twitter.com/mucushq\\n * Website: https://mucus.io\\n */\\ncontract DividendsPairStaking is IDividendsPairStaking {\\n    uint256 public totalDogFactionAmount;\\n    uint256 public totalFrogFactionAmount;\\n    uint256 public dividendsPerFrog;\\n    uint256 public dividendsPerDog;\\n    mapping(address => Staker) public stakers;\\n    uint256 public totalStakedAmount;\\n\\n    mapping(uint256 => SoupCycle) public soupCycles;\\n    uint256 public currentSoupIndex;\\n    uint256 public soupCycleDuration = 3 days;\\n\\n    IUniswapV2Router02 public router;\\n    IERC20 public pair;\\n    address private _mucus;\\n    address private _owner;\\n\\n    constructor(address mucus) {\\n        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        address _pair = IUniswapV2Factory(router.factory()).getPair(mucus, router.WETH());\\n        pair = IERC20(_pair);\\n        _mucus = mucus;\\n        _owner = msg.sender;\\n\\n        soupCycles[currentSoupIndex] = SoupCycle({timestamp: block.timestamp, soupedUp: Faction.FROG, totalFrogWins: 1});\\n    }\\n\\n    modifier onlyTokenOrOwner() {\\n        require(msg.sender == _mucus || msg.sender == _owner);\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner);\\n        _;\\n    }\\n\\n    function addStake(Faction faction, uint256 tokenAmountOutMin) external payable {\\n        require(msg.value > 0, \\\"ETH must be sent to stake\\\");\\n        Staker memory staker = stakers[msg.sender];\\n\\n        // This is equivalent to taring it to 0\\n        // This makes it so that the math to calculate the dps stays consistent\\n        if (staker.totalAmount > 0) {\\n            _distributeDividend(staker);\\n        }\\n\\n        uint256 amount = _addLiquidity(tokenAmountOutMin);\\n\\n        // add staker if never staked before\\n        if (staker.totalAmount == 0) {\\n            staker.previousDividendsPerFrog = dividendsPerFrog;\\n            staker.previousDividendsPerDog = dividendsPerDog;\\n        }\\n\\n        staker.lockingEndDate = block.timestamp + 2 weeks;\\n        staker.totalAmount += amount;\\n\\n        if (faction == Faction.DOG) {\\n            staker.dogFactionAmount += amount;\\n            totalDogFactionAmount += amount;\\n        } else {\\n            staker.frogFactionAmount += amount;\\n            totalFrogFactionAmount += amount;\\n        }\\n        totalStakedAmount += amount;\\n\\n        stakers[msg.sender] = staker;\\n\\n        emit StakeAdded(msg.sender, amount, faction);\\n    }\\n\\n    function _addLiquidity(uint256 tokenAmountOutMin) private returns (uint256) {\\n        uint256 ethAmount = msg.value >> 1;\\n        uint256 tokenAmount = _swapEthForTokens(ethAmount, tokenAmountOutMin);\\n\\n        // approve token transfer to cover all possible scenarios\\n        IERC20(_mucus).approve(address(router), tokenAmount);\\n\\n        // add the liquidity\\n        (,, uint256 liquidity) = router.addLiquidityETH{value: ethAmount}(\\n            _mucus,\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        return liquidity;\\n    }\\n\\n    function _swapEthForTokens(uint256 ethAmount, uint256 tokenAmountOutMin) private returns (uint256) {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = router.WETH();\\n        path[1] = address(_mucus);\\n\\n        uint256[] memory amounts =\\n            router.swapExactETHForTokens{value: ethAmount}(tokenAmountOutMin, path, address(this), block.timestamp);\\n\\n        return amounts[1];\\n    }\\n\\n    function removeStake(uint256 amount, Faction faction) external {\\n        Staker memory staker = stakers[msg.sender];\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(staker.totalAmount >= amount, \\\"Cannot unstake more than you have staked\\\");\\n        require(\\n            faction != Faction.DOG || staker.dogFactionAmount >= amount,\\n            \\\"Cannot unstake more than you have staked for the dog faction\\\"\\n        );\\n        require(\\n            faction != Faction.FROG || staker.frogFactionAmount >= amount,\\n            \\\"Cannot unstake more than you have staked for the frog faction\\\"\\n        );\\n        require(block.timestamp > staker.lockingEndDate, \\\"Cannot unstake until locking period is over\\\");\\n\\n        // This is equivalent to taring it to 0\\n        // This makes it so that the math to calculate the dps stays consistent\\n        _distributeDividend(staker);\\n\\n        if (faction == Faction.DOG) {\\n            staker.dogFactionAmount -= amount;\\n            totalDogFactionAmount -= amount;\\n        } else {\\n            staker.frogFactionAmount -= amount;\\n            totalFrogFactionAmount -= amount;\\n        }\\n\\n        if (staker.totalAmount == amount) {\\n            delete stakers[msg.sender];\\n        } else {\\n            staker.totalAmount -= amount;\\n            stakers[msg.sender] = staker;\\n        }\\n\\n        totalStakedAmount -= amount;\\n\\n        pair.approve(address(router), amount);\\n        (uint256 tokenAmount, uint256 ethAmount) = router.removeLiquidityETH(\\n            _mucus,\\n            amount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        IERC20(_mucus).transfer(msg.sender, tokenAmount);\\n        payable(msg.sender).transfer(ethAmount);\\n\\n        emit StakeRemoved(msg.sender, amount, faction);\\n    }\\n\\n    function vote(uint256 amount, Faction faction) external {\\n        Staker memory staker = stakers[msg.sender];\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(staker.totalAmount > 0, \\\"Cannot vote if you haven't staked\\\");\\n\\n        // reset to make it consistent\\n        _distributeDividend(staker);\\n\\n        if (faction == Faction.FROG) {\\n            require(staker.dogFactionAmount >= amount, \\\"Cannot swap more Dog votes than you have staked\\\");\\n\\n            staker.dogFactionAmount -= amount;\\n            staker.frogFactionAmount += amount;\\n            totalDogFactionAmount -= amount;\\n            totalFrogFactionAmount += amount;\\n        } else {\\n            require(staker.frogFactionAmount >= amount, \\\"Cannot swap more Frog votes than you have staked\\\");\\n\\n            staker.frogFactionAmount -= amount;\\n            staker.dogFactionAmount += amount;\\n            totalFrogFactionAmount -= amount;\\n            totalDogFactionAmount += amount;\\n        }\\n\\n        stakers[msg.sender] = staker;\\n\\n        emit VoteSwapped(msg.sender, amount, faction);\\n    }\\n\\n    function claim() external {\\n        Staker memory staker = stakers[msg.sender];\\n        require(staker.totalAmount > 0, \\\"Cannot claim if you haven't staked\\\");\\n        _distributeDividend(staker);\\n    }\\n\\n    function _distributeDividend(Staker memory staker) internal {\\n        uint256 frogRewards = (dividendsPerFrog - staker.previousDividendsPerFrog) * staker.frogFactionAmount;\\n        uint256 dogRewards = (dividendsPerDog - staker.previousDividendsPerDog) * staker.dogFactionAmount;\\n\\n        staker.previousDividendsPerFrog = dividendsPerFrog;\\n        staker.previousDividendsPerDog = dividendsPerDog;\\n\\n        stakers[msg.sender] = staker;\\n\\n        if (frogRewards + dogRewards > 0) {\\n            IERC20(_mucus).transfer(msg.sender, frogRewards + dogRewards);\\n        }\\n\\n        emit DividendsEarned(msg.sender, frogRewards + dogRewards);\\n    }\\n\\n    function deposit(uint256 amount) external onlyTokenOrOwner {\\n        if (amount > 0 && totalFrogFactionAmount > 0 && totalDogFactionAmount > 0) {\\n            uint256 frogAmount = amount * totalDogFactionAmount / totalStakedAmount;\\n            uint256 dogAmount = amount - frogAmount;\\n            dividendsPerFrog += frogAmount / totalFrogFactionAmount;\\n            dividendsPerDog += dogAmount / totalDogFactionAmount;\\n        }\\n\\n        emit DividendsPerShareUpdated(dividendsPerFrog, dividendsPerDog);\\n    }\\n\\n    function cycleSoup() external onlyTokenOrOwner {\\n        require(\\n            block.timestamp >= soupCycles[currentSoupIndex].timestamp + soupCycleDuration,\\n            \\\"Cannot update soup cycle until the current cycle is over\\\"\\n        );\\n        uint256 totalFrogWins = soupCycles[currentSoupIndex].totalFrogWins;\\n        Faction soupedUp = totalFrogFactionAmount > totalDogFactionAmount ? Faction.FROG : Faction.DOG;\\n        if (soupedUp == Faction.FROG) totalFrogWins++;\\n\\n        currentSoupIndex++;\\n        soupCycles[currentSoupIndex] =\\n            SoupCycle({timestamp: block.timestamp, soupedUp: soupedUp, totalFrogWins: totalFrogWins});\\n\\n        emit SoupCycled(currentSoupIndex, soupedUp);\\n    }\\n\\n    function getSoup(uint256 previousSoupIndex)\\n        external\\n        view\\n        returns (uint256, uint256, SoupCycle memory, SoupCycle memory)\\n    {\\n        return (currentSoupIndex, soupCycleDuration, soupCycles[previousSoupIndex], soupCycles[currentSoupIndex]);\\n    }\\n\\n    function nextSoupCycle() external view returns (uint256) {\\n        return soupCycles[currentSoupIndex].timestamp + soupCycleDuration;\\n    }\\n\\n    function getSoupedUp() external view returns (Faction) {\\n        return soupCycles[currentSoupIndex].soupedUp;\\n    }\\n\\n    function setSoupCycleDuration(uint256 _soupCycleDuration) external onlyOwner {\\n        soupCycleDuration = _soupCycleDuration;\\n\\n        emit SoupCycleDurationUpdated(_soupCycleDuration);\\n    }\\n\\n    function withdrawMucus() external onlyOwner {\\n        IERC20 mucus = IERC20(_mucus);\\n        mucus.transfer(msg.sender, mucus.balanceOf(address(this)));\\n    }\\n\\n    function withdrawEth() external onlyOwner {\\n        (bool success,) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Failed to send ETH\\\");\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDividendsPairStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IDividendsPairStaking {\\n    enum Faction {\\n        DOG,\\n        FROG\\n    }\\n\\n    struct Staker {\\n        uint256 totalAmount;\\n        uint256 frogFactionAmount;\\n        uint256 dogFactionAmount;\\n        uint256 previousDividendsPerFrog;\\n        uint256 previousDividendsPerDog;\\n        uint256 lockingEndDate;\\n    }\\n\\n    struct SoupCycle {\\n        uint256 timestamp;\\n        Faction soupedUp;\\n        uint256 totalFrogWins;\\n    }\\n\\n    event StakeAdded(address indexed staker, uint256 amount, Faction faction);\\n    event StakeRemoved(address indexed staker, uint256 amount, Faction faction);\\n    event VoteSwapped(address indexed staker, uint256 amount, Faction faction);\\n    event DividendsPerShareUpdated(uint256 dividendsPerFrog, uint256 dividendsPerDog);\\n    event DividendsEarned(address indexed staker, uint256 amount);\\n    event SoupCycled(uint256 indexed soupIndex, Faction soupedUp);\\n    event SoupCycleDurationUpdated(uint256 soupCycleDuration);\\n\\n    function stakers(address staker) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\\n    function currentSoupIndex() external view returns (uint256);\\n    function addStake(Faction faction, uint256 tokenAmountOutMin) external payable;\\n    function removeStake(uint256 amount, Faction faction) external;\\n    function vote(uint256 amount, Faction faction) external;\\n    function claim() external;\\n    function deposit(uint256 amount) external;\\n    function cycleSoup() external;\\n    function getSoup(uint256 previousSoupIndex)\\n        external\\n        view\\n        returns (uint256, uint256, SoupCycle memory, SoupCycle memory);\\n    function nextSoupCycle() external view returns (uint256);\\n    function getSoupedUp() external view returns (Faction);\\n    function setSoupCycleDuration(uint256 _soupCycleDuration) external;\\n    function withdrawMucus() external;\\n    function withdrawEth() external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"@uniswap/v2-periphery/=lib/v2-periphery/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mucus\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendsEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dividendsPerFrog\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dividendsPerDog\",\"type\":\"uint256\"}],\"name\":\"DividendsPerShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soupCycleDuration\",\"type\":\"uint256\"}],\"name\":\"SoupCycleDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"soupIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"soupedUp\",\"type\":\"uint8\"}],\"name\":\"SoupCycled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"faction\",\"type\":\"uint8\"}],\"name\":\"StakeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"faction\",\"type\":\"uint8\"}],\"name\":\"StakeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"faction\",\"type\":\"uint8\"}],\"name\":\"VoteSwapped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"faction\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOutMin\",\"type\":\"uint256\"}],\"name\":\"addStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSoupIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleSoup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerDog\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerFrog\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previousSoupIndex\",\"type\":\"uint256\"}],\"name\":\"getSoup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"soupedUp\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalFrogWins\",\"type\":\"uint256\"}],\"internalType\":\"struct IDividendsPairStaking.SoupCycle\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"soupedUp\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalFrogWins\",\"type\":\"uint256\"}],\"internalType\":\"struct IDividendsPairStaking.SoupCycle\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSoupedUp\",\"outputs\":[{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSoupCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"faction\",\"type\":\"uint8\"}],\"name\":\"removeStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_soupCycleDuration\",\"type\":\"uint256\"}],\"name\":\"setSoupCycleDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soupCycleDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"soupCycles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"soupedUp\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalFrogWins\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frogFactionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dogFactionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousDividendsPerFrog\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousDividendsPerDog\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockingEndDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDogFactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFrogFactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum IDividendsPairStaking.Faction\",\"name\":\"faction\",\"type\":\"uint8\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMucus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DividendsPairStaking", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c4a41fc62bfc4ed3033cff4befd21bbdcd811f64", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}