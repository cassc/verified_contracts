{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-12-30\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\n/// Standard IERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// Second part of the router interface of uniswap and forks\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n/// Interface for the pairs of uniswap and forks\r\ninterface IPair {\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns(address);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/// Transfer Helper to ensure the correct transfer of the tokens or ETH\r\nlibrary SafeTransfer {\r\n    using Address for address;\r\n    /** Safe Transfer asset from one wallet with approval of the wallet\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param from: the wallet to take from\r\n    * @param amount: the amount to take from the wallet\r\n    **/\r\n    function _pullUnderlying(IERC20 erc20, address from, uint amount) internal\r\n    {\r\n        safeTransferFrom(erc20,from,address(this),amount);\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /** Safe Transfer asset to one wallet from within the contract\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param to: the wallet to send to\r\n    * @param amount: the amount to send from the contract\r\n    **/\r\n    function _pushUnderlying(IERC20 erc20, address to, uint amount) internal\r\n    {\r\n        safeTransfer(erc20,to,amount);\r\n    }\r\n\r\n    /** Safe Transfer ETH to one wallet from within the contract\r\n    * @param to: the wallet to send to\r\n    * @param value: the amount to send from the contract\r\n    **/\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    uint256 private _status2;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"reentry\");\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract LPLoanRepayment is ReentrancyGuard{\r\n    mapping(address => bool) public agreed;\r\n    address public constant LP = 0x671c602224eC796D61ea76AA5E8e2dde249ED837;\r\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant FEG = 0xF3c7CECF8cBC3066F9a87b310cEBE198d00479aC;\r\n    address private _FEGlocation;\r\n    address public constant withdrawalAddress = 0x992274f2Ce632f5fABBdf02ce0039f127AD10Ae0;\r\n    address public constant admin = 0x8d5E1CD48b17d807e81DBfBe6c591CB7faB63971;\r\n    uint256 public rate = 10; //10 = 10% rate of release.\r\n    uint256 public interval = 14 days; // every 14 days rate is released.\r\n    uint256 public WETHout;\r\n    uint256 public FEGout;\r\n    uint256 public startTime;\r\n    uint256 public lastRoundTime;\r\n    uint256 public round; // times interval has passed\r\n    uint256 public addedLP;\r\n    uint256 public claimedLP;\r\n    uint256 public lastClaimedLP;\r\n    uint256 public goal = 40e18; // 40 ETH\r\n    uint256 public minETH;\r\n    uint256 public withdrawAmount;\r\n    bool public goalReached;\r\n    bool public enabled;\r\n    event AddLP(uint256 amount, uint256 time);\r\n    event Withdraw(uint256 ETHOut, uint256 ClaimedLP);\r\n    event SetAgree(address user, bool _bool);\r\n\r\n    modifier update() {    \r\n        if(round == 0) {\r\n            round = 1;\r\n            startTime = block.timestamp;\r\n            lastRoundTime = block.timestamp;\r\n        }  \r\n        if(block.timestamp > startTime + (round * interval)) {\r\n            round += 1;\r\n            lastRoundTime = block.timestamp;\r\n        }\r\n        _;\r\n    }\r\n\r\n    function FEGlocation() public view returns(address) {\r\n        address fl = _FEGlocation == address(0) ? admin : _FEGlocation;\r\n        return fl;\r\n    }\r\n\r\n    function setFEGlocation(address addy) external {\r\n        require(msg.sender == admin, \"admin\");\r\n        _FEGlocation = addy; // allow for FEG to be sent to a bonding contract if added\r\n    }\r\n\r\n    function addLP(uint256 amount) external nonReentrant update{\r\n        require(msg.sender == admin, \"admin\");\r\n        require(!goalReached, \"over\");\r\n        SafeTransfer.safeTransferFrom(IERC20(LP), admin, address(this), amount);\r\n        addedLP += amount;\r\n        emit AddLP(amount, block.timestamp);\r\n    }\r\n\r\n    // configured to read new rounds not yet registered with update\r\n    function balanceOpen() public view returns(uint256 amount) {  \r\n        uint256 r = round;\r\n        uint256 i = interval;\r\n        uint256 st = startTime;\r\n        if(block.timestamp > st + (round * i)) {\r\n        for(uint256 e = 0; e < 10 - round; e++) {\r\n            if(block.timestamp > st + (r * i)) {\r\n            r += 1;\r\n            }\r\n            if(block.timestamp <= st + (r * i)) {\r\n            break;\r\n            }\r\n        }\r\n        }\r\n        uint256 d = ((addedLP * rate / 100) * r) >= addedLP ? addedLP : ((addedLP * rate / 100) * r);\r\n        amount = goalReached ? 0 : d - claimedLP;\r\n    }\r\n\r\n    function LPValue() external view returns(uint256 native) {\r\n        uint256 a = IERC20(WETH).balanceOf(LP);\r\n        uint256 b = IERC20(LP).totalSupply();\r\n        uint256 c = IERC20(LP).balanceOf(address(this));\r\n        native = a * c / b;\r\n    }\r\n\r\n    function setAgreed(bool _bool) external nonReentrant update {\r\n        require(msg.sender == admin || msg.sender == withdrawalAddress, \"not permitted\");\r\n        if(msg.sender == admin) {\r\n            agreed[admin] = _bool;\r\n            emit SetAgree(msg.sender, _bool);\r\n        }\r\n        if(msg.sender == withdrawalAddress) {\r\n            agreed[withdrawalAddress] = _bool;\r\n            emit SetAgree(msg.sender, _bool);\r\n        }\r\n    }\r\n\r\n    // enable withdrawal before withdraw so that we can set minETH out automatically at 95% of claimable amount\r\n    function enableWithdrawal(uint256 amount) external {\r\n        require(msg.sender == withdrawalAddress, \"not permitted\");\r\n        require(amount <= 100 && amount > 0, \"0/100\");\r\n        uint256 bal = balanceOpen();\r\n        require(bal > 0, \"no bal\");\r\n        (uint112 reserve0, uint112 reserve1,) = IPair(LP).getReserves();\r\n        uint256 reserve = WETH == IPair(LP).token0() ? reserve0 : reserve1;\r\n        withdrawAmount = bal * amount / 100 >= addedLP * rate / 100 ? addedLP * rate / 100 : bal * amount / 100;\r\n        minETH = (reserve * withdrawAmount / IERC20(LP).totalSupply()) * 95 / 100; // require 95% of amount out minimum\r\n        enabled = true;\r\n    }\r\n\r\n    function withdraw() external nonReentrant update {\r\n        require(msg.sender == withdrawalAddress, \"not permitted\");\r\n        require(enabled && minETH > 0 && withdrawAmount > 0, \"enable withdraw first\");\r\n        uint256 bal = balanceOpen();\r\n        require(bal > 0, \"no bal\");\r\n        require(bal >= withdrawAmount, \"over\");\r\n        require(!goalReached, \"reached goal\");\r\n        require(block.timestamp > lastClaimedLP + 1 days, \"1 Day cool down\"); // if withdrawal address did not take full 10% allow them to take more after 1 days past\r\n        SafeTransfer.safeTransfer(IERC20(LP), LP, withdrawAmount);\r\n        IPair(LP).burn(address(this));\r\n        claimedLP += withdrawAmount;\r\n        uint256 fb = IERC20(FEG).balanceOf(address(this));\r\n        SafeTransfer.safeTransfer(IERC20(FEG), FEGlocation(), fb); // send FEG to FEGlocation if enabled\r\n        FEGout += fb;\r\n        uint256 eb = IERC20(WETH).balanceOf(address(this));\r\n        require(eb >= minETH, \"min ETH not met\");\r\n        bool reach = WETHout + eb > goal ? true : false;\r\n        uint256 ethOut = reach ? goal - WETHout : eb;        \r\n        WETHout = reach ? goal : WETHout + ethOut;\r\n        SafeTransfer.safeTransfer(IERC20(WETH), withdrawalAddress, ethOut);\r\n        lastClaimedLP = block.timestamp;\r\n        if(reach) {\r\n            goalReached = true;\r\n            SafeTransfer.safeTransfer(IERC20(WETH), admin, IERC20(WETH).balanceOf(address(this)));\r\n            SafeTransfer.safeTransfer(IERC20(LP), admin, IERC20(LP).balanceOf(address(this)));\r\n        }\r\n        emit Withdraw(ethOut, withdrawAmount);\r\n        withdrawAmount = 0;\r\n        minETH = 0;\r\n        enabled = false;\r\n    }\r\n\r\n    function saveTokens(address addy) external nonReentrant{\r\n        require(msg.sender == admin || msg.sender == withdrawalAddress, \"not permitted\");\r\n        if(!agreed[admin] && !agreed[withdrawalAddress]) {\r\n        require(block.timestamp > startTime + 90 days, \"live\"); // 90 days after starttime\r\n        }\r\n        uint256 a = IERC20(WETH).balanceOf(address(this));\r\n        if(a > 0) {\r\n        SafeTransfer.safeTransfer(IERC20(WETH), admin, a);\r\n        }\r\n        uint256 b = IERC20(LP).balanceOf(address(this));\r\n        if(b > 0) {\r\n        SafeTransfer.safeTransfer(IERC20(LP), admin, b);\r\n        }\r\n        uint256 c = IERC20(FEG).balanceOf(address(this));\r\n        if(c > 0) {\r\n        SafeTransfer.safeTransfer(IERC20(FEG), admin, c);\r\n        }\r\n        uint256 d = IERC20(addy).balanceOf(address(this));\r\n        if(d > 0) {\r\n        SafeTransfer.safeTransfer(IERC20(addy), admin, d);\r\n        }\r\n        if(agreed[admin] && agreed[withdrawalAddress]) {\r\n        agreed[admin] = false;\r\n        agreed[withdrawalAddress] = false;\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AddLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"SetAgree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ETHOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ClaimedLP\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGlocation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"native\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETHout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"agreed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOpen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enableWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastClaimedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoundTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"saveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setAgreed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setFEGlocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LPLoanRepayment", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9f36c51f213ef08d62564136edb309648d9b3c5b99485418dd7555e7d7cc0b9e"}