{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/governance/Governance.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {IGovernance} from \\\"./IGovernance.sol\\\";\\n\\n/// @author Matter Labs\\n/// @custom:security-contact security@matterlabs.dev\\n/// @dev Contract design is inspired by OpenZeppelin TimelockController and in-house Diamond Proxy upgrade mechanism.\\n/// @notice This contract manages operations (calls with preconditions) for governance tasks.\\n/// The contract allows for operations to be scheduled, executed, and canceled with\\n/// appropriate permissions and delays. It is used for managing and coordinating upgrades\\n/// and changes in all zkSync Era governed contracts.\\n///\\n/// Operations can be proposed as either fully transparent upgrades with on-chain data,\\n/// or \\\"shadow\\\" upgrades where upgrade data is not published on-chain before execution. Proposed operations\\n/// are subject to a delay before they can be executed, but they can be executed instantly\\n/// with the security council\u2019s permission.\\ncontract Governance is IGovernance, Ownable2Step {\\n    /// @notice A constant representing the timestamp for completed operations.\\n    uint256 internal constant EXECUTED_PROPOSAL_TIMESTAMP = uint256(1);\\n\\n    /// @notice The address of the security council.\\n    /// @dev It is supposed to be multisig contract.\\n    address public securityCouncil;\\n\\n    /// @notice A mapping to store timestamps when each operation will be ready for execution.\\n    /// @dev - 0 means the operation is not created.\\n    /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\\n    /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\\n    mapping(bytes32 operationId => uint256 executionTimestamp) public timestamps;\\n\\n    /// @notice The minimum delay in seconds for operations to be ready for execution.\\n    uint256 public minDelay;\\n\\n    /// @notice Initializes the contract with the admin address, security council address, and minimum delay.\\n    /// @param _admin The address to be assigned as the admin of the contract.\\n    /// @param _securityCouncil The address to be assigned as the security council of the contract.\\n    /// @param _minDelay The initial minimum delay (in seconds) to be set for operations.\\n    constructor(address _admin, address _securityCouncil, uint256 _minDelay) {\\n        require(_admin != address(0), \\\"Admin should be non zero address\\\");\\n\\n        _transferOwnership(_admin);\\n\\n        securityCouncil = _securityCouncil;\\n        emit ChangeSecurityCouncil(address(0), _securityCouncil);\\n\\n        minDelay = _minDelay;\\n        emit ChangeMinDelay(0, _minDelay);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MODIFIERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Checks that the message sender is contract itself.\\n    modifier onlySelf() {\\n        require(msg.sender == address(this), \\\"Only governance contract itself is allowed to call this function\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks that the message sender is an active security council.\\n    modifier onlySecurityCouncil() {\\n        require(msg.sender == securityCouncil, \\\"Only security council is allowed to call this function\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks that the message sender is an active owner or an active security council.\\n    modifier onlyOwnerOrSecurityCouncil() {\\n        require(\\n            msg.sender == owner() || msg.sender == securityCouncil,\\n            \\\"Only the owner and security council are allowed to call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OPERATION GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Returns whether an id corresponds to a registered operation. This\\n    /// includes both Waiting, Ready, and Done operations.\\n    function isOperation(bytes32 _id) public view returns (bool) {\\n        return getOperationState(_id) != OperationState.Unset;\\n    }\\n\\n    /// @dev Returns whether an operation is pending or not. Note that a \\\"pending\\\" operation may also be \\\"ready\\\".\\n    function isOperationPending(bytes32 _id) public view returns (bool) {\\n        OperationState state = getOperationState(_id);\\n        return state == OperationState.Waiting || state == OperationState.Ready;\\n    }\\n\\n    /// @dev Returns whether an operation is ready for execution. Note that a \\\"ready\\\" operation is also \\\"pending\\\".\\n    function isOperationReady(bytes32 _id) public view returns (bool) {\\n        return getOperationState(_id) == OperationState.Ready;\\n    }\\n\\n    /// @dev Returns whether an operation is done or not.\\n    function isOperationDone(bytes32 _id) public view returns (bool) {\\n        return getOperationState(_id) == OperationState.Done;\\n    }\\n\\n    /// @dev Returns operation state.\\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\\n        uint256 timestamp = timestamps[_id];\\n        if (timestamp == 0) {\\n            return OperationState.Unset;\\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\\n            return OperationState.Done;\\n        } else if (timestamp > block.timestamp) {\\n            return OperationState.Waiting;\\n        } else {\\n            return OperationState.Ready;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            SCHEDULING CALLS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain.\\n    /// @notice The owner will be able to execute the proposal either:\\n    /// - With a `delay` timelock on its own.\\n    /// - With security council instantly.\\n    /// @dev Only the current owner can propose an upgrade.\\n    /// @param _operation The operation parameters will be executed with the upgrade.\\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\\n        bytes32 id = hashOperation(_operation);\\n        _schedule(id, _delay);\\n        emit TransparentOperationScheduled(id, _delay, _operation);\\n    }\\n\\n    /// @notice Propose \\\"shadow\\\" upgrade, upgrade data is not publishing on-chain.\\n    /// @notice The owner will be able to execute the proposal either:\\n    /// - With a `delay` timelock on its own.\\n    /// - With security council instantly.\\n    /// @dev Only the current owner can propose an upgrade.\\n    /// @param _id The operation hash (see `hashOperation` function)\\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade may be executed by the owner.\\n    function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\\n        _schedule(_id, _delay);\\n        emit ShadowOperationScheduled(_id, _delay);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            CANCELING CALLS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Cancel the scheduled operation.\\n    /// @dev Only owner can call this function.\\n    /// @param _id Proposal id value (see `hashOperation`)\\n    function cancel(bytes32 _id) external onlyOwner {\\n        require(isOperationPending(_id), \\\"Operation must be pending\\\");\\n        delete timestamps[_id];\\n        emit OperationCancelled(_id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EXECUTING CALLS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Executes the scheduled operation after the delay passed.\\n    /// @dev Both the owner and security council may execute delayed operations.\\n    /// @param _operation The operation parameters will be executed with the upgrade.\\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\\n        bytes32 id = hashOperation(_operation);\\n        // Check if the predecessor operation is completed.\\n        _checkPredecessorDone(_operation.predecessor);\\n        // Ensure that the operation is ready to proceed.\\n        require(isOperationReady(id), \\\"Operation must be ready before execution\\\");\\n        // Execute operation.\\n        _execute(_operation.calls);\\n        // Reconfirming that the operation is still ready after execution.\\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\\n        require(isOperationReady(id), \\\"Operation must be ready after execution\\\");\\n        // Set operation to be done\\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\\n        emit OperationExecuted(id);\\n    }\\n\\n    /// @notice Executes the scheduled operation with the security council instantly.\\n    /// @dev Only the security council may execute an operation instantly.\\n    /// @param _operation The operation parameters will be executed with the upgrade.\\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\\n        bytes32 id = hashOperation(_operation);\\n        // Check if the predecessor operation is completed.\\n        _checkPredecessorDone(_operation.predecessor);\\n        // Ensure that the operation is in a pending state before proceeding.\\n        require(isOperationPending(id), \\\"Operation must be pending before execution\\\");\\n        // Execute operation.\\n        _execute(_operation.calls);\\n        // Reconfirming that the operation is still pending before execution.\\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\\n        require(isOperationPending(id), \\\"Operation must be pending after execution\\\");\\n        // Set operation to be done\\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\\n        emit OperationExecuted(id);\\n    }\\n\\n    /// @dev Returns the identifier of an operation.\\n    /// @param _operation The operation object to compute the identifier for.\\n    function hashOperation(Operation calldata _operation) public pure returns (bytes32) {\\n        return keccak256(abi.encode(_operation));\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            HELPERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Schedule an operation that is to become valid after a given delay.\\n    /// @param _id The operation hash (see `hashOperation` function)\\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\\n    function _schedule(bytes32 _id, uint256 _delay) internal {\\n        require(!isOperation(_id), \\\"Operation with this proposal id already exists\\\");\\n        require(_delay >= minDelay, \\\"Proposed delay is less than minimum delay\\\");\\n\\n        timestamps[_id] = block.timestamp + _delay;\\n    }\\n\\n    /// @dev Execute an operation's calls.\\n    /// @param _calls The array of calls to be executed.\\n    function _execute(Call[] calldata _calls) internal {\\n        for (uint256 i = 0; i < _calls.length; ++i) {\\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\\n            if (!success) {\\n                // Propagate an error if the call fails.\\n                assembly {\\n                    revert(add(returnData, 0x20), mload(returnData))\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Verifies if the predecessor operation is completed.\\n    /// @param _predecessorId The hash of the operation that should be completed.\\n    /// @dev Doesn't check the operation to be complete if the input is zero.\\n    function _checkPredecessorDone(bytes32 _predecessorId) internal view {\\n        require(_predecessorId == bytes32(0) || isOperationDone(_predecessorId), \\\"Predecessor operation not completed\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            SELF UPGRADES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Changes the minimum timelock duration for future operations.\\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\\n    function updateDelay(uint256 _newDelay) external onlySelf {\\n        emit ChangeMinDelay(minDelay, _newDelay);\\n        minDelay = _newDelay;\\n    }\\n\\n    /// @dev Updates the address of the security council.\\n    /// @param _newSecurityCouncil The address of the new security council.\\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\\n        securityCouncil = _newSecurityCouncil;\\n    }\\n\\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/governance/IGovernance.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\n/// @title Governance contract interface\\n/// @author Matter Labs\\n/// @custom:security-contact security@matterlabs.dev\\ninterface IGovernance {\\n    /// @dev This enumeration includes the following states:\\n    /// @param Unset Default state, indicating the operation has not been set.\\n    /// @param Waiting The operation is scheduled but not yet ready to be executed.\\n    /// @param Ready The operation is ready to be executed.\\n    /// @param Done The operation has been successfully executed.\\n    enum OperationState {\\n        Unset,\\n        Waiting,\\n        Ready,\\n        Done\\n    }\\n\\n    /// @dev Represents a call to be made during an operation.\\n    /// @param target The address to which the call will be made.\\n    /// @param value The amount of Ether (in wei) to be sent along with the call.\\n    /// @param data The calldata to be executed on the `target` address.\\n    struct Call {\\n        address target;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    /// @dev Defines the structure of an operation that Governance executes.\\n    /// @param calls An array of `Call` structs, each representing a call to be made during the operation.\\n    /// @param predecessor The hash of the predecessor operation, that should be executed before this operation.\\n    /// @param salt A bytes32 value used for creating unique operation hashes.\\n    struct Operation {\\n        Call[] calls;\\n        bytes32 predecessor;\\n        bytes32 salt;\\n    }\\n\\n    function isOperation(bytes32 _id) external view returns (bool);\\n\\n    function isOperationPending(bytes32 _id) external view returns (bool);\\n\\n    function isOperationReady(bytes32 _id) external view returns (bool);\\n\\n    function isOperationDone(bytes32 _id) external view returns (bool);\\n\\n    function getOperationState(bytes32 _id) external view returns (OperationState);\\n\\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external;\\n\\n    function scheduleShadow(bytes32 _id, uint256 _delay) external;\\n\\n    function cancel(bytes32 _id) external;\\n\\n    function execute(Operation calldata _operation) external payable;\\n\\n    function executeInstant(Operation calldata _operation) external payable;\\n\\n    function hashOperation(Operation calldata _operation) external pure returns (bytes32);\\n\\n    function updateDelay(uint256 _newDelay) external;\\n\\n    function updateSecurityCouncil(address _newSecurityCouncil) external;\\n\\n    /// @notice Emitted when transparent operation is scheduled.\\n    event TransparentOperationScheduled(bytes32 indexed _id, uint256 delay, Operation _operation);\\n\\n    /// @notice Emitted when shadow operation is scheduled.\\n    event ShadowOperationScheduled(bytes32 indexed _id, uint256 delay);\\n\\n    /// @notice Emitted when the operation is executed with delay or instantly.\\n    event OperationExecuted(bytes32 indexed _id);\\n\\n    /// @notice Emitted when the security council address is changed.\\n    event ChangeSecurityCouncil(address _securityCouncilBefore, address _securityCouncilAfter);\\n\\n    /// @notice Emitted when the minimum delay for future operations is modified.\\n    event ChangeMinDelay(uint256 _delayBefore, uint256 _delayAfter);\\n\\n    /// @notice Emitted when the operation with specified id is cancelled.\\n    event OperationCancelled(bytes32 indexed _id);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_securityCouncil\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_delayBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_delayAfter\",\"type\":\"uint256\"}],\"name\":\"ChangeMinDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_securityCouncilBefore\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_securityCouncilAfter\",\"type\":\"address\"}],\"name\":\"ChangeSecurityCouncil\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"OperationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"OperationExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"ShadowOperationScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IGovernance.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IGovernance.Operation\",\"name\":\"_operation\",\"type\":\"tuple\"}],\"name\":\"TransparentOperationScheduled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IGovernance.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct IGovernance.Operation\",\"name\":\"_operation\",\"type\":\"tuple\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IGovernance.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct IGovernance.Operation\",\"name\":\"_operation\",\"type\":\"tuple\"}],\"name\":\"executeInstant\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getOperationState\",\"outputs\":[{\"internalType\":\"enum IGovernance.OperationState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IGovernance.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct IGovernance.Operation\",\"name\":\"_operation\",\"type\":\"tuple\"}],\"name\":\"hashOperation\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isOperationDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isOperationPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isOperationReady\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"scheduleShadow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IGovernance.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct IGovernance.Operation\",\"name\":\"_operation\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"scheduleTransparent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"securityCouncil\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"operationId\",\"type\":\"bytes32\"}],\"name\":\"timestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"executionTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDelay\",\"type\":\"uint256\"}],\"name\":\"updateDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSecurityCouncil\",\"type\":\"address\"}],\"name\":\"updateSecurityCouncil\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Governance", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "0000000000000000000000001094b5812a40f1413a4b7f3bb717798c6305f34c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}