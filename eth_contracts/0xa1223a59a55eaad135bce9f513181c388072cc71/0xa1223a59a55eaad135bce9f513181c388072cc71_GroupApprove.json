{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GroupApprove/GroupApprove.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport \\\"./IMPC.sol\\\";\\nimport \\\"./ICross.sol\\\";\\n\\ncontract GroupApprove {\\n    struct Task {\\n        address to;\\n        bytes data;\\n        bool executed;\\n    }\\n\\n    struct SigData {\\n        bytes32 sigHash;\\n        bytes32 smgID; \\n        bytes r;\\n        bytes32 s;\\n    }\\n\\n    // slip-0044 standands chainId for local chain\\n    uint256 public chainId;\\n    uint256 public taskCount;\\n    address public foundation;\\n    address public signatureVerifier;\\n    address public oracle;\\n\\n    // proposalId => task\\n    mapping(uint256 => Task) public tasks;\\n\\n    enum GroupStatus { none, initial, curveSeted, failed, selected, ready, unregistered, dismissed }\\n\\n    modifier onlyFoundation() {\\n        require(msg.sender == foundation, \\\"not foundation\\\");\\n        _;\\n    }\\n\\n    modifier onlySelf() {\\n        require(msg.sender == address(this), \\\"not self\\\");\\n        _;\\n    }\\n\\n    modifier onlySmg(uint proposalId, bytes32 smgID, bytes calldata r, bytes32 s) {\\n        bytes32 sigHash = keccak256(abi.encode(proposalId, chainId));\\n        _verifyMpcSignature(\\n            SigData(\\n                sigHash, smgID, r, s\\n            )\\n        );\\n        _;\\n    }\\n\\n    event Proposal(\\n        uint256 indexed proposalId, \\n        address indexed to, \\n        bytes data\\n    );\\n\\n    event ApprovedAndExecuted(\\n        uint256 indexed proposalId, \\n        address indexed to, \\n        bytes data,\\n        bytes32 smgID\\n    );\\n\\n    event TransferFoundation(\\n        address indexed oldFoundation, \\n        address indexed newFoundation\\n    );\\n\\n    error SignatureVerifyFailed(\\n        bytes32 smgID,\\n        bytes32 sigHash,\\n        bytes r,\\n        bytes32 s\\n    );\\n\\n    error StoremanGroupNotReady(\\n        bytes32 smgID,\\n        uint256 status,\\n        uint256 timestamp,\\n        uint256 startTime,\\n        uint256 endTime\\n    );\\n    \\n    constructor(address _foundation, address _signatureVerifier, address _oracle, address _cross) {\\n        require(_foundation != address(0), \\\"foundation is empty\\\");\\n        address _oracleCross;\\n        address _signatureVerifierCross;\\n\\n        // cross check oracle and signatureVerifier address with cross contract\\n        (, _oracleCross, , , _signatureVerifierCross) = ICross(_cross).getPartners();\\n        oracle = _oracle;\\n        signatureVerifier = _signatureVerifier;\\n        require(_oracle == _oracleCross, \\\"oracle not match\\\");\\n        require(_signatureVerifier == _signatureVerifierCross, \\\"signatureVerifier not match\\\");\\n\\n        chainId = ICross(_cross).currentChainID(); // read from cross\\n        require(chainId != 0, \\\"chainId is empty\\\");\\n\\n        foundation = _foundation;\\n    }\\n\\n    function proposal(\\n        uint256 _chainId,\\n        address _to, \\n        bytes memory _data\\n    ) external onlyFoundation {\\n        require(_data.length > 0, \\\"data is empty\\\");\\n        require(_to != address(0), \\\"to is empty\\\");\\n        require(_chainId == chainId, \\\"chainId not match\\\");\\n\\n        // save task \\n        tasks[taskCount] = Task(_to, _data, false);\\n        emit Proposal(taskCount, _to, _data);\\n        taskCount++;\\n    }\\n\\n    function approveAndExecute(\\n        uint256 proposalId,\\n        bytes32 smgID,\\n        bytes calldata r,\\n        bytes32 s\\n    ) external onlySmg(proposalId, smgID, r, s) {\\n        Task storage task = tasks[proposalId];\\n        require(task.to != address(0), \\\"task not exists\\\");\\n        require(!task.executed, \\\"task already executed\\\");\\n\\n        (bool success, ) = task.to.call(task.data);\\n        require(success, \\\"call failed\\\");\\n        task.executed = true;\\n        emit ApprovedAndExecuted(proposalId, task.to, task.data, smgID);\\n    }\\n\\n    function halt(address _to, bool _halt) external onlyFoundation {\\n        ICross(_to).setHalt(_halt);\\n    }\\n\\n    function transferFoundation(address _newFoundation) external onlySelf {\\n        require(_newFoundation != address(0), \\\"new foundation is empty\\\");\\n        require(_newFoundation != foundation, \\\"new foundation is same as old\\\");\\n        foundation = _newFoundation;\\n        emit TransferFoundation(foundation, _newFoundation);\\n    }\\n\\n    // -------- internal functions --------\\n\\n    /// @notice                                 check the storeman group is ready or not\\n    /// @param smgID                            ID of storeman group\\n    /// @return curveID                         ID of elliptic curve\\n    /// @return PK                              PK of storeman group\\n    function _acquireReadySmgInfo(bytes32 smgID)\\n        internal\\n        view\\n        returns (uint curveID, bytes memory PK)\\n    {\\n        uint8 status;\\n        uint startTime;\\n        uint endTime;\\n        (,status,,,,curveID,,PK,,startTime,endTime) = IMPC(oracle).getStoremanGroupConfig(smgID);\\n\\n        if (!(status == uint8(GroupStatus.ready) && block.timestamp >= startTime && block.timestamp <= endTime)) {\\n            revert StoremanGroupNotReady({\\n                smgID: smgID,\\n                status: uint256(status),\\n                timestamp: block.timestamp,\\n                startTime: startTime,\\n                endTime: endTime\\n            });\\n        }\\n\\n        return (curveID, PK);\\n    }\\n\\n    /// @notice       convert bytes to bytes32\\n    /// @param b      bytes array\\n    /// @param offset offset of array to begin convert\\n    function _bytesToBytes32(bytes memory b, uint offset) internal pure returns (bytes32 result) {\\n        assembly {\\n            result := mload(add(add(b, offset), 32))\\n        }\\n    }\\n\\n    /**\\n     * @dev Verifies an MPC signature for a given message and Storeman Group ID\\n     * @param sig The signature to verify\\n     */\\n    function _verifyMpcSignature(SigData memory sig) internal {\\n        uint curveID;\\n        bytes memory PK;\\n\\n        // Acquire the curve ID and group public key for the given Storeman Group ID\\n        (curveID, PK) = _acquireReadySmgInfo(sig.smgID);\\n\\n        // Extract the X and Y components of the group public key\\n        bytes32 PKx = _bytesToBytes32(PK, 0);\\n        bytes32 PKy = _bytesToBytes32(PK, 32);\\n\\n        // Extract the X and Y components of the signature\\n        bytes32 Rx = _bytesToBytes32(sig.r, 0);\\n        bytes32 Ry = _bytesToBytes32(sig.r, 32);\\n\\n        // Verify the signature using the Wanchain MPC contract\\n        if (!IMPC(signatureVerifier).verify(curveID, sig.s, PKx, PKy, Rx, Ry, sig.sigHash)) {\\n            revert SignatureVerifyFailed({\\n                smgID: sig.smgID,\\n                sigHash: sig.sigHash,\\n                r: sig.r,\\n                s: sig.s\\n            });\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GroupApprove/ICross.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\ninterface ICross {\\n    function setHalt(bool) external;\\n    function getPartners() external view returns(address tokenManager, address smgAdminProxy, address smgFeeProxy, address quota, address sigVerifier);\\n    function currentChainID() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/GroupApprove/IMPC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\ninterface IMPC {\\n    /**\\n     * @dev Retrieves the configuration of a Storeman Group by ID\\n     * @param id The ID of the Storeman Group to retrieve\\n     * @return groupId The group ID of the Storeman Group\\n     * @return status The status of the Storeman Group\\n     * @return deposit The deposit amount of the Storeman Group\\n     * @return chain1 The ID of the first chain supported by the Storeman Group\\n     * @return chain2 The ID of the second chain supported by the Storeman Group\\n     * @return curve1 The ID of the first elliptic curve supported by the Storeman Group\\n     * @return curve2 The ID of the second elliptic curve supported by the Storeman Group\\n     * @return gpk1 The Group Public Key for the first elliptic curve\\n     * @return gpk2 The Group Public Key for the second elliptic curve\\n     * @return startTime The start time of the Storeman Group\\n     * @return endTime The end time of the Storeman Group\\n     */\\n    function getStoremanGroupConfig(\\n        bytes32 id\\n    ) external view returns (\\n        bytes32 groupId,\\n        uint8 status,\\n        uint deposit,\\n        uint chain1,\\n        uint chain2,\\n        uint curve1,\\n        uint curve2,\\n        bytes memory gpk1,\\n        bytes memory gpk2,\\n        uint startTime,\\n        uint endTime\\n    );\\n\\n    /**\\n     * @dev Verifies a signature using the provided parameters\\n     * @param curveId The ID of the elliptic curve used for the signature\\n     * @param signature The signature to be verified\\n     * @param groupKeyX The X component of the group public key\\n     * @param groupKeyY The Y component of the group public key\\n     * @param randomPointX The X component of the random point\\n     * @param randomPointY The Y component of the random point\\n     * @param message The message that was signed\\n     * @return true if the signature is valid, false otherwise\\n     */\\n    function verify(\\n        uint curveId,\\n        bytes32 signature,\\n        bytes32 groupKeyX,\\n        bytes32 groupKeyY,\\n        bytes32 randomPointX,\\n        bytes32 randomPointY,\\n        bytes32 message\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_foundation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signatureVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cross\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"smgID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"r\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"SignatureVerifyFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"smgID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"StoremanGroupNotReady\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"smgID\",\"type\":\"bytes32\"}],\"name\":\"ApprovedAndExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Proposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFoundation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFoundation\",\"type\":\"address\"}],\"name\":\"TransferFoundation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"smgID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"r\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"approveAndExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_halt\",\"type\":\"bool\"}],\"name\":\"halt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"proposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signatureVerifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taskCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFoundation\",\"type\":\"address\"}],\"name\":\"transferFoundation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GroupApprove", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004cf0a877e906dead748a41ae7da8c220e4247d9e0000000000000000000000009276ee38a5250e2f7fbe00a12ec17d09b5d28f3d000000000000000000000000bb38d10033b26f3836a8c1e41788206868b9f228000000000000000000000000fceaaaeb8d564a9d0e71ef36f027b9d162bc334e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8aa41d784797fbe662af29227111c68a1c91aaa18fad12684e814e7fec327c15"}