{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ReferralSystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./ReferralSystemStorage.sol\\\";\\n\\n/// @notice ReferralSystem contract is a contract that allows to create a referral codes and collect referral rewards\\n/// @author 0xLumos-Labs\\n/// @dev allows infinite nesting of referrals due to design of the contract of referrers being able to have referrers\\n/// @dev superior referrer is a referrer that invited another referrer\\n/// @dev inferior referrer is a referrer that have been invited by some referrer\\n/// @dev creator of referral code can be a first referrer ever existed, than he will never pay referral fees to his superior referrer\\ncontract ReferralSystem is ReferralSystemStorage, Ownable {\\n    /* ======== STORAGE ======== */\\n\\n    uint256 public SUPERIOR_REFERRER_SHARE_BPS;\\n\\n    /* ======== CONSTRUCTOR ======== */\\n\\n    constructor(uint256 _superiorReferrerShareBps) Ownable(msg.sender) {\\n        SUPERIOR_REFERRER_SHARE_BPS = _superiorReferrerShareBps;\\n    }\\n\\n    /* ======== ERRORS ======== */\\n\\n    error InvalidReferralCodeLength();\\n    error ReferralCodeUnavailable();\\n    error ReferralCodeNotExist();\\n    error NoRewardAccruedForReferrer();\\n    error ZeroAmountPassed();\\n\\n    /* ======== EVENTS ======== */\\n\\n    event ReferralCodeRegistered(\\n        bytes32 indexed referralCodeHash,\\n        address indexed referrer,\\n        bytes32 indexed superiorReferralCodeHash\\n    );\\n\\n    event ReferralRewardAccrued(\\n        address indexed token,\\n        uint256 reward,\\n        address indexed referrer\\n    );\\n\\n    event ReferralRewardWithdrawn(address indexed referrer, uint256 reward);\\n\\n    event ReferralRewardShareUpdated(uint256 newReferrerShareBps);\\n\\n    /* ======== MUTABLE FUNCTIONS ======== */\\n\\n    /// @notice new referrer can be registered with a referral code of another referrer\\n    /// @notice meaning that the new referrer will be a referral of the referrer and will share a reward with referrer\\n    function registerReferralCode(\\n        bytes32 referralCodeHash,\\n        address referrer,\\n        bytes32 superiorReferralCodeHash\\n    ) public {\\n        if (!isReferralCodeAvailable(referralCodeHash))\\n            revert ReferralCodeUnavailable();\\n\\n        if (\\n            superiorReferralCodeHash != bytes32(0) &&\\n            !isReferralCodeExist(superiorReferralCodeHash)\\n        ) revert ReferralCodeNotExist();\\n\\n        _setReferralCodeData(\\n            referralCodeHash,\\n            referrer,\\n            superiorReferralCodeHash\\n        );\\n\\n        emit ReferralCodeRegistered(\\n            referralCodeHash,\\n            referrer,\\n            superiorReferralCodeHash\\n        );\\n    }\\n\\n    function accrueNativeReferralReward(\\n        bytes32 referralCodeHash\\n    ) public payable {\\n        address referrer = getReferrerByReferralCodeHash(referralCodeHash);\\n\\n        _accrueReferralReward(address(0), msg.value, referrer);\\n    }\\n\\n    function accrueTokenReferralReward(\\n        address token,\\n        uint amount,\\n        bytes32 referralCodeHash\\n    ) public {\\n        address referrer = getReferrerByReferralCodeHash(referralCodeHash);\\n\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\n\\n        _accrueReferralReward(token, amount, referrer);\\n    }\\n\\n    /// @dev don't do checks on token\\n    /// @dev address(0) - rewards in native\\n    /// @dev a\\n    function _accrueReferralReward(\\n        address token,\\n        uint amount,\\n        address referrer\\n    ) public {\\n        if (referrer == address(0)) revert ReferrerNotExist();\\n\\n        _addRewardsToReferrer(token, amount, referrer);\\n\\n        emit ReferralRewardAccrued(token, amount, referrer);\\n    }\\n\\n    /// @param token address of the token to withdraw rewards for (zero address is native currency)\\n    function withdrawReferralRewards(address token) public {\\n        uint referralRewards = getReferrerRewards(msg.sender, token);\\n\\n        if (referralRewards == 0) revert NoRewardAccruedForReferrer();\\n\\n        address superior = getSuperiorReferrer(msg.sender);\\n\\n        _makeReferralRewards0(token, msg.sender);\\n\\n        uint256 superiorReferrerReward = _addRewardToSuperiorReferrer(\\n            token,\\n            referralRewards,\\n            superior\\n        );\\n\\n        uint256 amountToWithdraw = referralRewards - superiorReferrerReward;\\n\\n        if (token == address(0)) {\\n            payable(msg.sender).transfer(amountToWithdraw);\\n        } else {\\n            IERC20(token).transfer(msg.sender, amountToWithdraw);\\n        }\\n\\n        emit ReferralRewardWithdrawn(msg.sender, amountToWithdraw);\\n    }\\n\\n    function _addRewardToSuperiorReferrer(\\n        address token,\\n        uint inferiorReward,\\n        address superior\\n    ) internal returns (uint256 superiorReferrerReward) {\\n        if (superior == address(0)) {\\n            return 0;\\n        }\\n\\n        superiorReferrerReward = calcSuperiorReferrersShare(inferiorReward);\\n\\n        _addRewardsToReferrer(token, superiorReferrerReward, superior);\\n\\n        emit ReferralRewardAccrued(token, superiorReferrerReward, superior);\\n    }\\n\\n    /* ======== RESTRICTED FUNCTIONS ======== */\\n\\n    function updateReferralRewardShare(\\n        uint256 newSuperiorReferrerShareBps\\n    ) public onlyOwner {\\n        SUPERIOR_REFERRER_SHARE_BPS = newSuperiorReferrerShareBps;\\n\\n        emit ReferralRewardShareUpdated(newSuperiorReferrerShareBps);\\n    }\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    function calcSuperiorReferrersShare(\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        return (amount * SUPERIOR_REFERRER_SHARE_BPS) / 10000;\\n    }\\n\\n    function isReferralCodeAvailable(\\n        bytes32 referralCodeHash\\n    ) public view returns (bool) {\\n        return getReferrerByReferralCodeHash(referralCodeHash) == address(0);\\n    }\\n\\n    function isReferralCodeExist(\\n        bytes32 referralCodeHash\\n    ) public view returns (bool) {\\n        return getReferrerByReferralCodeHash(referralCodeHash) != address(0);\\n    }\\n\\n    function getReferralCodeHash(\\n        string calldata code\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(code));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ReferralSystemStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ncontract ReferralSystemStorage {\\n    /* ======== DATA TYPES ======== */\\n\\n    struct ReferrerData {\\n        // address(0) is native currency\\n        mapping(address => uint256) referralRewards;\\n        address superiorReferrer;\\n    }\\n\\n    mapping(address referrer => ReferrerData) private referrerData;\\n    // mapping(address referrer => address superiorReferrer)\\n    //     private superiorReferrer;\\n\\n    /* ======== ERRORS ======== */\\n\\n    error ReferrerNotExist();\\n    error ZeroAddressPassed();\\n    error ZeroReferralCodeHashPassed();\\n    error ZeroRewardPassed();\\n\\n    /* ======== STORAGE ======== */\\n\\n    mapping(bytes32 referralCodeHash => address referrer)\\n        private referrerByReferralCodeHash;\\n\\n    /* ======== MUTABLE FUNCTIONS ======== */\\n\\n    function _setReferralCodeData(\\n        bytes32 referralCodeHash,\\n        address referrer,\\n        bytes32 superiorReferralCodeHash\\n    ) internal {\\n        if (referrer == address(0)) revert ZeroAddressPassed();\\n        if (referralCodeHash == bytes32(0x0))\\n            revert ZeroReferralCodeHashPassed();\\n\\n        referrerByReferralCodeHash[referralCodeHash] = referrer;\\n\\n        address _superiorReferrer = getReferrerByReferralCodeHash(\\n            superiorReferralCodeHash\\n        );\\n\\n        referrerData[referrer].superiorReferrer = _superiorReferrer;\\n    }\\n\\n    function _addRewardsToReferrer(\\n        address token,\\n        uint256 reward,\\n        address referrer\\n    ) internal {\\n        if (reward == 0) revert ZeroRewardPassed();\\n        if (referrer == address(0)) revert ZeroAddressPassed();\\n\\n        referrerData[referrer].referralRewards[token] += reward;\\n    }\\n\\n    function _makeReferralRewards0(address token, address referrer) internal {\\n        referrerData[referrer].referralRewards[token] = 0;\\n    }\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    function getReferrerByReferralCode(\\n        string calldata referralCode\\n    ) public view returns (address referrer) {\\n        bytes32 referralCodeHash = keccak256(abi.encodePacked(referralCode));\\n        referrer = referrerByReferralCodeHash[referralCodeHash];\\n\\n        if (referrer == address(0)) revert ReferrerNotExist();\\n    }\\n\\n    function getReferrerByReferralCodeHash(\\n        bytes32 referralCodeHash\\n    ) public view returns (address referrer) {\\n        referrer = referrerByReferralCodeHash[referralCodeHash];\\n\\n        // if (referrer == address(0)) revert ReferrerNotExist(referralCodeHash);\\n    }\\n\\n    function getReferrerRewards(\\n        address referrer,\\n        address token\\n    ) public view returns (uint) {\\n        return referrerData[referrer].referralRewards[token];\\n    }\\n\\n    function getSuperiorReferrer(\\n        address referrer\\n    ) public view returns (address) {\\n        return referrerData[referrer].superiorReferrer;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_superiorReferrerShareBps\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidReferralCodeLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRewardAccruedForReferrer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralCodeNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralCodeUnavailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferrerNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmountPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroReferralCodeHashPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroRewardPassed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"superiorReferralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"ReferralCodeRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"ReferralRewardAccrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReferrerShareBps\",\"type\":\"uint256\"}],\"name\":\"ReferralRewardShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ReferralRewardWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SUPERIOR_REFERRER_SHARE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"_accrueReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"accrueNativeReferralReward\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"accrueTokenReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcSuperiorReferrersShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getReferralCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"}],\"name\":\"getReferrerByReferralCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"getReferrerByReferralCodeHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getReferrerRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"getSuperiorReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"isReferralCodeAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"isReferralCodeExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"referralCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"superiorReferralCodeHash\",\"type\":\"bytes32\"}],\"name\":\"registerReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSuperiorReferrerShareBps\",\"type\":\"uint256\"}],\"name\":\"updateReferralRewardShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawReferralRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ReferralSystem", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000003e8", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}