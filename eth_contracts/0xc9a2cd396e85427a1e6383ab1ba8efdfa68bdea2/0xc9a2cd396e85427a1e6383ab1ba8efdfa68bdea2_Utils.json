{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IUniswapV2Router01 {\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    returns (\\n      uint amountA,\\n      uint amountB,\\n      uint liquidity\\n    );\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    payable\\n    returns (\\n      uint amountToken,\\n      uint amountETH,\\n      uint liquidity\\n    );\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) external pure returns (uint amountB);\\n\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountOut);\\n\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountIn);\\n\\n  function getAmountsOut(uint amountIn, address[] calldata path)\\n    external\\n    view\\n    returns (uint[] memory amounts);\\n\\n  function getAmountsIn(uint amountOut, address[] calldata path)\\n    external\\n    view\\n    returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IUniswapV2Router.sol\\\";\\n\\nlibrary Utils {\\n  using SafeMath for uint256;\\n\\n  function random(\\n    uint256 from,\\n    uint256 to,\\n    uint256 salty\\n  ) private view returns (uint256) {\\n    uint256 seed = uint256(\\n      keccak256(\\n        abi.encodePacked(\\n          block.timestamp +\\n            block.difficulty +\\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) /\\n              (block.timestamp)) +\\n            block.gaslimit +\\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\\n              (block.timestamp)) +\\n            block.number +\\n            salty\\n        )\\n      )\\n    );\\n    return seed.mod(to - from) + from;\\n  }\\n\\n  function isLotteryWon(\\n    uint256 salty,\\n    uint256 winningDoubleRewardPercentage\\n  ) private view returns (bool) {\\n    uint256 luckyNumber = random(0, 100, salty);\\n    uint256 winPercentage = winningDoubleRewardPercentage;\\n    return luckyNumber <= winPercentage;\\n  }\\n\\n  function calculateETHRewardGamble(\\n    uint256 currentBalance,\\n    uint256 currentETHPool,\\n    uint256 totalSupply\\n  ) public view returns (uint256) {\\n    uint256 ethPool = currentETHPool;\\n\\n    uint256 reward = 0;\\n    // calculate reward to send\\n    bool isLotteryWonOnClaim = isLotteryWon(\\n      currentBalance,\\n      50\\n    );\\n    if (isLotteryWonOnClaim) {\\n      reward = ethPool.mul(2).mul(currentBalance).div(\\n        totalSupply\\n      );\\n    }\\n    return reward;\\n  }\\n\\n  function calculateTopUpClaim(\\n    uint256 currentRecipientBalance,\\n    uint256 basedRewardCycleBlock,\\n    uint256 threshHoldTopUpRate,\\n    uint256 amount\\n  ) public view returns (uint256) {\\n    if (currentRecipientBalance == 0) {\\n      return block.timestamp + basedRewardCycleBlock;\\n    } else {\\n      uint256 rate = amount.mul(100).div(currentRecipientBalance);\\n      if (uint256(rate) >= threshHoldTopUpRate) {\\n        uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(\\n          100\\n        );\\n        if (incurCycleBlock >= basedRewardCycleBlock) {\\n          incurCycleBlock = basedRewardCycleBlock;\\n        }\\n\\n        return incurCycleBlock;\\n      }\\n\\n      return 0;\\n    }\\n  }\\n\\n  function doNothing() private pure returns (bool) {\\n    return true;\\n  }\\n\\n  function swapETHForTokens(\\n    address routerAddress,\\n    address recipient,\\n    uint256 ethAmount\\n  ) public {\\n    IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\\n\\n    // generate the pancake pair path of token -> weth\\n    address[] memory path = new address[](2);\\n    path[0] = router.WETH();\\n    path[1] = address(this);\\n\\n    // make the swap\\n    router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\\n      0, // accept any amount of ETH\\n      path,\\n      address(recipient),\\n      block.timestamp + 360\\n    );\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentETHPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"calculateETHRewardGamble\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentRecipientBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basedRewardCycleBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshHoldTopUpRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateTopUpClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Utils", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}