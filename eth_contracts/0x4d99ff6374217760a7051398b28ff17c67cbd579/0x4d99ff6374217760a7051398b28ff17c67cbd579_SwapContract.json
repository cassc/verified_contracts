{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ncontract SwapContract {\r\n    // IUniswapV2Router02 public uniswapV2Router;\r\n    // address public uniswapV2Factory;\r\n    // address public uniswapV2Pair;\r\n    address public owner;\r\n\r\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    address private constant UNISWAP_V2_ROUTER =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private constant UNISWAP_V2_FACTORY =\r\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n    \r\n    IUniswapV2Router private router = IUniswapV2Router(UNISWAP_V2_ROUTER);\r\n    IUniswapV2Factory private factory = IUniswapV2Factory(UNISWAP_V2_FACTORY);\r\n\r\n    constructor() {\r\n        owner = msg.sender; // set the contract deployer as the owner\r\n    }\r\n\r\n    function buyToken(address _tokenAddress, uint256 _amountOut, uint8 preSlippage, uint8 postSlippage) external payable {\r\n        address uniswapV2Pair = factory.getPair(_tokenAddress, WETH);\r\n        require(address(uniswapV2Pair) != address(0), \"No liquidity pool exists for this token\");\r\n\r\n        // IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n        // address token0 = pair.token0();\r\n\r\n        // (uint112 reserve0,uint112 reserve1,) = pair.getReserves();\r\n        // if (token0 == WETH) {\r\n        //     require(reserve0 >= 1e18, \"Less than 1 eth\");\r\n        // }\r\n        // else {\r\n        //     require(reserve1 >= 1e18, \"Less than 1 eth\");\r\n        // }\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = _tokenAddress;\r\n        \r\n        // calculate output amount and apply slippage\r\n        uint256 amountOut = router.getAmountsOut(msg.value, path)[1];\r\n        uint256 amountOutMin = amountOut - (postSlippage * amountOut / 100);  // Decrease by % for slippage\r\n\r\n        require(amountOut > _amountOut - (preSlippage * _amountOut / 100), \"Price slipped\");\r\n\r\n        uint256 deadline = block.timestamp + 1 minutes;\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: msg.value }(\r\n            amountOutMin,\r\n            path,\r\n            address(this),\r\n            deadline\r\n        );\r\n\r\n        IERC20 token = IERC20(_tokenAddress);\r\n        uint256 maxUint = type(uint256).max;\r\n        bool success = token.approve(address(this), maxUint);\r\n        require(success, \"approve 1 failed\");\r\n        // success = token.approve(msg.sender, maxUint);\r\n        // require(success, \"approve 2 failed\");\r\n        success = token.approve(UNISWAP_V2_ROUTER, maxUint);\r\n        require(success, \"approve 3 failed\");\r\n        success = token.approve(uniswapV2Pair, maxUint);\r\n        require(success, \"approve 4 failed\");\r\n    }\r\n\r\n    function sellToken(address _tokenAddress) external payable {\r\n        require(msg.sender == owner, \"Only the contract owner can sell\");\r\n\r\n        // address uniswapV2Pair = factory.getPair(_tokenAddress, WETH);\r\n        // require(address(uniswapV2Pair) != address(0), \"No liquidity pool exists for this token\");\r\n\r\n        // IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n        // address token0 = pair.token0();\r\n\r\n        // (uint112 reserve0,uint112 reserve1,) = pair.getReserves();\r\n        // if (token0 == WETH) {\r\n        //     require(reserve0 >= 1e18, \"Less than 1 eth\");\r\n        // }\r\n        // else {\r\n        //     require(reserve1 >= 1e18, \"Less than 1 eth\");\r\n        // }\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = _tokenAddress;\r\n        path[1] = WETH;\r\n\r\n        IERC20 token = IERC20(_tokenAddress);\r\n        \r\n        uint256 amountIn = token.balanceOf(address(this));\r\n\r\n        uint256 amountOutMin = 0;\r\n\r\n        uint256 deadline = block.timestamp + 1 minutes;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            msg.sender,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    // function to allow the owner to withdraw all Ether from the contract\r\n    function withdraw() external {\r\n        require(msg.sender == owner, \"Only the contract owner can withdraw\");\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns (address);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"preSlippage\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"postSlippage\",\"type\":\"uint8\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"sellToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwapContract", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ae41e99ce8a751eb0e472240ae48f39a317c55604b4896f218e8fed19038b3b6"}