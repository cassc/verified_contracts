{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/YugaModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./ERC721Module.sol\\\";\\nimport \\\"../IApeCoinStaking.sol\\\";\\n\\nstruct ApeLocker {\\n    /// @notice Map of the locked tokens.\\n    ///     Note: Collection Address => Token ID => Lock state\\n    mapping(address => mapping(uint256 => uint8)) tokens;\\n}\\n\\nerror TokenIsLocked();\\nerror AlreadyInLockState();\\nerror NotEnoughRewards();\\nerror NotPaired();\\n\\n/// @title Cyan Wallet Yuga Module - A Cyan wallet's Ape & ApeCoin handling module.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\ncontract YugaModule is ERC721Module {\\n    // keccak256(\\\"wallet.YugaModule.lockedApe\\\")\\n    bytes32 public constant APE_LOCKER_SLOT = 0x010881fa8a1edce184936a8e4e08060bba49cb5145c9b396e6e80c0c6b0e1269;\\n\\n    // Yuga contracts\\n    IApeCoinStaking public constant apePool = IApeCoinStaking(0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9);\\n    IERC20 public constant apeCoin = IERC20(0x4d224452801ACEd8B2F0aebE155379bb5D594381);\\n    address public constant BAYC_ADDRESS = 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D;\\n    address public constant MAYC_ADDRESS = 0x60E4d786628Fea6478F785A6d7e704777c86a7c6;\\n    address public constant BAKC_ADDRESS = 0xba30E5F9Bb24caa003E9f2f0497Ad287FDF95623;\\n\\n    // ApePool ids\\n    uint256 public constant BAYC_POOL_ID = 1;\\n    uint256 public constant MAYC_POOL_ID = 2;\\n    uint256 public constant BAKC_POOL_ID = 3;\\n\\n    uint8 public constant LOCK_BIT_INDEX_0 = 0; // Lock bit index of BAYC & MAYC\\n    uint8 public constant LOCK_BIT_INDEX_1 = 1; // Lock bit index of BAKC\\n\\n    event SetLockedApeNFT(address collection, uint256 tokenId, uint8 lockStatus);\\n\\n    /// @inheritdoc IModule\\n    function handleTransaction(\\n        address collection,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable override returns (bytes memory) {\\n        bytes4 funcHash = Utils.parseFunctionSelector(data);\\n\\n        // BAYC deposit & withdraw checks\\n        if (\\n            funcHash == IApeCoinStaking.depositBAYC.selector ||\\n            funcHash == IApeCoinStaking.withdrawSelfBAYC.selector ||\\n            funcHash == IApeCoinStaking.withdrawBAYC.selector\\n        ) {\\n            _performSingleNftChecks(BAYC_ADDRESS, data);\\n        }\\n\\n        // MAYC deposit & withdraw checks\\n        if (\\n            funcHash == IApeCoinStaking.depositMAYC.selector ||\\n            funcHash == IApeCoinStaking.withdrawSelfMAYC.selector ||\\n            funcHash == IApeCoinStaking.withdrawMAYC.selector\\n        ) {\\n            _performSingleNftChecks(MAYC_ADDRESS, data);\\n        }\\n\\n        // BAYC & MAYC claim checks\\n        if (funcHash == IApeCoinStaking.claimBAYC.selector || funcHash == IApeCoinStaking.claimSelfBAYC.selector) {\\n            _performTokenIdChecks(BAYC_ADDRESS, data);\\n        }\\n        if (funcHash == IApeCoinStaking.claimMAYC.selector || funcHash == IApeCoinStaking.claimSelfMAYC.selector) {\\n            _performTokenIdChecks(MAYC_ADDRESS, data);\\n        }\\n\\n        // BAKC checks\\n        if (funcHash == IApeCoinStaking.depositBAKC.selector) {\\n            _performPairDepositChecks(data);\\n        }\\n        if (funcHash == IApeCoinStaking.withdrawBAKC.selector) {\\n            _performPairWithdrawChecks(data);\\n        }\\n        if (funcHash == IApeCoinStaking.claimBAKC.selector || funcHash == IApeCoinStaking.claimSelfBAKC.selector) {\\n            _performPairClaims(data);\\n        }\\n\\n        return super.handleTransaction(collection, value, data);\\n    }\\n\\n    function _performSingleNftChecks(address collection, bytes calldata data) private view {\\n        IApeCoinStaking.SingleNft[] memory nfts = abi.decode(data[4:], (IApeCoinStaking.SingleNft[]));\\n\\n        for (uint256 i; i < nfts.length; ) {\\n            if (_isLocked(collection, nfts[i].tokenId, LOCK_BIT_INDEX_0)) revert TokenIsLocked();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _performTokenIdChecks(address collection, bytes calldata data) private view {\\n        uint256[] memory tokenIds = abi.decode(data[4:], (uint256[]));\\n\\n        for (uint256 i; i < tokenIds.length; ) {\\n            if (_isLocked(collection, tokenIds[i], LOCK_BIT_INDEX_0)) revert TokenIsLocked();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _performPairDepositChecks(bytes calldata data) private view {\\n        (\\n            IApeCoinStaking.PairNftDepositWithAmount[] memory baycPairs,\\n            IApeCoinStaking.PairNftDepositWithAmount[] memory maycPairs\\n        ) = abi.decode(\\n                data[4:],\\n                (IApeCoinStaking.PairNftDepositWithAmount[], IApeCoinStaking.PairNftDepositWithAmount[])\\n            );\\n\\n        _checkLockOfPairDeposits(baycPairs);\\n        _checkLockOfPairDeposits(maycPairs);\\n    }\\n\\n    function _performPairWithdrawChecks(bytes calldata data) private view {\\n        (\\n            IApeCoinStaking.PairNftWithdrawWithAmount[] memory baycPairs,\\n            IApeCoinStaking.PairNftWithdrawWithAmount[] memory maycPairs\\n        ) = abi.decode(\\n                data[4:],\\n                (IApeCoinStaking.PairNftWithdrawWithAmount[], IApeCoinStaking.PairNftWithdrawWithAmount[])\\n            );\\n\\n        _checkLockOfPairWithdrawals(baycPairs);\\n        _checkLockOfPairWithdrawals(maycPairs);\\n    }\\n\\n    function _performPairClaims(bytes calldata data) private view {\\n        IApeCoinStaking.PairNft[] memory baycPairs;\\n        IApeCoinStaking.PairNft[] memory maycPairs;\\n\\n        (baycPairs, maycPairs) = abi.decode(data[4:], (IApeCoinStaking.PairNft[], IApeCoinStaking.PairNft[]));\\n        _checkLockOfPairClaims(baycPairs);\\n        _checkLockOfPairClaims(maycPairs);\\n    }\\n\\n    // Internal module methods, only operators can call these methods\\n\\n    /// @notice Allows operators to lock BAYC and stake to the ape pool.\\n    /// @param tokenId Token ID of BAYC\\n    /// @param amount Loaning ApeCoin amount\\n    function depositBAYCAndLock(uint32 tokenId, uint224 amount) external {\\n        _depositSingleNftAndLock(BAYC_ADDRESS, tokenId, amount);\\n    }\\n\\n    /// @notice Allows operators to lock MAYC and stake to the ape pool.\\n    /// @param tokenId Token ID of MAYC\\n    /// @param amount Loaning ApeCoin amount\\n    function depositMAYCAndLock(uint32 tokenId, uint224 amount) external {\\n        _depositSingleNftAndLock(MAYC_ADDRESS, tokenId, amount);\\n    }\\n\\n    function _depositSingleNftAndLock(\\n        address collection,\\n        uint32 tokenId,\\n        uint224 amount\\n    ) private {\\n        _lock(collection, tokenId, LOCK_BIT_INDEX_0);\\n\\n        IApeCoinStaking.SingleNft[] memory nfts = new IApeCoinStaking.SingleNft[](1);\\n        nfts[0] = IApeCoinStaking.SingleNft(tokenId, amount);\\n        apeCoin.approve(address(apePool), amount);\\n\\n        (collection == BAYC_ADDRESS) ? apePool.depositBAYC(nfts) : apePool.depositMAYC(nfts);\\n    }\\n\\n    /// @notice Allows operators to lock BAKC and stake to the ape pool.\\n    /// @param mainCollection BAYC or MAYC address\\n    /// @param mainTokenId BAYC or MAYC token ID\\n    /// @param bakcTokenId BAKC token ID\\n    /// @param amount Loaning ApeCoin amount\\n    function depositBAKCAndLock(\\n        address mainCollection,\\n        uint32 mainTokenId,\\n        uint32 bakcTokenId,\\n        uint224 amount\\n    ) external {\\n        _lock(mainCollection, mainTokenId, LOCK_BIT_INDEX_1);\\n        _lock(BAKC_ADDRESS, bakcTokenId, LOCK_BIT_INDEX_1);\\n\\n        IApeCoinStaking.PairNftDepositWithAmount[] memory baycs;\\n        IApeCoinStaking.PairNftDepositWithAmount[] memory maycs;\\n\\n        if (mainCollection == BAYC_ADDRESS) {\\n            baycs = new IApeCoinStaking.PairNftDepositWithAmount[](1);\\n            baycs[0] = IApeCoinStaking.PairNftDepositWithAmount(mainTokenId, bakcTokenId, uint184(amount));\\n        } else if (mainCollection == MAYC_ADDRESS) {\\n            maycs = new IApeCoinStaking.PairNftDepositWithAmount[](1);\\n            maycs[0] = IApeCoinStaking.PairNftDepositWithAmount(mainTokenId, bakcTokenId, uint184(amount));\\n        }\\n\\n        apeCoin.approve(address(apePool), amount);\\n        apePool.depositBAKC(baycs, maycs);\\n    }\\n\\n    /// @notice Allows operators to unlock BAYC and unstake from the ape pool.\\n    /// @param tokenId Token ID of BAYC\\n    function withdrawBAYCAndUnlock(uint32 tokenId) external {\\n        _unlock(BAYC_ADDRESS, tokenId, LOCK_BIT_INDEX_0);\\n\\n        IApeCoinStaking.SingleNft[] memory nfts = new IApeCoinStaking.SingleNft[](1);\\n        nfts[0] = IApeCoinStaking.SingleNft(tokenId, uint224(apePool.nftPosition(BAYC_POOL_ID, tokenId).stakedAmount));\\n        apePool.withdrawBAYC(nfts, msg.sender);\\n    }\\n\\n    /// @notice Allows operators to unlock MAYC and unstake from the ape pool.\\n    /// @param tokenId Token ID of MAYC\\n    function withdrawMAYCAndUnlock(uint32 tokenId) external {\\n        _unlock(MAYC_ADDRESS, tokenId, LOCK_BIT_INDEX_0);\\n\\n        IApeCoinStaking.SingleNft[] memory nfts = new IApeCoinStaking.SingleNft[](1);\\n        nfts[0] = IApeCoinStaking.SingleNft(tokenId, uint224(apePool.nftPosition(MAYC_POOL_ID, tokenId).stakedAmount));\\n        apePool.withdrawMAYC(nfts, msg.sender);\\n    }\\n\\n    /// @notice Allows operators to unlock BAKC and unstake from the ape pool.\\n    /// @param tokenId BAKC token ID\\n    function withdrawBAKCAndUnlock(uint32 tokenId) external {\\n        IApeCoinStaking.PairingStatus memory baycStatus = apePool.bakcToMain(tokenId, BAYC_POOL_ID);\\n\\n        address mainCollection;\\n        uint32 mainTokenId;\\n\\n        IApeCoinStaking.PairNftWithdrawWithAmount[] memory baycs;\\n        IApeCoinStaking.PairNftWithdrawWithAmount[] memory maycs;\\n        if (baycStatus.isPaired) {\\n            mainCollection = BAYC_ADDRESS;\\n            mainTokenId = uint32(baycStatus.tokenId);\\n            baycs = new IApeCoinStaking.PairNftWithdrawWithAmount[](1);\\n            baycs[0] = IApeCoinStaking.PairNftWithdrawWithAmount(mainTokenId, tokenId, 0, true);\\n        } else {\\n            IApeCoinStaking.PairingStatus memory maycStatus = apePool.bakcToMain(tokenId, MAYC_POOL_ID);\\n            if (maycStatus.isPaired) {\\n                mainCollection = MAYC_ADDRESS;\\n                mainTokenId = uint32(maycStatus.tokenId);\\n                maycs = new IApeCoinStaking.PairNftWithdrawWithAmount[](1);\\n                maycs[0] = IApeCoinStaking.PairNftWithdrawWithAmount(mainTokenId, tokenId, 0, true);\\n            } else {\\n                revert NotPaired();\\n            }\\n        }\\n\\n        uint256 stakedAmount = apePool.nftPosition(BAKC_POOL_ID, tokenId).stakedAmount;\\n        uint256 rewards = apePool.pendingRewards(BAKC_POOL_ID, address(this), tokenId);\\n\\n        _unlock(mainCollection, mainTokenId, LOCK_BIT_INDEX_1);\\n        _unlock(BAKC_ADDRESS, tokenId, LOCK_BIT_INDEX_1);\\n\\n        apePool.withdrawBAKC(baycs, maycs);\\n        apeCoin.transfer(msg.sender, stakedAmount + rewards);\\n    }\\n\\n    function autoCompound(uint256 poolId, uint32 tokenId) public {\\n        _claimRewards(poolId, tokenId, msg.sender);\\n    }\\n\\n    function _claimRewards(\\n        uint256 poolId,\\n        uint32 tokenId,\\n        address recipient\\n    ) private {\\n        if (poolId == BAYC_POOL_ID) {\\n            uint256[] memory nfts = new uint256[](1);\\n            nfts[0] = tokenId;\\n\\n            apePool.claimBAYC(nfts, recipient);\\n        } else if (poolId == MAYC_POOL_ID) {\\n            uint256[] memory nfts = new uint256[](1);\\n            nfts[0] = tokenId;\\n\\n            apePool.claimMAYC(nfts, recipient);\\n        } else {\\n            IApeCoinStaking.PairingStatus memory baycStatus = apePool.bakcToMain(tokenId, BAYC_POOL_ID);\\n\\n            IApeCoinStaking.PairNft[] memory baycs;\\n            IApeCoinStaking.PairNft[] memory maycs;\\n            if (baycStatus.isPaired) {\\n                baycs = new IApeCoinStaking.PairNft[](1);\\n                baycs[0] = IApeCoinStaking.PairNft(uint128(baycStatus.tokenId), tokenId);\\n            } else {\\n                IApeCoinStaking.PairingStatus memory maycStatus = apePool.bakcToMain(tokenId, MAYC_POOL_ID);\\n                if (maycStatus.isPaired) {\\n                    maycs = new IApeCoinStaking.PairNft[](1);\\n                    maycs[0] = IApeCoinStaking.PairNft(uint128(maycStatus.tokenId), tokenId);\\n                }\\n            }\\n\\n            apePool.claimBAKC(baycs, maycs, recipient);\\n        }\\n    }\\n\\n    // Lock handlers\\n    function _isLocked(\\n        address collection,\\n        uint256 tokenId,\\n        uint8 bitIndex\\n    ) private view returns (bool) {\\n        ApeLocker storage locker = _getApeLocker();\\n\\n        uint8 lockState = (uint8(1) << bitIndex);\\n        return (locker.tokens[collection][tokenId] & lockState) == lockState;\\n    }\\n\\n    function _lock(\\n        address collection,\\n        uint256 tokenId,\\n        uint8 bitIndex\\n    ) private {\\n        ApeLocker storage locker = _getApeLocker();\\n        if (_isLocked(collection, tokenId, bitIndex)) revert AlreadyInLockState();\\n\\n        locker.tokens[collection][tokenId] |= (uint8(1) << bitIndex);\\n        emit SetLockedApeNFT(collection, tokenId, locker.tokens[collection][tokenId]);\\n    }\\n\\n    function _unlock(\\n        address collection,\\n        uint256 tokenId,\\n        uint8 bitIndex\\n    ) private {\\n        ApeLocker storage locker = _getApeLocker();\\n        if (!_isLocked(collection, tokenId, bitIndex)) revert AlreadyInLockState();\\n\\n        locker.tokens[collection][tokenId] &= ~(uint8(1) << bitIndex);\\n        emit SetLockedApeNFT(collection, tokenId, locker.tokens[collection][tokenId]);\\n    }\\n\\n    /// @notice Checks whether the token is locked or not.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @return isLocked Whether the token is locked or not.\\n    function checkIsLocked(address collection, uint256 tokenId) public view override returns (bool) {\\n        return _isApeLocked(collection, tokenId) || super.checkIsLocked(collection, tokenId);\\n    }\\n\\n    /// @dev Returns the map of the locked tokens.\\n    /// @return result ERC721Locker struct of the locked tokens.\\n    ///     Note: Collection Address => Token ID => Lock state\\n    function _getApeLocker() internal pure returns (ApeLocker storage result) {\\n        assembly {\\n            result.slot := APE_LOCKER_SLOT\\n        }\\n    }\\n\\n    /// @notice Checks whether the token is ape locked or not.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @return isLocked Whether the token is ape locked or not.\\n    function _isApeLocked(address collection, uint256 tokenId) private view returns (bool) {\\n        return _getApeLocker().tokens[collection][tokenId] != 0;\\n    }\\n\\n    /// @notice Checks whether any of the tokens is locked or not.\\n    /// @param pairs Array of IApeCoinStaking.PairNftDepositWithAmount structs\\n    function _checkLockOfPairDeposits(IApeCoinStaking.PairNftDepositWithAmount[] memory pairs) private view {\\n        for (uint256 i; i < pairs.length; ) {\\n            if (_isLocked(BAKC_ADDRESS, pairs[i].bakcTokenId, LOCK_BIT_INDEX_1)) revert TokenIsLocked();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks whether any of the tokens is locked or not.\\n    /// @param pairs Array of IApeCoinStaking.PairNftWithdrawWithAmount structs\\n    function _checkLockOfPairWithdrawals(IApeCoinStaking.PairNftWithdrawWithAmount[] memory pairs) private view {\\n        for (uint256 i; i < pairs.length; ) {\\n            if (_isLocked(BAKC_ADDRESS, pairs[i].bakcTokenId, LOCK_BIT_INDEX_1)) revert TokenIsLocked();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks whether any of the tokens is locked or not.\\n    /// @param pairs Array of IApeCoinStaking.PairNft structs\\n    function _checkLockOfPairClaims(IApeCoinStaking.PairNft[] memory pairs) private view {\\n        for (uint256 i; i < pairs.length; ) {\\n            if (_isLocked(BAKC_ADDRESS, pairs[i].bakcTokenId, LOCK_BIT_INDEX_1)) revert TokenIsLocked();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/ERC721Module.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"../CoreStorage.sol\\\";\\nimport \\\"../Utils.sol\\\";\\n\\nstruct ERC721Locker {\\n    /// @notice Locked tokens count of the collection.\\n    ///     Note: Collection Address => Number of locked tokens\\n    mapping(address => uint256) count;\\n    /// @notice Map of the locked tokens.\\n    ///     Note: Collection Address => Token ID => isLocked\\n    mapping(address => mapping(uint256 => bool)) tokens;\\n}\\n\\n/// @title Cyan Wallet ERC721 Module - A Cyan wallet's ERC721 token handling module.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\ncontract ERC721Module is CoreStorage, IModule {\\n    // keccak256(\\\"wallet.ERC721Module.lockedERC721\\\")\\n    bytes32 private constant LOCKER_SLOT = 0x25888debd3e1e584ccaebe1162c7763ec457a94078c5d0d9a1d32a926ff9973c;\\n\\n    bytes4 private constant ERC721_APPROVE = IERC721.approve.selector;\\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = IERC721.setApprovalForAll.selector;\\n    bytes4 private constant ERC721_TRANSFER_FROM = IERC721.transferFrom.selector;\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES =\\n        bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,bytes)\\\"));\\n\\n    event SetLockedERC721Token(address collection, uint256 tokenId, bool isLocked);\\n\\n    /// @inheritdoc IModule\\n    function handleTransaction(\\n        address collection,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable virtual override returns (bytes memory) {\\n        bytes4 funcHash = Utils.parseFunctionSelector(data);\\n        if (\\n            funcHash == ERC721_TRANSFER_FROM ||\\n            funcHash == ERC721_SAFE_TRANSFER_FROM ||\\n            funcHash == ERC721_SAFE_TRANSFER_FROM_BYTES\\n        ) {\\n            uint256 tokenId = Utils.getUint256At(data, 0x44);\\n            require(!checkIsLocked(collection, tokenId), \\\"Cannot perform this action on locked token.\\\");\\n        }\\n        if (funcHash == ERC721_APPROVE) {\\n            uint256 tokenId = Utils.getUint256At(data, 0x24);\\n            require(!checkIsLocked(collection, tokenId), \\\"Cannot perform this action on locked token.\\\");\\n        }\\n        if (funcHash == ERC721_SET_APPROVAL_FOR_ALL) {\\n            require(_getLocker().count[collection] == 0, \\\"Cannot perform this action on locked token.\\\");\\n        }\\n\\n        return Utils._execute(collection, value, data);\\n    }\\n\\n    /// @notice Allows operators to lock/unlock the token.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token id.\\n    /// @param isLocked Boolean represents lock/unlock.\\n    function setLockedERC721Token(\\n        address collection,\\n        uint256 tokenId,\\n        bool isLocked\\n    ) public {\\n        ERC721Locker storage locker = _getLocker();\\n        require(locker.tokens[collection][tokenId] != isLocked, \\\"Token already in given state.\\\");\\n\\n        locker.tokens[collection][tokenId] = isLocked;\\n        if (isLocked) {\\n            ++locker.count[collection];\\n        } else {\\n            --locker.count[collection];\\n        }\\n        emit SetLockedERC721Token(collection, tokenId, isLocked);\\n    }\\n\\n    /// @notice Allows operators to get the defaulted token.\\n    ///     Note: Can only transfer if token is locked.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @param to Receiver address.\\n    function transferDefaultedERC721(\\n        address collection,\\n        uint256 tokenId,\\n        address to\\n    ) external returns (bytes memory) {\\n        require(checkIsLocked(collection, tokenId), \\\"Cannot perform this action on non-locked token.\\\");\\n        setLockedERC721Token(collection, tokenId, false);\\n\\n        bytes memory data = abi.encodeWithSelector(ERC721_SAFE_TRANSFER_FROM, address(this), to, tokenId);\\n        return Utils._execute(collection, 0, data);\\n    }\\n\\n    /// @notice Checks whether the token is locked or not.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @return isLocked Whether the token is locked or not.\\n    function checkIsLocked(address collection, uint256 tokenId) public view virtual returns (bool) {\\n        return _getLocker().tokens[collection][tokenId];\\n    }\\n\\n    /// @dev Returns the map of the locked tokens.\\n    /// @return result ERC721Locker struct of the locked tokens.\\n    ///     Note: Collection Address => Token ID => isLocked\\n    function _getLocker() internal pure returns (ERC721Locker storage result) {\\n        assembly {\\n            result.slot := LOCKER_SLOT\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IApeCoinStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title ApeCoin Staking Contract interface\\ninterface IApeCoinStaking {\\n    struct SingleNft {\\n        uint32 tokenId;\\n        uint224 amount;\\n    }\\n    struct PairNftDepositWithAmount {\\n        uint32 mainTokenId;\\n        uint32 bakcTokenId;\\n        uint184 amount;\\n    }\\n    struct PairNft {\\n        uint128 mainTokenId;\\n        uint128 bakcTokenId;\\n    }\\n    struct PairNftWithdrawWithAmount {\\n        uint32 mainTokenId;\\n        uint32 bakcTokenId;\\n        uint184 amount;\\n        bool isUncommit;\\n    }\\n\\n    struct Position {\\n        uint256 stakedAmount;\\n        int256 rewardsDebt;\\n    }\\n\\n    struct Pool {\\n        uint48 lastRewardedTimestampHour;\\n        uint16 lastRewardsRangeIndex;\\n        uint96 stakedAmount;\\n        uint96 accumulatedRewardsPerShare;\\n    }\\n\\n    struct TimeRange {\\n        uint48 startTimestampHour;\\n        uint48 endTimestampHour;\\n        uint96 rewardsPerHour;\\n        uint96 capPerPosition;\\n    }\\n\\n    struct PoolUI {\\n        uint256 poolId;\\n        uint256 stakedAmount;\\n        TimeRange currentTimeRange;\\n    }\\n\\n    struct PairingStatus {\\n        uint248 tokenId;\\n        bool isPaired;\\n    }\\n\\n    struct DashboardStake {\\n        uint256 poolId;\\n        uint256 tokenId;\\n        uint256 deposited;\\n        uint256 unclaimed;\\n        uint256 rewards24hr;\\n        DashboardPair pair;\\n    }\\n\\n    struct DashboardPair {\\n        uint256 mainTokenId;\\n        uint256 mainTypePoolId;\\n    }\\n\\n    function pools(uint256) external view returns (Pool memory);\\n\\n    function bakcToMain(uint256, uint256) external view returns (PairingStatus memory);\\n\\n    function nftPosition(uint256, uint256) external view returns (Position memory);\\n\\n    function getPoolsUI()\\n        external\\n        view\\n        returns (\\n            PoolUI memory,\\n            PoolUI memory,\\n            PoolUI memory,\\n            PoolUI memory\\n        );\\n\\n    function pendingRewards(\\n        uint256 _poolId,\\n        address _address,\\n        uint256 _tokenId\\n    ) external view returns (uint256);\\n\\n    function getApeCoinStake(address _address) external view returns (DashboardStake memory);\\n\\n    function getTimeRangeBy(uint256 _poolId, uint256 _index) external view returns (TimeRange memory);\\n\\n    function depositApeCoin(uint256 _amount, address _recipient) external;\\n\\n    function depositSelfApeCoin(uint256 _amount) external;\\n\\n    function depositBAYC(SingleNft[] calldata _nfts) external;\\n\\n    function depositMAYC(SingleNft[] calldata _nfts) external;\\n\\n    function depositBAKC(PairNftDepositWithAmount[] calldata _baycPairs, PairNftDepositWithAmount[] calldata _maycPairs)\\n        external;\\n\\n    function claimApeCoin(address _recipient) external;\\n\\n    function claimSelfApeCoin() external;\\n\\n    function claimBAYC(uint256[] calldata _nfts, address _recipient) external;\\n\\n    function claimSelfBAYC(uint256[] calldata _nfts) external;\\n\\n    function claimMAYC(uint256[] calldata _nfts, address _recipient) external;\\n\\n    function claimSelfMAYC(uint256[] calldata _nfts) external;\\n\\n    function claimBAKC(\\n        PairNft[] calldata _baycPairs,\\n        PairNft[] calldata _maycPairs,\\n        address _recipient\\n    ) external;\\n\\n    function claimSelfBAKC(PairNft[] calldata _baycPairs, PairNft[] calldata _maycPairs) external;\\n\\n    function withdrawApeCoin(uint256 _amount, address _recipient) external;\\n\\n    function withdrawSelfApeCoin(uint256 _amount) external;\\n\\n    function withdrawBAYC(SingleNft[] calldata _nfts, address _recipient) external;\\n\\n    function withdrawSelfBAYC(SingleNft[] calldata _nfts) external;\\n\\n    function withdrawMAYC(SingleNft[] calldata _nfts, address _recipient) external;\\n\\n    function withdrawSelfMAYC(SingleNft[] calldata _nfts) external;\\n\\n    function withdrawBAKC(\\n        PairNftWithdrawWithAmount[] calldata _baycPairs,\\n        PairNftWithdrawWithAmount[] calldata _maycPairs\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/CoreStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./managers/DelegateCallManager.sol\\\";\\nimport \\\"./managers/RoleManager.sol\\\";\\nimport \\\"./managers/ModuleManager.sol\\\";\\n\\n/// @title Cyan Wallet Core Storage - A Cyan wallet's core storage.\\n/// @dev This contract must be the very first parent of the Module contracts.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract CoreStorage is RoleManagerStorage, ModuleManagerStorage {\\n\\n}\\n\\n/// @title Cyan Wallet Core Storage - A Cyan wallet's core storage features.\\n/// @dev This contract must be the very first parent of the Core contract and Module contracts.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract ICoreStorage is DelegateCallManager, IRoleManager, IModuleManager {\\n    constructor(address admin) IRoleManager(admin) {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n    }\\n\\n    /// @inheritdoc IModuleManager\\n    function setModule(\\n        address target,\\n        bytes4 funcHash,\\n        address module\\n    ) external override noDelegateCall onlyAdmin {\\n        _modules[target][funcHash] = module;\\n        emit SetModule(target, funcHash, module);\\n    }\\n\\n    /// @inheritdoc IModuleManager\\n    function setInternalModule(bytes4 funcHash, address module) external override noDelegateCall onlyAdmin {\\n        _internalModules[funcHash] = module;\\n        emit SetInternalModule(funcHash, module);\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function getOwner() external view override onlyDelegateCall returns (address) {\\n        return _owner;\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function setAdmin(address admin) external override noDelegateCall onlyAdmin {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n        _admin = admin;\\n        emit SetAdmin(admin);\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function getAdmin() external view override noDelegateCall returns (address) {\\n        return _admin;\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function setOperator(uint8 index, address operator) external override noDelegateCall onlyAdmin {\\n        require(index < 3, \\\"Invalid operator index.\\\");\\n        require(operator != address(0x0), \\\"Invalid operator address.\\\");\\n        _operators[index] = operator;\\n        emit SetOperator(index, operator);\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function getOperators() external view override noDelegateCall returns (address[3] memory) {\\n        return _operators;\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function _checkOnlyAdmin() internal view override {\\n        if (address(this) != _this) {\\n            require(ICoreStorage(_this).getAdmin() == msg.sender, \\\"Caller is not an admin.\\\");\\n        } else {\\n            require(_admin == msg.sender, \\\"Caller is not an admin.\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function isOperator(address operator) external view override noDelegateCall returns (bool result) {\\n        assembly {\\n            result := or(\\n                or(eq(sload(_operators.slot), operator), eq(sload(add(_operators.slot, 0x1)), operator)),\\n                eq(sload(add(_operators.slot, 0x2)), operator)\\n            )\\n        }\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function _checkOnlyOperator() internal view override {\\n        require(ICoreStorage(_this).isOperator(msg.sender), \\\"Caller is not an operator.\\\");\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function _checkOnlyOwner() internal view override {\\n        require(_owner == msg.sender, \\\"Caller is not an owner.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Utils {\\n    /// @notice Executes a transaction to the given address.\\n    /// @param to Target address.\\n    /// @param value Native token value to be sent to the address.\\n    /// @param data Data to be sent to the address.\\n    /// @return Result of the transaciton.\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        assembly {\\n            let success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if eq(success, 0) {\\n                revert(0, returndatasize())\\n            }\\n            return(0, returndatasize())\\n        }\\n    }\\n\\n    /// @notice Recover signer address from signature.\\n    /// @param signedHash Arbitrary length data signed on the behalf of the wallet.\\n    /// @param signature Signature byte array associated with signedHash.\\n    /// @return Recovered signer address.\\n    function recoverSigner(bytes32 signedHash, bytes memory signature) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n        require(v == 27 || v == 28, \\\"Bad v value in signature.\\\");\\n\\n        address recoveredAddress = ecrecover(signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"ecrecover returned 0.\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /// @notice Helper method to parse the function selector from data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @return result Parsed function sighash.\\n    function parseFunctionSelector(bytes memory data) internal pure returns (bytes4 result) {\\n        require(data.length >= 4, \\\"Invalid data.\\\");\\n        assembly {\\n            result := mload(add(data, 0x20))\\n        }\\n    }\\n\\n    /// @notice Parse uint256 from given data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @param position Position in the data.\\n    /// @return result Uint256 parsed from given data.\\n    function getUint256At(bytes memory data, uint8 position) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mload(add(data, add(position, 0x20)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/managers/DelegateCallManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Manage the delegatecall to a contract\\n/// @notice Base contract that provides a modifier for managing delegatecall to methods in a child contract\\nabstract contract DelegateCallManager {\\n    /// @dev The address of this contract\\n    address payable internal immutable _this;\\n\\n    constructor() {\\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\\n        // In other words, this variable won't change when it's checked at runtime.\\n        _this = payable(address(this));\\n    }\\n\\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\\n    function _checkNotDelegateCall() private view {\\n        require(address(this) == _this, \\\"Only direct calls allowed.\\\");\\n    }\\n\\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\\n    function _checkOnlyDelegateCall() private view {\\n        require(address(this) != _this, \\\"Cannot be called directly.\\\");\\n    }\\n\\n    /// @notice Prevents delegatecall into the modified method\\n    modifier noDelegateCall() {\\n        _checkNotDelegateCall();\\n        _;\\n    }\\n\\n    /// @notice Prevents non delegatecall into the modified method\\n    modifier onlyDelegateCall() {\\n        _checkOnlyDelegateCall();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/managers/ModuleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"../modules/IModule.sol\\\";\\n\\n/// @title Cyan Wallet Module Manager Storage - A Cyan wallet's module manager's storage.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract ModuleManagerStorage {\\n    /// @notice Storing allowed contract methods.\\n    ///     Note: Target Contract Address => Sighash of method => Module address\\n    mapping(address => mapping(bytes4 => address)) internal _modules;\\n\\n    /// @notice Storing internally allowed module methods.\\n    ///     Note: Sighash of module method => Module address\\n    mapping(bytes4 => address) internal _internalModules;\\n}\\n\\n/// @title Cyan Wallet Module Manager - A Cyan wallet's module manager's functionalities.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IModuleManager is ModuleManagerStorage {\\n    event SetModule(address target, bytes4 funcHash, address module);\\n    event SetInternalModule(bytes4 funcHash, address module);\\n\\n    /// @notice Sets the handler module of the target's function.\\n    /// @param target Address of the target contract.\\n    /// @param funcHash Sighash of the target contract's method.\\n    /// @param module Address of the handler module.\\n    function setModule(\\n        address target,\\n        bytes4 funcHash,\\n        address module\\n    ) external virtual;\\n\\n    /// @notice Returns a handling module of the target function.\\n    /// @param target Address of the target contract.\\n    /// @param funcHash Sighash of the target contract's method.\\n    /// @return module Handler module.\\n    function getModule(address target, bytes4 funcHash) external view returns (address) {\\n        return _modules[target][funcHash];\\n    }\\n\\n    /// @notice Sets the internal handler module of the function.\\n    /// @param funcHash Sighash of the module method.\\n    /// @param module Address of the handler module.\\n    function setInternalModule(bytes4 funcHash, address module) external virtual;\\n\\n    /// @notice Returns an internal handling module of the given function.\\n    /// @param funcHash Sighash of the module's method.\\n    /// @return module Handler module.\\n    function getInternalModule(bytes4 funcHash) external view returns (address) {\\n        return _internalModules[funcHash];\\n    }\\n\\n    /// @notice Used to call module functions on the wallet.\\n    ///     Usually used to call locking function of the module on the wallet.\\n    /// @param data Data payload of the transaction.\\n    /// @return Result of the execution.\\n    function executeModule(bytes memory data) external virtual returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/managers/RoleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Cyan Wallet Role Manager - A Cyan wallet's role manager's storage.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract RoleManagerStorage {\\n    address[3] internal _operators;\\n    address internal _admin;\\n    address internal _owner;\\n}\\n\\n/// @title Cyan Wallet Role Manager - A Cyan wallet's role manager's functionalities.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IRoleManager is RoleManagerStorage {\\n    event SetOwner(address owner);\\n    event SetAdmin(address admin);\\n    event SetOperator(uint8 index, address operator);\\n\\n    modifier onlyOperator() {\\n        _checkOnlyOperator();\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        _checkOnlyAdmin();\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOnlyOwner();\\n        _;\\n    }\\n\\n    constructor(address admin) {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n        _admin = admin;\\n    }\\n\\n    /// @notice Returns current owner of the wallet.\\n    /// @return Address of the current owner.\\n    function getOwner() external view virtual returns (address);\\n\\n    /// @notice Changes the current admin.\\n    /// @param admin New admin address.\\n    function setAdmin(address admin) external virtual;\\n\\n    /// @notice Returns current admin of the core contract.\\n    /// @return Address of the current admin.\\n    function getAdmin() external view virtual returns (address);\\n\\n    /// @notice Sets the operator in the given index.\\n    /// @param index Index of the operator.\\n    /// @param operator Operator address.\\n    function setOperator(uint8 index, address operator) external virtual;\\n\\n    /// @notice Returns an array of operators.\\n    /// @return An array of the operator addresses.\\n    function getOperators() external view virtual returns (address[3] memory);\\n\\n    /// @notice Checks whether the given address is an operator.\\n    /// @param operator Address that will be checked.\\n    /// @return result Boolean result.\\n    function isOperator(address operator) external view virtual returns (bool result);\\n\\n    /// @notice Checks whether the message sender is an operator.\\n    function _checkOnlyOperator() internal view virtual;\\n\\n    /// @notice Checks whether the message sender is an admin.\\n    function _checkOnlyAdmin() internal view virtual;\\n\\n    /// @notice Checks whether the message sender is an owner.\\n    function _checkOnlyOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IModule {\\n    /// @notice Executes given transaction data to given address.\\n    /// @param to Target contract address.\\n    /// @param value Value of the given transaction.\\n    /// @param data Calldata of the transaction.\\n    /// @return Result of the execution.\\n    function handleTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInLockState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPaired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIsLocked\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lockStatus\",\"type\":\"uint8\"}],\"name\":\"SetLockedApeNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"SetLockedERC721Token\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APE_LOCKER_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BAKC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BAKC_POOL_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BAYC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BAYC_POOL_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK_BIT_INDEX_0\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK_BIT_INDEX_1\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAYC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAYC_POOL_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apeCoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apePool\",\"outputs\":[{\"internalType\":\"contract IApeCoinStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"autoCompound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mainCollection\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mainTokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"bakcTokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"}],\"name\":\"depositBAKCAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"}],\"name\":\"depositBAYCAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"}],\"name\":\"depositMAYCAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"handleTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"setLockedERC721Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferDefaultedERC721\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"withdrawBAKCAndUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"withdrawBAYCAndUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"withdrawMAYCAndUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "YugaModule", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}