// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

import "solmate/src/tokens/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

enum GraduationTiers {
    OG,
    HONORS,
    ENGINEERS,
    FOUNDERS
}

contract MacroGraduateSBT is ERC721, Ownable {
    /// @notice baseURI where the SBT metadata is located
    string public baseTokenURI;

    /// @notice the Merkle root used to prove inclusion in the MerkleDrop
    bytes32 public root; // merkle root

    /// @param _baseURI the URI which returns the SBT metadata
    /// @param _root the new merkle root
    /// @param _owner the address of the admin of the contract
    constructor(
        string memory _baseURI,
        bytes32 _root,
        address _owner
    ) ERC721("Macro Graduate Soulbound Token", "MGSBT") {
        baseTokenURI = _baseURI;
        emit BaseURISet(_baseURI);
        root = _root;
        emit MerkleRootSet(_root);
        transferOwnership(_owner);
    }

    /// @notice Emitted when the locking status is changed to locked.
    /// @dev If a token is minted and the status is locked, this event should be emitted.
    /// @param tokenId The identifier for a token
    event Locked(uint256 tokenId);

    /// @notice Emitted when the setMerkleRoot function is called successfully
    /// @param root The new merkle root
    event MerkleRootSet(bytes32 root);

    /// @notice Emitted when the setBaseURI function is called successfully
    /// @param baseURI The new baseTokenURI
    event BaseURISet(string baseURI);

    /// @notice Function for graduate to claim their SBT
    /// @dev The tokenId contains the graduate's address, cohort number, and graduation tier
    /// @dev Replay mint attacks are prevented because a given graduate's tokenId will always be the same, and duplicate tokenIds cannot be minted
    /// @param to address they would like to soul bound the token to
    /// @param cohortNumber the cohort (block) number that a given graduate graduated in
    /// @param graduationTier enum representing how well an graduate did in the fellowship
    /// @param proof merkle proof to be generated by frontend tool
    function mint(
        address to,
        uint16 cohortNumber,
        GraduationTiers graduationTier,
        bytes32[] calldata proof
    ) external {
        require(
            _verify(_leaf(msg.sender, cohortNumber, graduationTier), proof),
            "INVALID_PROOF"
        );
        _create(msg.sender, cohortNumber, graduationTier, to);
    }

    /// @notice Function for admin to gift NFTs to graduates
    /// @dev all arrays must be of the same length and the indexes of each array correspond to the same graduate data across each array
    /// @param addresses array of graduate addresses which will receive tokens
    /// @param cohortNumbers and array of cohort (block) numbers that a given graduate graduated in
    /// @param gradTiers array of enums representing how well a graduate did in the fellowship
    function batchAirdrop(
        address[] calldata addresses,
        uint16[] calldata cohortNumbers,
        GraduationTiers[] calldata gradTiers
    ) external onlyOwner {
        uint256 length = addresses.length;
        require(
            length > 0 &&
                length == cohortNumbers.length &&
                length == gradTiers.length,
            "INCONSISTENT_LENGTH"
        );
        unchecked {
            for (uint256 i; i < length; ++i) {
                address currentAddress = addresses[i];
                _create(
                    currentAddress,
                    cohortNumbers[i],
                    gradTiers[i],
                    currentAddress
                );
            }
        }
    }

    /// @dev private function to abstract duplicate logic in mint and batchAirdrop
    /// @param claimerAddress address within the merkle tree or batch airdrop "addresses" array
    /// @param cohortNumber the cohort (block) number that a given graduate graduated in
    /// @param gradTier enum representing how well an graduate did in the fellowship
    /// @param to address receiving the token
    function _create(
        address claimerAddress,
        uint16 cohortNumber,
        GraduationTiers gradTier,
        address to
    ) private {
        uint256 tokenId = (uint256(uint160(claimerAddress)) << uint256(24)) +
            (uint256(cohortNumber) << uint256(8)) +
            uint256(uint8(gradTier));
        _safeMint(to, tokenId);
        emit Locked(tokenId);
    }

    /// @notice burn deletes the token from the ERC721 implementation
    /// @dev burn will be used to update graduate data or "transfer" tokens to new address by burning and minting a new SBT
    /// @param tokenId tokenId which will be burned
    function burn(uint256 tokenId) external onlyOwner {
        _burn(tokenId);
    }

    /// @dev will always revert - if tokens need to be transfered, an admin must burn and then mint a new one.
    function transferFrom(
        address from,
        address to,
        uint256 id
    ) public override {
        revert("NON_TRANSFERABLE");
    }

    /// @dev will always revert - if tokens need to be transfered, an admin must burn and then mint a new one.
    function approve(address spender, uint256 id) public override {
        revert("NON_TRANSFERABLE");
    }

    /// @dev will always revert - if tokens need to be transfered, an admin must burn and then mint a new one.
    function setApprovalForAll(address operator, bool approved)
        public
        override
    {
        revert("NON_TRANSFERABLE");
    }

    /// @notice view function that returns the cohort number for a given tokenId
    /// @param tokenId the token id requested
    function cohortNumber(uint256 tokenId) external view returns (uint16) {
        ownerOf(tokenId);
        return uint16(tokenId >> uint256(8));
    }

    /// @notice view function that returns the graduation tier for a given tokenId
    /// @param tokenId the token id requested
    function graduationTier(uint256 tokenId) external view returns (uint16) {
        ownerOf(tokenId);
        return uint8(tokenId);
    }

    /// @dev returns the location of the asset corresponding to a specific token id
    /// @param id the token id for the asset being requested
    function tokenURI(uint256 id) public view override returns (string memory) {
        ownerOf(id); // ownerOf will revert if the token does not exist
          return string.concat(baseTokenURI, Strings.toString(id), ".json");
    }

    /// @dev updates the base uri in storage where the assets for the colleciton are held
    /// @param _baseURI the URI which returns the NFT metadata
    function setBaseURI(string calldata _baseURI) external onlyOwner {
        baseTokenURI = _baseURI;
        emit BaseURISet(_baseURI);
    }

    /// @notice this function will need to be called at the end of every cohort to enable new grads to claim their tokens
    /// @param _root the new merkle root
    function setMerkleRoot(bytes32 _root) external onlyOwner {
        root = _root;
        emit MerkleRootSet(_root);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        pure
        override
        returns (bool)
    {
        return
            interfaceId == 0xb45a3c0e || // ERC165 Interface ID for ERC5192
            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
    }

    /// @notice Returns the locking status of an Soulbound Token
    /// @dev SBTs assigned to zero address are considered invalid, and queries
    /// about them do throw.
    /// @param tokenId The identifier for an SBT.
    function locked(uint256 tokenId) external view returns (bool) {
        ownerOf(tokenId);
        return true;
    }

    /// @dev this function returns the hash of graduate data, also known as a leaf in our merkle tree
    /// @param account the graduate's address (is msg.sender)
    /// @param cohortNumber the cohort (block) number that a given graduate graduated in
    /// @param graduationTier enum representing how well an graduate did in the fellowship
    function _leaf(
        address account,
        uint16 cohortNumber,
        GraduationTiers graduationTier
    ) internal pure returns (bytes32) {
        return
            keccak256(abi.encodePacked(account, cohortNumber, graduationTier));
    }

    /// @dev this function verifies if the leaf is found in the merkle tree
    /// @param leaf a hash of all the graduate's data
    /// @param proof a valid merkle proof. a merkle proof consists of the values to hash together with the value being proved to get back the Merkle root
    function _verify(bytes32 leaf, bytes32[] memory proof)
        internal
        view
        returns (bool)
    {
        return MerkleProof.verify(proof, root, leaf);
    }
}