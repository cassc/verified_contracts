{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/NodeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IERC20, SafeERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {UUPSUpgradeable} from \\\"openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {OwnableUpgradeable} from \\\"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\\\";\\nimport {INodeRegistry, ISignatureUtils} from \\\"./interfaces/INodeRegistry.sol\\\";\\nimport {INodeRegistryOwner} from \\\"./interfaces/INodeRegistryOwner.sol\\\";\\nimport {IController} from \\\"./interfaces/IController.sol\\\";\\nimport {INodeStaking} from \\\"Staking-v0.1/interfaces/INodeStaking.sol\\\";\\nimport {IServiceManager} from \\\"./interfaces/IServiceManager.sol\\\";\\nimport {BLS} from \\\"./libraries/BLS.sol\\\";\\nimport {IERC1271} from \\\"openzeppelin-contracts/contracts/interfaces/IERC1271.sol\\\";\\nimport {Address} from \\\"openzeppelin-contracts/contracts/utils/Address.sol\\\";\\nimport {ECDSA} from \\\"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\ncontract NodeRegistry is UUPSUpgradeable, INodeRegistry, INodeRegistryOwner, OwnableUpgradeable {\\n    using SafeERC20 for IERC20;\\n\\n    // *Constants*\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n    /// @notice The EIP-712 typehash for the `Registration` struct used by the contract\\n    bytes32 public constant NATIVE_NODE_REGISTRATION_TYPEHASH =\\n        keccak256(\\\"NativeNodeRegistration(address assetAccountAddress,bytes32 salt,uint256 expiry)\\\");\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant _EIP1271_MAGICVALUE = 0x1626ba7e;\\n    uint16 private constant _BALANCE_BASE = 1;\\n\\n    // *NodeRegistry Config*\\n    NodeRegistryConfig private _config;\\n    IERC20 private _arpa;\\n\\n    // *Node State Variables*\\n    mapping(address => Node) private _nodes; // maps node address to Node Struct\\n    mapping(address => uint256) private _withdrawableEths; // maps node address to withdrawable eth amount\\n    mapping(address => uint256) private _arpaRewards; // maps node address to arpa rewards\\n    mapping(address => address) private _assetAccountsToNodes; // maps asset account address to node address\\n    mapping(address => address) private _nodesToAssetAccounts; // maps node address to asset account address\\n    mapping(address => mapping(bytes32 => bool)) private _assetAccountSaltIsSpent; // maps asset account address to salt\\n\\n    // *Events*\\n    event NodeRegistered(address indexed nodeAddress, bytes dkgPublicKey, uint256 groupIndex);\\n    event NodeActivated(address indexed nodeAddress, uint256 groupIndex);\\n    event NodeQuit(address indexed nodeAddress);\\n    event DkgPublicKeyChanged(address indexed nodeAddress, bytes dkgPublicKey);\\n    event NodeRewarded(address indexed nodeAddress, uint256 ethAmount, uint256 arpaAmount);\\n    event NodeSlashed(address indexed nodeIdAddress, uint256 stakingRewardPenalty, uint256 pendingBlock);\\n    event AssetAccountSet(address indexed assetAccountAddress, address indexed nodeAddress);\\n\\n    // *Errors*\\n    error NodeNotRegistered();\\n    error NodeAlreadyRegistered();\\n    error NodeAlreadyActive();\\n    error NodeStillPending(uint256 pendingUntilBlock);\\n    error SenderNotController();\\n    error InvalidZeroAddress();\\n    error OperatorUnderStaking();\\n    error EIP1271SignatureVerificationFailed();\\n    error EIP1271SignatureNotFromSigner();\\n    error EIP1271SignatureExpired();\\n    error EIP1271SignatureSaltAlreadySpent();\\n    error InvalidArrayLength();\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    function initialize(address arpa) public override(INodeRegistryOwner) initializer {\\n        _arpa = IERC20(arpa);\\n\\n        __Ownable_init();\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function _authorizeUpgrade(address) internal override onlyOwner {}\\n\\n    function setNodeRegistryConfig(\\n        address controllerContractAddress,\\n        address stakingContractAddress,\\n        address serviceManagerContractAddress,\\n        uint256 nativeNodeStakingAmount,\\n        uint256 eigenlayerNodeStakingAmount,\\n        uint256 pendingBlockAfterQuit\\n    ) external override(INodeRegistryOwner) onlyOwner {\\n        _config = NodeRegistryConfig(\\n            controllerContractAddress,\\n            stakingContractAddress,\\n            serviceManagerContractAddress,\\n            nativeNodeStakingAmount,\\n            eigenlayerNodeStakingAmount,\\n            pendingBlockAfterQuit\\n        );\\n    }\\n\\n    function dismissNode(address nodeIdAddress, uint256 pendingBlock) external override(INodeRegistryOwner) onlyOwner {\\n        _nodeQuitHelper(nodeIdAddress, pendingBlock);\\n    }\\n\\n    function setAssetAccount(address[] calldata assetAccountAddresses, address[] calldata nodeAddresses)\\n        external\\n        override(INodeRegistryOwner)\\n        onlyOwner\\n    {\\n        if (assetAccountAddresses.length != nodeAddresses.length) {\\n            revert InvalidArrayLength();\\n        }\\n        for (uint256 i = 0; i < assetAccountAddresses.length; i++) {\\n            _assetAccountsToNodes[assetAccountAddresses[i]] = nodeAddresses[i];\\n            _nodesToAssetAccounts[nodeAddresses[i]] = assetAccountAddresses[i];\\n            emit AssetAccountSet(assetAccountAddresses[i], nodeAddresses[i]);\\n        }\\n    }\\n\\n    // =============\\n    // INodeRegistry\\n    // =============\\n    function nodeRegister(\\n        bytes calldata dkgPublicKey,\\n        bool isEigenlayerNode,\\n        address assetAccountAddress,\\n        ISignatureUtils.SignatureWithSaltAndExpiry memory assetAccountSignature\\n    ) external override(INodeRegistry) {\\n        if (_assetAccountsToNodes[assetAccountAddress] != address(0)) {\\n            revert NodeAlreadyRegistered();\\n        }\\n\\n        _nodeRegister(dkgPublicKey, isEigenlayerNode);\\n\\n        _assetAccountsToNodes[assetAccountAddress] = msg.sender;\\n        _nodesToAssetAccounts[msg.sender] = assetAccountAddress;\\n\\n        if (isEigenlayerNode) {\\n            uint256 share = IServiceManager(_config.serviceManagerContractAddress).getOperatorShare(assetAccountAddress);\\n            if (share < _config.eigenlayerNodeStakingAmount) {\\n                revert OperatorUnderStaking();\\n            }\\n            IServiceManager(_config.serviceManagerContractAddress).registerOperator(\\n                assetAccountAddress, assetAccountSignature\\n            );\\n        } else {\\n            if (msg.sender != assetAccountAddress) {\\n                _checkEIP1271SignatureWithSaltAndExpiry(assetAccountAddress, assetAccountSignature);\\n            }\\n            // Lock staking amount in Staking contract\\n            INodeStaking(_config.stakingContractAddress).lock(assetAccountAddress, _config.nativeNodeStakingAmount);\\n        }\\n\\n        emit AssetAccountSet(assetAccountAddress, msg.sender);\\n    }\\n\\n    function nodeActivate(ISignatureUtils.SignatureWithSaltAndExpiry memory assetAccountSignature)\\n        external\\n        override(INodeRegistry)\\n    {\\n        Node storage node = _nodes[msg.sender];\\n        if (node.idAddress != msg.sender) {\\n            revert NodeNotRegistered();\\n        }\\n\\n        if (node.state) {\\n            revert NodeAlreadyActive();\\n        }\\n\\n        if (node.pendingUntilBlock > block.number) {\\n            revert NodeStillPending(node.pendingUntilBlock);\\n        }\\n\\n        node.state = true;\\n\\n        uint256 groupIndex = IController(_config.controllerContractAddress).nodeJoin(msg.sender);\\n\\n        emit NodeActivated(msg.sender, groupIndex);\\n\\n        address assetAccountAddress = _nodesToAssetAccounts[msg.sender];\\n\\n        if (node.isEigenlayerNode) {\\n            uint256 share = IServiceManager(_config.serviceManagerContractAddress).getOperatorShare(assetAccountAddress);\\n            if (share < _config.eigenlayerNodeStakingAmount) {\\n                revert OperatorUnderStaking();\\n            }\\n            IServiceManager(_config.serviceManagerContractAddress).registerOperator(\\n                assetAccountAddress, assetAccountSignature\\n            );\\n        } else {\\n            if (msg.sender != assetAccountAddress) {\\n                _checkEIP1271SignatureWithSaltAndExpiry(assetAccountAddress, assetAccountSignature);\\n            }\\n            // lock up to staking amount in Staking contract\\n            uint256 lockedAmount = INodeStaking(_config.stakingContractAddress).getLockedAmount(assetAccountAddress);\\n            if (lockedAmount < _config.nativeNodeStakingAmount) {\\n                INodeStaking(_config.stakingContractAddress).lock(\\n                    assetAccountAddress, _config.nativeNodeStakingAmount - lockedAmount\\n                );\\n            }\\n        }\\n    }\\n\\n    function nodeQuit() external override(INodeRegistry) {\\n        _nodeQuitHelper(msg.sender, _config.pendingBlockAfterQuit);\\n    }\\n\\n    function nodeLogOff() external override(INodeRegistry) {\\n        address nodeAccountAddress = _assetAccountsToNodes[msg.sender];\\n        if (nodeAccountAddress == address(0)) {\\n            revert NodeNotRegistered();\\n        }\\n        if (_nodes[nodeAccountAddress].state) {\\n            revert NodeAlreadyActive();\\n        }\\n        delete _assetAccountsToNodes[msg.sender];\\n        delete _nodesToAssetAccounts[nodeAccountAddress];\\n\\n        emit AssetAccountSet(msg.sender, address(0));\\n    }\\n\\n    function changeDkgPublicKey(bytes calldata dkgPublicKey) external override(INodeRegistry) {\\n        Node storage node = _nodes[msg.sender];\\n        if (node.idAddress != msg.sender) {\\n            revert NodeNotRegistered();\\n        }\\n\\n        if (node.state) {\\n            revert NodeAlreadyActive();\\n        }\\n\\n        uint256[4] memory publicKey = BLS.fromBytesPublicKey(dkgPublicKey);\\n        if (!BLS.isValidPublicKey(publicKey)) {\\n            revert BLS.InvalidPublicKey();\\n        }\\n\\n        node.dkgPublicKey = dkgPublicKey;\\n\\n        emit DkgPublicKeyChanged(msg.sender, dkgPublicKey);\\n    }\\n\\n    function nodeWithdraw(address recipient) external override(INodeRegistry) {\\n        if (recipient == address(0)) {\\n            revert InvalidZeroAddress();\\n        }\\n        uint256 ethAmount = _withdrawableEths[msg.sender];\\n        uint256 arpaAmount = _arpaRewards[msg.sender];\\n        if (arpaAmount > _BALANCE_BASE) {\\n            _arpaRewards[msg.sender] = _BALANCE_BASE;\\n            _arpa.safeTransfer(recipient, arpaAmount - _BALANCE_BASE);\\n        }\\n        if (ethAmount > _BALANCE_BASE) {\\n            _withdrawableEths[msg.sender] = _BALANCE_BASE;\\n            IController(_config.controllerContractAddress).nodeWithdrawETH(recipient, ethAmount - _BALANCE_BASE);\\n        }\\n    }\\n\\n    function addReward(address[] memory nodes, uint256 ethAmount, uint256 arpaAmount) public override(INodeRegistry) {\\n        if (msg.sender != _config.controllerContractAddress) {\\n            revert SenderNotController();\\n        }\\n\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            _withdrawableEths[nodes[i]] += ethAmount;\\n            _arpaRewards[nodes[i]] += arpaAmount;\\n            emit NodeRewarded(nodes[i], ethAmount, arpaAmount);\\n        }\\n    }\\n\\n    // Give node staking reward penalty and freezeNode\\n    function slashNode(address nodeIdAddress, uint256 stakingRewardPenalty, uint256 pendingBlock)\\n        public\\n        override(INodeRegistry)\\n    {\\n        if (msg.sender != _config.controllerContractAddress) {\\n            revert SenderNotController();\\n        }\\n\\n        Node storage node = _nodes[nodeIdAddress];\\n\\n        address assetAccountAddress = _nodesToAssetAccounts[nodeIdAddress];\\n\\n        if (node.isEigenlayerNode) {\\n            IServiceManager(_config.serviceManagerContractAddress).slashDelegationStaking(\\n                assetAccountAddress, stakingRewardPenalty\\n            );\\n            IServiceManager(_config.serviceManagerContractAddress).deregisterOperator(assetAccountAddress);\\n        } else {\\n            // slash staking reward in Staking contract\\n            INodeStaking(_config.stakingContractAddress).slashDelegationReward(\\n                assetAccountAddress, stakingRewardPenalty\\n            );\\n        }\\n\\n        _freezeNode(nodeIdAddress, pendingBlock);\\n\\n        emit NodeSlashed(nodeIdAddress, stakingRewardPenalty, pendingBlock);\\n    }\\n\\n    // =============\\n    // View\\n    // =============\\n    function getDKGPublicKey(address nodeAddress) public view override(INodeRegistry) returns (bytes memory) {\\n        return _nodes[nodeAddress].dkgPublicKey;\\n    }\\n\\n    function getNode(address nodeAddress) public view override(INodeRegistry) returns (Node memory) {\\n        return _nodes[nodeAddress];\\n    }\\n\\n    function getNodeWithdrawableTokens(address nodeAddress)\\n        public\\n        view\\n        override(INodeRegistry)\\n        returns (uint256, uint256)\\n    {\\n        return (\\n            _withdrawableEths[nodeAddress] == 0 ? 0 : (_withdrawableEths[nodeAddress] - _BALANCE_BASE),\\n            _arpaRewards[nodeAddress] == 0 ? 0 : (_arpaRewards[nodeAddress] - _BALANCE_BASE)\\n        );\\n    }\\n\\n    function getNodeRegistryConfig()\\n        public\\n        view\\n        override(INodeRegistry)\\n        returns (\\n            address controllerContractAddress,\\n            address stakingContractAddress,\\n            address serviceManagerContractAddress,\\n            uint256 nativeNodeStakingAmount,\\n            uint256 eigenlayerNodeStakingAmount,\\n            uint256 pendingBlockAfterQuit\\n        )\\n    {\\n        return (\\n            _config.controllerContractAddress,\\n            _config.stakingContractAddress,\\n            _config.serviceManagerContractAddress,\\n            _config.nativeNodeStakingAmount,\\n            _config.eigenlayerNodeStakingAmount,\\n            _config.pendingBlockAfterQuit\\n        );\\n    }\\n\\n    function getNodeAddressByAssetAccountAddress(address assetAccountAddress)\\n        public\\n        view\\n        override(INodeRegistry)\\n        returns (address)\\n    {\\n        return _assetAccountsToNodes[assetAccountAddress];\\n    }\\n\\n    function getAssetAccountAddressByNodeAddress(address nodeAddress)\\n        public\\n        view\\n        override(INodeRegistry)\\n        returns (address)\\n    {\\n        return _nodesToAssetAccounts[nodeAddress];\\n    }\\n\\n    /**\\n     * @notice Calculates the digest hash to be signed as a native node\\n     * @param assetAccountAddress The asset account address of the staking node\\n     * @param salt A unique and single use value associated with the approver signature.\\n     * @param expiry Time after which the approver's signature becomes invalid\\n     */\\n    function calculateNativeNodeRegistrationDigestHash(address assetAccountAddress, bytes32 salt, uint256 expiry)\\n        public\\n        view\\n        override(INodeRegistry)\\n        returns (bytes32)\\n    {\\n        // calculate the struct hash\\n        bytes32 structHash = keccak256(abi.encode(NATIVE_NODE_REGISTRATION_TYPEHASH, assetAccountAddress, salt, expiry));\\n        // calculate the digest hash\\n        bytes32 digestHash = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator(), structHash));\\n        return digestHash;\\n    }\\n\\n    /**\\n     * @notice Getter function for the current EIP-712 domain separator for this contract.\\n     */\\n    function domainSeparator() public view override(INodeRegistry) returns (bytes32) {\\n        return keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"ARPANetwork\\\")), block.chainid, address(this)));\\n    }\\n\\n    function assetAccountSaltIsSpent(address assetAccountAddress, bytes32 salt)\\n        public\\n        view\\n        override(INodeRegistry)\\n        returns (bool)\\n    {\\n        return _assetAccountSaltIsSpent[assetAccountAddress][salt];\\n    }\\n\\n    // =============\\n    // Internal\\n    // =============\\n    function _nodeRegister(bytes calldata dkgPublicKey, bool isEigenlayerNode) internal {\\n        if (_nodes[msg.sender].idAddress != address(0)) {\\n            revert NodeAlreadyRegistered();\\n        }\\n\\n        uint256[4] memory publicKey = BLS.fromBytesPublicKey(dkgPublicKey);\\n        if (!BLS.isValidPublicKey(publicKey)) {\\n            revert BLS.InvalidPublicKey();\\n        }\\n\\n        // Populate Node struct and insert into nodes\\n        Node storage n = _nodes[msg.sender];\\n        n.idAddress = msg.sender;\\n        n.dkgPublicKey = dkgPublicKey;\\n        n.state = true;\\n        n.isEigenlayerNode = isEigenlayerNode;\\n\\n        // Initialize withdrawable eths and arpa rewards to save gas for adapter call\\n        _withdrawableEths[msg.sender] = _BALANCE_BASE;\\n        _arpaRewards[msg.sender] = _BALANCE_BASE;\\n\\n        uint256 groupIndex = IController(_config.controllerContractAddress).nodeJoin(msg.sender);\\n\\n        emit NodeRegistered(msg.sender, dkgPublicKey, groupIndex);\\n    }\\n\\n    function _freezeNode(address nodeIdAddress, uint256 pendingBlock) internal {\\n        // set node state to false for frozen node\\n        _nodes[nodeIdAddress].state = false;\\n\\n        uint256 currentBlock = block.number;\\n        // if the node is already pending, add the pending block to the current pending block\\n        if (_nodes[nodeIdAddress].pendingUntilBlock > currentBlock) {\\n            _nodes[nodeIdAddress].pendingUntilBlock += pendingBlock;\\n            // else set the pending block to the current block + pending block\\n        } else {\\n            _nodes[nodeIdAddress].pendingUntilBlock = currentBlock + pendingBlock;\\n        }\\n    }\\n\\n    function _nodeQuitHelper(address nodeIdAddress, uint256 pendingBlock) internal {\\n        Node storage node = _nodes[nodeIdAddress];\\n\\n        if (node.idAddress != nodeIdAddress) {\\n            revert NodeNotRegistered();\\n        }\\n\\n        IController(_config.controllerContractAddress).nodeLeave(nodeIdAddress);\\n\\n        _freezeNode(nodeIdAddress, pendingBlock);\\n\\n        address assetAccountAddress = _nodesToAssetAccounts[nodeIdAddress];\\n\\n        if (node.isEigenlayerNode) {\\n            IServiceManager(_config.serviceManagerContractAddress).deregisterOperator(assetAccountAddress);\\n        } else {\\n            // unlock staking amount in Staking contract\\n            INodeStaking(_config.stakingContractAddress).unlock(assetAccountAddress, _config.nativeNodeStakingAmount);\\n        }\\n\\n        emit NodeQuit(nodeIdAddress);\\n    }\\n\\n    function _checkEIP1271SignatureWithSaltAndExpiry(\\n        address assetAccountAddress,\\n        ISignatureUtils.SignatureWithSaltAndExpiry memory assetAccountSignature\\n    ) internal {\\n        if (assetAccountSignature.expiry < block.timestamp) {\\n            revert EIP1271SignatureExpired();\\n        }\\n        if (_assetAccountSaltIsSpent[assetAccountAddress][assetAccountSignature.salt]) {\\n            revert EIP1271SignatureSaltAlreadySpent();\\n        }\\n        bytes32 nativeNodeRegistrationDigestHash = calculateNativeNodeRegistrationDigestHash(\\n            assetAccountAddress, assetAccountSignature.salt, assetAccountSignature.expiry\\n        );\\n        _checkEIP1271Signature(assetAccountAddress, nativeNodeRegistrationDigestHash, assetAccountSignature.signature);\\n        _assetAccountSaltIsSpent[assetAccountAddress][assetAccountSignature.salt] = true;\\n    }\\n\\n    /**\\n     * @notice Checks @param signature is a valid signature of @param digestHash from @param signer.\\n     * If the `signer` contains no code -- i.e. it is not (yet, at least) a contract address, then checks using standard ECDSA logic\\n     * Otherwise, passes on the signature to the signer to verify the signature and checks that it returns the `EIP1271_MAGICVALUE`.\\n     */\\n    function _checkEIP1271Signature(address signer, bytes32 digestHash, bytes memory signature) internal view {\\n        /**\\n         * check validity of signature:\\n         * 1) if `signer` is an EOA, then `signature` must be a valid ECDSA signature from `signer`,\\n         * indicating their intention for this action\\n         * 2) if `signer` is a contract, then `signature` must will be checked according to EIP-1271\\n         */\\n        if (Address.isContract(signer)) {\\n            if (IERC1271(signer).isValidSignature(digestHash, signature) != _EIP1271_MAGICVALUE) {\\n                revert EIP1271SignatureVerificationFailed();\\n            }\\n        } else {\\n            if (ECDSA.recover(digestHash, signature) != signer) {\\n                revert EIP1271SignatureNotFromSigner();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INodeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {ISignatureUtils} from \\\"./ISignatureUtils.sol\\\";\\n\\ninterface INodeRegistry {\\n    struct Node {\\n        address idAddress;\\n        bytes dkgPublicKey;\\n        bool isEigenlayerNode;\\n        bool state;\\n        uint256 pendingUntilBlock;\\n    }\\n\\n    struct NodeRegistryConfig {\\n        address controllerContractAddress;\\n        address stakingContractAddress;\\n        address serviceManagerContractAddress;\\n        uint256 nativeNodeStakingAmount;\\n        uint256 eigenlayerNodeStakingAmount;\\n        uint256 pendingBlockAfterQuit;\\n    }\\n\\n    // node transaction\\n    function nodeRegister(\\n        bytes calldata dkgPublicKey,\\n        bool isEigenlayerNode,\\n        address assetAccountAddress,\\n        ISignatureUtils.SignatureWithSaltAndExpiry memory assetAccountSignature\\n    ) external;\\n\\n    function nodeActivate(ISignatureUtils.SignatureWithSaltAndExpiry memory assetAccountSignature) external;\\n\\n    function nodeQuit() external;\\n\\n    function nodeLogOff() external;\\n\\n    function changeDkgPublicKey(bytes calldata dkgPublicKey) external;\\n\\n    function nodeWithdraw(address recipient) external;\\n\\n    // controller transaction\\n    function slashNode(address nodeIdAddress, uint256 stakingRewardPenalty, uint256 pendingBlock) external;\\n\\n    // adapter transaction\\n    function addReward(address[] memory nodes, uint256 ethAmount, uint256 arpaAmount) external;\\n\\n    // view\\n    function getDKGPublicKey(address nodeAddress) external view returns (bytes memory);\\n\\n    function getNode(address nodeAddress) external view returns (Node memory);\\n\\n    function getNodeWithdrawableTokens(address nodeAddress) external view returns (uint256, uint256);\\n\\n    function getNodeRegistryConfig()\\n        external\\n        view\\n        returns (\\n            address controllerContractAddress,\\n            address stakingContractAddress,\\n            address serviceManagerContractAddress,\\n            uint256 nativeNodeStakingAmount,\\n            uint256 eigenlayerNodeStakingAmount,\\n            uint256 pendingBlockAfterQuit\\n        );\\n\\n    function getNodeAddressByAssetAccountAddress(address assetAccountAddress) external view returns (address);\\n\\n    function getAssetAccountAddressByNodeAddress(address nodeAddress) external view returns (address);\\n\\n    function calculateNativeNodeRegistrationDigestHash(address assetAccountAddress, bytes32 salt, uint256 expiry)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    function domainSeparator() external view returns (bytes32);\\n\\n    function assetAccountSaltIsSpent(address assetAccountAddress, bytes32 salt) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INodeRegistryOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface INodeRegistryOwner {\\n    /**\\n     * @notice Sets the configuration of the NodeRegistry\\n     * @param controllerContract The address of the controller contract\\n     * @param stakingContract The address of the staking contract\\n     * @param serviceManagerContract The address of the service manager contract\\n     * @param nativeNodeStakingAmount The amount of ARPA must staked by a node\\n     * @param eigenlayerNodeStakingAmount The amount of token must restaked by an eigenlayer node\\n     * @param pendingBlockAfterQuit The number of blocks a node must wait before joining a group after quitting\\n     */\\n    function setNodeRegistryConfig(\\n        address controllerContract,\\n        address stakingContract,\\n        address serviceManagerContract,\\n        uint256 nativeNodeStakingAmount,\\n        uint256 eigenlayerNodeStakingAmount,\\n        uint256 pendingBlockAfterQuit\\n    ) external;\\n\\n    function initialize(address arpa) external;\\n\\n    /**\\n     * @notice Dismiss a node from the registry forcefully\\n     * @param nodeIdAddress The address of the node\\n     * @param pendingBlock The number of blocks the node must wait before activating again\\n     */\\n    function dismissNode(address nodeIdAddress, uint256 pendingBlock) external;\\n\\n    /**\\n     * @notice Set the asset account of the node\\n     * @param assetAccountAddresses The addresses of the asset accounts\\n     * @param nodeAddresses The addresses of the nodes\\n     */\\n    function setAssetAccount(address[] calldata assetAccountAddresses, address[] calldata nodeAddresses) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface IController {\\n    struct Group {\\n        uint256 index;\\n        uint256 epoch;\\n        uint256 size;\\n        uint256 threshold;\\n        Member[] members;\\n        address[] committers;\\n        CommitCache[] commitCacheList;\\n        bool isStrictlyMajorityConsensusReached;\\n        uint256[4] publicKey;\\n    }\\n\\n    struct Member {\\n        address nodeIdAddress;\\n        uint256[4] partialPublicKey;\\n    }\\n\\n    struct CommitResult {\\n        uint256 groupEpoch;\\n        uint256[4] publicKey;\\n        address[] disqualifiedNodes;\\n    }\\n\\n    struct CommitCache {\\n        address[] nodeIdAddress;\\n        CommitResult commitResult;\\n    }\\n\\n    struct CommitDkgParams {\\n        uint256 groupIndex;\\n        uint256 groupEpoch;\\n        bytes publicKey;\\n        bytes partialPublicKey;\\n        address[] disqualifiedNodes;\\n    }\\n\\n    // node transaction\\n    function nodeJoin(address nodeIdAddress) external returns (uint256 groupIndex);\\n\\n    function nodeLeave(address nodeIdAddress) external;\\n\\n    function commitDkg(CommitDkgParams memory params) external;\\n\\n    function postProcessDkg(uint256 groupIndex, uint256 groupEpoch) external;\\n\\n    // nodeRegistry transaction\\n    function nodeWithdrawETH(address recipient, uint256 ethAmount) external;\\n\\n    // adapter transaction\\n    function addReward(address[] memory nodes, uint256 ethAmount, uint256 arpaAmount) external;\\n\\n    function setLastOutput(uint256 lastOutput) external;\\n\\n    // view\\n    function getControllerConfig()\\n        external\\n        view\\n        returns (\\n            address nodeRegistryContractAddress,\\n            address adapterContractAddress,\\n            uint256 disqualifiedNodePenaltyAmount,\\n            uint256 defaultNumberOfCommitters,\\n            uint256 defaultDkgPhaseDuration,\\n            uint256 groupMaxCapacity,\\n            uint256 idealNumberOfGroups,\\n            uint256 dkgPostProcessReward\\n        );\\n\\n    /// @notice Get list of all group indexes where group.isStrictlyMajorityConsensusReached == true\\n    /// @return uint256[] List of valid group indexes\\n    function getValidGroupIndices() external view returns (uint256[] memory);\\n\\n    function getGroupEpoch() external view returns (uint256);\\n\\n    function getGroupCount() external view returns (uint256);\\n\\n    function getGroup(uint256 index) external view returns (Group memory);\\n\\n    function getGroupThreshold(uint256 groupIndex) external view returns (uint256, uint256);\\n\\n    function getMember(uint256 groupIndex, uint256 memberIndex) external view returns (Member memory);\\n\\n    /// @notice Get the group index and member index of a given node.\\n    function getBelongingGroup(address nodeAddress) external view returns (int256, int256);\\n\\n    function getCoordinator(uint256 groupIndex) external view returns (address);\\n\\n    function getLastOutput() external view returns (uint256);\\n\\n    /// @notice Check to see if a group has a partial public key registered for a given node.\\n    /// @return bool True if the node has a partial public key registered for the group.\\n    function isPartialKeyRegistered(uint256 groupIndex, address nodeIdAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/Staking-v0.1/src/interfaces/INodeStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface INodeStaking {\\n    /// @notice This event is emitted when a node locks stake in the pool.\\n    /// @param staker Staker address\\n    /// @param newLock New principal amount locked\\n    event Locked(address staker, uint256 newLock);\\n\\n    /// @notice This event is emitted when a node unlocks stake in the pool.\\n    /// @param staker Staker address\\n    /// @param newUnlock New principal amount unlocked\\n    event Unlocked(address staker, uint256 newUnlock);\\n\\n    /// @notice This event is emitted when a node gets delegation reward slashed.\\n    /// @param staker Staker address\\n    /// @param amount Amount slashed\\n    event DelegationRewardSlashed(address staker, uint256 amount);\\n\\n    /// @notice This error is raised when attempting to unlock with more than the current locked staking amount\\n    /// @param currentLockedStakingAmount Current locked staking amount\\n    error InadequateOperatorLockedStakingAmount(uint256 currentLockedStakingAmount);\\n\\n    /// @notice This function allows controller to lock staking amount for a node.\\n    /// @param staker Node address\\n    /// @param amount Amount to lock\\n    function lock(address staker, uint256 amount) external;\\n\\n    /// @notice This function allows controller to unlock staking amount for a node.\\n    /// @param staker Node address\\n    /// @param amount Amount to unlock\\n    function unlock(address staker, uint256 amount) external;\\n\\n    /// @notice This function allows controller to slash delegation reward of a node.\\n    /// @param staker Node address\\n    /// @param amount Amount to slash\\n    function slashDelegationReward(address staker, uint256 amount) external;\\n\\n    /// @notice This function returns the locked amount of a node.\\n    /// @param staker Node address\\n    function getLockedAmount(address staker) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IServiceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {ISignatureUtils} from \\\"./ISignatureUtils.sol\\\";\\n\\ninterface IServiceManager {\\n    function registerOperator(address operator, ISignatureUtils.SignatureWithSaltAndExpiry memory operatorSignature)\\n        external;\\n\\n    function deregisterOperator(address operator) external;\\n\\n    function slashDelegationStaking(address operator, uint256 amount) external;\\n\\n    function getOperatorShare(address operator) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/libraries/BLS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL 3.0\\npragma solidity ^0.8.18;\\n\\nimport {BN256G2} from \\\"./BN256G2.sol\\\";\\n\\n/**\\n * @title BLS operations on bn254 curve\\n * @author ARPA-Network adapted from https://github.com/ChihChengLiang/bls_solidity_python\\n * @dev Homepage: https://github.com/ARPA-Network/BLS-TSS-Network\\n *      Signature and Point hashed to G1 are represented by affine coordinate in big-endian order, deserialized from compressed format.\\n *      Public key is represented and serialized by affine coordinate Q-x-re(x0), Q-x-im(x1), Q-y-re(y0), Q-y-im(y1) in big-endian order.\\n */\\nlibrary BLS {\\n    // Field order\\n    uint256 public constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n    // Negated genarator of G2\\n    uint256 public constant N_G2_X1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\\n    uint256 public constant N_G2_X0 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\\n    uint256 public constant N_G2_Y1 = 17805874995975841540914202342111839520379459829704422454583296818431106115052;\\n    uint256 public constant N_G2_Y0 = 13392588948715843804641432497768002650278120570034223513918757245338268106653;\\n\\n    uint256 public constant FIELD_MASK = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    error MustNotBeInfinity();\\n    error InvalidPublicKeyEncoding();\\n    error InvalidSignatureFormat();\\n    error InvalidSignature();\\n    error InvalidPartialSignatureFormat();\\n    error InvalidPartialSignatures();\\n    error EmptyPartialSignatures();\\n    error InvalidPublicKey();\\n    error InvalidPartialPublicKey();\\n\\n    function verifySingle(uint256[2] memory signature, uint256[4] memory pubkey, uint256[2] memory message)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256[12] memory input = [\\n            signature[0],\\n            signature[1],\\n            N_G2_X1,\\n            N_G2_X0,\\n            N_G2_Y1,\\n            N_G2_Y0,\\n            message[0],\\n            message[1],\\n            pubkey[1],\\n            pubkey[0],\\n            pubkey[3],\\n            pubkey[2]\\n        ];\\n        uint256[1] memory out;\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 8, input, 384, out, 0x20)\\n            switch success\\n            case 0 { invalid() }\\n        }\\n        require(success, \\\"\\\");\\n        return out[0] != 0;\\n    }\\n\\n    function verifyPartials(uint256[2][] memory partials, uint256[4][] memory pubkeys, uint256[2] memory message)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256[2] memory aggregatedSignature;\\n        uint256[4] memory aggregatedPublicKey;\\n        for (uint256 i = 0; i < partials.length; i++) {\\n            aggregatedSignature = addPoints(aggregatedSignature, partials[i]);\\n            aggregatedPublicKey = BN256G2.ecTwistAdd(aggregatedPublicKey, pubkeys[i]);\\n        }\\n\\n        uint256[12] memory input = [\\n            aggregatedSignature[0],\\n            aggregatedSignature[1],\\n            N_G2_X1,\\n            N_G2_X0,\\n            N_G2_Y1,\\n            N_G2_Y0,\\n            message[0],\\n            message[1],\\n            aggregatedPublicKey[1],\\n            aggregatedPublicKey[0],\\n            aggregatedPublicKey[3],\\n            aggregatedPublicKey[2]\\n        ];\\n        uint256[1] memory out;\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 8, input, 384, out, 0x20)\\n            switch success\\n            case 0 { invalid() }\\n        }\\n        require(success, \\\"\\\");\\n        return out[0] != 0;\\n    }\\n\\n    // TODO a simple hash and increment implementation, can be improved later\\n    function hashToPoint(bytes memory data) public view returns (uint256[2] memory p) {\\n        bool found;\\n        bytes32 candidateHash = keccak256(data);\\n        while (true) {\\n            (p, found) = mapToPoint(candidateHash);\\n            if (found) {\\n                break;\\n            }\\n            candidateHash = keccak256(bytes.concat(candidateHash));\\n        }\\n    }\\n\\n    //  we take the y-coordinate as the lexicographically largest of the two associated with the encoded x-coordinate\\n    function mapToPoint(bytes32 _x) internal view returns (uint256[2] memory p, bool found) {\\n        uint256 y;\\n        uint256 x = uint256(_x) % N;\\n        (y, found) = deriveYOnG1(x);\\n        if (found) {\\n            p[0] = x;\\n            p[1] = y > N / 2 ? N - y : y;\\n        }\\n    }\\n\\n    function deriveYOnG1(uint256 x) internal view returns (uint256, bool) {\\n        uint256 y;\\n        y = mulmod(x, x, N);\\n        y = mulmod(y, x, N);\\n        y = addmod(y, 3, N);\\n        return sqrt(y);\\n    }\\n\\n    function isValidPublicKey(uint256[4] memory publicKey) public pure returns (bool) {\\n        if ((publicKey[0] >= N) || (publicKey[1] >= N) || (publicKey[2] >= N || (publicKey[3] >= N))) {\\n            return false;\\n        } else {\\n            return isOnCurveG2(publicKey);\\n        }\\n    }\\n\\n    function fromBytesPublicKey(bytes memory point) public pure returns (uint256[4] memory pubkey) {\\n        if (point.length != 128) {\\n            revert InvalidPublicKeyEncoding();\\n        }\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // look the first 32 bytes of a bytes struct is its length\\n            x0 := mload(add(point, 32))\\n            x1 := mload(add(point, 64))\\n            y0 := mload(add(point, 96))\\n            y1 := mload(add(point, 128))\\n        }\\n        pubkey = [x0, x1, y0, y1];\\n    }\\n\\n    function decompress(uint256 compressedSignature) public view returns (uint256[2] memory uncompressed) {\\n        uint256 x = compressedSignature & FIELD_MASK;\\n        // The most significant bit, when set, indicates that the y-coordinate of the point\\n        // is the lexicographically largest of the two associated values.\\n        // The second-most significant bit indicates that the point is at infinity. If this bit is set,\\n        // the remaining bits of the group element's encoding should be set to zero.\\n        // We don't accept infinity as valid signature.\\n        uint256 decision = compressedSignature >> 254;\\n        if (decision & 1 == 1) {\\n            revert MustNotBeInfinity();\\n        }\\n        uint256 y;\\n        (y,) = deriveYOnG1(x);\\n\\n        // If the following two conditions or their negative forms are not met at the same time, get the negative y.\\n        // 1. The most significant bit of compressed signature is set\\n        // 2. The y we recovered first is the lexicographically largest\\n        if (((decision >> 1) ^ (y > N / 2 ? 1 : 0)) == 1) {\\n            y = N - y;\\n        }\\n        return [x, y];\\n    }\\n\\n    function isValid(uint256 compressedSignature) public view returns (bool) {\\n        uint256 x = compressedSignature & FIELD_MASK;\\n        if (x >= N) {\\n            return false;\\n        } else if (x == 0) {\\n            return false;\\n        }\\n        return isOnCurveG1(x);\\n    }\\n\\n    function isOnCurveG1(uint256[2] memory point) internal pure returns (bool _isOnCurve) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let t0 := mload(point)\\n            let t1 := mload(add(point, 32))\\n            let t2 := mulmod(t0, t0, N)\\n            t2 := mulmod(t2, t0, N)\\n            t2 := addmod(t2, 3, N)\\n            t1 := mulmod(t1, t1, N)\\n            _isOnCurve := eq(t1, t2)\\n        }\\n    }\\n\\n    function isOnCurveG1(uint256 x) internal view returns (bool _isOnCurve) {\\n        bool callSuccess;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let t0 := x\\n            let t1 := mulmod(t0, t0, N)\\n            t1 := mulmod(t1, t0, N)\\n            // x ^ 3 + b\\n            t1 := addmod(t1, 3, N)\\n\\n            let freemem := mload(0x40)\\n            mstore(freemem, 0x20)\\n            mstore(add(freemem, 0x20), 0x20)\\n            mstore(add(freemem, 0x40), 0x20)\\n            mstore(add(freemem, 0x60), t1)\\n            // (N - 1) / 2 = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea3\\n            mstore(add(freemem, 0x80), 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea3)\\n            // N = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\\n            mstore(add(freemem, 0xA0), 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47)\\n            callSuccess := staticcall(sub(gas(), 2000), 5, freemem, 0xC0, freemem, 0x20)\\n            _isOnCurve := eq(1, mload(freemem))\\n        }\\n    }\\n\\n    function isOnCurveG2(uint256[4] memory point) internal pure returns (bool _isOnCurve) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // x0, x1\\n            let t0 := mload(point)\\n            let t1 := mload(add(point, 32))\\n            // x0 ^ 2\\n            let t2 := mulmod(t0, t0, N)\\n            // x1 ^ 2\\n            let t3 := mulmod(t1, t1, N)\\n            // 3 * x0 ^ 2\\n            let t4 := add(add(t2, t2), t2)\\n            // 3 * x1 ^ 2\\n            let t5 := addmod(add(t3, t3), t3, N)\\n            // x0 * (x0 ^ 2 - 3 * x1 ^ 2)\\n            t2 := mulmod(add(t2, sub(N, t5)), t0, N)\\n            // x1 * (3 * x0 ^ 2 - x1 ^ 2)\\n            t3 := mulmod(add(t4, sub(N, t3)), t1, N)\\n\\n            // x ^ 3 + b\\n            t0 := addmod(t2, 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5, N)\\n            t1 := addmod(t3, 0x009713b03af0fed4cd2cafadeed8fdf4a74fa084e52d1852e4a2bd0685c315d2, N)\\n\\n            // y0, y1\\n            t2 := mload(add(point, 64))\\n            t3 := mload(add(point, 96))\\n            // y ^ 2\\n            t4 := mulmod(addmod(t2, t3, N), addmod(t2, sub(N, t3), N), N)\\n            t3 := mulmod(shl(1, t2), t3, N)\\n\\n            // y ^ 2 == x ^ 3 + b\\n            _isOnCurve := and(eq(t0, t4), eq(t1, t3))\\n        }\\n    }\\n\\n    function sqrt(uint256 xx) internal view returns (uint256 x, bool hasRoot) {\\n        bool callSuccess;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freemem := mload(0x40)\\n            mstore(freemem, 0x20)\\n            mstore(add(freemem, 0x20), 0x20)\\n            mstore(add(freemem, 0x40), 0x20)\\n            mstore(add(freemem, 0x60), xx)\\n            // this is enabled by N % 4 = 3 and Fermat's little theorem\\n            // (N + 1) / 4 = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52\\n            mstore(add(freemem, 0x80), 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52)\\n            // N = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\\n            mstore(add(freemem, 0xA0), 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47)\\n            callSuccess := staticcall(sub(gas(), 2000), 5, freemem, 0xC0, freemem, 0x20)\\n            x := mload(freemem)\\n            hasRoot := eq(xx, mulmod(x, x, N))\\n        }\\n        require(callSuccess, \\\"BLS: sqrt modexp call failed\\\");\\n    }\\n\\n    /// @notice Add two points in G1\\n    function addPoints(uint256[2] memory p1, uint256[2] memory p2) internal view returns (uint256[2] memory ret) {\\n        uint256[4] memory input;\\n        input[0] = p1[0];\\n        input[1] = p1[1];\\n        input[2] = p2[0];\\n        input[3] = p2[1];\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, ret, 0x60)\\n        }\\n        // solhint-disable-next-line reason-string\\n        require(success);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISignatureUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title The interface for common signature utilities.\\n * @author Layr Labs, Inc.\\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\\n */\\ninterface ISignatureUtils {\\n    // @notice Struct that bundles together a signature and an expiration time for the signature. Used primarily for stack management.\\n    struct SignatureWithExpiry {\\n        // the signature itself, formatted as a single bytes object\\n        bytes signature;\\n        // the expiration timestamp (UTC) of the signature\\n        uint256 expiry;\\n    }\\n\\n    // @notice Struct that bundles together a signature, a salt for uniqueness, and an expiration time for the signature. Used primarily for stack management.\\n    struct SignatureWithSaltAndExpiry {\\n        // the signature itself, formatted as a single bytes object\\n        bytes signature;\\n        // the salt used to generate the signature\\n        bytes32 salt;\\n        // the expiration timestamp (UTC) of the signature\\n        uint256 expiry;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/BN256G2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL 3.0\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title Elliptic curve operations on twist points for alt_bn128\\n * @author ARPA-Network adapted from https://github.com/musalbas/solidity-BN256G2\\n * @dev Homepage: https://github.com/ARPA-Network/BLS-TSS-Network\\n */\\n\\nlibrary BN256G2 {\\n    uint256 public constant FIELD_MODULUS = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\\n    uint256 public constant TWISTBX = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\\n    uint256 public constant TWISTBY = 0x9713b03af0fed4cd2cafadeed8fdf4a74fa084e52d1852e4a2bd0685c315d2;\\n    uint256 public constant PTXX = 0;\\n    uint256 public constant PTXY = 1;\\n    uint256 public constant PTYX = 2;\\n    uint256 public constant PTYY = 3;\\n    uint256 public constant PTZX = 4;\\n    uint256 public constant PTZY = 5;\\n\\n    function ecTwistAdd(uint256[4] memory pt1, uint256[4] memory pt2) internal view returns (uint256[4] memory pt) {\\n        (uint256 xx, uint256 xy, uint256 yx, uint256 yy) =\\n            ecTwistAdd(pt1[0], pt1[1], pt1[2], pt1[3], pt2[0], pt2[1], pt2[2], pt2[3]);\\n        pt = [xx, xy, yx, yy];\\n    }\\n\\n    /**\\n     * @notice Add two twist points\\n     * @param pt1xx Coefficient 1 of x on point 1\\n     * @param pt1xy Coefficient 2 of x on point 1\\n     * @param pt1yx Coefficient 1 of y on point 1\\n     * @param pt1yy Coefficient 2 of y on point 1\\n     * @param pt2xx Coefficient 1 of x on point 2\\n     * @param pt2xy Coefficient 2 of x on point 2\\n     * @param pt2yx Coefficient 1 of y on point 2\\n     * @param pt2yy Coefficient 2 of y on point 2\\n     * @return (pt3xx, pt3xy, pt3yx, pt3yy)\\n     */\\n    function ecTwistAdd(\\n        uint256 pt1xx,\\n        uint256 pt1xy,\\n        uint256 pt1yx,\\n        uint256 pt1yy,\\n        uint256 pt2xx,\\n        uint256 pt2xy,\\n        uint256 pt2yx,\\n        uint256 pt2yy\\n    ) internal view returns (uint256, uint256, uint256, uint256) {\\n        if (pt1xx == 0 && pt1xy == 0 && pt1yx == 0 && pt1yy == 0) {\\n            if (!(pt2xx == 0 && pt2xy == 0 && pt2yx == 0 && pt2yy == 0)) {\\n                assert(isOnCurve(pt2xx, pt2xy, pt2yx, pt2yy));\\n            }\\n            return (pt2xx, pt2xy, pt2yx, pt2yy);\\n        } else if (pt2xx == 0 && pt2xy == 0 && pt2yx == 0 && pt2yy == 0) {\\n            assert(isOnCurve(pt1xx, pt1xy, pt1yx, pt1yy));\\n            return (pt1xx, pt1xy, pt1yx, pt1yy);\\n        }\\n\\n        assert(isOnCurve(pt1xx, pt1xy, pt1yx, pt1yy));\\n        assert(isOnCurve(pt2xx, pt2xy, pt2yx, pt2yy));\\n\\n        uint256[6] memory pt1 = [pt1xx, pt1xy, pt1yx, pt1yy, 1, 0];\\n        uint256[6] memory pt2 = [pt2xx, pt2xy, pt2yx, pt2yy, 1, 0];\\n        uint256[6] memory pt3 = ecTwistAddJacobian(pt1, pt2);\\n\\n        return fromJacobian(pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]);\\n    }\\n\\n    function submod(uint256 a, uint256 b, uint256 n) internal pure returns (uint256) {\\n        return addmod(a, n - b, n);\\n    }\\n\\n    function fq2Mul(uint256 xx, uint256 xy, uint256 yx, uint256 yy) internal pure returns (uint256, uint256) {\\n        return (\\n            submod(mulmod(xx, yx, FIELD_MODULUS), mulmod(xy, yy, FIELD_MODULUS), FIELD_MODULUS),\\n            addmod(mulmod(xx, yy, FIELD_MODULUS), mulmod(xy, yx, FIELD_MODULUS), FIELD_MODULUS)\\n        );\\n    }\\n\\n    function fq2Muc(uint256 xx, uint256 xy, uint256 c) internal pure returns (uint256, uint256) {\\n        return (mulmod(xx, c, FIELD_MODULUS), mulmod(xy, c, FIELD_MODULUS));\\n    }\\n\\n    function fq2Sub(uint256 xx, uint256 xy, uint256 yx, uint256 yy) internal pure returns (uint256 rx, uint256 ry) {\\n        return (submod(xx, yx, FIELD_MODULUS), submod(xy, yy, FIELD_MODULUS));\\n    }\\n\\n    function fq2Inv(uint256 x, uint256 y) internal view returns (uint256, uint256) {\\n        uint256 inv =\\n            modInv(addmod(mulmod(y, y, FIELD_MODULUS), mulmod(x, x, FIELD_MODULUS), FIELD_MODULUS), FIELD_MODULUS);\\n        return (mulmod(x, inv, FIELD_MODULUS), FIELD_MODULUS - mulmod(y, inv, FIELD_MODULUS));\\n    }\\n\\n    function isOnCurve(uint256 xx, uint256 xy, uint256 yx, uint256 yy) internal pure returns (bool) {\\n        uint256 yyx;\\n        uint256 yyy;\\n        uint256 xxxx;\\n        uint256 xxxy;\\n        (yyx, yyy) = fq2Mul(yx, yy, yx, yy);\\n        (xxxx, xxxy) = fq2Mul(xx, xy, xx, xy);\\n        (xxxx, xxxy) = fq2Mul(xxxx, xxxy, xx, xy);\\n        (yyx, yyy) = fq2Sub(yyx, yyy, xxxx, xxxy);\\n        (yyx, yyy) = fq2Sub(yyx, yyy, TWISTBX, TWISTBY);\\n        return yyx == 0 && yyy == 0;\\n    }\\n\\n    function modInv(uint256 a, uint256 n) internal view returns (uint256 result) {\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freemem := mload(0x40)\\n            mstore(freemem, 0x20)\\n            mstore(add(freemem, 0x20), 0x20)\\n            mstore(add(freemem, 0x40), 0x20)\\n            mstore(add(freemem, 0x60), a)\\n            mstore(add(freemem, 0x80), sub(n, 2))\\n            mstore(add(freemem, 0xA0), n)\\n            success := staticcall(sub(gas(), 2000), 5, freemem, 0xC0, freemem, 0x20)\\n            result := mload(freemem)\\n        }\\n        // solhint-disable-next-line reason-string\\n        require(success);\\n    }\\n\\n    function fromJacobian(uint256 pt1xx, uint256 pt1xy, uint256 pt1yx, uint256 pt1yy, uint256 pt1zx, uint256 pt1zy)\\n        internal\\n        view\\n        returns (uint256 pt2xx, uint256 pt2xy, uint256 pt2yx, uint256 pt2yy)\\n    {\\n        uint256 invzx;\\n        uint256 invzy;\\n        (invzx, invzy) = fq2Inv(pt1zx, pt1zy);\\n        (pt2xx, pt2xy) = fq2Mul(pt1xx, pt1xy, invzx, invzy);\\n        (pt2yx, pt2yy) = fq2Mul(pt1yx, pt1yy, invzx, invzy);\\n    }\\n\\n    function ecTwistAddJacobian(uint256[6] memory pt1, uint256[6] memory pt2)\\n        public\\n        pure\\n        returns (uint256[6] memory pt3)\\n    {\\n        if (pt1[4] == 0 && pt1[5] == 0) {\\n            (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) =\\n                (pt2[0], pt2[1], pt2[2], pt2[3], pt2[4], pt2[5]);\\n            return pt3;\\n        } else if (pt2[4] == 0 && pt2[5] == 0) {\\n            (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) =\\n                (pt1[0], pt1[1], pt1[2], pt1[3], pt1[4], pt1[5]);\\n            return pt3;\\n        }\\n\\n        (pt2[2], pt2[3]) = fq2Mul(pt2[2], pt2[3], pt1[4], pt1[5]); // U1 = y2 * z1\\n        (pt3[PTYX], pt3[PTYY]) = fq2Mul(pt1[2], pt1[3], pt2[4], pt2[5]); // U2 = y1 * z2\\n        (pt2[0], pt2[1]) = fq2Mul(pt2[0], pt2[1], pt1[4], pt1[5]); // V1 = x2 * z1\\n        (pt3[PTZX], pt3[PTZY]) = fq2Mul(pt1[0], pt1[1], pt2[4], pt2[5]); // V2 = x1 * z2\\n\\n        if (pt2[0] == pt3[PTZX] && pt2[1] == pt3[PTZY]) {\\n            if (pt2[2] == pt3[PTYX] && pt2[3] == pt3[PTYY]) {\\n                (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) =\\n                    ecTwistDoubleJacobian(pt1[0], pt1[1], pt1[2], pt1[3], pt1[4], pt1[5]);\\n                return pt3;\\n            }\\n            (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) = (1, 0, 1, 0, 0, 0);\\n            return pt3;\\n        }\\n\\n        (pt2[4], pt2[5]) = fq2Mul(pt1[4], pt1[5], pt2[4], pt2[5]); // W = z1 * z2\\n        (pt1[0], pt1[1]) = fq2Sub(pt2[2], pt2[3], pt3[PTYX], pt3[PTYY]); // U = U1 - U2\\n        (pt1[2], pt1[3]) = fq2Sub(pt2[0], pt2[1], pt3[PTZX], pt3[PTZY]); // V = V1 - V2\\n        (pt1[4], pt1[5]) = fq2Mul(pt1[2], pt1[3], pt1[2], pt1[3]); // V_squared = V * V\\n        (pt2[2], pt2[3]) = fq2Mul(pt1[4], pt1[5], pt3[PTZX], pt3[PTZY]); // V_squared_times_V2 = V_squared * V2\\n        (pt1[4], pt1[5]) = fq2Mul(pt1[4], pt1[5], pt1[2], pt1[3]); // V_cubed = V * V_squared\\n        (pt3[PTZX], pt3[PTZY]) = fq2Mul(pt1[4], pt1[5], pt2[4], pt2[5]); // newz = V_cubed * W\\n        (pt2[0], pt2[1]) = fq2Mul(pt1[0], pt1[1], pt1[0], pt1[1]); // U * U\\n        (pt2[0], pt2[1]) = fq2Mul(pt2[0], pt2[1], pt2[4], pt2[5]); // U * U * W\\n        (pt2[0], pt2[1]) = fq2Sub(pt2[0], pt2[1], pt1[4], pt1[5]); // U * U * W - V_cubed\\n        (pt2[4], pt2[5]) = fq2Muc(pt2[2], pt2[3], 2); // 2 * V_squared_times_V2\\n        (pt2[0], pt2[1]) = fq2Sub(pt2[0], pt2[1], pt2[4], pt2[5]); // A = U * U * W - V_cubed - 2 * V_squared_times_V2\\n        (pt3[PTXX], pt3[PTXY]) = fq2Mul(pt1[2], pt1[3], pt2[0], pt2[1]); // newx = V * A\\n        (pt1[2], pt1[3]) = fq2Sub(pt2[2], pt2[3], pt2[0], pt2[1]); // V_squared_times_V2 - A\\n        (pt1[2], pt1[3]) = fq2Mul(pt1[0], pt1[1], pt1[2], pt1[3]); // U * (V_squared_times_V2 - A)\\n        (pt1[0], pt1[1]) = fq2Mul(pt1[4], pt1[5], pt3[PTYX], pt3[PTYY]); // V_cubed * U2\\n        (pt3[PTYX], pt3[PTYY]) = fq2Sub(pt1[2], pt1[3], pt1[0], pt1[1]); // newy = U * (V_squared_times_V2 - A) - V_cubed * U2\\n    }\\n\\n    function ecTwistDoubleJacobian(\\n        uint256 pt1xx,\\n        uint256 pt1xy,\\n        uint256 pt1yx,\\n        uint256 pt1yy,\\n        uint256 pt1zx,\\n        uint256 pt1zy\\n    ) public pure returns (uint256 pt2xx, uint256 pt2xy, uint256 pt2yx, uint256 pt2yy, uint256 pt2zx, uint256 pt2zy) {\\n        (pt2xx, pt2xy) = fq2Muc(pt1xx, pt1xy, 3); // 3 * x\\n        (pt2xx, pt2xy) = fq2Mul(pt2xx, pt2xy, pt1xx, pt1xy); // W = 3 * x * x\\n        (pt1zx, pt1zy) = fq2Mul(pt1yx, pt1yy, pt1zx, pt1zy); // S = y * z\\n        (pt2yx, pt2yy) = fq2Mul(pt1xx, pt1xy, pt1yx, pt1yy); // x * y\\n        (pt2yx, pt2yy) = fq2Mul(pt2yx, pt2yy, pt1zx, pt1zy); // B = x * y * S\\n        (pt1xx, pt1xy) = fq2Mul(pt2xx, pt2xy, pt2xx, pt2xy); // W * W\\n        (pt2zx, pt2zy) = fq2Muc(pt2yx, pt2yy, 8); // 8 * B\\n        (pt1xx, pt1xy) = fq2Sub(pt1xx, pt1xy, pt2zx, pt2zy); // H = W * W - 8 * B\\n        (pt2zx, pt2zy) = fq2Mul(pt1zx, pt1zy, pt1zx, pt1zy); // S_squared = S * S\\n        (pt2yx, pt2yy) = fq2Muc(pt2yx, pt2yy, 4); // 4 * B\\n        (pt2yx, pt2yy) = fq2Sub(pt2yx, pt2yy, pt1xx, pt1xy); // 4 * B - H\\n        (pt2yx, pt2yy) = fq2Mul(pt2yx, pt2yy, pt2xx, pt2xy); // W * (4 * B - H)\\n        (pt2xx, pt2xy) = fq2Muc(pt1yx, pt1yy, 8); // 8 * y\\n        (pt2xx, pt2xy) = fq2Mul(pt2xx, pt2xy, pt1yx, pt1yy); // 8 * y * y\\n        (pt2xx, pt2xy) = fq2Mul(pt2xx, pt2xy, pt2zx, pt2zy); // 8 * y * y * S_squared\\n        (pt2yx, pt2yy) = fq2Sub(pt2yx, pt2yy, pt2xx, pt2xy); // newy = W * (4 * B - H) - 8 * y * y * S_squared\\n        (pt2xx, pt2xy) = fq2Muc(pt1xx, pt1xy, 2); // 2 * H\\n        (pt2xx, pt2xy) = fq2Mul(pt2xx, pt2xy, pt1zx, pt1zy); // newx = 2 * H * S\\n        (pt2zx, pt2zy) = fq2Mul(pt1zx, pt1zy, pt2zx, pt2zy); // S * S_squared\\n        (pt2zx, pt2zy) = fq2Muc(pt2zx, pt2zy, 8); // newz = 8 * S * S_squared\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"Staking-v0.1/=lib/Staking-v0.1/src/\",\r\n      \"Randcast-User-Contract/=lib/Randcast-User-Contract/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"fx-portal/=lib/fx-portal/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {\r\n      \"src/libraries/BLS.sol\": {\r\n        \"BLS\": \"0x554816B8C04Fe2Eeab2e9aAbF128d4f759AFE760\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EIP1271SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EIP1271SignatureNotFromSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EIP1271SignatureSaltAlreadySpent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EIP1271SignatureVerificationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPublicKey\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NodeAlreadyActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NodeAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NodeNotRegistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingUntilBlock\",\"type\":\"uint256\"}],\"name\":\"NodeStillPending\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorUnderStaking\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotController\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAccountAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"AssetAccountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dkgPublicKey\",\"type\":\"bytes\"}],\"name\":\"DkgPublicKeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupIndex\",\"type\":\"uint256\"}],\"name\":\"NodeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"NodeQuit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dkgPublicKey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupIndex\",\"type\":\"uint256\"}],\"name\":\"NodeRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arpaAmount\",\"type\":\"uint256\"}],\"name\":\"NodeRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeIdAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingRewardPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingBlock\",\"type\":\"uint256\"}],\"name\":\"NodeSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_NODE_REGISTRATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nodes\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arpaAmount\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAccountAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"assetAccountSaltIsSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAccountAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"calculateNativeNodeRegistrationDigestHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dkgPublicKey\",\"type\":\"bytes\"}],\"name\":\"changeDkgPublicKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeIdAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pendingBlock\",\"type\":\"uint256\"}],\"name\":\"dismissNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"getAssetAccountAddressByNodeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"getDKGPublicKey\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"getNode\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"idAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"dkgPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isEigenlayerNode\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pendingUntilBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct INodeRegistry.Node\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAccountAddress\",\"type\":\"address\"}],\"name\":\"getNodeAddressByAssetAccountAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeRegistryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"controllerContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"serviceManagerContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nativeNodeStakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eigenlayerNodeStakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBlockAfterQuit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"}],\"name\":\"getNodeWithdrawableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"arpa\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\"name\":\"assetAccountSignature\",\"type\":\"tuple\"}],\"name\":\"nodeActivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeLogOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeQuit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dkgPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isEigenlayerNode\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"assetAccountAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\"name\":\"assetAccountSignature\",\"type\":\"tuple\"}],\"name\":\"nodeRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"nodeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetAccountAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"nodeAddresses\",\"type\":\"address[]\"}],\"name\":\"setAssetAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controllerContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"serviceManagerContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nativeNodeStakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eigenlayerNodeStakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBlockAfterQuit\",\"type\":\"uint256\"}],\"name\":\"setNodeRegistryConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeIdAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingRewardPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBlock\",\"type\":\"uint256\"}],\"name\":\"slashNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "NodeRegistry", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}