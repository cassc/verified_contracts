{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@solidstate/contracts/security/pausable/IPausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IPausableInternal {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/PausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IPausableInternal } from './IPausableInternal.sol';\\nimport { PausableStorage } from './PausableStorage.sol';\\n\\n/**\\n * @title Internal functions for Pausable security control module.\\n */\\nabstract contract PausableInternal is IPausableInternal {\\n    modifier whenNotPaused() {\\n        if (_paused()) revert Pausable__Paused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        if (!_paused()) revert Pausable__NotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice query whether contract is paused\\n     * @return status whether contract is paused\\n     */\\n    function _paused() internal view virtual returns (bool status) {\\n        status = PausableStorage.layout().paused;\\n    }\\n\\n    /**\\n     * @notice Triggers paused state, when contract is unpaused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage.layout().paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Triggers unpaused state, when contract is paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        delete PausableStorage.layout().paused;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/PausableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary PausableStorage {\\n    struct Layout {\\n        bool paused;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Pausable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/reentrancy_guard/IReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IReentrancyGuard {\\n    error ReentrancyGuard__ReentrantCall();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IReentrancyGuard } from './IReentrancyGuard.sol';\\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\\n\\n/**\\n * @title Utility contract for preventing reentrancy attacks\\n */\\nabstract contract ReentrancyGuard is IReentrancyGuard {\\n    uint256 internal constant REENTRANCY_STATUS_LOCKED = 2;\\n    uint256 internal constant REENTRANCY_STATUS_UNLOCKED = 1;\\n\\n    modifier nonReentrant() virtual {\\n        if (_isReentrancyGuardLocked()) revert ReentrancyGuard__ReentrantCall();\\n        _lockReentrancyGuard();\\n        _;\\n        _unlockReentrancyGuard();\\n    }\\n\\n    /**\\n     * @notice returns true if the reentrancy guard is locked, false otherwise\\n     */\\n    function _isReentrancyGuardLocked() internal view virtual returns (bool) {\\n        return\\n            ReentrancyGuardStorage.layout().status == REENTRANCY_STATUS_LOCKED;\\n    }\\n\\n    /**\\n     * @notice lock functions that use the nonReentrant modifier\\n     */\\n    function _lockReentrancyGuard() internal virtual {\\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_LOCKED;\\n    }\\n\\n    /**\\n     * @notice unlock functions that use the nonReentrant modifier\\n     */\\n    function _unlockReentrancyGuard() internal virtual {\\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_UNLOCKED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ReentrancyGuardStorage {\\n    struct Layout {\\n        uint256 status;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/OnlyDelegateCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title OnlyDelegateCall\\n * @notice delegatecall invocation guard\\n */\\nabstract contract OnlyDelegateCall {\\n    address private immutable self = address(this);\\n\\n    /**\\n     * @dev Reverts if the current function context is not inside of a delegatecall\\n     */\\n    modifier onlyDelegateCall() {\\n        require(address(this) != self, 'onlyDelegateCall');\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice Emitted when an approval action fails\\n */\\nerror SafeApproveError();\\n\\n/**\\n * @notice Emitted when a transfer action fails\\n */\\nerror SafeTransferError();\\n\\n/**\\n * @notice Emitted when a transferFrom action fails\\n */\\nerror SafeTransferFromError();\\n\\n/**\\n * @notice Emitted when a transfer of the native token fails\\n */\\nerror SafeTransferNativeError();\\n\\n/**\\n * @notice Safely approve the token to the account\\n * @param _token The token address\\n * @param _to The token approval recipient address\\n * @param _value The token approval amount\\n */\\nfunction safeApprove(address _token, address _to, uint256 _value) {\\n    // 0x095ea7b3 is the selector for \\\"approve(address,uint256)\\\"\\n    (bool success, bytes memory data) = _token.call(\\n        abi.encodeWithSelector(0x095ea7b3, _to, _value)\\n    );\\n\\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\\n\\n    if (!condition) {\\n        revert SafeApproveError();\\n    }\\n}\\n\\n/**\\n * @notice Safely transfer the token to the account\\n * @param _token The token address\\n * @param _to The token transfer recipient address\\n * @param _value The token transfer amount\\n */\\nfunction safeTransfer(address _token, address _to, uint256 _value) {\\n    // 0xa9059cbb is the selector for \\\"transfer(address,uint256)\\\"\\n    (bool success, bytes memory data) = _token.call(\\n        abi.encodeWithSelector(0xa9059cbb, _to, _value)\\n    );\\n\\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\\n\\n    if (!condition) {\\n        revert SafeTransferError();\\n    }\\n}\\n\\n/**\\n * @notice Safely transfer the token between the accounts\\n * @param _token The token address\\n * @param _from The token transfer source address\\n * @param _to The token transfer recipient address\\n * @param _value The token transfer amount\\n */\\nfunction safeTransferFrom(address _token, address _from, address _to, uint256 _value) {\\n    // 0x23b872dd is the selector for \\\"transferFrom(address,address,uint256)\\\"\\n    (bool success, bytes memory data) = _token.call(\\n        abi.encodeWithSelector(0x23b872dd, _from, _to, _value)\\n    );\\n\\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\\n\\n    if (!condition) {\\n        revert SafeTransferFromError();\\n    }\\n}\\n\\n/**\\n * @notice Safely transfer the native token to the account\\n * @param _to The native token transfer recipient address\\n * @param _value The native token transfer amount\\n */\\nfunction safeTransferNative(address _to, uint256 _value) {\\n    (bool success, ) = _to.call{ value: _value }(new bytes(0));\\n\\n    if (!success) {\\n        revert SafeTransferNativeError();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oft/wrapper/facets/OFTWrapperLZV2Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\nimport { PausableInternal } from '@solidstate/contracts/security/pausable/PausableInternal.sol';\\nimport { ReentrancyGuard } from '@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol';\\nimport { OnlyDelegateCall } from '../../../access/OnlyDelegateCall.sol';\\nimport { OFTWrapperStatus } from '../OFTWrapperStatus.sol';\\nimport { OFTWrapperStorage } from '../OFTWrapperStorage.sol';\\nimport '../../../helpers/TransferHelper.sol' as TransferHelper;\\n\\n/**\\n * @title OFTWrapperLZV2Facet\\n * @notice The OFTWrapperDiamond facet for LayerZero V2 OFTs\\n */\\ncontract OFTWrapperLZV2Facet is\\n    OnlyDelegateCall,\\n    PausableInternal,\\n    ReentrancyGuard,\\n    OFTWrapperStatus\\n{\\n    /**\\n     * @notice OFT \\\"send\\\" parameter structure (LayerZero V2 OFT)\\n     * @param sendParam The parameters for the \\\"send\\\" operation\\n     * @param fee The fee information supplied by the caller\\n     * @param refundAddress The address to receive any excess funds from fees etc. on the source chain\\n     */\\n    struct SendParams {\\n        ILZV2OFTSend.SendParam sendParam;\\n        ILZV2OFTSend.MessagingFee fee;\\n        address refundAddress;\\n    }\\n\\n    /**\\n     * @notice OFT \\\"quoteSend\\\" parameter structure (LayerZero V2 OFT)\\n     * @param sendParam The parameters for the \\\"send\\\" operation\\n     * @param payInLzToken Flag indicating whether the caller is paying in the LZ token\\n     */\\n    struct QuoteSendParams {\\n        ILZV2OFTSend.SendParam sendParam;\\n        bool payInLzToken;\\n    }\\n\\n    /**\\n     * @notice OFT \\\"enforcedOptions\\\" parameter structure (LayerZero V2 OFT)\\n     * @param eid The destination chain endpoint identifier\\n     * @param msgType The cross-chain message type\\n     */\\n    struct EnforcedOptionsParams {\\n        uint32 eid;\\n        uint16 msgType;\\n    }\\n\\n    /**\\n     * @notice Sends tokens to the destination chain (LayerZero V2 OFT)\\n     * @param _oft The address of the OFT\\n     * @param _params The \\\"send\\\" parameter structure\\n     * @param _reserve The reserve value\\n     * @return The LayerZero messaging receipt from the \\\"send\\\" operation\\n     * @return The OFT receipt information\\n     */\\n    function lzv2oftSend(\\n        ILZV2OFTSend _oft,\\n        SendParams calldata _params,\\n        uint256 _reserve\\n    )\\n        external\\n        payable\\n        onlyDelegateCall\\n        whenNotPaused\\n        nonReentrant\\n        returns (ILZV2OFTSend.MessagingReceipt memory, ILZV2OFTSend.OFTReceipt memory)\\n    {\\n        address token = _oft.token();\\n        uint256 amount = _params.sendParam.amountLD;\\n\\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\\n\\n        bool approvalRequired = _oft.approvalRequired();\\n\\n        if (approvalRequired) {\\n            TransferHelper.safeApprove(token, address(_oft), amount);\\n        }\\n\\n        (\\n            ILZV2OFTSend.MessagingReceipt memory messagingReceipt,\\n            ILZV2OFTSend.OFTReceipt memory oftReceipt\\n        ) = _oft.send{ value: msg.value - _reserve }(\\n                _params.sendParam,\\n                _params.fee,\\n                _params.refundAddress\\n            );\\n\\n        if (approvalRequired) {\\n            TransferHelper.safeApprove(token, address(_oft), 0);\\n        }\\n\\n        TransferHelper.safeTransferNative(OFTWrapperStorage.layout().collector, _reserve);\\n\\n        emit OftSent();\\n\\n        return (messagingReceipt, oftReceipt);\\n    }\\n\\n    /**\\n     * @notice Provides a quote for the \\\"lzv2oftSend\\\" operation\\n     * @param _oft The address of the OFT\\n     * @param _params The \\\"quoteSend\\\" parameter structure\\n     * @param _reserve The reserve value\\n     * @return messagingFee The calculated messaging fee: \\\"lzv2oftSend\\\" operation\\n     * @return oftMessagingFee The calculated LayerZero messaging fee: \\\"send\\\" operation\\n     */\\n    function lzv2oftQuoteSend(\\n        ILZV2OFTSend _oft,\\n        QuoteSendParams calldata _params,\\n        uint256 _reserve\\n    )\\n        external\\n        view\\n        onlyDelegateCall\\n        returns (\\n            ILZV2OFTSend.MessagingFee memory messagingFee,\\n            ILZV2OFTSend.MessagingFee memory oftMessagingFee\\n        )\\n    {\\n        oftMessagingFee = _oft.quoteSend(_params.sendParam, _params.payInLzToken);\\n\\n        messagingFee = ILZV2OFTSend.MessagingFee({\\n            nativeFee: oftMessagingFee.nativeFee + _reserve,\\n            lzTokenFee: oftMessagingFee.lzTokenFee\\n        });\\n    }\\n\\n    /**\\n     * @notice Gets the enforced options for specific endpoint and message type combinations\\n     * @param _oft The address of the OFT\\n     * @param _params The \\\"enforcedOptions\\\" parameter structure\\n     */\\n    function lzv2oftEnforcedOptions(\\n        ILZV2OFTSend _oft,\\n        EnforcedOptionsParams calldata _params\\n    ) external view onlyDelegateCall returns (bytes memory) {\\n        return _oft.enforcedOptions(_params.eid, _params.msgType);\\n    }\\n}\\n\\ninterface ILZV2OFTSend {\\n    struct SendParam {\\n        uint32 dstEid; // Destination endpoint ID\\n        bytes32 to; // Recipient address\\n        uint256 amountLD; // Amount to send in local decimals\\n        uint256 minAmountLD; // Minimum amount to send in local decimals\\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message\\n        bytes composeMsg; // The composed message for the \\\"send\\\" operation\\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations\\n    }\\n\\n    struct MessagingFee {\\n        uint256 nativeFee;\\n        uint256 lzTokenFee;\\n    }\\n\\n    struct MessagingReceipt {\\n        bytes32 guid;\\n        uint64 nonce;\\n        MessagingFee fee;\\n    }\\n\\n    struct OFTReceipt {\\n        uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals\\n        uint256 amountReceivedLD; // Amount of tokens to be received on the remote side\\n    }\\n\\n    function send(\\n        SendParam calldata _sendParam,\\n        MessagingFee calldata _fee,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\\n\\n    function quoteSend(\\n        SendParam calldata _sendParam,\\n        bool _payInLzToken\\n    ) external view returns (MessagingFee memory);\\n\\n    function enforcedOptions(uint32 _eid, uint16 _msgType) external view returns (bytes memory);\\n\\n    function token() external view returns (address);\\n\\n    function approvalRequired() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/oft/wrapper/OFTWrapperStatus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title OFTWrapperStatus\\n * @notice OFTWrapperDiamond events and custom errors\\n */\\ninterface OFTWrapperStatus {\\n    /**\\n     * @notice Emitted when the OFT sending function is invoked\\n     */\\n    event OftSent();\\n\\n    /**\\n     * @notice Emitted when the caller is not the token sender\\n     */\\n    error SenderError();\\n}\\n\"\r\n    },\r\n    \"contracts/oft/wrapper/OFTWrapperStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title OFTWrapperStorage\\n * @notice OFTWrapperDiamond storage\\n */\\nlibrary OFTWrapperStorage {\\n    /**\\n     * @notice OFTWrapperDiamond storage layout\\n     * @param collector The address of the collector\\n     */\\n    struct Layout {\\n        address collector;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256('interport.oft.wrapper.OFTWrapperDiamond');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"Pausable__NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard__ReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeApproveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferNativeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OftSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ILZV2OFTSend\",\"name\":\"_oft\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"msgType\",\"type\":\"uint16\"}],\"internalType\":\"struct OFTWrapperLZV2Facet.EnforcedOptionsParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"lzv2oftEnforcedOptions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILZV2OFTSend\",\"name\":\"_oft\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"to\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountLD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountLD\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraOptions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"composeMsg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"oftCmd\",\"type\":\"bytes\"}],\"internalType\":\"struct ILZV2OFTSend.SendParam\",\"name\":\"sendParam\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"payInLzToken\",\"type\":\"bool\"}],\"internalType\":\"struct OFTWrapperLZV2Facet.QuoteSendParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_reserve\",\"type\":\"uint256\"}],\"name\":\"lzv2oftQuoteSend\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ILZV2OFTSend.MessagingFee\",\"name\":\"messagingFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ILZV2OFTSend.MessagingFee\",\"name\":\"oftMessagingFee\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILZV2OFTSend\",\"name\":\"_oft\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"to\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountLD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountLD\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraOptions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"composeMsg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"oftCmd\",\"type\":\"bytes\"}],\"internalType\":\"struct ILZV2OFTSend.SendParam\",\"name\":\"sendParam\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ILZV2OFTSend.MessagingFee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"internalType\":\"struct OFTWrapperLZV2Facet.SendParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_reserve\",\"type\":\"uint256\"}],\"name\":\"lzv2oftSend\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ILZV2OFTSend.MessagingFee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"internalType\":\"struct ILZV2OFTSend.MessagingReceipt\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountSentLD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountReceivedLD\",\"type\":\"uint256\"}],\"internalType\":\"struct ILZV2OFTSend.OFTReceipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "OFTWrapperLZV2Facet", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}