{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/stake/IAnryton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IAnryton is IERC20 {\\n    function getAssignedWalletAndSupply(string memory _saleName) external view returns (uint256, address);\\n    function getMaxSupply() external view returns (uint64);\\n    function getLatestSale() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/stake/Sales.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./IAnryton.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Sales is Ownable {\\n    uint256 private saleCounter;\\n\\n    struct Sale {\\n        string name;\\n        uint160 supply;\\n        address walletAddress;\\n        uint256 startAt;\\n    }\\n\\n    IAnryton public token;\\n\\n    mapping(string => uint256) public saleId;\\n    mapping(uint256 => Sale) public saleInfo;\\n\\n    event SaleInfo(\\n        uint256 indexed saleId,\\n        string indexed name,\\n        uint256 indexed startAt\\n    );\\n\\n    constructor (\\n        address _token,\\n        address _owner\\n    ) Ownable(msg.sender) {\\n        saleCounter = 0;\\n         token = IAnryton(_token);\\n        _defaultSale(_owner);\\n    }\\n\\n    /***\\n     * @function _defaultSale\\n     * @dev start \\\"Friend & Family\\\" sale at the time of deoloy\\n     */\\n    function _defaultSale(address _owner) private {\\n        startSale();\\n        _transferOwnership(_owner);\\n    }\\n\\n    /***\\n     * @function startSale\\n     * @dev starting sale PUBLIC or PRIVATE\\n     * @notice only by owner\\n     */\\n    function startSale() public onlyOwner {\\n        uint256 _currentTime = block.timestamp;\\n        uint256 _count = ++saleCounter;\\n        (\\n            string memory _saleName,\\n            uint256 _supply,\\n            address _walletAddress\\n        ) = getLatestMintedSale();\\n        /** add sale based on count number */\\n        _addSale(_count, _saleName, _supply, _walletAddress, _currentTime);\\n    }\\n\\n    function _addSale(\\n        uint256 _count,\\n        string memory _saleName,\\n        uint256 _supply,\\n        address _walletAddress,\\n        uint256 _currentTime\\n    ) private {\\n        saleInfo[_count].name = _saleName;\\n        saleInfo[_count].supply = uint160(_supply);\\n        saleInfo[_count].walletAddress = _walletAddress;\\n        saleInfo[_count].startAt = _currentTime;\\n        saleId[_saleName] = _count;\\n        emit SaleInfo(_count, _saleName, _currentTime);\\n    }\\n\\n    /***\\n     * @function getLatestMintedSale\\n     * @dev Latest minted sale on ERC20 contract, ONLY READ\\n     */\\n    function getLatestMintedSale()\\n        public\\n        view\\n        returns (string memory, uint256, address)\\n    {\\n        string memory _saleName = token.getLatestSale();\\n        (uint256 _supply, address _walletAddress) = token\\n            .getAssignedWalletAndSupply(_saleName);\\n        return (_saleName, _supply, _walletAddress);\\n    }\\n\\n    /***\\n     * @function getCurrentSaleCount\\n     * @dev Returning latest count of sale counter\\n     */\\n    function getLatestSaleCount() public view returns (uint256) {\\n        return saleCounter;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/stake/Stake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./Sales.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract Stake is Sales, ReentrancyGuard {\\n    struct Staking {\\n        uint232 stakeAmount;\\n        uint160 unStakedAmount;\\n        uint256 stakedAt;\\n        bool isUnstaked;\\n    }\\n\\n    struct Locking {\\n        uint248 lockedAmount;\\n        uint256 lockedAt;\\n        uint256 unLockedAt;\\n        bool isUnlocked;\\n    }\\n\\n    struct Deposit {\\n        uint208 depositAmount;\\n        uint208 withdrawAmount;\\n        uint256 depositedAt;\\n        string sale;\\n        bool isMatured;\\n    }\\n\\n    struct UserInfo {\\n        uint184 tokenBalance;\\n        uint184 withdrawTokens;\\n        uint128 stakedTokens;\\n        uint128 lockedTokens;\\n        uint48 totalStakes;\\n        uint48 totalLocks;\\n        uint48 totalDeposits;\\n    }\\n\\n    /** always multiply with 10 to ignore decials in smart contract */\\n    uint16 public stakingPercentage;\\n\\n    /*** @dev finances for getting all info related to user total invested amount */\\n    mapping(address => UserInfo) public users;\\n    mapping(address => mapping(uint => Staking)) public stakings;\\n    mapping(address => mapping(uint => Locking)) public lockings;\\n    mapping(address => mapping(uint => Deposit)) public deposits;\\n\\n    event StakePercentage(uint8 indexed percentage, address indexed changedBy);\\n    event DepositWithdraw(\\n        address indexed user,\\n        uint256 indexed amount,\\n        string indexed action\\n    );\\n    event StakedTokens(\\n        address indexed user,\\n        uint256 indexed amount,\\n        uint256 indexed serialNo\\n    );\\n    event LockedTokens(\\n        address indexed user,\\n        uint256 indexed amount,\\n        uint256 indexed serialNo\\n    );\\n\\n    /*** @dev require to check amount should be greater than zero */\\n    modifier amountZero(uint256 _amount) {\\n        require(_amount > 0, \\\"STAKE:: amount should be greater than zero.\\\");\\n        _;\\n    }\\n\\n    /** @dev check if user adress is zero or not */\\n    modifier addressZero(address _user) {\\n        require(\\n            _user != address(0),\\n            \\\"STAKE:: user should not be equal to address zero\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _token,\\n        address _owner\\n    ) Sales(_token, _owner) {\\n        stakingPercentage = 100;\\n    }\\n\\n    /***\\n     * @function deposit\\n     * @dev deposit ERC20 token amount to contract\\n     * @notice update balance and transfer token from user account to this contract\\n     */\\n    function deposit(\\n        address user,\\n        uint208 tokenAmount\\n    ) public nonReentrant returns (bool) {\\n        _updateTokenBalance(user, tokenAmount, \\\"DEPOSIT\\\");\\n        bool isTransferred = token.transferFrom(\\n            msg.sender,\\n            address(this),\\n            tokenAmount\\n        );\\n        return isTransferred;\\n    }\\n\\n    /***\\n     * @function withdraw\\n     * @dev deposit ERC20 token amount to contract\\n     * @notice update balance after withdraw, send token to user account\\n     */\\n    function withdraw() public returns (bool) {\\n        uint256 currentTime = block.timestamp;\\n        uint256 _maturedAmt = 0;\\n        uint256 _releasedAmt = 0;\\n\\n        for (uint256 m = 7; m <= 42; m++) {\\n            uint256 _withdrawnAmt = 0;\\n\\n            for (uint256 i = 1; i <= users[msg.sender].totalDeposits; i++) {\\n                Deposit memory userDeposit = deposits[msg.sender][i];\\n                if (!userDeposit.isMatured) {\\n                    (\\n                        uint256 _vestedAmt,\\n                        uint256 _tokenWithdrawn,\\n                        bool _isMatured\\n                    ) = _vesting(m, currentTime, userDeposit);\\n\\n                    if (_vestedAmt > 0) {\\n                        _maturedAmt += _vestedAmt;\\n                        _withdrawnAmt += _tokenWithdrawn;\\n                        deposits[msg.sender][i].withdrawAmount += uint160(\\n                            _vestedAmt\\n                        );\\n\\n                        if (_isMatured)\\n                            deposits[msg.sender][i].isMatured = true;\\n                    }\\n                }\\n            }\\n\\n            if (_withdrawnAmt > 0) _releasedAmt = _withdrawnAmt;\\n        }\\n\\n        _maturedAmt -= _releasedAmt;\\n        if (_maturedAmt <= 0)\\n            revert(\\\"STAKE:: there is no funds to be transferred.\\\");\\n        _updateTokenBalance(msg.sender, uint160(_maturedAmt), \\\"WITHDRAW\\\");\\n        bool isTransferred = token.transfer(msg.sender, _maturedAmt);\\n        return isTransferred;\\n    }\\n\\n    /***\\n     * @function updateTokenBalance\\n     * @dev update user token balance, scope (private)\\n     */\\n    function _updateTokenBalance(\\n        address _user,\\n        uint208 _amount,\\n        string memory _action\\n    ) private amountZero(_amount) addressZero(_user) {\\n        uint256 balance = users[_user].tokenBalance;\\n        if (_compareEqual(_action, \\\"DEPOSIT\\\")) {\\n            balance += _amount;\\n            _deposit(_user, _amount);\\n        } else if (_compareEqual(_action, \\\"WITHDRAW\\\")) {\\n            balance -= _amount;\\n            users[_user].withdrawTokens += uint184(_amount);\\n        }\\n\\n        users[_user].tokenBalance = uint184(balance);\\n        emit DepositWithdraw(_user, _amount, _action);\\n    }\\n\\n    /***\\n     * @function _deposit\\n     * @dev adding info of each time deposit\\n     */\\n    function _deposit(address _user, uint208 _amount) private {\\n        uint256 _latestSale = getLatestSaleCount();\\n        uint48 _count = ++users[_user].totalDeposits;\\n        deposits[_user][_count].depositAmount = _amount;\\n        deposits[_user][_count].depositedAt = block.timestamp;\\n        deposits[_user][_count].sale = saleInfo[_latestSale].name;\\n    }\\n\\n    /***\\n     * @function stakeTokens\\n     * @dev Staking token if deposited by a user\\n     * @notice adding modifiers to check amount should be greater than zero\\n     */\\n    function stakeOrLockTokens(\\n        address to,\\n        uint232 tokenAmount,\\n        string memory stakeOrLockType\\n    )\\n        public\\n        amountZero(tokenAmount)\\n        addressZero(to)\\n        nonReentrant\\n        returns (bool)\\n    {\\n        uint256 currentTime = block.timestamp;\\n        /** check if type is LOCK or STAKE */\\n        if (_compareEqual(stakeOrLockType, \\\"STAKE\\\")) {\\n            users[to].stakedTokens += uint128(tokenAmount);\\n            return _stakeTokens(msg.sender, to, tokenAmount, currentTime);\\n        } else if (_compareEqual(stakeOrLockType, \\\"LOCK\\\")) {\\n            users[to].lockedTokens += uint128(tokenAmount);\\n            return _lockTokens(msg.sender, to, tokenAmount, currentTime);\\n        } else {\\n            revert(\\\"STAKE:: type should be 'LOCK' or 'STAKE'\\\");\\n        }\\n    }\\n\\n    /***\\n     * @function _stakedTokens\\n     * @dev called by stakedAmount function\\n     * @notice scope private\\n     */\\n    function _stakeTokens(\\n        address _from,\\n        address _to,\\n        uint232 _amount,\\n        uint256 _currentTime\\n    ) private returns (bool) {\\n        uint48 _count = ++users[_to].totalStakes;\\n        /** set stakedAt, unStakedAt time and amount */\\n        stakings[_to][_count].stakedAt = _currentTime;\\n        stakings[_to][_count].stakeAmount = _amount;\\n        /** emit information in StakedTokens event */\\n        emit StakedTokens(_to, _amount, _count);\\n        bool isTransferred = token.transferFrom(_from, address(this), _amount);\\n        return isTransferred;\\n    }\\n\\n    /***\\n     * @function _lockedTokens\\n     * @dev locking tokens of a particular user for a limit of time\\n     * @notice scope is private\\n     */\\n    function _lockTokens(\\n        address _from,\\n        address _to,\\n        uint232 _amount,\\n        uint256 _currentTime\\n    ) private returns (bool) {\\n        uint48 _count = ++users[_to].totalLocks;\\n        /** set stakedAt, unStakedAt time and amount */\\n        lockings[_to][_count].lockedAt = _currentTime;\\n        lockings[_to][_count].unLockedAt = _currentTime + (30 * 24 * 60 * 60);\\n        lockings[_to][_count].lockedAmount = uint248(_amount);\\n        /** emit information in StakedTokens event */\\n        emit LockedTokens(_to, _amount, _count);\\n        bool isTransferred = token.transferFrom(_from, address(this), _amount);\\n        return isTransferred;\\n    }\\n\\n    /***\\n     * @function unStakeTokens\\n     * @dev unStake or unLock tokens on a particular ID\\n     */\\n    function unStakeOrUnLock(\\n        string memory stakeOrLock\\n    ) public nonReentrant returns (bool) {\\n        uint256 currentTime = block.timestamp;\\n        if (_compareEqual(stakeOrLock, \\\"UN_STAKE\\\")) {\\n            return _unStakeTokens(msg.sender, currentTime);\\n        } else if (_compareEqual(stakeOrLock, \\\"UN_LOCK\\\")) {\\n            return _unLockTokens(msg.sender, currentTime);\\n        } else {\\n            revert(\\\"STAKE:: type should be 'UN_LOCK' or 'UN_STAKE'\\\");\\n        }\\n    }\\n\\n    /***\\n     * @function _unStakeTokens\\n     * @dev unStaked tokens on a particular id\\n     * @notice this can be called publically as it is private\\n     */\\n    function _unStakeTokens(\\n        address _user,\\n        uint256 _currentTime\\n    ) private returns (bool) {\\n        uint256 _maturedAmt = 0;\\n        uint256 _withdrawnAmt = 0;\\n        uint256 _beforeUnstakedAmt = 0;\\n\\n        for (uint256 m = 13; m <= 18; m++) {\\n            _withdrawnAmt = 0;\\n\\n            for (uint256 i = 1; i <= users[_user].totalStakes; i++) {\\n                Staking memory userStaking = stakings[_user][i];\\n\\n                if (!userStaking.isUnstaked) {\\n                    if (m == 13)\\n                        _beforeUnstakedAmt = userStaking.unStakedAmount;\\n\\n                    (\\n                        uint256 releasedAmt,\\n                        bool isUnstaked\\n                    ) = _getMaturedStakeAmt(m, _currentTime, userStaking);\\n\\n                    if (releasedAmt > 0) {\\n                        uint256 profit = mulDiv(\\n                            releasedAmt,\\n                            stakingPercentage,\\n                            1000\\n                        );\\n\\n                        _maturedAmt += releasedAmt + profit;\\n                        _withdrawnAmt += _beforeUnstakedAmt;\\n                        stakings[_user][i].unStakedAmount += uint160(\\n                            releasedAmt + profit\\n                        );\\n\\n                        if (isUnstaked == true)\\n                            stakings[_user][i].isUnstaked = isUnstaked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        _maturedAmt -= _withdrawnAmt;\\n        if (_maturedAmt == 0)\\n            revert(\\\"STAKE:: there is no token to be un-stake\\\");\\n        bool isTransferred = token.transfer(_user, _maturedAmt);\\n        return isTransferred;\\n    }\\n\\n    /***\\n     * @function _unLockTokens\\n     * @dev unLocked all tokens on particular Id\\n     * @notice this can be called publically as it is private\\n     */\\n    function _unLockTokens(\\n        address _user,\\n        uint256 _currentTime\\n    ) private returns (bool) {\\n        uint256 _maturedAmt = 0;\\n\\n        for (uint i = 1; i <= users[_user].totalLocks; i++) {\\n            Locking memory _locked = lockings[msg.sender][i];\\n            /** get current time to verify with unStakedAt */\\n            if (!_locked.isUnlocked) {\\n                if (_currentTime > _locked.unLockedAt) {\\n                    _maturedAmt += _locked.lockedAmount;\\n                    lockings[_user][i].isUnlocked = true;\\n                }\\n            }\\n        }\\n\\n        if (_maturedAmt == 0)\\n            revert(\\\"STAKE: there is no amount to be transferred.\\\");\\n        bool isTransferred = token.transfer(_user, _maturedAmt);\\n        return isTransferred;\\n    }\\n\\n    /***\\n     * @function getMaturedStakedAmt\\n     * @dev get total matured balance after staking\\n     */\\n    function getMaturedStakedAmt(address user) public view returns (uint256) {\\n        uint256 maturedAmt = 0;\\n        uint256 withdrawnAmt = 0;\\n        uint256 _beforeUnstakedAmt = 0;\\n        uint256 currentTime = block.timestamp;\\n\\n        for (uint256 m = 13; m <= 18; m++) {\\n            withdrawnAmt = 0;\\n\\n            for (uint256 i = 1; i <= users[user].totalStakes; i++) {\\n                Staking memory userStaking = stakings[user][i];\\n\\n                if (!userStaking.isUnstaked) {\\n                    if (m == 13)\\n                        _beforeUnstakedAmt = userStaking.unStakedAmount;\\n\\n                    (uint256 releasedAmt, ) = _getMaturedStakeAmt(\\n                        m,\\n                        currentTime,\\n                        userStaking\\n                    );\\n\\n                    if (releasedAmt > 0) {\\n                        uint256 profit = mulDiv(\\n                            releasedAmt,\\n                            stakingPercentage,\\n                            1000\\n                        );\\n\\n                        maturedAmt += releasedAmt + profit;\\n                        withdrawnAmt += _beforeUnstakedAmt;\\n                    }\\n                }\\n            }\\n        }\\n\\n        maturedAmt -= withdrawnAmt;\\n        return maturedAmt;\\n    }\\n\\n    /***\\n     * @function _getMaturedStakeAmt\\n     * @dev get single stake value calling func in a loop\\n     */\\n    function _getMaturedStakeAmt(\\n        uint256 m,\\n        uint256 currentTime,\\n        Staking memory userStaking\\n    ) private pure returns (uint256, bool) {\\n        uint256 _amount = 0;\\n        bool _isUnstaked = false;\\n        /** 5 sec === 1 month */\\n        uint256 endTime = userStaking.stakedAt + (m * 30 * 24 * 60 * 60);\\n\\n        if (currentTime > endTime) {\\n            uint256 unStakePerMonth = userStaking.stakeAmount / 6;\\n            _amount += unStakePerMonth;\\n            if (m == 18) _isUnstaked = true;\\n        }\\n\\n        return (_amount, _isUnstaked);\\n    }\\n\\n    /***\\n     * @function changeStakePercentage\\n     * @dev change percentage of staking profit (always multiply by 10 before call this func)\\n     */\\n    function changeStakePercentage(\\n        uint8 percentage\\n    ) public amountZero(percentage) onlyOwner {\\n        stakingPercentage = percentage;\\n        emit StakePercentage(percentage, msg.sender);\\n    }\\n\\n    /***\\n     * @function compareStrings\\n     * @dev comparing two string with bytes length\\n     */\\n    function _compareEqual(\\n        string memory a,\\n        string memory b\\n    ) private pure returns (bool) {\\n        return (keccak256(bytes(a)) == keccak256(bytes(b)));\\n    }\\n\\n    /***\\n     * @function getLeftBalance\\n     * @dev get left amount after staked or locked amount\\n     * @notice publically readable\\n     */\\n    function getLeftBalance(address user) public view returns (uint) {\\n        UserInfo memory finance = users[user];\\n        /** get total staked and locked tokens and add them to deduct from tokenBalance */\\n        uint256 balance = finance.stakedTokens + finance.lockedTokens;\\n        balance = finance.tokenBalance - balance;\\n        return balance;\\n    }\\n\\n    /***\\n     * @function vesting\\n     * @dev getting info all the vesting data\\n     */\\n    function vesting(address user) public view returns (uint256) {\\n        uint256 currentTime = block.timestamp;\\n        uint256 maturedAmt = 0;\\n        uint256 releasedAmt = 0;\\n\\n        for (uint256 m = 7; m <= 42; m++) {\\n            uint256 withdrawnAmt = 0;\\n\\n            for (uint256 i = 1; i <= users[user].totalDeposits; i++) {\\n                Deposit memory userDeposit = deposits[user][i];\\n                if (!userDeposit.isMatured) {\\n                    (uint256 _vestedAmt, uint256 _tokenWithdrawn, ) = _vesting(\\n                        m,\\n                        currentTime,\\n                        userDeposit\\n                    );\\n                    if (_vestedAmt > 0) {\\n                        maturedAmt += _vestedAmt;\\n                        withdrawnAmt += _tokenWithdrawn;\\n                    }\\n                }\\n            }\\n\\n            if (withdrawnAmt > 0) releasedAmt = withdrawnAmt;\\n        }\\n\\n        maturedAmt -= releasedAmt;\\n        return maturedAmt;\\n    }\\n\\n    /***\\n     * @function _vesting\\n     * @dev get info of single deposit in a loop\\n     */\\n    function _vesting(\\n        uint256 _m,\\n        uint256 _currentTime,\\n        Deposit memory _userDeposit\\n    ) private pure returns (uint256, uint256, bool) {\\n        uint256 _amount = 0;\\n        uint256 _tgcAmount = 0;\\n        uint256 _tokenWithdrawn = 0;\\n        bool _isMatured = false;\\n\\n        /** cliff calculation */\\n        if (_m == 7) {\\n            _tgcAmount = _calcTgcAmount(_userDeposit, _currentTime);\\n            _amount += _tgcAmount;\\n        }\\n\\n        uint256 endTime = _userDeposit.depositedAt + (_m * 30 * 24 * 60 * 60);\\n        if (_currentTime > endTime) {\\n            _userDeposit.depositAmount -= uint160(_tgcAmount);\\n\\n            /** check if sale is \\\"PUBLIC_SALE\\\" OR \\\"PRIVATE_SALE\\\" */\\n            if (\\n                _compareEqual(_userDeposit.sale, \\\"FRIEND_FAMILY\\\") ||\\n                _compareEqual(_userDeposit.sale, \\\"PRIVATE_SALE\\\") ||\\n                _compareEqual(_userDeposit.sale, \\\"PUBLIC_SALE\\\")\\n            ) {\\n                if ((_m >= 7) && (_m <= 18)) {\\n                    if (_m == 7) _tokenWithdrawn = _userDeposit.withdrawAmount;\\n                    _amount += _userDeposit.depositAmount / 12;\\n                    if (_m == 18) _isMatured = true;\\n                }\\n            }\\n\\n            /** check if sale is \\\"TEAM\\\" OR \\\"ADVISORS\\\" */\\n            if (\\n                _compareEqual(_userDeposit.sale, \\\"TEAM\\\") ||\\n                _compareEqual(_userDeposit.sale, \\\"ADVISORS\\\")\\n            ) {\\n                if ((_m >= 13) && (_m <= 36)) {\\n                    if (_m == 13) _tokenWithdrawn = _userDeposit.withdrawAmount;\\n                    _amount += _userDeposit.depositAmount / 24;\\n                    if (_m == 36) _isMatured = true;\\n                }\\n            }\\n\\n            /** check if sale is \\\"RESERVES\\\" OR \\\"STORAGE_MINTING_ALLOCATION\\\" */\\n            if (\\n                _compareEqual(_userDeposit.sale, \\\"RESERVES\\\") ||\\n                _compareEqual(_userDeposit.sale, \\\"STORAGE_MINTING_ALLOCATION\\\")\\n            ) {\\n                if ((_m >= 25) && (_m <= 36)) {\\n                    if (_m == 25) _tokenWithdrawn = _userDeposit.withdrawAmount;\\n                    _amount += _userDeposit.depositAmount / 12;\\n                    if (_m == 36) _isMatured = true;\\n                }\\n            }\\n\\n            /** Getting value for MARKETTING */\\n            if (_compareEqual(_userDeposit.sale, \\\"MARKETTING\\\")) {\\n                if (_m == 18) _tokenWithdrawn = _userDeposit.withdrawAmount;\\n                _amount += _calcMarketting(_m, _userDeposit.depositAmount);\\n                if (_m == 42) _isMatured = true;\\n            }\\n        }\\n\\n        return (_amount, _tokenWithdrawn, _isMatured);\\n    }\\n\\n    /***\\n     * @function _calcTgcAmount\\n     * @dev Calculate TGC amount of PUBLIC_SALE\\n     */\\n    function _calcTgcAmount(\\n        Deposit memory _userDeposit,\\n        uint256 _currentTime\\n    ) private pure returns (uint256) {\\n        uint256 _tgcAmount = 0;\\n        /** Only for Public Sale which is given after two days  */\\n        if (_compareEqual(_userDeposit.sale, \\\"PUBLIC_SALE\\\")) {\\n            uint256 tgcTime = _userDeposit.depositedAt + (2 * 24 * 60 * 60);\\n            if (_currentTime > tgcTime)\\n                _tgcAmount = mulDiv(_userDeposit.depositAmount, 20, 100);\\n        }\\n\\n        return _tgcAmount;\\n    }\\n\\n    /***\\n     * @function _calcMarketting\\n     * @dev calculate marketting value\\n     */\\n    function _calcMarketting(\\n        uint256 _m,\\n        uint208 _depositedAmt\\n    ) private pure returns (uint256) {\\n        uint _amount = 0;\\n        uint8 age = 0;\\n\\n        if (_m == 42) age = 5;\\n        else if (_m == 36) age = 4;\\n        else if (_m == 30) age = 3;\\n        else if (_m == 24) age = 2;\\n        else if (_m == 18) age = 1;\\n\\n        if (age > 0) _amount = mulDiv(_depositedAmt, 20, 100);\\n        return _amount;\\n    }\\n\\n    /***\\n     * @function mulDiv\\n     */\\n    function mulDiv(\\n        uint256 value,\\n        uint256 percentage,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        return (value * percentage) / denominator;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DepositWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"serialNo\",\"type\":\"uint256\"}],\"name\":\"LockedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"startAt\",\"type\":\"uint256\"}],\"name\":\"SaleInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"StakePercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"serialNo\",\"type\":\"uint256\"}],\"name\":\"StakedTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"changeStakePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint208\",\"name\":\"tokenAmount\",\"type\":\"uint208\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint208\",\"name\":\"depositAmount\",\"type\":\"uint208\"},{\"internalType\":\"uint208\",\"name\":\"withdrawAmount\",\"type\":\"uint208\"},{\"internalType\":\"uint256\",\"name\":\"depositedAt\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"sale\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isMatured\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestMintedSale\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestSaleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLeftBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMaturedStakedAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockings\",\"outputs\":[{\"internalType\":\"uint248\",\"name\":\"lockedAmount\",\"type\":\"uint248\"},{\"internalType\":\"uint256\",\"name\":\"lockedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unLockedAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"saleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint160\",\"name\":\"supply\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint232\",\"name\":\"tokenAmount\",\"type\":\"uint232\"},{\"internalType\":\"string\",\"name\":\"stakeOrLockType\",\"type\":\"string\"}],\"name\":\"stakeOrLockTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPercentage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakings\",\"outputs\":[{\"internalType\":\"uint232\",\"name\":\"stakeAmount\",\"type\":\"uint232\"},{\"internalType\":\"uint160\",\"name\":\"unStakedAmount\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnstaked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IAnryton\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"stakeOrLock\",\"type\":\"string\"}],\"name\":\"unStakeOrUnLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint184\",\"name\":\"tokenBalance\",\"type\":\"uint184\"},{\"internalType\":\"uint184\",\"name\":\"withdrawTokens\",\"type\":\"uint184\"},{\"internalType\":\"uint128\",\"name\":\"stakedTokens\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lockedTokens\",\"type\":\"uint128\"},{\"internalType\":\"uint48\",\"name\":\"totalStakes\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"totalLocks\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"totalDeposits\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"vesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Stake", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000085e67b36d62b2d743d761740af4d8580a6033f3c00000000000000000000000040bb04d55941ed1b2ad662afa42ba81db3c0c9e8", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}