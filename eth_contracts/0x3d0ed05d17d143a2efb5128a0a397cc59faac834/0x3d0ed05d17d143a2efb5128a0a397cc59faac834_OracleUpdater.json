{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/OracleUpdater.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.22;\\n\\nimport {ICauldronV1} from \\\"interfaces/ICauldronV1.sol\\\";\\nimport {ICauldronV2} from \\\"interfaces/ICauldronV2.sol\\\";\\nimport {CauldronRegistry} from \\\"periphery/CauldronRegistry.sol\\\";\\nimport {MasterContractConfigurationRegistry} from \\\"periphery/MasterContractConfigurationRegistry.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\n\\ninterface IOracleUpdater {\\n    function updateCauldrons(ICauldronV1[] memory cauldrons_) external;\\n}\\n\\ninterface IGelatoChecker {\\n    function checker() external view returns (bool canExec, bytes memory execPayload);\\n}\\n\\ncontract OracleUpdater is IOracleUpdater, IGelatoChecker {\\n    uint256 private constant EXCHANGERATE_PRECISION = 1e18;\\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5;\\n    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\\n\\n    CauldronRegistry cauldronRegistry;\\n    MasterContractConfigurationRegistry masterContractConfigurationRegistry;\\n\\n    constructor(CauldronRegistry cauldronRegistry_, MasterContractConfigurationRegistry masterContractConfigurationRegistry_) {\\n        cauldronRegistry = cauldronRegistry_;\\n        masterContractConfigurationRegistry = masterContractConfigurationRegistry_;\\n    }\\n\\n    function updateCauldrons(ICauldronV1[] calldata cauldrons_) external override {\\n        for (uint256 i = 0; i < cauldrons_.length; ++i) {\\n            cauldrons_[i].updateExchangeRate();\\n        }\\n    }\\n\\n    function checker() external view override returns (bool canExec, bytes memory execPayload) {\\n        canExec = false;\\n        uint256 len;\\n        uint256 cauldronsLength = cauldronRegistry.cauldronsLength();\\n        bool[] memory isToBeUpdated = new bool[](cauldronsLength);\\n\\n        for (uint256 i = 0; i < cauldronsLength; ++i) {\\n            ICauldronV1 cauldron = cauldronRegistry.cauldrons(i);\\n\\n            (uint256 collaterizationRate, uint256 liquidationMultiplier) = masterContractConfigurationRegistry.configurations(\\n                cauldron.masterContract()\\n            );\\n            if (collaterizationRate == 0) {\\n                // Not registered --- assume V2 plus\\n                collaterizationRate = ICauldronV2(address(cauldron)).COLLATERIZATION_RATE();\\n                liquidationMultiplier = ICauldronV2(address(cauldron)).LIQUIDATION_MULTIPLIER();\\n            }\\n            uint256 collateralizationDelta = COLLATERIZATION_RATE_PRECISION - collaterizationRate;\\n            uint256 liquidationDelta = liquidationMultiplier - LIQUIDATION_MULTIPLIER_PRECISION;\\n\\n            (, uint256 currentRate) = cauldron.oracle().peek(cauldron.oracleData());\\n\\n            uint256 staleRate = cauldron.exchangeRate();\\n\\n            // Effectively staleRate * (1 - LTV)\\n            uint256 collaterizationBuffer = (staleRate * collateralizationDelta) / COLLATERIZATION_RATE_PRECISION;\\n            // Effectively staleRate * (liquidationMultiplier - 1)\\n            uint256 liquidationBuffer = (staleRate * liquidationDelta) / LIQUIDATION_MULTIPLIER_PRECISION;\\n            if (staleRate + collaterizationBuffer - liquidationBuffer < currentRate) {\\n                canExec = true;\\n                isToBeUpdated[i] = true;\\n                unchecked {\\n                    len++;\\n                }\\n            }\\n        }\\n\\n        ICauldronV1[] memory toBeUpdated = new ICauldronV1[](len);\\n\\n        for (uint256 i = 0; i < cauldronsLength; ++i) {\\n            if (isToBeUpdated[i]) {\\n                toBeUpdated[toBeUpdated.length - len] = cauldronRegistry.cauldrons(i);\\n                unchecked {\\n                    --len;\\n                }\\n            }\\n        }\\n\\n        execPayload = abi.encodeCall(IOracleUpdater.updateCauldrons, (toBeUpdated));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICauldronV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IOracle} from \\\"interfaces/IOracle.sol\\\";\\n\\ninterface ICauldronV1 {\\n    function accrue() external;\\n\\n    function withdrawFees() external;\\n\\n    function accrueInfo() external view returns (uint64, uint128);\\n\\n    function setFeeTo(address newFeeTo) external;\\n\\n    function feeTo() external view returns (address);\\n\\n    function masterContract() external view returns (ICauldronV1);\\n\\n    function bentoBox() external view returns (address);\\n\\n    function exchangeRate() external view returns (uint256 rate);\\n\\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\\n\\n    function oracle() external view returns (IOracle);\\n\\n    function oracleData() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICauldronV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport {IOracle} from \\\"interfaces/IOracle.sol\\\";\\nimport {Rebase} from \\\"BoringSolidity/libraries/BoringRebase.sol\\\";\\n\\ninterface ICauldronV2 {\\n    function oracle() external view returns (IOracle);\\n\\n    function oracleData() external view returns (bytes memory);\\n\\n    function accrueInfo() external view returns (uint64, uint128, uint64);\\n\\n    function BORROW_OPENING_FEE() external view returns (uint256);\\n\\n    function COLLATERIZATION_RATE() external view returns (uint256);\\n\\n    function LIQUIDATION_MULTIPLIER() external view returns (uint256);\\n\\n    function totalCollateralShare() external view returns (uint256);\\n\\n    function bentoBox() external view returns (address);\\n\\n    function feeTo() external view returns (address);\\n\\n    function masterContract() external view returns (ICauldronV2);\\n\\n    function collateral() external view returns (IERC20);\\n\\n    function setFeeTo(address newFeeTo) external;\\n\\n    function accrue() external;\\n\\n    function totalBorrow() external view returns (Rebase memory);\\n\\n    function userBorrowPart(address account) external view returns (uint256);\\n\\n    function userCollateralShare(address account) external view returns (uint256);\\n\\n    function withdrawFees() external;\\n\\n    function cook(\\n        uint8[] calldata actions,\\n        uint256[] calldata values,\\n        bytes[] calldata datas\\n    ) external payable returns (uint256 value1, uint256 value2);\\n\\n    function addCollateral(address to, bool skim, uint256 share) external;\\n\\n    function removeCollateral(address to, uint256 share) external;\\n\\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\\n\\n    function repay(address to, bool skim, uint256 part) external returns (uint256 amount);\\n\\n    function reduceSupply(uint256 amount) external;\\n\\n    function magicInternetMoney() external view returns (IERC20);\\n\\n    function liquidate(address[] calldata users, uint256[] calldata maxBorrowParts, address to, address swapper) external;\\n\\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\\n\\n    function exchangeRate() external view returns (uint256 rate);\\n}\\n\"\r\n    },\r\n    \"src/periphery/CauldronRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.22;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ICauldronV1} from \\\"interfaces/ICauldronV1.sol\\\";\\n\\ncontract CauldronRegistry is Owned {\\n    error ErrAlreadyRegistered(ICauldronV1 cauldron_);\\n    error ErrNotRegistered(ICauldronV1 cauldron_);\\n    error ErrEmptyRegistry();\\n    error ErrInvalidCauldron(ICauldronV1 cauldron_);\\n\\n    ICauldronV1[] public cauldrons;\\n    mapping(ICauldronV1 => uint256) internal cauldronIndicies;\\n\\n    constructor(address owner_) Owned(owner_) {}\\n\\n    function addCauldrons(ICauldronV1[] calldata cauldrons_) external onlyOwner {\\n        for (uint256 i = 0; i < cauldrons_.length; ++i) {\\n            ICauldronV1 cauldron = cauldrons_[i];\\n\\n            if (address(cauldron) == address(0)) {\\n                revert ErrInvalidCauldron(cauldron);\\n            }\\n\\n            if (cauldronIndicies[cauldron] != 0 || (cauldrons.length != 0 && cauldrons[0] == cauldron)) {\\n                revert ErrAlreadyRegistered(cauldron);\\n            }\\n\\n            uint256 cauldronIndex = cauldrons.length;\\n            cauldrons.push(cauldron);\\n            cauldronIndicies[cauldron] = cauldronIndex;\\n        }\\n    }\\n\\n    function removeCauldrons(ICauldronV1[] calldata cauldrons_) external onlyOwner {\\n        if (cauldrons.length == 0) {\\n            revert ErrEmptyRegistry();\\n        }\\n\\n        for (uint256 i = 0; i < cauldrons_.length; ++i) {\\n            ICauldronV1 cauldron = cauldrons_[i];\\n\\n            if (address(cauldron) == address(0)) {\\n                revert ErrInvalidCauldron(cauldron);\\n            }\\n\\n            uint256 cauldronIndex = cauldronIndicies[cauldron];\\n            if (cauldronIndex == 0 && cauldrons[0] != cauldron) {\\n                revert ErrNotRegistered(cauldron);\\n            }\\n\\n            uint256 lastIndex = cauldrons.length - 1;\\n            if (cauldronIndex == lastIndex) {\\n                cauldrons.pop();\\n                delete cauldronIndicies[cauldron];\\n            } else {\\n                cauldronIndicies[cauldrons[lastIndex]] = cauldronIndex;\\n                cauldrons[cauldronIndex] = cauldrons[lastIndex];\\n                cauldrons.pop();\\n                delete cauldronIndicies[cauldron];\\n            }\\n        }\\n    }\\n\\n    function cauldronsLength() public view returns (uint256) {\\n        return cauldrons.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/periphery/MasterContractConfigurationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.22;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ICauldronV1} from \\\"interfaces/ICauldronV1.sol\\\";\\n\\nstruct MasterContractConfiguration {\\n    uint24 collaterizationRate;\\n    uint24 liquidationMultiplier;\\n}\\n\\ncontract MasterContractConfigurationRegistry is Owned {\\n    error ErrInvalidConfigration();\\n    error ErrInvalidMasterContract(ICauldronV1 masterContract);\\n    error ErrLengthMismatch();\\n\\n    mapping(ICauldronV1 => MasterContractConfiguration) public configurations;\\n\\n    constructor(address owner_) Owned(owner_) {}\\n\\n    function setConfigurations(\\n        ICauldronV1[] calldata masterContracts_,\\n        MasterContractConfiguration[] calldata configurations_\\n    ) external onlyOwner {\\n        if (masterContracts_.length != configurations_.length) {\\n            revert ErrLengthMismatch();\\n        }\\n\\n        for (uint256 i = 0; i < masterContracts_.length; ++i) {\\n            ICauldronV1 masterContract = masterContracts_[i];\\n            MasterContractConfiguration calldata configuration = configurations_[i];\\n\\n            if (address(masterContract) == address(0)) {\\n                revert ErrInvalidMasterContract(masterContract);\\n            }\\n\\n            if (configuration.collaterizationRate == 0 || configuration.liquidationMultiplier == 0) {\\n                revert ErrInvalidConfigration();\\n            }\\n\\n            configurations[masterContract] = configuration;\\n        }\\n    }\\n\\n    function removeConfigurations(ICauldronV1[] calldata masterContracts_) external onlyOwner {\\n        for (uint256 i = 0; i < masterContracts_.length; ++i) {\\n            ICauldronV1 masterContract = masterContracts_[i];\\n\\n            if (address(masterContract) == address(0)) {\\n                revert ErrInvalidMasterContract(masterContract);\\n            }\\n\\n            delete configurations[masterContract];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IOracle {\\n    function decimals() external view returns (uint8);\\n\\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\\n\\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\\n\\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\\n\\n    function symbol(bytes calldata data) external view returns (string memory);\\n\\n    function name(bytes calldata data) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\\n    // By removing them you can't accidentally use them.\\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ninterface IStrictERC20 {\\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringRebase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {BoringMath, BoringMath128} from \\\"./BoringMath.sol\\\";\\n\\nstruct Rebase {\\n    uint128 elastic;\\n    uint128 base;\\n}\\n\\n/// @notice A rebasing library using overflow-/underflow-safe math.\\nlibrary RebaseLibrary {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n\\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\\n    function toBase(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (uint256 base) {\\n        if (total.elastic == 0) {\\n            base = elastic;\\n        } else {\\n            base = (elastic * total.base) / total.elastic;\\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\\n                base++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\\n    function toElastic(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (uint256 elastic) {\\n        if (total.base == 0) {\\n            elastic = base;\\n        } else {\\n            elastic = (base * total.elastic) / total.base;\\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\\n                elastic++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\\n    /// @return (Rebase) The new total.\\n    /// @return base in relationship to `elastic`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 base) {\\n        base = toBase(total, elastic, roundUp);\\n        total.elastic += elastic.to128();\\n        total.base += base.to128();\\n        return (total, base);\\n    }\\n\\n    /// @notice Sub `base` from `total` and update `total.elastic`.\\n    /// @return (Rebase) The new total.\\n    /// @return elastic in relationship to `base`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 elastic) {\\n        elastic = toElastic(total, base, roundUp);\\n        total.elastic -= elastic.to128();\\n        total.base -= base.to128();\\n        return (total, elastic);\\n    }\\n\\n    /// @notice Add `elastic` and `base` to `total`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic += elastic.to128();\\n        total.base += base.to128();\\n        return total;\\n    }\\n\\n    /// @notice Subtract `elastic` and `base` to `total`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic -= elastic.to128();\\n        total.base -= base.to128();\\n        return total;\\n    }\\n\\n    /// @notice Add `elastic` to `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic += elastic.to128();\\n    }\\n\\n    /// @notice Subtract `elastic` from `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic -= elastic.to128();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary BoringMath {\\n    error ErrOverflow();\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\n        if(a > type(uint128).max) {\\n            revert ErrOverflow();\\n        }\\n        c = uint128(a);\\n    }\\n\\n    function to64(uint256 a) internal pure returns (uint64 c) {\\n        if(a > type(uint64).max) {\\n            revert ErrOverflow();\\n        }\\n        c = uint64(a);\\n    }\\n\\n    function to32(uint256 a) internal pure returns (uint32 c) {\\n        if(a > type(uint32).max) {\\n            revert ErrOverflow();\\n        }\\n        c = uint32(a);\\n    }\\n}\\n\\nlibrary BoringMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\\n        c = a + b;\\n    }\\n\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\\n        c = a - b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"BoringSolidity/=lib/BoringSolidity/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"utils/=utils/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"cauldrons/=src/cauldrons/\",\r\n      \"swappers/=src/swappers/\",\r\n      \"oracles/=src/oracles/\",\r\n      \"strategies/=src/strategies/\",\r\n      \"tokens/=src/tokens/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"mixins/=src/mixins/\",\r\n      \"lenses/=src/lenses/\",\r\n      \"surl/=lib/surl/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-deploy/=lib/forge-deploy/contracts/\",\r\n      \"ExcessivelySafeCall/=lib/ExcessivelySafeCall/src/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract CauldronRegistry\",\"name\":\"cauldronRegistry_\",\"type\":\"address\"},{\"internalType\":\"contract MasterContractConfigurationRegistry\",\"name\":\"masterContractConfigurationRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"checker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV1[]\",\"name\":\"cauldrons_\",\"type\":\"address[]\"}],\"name\":\"updateCauldrons\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OracleUpdater", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "000000000000000000000000d5448076c44847212c3daacd789ad077153aee16000000000000000000000000c659296c689f82e100c81ca6862049b806d3305a", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}