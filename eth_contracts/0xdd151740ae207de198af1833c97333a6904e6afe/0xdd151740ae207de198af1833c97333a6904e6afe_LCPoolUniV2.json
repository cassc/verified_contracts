{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LCPoolUniV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IWETH.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Router01.sol\\\";\\r\\nimport \\\"./interfaces/IMasterChef.sol\\\";\\r\\nimport \\\"./interfaces/ISwapPlusv1.sol\\\";\\r\\nimport \\\"./interfaces/IFeeTierStrate.sol\\\";\\r\\nimport \\\"./interfaces/ILCPoolUniV2Ledger.sol\\\";\\r\\n\\r\\nimport \\\"./utils/Ownable.sol\\\";\\r\\nimport \\\"./utils/SafeERC20.sol\\\";\\r\\nimport \\\"./utils/StringUtils.sol\\\";\\r\\n\\r\\ncontract LCPoolUniV2 is Ownable {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  address public v2Router;\\r\\n  address public v2MasterChef;\\r\\n  address public WETH;\\r\\n  address public rewardToken;\\r\\n  address public swapRouter;\\r\\n  address public feeStrate;\\r\\n  address public ledger;\\r\\n  string public pendingRewardsFunctionName;\\r\\n\\r\\n  uint256 private constant coreDecimal = 1000000;\\r\\n  bool public reinvestAble = true;\\r\\n  uint256 public reinvestEdge = 100;\\r\\n\\r\\n  struct Operator {\\r\\n    address account;\\r\\n    address[2] pair;\\r\\n    uint256 meta; // poolId\\r\\n    uint256 basketId;\\r\\n    address token;\\r\\n    uint256 amount;\\r\\n  }\\r\\n\\r\\n  struct swapPath {\\r\\n    ISwapPlusv1.swapBlock[] path;\\r\\n  }\\r\\n\\r\\n  mapping (address => bool) public managers;\\r\\n  mapping (address => bool) public operators;\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"LC pool: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  event Deposit(uint256 poolId, uint256 liquiidty);\\r\\n  event Withdraw(uint256 poolId, uint256 liquiidty, uint256 amountOut);\\r\\n  event ReInvest(address token0, address token1, uint256 poolId, uint256 reward, uint256 extraLp);\\r\\n  event RemovePool(address operator, address from, uint256 tokenId, address token0, address token1, uint24 fee, bytes data);\\r\\n  event LcFee(address account, address token, uint256 amount);\\r\\n  event ClaimReward(address account, uint256 poolId, uint256 basketId, uint256 extraLp, uint256 reward);\\r\\n\\r\\n  constructor (\\r\\n    address _v2Router,\\r\\n    address _v2MasterChef,\\r\\n    address _swapRouter,\\r\\n    address _feeStrate,\\r\\n    address _ledger,\\r\\n    address _WETH,\\r\\n    address _reward,\\r\\n    string memory _pendingRewardsFunctionName\\r\\n  ) {\\r\\n    require(_v2Router != address(0), \\\"LC pool: router\\\");\\r\\n    require(_v2MasterChef != address(0), \\\"LC pool: master chef\\\");\\r\\n    require(_swapRouter != address(0), \\\"LC pool: swap router\\\");\\r\\n    require(_feeStrate != address(0), \\\"LC pool: feeStrate\\\");\\r\\n    require(_ledger != address(0), \\\"LC pool: ledger\\\");\\r\\n    require(_WETH != address(0), \\\"LC pool: WETH\\\");\\r\\n    require(_reward != address(0), \\\"LC pool: reward\\\");\\r\\n\\r\\n    v2Router = _v2Router;\\r\\n    v2MasterChef = _v2MasterChef;\\r\\n    swapRouter = _swapRouter;\\r\\n    feeStrate = _feeStrate;\\r\\n    ledger = _ledger;\\r\\n    WETH = _WETH;\\r\\n    rewardToken = _reward;\\r\\n    pendingRewardsFunctionName = _pendingRewardsFunctionName;\\r\\n    managers[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * mtoken     0: tokenMReward, 1: tM'\\r\\n   * percent    0: tM->t0%       1: tM->t1%\\r\\n   * paths      0: tIn->tM,      1: tM->t0,  2: tM->t1\\r\\n   * minAmounts 0: lpMin0        1: lpMin1\\r\\n   */\\r\\n  // function deposit(uint256 tokenId, uint256 basketId, uint256 liquidity, uint256 reward, uint256 exRate) public payable {\\r\\n  function deposit(\\r\\n    Operator calldata info,\\r\\n    address[2][2] calldata mtoken,\\r\\n    uint256[2][2] calldata percent,\\r\\n    swapPath[3] calldata paths,\\r\\n    swapPath[3] calldata rpaths,\\r\\n    uint256[2][2] calldata minAmounts\\r\\n  ) public payable returns(uint256, uint256) {\\r\\n    require(msg.sender == info.account || operators[msg.sender], \\\"LC pool: no access\\\");\\r\\n    uint256[] memory dpvar = new uint256[](4);\\r\\n    dpvar[0] = 0; // reward\\r\\n    dpvar[1] = 0; // exLp\\r\\n    dpvar[2] = 0; // rewardReserve\\r\\n    dpvar[3] = 0; // iAmount\\r\\n    if (info.token != address(0)) {  // If address is not null, send this amount to contract.\\r\\n      dpvar[3] = IERC20(info.token).balanceOf(address(this));\\r\\n      IERC20(info.token).safeTransferFrom(info.account, address(this), info.amount);\\r\\n      dpvar[3] = IERC20(info.token).balanceOf(address(this)) - dpvar[3];\\r\\n    }\\r\\n    else {\\r\\n      IWETH(WETH).deposit{value: msg.value}();\\r\\n      dpvar[3] = msg.value;\\r\\n    }\\r\\n\\r\\n    \\r\\n    (dpvar[1], dpvar[0], dpvar[2], ,) = _reinvest(info, mtoken[1], percent[1], rpaths, minAmounts[1], false);\\r\\n\\r\\n    dpvar[3] = _distributeFee(info.basketId, (info.token==address(0)?WETH:info.token), dpvar[3], 1);\\r\\n    uint256 liquidity = _deposit(info, dpvar[3], mtoken[0], percent[0], paths, minAmounts[0]);\\r\\n    ILCPoolUniV2Ledger(ledger).updateInfo(info.account, info.meta, info.basketId, liquidity, dpvar[0], dpvar[2], dpvar[1], true);\\r\\n\\r\\n    return (info.meta, liquidity);\\r\\n  }\\r\\n\\r\\n  function withdraw(\\r\\n    address receiver,\\r\\n    Operator calldata info,\\r\\n    address[2][2] calldata mtoken,\\r\\n    uint256[2] calldata percent,\\r\\n    swapPath[3] calldata paths,\\r\\n    swapPath[3] calldata rpaths,\\r\\n    uint256[2][2] calldata minAmounts\\r\\n  ) public returns(uint256) {\\r\\n    require(receiver == info.account || operators[msg.sender], \\\"LC pool: no access\\\");\\r\\n    // 0: reward\\r\\n    // 1: exLp\\r\\n    // 2: rewardReserve\\r\\n    // 3: tokenId\\r\\n    // 4: outAmount\\r\\n    // 5: claim extra lp\\r\\n    // 6: claim reward amount\\r\\n    // 7: withdrawn liquidity amount\\r\\n    // 8: current reward\\r\\n    uint256[] memory wvar = new uint256[](9);\\r\\n    \\r\\n    (wvar[1], wvar[0], wvar[2], wvar[5], wvar[6]) = _reinvest(info, mtoken[1], percent, rpaths, minAmounts[1], true);\\r\\n    wvar[8] = IERC20(rewardToken).balanceOf(address(this));\\r\\n    if (wvar[8] < wvar[6]) {\\r\\n      wvar[6] = wvar[8];\\r\\n    }\\r\\n    if (wvar[6] > 0) {\\r\\n      IERC20(rewardToken).safeTransfer(info.account, wvar[6]);\\r\\n    }\\r\\n\\r\\n    bool isCoin = false;\\r\\n    if (info.token == address(0)) {\\r\\n      isCoin = true;\\r\\n    }\\r\\n    // return tokenId, withdraw liquidity amount, receive token amount\\r\\n    (wvar[3], wvar[7], wvar[4]) = _withdraw(info, wvar[5], mtoken[0], paths, minAmounts[0]);\\r\\n    ILCPoolUniV2Ledger(ledger).updateInfo(info.account, wvar[3], info.basketId, wvar[7], wvar[0], wvar[2], wvar[1], false);\\r\\n\\r\\n    wvar[4] = _distributeFee(info.basketId, isCoin?WETH:info.token, wvar[4], 0);\\r\\n\\r\\n    if (wvar[4] > 0) {\\r\\n      if (isCoin) {\\r\\n        IWETH(WETH).withdraw(wvar[4]);\\r\\n        (bool success, ) = payable(receiver).call{value: wvar[4]}(\\\"\\\");\\r\\n        require(success, \\\"LC pool: Failed receipt\\\");\\r\\n      }\\r\\n      else {\\r\\n        IERC20(info.token).safeTransfer(receiver, wvar[4]);\\r\\n      }\\r\\n    }\\r\\n    if (wvar[5] > 0 || wvar[6] > 0) {\\r\\n      emit ClaimReward(info.account, wvar[3], info.basketId, wvar[5], wvar[6]);\\r\\n    }\\r\\n    return wvar[4];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * tokens   0: token0,  1: token1,\\r\\n   * mtokens  0: tokenM,  1: tM'\\r\\n   * paths    0: t->tM,   1: tM->t0,   2: tM->t1\\r\\n   * percents 0: tM->t0%  1: tM->t1%\\r\\n   * return amount0, amount1\\r\\n   */\\r\\n  function _depositSwap(\\r\\n    address tokenIn,\\r\\n    uint256 amountIn,\\r\\n    address[2] memory tokens,\\r\\n    address[2] calldata mTokens,\\r\\n    uint256[2] calldata percents,\\r\\n    swapPath[3] calldata paths\\r\\n  ) internal returns(uint256, uint256) {\\r\\n    uint256[2] memory outs;\\r\\n    outs[0] = amountIn;\\r\\n    outs[1] = amountIn;\\r\\n    uint256 amountM = amountIn;\\r\\n    if (tokenIn == address(0)) tokenIn = WETH;\\r\\n\\r\\n    if (paths[0].path.length > 0) {\\r\\n      _approveTokenIfNeeded(tokenIn, swapRouter, amountM);\\r\\n      (, amountM) = ISwapPlusv1(swapRouter).swap(tokenIn, amountM, mTokens[0], address(this), paths[0].path);\\r\\n    }\\r\\n    if (paths[1].path.length > 0) {\\r\\n      _approveTokenIfNeeded(mTokens[0], swapRouter, amountM);\\r\\n      (, outs[0]) = ISwapPlusv1(swapRouter).swap(mTokens[0], amountM*percents[0]/coreDecimal, tokens[0], address(this), paths[1].path);\\r\\n      amountM -= amountM*percents[0]/coreDecimal;\\r\\n      outs[1] = amountM;\\r\\n    }\\r\\n    if (paths[2].path.length > 0) {\\r\\n      if (mTokens[0] == mTokens[1]) {\\r\\n        _approveTokenIfNeeded(mTokens[1], swapRouter, amountM);\\r\\n        (, outs[1]) = ISwapPlusv1(swapRouter).swap(mTokens[1], amountM, tokens[1], address(this), paths[2].path);\\r\\n      }\\r\\n      else {\\r\\n        _approveTokenIfNeeded(mTokens[1], swapRouter, outs[0]);\\r\\n        (, outs[1]) = ISwapPlusv1(swapRouter).swap(mTokens[1], outs[0]*percents[1]/coreDecimal, tokens[1], address(this), paths[2].path);\\r\\n        outs[0] -= outs[0]*percents[1]/coreDecimal;\\r\\n      }\\r\\n    }\\r\\n    return (outs[0], outs[1]);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * return extraLp, reward, reserved reward\\r\\n   */\\r\\n  function _reinvest(\\r\\n    Operator calldata info,\\r\\n    address[2] calldata mtoken,\\r\\n    uint256[2] calldata percents,\\r\\n    swapPath[3] calldata paths,\\r\\n    uint256[2] calldata minAmounts,\\r\\n    bool claimReward\\r\\n  ) internal returns(uint256, uint256, uint256, uint256, uint256) {\\r\\n    uint256[] memory rvar = new uint256[](8);\\r\\n    rvar[1] = IERC20(rewardToken).balanceOf(address(this)); // reward\\r\\n    rvar[2] = 0; // extraLp\\r\\n    rvar[6] = 0; // claim extra lp\\r\\n    rvar[7] = 0; // claim reward amount\\r\\n    if (_rewardsAvailable(info.meta) > 0) {\\r\\n      IMasterChef(v2MasterChef).deposit(info.meta, 0);\\r\\n    }\\r\\n    rvar[1] = IERC20(rewardToken).balanceOf(address(this)) - rvar[1];\\r\\n    if (claimReward) {\\r\\n      (rvar[6], rvar[7]) = ILCPoolUniV2Ledger(ledger).getSingleReward(info.account, info.meta, info.basketId, rvar[1], false);\\r\\n    }\\r\\n    rvar[1] += ILCPoolUniV2Ledger(ledger).getLastRewardAmount(info.meta);\\r\\n\\r\\n    rvar[1] = _distributeFee(info.basketId, rewardToken, rvar[1], 2);\\r\\n    rvar[1] = rvar[1] >= rvar[7] ? rvar[1] - rvar[7] : 0;\\r\\n    rvar[3] = rvar[1]; // reserveReward\\r\\n\\r\\n    if (reinvestAble && rvar[1] >= reinvestEdge) {\\r\\n      rvar[3] = IERC20(rewardToken).balanceOf(address(this));\\r\\n      (rvar[4], rvar[5]) = _depositSwap(rewardToken, rvar[1], info.pair, mtoken, percents, paths);\\r\\n      (rvar[2], , ) = _increaseLiquidity(info.meta, info.pair, rvar[4], rvar[5], minAmounts[0], minAmounts[1]);\\r\\n      rvar[3] = rvar[1] + IERC20(rewardToken).balanceOf(address(this)) - rvar[3];\\r\\n      emit ReInvest(info.pair[0], info.pair[1], info.meta, rvar[1], rvar[2]);\\r\\n    }\\r\\n    return (rvar[2], rvar[1], rvar[3], rvar[6], rvar[7]);\\r\\n  }\\r\\n\\r\\n  function _rewardsAvailable(uint256 poolId) public view returns (uint256) {\\r\\n    string memory signature = StringUtils.concat(pendingRewardsFunctionName, \\\"(uint256,address)\\\");\\r\\n    bytes memory result = Address.functionStaticCall(\\r\\n      v2MasterChef, \\r\\n      abi.encodeWithSignature(\\r\\n        signature,\\r\\n        poolId,\\r\\n        address(this)\\r\\n      )\\r\\n    );  \\r\\n    return abi.decode(result, (uint256));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * return tokenId, liquidity\\r\\n   */\\r\\n  function _deposit(\\r\\n    Operator calldata info,\\r\\n    uint256 iAmount,\\r\\n    address[2] calldata mtoken,\\r\\n    uint256[2] calldata percents,\\r\\n    swapPath[3] calldata paths,\\r\\n    uint256[2] calldata minAmounts\\r\\n  ) internal returns(uint256) {\\r\\n    (uint256 amount0, uint256 amount1) = _depositSwap(info.token, iAmount, info.pair, mtoken, percents, paths);\\r\\n    uint256 liquidity = 0;\\r\\n    uint256[] memory amount = new uint256[](2);\\r\\n    (liquidity, amount[0], amount[1]) = _increaseLiquidity(info.meta, info.pair, amount0, amount1, minAmounts[0], minAmounts[1]);\\r\\n    _refundReserveToken(info.account, info.pair[0], info.pair[1], amount0-amount[0], amount1-amount[1]);\\r\\n    emit Deposit(info.meta, liquidity);\\r\\n    return liquidity;\\r\\n  }\\r\\n\\r\\n  function _increaseLiquidity(\\r\\n    uint256 tokenId,\\r\\n    address[2] calldata tokens,\\r\\n    uint256 amount0ToAdd,\\r\\n    uint256 amount1ToAdd,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min\\r\\n  ) internal returns (uint256 liquidity, uint256 amount0, uint256 amount1) {\\r\\n    _approveTokenIfNeeded(tokens[0], v2Router, amount0ToAdd);\\r\\n    _approveTokenIfNeeded(tokens[1], v2Router, amount1ToAdd);\\r\\n    (amount0, amount1, liquidity) = IUniswapV2Router01(v2Router).addLiquidity(\\r\\n      tokens[0],\\r\\n      tokens[1],\\r\\n      amount0ToAdd,\\r\\n      amount1ToAdd,\\r\\n      amount0Min,\\r\\n      amount1Min,\\r\\n      address(this),\\r\\n      block.timestamp\\r\\n    );\\r\\n\\r\\n    address pair = _getPair(tokens[0], tokens[1]);\\r\\n    _approveTokenIfNeeded(pair, v2MasterChef, liquidity);\\r\\n    IMasterChef(v2MasterChef).deposit(tokenId, liquidity);\\r\\n  }\\r\\n\\r\\n  function _getPair(address token0, address token1) internal view returns(address) {\\r\\n    address factory = IUniswapV2Router01(v2Router).factory();\\r\\n    return IUniswapV2Factory(factory).getPair(token0, token1);\\r\\n  }\\r\\n\\r\\n  function _refundReserveToken(address account, address token0, address token1, uint256 amount0, uint256 amount1) internal {\\r\\n    if (amount0 > 0) {\\r\\n      IERC20(token0).safeTransfer(account, amount0);\\r\\n    }\\r\\n    if (amount1 > 0) {\\r\\n      IERC20(token1).safeTransfer(account, amount1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _withdrawSwap(\\r\\n    address tokenOut,\\r\\n    address[2] memory tokens,\\r\\n    uint256[2] memory amount,\\r\\n    address[2] memory mTokens,\\r\\n    swapPath[3] memory paths\\r\\n  ) internal returns(uint256) {\\r\\n    uint256 amountM0 = amount[0];\\r\\n    uint256 amountM1 = amount[1];\\r\\n    if (paths[2].path.length > 0) {\\r\\n      _approveTokenIfNeeded(tokens[1], swapRouter, amount[1]);\\r\\n      (, amountM1) = ISwapPlusv1(swapRouter).swap(tokens[1], amount[1], mTokens[1], address(this), paths[2].path);\\r\\n    }\\r\\n\\r\\n    if (paths[1].path.length == 0) {\\r\\n      return amount[0] + amountM1;\\r\\n    }\\r\\n    else {\\r\\n      if (mTokens[1] == tokens[0]) {\\r\\n        amount[0] += amountM1;\\r\\n      }\\r\\n      _approveTokenIfNeeded(tokens[0], swapRouter, amount[0]);\\r\\n      (, amountM0) = ISwapPlusv1(swapRouter).swap(tokens[0], amount[0], mTokens[0], address(this), paths[1].path);\\r\\n    }\\r\\n\\r\\n    if (paths[0].path.length == 0) {\\r\\n      if (mTokens[0] == mTokens[1]) return amountM0+amountM1;\\r\\n      else return amountM0;\\r\\n    }\\r\\n    else {\\r\\n      _approveTokenIfNeeded(mTokens[0], swapRouter, amountM0+amountM1);\\r\\n      (, amountM0) = ISwapPlusv1(swapRouter).swap(mTokens[0], amountM0+amountM1, tokenOut, address(this), paths[0].path);\\r\\n      return amountM0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * return tokenId, withdraw liquidity amount, receive token amount\\r\\n   */\\r\\n  function _withdraw(\\r\\n    Operator calldata info,\\r\\n    uint256 extraLp,\\r\\n    address[2] memory mtoken,\\r\\n    swapPath[3] memory paths,\\r\\n    uint256[2] memory minAmounts\\r\\n  ) internal returns(uint256, uint256, uint256) {\\r\\n    uint256 withdrawAmount = info.amount;\\r\\n    uint256 userLiquidity = ILCPoolUniV2Ledger(ledger).getUserLiquidity(info.account, info.meta, info.basketId);\\r\\n    if (userLiquidity < withdrawAmount) {\\r\\n      withdrawAmount = userLiquidity;\\r\\n    }\\r\\n    uint256[] memory amount = new uint256[](3);\\r\\n    withdrawAmount += extraLp;\\r\\n    (uint256 liquidity0, ) = IMasterChef(v2MasterChef).userInfo(info.meta, address(this));\\r\\n    if (liquidity0 < withdrawAmount) {\\r\\n      withdrawAmount = liquidity0;\\r\\n    }\\r\\n    if (withdrawAmount > 0) {\\r\\n      (amount[0], amount[1]) = _decreaseLiquidity(info.meta, info.pair, withdrawAmount, minAmounts[0], minAmounts[1]);\\r\\n      amount[2] = _withdrawSwap(info.token, info.pair, [amount[0], amount[1]], mtoken, paths);\\r\\n      emit Withdraw(info.meta, withdrawAmount, amount[2]);\\r\\n      return (info.meta, withdrawAmount, amount[2]);\\r\\n    }\\r\\n    else {\\r\\n      return (info.meta, withdrawAmount, 0);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _decreaseLiquidity(\\r\\n    uint256 tokenId,\\r\\n    address[2] calldata tokens,\\r\\n    uint256 liquidity,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min\\r\\n  ) internal returns (uint256, uint256) {\\r\\n    address pair = _getPair(tokens[0], tokens[1]);\\r\\n    uint256 balanceLP = IERC20(pair).balanceOf(address(this));\\r\\n    IMasterChef(v2MasterChef).withdraw(tokenId, liquidity);\\r\\n    liquidity = IERC20(pair).balanceOf(address(this)) - balanceLP;\\r\\n\\r\\n    _approveTokenIfNeeded(pair, v2Router, liquidity);\\r\\n\\r\\n    return IUniswapV2Router01(v2Router).removeLiquidity(\\r\\n      tokens[0],\\r\\n      tokens[1],\\r\\n      liquidity,\\r\\n      amount0Min,\\r\\n      amount1Min,\\r\\n      address(this),\\r\\n      block.timestamp\\r\\n    );\\r\\n  }\\r\\n\\r\\n  // mode 0: withdraw 1: deposit 2: reward\\r\\n  function _distributeFee(uint256 basketId, address token, uint256 amount, uint256 mode) internal returns(uint256) {\\r\\n    uint256[] memory fvar = new uint256[](4);\\r\\n    fvar[0] = 0; // totalFee\\r\\n    fvar[1] = 0; // baseFee\\r\\n    if (mode == 0) {\\r\\n      (fvar[0], fvar[1]) = IFeeTierStrate(feeStrate).getWithdrawFee(basketId);\\r\\n    }\\r\\n    else if (mode == 1) {\\r\\n      (fvar[0], fvar[1]) = IFeeTierStrate(feeStrate).getDepositFee(basketId);\\r\\n    }\\r\\n    else if (mode == 2) {\\r\\n      (fvar[0], fvar[1]) = IFeeTierStrate(feeStrate).getTotalFee(basketId);\\r\\n    }\\r\\n\\r\\n    fvar[2] = amount; // rewardReserve\\r\\n    require(fvar[1] > 0, \\\"LC pool: wrong fee configure\\\");\\r\\n    fvar[3] = amount * fvar[0] / fvar[1]; // rewardLc\\r\\n\\r\\n    if (fvar[3] > 0) {\\r\\n      uint256[] memory feeIndexs = IFeeTierStrate(feeStrate).getAllTier();\\r\\n      uint256 len = feeIndexs.length;\\r\\n      uint256 maxFee = IFeeTierStrate(feeStrate).getMaxFee();\\r\\n      for (uint256 i=0; i<len; i++) {\\r\\n        (address feeAccount, ,uint256 fee) = IFeeTierStrate(feeStrate).getTier(feeIndexs[i]);\\r\\n        uint256 feeAmount = fvar[3] * fee / maxFee;\\r\\n        if (feeAmount > 0 && fvar[2] >= feeAmount && IERC20(token).balanceOf(address(this)) > feeAmount) {\\r\\n          IERC20(token).safeTransfer(feeAccount, feeAmount);\\r\\n          emit LcFee(feeAccount, token, feeAmount);\\r\\n          fvar[2] -= feeAmount;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    return fvar[2];\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setOperator(address account, bool access) public onlyManager {\\r\\n    operators[account] = access;\\r\\n  }\\r\\n\\r\\n  function setFeeStrate(address _feeStrate) external onlyManager {\\r\\n    require(_feeStrate != address(0), \\\"LC pool: Fee Strate\\\");\\r\\n    feeStrate = _feeStrate;\\r\\n  }\\r\\n\\r\\n  function setSwapRouter(address _swapRouter) external onlyManager {\\r\\n    require(_swapRouter != address(0), \\\"LC pool: Swap Router\\\");\\r\\n    swapRouter = _swapRouter;\\r\\n  }\\r\\n\\r\\n  function setReinvestInfo(bool able, uint256 edge) public onlyManager {\\r\\n    reinvestAble = able;\\r\\n    reinvestEdge = edge;\\r\\n  }\\r\\n\\r\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\\r\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\r\\n      IERC20(token).safeApprove(spender, 0);\\r\\n      IERC20(token).safeApprove(spender, type(uint256).max);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/StringUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary StringUtils {\\r\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\r\\n    return string(abi.encodePacked(a, b));\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"./draft-IERC20Permit.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n  function deposit() external payable;\\r\\n  function withdraw(uint amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint amountADesired,\\r\\n    uint amountBDesired,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n  \\r\\n  function removeLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n  function feeTo() external view returns (address);\\r\\n  function feeToSetter() external view returns (address);\\r\\n\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n  function allPairs(uint) external view returns (address pair);\\r\\n  function allPairsLength() external view returns (uint);\\r\\n\\r\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n  function setFeeTo(address) external;\\r\\n  function setFeeToSetter(address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/ISwapPlusv1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface ISwapPlusv1 {\\r\\n  struct swapRouter {\\r\\n    string platform;\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint256 amountOutMin;\\r\\n    uint256 meta; // fee, flag(stable), 0=v2\\r\\n    uint256 percent;\\r\\n  }\\r\\n  struct swapLine {\\r\\n    swapRouter[] swaps;\\r\\n  }\\r\\n  struct swapBlock {\\r\\n    swapLine[] lines;\\r\\n  }\\r\\n\\r\\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) external payable returns(uint256, uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IMasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IMasterChef {\\r\\n  function deposit(uint256 _pid, uint256 _amount) external;\\r\\n  function withdraw(uint256 _pid, uint256 _amount) external;\\r\\n  function enterStaking(uint256 _amount) external;\\r\\n  function leaveStaking(uint256 _amount) external;\\r\\n  function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\\r\\n  function emergencyWithdraw(uint256 _pid) external;\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/ILCPoolUniV2Ledger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface ILCPoolUniV2Ledger {\\r\\n  function getLastRewardAmount(uint256 poolId) external view returns(uint256);\\r\\n  function getUserLiquidity(address account, uint256 poolId, uint256 basketId) external view returns(uint256);\\r\\n\\r\\n  function updateInfo(\\r\\n    address acc,\\r\\n    uint256 tId,\\r\\n    uint256 bId,\\r\\n    uint256 liquidity,\\r\\n    uint256 reward,\\r\\n    uint256 rewardAfter,\\r\\n    uint256 exLp,\\r\\n    bool increase\\r\\n  ) external;\\r\\n\\r\\n  function getSingleReward(address acc, uint256 poolId, uint256 basketId, uint256 currentReward, bool cutfee)\\r\\n    external view returns(uint256, uint256);\\r\\n  function getReward(address account, uint256[] memory poolId, uint256[] memory basketIds) external view\\r\\n    returns(uint256[] memory, uint256[] memory);\\r\\n  function poolInfoLength(uint256 poolId) external view returns(uint256);\\r\\n  function reInvestInfoLength(uint256 poolId) external view returns(uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IFeeTierStrate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IFeeTierStrate {\\r\\n  function getMaxFee() external view returns(uint256);\\r\\n  function getDepositFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getTotalFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getWithdrawFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getAllTier() external view returns(uint256[] memory);\\r\\n  function getTier(uint256 index) external view returns(address, string memory, uint256);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_v2Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_v2MasterChef\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeStrate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reward\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_pendingRewardsFunctionName\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extraLp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquiidty\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LcFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extraLp\",\"type\":\"uint256\"}],\"name\":\"ReInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RemovePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquiidty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"_rewardsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"pair\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LCPoolUniV2.Operator\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"address[2][2]\",\"name\":\"mtoken\",\"type\":\"address[2][2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"percent\",\"type\":\"uint256[2][2]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolUniV2.swapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolUniV2.swapPath[3]\",\"name\":\"rpaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"minAmounts\",\"type\":\"uint256[2][2]\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeStrate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ledger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewardsFunctionName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestAble\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestEdge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeStrate\",\"type\":\"address\"}],\"name\":\"setFeeStrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"able\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"edge\",\"type\":\"uint256\"}],\"name\":\"setReinvestInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2MasterChef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2Router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"pair\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LCPoolUniV2.Operator\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"address[2][2]\",\"name\":\"mtoken\",\"type\":\"address[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"percent\",\"type\":\"uint256[2]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolUniV2.swapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolUniV2.swapPath[3]\",\"name\":\"rpaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"minAmounts\",\"type\":\"uint256[2][2]\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LCPoolUniV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f000000000000000000000000c2edad668740f1aa35e4d8f227fb8e17dca888cd00000000000000000000000091f6aa43c190e317e4d02698127aa7a629cf4b23000000000000000000000000471200ce99a9608b5676660c98d31167825af1de00000000000000000000000022011bf1a77a618e3c6bb1c0d134f72ad77d4184000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe20000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000c70656e64696e6753757368690000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}