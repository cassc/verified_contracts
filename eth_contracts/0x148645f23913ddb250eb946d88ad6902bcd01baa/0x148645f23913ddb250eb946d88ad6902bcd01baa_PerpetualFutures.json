{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PerpetualFutures.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport './interfaces/IFeeReducer.sol';\\nimport './interfaces/IPerpetualFutures.sol';\\nimport './libraries/BokkyPooBahsDateTimeLibrary.sol';\\nimport './pfYDF.sol';\\nimport './PerpsTriggerOrders.sol';\\nimport './PerpetualFuturesUnsettledHandler.sol';\\n\\ncontract PerpetualFutures is Ownable, PerpsTriggerOrders {\\n  using SafeERC20 for IERC20Metadata;\\n\\n  uint256 constant FACTOR = 10**18;\\n  uint256 constant PERC_DEN = 100000;\\n\\n  pfYDF public perpsNft;\\n  IFeeReducer public feeReducer;\\n\\n  bool public tradingEnabled;\\n\\n  mapping(address => bool) public relays;\\n\\n  address public mainCollateralToken =\\n    0x30dcBa0405004cF124045793E1933C798Af9E66a;\\n  mapping(address => bool) _validColl;\\n  address[] _allCollTokens;\\n  mapping(address => uint256) _allCollTokensInd;\\n\\n  uint16 public maxLeverage = 1500; // 150x\\n  // indexIdx => max leverage\\n  mapping(uint256 => uint16) public maxLevIdxOverride;\\n\\n  uint256 public maxProfitPerc = PERC_DEN * 10; // 10x collateral amount\\n  uint256 public openFeeETH;\\n  uint256 public openFeePositionSize = (PERC_DEN * 1) / 1000; // 0.1%\\n  uint256 public closeFeePositionSize = (PERC_DEN * 1) / 1000; // 0.1%\\n  uint256 public closeFeePerDurationUnit = 1 hours;\\n  uint256 public closeFeePerDuration = (PERC_DEN * 5) / 100000; // 0.005% / hour\\n\\n  // collateral token => amount\\n  mapping(address => uint256) public amtOpenLong;\\n  mapping(address => uint256) public amtOpenShort;\\n  mapping(address => uint256) public maxCollateralOpenDiff;\\n  mapping(address => uint256) public minCollateralAmount;\\n\\n  IPerpetualFutures.Index[] public indexes;\\n\\n  uint256 public pendingPositionExp = 10 minutes;\\n  IPerpetualFutures.ActionRequest[] public pendingOpenPositions;\\n  IPerpetualFutures.ActionRequest[] public pendingClosePositions; // tokenId[]\\n  mapping(uint256 => bool) _hasPendingCloseRequest;\\n\\n  // tokenId => Position\\n  mapping(uint256 => IPerpetualFutures.Position) public positions;\\n  // tokenId[]\\n  uint256[] public allOpenPositions;\\n  // tokenId => allOpenPositions index\\n  mapping(uint256 => uint256) internal _openPositionsIdx;\\n\\n  PerpetualFuturesUnsettledHandler public unsettledHandler;\\n\\n  event CloseUnsettledPosition(uint256 indexed tokenId);\\n  event OpenPositionRequest(\\n    address indexed user,\\n    uint256 requestIdx,\\n    uint256 indexPriceStartDesired,\\n    uint256 positionCollateral,\\n    bool isLong,\\n    uint256 leverage\\n  );\\n  event OpenPosition(\\n    uint256 indexed tokenId,\\n    address indexed user,\\n    uint256 indexPriceStart,\\n    uint256 positionCollateral,\\n    bool isLong,\\n    uint256 leverage\\n  );\\n  event ClosePositionRequest(\\n    uint256 indexed tokenId,\\n    address indexed user,\\n    uint256 requestIdx,\\n    uint256 collateralReduction\\n  );\\n  event ClosePosition(\\n    uint256 indexed tokenId,\\n    address indexed user,\\n    uint256 indexPriceStart,\\n    uint256 indexPriceSettle,\\n    uint256 amountWon,\\n    uint256 amountLost\\n  );\\n  event LiquidatePosition(uint256 indexed tokenId);\\n  event ClosePositionFromTriggerOrder(uint256 indexed tokenId);\\n  event SettlePosition(address indexed to, uint256 amountSettled);\\n\\n  modifier onlyRelay() {\\n    require(relays[_msgSender()], 'RELAY');\\n    _;\\n  }\\n\\n  modifier onlyUnsettled() {\\n    require(_msgSender() == address(unsettledHandler), 'UNSETTLED');\\n    _;\\n  }\\n\\n  constructor() {\\n    perpsNft = new pfYDF();\\n    perpsNft.transferOwnership(_msgSender());\\n    _setPfydf(address(perpsNft));\\n\\n    unsettledHandler = new PerpetualFuturesUnsettledHandler();\\n  }\\n\\n  function getAllIndexes()\\n    external\\n    view\\n    returns (IPerpetualFutures.Index[] memory)\\n  {\\n    return indexes;\\n  }\\n\\n  function getAllValidCollateralTokens()\\n    external\\n    view\\n    returns (address[] memory)\\n  {\\n    return _allCollTokens;\\n  }\\n\\n  function getAllOpenPositions() external view returns (uint256[] memory) {\\n    return allOpenPositions;\\n  }\\n\\n  function getOpenPositionRequests()\\n    external\\n    view\\n    returns (IPerpetualFutures.ActionRequest[] memory)\\n  {\\n    return pendingOpenPositions;\\n  }\\n\\n  function getClosePositionRequests()\\n    external\\n    view\\n    returns (IPerpetualFutures.ActionRequest[] memory)\\n  {\\n    return pendingClosePositions;\\n  }\\n\\n  function openPositionRequest(\\n    address _collToken,\\n    uint256 _indexInd,\\n    uint256 _desiredPrice,\\n    uint256 _slippage, // 1 == 0.1%, 10 == 1%\\n    uint256 _collateral,\\n    uint16 _leverage, // 10 == 1x, 1000 == 100x\\n    bool _isLong,\\n    uint256 _tokenId, // optional: if adding margin\\n    address _owner // optional: if opening for another wallet\\n  ) external payable {\\n    require(tradingEnabled);\\n    require(indexes[_indexInd].isActive, 'INVIDX');\\n    require(_leverage >= 10);\\n    require(_collateral >= minCollateralAmount[_collToken], 'MINCOLL');\\n    require(_canOpenAgainstIndex(_indexInd, 0), 'INDOOB1');\\n    // TODO: include address(0) if we support ETH as collateral\\n    require(\\n      _collToken == mainCollateralToken || _validColl[_collToken],\\n      'POSTOKEN1'\\n    );\\n    if (maxLevIdxOverride[_indexInd] > 0) {\\n      require(_leverage <= maxLevIdxOverride[_indexInd], 'LEV1');\\n    } else {\\n      require(_leverage <= maxLeverage, 'LEV2');\\n    }\\n    if (openFeeETH > 0) {\\n      require(msg.value == openFeeETH, 'OPENFEE');\\n      (bool _s, ) = payable(owner()).call{ value: openFeeETH }('');\\n      require(_s, 'FEESEND');\\n    }\\n    if (_tokenId > 0) {\\n      require(perpsNft.ownerOf(_tokenId) == _msgSender(), 'OWNER');\\n    }\\n\\n    pendingOpenPositions.push(\\n      IPerpetualFutures.ActionRequest({\\n        timestamp: block.timestamp,\\n        requester: _msgSender(),\\n        tokenId: _tokenId,\\n        indexIdx: _indexInd,\\n        owner: _owner == address(0) ? _msgSender() : _owner,\\n        collateralToken: _collToken,\\n        collateralAmount: _collateral,\\n        isLong: _isLong,\\n        leverage: _leverage,\\n        openSlippage: _slippage,\\n        desiredIdxPriceStart: _desiredPrice\\n      })\\n    );\\n    emit OpenPositionRequest(\\n      _msgSender(),\\n      pendingOpenPositions.length - 1,\\n      _desiredPrice,\\n      _collateral,\\n      _isLong,\\n      _leverage\\n    );\\n  }\\n\\n  function openPositionRequestCancel(uint256 _openReqIdx) external {\\n    require(\\n      _msgSender() == pendingOpenPositions[_openReqIdx].requester ||\\n        block.timestamp >\\n        pendingOpenPositions[_openReqIdx].timestamp + pendingPositionExp\\n    );\\n    pendingOpenPositions[_openReqIdx] = pendingOpenPositions[\\n      pendingOpenPositions.length - 1\\n    ];\\n    pendingOpenPositions.pop();\\n  }\\n\\n  function openPosition(uint256 _openPrice, uint256 _pendingIdx)\\n    external\\n    onlyRelay\\n  {\\n    IPerpetualFutures.ActionRequest memory _ar = pendingOpenPositions[\\n      _pendingIdx\\n    ];\\n    pendingOpenPositions[_pendingIdx] = pendingOpenPositions[\\n      pendingOpenPositions.length - 1\\n    ];\\n    pendingOpenPositions.pop();\\n\\n    (uint256 _openFee, uint256 _finalColl) = _processCollateral(\\n      _ar.requester,\\n      _ar.tokenId == 0\\n        ? _ar.collateralToken\\n        : positions[_ar.tokenId].collateralToken,\\n      _ar.collateralAmount,\\n      _ar.leverage\\n    );\\n\\n    _slippageValidation(\\n      _ar.desiredIdxPriceStart,\\n      _openPrice,\\n      _ar.openSlippage,\\n      _ar.isLong\\n    );\\n\\n    uint256 _newTokenId = _ar.tokenId == 0\\n      ? perpsNft.mint(_ar.owner)\\n      : _ar.tokenId;\\n    uint256 _currentCollateral = positions[_newTokenId].collateralAmount;\\n    uint16 _currentLeverage = positions[_newTokenId].leverage;\\n    IPerpetualFutures.Position storage _pos = _setOpenPosition(\\n      _newTokenId,\\n      _openFee,\\n      _openPrice,\\n      _finalColl,\\n      _ar\\n    );\\n    _validateAndUpdateOpenAmounts(\\n      _newTokenId,\\n      _getPositionAmount(_currentCollateral, _currentLeverage),\\n      _getPositionAmount(_pos.collateralAmount, _pos.leverage)\\n    );\\n    emit OpenPosition(\\n      _newTokenId,\\n      _ar.owner,\\n      _openPrice,\\n      _finalColl,\\n      _pos.isLong,\\n      _pos.leverage\\n    );\\n  }\\n\\n  function closePositionRequest(uint256 _tokenId, uint256 _collateralReduction)\\n    external\\n  {\\n    address _user = perpsNft.ownerOf(_tokenId);\\n    require(_msgSender() == _user);\\n    require(!_hasPendingCloseRequest[_tokenId]);\\n    _hasPendingCloseRequest[_tokenId] = true;\\n    pendingClosePositions.push(\\n      IPerpetualFutures.ActionRequest({\\n        timestamp: block.timestamp,\\n        requester: _msgSender(),\\n        tokenId: _tokenId,\\n        collateralAmount: _collateralReduction,\\n        // noops\\n        indexIdx: positions[_tokenId].indexIdx,\\n        owner: _msgSender(),\\n        collateralToken: address(0),\\n        isLong: false,\\n        leverage: 0,\\n        openSlippage: 0,\\n        desiredIdxPriceStart: 0\\n      })\\n    );\\n    emit ClosePositionRequest(\\n      _tokenId,\\n      _msgSender(),\\n      pendingClosePositions.length - 1,\\n      _collateralReduction\\n    );\\n  }\\n\\n  function closePositionRequestCancel(uint256 _closeReqIdx) external {\\n    uint256 _tokenId = pendingClosePositions[_closeReqIdx].tokenId;\\n    if (\\n      block.timestamp <=\\n      pendingClosePositions[_closeReqIdx].timestamp + pendingPositionExp\\n    ) {\\n      address _user = perpsNft.ownerOf(_tokenId);\\n      require(_msgSender() == _user);\\n    }\\n    delete _hasPendingCloseRequest[_tokenId];\\n    pendingClosePositions[_closeReqIdx] = pendingClosePositions[\\n      pendingClosePositions.length - 1\\n    ];\\n    pendingClosePositions.pop();\\n  }\\n\\n  function closePosition(uint256 _closePrice, uint256 _pendingCloseIdx)\\n    external\\n    onlyRelay\\n  {\\n    uint256 _tokenId = pendingClosePositions[_pendingCloseIdx].tokenId;\\n    require(_tokenId > 0);\\n    uint256 _collateralReduction = pendingClosePositions[_pendingCloseIdx]\\n      .collateralAmount;\\n    delete _hasPendingCloseRequest[_tokenId];\\n    pendingClosePositions[_pendingCloseIdx] = pendingClosePositions[\\n      pendingClosePositions.length - 1\\n    ];\\n    pendingClosePositions.pop();\\n    _closePosition(_tokenId, _closePrice, _collateralReduction);\\n  }\\n\\n  function _closePosition(\\n    uint256 _tokenId,\\n    uint256 _currentPrice,\\n    uint256 _collateralReduction // 0 for closing completely\\n  ) internal {\\n    address _user = perpsNft.ownerOf(_tokenId);\\n    require(perpsNft.doesTokenExist(_tokenId));\\n\\n    uint256 _prevCollateral = positions[_tokenId].collateralAmount;\\n    uint16 _prevLeverage = positions[_tokenId].leverage;\\n    bool _isClosed = _getAndClosePositionPLInfo(\\n      _tokenId,\\n      _user,\\n      _currentPrice,\\n      _collateralReduction\\n    );\\n    if (_isClosed) {\\n      _updateCloseAmounts(\\n        _tokenId,\\n        _getPositionAmount(_prevCollateral, _prevLeverage),\\n        0\\n      );\\n      _removeOpenPosition(_tokenId);\\n      perpsNft.burn(_tokenId);\\n      emit ClosePosition(\\n        _tokenId,\\n        _user,\\n        positions[_tokenId].indexPriceStart,\\n        positions[_tokenId].indexPriceSettle,\\n        positions[_tokenId].amountWon,\\n        positions[_tokenId].amountLost\\n      );\\n    } else {\\n      _updateCloseAmounts(\\n        _tokenId,\\n        _getPositionAmount(_prevCollateral, _prevLeverage),\\n        _getPositionAmount(\\n          positions[_tokenId].collateralAmount,\\n          positions[_tokenId].leverage\\n        )\\n      );\\n    }\\n  }\\n\\n  function executeSettlement(\\n    uint256 tokenId,\\n    address _to,\\n    uint256 _amount\\n  ) external onlyUnsettled {\\n    positions[tokenId].mainCollateralSettledAmount = _amount;\\n    IERC20Metadata(mainCollateralToken).safeTransfer(_to, _amount);\\n    emit SettlePosition(_to, _amount);\\n  }\\n\\n  function getIndexAndPLInfo(uint256 _tokenId, uint256 _currentIndexPrice)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      bool,\\n      bool\\n    )\\n  {\\n    IPerpetualFutures.Position memory _position = positions[_tokenId];\\n    return\\n      _getIdxAndPLInfo(\\n        _position.indexPriceStart,\\n        _currentIndexPrice,\\n        _position.collateralAmount,\\n        _position.leverage,\\n        _position.isLong\\n      );\\n  }\\n\\n  function _getIdxAndPLInfo(\\n    uint256 _openIndexPrice,\\n    uint256 _currentIndexPrice,\\n    uint256 _collateralAmount,\\n    uint16 _leverage,\\n    bool _isLong\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      bool,\\n      bool\\n    )\\n  {\\n    bool _settlePriceIsHigher = _currentIndexPrice > _openIndexPrice;\\n    uint256 _indexAbsDiffFromOpen = _settlePriceIsHigher\\n      ? _currentIndexPrice - _openIndexPrice\\n      : _openIndexPrice - _currentIndexPrice;\\n    uint256 _absolutePL = (_getPositionAmount(_collateralAmount, _leverage) *\\n      _indexAbsDiffFromOpen) / _openIndexPrice;\\n    bool _isProfit = _isLong ? _settlePriceIsHigher : !_settlePriceIsHigher;\\n\\n    bool _isMax;\\n    if (_isProfit) {\\n      uint256 _maxProfit = (_collateralAmount * maxProfitPerc) / PERC_DEN;\\n      if (_absolutePL > _maxProfit) {\\n        _absolutePL = _maxProfit;\\n        _isMax = true;\\n      }\\n    }\\n\\n    uint256 _amountReturnToUser = _collateralAmount;\\n    if (_isProfit) {\\n      _amountReturnToUser += _absolutePL;\\n    } else {\\n      if (_absolutePL > _amountReturnToUser) {\\n        _amountReturnToUser = 0;\\n      } else {\\n        _amountReturnToUser -= _absolutePL;\\n      }\\n    }\\n    return (_amountReturnToUser, _absolutePL, _isProfit, _isMax);\\n  }\\n\\n  function getLiquidationPriceChange(uint256 _tokenId)\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    // 85% of exact liquidation as buffer\\n    // NOTE: _position.leverage == 10 means 1x\\n    // Ex. price start == 100, leverage == 15 (1.5x)\\n    // (priceStart / (15 / 10)) * (8.5 / 10)\\n    // (priceStart * 10 / 15) * (8.5 / 10)\\n    // (priceStart / 15) * 8.5\\n    // (priceStart * 8.5) / 15\\n    return\\n      (positions[_tokenId].indexPriceStart * 85) /\\n      10 /\\n      positions[_tokenId].leverage;\\n  }\\n\\n  function getPositionCloseFees(uint256 _tokenId)\\n    external\\n    view\\n    returns (uint256, uint256)\\n  {\\n    return\\n      _getCloseFees(\\n        _tokenId,\\n        positions[_tokenId].collateralToken,\\n        positions[_tokenId].collateralAmount,\\n        positions[_tokenId].leverage,\\n        positions[_tokenId].lifecycle.openTime\\n      );\\n  }\\n\\n  function _getCloseFees(\\n    uint256 _tokenId,\\n    address _collateral,\\n    uint256 _amount,\\n    uint16 _leverage,\\n    uint256 _openTime\\n  ) internal view returns (uint256, uint256) {\\n    address _owner = perpsNft.ownerOf(_tokenId);\\n    (uint256 _percentOff, uint256 _percOffDenomenator) = getFeeDiscount(\\n      _owner,\\n      _collateral,\\n      _amount,\\n      _leverage\\n    );\\n    uint256 _positionAmount = _getPositionAmount(_amount, _leverage);\\n    uint256 _closingFeePosition = (_positionAmount * closeFeePositionSize) /\\n      PERC_DEN;\\n    uint256 _closingFeeDurationPerUnit = (_positionAmount *\\n      closeFeePerDuration) / PERC_DEN;\\n    uint256 _closingFeeDurationTotal = (_closingFeeDurationPerUnit *\\n      (block.timestamp - _openTime)) / closeFeePerDurationUnit;\\n\\n    // user has discount from fees\\n    if (_percentOff > 0) {\\n      _closingFeePosition -=\\n        (_closingFeePosition * _percentOff) /\\n        _percOffDenomenator;\\n      _closingFeeDurationTotal -=\\n        (_closingFeeDurationTotal * _percentOff) /\\n        _percOffDenomenator;\\n    }\\n    return (_closingFeePosition, _closingFeeDurationTotal);\\n  }\\n\\n  function setValidCollateralToken(address _token, bool _isValid)\\n    external\\n    onlyOwner\\n  {\\n    require(_validColl[_token] != _isValid);\\n    _validColl[_token] = _isValid;\\n    if (_isValid) {\\n      _allCollTokensInd[_token] = _allCollTokens.length;\\n      _allCollTokens.push(_token);\\n    } else {\\n      uint256 _ind = _allCollTokensInd[_token];\\n      delete _allCollTokensInd[_token];\\n      _allCollTokens[_ind] = _allCollTokens[_allCollTokens.length - 1];\\n      _allCollTokens.pop();\\n    }\\n  }\\n\\n  // 10 == 1x, 1000 == 100x, etc.\\n  function setMaxLeverage(uint16 _max) external onlyOwner {\\n    require(_max <= 2500);\\n    maxLeverage = _max;\\n  }\\n\\n  function setMaxLevIdxOverride(uint256 _idx, uint16 _max) external onlyOwner {\\n    require(_max <= 2500);\\n    maxLevIdxOverride[_idx] = _max;\\n  }\\n\\n  function setMaxProfitPerc(uint256 _max) external onlyOwner {\\n    require(_max >= PERC_DEN);\\n    maxProfitPerc = _max;\\n  }\\n\\n  function setMaxTriggerOrders(uint8 _max) external onlyOwner {\\n    maxTriggerOrders = _max;\\n  }\\n\\n  function setOpenFeePositionSize(uint256 _percentage) external onlyOwner {\\n    require(_percentage < (PERC_DEN * 10) / 100);\\n    openFeePositionSize = _percentage;\\n  }\\n\\n  function setOpenFeeETH(uint256 _wei) external onlyOwner {\\n    openFeeETH = _wei;\\n  }\\n\\n  function setCloseFeePositionSize(uint256 _percentage) external onlyOwner {\\n    require(_percentage < (PERC_DEN * 10) / 100);\\n    closeFeePositionSize = _percentage;\\n  }\\n\\n  function setPendingPositionExp(uint256 _expiration) external onlyOwner {\\n    require(_expiration <= 1 hours);\\n    pendingPositionExp = _expiration;\\n  }\\n\\n  function setCloseFeePositionPerDurationUnit(uint256 _seconds)\\n    external\\n    onlyOwner\\n  {\\n    require(_seconds >= 10 minutes);\\n    closeFeePerDurationUnit = _seconds;\\n  }\\n\\n  function setClosePositionFeePerDuration(uint256 _percentage)\\n    external\\n    onlyOwner\\n  {\\n    require(_percentage < (PERC_DEN * 1) / 100);\\n    closeFeePerDuration = _percentage;\\n  }\\n\\n  function setRelay(address _wallet, bool _isRelay) external onlyOwner {\\n    require(relays[_wallet] != _isRelay);\\n    relays[_wallet] = _isRelay;\\n  }\\n\\n  function setMaxCollateralOpenDiff(address _collateral, uint256 _amount)\\n    external\\n    onlyOwner\\n  {\\n    maxCollateralOpenDiff[_collateral] = _amount;\\n  }\\n\\n  function setMinCollateralAmount(address _collateral, uint256 _amount)\\n    external\\n    onlyOwner\\n  {\\n    minCollateralAmount[_collateral] = _amount;\\n  }\\n\\n  function addIndex(string memory _name) external onlyOwner {\\n    IPerpetualFutures.Index storage _newIndex = indexes.push();\\n    _newIndex.name = _name;\\n    _newIndex.isActive = true;\\n  }\\n\\n  function activateIndex(uint256 _idx) external onlyOwner {\\n    require(_idx < indexes.length);\\n    indexes[_idx].isActive = true;\\n  }\\n\\n  function removeIndex(uint256 _idx) external onlyOwner {\\n    indexes[_idx].isActive = false;\\n  }\\n\\n  function updateIndexOpenTimeBounds(\\n    uint256 _indexInd,\\n    uint256 _dowOpenMin,\\n    uint256 _dowOpenMax,\\n    uint256 _hourOpenMin,\\n    uint256 _hourOpenMax\\n  ) external onlyOwner {\\n    IPerpetualFutures.Index storage _index = indexes[_indexInd];\\n    _index.dowOpenMin = _dowOpenMin;\\n    _index.dowOpenMax = _dowOpenMax;\\n    _index.hourOpenMin = _hourOpenMin;\\n    _index.hourOpenMax = _hourOpenMax;\\n  }\\n\\n  function setTradingEnabled(bool _tradingEnabled) external onlyOwner {\\n    tradingEnabled = _tradingEnabled;\\n  }\\n\\n  function setFeeReducer(IFeeReducer _reducer) external onlyOwner {\\n    feeReducer = _reducer;\\n  }\\n\\n  function processFees(uint256 _amount) external onlyOwner {\\n    IERC20Metadata(mainCollateralToken).safeTransfer(\\n      mainCollateralToken,\\n      _amount\\n    );\\n  }\\n\\n  function checkUpkeep(uint256 _tokenId, uint256 _currentPrice)\\n    external\\n    view\\n    returns (bool upkeepNeeded)\\n  {\\n    (bool _shouldTrigger, ) = shouldPositionCloseFromTrigger(\\n      _tokenId,\\n      _currentPrice\\n    );\\n    return shouldPositionLiquidate(_tokenId, _currentPrice) || _shouldTrigger;\\n  }\\n\\n  function performUpkeep(uint256 _tokenId, uint256 _currentPrice)\\n    external\\n    onlyRelay\\n    returns (bool wasLiquidated)\\n  {\\n    return _checkAndLiquidatePosition(_tokenId, _currentPrice);\\n  }\\n\\n  function _checkAndLiquidatePosition(uint256 _tokenId, uint256 _currentPrice)\\n    internal\\n    returns (bool)\\n  {\\n    bool _shouldLiquidate = shouldPositionLiquidate(_tokenId, _currentPrice);\\n    (\\n      bool _triggerClose,\\n      uint256 _collateralChange\\n    ) = shouldPositionCloseFromTrigger(_tokenId, _currentPrice);\\n    if (_shouldLiquidate || _triggerClose) {\\n      _closePosition(_tokenId, _currentPrice, _collateralChange);\\n\\n      if (_shouldLiquidate) {\\n        emit LiquidatePosition(_tokenId);\\n      } else if (_triggerClose) {\\n        emit ClosePositionFromTriggerOrder(_tokenId);\\n      }\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function getFeeDiscount(\\n    address _wallet,\\n    address _token,\\n    uint256 _amount,\\n    uint16 _leverage\\n  ) public view returns (uint256, uint256) {\\n    return\\n      address(feeReducer) != address(0)\\n        ? feeReducer.percentDiscount(_wallet, _token, _amount, _leverage)\\n        : (0, 0);\\n  }\\n\\n  function _getPositionOpenFee(\\n    address _user,\\n    address _collateralToken,\\n    uint256 _collateral,\\n    uint16 _leverage\\n  ) internal view returns (uint256) {\\n    uint256 _positionPreFee = (_collateral * _leverage) / 10;\\n    uint256 _openFee = (_positionPreFee * openFeePositionSize) / PERC_DEN;\\n    (uint256 _percentOff, uint256 _percOffDenomenator) = getFeeDiscount(\\n      _user,\\n      _collateralToken,\\n      _collateral,\\n      _leverage\\n    );\\n    // user has discount from fees\\n    if (_percentOff > 0) {\\n      _openFee -= (_openFee * _percentOff) / _percOffDenomenator;\\n    }\\n    return _openFee;\\n  }\\n\\n  function _setOpenPosition(\\n    uint256 _tokenId,\\n    uint256 _openFee,\\n    uint256 _openPrice,\\n    uint256 _newCollateral,\\n    IPerpetualFutures.ActionRequest memory _ar\\n  ) internal returns (IPerpetualFutures.Position storage) {\\n    IPerpetualFutures.Position storage _pos = positions[_tokenId];\\n\\n    if (_tokenId == _ar.tokenId) {\\n      // add margin to existing position\\n      uint256 _prevSize = _getPositionAmount(\\n        _pos.collateralAmount,\\n        _pos.leverage\\n      );\\n      uint256 _addedSize = _getPositionAmount(_newCollateral, _ar.leverage);\\n      uint256 _newSize = _prevSize + _addedSize;\\n      (, uint256 _closingFeeDurationTotal) = _getCloseFees(\\n        _tokenId,\\n        _pos.collateralToken,\\n        _pos.collateralAmount,\\n        _pos.leverage,\\n        _pos.lifecycle.openTime\\n      );\\n      _pos.leverage = uint16(\\n        (_newSize * 10) / (_pos.collateralAmount + _newCollateral)\\n      );\\n      _pos.indexPriceStart =\\n        ((_pos.indexPriceStart * _prevSize) + (_openPrice * _addedSize)) /\\n        _newSize;\\n      _pos.lifecycle.closeFees += _closingFeeDurationTotal;\\n    } else {\\n      // new position\\n      _pos.indexIdx = _ar.indexIdx;\\n      _pos.collateralToken = _ar.collateralToken;\\n      _pos.isLong = _ar.isLong;\\n      _pos.leverage = _ar.leverage;\\n      _pos.indexPriceStart = _openPrice;\\n      _openPositionsIdx[_tokenId] = allOpenPositions.length;\\n      allOpenPositions.push(_tokenId);\\n    }\\n    _pos.collateralAmount += _newCollateral;\\n    _pos.lifecycle.openFees += _openFee;\\n    _pos.lifecycle.openTime = block.timestamp; // reset since we already added to closeFees\\n    return _pos;\\n  }\\n\\n  function _removeOpenPosition(uint256 _tokenId) internal {\\n    uint256 _allPositionsIdx = _openPositionsIdx[_tokenId];\\n    uint256 _tokenIdMoving = allOpenPositions[allOpenPositions.length - 1];\\n    delete _openPositionsIdx[_tokenId];\\n    _openPositionsIdx[_tokenIdMoving] = _allPositionsIdx;\\n    allOpenPositions[_allPositionsIdx] = _tokenIdMoving;\\n    allOpenPositions.pop();\\n  }\\n\\n  function _checkAndSettlePosition(\\n    uint256 _tokenId,\\n    address _collateralToken,\\n    uint256 _collateralAmount,\\n    address _closingUser,\\n    uint256 _returnAmount,\\n    bool _isClosing\\n  ) internal {\\n    if (_returnAmount > 0) {\\n      if (_collateralToken == mainCollateralToken) {\\n        positions[_tokenId].isSettled = _isClosing;\\n        IERC20Metadata(_collateralToken).safeTransfer(\\n          _closingUser,\\n          _returnAmount\\n        );\\n      } else {\\n        if (_returnAmount > _collateralAmount) {\\n          if (_collateralToken == address(0)) {\\n            uint256 _before = address(this).balance;\\n            payable(_closingUser).call{ value: _collateralAmount }('');\\n            require(address(this).balance >= _before - _collateralAmount);\\n          } else {\\n            IERC20Metadata(_collateralToken).safeTransfer(\\n              _closingUser,\\n              _collateralAmount\\n            );\\n          }\\n          unsettledHandler.addUnsettledPosition(\\n            _tokenId,\\n            _closingUser,\\n            _collateralToken,\\n            _returnAmount - _collateralAmount\\n          );\\n          emit CloseUnsettledPosition(_tokenId);\\n        } else {\\n          positions[_tokenId].isSettled = _isClosing;\\n          if (_collateralToken == address(0)) {\\n            uint256 _before = address(this).balance;\\n            payable(_closingUser).call{ value: _returnAmount }('');\\n            require(address(this).balance >= _before - _returnAmount);\\n          } else {\\n            IERC20Metadata(_collateralToken).safeTransfer(\\n              _closingUser,\\n              _returnAmount\\n            );\\n          }\\n        }\\n      }\\n    } else {\\n      positions[_tokenId].isSettled = _isClosing;\\n    }\\n  }\\n\\n  function _getPositionAmount(uint256 _collateralAmount, uint16 _leverage)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return (_collateralAmount * _leverage) / 10;\\n  }\\n\\n  function _getAndClosePositionPLInfo(\\n    uint256 _tokenId,\\n    address _closingUser,\\n    uint256 _currentPrice,\\n    uint256 _collateralReduction\\n  ) internal returns (bool) {\\n    IPerpetualFutures.Position storage _position = positions[_tokenId];\\n    bool _isClosing = _collateralReduction == 0 ||\\n      _collateralReduction >= _position.collateralAmount;\\n    (\\n      uint256 _closingFeePosition,\\n      uint256 _closingFeeDurationTotal\\n    ) = _getCloseFees(\\n        _tokenId,\\n        _position.collateralToken,\\n        _isClosing ? _position.collateralAmount : _collateralReduction,\\n        _position.leverage,\\n        _position.lifecycle.openTime\\n      );\\n    uint256 _totalCloseFees = _position.lifecycle.closeFees +\\n      _closingFeePosition +\\n      _closingFeeDurationTotal;\\n\\n    _position.lifecycle.closeFees += _totalCloseFees;\\n\\n    (\\n      uint256 _amountReturnToUser,\\n      uint256 _absolutePL,\\n      bool _isProfit,\\n\\n    ) = _getIdxAndPLInfo(\\n        _position.indexPriceStart,\\n        _currentPrice,\\n        _isClosing ? _position.collateralAmount : _collateralReduction,\\n        _position.leverage,\\n        _position.isLong\\n      );\\n\\n    _position.amountWon += _isProfit ? _absolutePL : 0;\\n    _position.amountLost += _isProfit\\n      ? 0\\n      : _absolutePL > _position.collateralAmount\\n      ? _position.collateralAmount\\n      : _absolutePL;\\n\\n    if (_isClosing) {\\n      // closing position completely\\n      _position.lifecycle.closeTime = block.timestamp;\\n      _position.indexPriceSettle = _currentPrice;\\n      // adjust amount returned based on closing fees incurred\\n      _amountReturnToUser = _totalCloseFees > _amountReturnToUser\\n        ? 0\\n        : _amountReturnToUser - _totalCloseFees;\\n    } else {\\n      _position.collateralAmount -= _collateralReduction;\\n    }\\n\\n    _checkAndSettlePosition(\\n      _tokenId,\\n      _position.collateralToken,\\n      _isClosing ? _position.collateralAmount : _collateralReduction,\\n      _closingUser,\\n      _amountReturnToUser,\\n      _isClosing\\n    );\\n    return _isClosing;\\n  }\\n\\n  function _validateAndUpdateOpenAmounts(\\n    uint256 _tokenId,\\n    uint256 _oldPositionSize,\\n    uint256 _newPositionSize\\n  ) internal {\\n    if (positions[_tokenId].isLong) {\\n      amtOpenLong[positions[_tokenId].collateralToken] -= _oldPositionSize;\\n      amtOpenLong[positions[_tokenId].collateralToken] += _newPositionSize;\\n    } else {\\n      amtOpenShort[positions[_tokenId].collateralToken] -= _oldPositionSize;\\n      amtOpenShort[positions[_tokenId].collateralToken] += _newPositionSize;\\n    }\\n    if (maxCollateralOpenDiff[positions[_tokenId].collateralToken] > 0) {\\n      uint256 _openDiff = amtOpenLong[positions[_tokenId].collateralToken] >\\n        amtOpenShort[positions[_tokenId].collateralToken]\\n        ? amtOpenLong[positions[_tokenId].collateralToken] -\\n          amtOpenShort[positions[_tokenId].collateralToken]\\n        : amtOpenShort[positions[_tokenId].collateralToken] -\\n          amtOpenLong[positions[_tokenId].collateralToken];\\n      require(\\n        _openDiff <= maxCollateralOpenDiff[positions[_tokenId].collateralToken]\\n      );\\n    }\\n  }\\n\\n  function _updateCloseAmounts(\\n    uint256 _tokenId,\\n    uint256 _previousPositionSize,\\n    uint256 _currentPositionSize\\n  ) internal {\\n    if (positions[_tokenId].isLong) {\\n      amtOpenLong[positions[_tokenId].collateralToken] -= _previousPositionSize;\\n      amtOpenLong[positions[_tokenId].collateralToken] += _currentPositionSize;\\n    } else {\\n      amtOpenShort[\\n        positions[_tokenId].collateralToken\\n      ] -= _previousPositionSize;\\n      amtOpenShort[positions[_tokenId].collateralToken] += _currentPositionSize;\\n    }\\n  }\\n\\n  function _processCollateral(\\n    address _user,\\n    address _collToken,\\n    uint256 _collateral,\\n    uint16 _leverage\\n  ) internal returns (uint256, uint256) {\\n    uint256 _openFee;\\n    uint256 _finalCollateral;\\n\\n    // native token\\n    if (_collToken == address(0)) {\\n      require(msg.value > 0, 'COLL3');\\n      _collateral = msg.value;\\n      _openFee = _getPositionOpenFee(_user, _collToken, _collateral, _leverage);\\n      _finalCollateral = _collateral - _openFee;\\n    } else {\\n      IERC20Metadata _collCont = IERC20Metadata(_collToken);\\n      require(_collCont.balanceOf(_user) >= _collateral, 'BAL1');\\n\\n      uint256 _before = _collCont.balanceOf(address(this));\\n      _collCont.safeTransferFrom(_user, address(this), _collateral);\\n      _collateral = _collCont.balanceOf(address(this)) - _before;\\n      _openFee = _getPositionOpenFee(_user, _collToken, _collateral, _leverage);\\n      _finalCollateral = _collateral - _openFee;\\n    }\\n    return (_openFee, _finalCollateral);\\n  }\\n\\n  function _slippageValidation(\\n    uint256 _desiredPrice,\\n    uint256 _currentPrice,\\n    uint256 _slippage, // 1 == 0.1%, 10 == 1%\\n    bool _isLong\\n  ) internal pure {\\n    uint256 _idxSlipDiff;\\n    if (_isLong && _currentPrice > _desiredPrice) {\\n      _idxSlipDiff = _currentPrice - _desiredPrice;\\n    } else if (!_isLong && _desiredPrice > _currentPrice) {\\n      _idxSlipDiff = _desiredPrice - _currentPrice;\\n    }\\n    if (_idxSlipDiff > 0) {\\n      require(\\n        (_idxSlipDiff * FACTOR) / _desiredPrice <= (_slippage * FACTOR) / 1000\\n      );\\n    }\\n  }\\n\\n  function _canOpenAgainstIndex(uint256 _ind, uint256 _timestamp)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return\\n      _doTimeBoundsPass(\\n        _timestamp,\\n        indexes[_ind].dowOpenMin,\\n        indexes[_ind].dowOpenMax,\\n        indexes[_ind].hourOpenMin,\\n        indexes[_ind].hourOpenMax\\n      );\\n  }\\n\\n  function _doTimeBoundsPass(\\n    uint256 _timestamp,\\n    uint256 _dowOpenMin,\\n    uint256 _dowOpenMax,\\n    uint256 _hourOpenMin,\\n    uint256 _hourOpenMax\\n  ) internal view returns (bool) {\\n    _timestamp = _timestamp == 0 ? block.timestamp : _timestamp;\\n    if (_dowOpenMin >= 1 && _dowOpenMax >= 1) {\\n      uint256 _dow = BokkyPooBahsDateTimeLibrary.getDayOfWeek(_timestamp);\\n      if (_dow < _dowOpenMin || _dow > _dowOpenMax) {\\n        return false;\\n      }\\n    }\\n    if (_hourOpenMin >= 1 || _hourOpenMax >= 1) {\\n      uint256 _hour = BokkyPooBahsDateTimeLibrary.getHour(_timestamp);\\n      if (_hour < _hourOpenMin || _hour > _hourOpenMax) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function shouldPositionLiquidate(uint256 _tokenId, uint256 _currentPrice)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    IPerpetualFutures.Position memory _pos = positions[_tokenId];\\n    uint256 _priceChangeForLiquidation = getLiquidationPriceChange(_tokenId);\\n    (uint256 _closingFeeMain, uint256 _closingFeeTime) = _getCloseFees(\\n      _tokenId,\\n      _pos.collateralToken,\\n      _pos.collateralAmount,\\n      _pos.leverage,\\n      _pos.lifecycle.openTime\\n    );\\n    (uint256 _amountReturnToUser, , , bool _isMax) = _getIdxAndPLInfo(\\n      _pos.indexPriceStart,\\n      _currentPrice,\\n      _pos.collateralAmount,\\n      _pos.leverage,\\n      _pos.isLong\\n    );\\n    uint256 _indexPriceDelinquencyPrice = _pos.isLong\\n      ? _pos.indexPriceStart - _priceChangeForLiquidation\\n      : _pos.indexPriceStart + _priceChangeForLiquidation;\\n    bool _priceInLiquidation = _pos.isLong\\n      ? _currentPrice <= _indexPriceDelinquencyPrice\\n      : _currentPrice >= _indexPriceDelinquencyPrice;\\n    bool _feesExceedReturn = _closingFeeMain + _closingFeeTime >=\\n      _amountReturnToUser;\\n    return _priceInLiquidation || _feesExceedReturn || _isMax;\\n  }\\n\\n  function shouldPositionCloseFromTrigger(\\n    uint256 _tokenId,\\n    uint256 _currIdxPrice\\n  ) public view returns (bool, uint256) {\\n    for (uint256 _i = 0; _i < triggerOrders[_tokenId].length; _i++) {\\n      uint256 _collateralChange = triggerOrders[_tokenId][_i]\\n        .amountCollateralChange;\\n      uint256 _target = triggerOrders[_tokenId][_i].idxPriceTarget;\\n      bool _lessThanEQ = _target < triggerOrders[_tokenId][_i].idxPriceCurrent;\\n      if (_lessThanEQ) {\\n        if (_currIdxPrice <= _target) {\\n          return (true, _collateralChange);\\n        }\\n      } else {\\n        if (_currIdxPrice >= _target) {\\n          return (true, _collateralChange);\\n        }\\n      }\\n    }\\n    return (false, 0);\\n  }\\n\\n  function withdrawERC20(address _token, uint256 _amount) external onlyOwner {\\n    IERC20Metadata _contract = IERC20Metadata(_token);\\n    _amount = _amount == 0 ? _contract.balanceOf(address(this)) : _amount;\\n    require(_amount > 0);\\n    _contract.safeTransfer(owner(), _amount);\\n  }\\n\\n  function withdrawETH(uint256 _amount) external onlyOwner {\\n    _amount = _amount == 0 ? address(this).balance : _amount;\\n    (bool _s, ) = payable(owner()).call{ value: _amount }('');\\n    require(_s);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeReducer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IFeeReducer {\\n  function percentDiscount(\\n    address wallet,\\n    address collateralToken,\\n    uint256 collateralAmount,\\n    uint16 leverage\\n  ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPerpetualFutures.sol\": {\r\n      \"content\": \"import '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IPerpetualFutures {\\n  struct Index {\\n    string name;\\n    uint256 dowOpenMin;\\n    uint256 dowOpenMax;\\n    uint256 hourOpenMin;\\n    uint256 hourOpenMax;\\n    bool isActive;\\n  }\\n\\n  struct PositionLifecycle {\\n    uint256 openTime;\\n    uint256 openFees;\\n    uint256 closeTime;\\n    uint256 closeFees;\\n    uint256 settleCollPriceUSD; // For positions with alternate collateral, USD per collateral token extended to 18 decimals\\n    uint256 settleMainPriceUSD; // For positions with alternate collateral, USD per main token extended to 18 decimals\\n  }\\n\\n  struct Position {\\n    PositionLifecycle lifecycle;\\n    uint256 indexIdx;\\n    address collateralToken;\\n    uint256 collateralAmount;\\n    bool isLong;\\n    uint16 leverage;\\n    uint256 indexPriceStart;\\n    uint256 indexPriceSettle;\\n    uint256 amountWon;\\n    uint256 amountLost;\\n    bool isSettled;\\n    uint256 mainCollateralSettledAmount;\\n  }\\n\\n  struct ActionRequest {\\n    uint256 timestamp;\\n    address requester;\\n    uint256 indexIdx;\\n    uint256 tokenId;\\n    address owner;\\n    address collateralToken;\\n    uint256 collateralAmount;\\n    bool isLong;\\n    uint16 leverage;\\n    uint256 openSlippage;\\n    uint256 desiredIdxPriceStart;\\n  }\\n\\n  function openFeeETH() external view returns (uint256);\\n\\n  function mainCollateralToken() external view returns (address);\\n\\n  function relays(address wallet) external view returns (bool);\\n\\n  function perpsNft() external view returns (IERC721);\\n\\n  function positions(uint256 tokenId) external view returns (Position memory);\\n\\n  function openPositionRequest(\\n    address collateralToken,\\n    uint256 indexInd,\\n    uint256 desiredPrice,\\n    uint256 slippage,\\n    uint256 collateral,\\n    uint16 leverage,\\n    bool isLong,\\n    uint256 tokenId, // optional: if adding margin\\n    address owner // optional: if opening for another wallet\\n  ) external payable;\\n\\n  function executeSettlement(\\n    uint256 tokenId,\\n    address to,\\n    uint256 amount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BokkyPooBahsDateTimeLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.00\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\\n//\\n// GNU Lesser General Public License 3.0\\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n  uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n  uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n  uint256 constant SECONDS_PER_MINUTE = 60;\\n  int256 constant OFFSET19700101 = 2440588;\\n\\n  uint256 constant DOW_MON = 1;\\n  uint256 constant DOW_TUE = 2;\\n  uint256 constant DOW_WED = 3;\\n  uint256 constant DOW_THU = 4;\\n  uint256 constant DOW_FRI = 5;\\n  uint256 constant DOW_SAT = 6;\\n  uint256 constant DOW_SUN = 7;\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate the number of days from 1970/01/01 to year/month/day using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // days = day\\n  //      - 32075\\n  //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n  //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n  //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n  //      - offset\\n  // ------------------------------------------------------------------------\\n  function _daysFromDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (uint256 _days) {\\n    require(year >= 1970);\\n    int256 _year = int256(year);\\n    int256 _month = int256(month);\\n    int256 _day = int256(day);\\n\\n    int256 __days = _day -\\n      32075 +\\n      (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n      4 +\\n      (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n      12 -\\n      (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n      4 -\\n      OFFSET19700101;\\n\\n    _days = uint256(__days);\\n  }\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate year/month/day from the number of days since 1970/01/01 using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and adding the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // int L = days + 68569 + offset\\n  // int N = 4 * L / 146097\\n  // L = L - (146097 * N + 3) / 4\\n  // year = 4000 * (L + 1) / 1461001\\n  // L = L - 1461 * year / 4 + 31\\n  // month = 80 * L / 2447\\n  // dd = L - 2447 * month / 80\\n  // L = month / 11\\n  // month = month + 2 - 12 * L\\n  // year = 100 * (N - 49) + year + L\\n  // ------------------------------------------------------------------------\\n  function _daysToDate(uint256 _days)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day\\n    )\\n  {\\n    int256 __days = int256(_days);\\n\\n    int256 L = __days + 68569 + OFFSET19700101;\\n    int256 N = (4 * L) / 146097;\\n    L = L - (146097 * N + 3) / 4;\\n    int256 _year = (4000 * (L + 1)) / 1461001;\\n    L = L - (1461 * _year) / 4 + 31;\\n    int256 _month = (80 * L) / 2447;\\n    int256 _day = L - (2447 * _month) / 80;\\n    L = _month / 11;\\n    _month = _month + 2 - 12 * L;\\n    _year = 100 * (N - 49) + _year + L;\\n\\n    year = uint256(_year);\\n    month = uint256(_month);\\n    day = uint256(_day);\\n  }\\n\\n  function timestampFromDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (uint256 timestamp) {\\n    timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n  }\\n\\n  function timestampFromDateTime(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day,\\n    uint256 hour,\\n    uint256 minute,\\n    uint256 second\\n  ) internal pure returns (uint256 timestamp) {\\n    timestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      hour *\\n      SECONDS_PER_HOUR +\\n      minute *\\n      SECONDS_PER_MINUTE +\\n      second;\\n  }\\n\\n  function timestampToDate(uint256 timestamp)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day\\n    )\\n  {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function timestampToDateTime(uint256 timestamp)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day,\\n      uint256 hour,\\n      uint256 minute,\\n      uint256 second\\n    )\\n  {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    uint256 secs = timestamp % SECONDS_PER_DAY;\\n    hour = secs / SECONDS_PER_HOUR;\\n    secs = secs % SECONDS_PER_HOUR;\\n    minute = secs / SECONDS_PER_MINUTE;\\n    second = secs % SECONDS_PER_MINUTE;\\n  }\\n\\n  function isValidDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (bool valid) {\\n    if (year >= 1970 && month > 0 && month <= 12) {\\n      uint256 daysInMonth = _getDaysInMonth(year, month);\\n      if (day > 0 && day <= daysInMonth) {\\n        valid = true;\\n      }\\n    }\\n  }\\n\\n  function isValidDateTime(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day,\\n    uint256 hour,\\n    uint256 minute,\\n    uint256 second\\n  ) internal pure returns (bool valid) {\\n    if (isValidDate(year, month, day)) {\\n      if (hour < 24 && minute < 60 && second < 60) {\\n        valid = true;\\n      }\\n    }\\n  }\\n\\n  function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\\n    uint256 year;\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    leapYear = _isLeapYear(year);\\n  }\\n\\n  function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n    leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n  }\\n\\n  function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n    weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n  }\\n\\n  function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n    weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n  }\\n\\n  function getDaysInMonth(uint256 timestamp)\\n    internal\\n    pure\\n    returns (uint256 daysInMonth)\\n  {\\n    uint256 year;\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    daysInMonth = _getDaysInMonth(year, month);\\n  }\\n\\n  function _getDaysInMonth(uint256 year, uint256 month)\\n    internal\\n    pure\\n    returns (uint256 daysInMonth)\\n  {\\n    if (\\n      month == 1 ||\\n      month == 3 ||\\n      month == 5 ||\\n      month == 7 ||\\n      month == 8 ||\\n      month == 10 ||\\n      month == 12\\n    ) {\\n      daysInMonth = 31;\\n    } else if (month != 2) {\\n      daysInMonth = 30;\\n    } else {\\n      daysInMonth = _isLeapYear(year) ? 29 : 28;\\n    }\\n  }\\n\\n  // 1 = Monday, 7 = Sunday\\n  function getDayOfWeek(uint256 timestamp)\\n    internal\\n    pure\\n    returns (uint256 dayOfWeek)\\n  {\\n    uint256 _days = timestamp / SECONDS_PER_DAY;\\n    dayOfWeek = ((_days + 3) % 7) + 1;\\n  }\\n\\n  function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n    uint256 year;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n    uint256 year;\\n    uint256 month;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n    uint256 secs = timestamp % SECONDS_PER_DAY;\\n    hour = secs / SECONDS_PER_HOUR;\\n  }\\n\\n  function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\\n    uint256 secs = timestamp % SECONDS_PER_HOUR;\\n    minute = secs / SECONDS_PER_MINUTE;\\n  }\\n\\n  function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\\n    second = timestamp % SECONDS_PER_MINUTE;\\n  }\\n\\n  function addYears(uint256 timestamp, uint256 _years)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    uint256 year;\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    year += _years;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addMonths(uint256 timestamp, uint256 _months)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    uint256 year;\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    month += _months;\\n    year += (month - 1) / 12;\\n    month = ((month - 1) % 12) + 1;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addDays(uint256 timestamp, uint256 _days)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addHours(uint256 timestamp, uint256 _hours)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addMinutes(uint256 timestamp, uint256 _minutes)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addSeconds(uint256 timestamp, uint256 _seconds)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _seconds;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function subYears(uint256 timestamp, uint256 _years)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    uint256 year;\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    year -= _years;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subMonths(uint256 timestamp, uint256 _months)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    uint256 year;\\n    uint256 month;\\n    uint256 day;\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    uint256 yearMonth = year * 12 + (month - 1) - _months;\\n    year = yearMonth / 12;\\n    month = (yearMonth % 12) + 1;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subDays(uint256 timestamp, uint256 _days)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subHours(uint256 timestamp, uint256 _hours)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subMinutes(uint256 timestamp, uint256 _minutes)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subSeconds(uint256 timestamp, uint256 _seconds)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _seconds;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _years)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    uint256 fromYear;\\n    uint256 fromMonth;\\n    uint256 fromDay;\\n    uint256 toYear;\\n    uint256 toMonth;\\n    uint256 toDay;\\n    (fromYear, fromMonth, fromDay) = _daysToDate(\\n      fromTimestamp / SECONDS_PER_DAY\\n    );\\n    (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n    _years = toYear - fromYear;\\n  }\\n\\n  function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _months)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    uint256 fromYear;\\n    uint256 fromMonth;\\n    uint256 fromDay;\\n    uint256 toYear;\\n    uint256 toMonth;\\n    uint256 toDay;\\n    (fromYear, fromMonth, fromDay) = _daysToDate(\\n      fromTimestamp / SECONDS_PER_DAY\\n    );\\n    (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n    _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n  }\\n\\n  function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _days)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n  }\\n\\n  function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _hours)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n  }\\n\\n  function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _minutes)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n  }\\n\\n  function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _seconds)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _seconds = toTimestamp - fromTimestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/pfYDF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Counters.sol';\\n\\ncontract pfYDF is Context, Ownable {\\n  using Counters for Counters.Counter;\\n\\n  address public perpetualFutures;\\n\\n  mapping(uint256 => address) _owners;\\n  Counters.Counter _ids;\\n\\n  // array of all the NFT token IDs owned by a user\\n  mapping(address => uint256[]) public allUserOwned;\\n  // the index in the token ID array at allUserOwned to save gas on operations\\n  mapping(uint256 => uint256) public ownedIndex;\\n\\n  mapping(uint256 => uint256) public tokenMintedAt;\\n\\n  event Burn(uint256 indexed tokenId, address indexed owner);\\n  event Mint(uint256 indexed tokenId, address indexed owner);\\n\\n  modifier onlyPerps() {\\n    require(_msgSender() == perpetualFutures, 'only perps');\\n    _;\\n  }\\n\\n  constructor() {\\n    perpetualFutures = _msgSender();\\n  }\\n\\n  function mint(address owner) external onlyPerps returns (uint256) {\\n    _ids.increment();\\n    _mint(owner, _ids.current());\\n    tokenMintedAt[_ids.current()] = block.timestamp;\\n    emit Mint(_ids.current(), owner);\\n    return _ids.current();\\n  }\\n\\n  function burn(uint256 _tokenId) external onlyPerps {\\n    address _user = ownerOf(_tokenId);\\n    require(_exists(_tokenId));\\n    _burn(_tokenId);\\n    emit Burn(_tokenId, _user);\\n  }\\n\\n  function getLastMintedTokenId() external view returns (uint256) {\\n    return _ids.current();\\n  }\\n\\n  function doesTokenExist(uint256 _tokenId) external view returns (bool) {\\n    return _exists(_tokenId);\\n  }\\n\\n  function setPerpetualFutures(address _perps) external onlyOwner {\\n    perpetualFutures = _perps;\\n  }\\n\\n  function getAllUserOwned(address _user)\\n    external\\n    view\\n    returns (uint256[] memory)\\n  {\\n    return allUserOwned[_user];\\n  }\\n\\n  function ownerOf(uint256 _tokenId) public view returns (address) {\\n    require(_owners[_tokenId] != address(0));\\n    return _owners[_tokenId];\\n  }\\n\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    require(_to != address(0) && _owners[_tokenId] == address(0));\\n    _owners[_tokenId] = _to;\\n    _afterTokenTransfer(address(0), _to, _tokenId);\\n  }\\n\\n  function _burn(uint256 _tokenId) internal {\\n    address _user = _owners[_tokenId];\\n    require(_owners[_tokenId] != address(0));\\n    delete _owners[_tokenId];\\n    _afterTokenTransfer(_user, address(0), _tokenId);\\n  }\\n\\n  function _exists(uint256 _tokenId) internal view returns (bool) {\\n    return _owners[_tokenId] != address(0);\\n  }\\n\\n  function _afterTokenTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  ) internal {\\n    // if from == address(0), token is being minted\\n    if (_from != address(0)) {\\n      uint256 _currIndex = ownedIndex[_tokenId];\\n      uint256 _tokenIdMovingIndices = allUserOwned[_from][\\n        allUserOwned[_from].length - 1\\n      ];\\n      allUserOwned[_from][_currIndex] = allUserOwned[_from][\\n        allUserOwned[_from].length - 1\\n      ];\\n      allUserOwned[_from].pop();\\n      ownedIndex[_tokenIdMovingIndices] = _currIndex;\\n    }\\n\\n    // if to == address(0), token is being burned\\n    if (_to != address(0)) {\\n      ownedIndex[_tokenId] = allUserOwned[_to].length;\\n      allUserOwned[_to].push(_tokenId);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/PerpsTriggerOrders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\ncontract PerpsTriggerOrders is Context {\\n  IERC721 internal _pfydf;\\n  uint8 public maxTriggerOrders = 2;\\n\\n  struct TriggerOrder {\\n    uint256 idxPriceCurrent;\\n    uint256 idxPriceTarget;\\n    uint256 amountCollateralChange;\\n  }\\n\\n  // tokenId => orders\\n  mapping(uint256 => TriggerOrder[]) public triggerOrders;\\n\\n  modifier onlyPositionOwner(uint256 _tokenId) {\\n    require(msg.sender == _pfydf.ownerOf(_tokenId), 'UNAUTHORIZED');\\n    _;\\n  }\\n\\n  function getAllPositionTriggerOrders(uint256 _tokenId)\\n    external\\n    view\\n    returns (TriggerOrder[] memory)\\n  {\\n    return triggerOrders[_tokenId];\\n  }\\n\\n  function addTriggerOrder(\\n    uint256 _tokenId,\\n    uint256 _idxPriceTarget,\\n    uint256 _currentPrice,\\n    uint256 _collateralChange\\n  ) external onlyPositionOwner(_tokenId) {\\n    _addTriggerOrder(\\n      _tokenId,\\n      _idxPriceTarget,\\n      _currentPrice,\\n      _collateralChange\\n    );\\n  }\\n\\n  function updateTriggerOrder(\\n    uint256 _tokenId,\\n    uint256 _idx,\\n    uint256 _idxPriceTarget,\\n    uint256 _newCollateralChange\\n  ) external onlyPositionOwner(_tokenId) {\\n    _updateTriggerOrder(_tokenId, _idx, _idxPriceTarget, _newCollateralChange);\\n  }\\n\\n  function removeTriggerOrder(uint256 _tokenId, uint256 _idx)\\n    external\\n    onlyPositionOwner(_tokenId)\\n  {\\n    _removeTriggerOrder(_tokenId, _idx);\\n  }\\n\\n  function _addTriggerOrder(\\n    uint256 _tokenId,\\n    uint256 _idxPriceTarget,\\n    uint256 _idxCurrentPrice,\\n    uint256 _collateralChange\\n  ) internal {\\n    require(_idxPriceTarget > 0, 'TO0');\\n    require(triggerOrders[_tokenId].length < maxTriggerOrders, 'TO1');\\n    require(_idxCurrentPrice != _idxPriceTarget, 'TO2');\\n\\n    triggerOrders[_tokenId].push(\\n      TriggerOrder({\\n        idxPriceCurrent: _idxCurrentPrice,\\n        idxPriceTarget: _idxPriceTarget,\\n        amountCollateralChange: _collateralChange\\n      })\\n    );\\n  }\\n\\n  function _updateTriggerOrder(\\n    uint256 _tokenId,\\n    uint256 _idx,\\n    uint256 _idxTargetPrice,\\n    uint256 _newCollateralChange\\n  ) internal {\\n    require(_idxTargetPrice > 0, 'TO0');\\n\\n    TriggerOrder storage _order = triggerOrders[_tokenId][_idx];\\n    bool _isTargetLess = _order.idxPriceTarget < _order.idxPriceCurrent;\\n    // if original target is less than original current, new target must\\n    // remain less than, or vice versa for higher than prices\\n    require(\\n      _isTargetLess\\n        ? _idxTargetPrice < _order.idxPriceCurrent\\n        : _idxTargetPrice > _order.idxPriceCurrent,\\n      'TO3'\\n    );\\n    _order.idxPriceTarget = _idxTargetPrice;\\n    _order.amountCollateralChange = _newCollateralChange;\\n  }\\n\\n  function _removeTriggerOrder(uint256 _tokenId, uint256 _idx) internal {\\n    triggerOrders[_tokenId][_idx] = triggerOrders[_tokenId][\\n      triggerOrders[_tokenId].length - 1\\n    ];\\n    triggerOrders[_tokenId].pop();\\n  }\\n\\n  function _setPfydf(address _nft) internal {\\n    _pfydf = IERC721(_nft);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/PerpetualFuturesUnsettledHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport './interfaces/IPerpetualFutures.sol';\\n\\ncontract PerpetualFuturesUnsettledHandler is Context {\\n  IPerpetualFutures public perpetualFutures;\\n\\n  struct UnsettledPositions {\\n    uint256 tokenId;\\n    address owner;\\n    address collateralToken;\\n    uint256 unsettledAmount;\\n  }\\n\\n  UnsettledPositions[] public unsettled;\\n\\n  event AddUnsettledPosition(\\n    uint256 indexed tokenId,\\n    address indexed token,\\n    uint256 amount,\\n    uint256 idx\\n  );\\n  event SettlePosition(\\n    uint256 indexed tokenId,\\n    uint256 collateralAmount,\\n    uint256 mainAmount,\\n    uint256 collateralPriceUSD,\\n    uint256 mainPriceUSD\\n  );\\n\\n  modifier onlyPerps() {\\n    require(_msgSender() == address(perpetualFutures), 'UNAUTHORIZED');\\n    _;\\n  }\\n\\n  modifier onlyRelay() {\\n    require(perpetualFutures.relays(_msgSender()), 'UNAUTHORIZED');\\n    _;\\n  }\\n\\n  constructor() {\\n    perpetualFutures = IPerpetualFutures(_msgSender());\\n  }\\n\\n  function getAllUnsettled()\\n    external\\n    view\\n    returns (UnsettledPositions[] memory)\\n  {\\n    return unsettled;\\n  }\\n\\n  function getUnsettledLength() external view returns (uint256) {\\n    return unsettled.length;\\n  }\\n\\n  function addUnsettledPosition(\\n    uint256 _tokenId,\\n    address _ownerAtAddTime,\\n    address _token,\\n    uint256 _amount\\n  ) external onlyPerps {\\n    unsettled.push(\\n      UnsettledPositions({\\n        tokenId: _tokenId,\\n        owner: _ownerAtAddTime,\\n        collateralToken: _token,\\n        unsettledAmount: _amount\\n      })\\n    );\\n    emit AddUnsettledPosition(_tokenId, _token, _amount, unsettled.length - 1);\\n  }\\n\\n  function settleUnsettledPosition(\\n    uint256 _idx,\\n    uint256 _collPriceUSD,\\n    uint256 _mainPriceUSD\\n  ) external onlyRelay {\\n    UnsettledPositions memory _info = unsettled[_idx];\\n    uint256 _mainSettleAmt = (_info.unsettledAmount *\\n      10**IERC20Metadata(perpetualFutures.mainCollateralToken()).decimals() *\\n      _collPriceUSD) /\\n      _mainPriceUSD /\\n      10**IERC20Metadata(_info.collateralToken).decimals();\\n    perpetualFutures.executeSettlement(\\n      _info.tokenId,\\n      _info.owner,\\n      _mainSettleAmt\\n    );\\n    unsettled[_idx] = unsettled[unsettled.length - 1];\\n    unsettled.pop();\\n    emit SettlePosition(\\n      _info.tokenId,\\n      _info.unsettledAmount,\\n      _mainSettleAmt,\\n      _collPriceUSD,\\n      _mainPriceUSD\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPriceStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPriceSettle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLost\",\"type\":\"uint256\"}],\"name\":\"ClosePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ClosePositionFromTriggerOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralReduction\",\"type\":\"uint256\"}],\"name\":\"ClosePositionRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CloseUnsettledPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"LiquidatePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPriceStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"OpenPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPriceStartDesired\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"OpenPositionRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSettled\",\"type\":\"uint256\"}],\"name\":\"SettlePosition\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"activateIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"addIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_idxPriceTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateralChange\",\"type\":\"uint256\"}],\"name\":\"addTriggerOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOpenPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amtOpenLong\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amtOpenShort\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeFeePerDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeFeePerDurationUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeFeePositionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_closePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pendingCloseIdx\",\"type\":\"uint256\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateralReduction\",\"type\":\"uint256\"}],\"name\":\"closePositionRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_closeReqIdx\",\"type\":\"uint256\"}],\"name\":\"closePositionRequestCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"executeSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReducer\",\"outputs\":[{\"internalType\":\"contract IFeeReducer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllIndexes\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"dowOpenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dowOpenMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hourOpenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hourOpenMax\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct IPerpetualFutures.Index[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllOpenPositions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAllPositionTriggerOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"idxPriceCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idxPriceTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateralChange\",\"type\":\"uint256\"}],\"internalType\":\"struct PerpsTriggerOrders.TriggerOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllValidCollateralTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClosePositionRequests\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"indexIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"openSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desiredIdxPriceStart\",\"type\":\"uint256\"}],\"internalType\":\"struct IPerpetualFutures.ActionRequest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_leverage\",\"type\":\"uint16\"}],\"name\":\"getFeeDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentIndexPrice\",\"type\":\"uint256\"}],\"name\":\"getIndexAndPLInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLiquidationPriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenPositionRequests\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"indexIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"openSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desiredIdxPriceStart\",\"type\":\"uint256\"}],\"internalType\":\"struct IPerpetualFutures.ActionRequest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPositionCloseFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"dowOpenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dowOpenMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hourOpenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hourOpenMax\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCollateralToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxCollateralOpenDiff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxLevIdxOverride\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLeverage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProfitPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTriggerOrders\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openFeeETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openFeePositionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pendingIdx\",\"type\":\"uint256\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_indexInd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_desiredPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_leverage\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"openPositionRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openReqIdx\",\"type\":\"uint256\"}],\"name\":\"openPositionRequestCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingClosePositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"indexIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"openSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desiredIdxPriceStart\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingOpenPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"indexIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"openSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desiredIdxPriceStart\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingPositionExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"}],\"name\":\"performUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"wasLiquidated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perpsNft\",\"outputs\":[{\"internalType\":\"contract pfYDF\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleCollPriceUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleMainPriceUSD\",\"type\":\"uint256\"}],\"internalType\":\"struct IPerpetualFutures.PositionLifecycle\",\"name\":\"lifecycle\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"indexIdx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"indexPriceStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexPriceSettle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLost\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mainCollateralSettledAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"processFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"removeIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"removeTriggerOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"setCloseFeePositionPerDurationUnit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setCloseFeePositionSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setClosePositionFeePerDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFeeReducer\",\"name\":\"_reducer\",\"type\":\"address\"}],\"name\":\"setFeeReducer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxCollateralOpenDiff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_max\",\"type\":\"uint16\"}],\"name\":\"setMaxLevIdxOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_max\",\"type\":\"uint16\"}],\"name\":\"setMaxLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMaxProfitPerc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_max\",\"type\":\"uint8\"}],\"name\":\"setMaxTriggerOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinCollateralAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"setOpenFeeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setOpenFeePositionSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"setPendingPositionExp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isRelay\",\"type\":\"bool\"}],\"name\":\"setRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradingEnabled\",\"type\":\"bool\"}],\"name\":\"setTradingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isValid\",\"type\":\"bool\"}],\"name\":\"setValidCollateralToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currIdxPrice\",\"type\":\"uint256\"}],\"name\":\"shouldPositionCloseFromTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"}],\"name\":\"shouldPositionLiquidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"triggerOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"idxPriceCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idxPriceTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateralChange\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unsettledHandler\",\"outputs\":[{\"internalType\":\"contract PerpetualFuturesUnsettledHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_indexInd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dowOpenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dowOpenMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hourOpenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hourOpenMax\",\"type\":\"uint256\"}],\"name\":\"updateIndexOpenTimeBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_idxPriceTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newCollateralChange\",\"type\":\"uint256\"}],\"name\":\"updateTriggerOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PerpetualFutures", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}