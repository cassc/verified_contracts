/*----------------------------------------------------------*|
|*          ███    ██ ██ ███    ██ ███████  █████           *|
|*          ████   ██ ██ ████   ██ ██      ██   ██          *|
|*          ██ ██  ██ ██ ██ ██  ██ █████   ███████          *|
|*          ██  ██ ██ ██ ██  ██ ██ ██      ██   ██          *|
|*          ██   ████ ██ ██   ████ ██      ██   ██          *|
|*----------------------------------------------------------*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "../ERC721.sol";

/// @custom:security-contact [email protected]
abstract contract ERC721LazyMintableCommunal is ERC721 {
    /*----------------------------------------------------------*|
    |*  # EIP-712                                               *|
    |*----------------------------------------------------------*/

    struct Voucher {
        bytes32 tokenURI;
        uint256 price;
        uint256 commissionBps;
        address commissionRecipient;
    }

    bytes32 private immutable DOMAIN_SEPARATOR;
    bytes32 private immutable DOMAIN_TYPEHASH;
    bytes32 private immutable VOUCHER_TYPEHASH;

    /*----------------------------------------------------------*|
    |*  # LAZY MINTING                                          *|
    |*----------------------------------------------------------*/

    mapping(bytes32 => bool) private _mintedURIs;

    /**
     * @param _to buyer, needed if using a external payment gateway, so that the minted tokenId value is sent to the address specified insead of `msg.sender`
     * @param _data data bytes are passed to `onErc1155Received` function if the `_to` address is a contract, for example a marketplace.
     *      `onErc1155Received` is not being called on the minter's address when a new tokenId is minted however, even if it was contract.
     * @dev Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the voucher signer must have the `MINTER_ROLE` role.
     * - access control must be set in derived contracts, e.g. `require(hasRole(MINTER_ROLE, signer)`
     * - extensions must be overridden in derived contract
     */
    function _lazyMint(
        Voucher calldata _voucher,
        bytes calldata _signature,
        bytes calldata _data,
        address _to,
        uint256 _tokenId,
        uint256 _sellerAmount
    ) internal returns (address _signer) {
        if (_mintedURIs[_voucher.tokenURI]) revert();

        /*----------------------------------------------------------*|
        |*  # EIP-712 TYPED DATA SIGNATURE VERIFICATION             *|
        |*----------------------------------------------------------*/

        _signer = _recover(_voucher, _signature);

        /*----------------------------------------------------------*|
        |*  # MINT & TRANSFER                                       *|
        |*----------------------------------------------------------*/
        _mintedURIs[_voucher.tokenURI] = true;

        _mintAndTransfer(_signer, _to, _tokenId, _data);

        /*----------------------------------------------------------*|
        |*  # PAY COMMISSIONS (if any)                              *|
        |*----------------------------------------------------------*/

        if (_voucher.commissionBps > 0) {
            uint256 commissionAmount = (msg.value * _voucher.commissionBps) /
                10000;
            _sellerAmount -= commissionAmount;
            _sendValue(_voucher.commissionRecipient, commissionAmount);
        }

        /*----------------------------------------------------------*|
        |*  # PAY SELLER                                            *|
        |*----------------------------------------------------------*/

        _sendValue(_signer, _sellerAmount);
    }

    function _recover(
        Voucher calldata _voucher,
        bytes memory _signature
    ) private view returns (address _signer) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        VOUCHER_TYPEHASH,
                        _voucher.tokenURI,
                        _voucher.price,
                        _voucher.commissionBps,
                        _voucher.commissionRecipient
                    )
                )
            )
        );

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(_signature, 0x20))
            s := mload(add(_signature, 0x40))
            v := byte(0, mload(add(_signature, 0x60)))
        }

        _signer = ecrecover(digest, v, r, s);
        if (_signer == address(0)) revert();
    }

    function _sendValue(address _receiver, uint256 _amount) internal {
        (bool success, ) = payable(_receiver).call{value: _amount}("");
        require(success);
    }

    /**
     * @notice creates `DOMAIN_SEPARATOR`,
     *      Grants `DEFAULT_ADMIN_ROLE` to the account that deploys the contract,
     *      assigns `CURATOR_ROLE` as the admin role for `MINTER_ROLE`,
     */
    constructor(string memory _eip712DomainName) {
        DOMAIN_TYPEHASH = keccak256(
            "EIP712Domain(string name,uint256 chainId,address verifyingContract)"
        );
        VOUCHER_TYPEHASH = keccak256(
            "Voucher(bytes32 tokenURI,uint256 price,uint256 commissionBps,address commissionRecipient)"
        );
        /**
         * @dev The EIP712Domain fields should be the order as above, skipping any absent fields.
         *      Protocol designers only need to include the fields that make sense for their signing domain. Unused fields are left out of the struct type.
         * @param name the user readable name of signing domain, i.e. the name of the DApp or the protocol.
         * @param chainId the EIP-155 chain id. The user-agent should refuse signing if it does not match the currently active chain.
         * @param verifyingContract the address of the contract that will verify the signature. The user-agent may do contract specific phishing prevention.
         *      verifyingContract is the only variable parameter in the DOMAIN_SEPARATOR in order to avoid signature replay across different contracts
         *      therefore the DOMAIN_SEPARATOR MUST be calculated inside of the `initialize` function rather than the constructor.
         */
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(_eip712DomainName)), // name
                block.chainid, // chainId
                address(this) // verifyingContract
            )
        );
    }
}