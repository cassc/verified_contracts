{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n\r\n /$$$$$$$$ /$$$$$$ /$$   /$$  /$$$$$$  /$$$$$$$$ /$$   /$$ /$$     /$$\r\n| $$_____/|_  $$_/| $$$ | $$ /$$__  $$| $$_____/| $$  / $$|  $$   /$$/\r\n| $$        | $$  | $$$$| $$| $$  \\__/| $$      |  $$/ $$/ \\  $$ /$$/\r\n| $$$$$     | $$  | $$ $$ $$|  $$$$$$ | $$$$$    \\  $$$$/   \\  $$$$/\r\n| $$__/     | $$  | $$  $$$$ \\____  $$| $$__/     >$$  $$    \\  $$/\r\n| $$        | $$  | $$\\  $$$ /$$  \\ $$| $$       /$$/\\  $$    | $$\r\n| $$       /$$$$$$| $$ \\  $$|  $$$$$$/| $$$$$$$$| $$  \\ $$    | $$\r\n|__/      |______/|__/  \\__/ \\______/ |________/|__/  |__/    |__/\r\n\r\n\r\nhttps://finsexy.com\r\n\r\nby steviep.eth\r\n\r\n*/\r\n\r\npragma solidity ^0.8.23;\r\n\r\ninterface IForwardedURI {\r\n  function tokenURI(string memory name, string memory symbol, uint256 tokenId) external view returns (string memory);\r\n  function isSpecial(uint256 tokenId) external view returns (bool);\r\n}\r\n\r\ninterface IDrAndy {\r\n  function mintedBy(uint256) external view returns (address);\r\n  function timestamp(uint256) external view returns (uint256);\r\n  function tributes(address) external view returns (uint256);\r\n}\r\n\r\ncontract DrAndyURI is IForwardedURI{\r\n  using IntToString for uint256;\r\n\r\n  IDrAndy public ai;\r\n\r\n  constructor(address addr) {\r\n    ai = IDrAndy(addr);\r\n  }\r\n\r\n  function tokenURI(string memory name, string memory, uint256 tokenId) external view returns (string memory) {\r\n    string memory tokenName = string.concat(name, ' #', tokenId.toString());\r\n\r\n    address originalMinter = ai.mintedBy(tokenId);\r\n    bool finalSessionPaid = ai.tributes(originalMinter) >= 0.05 ether;\r\n\r\n    bytes memory json = abi.encodePacked(\r\n      'data:application/json;utf8,'\r\n      '{\"name\": \"', tokenName,'\",'\r\n      '\"description\": \"Invoices must be paid within 90 business days with either ETH or SexyCredits.\",'\r\n      '\"external_url\": \"https://finsexy.com/doms/DrAndy\",'\r\n      '\"attributes\": [{\"trait_type\": \"Final Session Paid\", \"value\": \"', finalSessionPaid ? 'True' : 'False','\"},{\"trait_type\": \"Is Special\", \"value\": \"', isSpecial(tokenId) ? 'True' : 'False','\"}],'\r\n      '\"image\": \"', encodedSVG(tokenId),\r\n      '\"}'\r\n    );\r\n\r\n    return string(json);\r\n  }\r\n\r\n  function isSpecial(uint256) public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function encodedSVG(uint256 tokenId) public view returns (string memory) {\r\n    return string(abi.encodePacked(\r\n      'data:image/svg+xml;base64,',\r\n      Base64Encode.encode(rawSVG(tokenId))\r\n    ));\r\n  }\r\n\r\n  function rawSVG(uint256 tokenId) public view returns (bytes memory) {\r\n    address originalMinter = ai.mintedBy(tokenId);\r\n    bool finalSessionPaid = ai.tributes(originalMinter) >= 0.05 ether;\r\n    uint256 taxId = uint256(keccak256(abi.encodePacked(originalMinter, tokenId))) % 1000000;\r\n\r\n    string memory header = string.concat(\r\n      '<svg viewBox=\"0 0 850 1100\" xmlns=\"http://www.w3.org/2000/svg\"><style>.c{dominant-baseline:hanging;text-anchor:middle}.e{text-anchor:end}text{font-size:25px}line{stroke:#000}</style><rect x=\"0\" y=\"0\" width=\"850\" height=\"1100\" fill=\"#fff\"></rect><text class=\"c\" x=\"50%\" y=\"125\" style=\"font-size:60px\">INVOICE</text><text class=\"c\" x=\"50%\" y=\"183\" style=\"font-size:45px\">Dr. Andy Ingram</text><text class=\"c s\" x=\"50%\" y=\"240\">',\r\n      uint256(uint160(address(ai))).toHexString(),\r\n      '</text>'\r\n    );\r\n\r\n    string memory middleSection = string.concat(\r\n      '<text x=\"100\" y=\"345\" class=\"s\">Invoice # ',\r\n      tokenId.toString(),\r\n      '</text><text x=\"750\" y=\"345\" class=\"s e\">Tax # ',\r\n      taxId.toString(),\r\n      '</text><line x1=\"100\" x2=\"750\" y1=\"350\" y2=\"350\"></line><text x=\"100\" y=\"410\" class=\"s\">Statement Timestamp: ',\r\n      ai.timestamp(tokenId).toString(),\r\n      '</text><text x=\"100\" y=\"445\" class=\"s\">Patient:</text><text x=\"185\" y=\"445\" class=\"s\">',\r\n       uint256(uint160(originalMinter)).toHexString(),\r\n      '</text>'\r\n    );\r\n\r\n    string memory feeSection = string.concat(\r\n      '<text x=\"100\" y=\"595\" class=\"s\"># of Sessions: 4</text><text x=\"750\" y=\"595\" class=\"s e\">Fee Per Session: 0.01 ETH</text><line x1=\"100\" x2=\"750\" y1=\"600\" y2=\"600\"></line><text x=\"150\" y=\"675\">Session 1:</text><text x=\"300\" y=\"675\">0.01 ETH</text><text x=\"450\" y=\"675\">PAID</text><text x=\"150\" y=\"715\">Session 2:</text><text x=\"300\" y=\"715\">0.01 ETH</text><text x=\"450\" y=\"715\">PAID</text><text x=\"150\" y=\"755\">Session 3:</text><text x=\"300\" y=\"755\">0.01 ETH</text><text x=\"450\" y=\"755\">PAID</text><text x=\"150\" y=\"795\">Session 4:</text><text x=\"300\" y=\"795\">0.01 ETH</text><text x=\"450\" y=\"795\" fill=\"',\r\n      finalSessionPaid ? '#000' : '#f00',\r\n      '\">',\r\n      finalSessionPaid ? 'PAID' : 'UNPAID',\r\n      '</text>'\r\n    );\r\n\r\n    string memory end = string.concat(\r\n      '<text x=\"100\" y=\"935\">Balance Paid: 0.0',\r\n      finalSessionPaid ? '4' : '3',\r\n      ' ETH</text><text x=\"100\" y=\"975\">Balance Due: 0.0',\r\n       finalSessionPaid ? '0' : '1',\r\n       ' ETH</text></svg>'\r\n    );\r\n\r\n    return abi.encodePacked(\r\n      header,\r\n      middleSection,\r\n      feeSection,\r\n      end\r\n    );\r\n  }\r\n}\r\n\r\nlibrary IntToString {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /*\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\nlibrary Base64Encode {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n\r\n            } {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ai\",\"outputs\":[{\"internalType\":\"contract IDrAndy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"encodedSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isSpecial\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rawSVG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DrAndyURI", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000fa5e41483022b76d4f2414e020c4b6fcdcbb893b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://de94448a792e378bb76fb0948c6894b605191df2c2f0b182dee5fc6e972ce091"}