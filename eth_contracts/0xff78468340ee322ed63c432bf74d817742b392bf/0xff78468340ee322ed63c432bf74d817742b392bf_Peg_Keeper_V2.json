{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title Peg Keeper V2\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Peg Keeper\r\n@dev Version 2\r\n\"\"\"\r\n\r\ninterface Regulator:\r\n    def stablecoin() -> address: view\r\n    def provide_allowed(_pk: address=msg.sender) -> uint256: view\r\n    def withdraw_allowed(_pk: address=msg.sender) -> uint256: view\r\n    def fee_receiver() -> address: view\r\n\r\ninterface CurvePool:\r\n    def balances(i_coin: uint256) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def get_virtual_price() -> uint256: view\r\n    def balanceOf(arg0: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface CurvePoolOld:\r\n    def calc_token_amount(_amounts: uint256[2], _is_deposit: bool) -> uint256: view\r\n    def add_liquidity(_amounts: uint256[2], _min_mint_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity_imbalance(_amounts: uint256[2], _max_burn_amount: uint256) -> uint256: nonpayable\r\n\r\ninterface CurvePoolNG:\r\n    def calc_token_amount(_amounts: DynArray[uint256, 8], _is_deposit: bool) -> uint256: view\r\n    def add_liquidity(_amounts: DynArray[uint256, 8], _min_mint_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity_imbalance(_amounts: DynArray[uint256, 8], _max_burn_amount: uint256) -> uint256: nonpayable\r\n\r\ninterface ERC20:\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def decimals() -> uint256: view\r\n\r\n\r\nevent Provide:\r\n    amount: uint256\r\n\r\nevent Withdraw:\r\n    amount: uint256\r\n\r\nevent Profit:\r\n    lp_amount: uint256\r\n\r\nevent CommitNewAdmin:\r\n    admin: address\r\n\r\nevent ApplyNewAdmin:\r\n    admin: address\r\n\r\nevent SetNewCallerShare:\r\n    caller_share: uint256\r\n\r\nevent SetNewRegulator:\r\n    regulator: address\r\n\r\n\r\n# Time between providing/withdrawing coins\r\nACTION_DELAY: constant(uint256) = 15 * 60\r\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\r\n\r\nPRECISION: constant(uint256) = 10 ** 18\r\n\r\nPOOL: immutable(CurvePool)\r\nI: immutable(uint256)  # index of pegged in pool\r\nPEGGED: immutable(ERC20)\r\nIS_INVERSE: public(immutable(bool))\r\nIS_NG: public(immutable(bool))  # Interface for CurveStableSwapNG\r\nPEG_MUL: immutable(uint256)\r\n\r\nregulator: public(Regulator)\r\n\r\nlast_change: public(uint256)\r\ndebt: public(uint256)\r\n\r\nSHARE_PRECISION: constant(uint256) = 10 ** 5\r\ncaller_share: public(uint256)\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\nnew_admin_deadline: public(uint256)\r\n\r\n# Receiver of profit\r\nreceiver: public(address)\r\n\r\nFACTORY: immutable(address)\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _pool: CurvePool, _caller_share: uint256,\r\n    _factory: address, _regulator: Regulator, _admin: address,\r\n):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _pool Contract pool address\r\n    @param _caller_share Caller's share of profit\r\n    @param _factory Factory which should be able to take coins away\r\n    @param _regulator Peg Keeper Regulator\r\n    @param _admin Admin account\r\n    \"\"\"\r\n    POOL = _pool\r\n    pegged: ERC20 = ERC20(_regulator.stablecoin())\r\n    PEGGED = pegged\r\n    pegged.approve(_pool.address, max_value(uint256))\r\n    pegged.approve(_factory, max_value(uint256))\r\n\r\n    coins: ERC20[2] = [ERC20(_pool.coins(0)), ERC20(_pool.coins(1))]\r\n    for i in range(2):\r\n        if coins[i] == pegged:\r\n            I = i\r\n            IS_INVERSE = (i == 0)\r\n        else:\r\n            PEG_MUL = 10 ** (18 - coins[i].decimals())\r\n\r\n    IS_NG = raw_call(\r\n        _pool.address, _abi_encode(convert(0, uint256), method_id=method_id(\"price_oracle(uint256)\")),\r\n        revert_on_failure=False\r\n    )\r\n\r\n    self.admin = _admin\r\n    log ApplyNewAdmin(msg.sender)\r\n\r\n    self.regulator = _regulator\r\n    log SetNewRegulator(_regulator.address)\r\n\r\n    assert _caller_share <= SHARE_PRECISION  # dev: bad part value\r\n    self.caller_share = _caller_share\r\n    log SetNewCallerShare(_caller_share)\r\n\r\n    FACTORY = _factory\r\n\r\n\r\n@pure\r\n@external\r\ndef factory() -> address:\r\n    return FACTORY\r\n\r\n\r\n@pure\r\n@external\r\ndef pegged() -> address:\r\n    \"\"\"\r\n    @return Address of stablecoin being pegged\r\n    \"\"\"\r\n    return PEGGED.address\r\n\r\n\r\n@pure\r\n@external\r\ndef pool() -> CurvePool:\r\n    \"\"\"\r\n    @return StableSwap pool being used\r\n    \"\"\"\r\n    return POOL\r\n\r\n\r\n@internal\r\ndef _provide(_amount: uint256):\r\n    \"\"\"\r\n    @notice Implementation of provide\r\n    @dev Coins should be already in the contract\r\n    \"\"\"\r\n    if _amount == 0:\r\n        return\r\n\r\n    amount: uint256 = min(_amount, PEGGED.balanceOf(self))\r\n\r\n    if IS_NG:\r\n        amounts: DynArray[uint256, 2] = [0, 0]\r\n        amounts[I] = amount\r\n        CurvePoolNG(POOL.address).add_liquidity(amounts, 0)\r\n    else:\r\n        amounts: uint256[2] = empty(uint256[2])\r\n        amounts[I] = amount\r\n        CurvePoolOld(POOL.address).add_liquidity(amounts, 0)\r\n\r\n    self.last_change = block.timestamp\r\n    self.debt += amount\r\n    log Provide(amount)\r\n\r\n\r\n@internal\r\ndef _withdraw(_amount: uint256):\r\n    \"\"\"\r\n    @notice Implementation of withdraw\r\n    \"\"\"\r\n    if _amount == 0:\r\n        return\r\n\r\n    debt: uint256 = self.debt\r\n    amount: uint256 = min(_amount, debt)\r\n\r\n    if IS_NG:\r\n        amounts: DynArray[uint256, 2] = [0, 0]\r\n        amounts[I] = amount\r\n        CurvePoolNG(POOL.address).remove_liquidity_imbalance(amounts, max_value(uint256))\r\n    else:\r\n        amounts: uint256[2] = empty(uint256[2])\r\n        amounts[I] = amount\r\n        CurvePoolOld(POOL.address).remove_liquidity_imbalance(amounts, max_value(uint256))\r\n\r\n    self.last_change = block.timestamp\r\n    self.debt = debt - amount\r\n\r\n    log Withdraw(amount)\r\n\r\n\r\n@internal\r\n@pure\r\ndef _calc_profit_from(lp_balance: uint256, virtual_price: uint256, debt: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice PegKeeper's profit calculation formula\r\n    \"\"\"\r\n    lp_debt: uint256 = debt * PRECISION / virtual_price\r\n\r\n    if lp_balance <= lp_debt:\r\n        return 0\r\n    else:\r\n        return lp_balance - lp_debt\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_profit() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate PegKeeper's profit using current values\r\n    \"\"\"\r\n    return self._calc_profit_from(POOL.balanceOf(self), POOL.get_virtual_price(), self.debt)\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_call_profit(_amount: uint256, _is_deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate overall profit from calling update()\r\n    \"\"\"\r\n    lp_balance: uint256 = POOL.balanceOf(self)\r\n    virtual_price: uint256 = POOL.get_virtual_price()\r\n    debt: uint256 = self.debt\r\n    initial_profit: uint256 = self._calc_profit_from(lp_balance, virtual_price, debt)\r\n\r\n    amount: uint256 = _amount\r\n    if _is_deposit:\r\n        amount = min(_amount, PEGGED.balanceOf(self))\r\n    else:\r\n        amount = min(_amount, debt)\r\n\r\n    lp_balance_diff: uint256 = 0\r\n    if IS_NG:\r\n        amounts: DynArray[uint256, 2] = [0, 0]\r\n        amounts[I] = amount\r\n        lp_balance_diff = CurvePoolNG(POOL.address).calc_token_amount(amounts, _is_deposit)\r\n    else:\r\n        amounts: uint256[2] = empty(uint256[2])\r\n        amounts[I] = amount\r\n        lp_balance_diff = CurvePoolOld(POOL.address).calc_token_amount(amounts, _is_deposit)\r\n\r\n    if _is_deposit:\r\n        lp_balance += lp_balance_diff\r\n        debt += amount\r\n    else:\r\n        lp_balance -= lp_balance_diff\r\n        debt -= amount\r\n\r\n    new_profit: uint256 = self._calc_profit_from(lp_balance, virtual_price, debt)\r\n    if new_profit <= initial_profit:\r\n        return 0\r\n    return new_profit - initial_profit\r\n\r\n\r\n@external\r\n@view\r\ndef calc_profit() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate generated profit in LP tokens. Does NOT include already withdrawn profit\r\n    @return Amount of generated profit\r\n    \"\"\"\r\n    return self._calc_profit()\r\n\r\n\r\n@external\r\n@view\r\ndef estimate_caller_profit() -> uint256:\r\n    \"\"\"\r\n    @notice Estimate profit from calling update()\r\n    @dev This method is not precise, real profit is always more because of increasing virtual price\r\n    @return Expected amount of profit going to beneficiary\r\n    \"\"\"\r\n    if self.last_change + ACTION_DELAY > block.timestamp:\r\n        return 0\r\n\r\n    balance_pegged: uint256 = POOL.balances(I)\r\n    balance_peg: uint256 = POOL.balances(1 - I) * PEG_MUL\r\n\r\n    call_profit: uint256 = 0\r\n    if balance_peg > balance_pegged:\r\n        allowed: uint256 = self.regulator.provide_allowed()\r\n        call_profit = self._calc_call_profit(min((balance_peg - balance_pegged) / 5, allowed), True)  # this dumps stablecoin\r\n\r\n    else:\r\n        allowed: uint256 = self.regulator.withdraw_allowed()\r\n        call_profit = self._calc_call_profit(min((balance_pegged - balance_peg) / 5, allowed), False)  # this pumps stablecoin\r\n\r\n    return call_profit * self.caller_share / SHARE_PRECISION\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef update(_beneficiary: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Provide or withdraw coins from the pool to stabilize it\r\n    @param _beneficiary Beneficiary address\r\n    @return Amount of profit received by beneficiary\r\n    \"\"\"\r\n    if self.last_change + ACTION_DELAY > block.timestamp:\r\n        return 0\r\n\r\n    balance_pegged: uint256 = POOL.balances(I)\r\n    balance_peg: uint256 = POOL.balances(1 - I) * PEG_MUL\r\n\r\n    initial_profit: uint256 = self._calc_profit()\r\n\r\n    if balance_peg > balance_pegged:\r\n        allowed: uint256 = self.regulator.provide_allowed()\r\n        assert allowed > 0, \"Regulator ban\"\r\n        self._provide(min(unsafe_sub(balance_peg, balance_pegged) / 5, allowed))  # this dumps stablecoin\r\n\r\n    else:\r\n        allowed: uint256 = self.regulator.withdraw_allowed()\r\n        assert allowed > 0, \"Regulator ban\"\r\n        self._withdraw(min(unsafe_sub(balance_pegged, balance_peg) / 5, allowed))  # this pumps stablecoin\r\n\r\n    # Send generated profit\r\n    new_profit: uint256 = self._calc_profit()\r\n    assert new_profit > initial_profit, \"peg unprofitable\"\r\n    lp_amount: uint256 = new_profit - initial_profit\r\n    caller_profit: uint256 = lp_amount * self.caller_share / SHARE_PRECISION\r\n    if caller_profit > 0:\r\n        POOL.transfer(_beneficiary, caller_profit)\r\n\r\n    return caller_profit\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef withdraw_profit() -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw profit generated by Peg Keeper\r\n    @return Amount of LP Token received\r\n    \"\"\"\r\n    lp_amount: uint256 = self._calc_profit()\r\n    POOL.transfer(self.regulator.fee_receiver(), lp_amount)\r\n\r\n    log Profit(lp_amount)\r\n\r\n    return lp_amount\r\n\r\n\r\n# ------------------------------- Admin methods --------------------------------\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef set_new_caller_share(_new_caller_share: uint256):\r\n    \"\"\"\r\n    @notice Set new update caller's part\r\n    @param _new_caller_share Part with SHARE_PRECISION\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only admin\r\n    assert _new_caller_share <= SHARE_PRECISION  # dev: bad part value\r\n\r\n    self.caller_share = _new_caller_share\r\n\r\n    log SetNewCallerShare(_new_caller_share)\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef set_new_regulator(_new_regulator: Regulator):\r\n    \"\"\"\r\n    @notice Set new peg keeper regulator\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only admin\r\n    assert _new_regulator.address != empty(address)  # dev: bad regulator\r\n\r\n    self.regulator = _new_regulator\r\n    log SetNewRegulator(_new_regulator.address)\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef commit_new_admin(_new_admin: address):\r\n    \"\"\"\r\n    @notice Commit new admin of the Peg Keeper\r\n    @dev In order to revert, commit_new_admin(current_admin) may be called\r\n    @param _new_admin Address of the new admin\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only admin\r\n    assert _new_admin != empty(address)  # dev: bad admin\r\n\r\n    self.new_admin_deadline = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.future_admin = _new_admin\r\n\r\n    log CommitNewAdmin(_new_admin)\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef apply_new_admin():\r\n    \"\"\"\r\n    @notice Apply new admin of the Peg Keeper\r\n    @dev Should be executed from new admin\r\n    \"\"\"\r\n    new_admin: address = self.future_admin\r\n    new_admin_deadline: uint256 = self.new_admin_deadline\r\n    assert msg.sender == new_admin  # dev: only new admin\r\n    assert block.timestamp >= new_admin_deadline  # dev: insufficient time\r\n    assert new_admin_deadline != 0  # dev: no active action\r\n\r\n    self.admin = new_admin\r\n    self.new_admin_deadline = 0\r\n\r\n    log ApplyNewAdmin(new_admin)", "ABI": "[{\"name\":\"Provide\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Profit\",\"inputs\":[{\"name\":\"lp_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyNewAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetNewCallerShare\",\"inputs\":[{\"name\":\"caller_share\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetNewRegulator\",\"inputs\":[{\"name\":\"regulator\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_caller_share\",\"type\":\"uint256\"},{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_regulator\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"pegged\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"estimate_caller_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update\",\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_new_caller_share\",\"inputs\":[{\"name\":\"_new_caller_share\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_new_regulator\",\"inputs\":[{\"name\":\"_new_regulator\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_admin\",\"inputs\":[{\"name\":\"_new_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_admin\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"IS_INVERSE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"IS_NG\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"regulator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_change\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"debt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"caller_share\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"new_admin_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Peg Keeper V2", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000390f3595bca2df7d23783dfd126427cceb997bf40000000000000000000000000000000000000000000000000000000000004e20000000000000000000000000c9332fdcb1c491dcc683bae86fe3cb70360738bc00000000000000000000000036a04caffc681fa179558b2aaba30395cddd855f00000000000000000000000040907540d8a6c65c637785e8f8b742ae6b0b9968", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}