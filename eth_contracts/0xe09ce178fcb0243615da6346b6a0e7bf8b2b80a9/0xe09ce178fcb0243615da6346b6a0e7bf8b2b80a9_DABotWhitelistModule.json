{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Errors {\\r\\n    /// Common error\\r\\n    string constant CM_CONTRACT_HAS_BEEN_INITIALIZED = \\\"CM-01\\\"; \\r\\n    string constant CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-02\\\";\\r\\n    string constant CM_VICS_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-03\\\";\\r\\n    string constant CM_VICS_EXCHANGE_IS_NOT_CONFIGURED = \\\"CM-04\\\";\\r\\n    string constant CM_CEX_FUND_MANAGER_IS_NOT_CONFIGURED = \\\"CM-05\\\";\\r\\n    string constant CM_TREASURY_MANAGER_IS_NOT_CONFIGURED = \\\"CM-06\\\";\\r\\n    string constant CM_CEX_DEFAULT_MASTER_ACCOUNT_IS_NOT_CONFIGURED = \\\"CM-07\\\";\\r\\n    string constant CM_ADDRESS_IS_NOT_ICEXDABOTCERTTOKEN = \\\"CM-08\\\";\\r\\n    string constant CM_INDEX_OUT_OF_RANGE = \\\"CM-09\\\";\\r\\n    string constant CM_UNAUTHORIZED_CALLER = \\\"CM-10\\\";\\r\\n    string constant CM_PROXY_ADMIN_IS_NOT_CONFIGURED = \\\"CM-11\\\";\\r\\n    \\r\\n\\r\\n    /// IBCertToken error  (Bot Certificate Token)\\r\\n    string constant BCT_CALLER_IS_NOT_OWNER = \\\"BCT-01\\\"; \\r\\n    string constant BCT_REQUIRE_ALL_TOKENS_BURNT = \\\"BCT-02\\\";\\r\\n    string constant BCT_UNLOCK_AMOUNT_EXCEEDS_TOTAL_LOCKED = \\\"BCT-03\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_UNLOCKING = \\\"BCT-04a\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_LOCKING = \\\"BCT-04b\\\";\\r\\n    string constant BCT_AMOUNT_EXCEEDS_TOTAL_STAKE = \\\"BCT-05\\\";\\r\\n    string constant BCT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BCT-06\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_BURN = \\\"BCT-07\\\";\\r\\n    string constant BCT_INSUFFICIENT_ACCOUNT_FUND = \\\"BCT-08\\\";\\r\\n    string constant BCT_CALLER_IS_NEITHER_BOT_NOR_CERTLOCKER = \\\"BCT-09\\\";\\r\\n    string constant BCT_VALUE_MISMATCH_ASSET_AMOUNT = \\\"BCT-10\\\";\\r\\n\\r\\n    /// IBCEXCertToken error (Cex Bot Certificate Token)\\r\\n    string constant CBCT_CALLER_IS_NOT_FUND_MANAGER = \\\"CBCT-01\\\";\\r\\n\\r\\n    /// GovernToken error (Bot Governance Token)\\r\\n    string constant BGT_CALLER_IS_NOT_OWNED_BOT = \\\"BGT-01\\\";\\r\\n    string constant BGT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BGT-02\\\";\\r\\n    string constant BGT_CALLER_IS_NOT_GOVERNANCE = \\\"BGT-03\\\";\\r\\n\\r\\n    // VaultBase error (VB)\\r\\n    string constant VB_CALLER_IS_NOT_DABOT = \\\"VB-01a\\\";\\r\\n    string constant VB_CALLER_IS_NOT_OWNER_BOT = \\\"VB-01b\\\";\\r\\n    string constant VB_INVALID_VAULT_ID = \\\"VB-02\\\";\\r\\n    string constant VB_INVALID_VAULT_TYPE = \\\"VB-03\\\";\\r\\n    string constant VB_INVALID_SNAPSHOT_ID = \\\"VB-04\\\";\\r\\n\\r\\n    // RegularVault Error (RV)\\r\\n    string constant RV_VAULT_IS_RESTRICTED = \\\"RV-01\\\";\\r\\n    string constant RV_DEPOSIT_LOCKED = \\\"RV-02\\\";\\r\\n    string constant RV_WITHDRAWL_AMOUNT_EXCEED_DEPOSIT = \\\"RV-03\\\";\\r\\n\\r\\n    // BotVaultManager (VM)\\r\\n    string constant VM_VAULT_EXISTS = \\\"VM-01\\\";\\r\\n\\r\\n    // BotManager (BM)\\r\\n    string constant BM_DOES_NOT_SUPPORT_IDABOT = \\\"BM-01\\\";\\r\\n    string constant BM_DUPLICATED_BOT_QUALIFIED_NAME = \\\"BM-02\\\";\\r\\n    string constant BM_TEMPLATE_IS_NOT_REGISTERED = \\\"BM-03\\\";\\r\\n    string constant BM_GOVERNANCE_TOKEN_IS_NOT_DEPLOYED = \\\"BM-04\\\";\\r\\n    string constant BM_BOT_IS_NOT_REGISTERED = \\\"BM-05\\\";\\r\\n\\r\\n    // DABotModule (BMOD)\\r\\n    string constant BMOD_CALLER_IS_NOT_OWNER = \\\"BMOD-01\\\";\\r\\n    string constant BMOD_CALLER_IS_NOT_BOT_MANAGER = \\\"BMOD-02\\\";\\r\\n    string constant BMOD_BOT_IS_ABANDONED = \\\"BMOD-03\\\";\\r\\n\\r\\n    // DABotControllerLib (BCL)\\r\\n    string constant BCL_DUPLICATED_MODULE = \\\"BCL-01\\\";\\r\\n    string constant BCL_CERT_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-02\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-03\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED = \\\"BCL-04\\\";\\r\\n    string constant BCL_WARMUP_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-05\\\";\\r\\n    string constant BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-06\\\";\\r\\n    string constant BCL_UKNOWN_MODULE_ID = \\\"BCL-07\\\";\\r\\n    string constant BCL_BOT_MANAGER_IS_NOT_CONFIGURED = \\\"BCL-08\\\";\\r\\n\\r\\n    // DABotController (BCMOD)\\r\\n    string constant BCMOD_CANNOT_CALL_TEMPLATE_METHOD_ON_BOT_INSTANCE = \\\"BCMOD-01\\\";\\r\\n    string constant BCMOD_CALLER_IS_NOT_OWNER = \\\"BCMOD-02\\\";\\r\\n    string constant BCMOD_MODULE_HANDLER_NOT_FOUND_FOR_METHOD_SIG = \\\"BCMOD-03\\\";\\r\\n    string constant BCMOD_NEW_OWNER_IS_ZERO = \\\"BCMOD-04\\\";\\r\\n\\r\\n    // CEXFundManagerModule (CFMOD)\\r\\n    string constant CFMOD_DUPLICATED_BENEFITCIARY = \\\"CFMOD-01\\\";\\r\\n    string constant CFMOD_INVALID_CERTIFICATE_OF_ASSET = \\\"CFMOD-02\\\";\\r\\n    string constant CFMOD_CALLER_IS_NOT_FUND_MANAGER = \\\"CFMOD-03\\\";\\r\\n\\r\\n    // DABotSettingLib (BSL)\\r\\n    string constant BSL_CALLER_IS_NOT_OWNER = \\\"BSL-01\\\";\\r\\n    string constant BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR = \\\"BSL-02\\\";\\r\\n    string constant BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME = \\\"BSL-03\\\";\\r\\n    string constant BSL_BOT_IS_ABANDONED = \\\"BSL-04\\\";\\r\\n\\r\\n    // DABotSettingModule (BSMOD)\\r\\n    string constant BSMOD_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME =  \\\"BSMOD-01\\\";\\r\\n    string constant BSMOD_INIT_DEPOSIT_IS_LESS_THAN_CONFIGURED_THRESHOLD = \\\"BSMOD-02\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_ZERO = \\\"BSMOD-03\\\";\\r\\n    string constant BSMOD_INSUFFICIENT_MAX_SHARE = \\\"BSMOD-04\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_GREATER_THAN_IBO_SHARE = \\\"BSMOD-05\\\";\\r\\n\\r\\n    // DABotCertLocker (LOCKER)\\r\\n    string constant LOCKER_CALLER_IS_NOT_OWNER_BOT = \\\"LOCKER-01\\\";\\r\\n\\r\\n    // DABotStakingModule (BSTMOD)\\r\\n    string constant BSTMOD_PRE_IBO_REQUIRED = \\\"BSTMOD-01\\\";\\r\\n    string constant BSTMOD_AFTER_IBO_REQUIRED = \\\"BSTMOD-02\\\";\\r\\n    string constant BSTMOD_INVALID_PORTFOLIO_ASSET = \\\"BSTMOD-03\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_FULL = \\\"BSTMOD-04\\\";\\r\\n    string constant BSTMOD_INVALID_CERTIFICATE_ASSET = \\\"BSTMOD-05\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_ASSET_NOT_FOUND = \\\"BSTMOD-06\\\";\\r\\n    string constant BSTMOD_ASSET_IS_ZERO = \\\"BSTMOD-07\\\";\\r\\n    string constant BSTMOD_INVALID_STAKING_CAP = \\\"BSTMOD-08\\\";\\r\\n    string constant BSTMOD_INSUFFICIENT_FUND = \\\"BSTMOD-09\\\";\\r\\n    string constant BSTMOD_CAP_IS_ZERO = \\\"BSTMOD-10\\\";\\r\\n    string constant BSTMOD_CAP_IS_LESS_THAN_STAKED_AND_IBO_CAP = \\\"BSTMOD-11\\\";\\r\\n    string constant BSTMOD_WERIGHT_IS_ZERO = \\\"BSTMOD-12\\\";\\r\\n\\r\\n    // CEX FundManager (CFM)\\r\\n    string constant CFM_REQ_TYPE_IS_MISMATCHED = \\\"CFM-01\\\";\\r\\n    string constant CFM_INVALID_REQUEST_ID = \\\"CFM-02\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_BOT_TOKEN = \\\"CFM-03\\\";\\r\\n    string constant CFM_CLOSE_TYPE_VALUE_IS_NOT_SUPPORTED = \\\"CFM-04\\\";\\r\\n    string constant CFM_UNKNOWN_REQUEST_TYPE = \\\"CFM-05\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_REQUESTER = \\\"CFM-06\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_APPROVER = \\\"CFM-07\\\";\\r\\n    string constant CFM_CEX_CERTIFICATE_IS_REQUIRED = \\\"CFM-08\\\";\\r\\n    string constant CFM_TREASURY_ASSET_CERTIFICATE_IS_REQUIRED = \\\"CFM-09\\\";\\r\\n    string constant CFM_FAIL_TO_TRANSFER_VALUE = \\\"CFM-10\\\";\\r\\n    string constant CFM_AWARDED_ASSET_IS_NOT_TREASURY = \\\"CFM-11\\\";\\r\\n    string constant CFM_INSUFFIENT_ASSET_TO_MINT_STOKEN = \\\"CFM-12\\\";\\r\\n\\r\\n    // FarmBot Module (FBM)  string constant FBM_ = \\\"FBM-\\\";\\r\\n    string constant FBM_CANNOT_REMOVE_WORKER = \\\"FBM-01\\\";\\r\\n    string constant FBM_NULL_OPERATOR_ACCOUNT = \\\"FBM-02\\\";\\r\\n    string constant FBM_INVALID_WORKER = \\\"FBM-03\\\";\\r\\n    string constant FBM_REPAY_ERROR = \\\"FBM-04\\\";\\r\\n    string constant FBM_INVALID_SWAP_ADAPTER = \\\"FBM-05\\\";\\r\\n    string constant FBM_INVALID_SWAP_PATH = \\\"FBM-06\\\";\\r\\n    string constant FBM_INSUFFICIENT_FUND = \\\"FBM-07\\\";\\r\\n\\r\\n    // TreasuryAsset (TA)\\r\\n    string constant TA_MINT_ZERO_AMOUNT = \\\"TA-01\\\";\\r\\n    string constant TA_LOCK_AMOUNT_EXCEED_BALANCE = \\\"TA-02\\\";\\r\\n    string constant TA_UNLOCK_AMOUNT_AND_PASSED_VALUE_IS_MISMATCHED = \\\"TA-03\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_AVAILABLE_BALANCE = \\\"TA-04\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_VALUE_BALANCE = \\\"TA-05\\\";\\r\\n    string constant TA_FUND_MANAGER_IS_NOT_SET = \\\"TA-06\\\";\\r\\n    string constant TA_FAIL_TO_TRANSFER_VALUE = \\\"TA-07\\\";\\r\\n\\r\\n    // Governance (GOV)\\r\\n    string constant GOV_DEFAULT_STRATEGY_IS_NOT_SET = \\\"GOV-01\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_CREATE_PROPOSAL = \\\"GOV-02\\\";\\r\\n    string constant GOV_INSUFFICIENT_VICS_TO_CREATE_PROPOSAL = \\\"GOV-03\\\";\\r\\n    string constant GOV_INVALID_PROPOSAL_ID = \\\"GOV-04\\\";\\r\\n    string constant GOV_REQUIRED_PROPOSER_OR_GUARDIAN = \\\"GOV-05\\\";\\r\\n    string constant GOV_TARGET_SHOULD_BE_ZERO_OR_REGISTERED_BOT = \\\"GOV-06\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_VOTE = \\\"GOV-07\\\";\\r\\n    string constant GOV_INVALID_NEW_STATE = \\\"GOV-08\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_CLOSED_PROPOSAL = \\\"GOV-08\\\";\\r\\n    string constant GOV_INVALID_CREATION_DATA = \\\"GOV-09\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_ON_CHAIN_PROPOSAL = \\\"GOV-10\\\";\\r\\n    string constant GOV_PROPOSAL_DONT_ACCEPT_VOTE = \\\"GOV-11\\\";\\r\\n    string constant GOV_DUPLICATED_VOTE = \\\"GOV-12\\\";\\r\\n    string constant GOV_CAN_ONLY_QUEUE_PASSED_PROPOSAL = \\\"GOV-13\\\";\\r\\n    string constant GOV_DUPLICATED_ACTION = \\\"GOV-14\\\";\\r\\n    string constant GOV_INVALID_VICS_ADDRESS = \\\"GOV-15\\\";\\r\\n\\r\\n    // Timelock Executor (TLE)\\r\\n    string constant TLE_DELAY_SHORTER_THAN_MINIMUM = \\\"TLE-01\\\";\\r\\n    string constant TLE_DELAY_LONGER_THAN_MAXIMUM = \\\"TLE-02\\\";\\r\\n    string constant TLE_ONLY_BY_ADMIN = \\\"TLE-03\\\";\\r\\n    string constant TLE_ONLY_BY_PENDING_ADMIN = \\\"TLE-04\\\";\\r\\n    string constant TLE_ONLY_BY_THIS_TIMELOCK = \\\"TLE-05\\\";\\r\\n    string constant TLE_EXECUTION_TIME_UNDERESTIMATED = \\\"TLE-06\\\";\\r\\n    string constant TLE_ACTION_NOT_QUEUED = \\\"TLE-07\\\";\\r\\n    string constant TLE_TIMELOCK_NOT_FINISHED = \\\"TLE-08\\\";\\r\\n    string constant TLE_GRACE_PERIOD_FINISHED = \\\"TLE-09\\\";\\r\\n    string constant TLE_NOT_ENOUGH_MSG_VALUE = \\\"TLE-10\\\";\\r\\n\\r\\n    // DABotVoteStrategy (BVS) string constant BVS_ = \\\"BVS-\\\";\\r\\n    string constant BVS_NOT_A_REGISTERED_DABOT = \\\"BVS-01\\\";\\r\\n\\r\\n    // DABotWhiteList (BWL) string constant BWL_ = \\\"BWL-\\\";\\r\\n    string constant BWL_ACCOUNT_IS_ZERO = \\\"BWL-01\\\";\\r\\n    string constant BWL_ACCOUNT_IS_NOT_WHITELISTED = \\\"BWL-02\\\";\\r\\n\\r\\n    // Marginal Lending Worker string constant MLF_ = \\\"MLF-\\\";\\r\\n    string constant MLF_ZERO_DEPOSIT = \\\"MLF-01\\\";\\r\\n    string constant MLF_UNKNOWN_CONFIG_TOPIC = \\\"MLF-02\\\";\\r\\n    string constant MLF_REGISTERED_COLLATERAL_ID_EXPECTED = \\\"MLF-03\\\";\\r\\n    string constant MLF_CONFIG_TOPICS_AND_VALUES_MISMATCHED = \\\"MLF-04\\\";\\r\\n    string constant MLF_ADAPTER_IS_NOT_CONFIGURED = \\\"MLF-05\\\";\\r\\n    string constant MLF_CANNOT_REMOVE_IN_USED_COLLATERAL = \\\"MLF-06\\\";\\r\\n    string constant MLF_CANNOT_CHANGE_LENDING_ADAPTER = \\\"MLF-07\\\";\\r\\n    string constant MLF_INVALID_PLATFORM_TOKEN = \\\"MLF-08\\\";\\r\\n    string constant MLF_CANNOT_CHANGE_IN_USED_LEVERAGE_ASSET = \\\"MLF-09\\\";\\r\\n    string constant MLF_INVALID_EXPECTED_HEALTH_FACTOR = \\\"MLF-10\\\";\\r\\n    string constant MLF_LEVERAGE_ASSET_IS_NOT_SET = \\\"MLF-11\\\";\\r\\n    string constant MLF_INVALID_PRECISION = \\\"MLF-12\\\";\\r\\n    string constant MLF_INTERNAL_ERROR = \\\"MLF-13\\\";\\r\\n\\r\\n    // FarmCertTokenModule (FTM) string constant FTM_ = \\\"FTM-\\\";\\r\\n    string constant FTM_INSUFFICICIENT_AMOUNT_TO_DEPOSIT = \\\"FTM-01\\\";\\r\\n\\r\\n    // ILendingAdapter (ILA) string constant ILA_ = \\\"ILA-\\\";\\r\\n    string constant ILA_INVALID_EXPECTED_HEALTH_FACTOR = \\\"ILA-01\\\";\\r\\n    string constant ILA_DEPOSIT_FAILED = \\\"ILA-02\\\";\\r\\n    string constant ILA_WITHDRAW_FAILED = \\\"ILA-03\\\";\\r\\n    string constant ILA_BORROW_FAILED = \\\"ILA-04\\\";\\r\\n    string constant ILA_REPAY_BORROW_FAILED = \\\"ILA-05\\\";\\r\\n\\r\\n    // RoboFi game string constant RFG_ = \\\"RFG-\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_REGISTERED_BOT = \\\"RFG-01\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_BOT_OWNER = \\\"RFG-02\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_VAULT = \\\"RFG-03\\\";\\r\\n    string constant RFG_ROUND_NOT_FINISHED = \\\"RFG-04\\\";\\r\\n    string constant RFG_ROUND_NOT_IN_COMMIT_PHASE = \\\"RFG-05\\\";\\r\\n    string constant RFG_ROUND_NOT_IN_REVEAL_PHASE = \\\"RFG-06\\\";\\r\\n    string constant RFG_ROUND_NOT_READY_CLOSE = \\\"RFG-07\\\";\\r\\n    string constant RFG_ROUND_NOT_CLOSED_YET = \\\"RFG-08\\\";\\r\\n    string constant RFG_INVALID_SECRET_NUMBER = \\\"RFG-09\\\";\\r\\n    string constant RFG_WINNER_IS_REQUIRE = \\\"RFG-10\\\";\\r\\n    string constant RFG_INVALID_SUBMIT_WINNERS = \\\"RFG-11\\\";\\r\\n    string constant RFG_INVALID_NUMBER_OF_WINNERS = \\\"RFG-12\\\";\\r\\n    string constant RFG_INVALID_WON_NUMBER = \\\"RFG-13\\\";\\r\\n    string constant RFG_INVALID_VICS_ADDRESS = \\\"RFG-14\\\";\\r\\n    string constant RFG_INVALID_COMMIT_DURATION = \\\"RFG-15\\\";\\r\\n    string constant RFG_INVALID_REVEAL_DURATION = \\\"RFG-16\\\";\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/IConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\nlibrary Roles {\\r\\n    bytes32 constant ROLE_ADMIN = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_OPERATORS = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_TEMPLATE_CREATOR = keccak256('creator.template.dabot.role');\\r\\n    bytes32 constant ROLE_BOT_CREATOR = keccak256('creator.dabot.role');\\r\\n    bytes32 constant ROLE_FUND_APPROVER = keccak256('approver.fund.role');\\r\\n}\\r\\n\\r\\nlibrary AddressBook {\\r\\n    bytes32 constant ADDR_FACTORY = keccak256('factory.address');\\r\\n    bytes32 constant ADDR_VICS = keccak256('vics.address');\\r\\n    bytes32 constant ADDR_TAX = keccak256('tax.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE = keccak256('governance.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE_EXECUTOR = keccak256('executor.governance.address');\\r\\n    bytes32 constant ADDR_BOT_MANAGER = keccak256('botmanager.address');\\r\\n    bytes32 constant ADDR_VICS_EXCHANGE = keccak256('exchange.vics.address');\\r\\n    bytes32 constant ADDR_TREASURY_MANAGER = keccak256('treasury-manager.address');\\r\\n    bytes32 constant ADDR_CEX_FUND_MANAGER = keccak256('fund-manager.address');\\r\\n    bytes32 constant ADDR_CEX_DEFAULT_MASTER_ACCOUNT = keccak256('default.master.address');\\r\\n    bytes32 constant ADDR_ROBOFI_GAME = keccak256('robofi-game.address');\\r\\n}\\r\\n\\r\\nlibrary Config {\\r\\n    /// The amount of VICS that a proposer has to pay when create a new proposal\\r\\n    bytes32 constant PROPOSAL_DEPOSIT = keccak256('deposit.proposal.config');\\r\\n\\r\\n    /// The percentage of proposal creation fee distributed to the account that execute a propsal\\r\\n    bytes32 constant PROPOSAL_REWARD_PERCENT = keccak256('reward.proposal.config');\\r\\n\\r\\n    /// The minimum VICS a bot creator has to deposit to a newly created bot\\r\\n    bytes32 constant CREATOR_DEPOSIT = keccak256('deposit.creator.config');\\r\\n\\r\\n    /// The minim \\r\\n    bytes32 constant PROPOSAL_CREATOR_MININUM_POWER = keccak256('minpower.goverance.config');\\r\\n    \\r\\n    /// The minimum percentage of for-votes over total votes a proposal has to achieve to be passed\\r\\n    bytes32 constant PROPOSAL_MINIMUM_QUORUM = keccak256('minquorum.governance.config');\\r\\n\\r\\n    /// The minimum difference (in percentage) between for-votes and against-vote for a proposal to be passed\\r\\n    bytes32 constant PROPOSAL_VOTE_DIFFERENTIAL = keccak256('differential.governance.config');\\r\\n\\r\\n    /// The voting duration of a proposal\\r\\n    bytes32 constant PROPOSAL_DURATION = keccak256('duration.goverance.config');\\r\\n\\r\\n    /// The interval that a passed proposed is waiting in queue before being executed\\r\\n    bytes32 constant PROPOSAL_EXECUTION_DELAY = keccak256('execdelay.governance.config');\\r\\n\\r\\n    // Number of winners of RoboFi Game\\r\\n    bytes32 constant GAME_NUMBER_WINNER = keccak256('num-of-winner.game.config');\\r\\n\\r\\n    // The commit phase duration of a game\\r\\n    bytes32 constant GAME_COMMIT_DURATION = keccak256('commit.game.config');\\r\\n\\r\\n    // The reveal phase duration of a game\\r\\n    bytes32 constant GAME_REVEAL_DURATION = keccak256('reveal.game.config');\\r\\n}\\r\\n\\r\\ninterface IConfigurator {\\r\\n    function addressOf(bytes32 addrId) external view returns(address);\\r\\n    function configOf(bytes32 configId) external view returns(uint);\\r\\n    function bytesConfigOf(bytes32 configId) external view returns(bytes memory);\\r\\n\\r\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\r\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\r\\n\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/common/IRoboFiFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRoboFiFactory {\\r\\n    function deploy(address masterContract, \\r\\n                    bytes calldata data, \\r\\n                    bool useCreate2) \\r\\n        external \\r\\n        payable \\r\\n        returns(address);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/dabot/controller/DABotControllerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IBotTemplateController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernToken.sol\\\";\\r\\nimport \\\"../interfaces/IDABotManager.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct BotTemplateController {\\r\\n    mapping(bytes4 => bytes32) selectors;\\r\\n    mapping(bytes32 => address) moduleAddresses;\\r\\n    bytes32[] modules;\\r\\n}\\r\\n\\r\\nstruct BotCoreData {\\r\\n    BotTemplateController controller;\\r\\n    BotMetaData metadata;\\r\\n    BotSetting setting;\\r\\n}\\r\\n\\r\\nlibrary DABotTemplateControllerLib {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function controller() internal view returns (BotTemplateController storage) {\\r\\n        return coredata().controller;\\r\\n    }\\r\\n\\r\\n    function requireNewModule(bytes32 moduleId) internal view {\\r\\n        BotTemplateController storage ds = controller();\\r\\n        require(ds.module(moduleId) == address(0), Errors.BCL_DUPLICATED_MODULE);\\r\\n    }\\r\\n\\r\\n    function module(BotTemplateController storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function moduleOfSelector(BotTemplateController storage ds, bytes4 selector) internal view returns(address) {\\r\\n        bytes32 moduleId = ds.selectors[selector];\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function registerModule(BotTemplateController storage ds, bytes32 moduleId, address moduleAddress) internal returns(address oldModuleAddress) {\\r\\n        oldModuleAddress = ds.moduleAddresses[moduleId];\\r\\n        ds.moduleAddresses[moduleId] = moduleAddress;\\r\\n    }\\r\\n\\r\\n    function registerSelectors(BotTemplateController storage ds, bytes32 moduleId, bytes4[] memory selectors) internal {\\r\\n        for(uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = moduleId;\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\nlibrary DABotMetaLib {\\r\\n\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function metadata() internal view returns (BotMetaData storage) {\\r\\n        return coredata().metadata;\\r\\n    }\\r\\n\\r\\n    function manager(BotMetaData storage ds) internal view returns(IDABotManager _manager) {\\r\\n        _manager = IDABotManager(ds.botManager);\\r\\n        require(address(_manager) != address(0), Errors.BCL_BOT_MANAGER_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function configurator(BotMetaData storage ds) internal view returns(IConfigurator _config) {\\r\\n        _config = ds.manager().configurator();\\r\\n    }\\r\\n\\r\\n    function factory(BotMetaData storage ds) internal view returns(IRoboFiFactory _factory) {\\r\\n        IConfigurator config = ds.configurator();\\r\\n        _factory = IRoboFiFactory(config.addressOf(AddressBook.ADDR_FACTORY));\\r\\n        require(address(_factory) != address(0), Errors.CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function governToken(BotMetaData storage ds) internal view returns(IDABotGovernToken) {\\r\\n        address gToken = ds.gToken;\\r\\n        require(gToken != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED);\\r\\n        return IDABotGovernToken(gToken);\\r\\n    }\\r\\n\\r\\n    function module(BotMetaData storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        if (ds.botTemplate == address(0)) {\\r\\n            return DABotTemplateControllerLib.controller().module(moduleId);\\r\\n        }\\r\\n        return IBotTemplateController(ds.botTemplate).module(moduleId);\\r\\n    }\\r\\n\\r\\n    function deployCertToken(BotMetaData storage ds, address asset) internal returns(address) {\\r\\n        address certTokenMaster = ds.module(BOT_CERT_TOKEN_TEMPLATE_ID);\\r\\n        if (certTokenMaster == address(0)) {\\r\\n            revert(string(abi.encodePacked(\\r\\n                Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED, \\r\\n                '. template: ', \\r\\n                Strings.toHexString(uint160(ds.botTemplate), 20)\\r\\n                )));\\r\\n        }\\r\\n        require(certTokenMaster != address(0), Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            certTokenMaster,\\r\\n            abi.encode(address(this), asset),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployGovernanceToken(BotMetaData storage ds) internal returns(address) {\\r\\n        address governTokenMaster = ds.module(BOT_GOV_TOKEN_TEMPLATE_ID);\\r\\n        require(governTokenMaster != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            governTokenMaster,\\r\\n            abi.encode(address(this)),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployLocker(BotMetaData storage ds, bytes32 lockerType, LockerData memory data) internal returns(address) {\\r\\n        address lockerMaster = ds.module(lockerType);\\r\\n        if (lockerMaster == address(0)) {\\r\\n            if (lockerType == BOT_CERT_TOKEN_COOLDOWN_HANDLER_ID) \\r\\n                revert(Errors.BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED);\\r\\n            revert(Errors.BCL_UKNOWN_MODULE_ID);\\r\\n        }\\r\\n        return ds.factory().deploy(\\r\\n            lockerMaster,\\r\\n            abi.encode(data),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/DABotCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IDABotComponent.sol\\\";\\r\\n\\r\\nenum BotStatus { PRE_IBO, IN_IBO, ACTIVE, ABANDONED }\\r\\n\\r\\nstruct BotModuleInitData {\\r\\n    bytes32 moduleId;\\r\\n    bytes data;\\r\\n}\\r\\n\\r\\nstruct BotSetting {             // for saving storage, the meta-fields of a bot are encoded into a single uint256 byte slot.\\r\\n    uint64 iboTime;             // 32 bit low: iboStartTime (unix timestamp), \\r\\n                                // 32 bit high: iboEndTime (unix timestamp)\\r\\n    uint24 stakingTime;         // 8 bit low: warm-up time, \\r\\n                                // 8 bit mid: cool-down time\\r\\n                                // 8 bit high: time unit (0 - day, 1 - hour, 2 - minute, 3 - second)\\r\\n    uint32 pricePolicy;         // 16 bit low: price multiplier (fixed point, 2 digits for decimal)\\r\\n                                // 16 bit high: commission fee in percentage (fixed point, 2 digit for decimal)\\r\\n    uint128 profitSharing;      // packed of 16bit profit sharing: bot-creator, gov-user, stake-user, and robofi-game\\r\\n    uint initDeposit;           // the intial deposit (in VICS) of bot-creator\\r\\n    uint initFounderShare;      // the intial shares (i.e., governance token) distributed to bot-creator\\r\\n    uint maxShare;              // max cap of gtoken supply\\r\\n    uint iboShare;              // max supply of gtoken for IBO. Constraint: maxShare >= iboShare + initFounderShare\\r\\n}\\r\\n\\r\\nstruct BotMetaData {\\r\\n    string name;\\r\\n    string symbol;\\r\\n    string version;\\r\\n    uint8 botType;\\r\\n    bool abandoned;\\r\\n    bool isTemplate;        // determine this module is a template, not a bot instance\\r\\n    bool initialized;       // determines whether the bot has been initialized \\r\\n    address botOwner;       // the public address of the bot owner\\r\\n    address botManager;\\r\\n    address botTemplate;    // address of the template contract \\r\\n    address gToken;         // address of the governance token\\r\\n}\\r\\n\\r\\nstruct BotDetail { // represents a detail information of a bot, merely use for bot infomation query\\r\\n    uint id;                    // the unique id of a bot within its manager.\\r\\n                                // note: this id only has value when calling {DABotManager.queryBots}\\r\\n    address botAddress;         // the contract address of the bot.\\r\\n\\r\\n    BotStatus status;           // 0 - PreIBO, 1 - InIBO, 2 - Active, 3 - Abandonned\\r\\n    uint8 botType;              // type of the bot (inherits from the bot's template)\\r\\n    string botSymbol;           // get the bot name.\\r\\n    string botName;             // get the bot full name.\\r\\n    address governToken;        // the address of the governance token\\r\\n    address template;           // the address of the master contract which defines the behaviors of this bot.\\r\\n    string templateName;        // the template name.\\r\\n    string templateVersion;     // the template version.\\r\\n    uint iboStartTime;          // the time when IBO starts (unix second timestamp)\\r\\n    uint iboEndTime;            // the time when IBO ends (unix second timestamp)\\r\\n    uint warmup;                // the duration (in days) for which the staking profit starts counting\\r\\n    uint cooldown;              // the duration (in days) for which users could claim back their stake after submiting the redeem request.\\r\\n    uint priceMul;              // the price multiplier to calculate the price per gtoken (based on the IBO price).\\r\\n    uint commissionFee;         // the commission fee when buying gtoken after IBO time.\\r\\n    uint initDeposit;           \\r\\n    uint initFounderShare;\\r\\n    uint144 profitSharing;\\r\\n    uint maxShare;              // max supply of governance token.\\r\\n    uint circulatedShare;       // the current supply of governance token.\\r\\n    uint iboShare;              // the max supply of gtoken for IBO.\\r\\n    uint userShare;             // the amount of governance token in the caller's balance.\\r\\n    UserPortfolioAsset[] portfolio;\\r\\n}\\r\\n\\r\\nstruct BotModuleInfo {\\r\\n    string name;\\r\\n    string version;\\r\\n    address handler;\\r\\n}\\r\\n\\r\\nstruct PortfolioCreationData {\\r\\n    address asset;\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct PortfolioAsset {\\r\\n    address certToken;    // the certificate asset to return to stake-users\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct UserPortfolioAsset {\\r\\n    address asset;\\r\\n    PortfolioAsset info;\\r\\n    uint256 userStake;\\r\\n    uint256 totalStake;     // the total stake of all users.\\r\\n    uint256 certSupply;     // the total supply of the certificated token\\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Records warming-up certificate tokens of a DABot.\\r\\n*/\\r\\nstruct LockerData {         \\r\\n    address bot;            // the DABOT which creates this locker.\\r\\n    address owner;          // the locker owner, who is albe to unlock and get tokens after the specified release time.\\r\\n    address token;          // the contract of the certificate token.\\r\\n    uint64 created_at;      // the moment when locker is created.\\r\\n    uint64 release_at;      // the monent when locker could be unlock. \\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Provides detail information of a warming-up token lock, plus extra information.\\r\\n    */\\r\\nstruct LockerInfo {\\r\\n    address locker;\\r\\n    LockerData info;\\r\\n    uint256 amount;         // the locked amount of cert token within this locker.\\r\\n    uint256 reward;         // the accumulated rewards\\r\\n    address asset;          // the stake asset beyond the certificated token\\r\\n}\\r\\n\\r\\nstruct MintableShareDetail {\\r\\n    address asset;\\r\\n    uint stakeAmount;\\r\\n    uint mintableShare;\\r\\n    uint weight;\\r\\n    uint iboCap;\\r\\n}\\r\\n\\r\\nstruct AwardingDetail {\\r\\n    address asset;\\r\\n    uint compound;\\r\\n    uint reward;\\r\\n    uint compoundMode;  // 0 - increase, 1 - decrrease\\r\\n}\\r\\n\\r\\nstruct StakingReward {\\r\\n    address asset;\\r\\n    uint amount;\\r\\n}\\r\\n\\r\\nstruct BenefitciaryInfo {\\r\\n    address account;\\r\\n    string name;\\r\\n    string shortName;\\r\\n    uint weight;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/DABotModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"../common/Errors.sol\\\";\\r\\nimport \\\"./DABotCommon.sol\\\";\\r\\nimport \\\"./interfaces/IDABotModule.sol\\\";\\r\\nimport \\\"./whitelist/DABotWhitelistLib.sol\\\";\\r\\nimport \\\"./controller/DABotControllerLib.sol\\\";\\r\\n\\r\\nabstract contract DABotModule is IDABotModule, Context {\\r\\n\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    \\r\\n\\r\\n    modifier onlyTemplateAdmin() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(ds.isTemplate && (ds.botOwner == _msgSender()), \\r\\n            \\\"BotModule: caller is not template admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyBotOwner() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.isTemplate && (!ds.initialized || ds.botOwner == _msgSender()), Errors.BMOD_CALLER_IS_NOT_OWNER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyBotManager() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.initialized || ds.botManager == _msgSender(), Errors.BMOD_CALLER_IS_NOT_BOT_MANAGER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier activeBot() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.abandoned, Errors.BMOD_BOT_IS_ABANDONED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whitelistCheck(address account, uint scope) {\\r\\n        require(DABotWhitelistLib.isWhitelist(account, scope), Errors.BWL_ACCOUNT_IS_NOT_WHITELISTED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier initializer() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.initialized, Errors.CM_CONTRACT_HAS_BEEN_INITIALIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function configurator() internal view returns(IConfigurator) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        return meta.manager().configurator();\\r\\n    }\\r\\n\\r\\n    function onRegister(address moduleAddress) external override onlyTemplateAdmin {\\r\\n        _onRegister(moduleAddress);\\r\\n    }\\r\\n\\r\\n    function onInitialize(bytes calldata data) external override initializer {\\r\\n        _initialize(data);\\r\\n    }\\r\\n\\r\\n    function _initialize(bytes calldata data) internal virtual;\\r\\n    function _onRegister(address moduleAddress) internal virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotTemplateController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IBotTemplateController {\\r\\n    function registerModule(address moduleHandler) external;\\r\\n    function updateModuleHandler(bytes32 moduleId, address newModuleAddress) external;\\r\\n    function module(bytes32 moduleId) external view returns(address);\\r\\n    function moduleOfSelector(bytes32 selector) external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\n\\r\\nstruct VaultData {\\r\\n    address botToken;\\r\\n    IERC20 asset;\\r\\n    address bot;\\r\\n    uint8 index;                // the index-th vault generated from botToken\\r\\n                                //  0 - warmup vault, 1 - regular vault, 2 - VIP vault\\r\\n    bytes4 vaultType;           // type of the vault, used to determine the vault handler\\r\\n}\\r\\n\\r\\nstruct UserInfo {\\r\\n    uint deposit;\\r\\n    uint debtPoints;\\r\\n    uint debt;\\r\\n    uint lockPeriod;\\r\\n    uint lastDepositTime;\\r\\n}\\r\\n\\r\\nstruct VaultInfo {\\r\\n    VaultData data;             \\r\\n    UserInfo user;\\r\\n    uint totalDeposit;          // total deposits in the vault\\r\\n    uint accRewardPerShare;     // the pending reward per each unit of deposit\\r\\n    uint lastRewardTime;        // the block time of the last reward transaction\\r\\n    uint pendingReward;         // the pending reward for the caller\\r\\n    bytes option;               // vault option\\r\\n} \\r\\n\\r\\nstruct RegularVaultOption {\\r\\n    bool restricted;    // restrict deposit activity to bot only\\r\\n}\\r\\n\\r\\n\\r\\ninterface IBotVaultEvent {\\r\\n    event Deposit(uint vID, address indexed payor, address indexed account, uint amount);\\r\\n    event Widthdraw(uint vID, address indexed account, uint amount);\\r\\n    event RewardAdded(uint vID, uint assetAmount);\\r\\n    event RewardClaimed(uint vID, address indexed account, uint amount);\\r\\n    event Snapshot(uint vID, uint snapshotId);\\r\\n}\\r\\n\\r\\ninterface IBotVault is IBotVaultEvent {\\r\\n    function deposit(uint vID, uint amount) external;\\r\\n    function delegateDeposit(uint vID, address payor, address account, uint amount, uint lockTime) external;\\r\\n    function withdraw(uint vID, uint amount) external;\\r\\n    function delegateWithdraw(uint vID, address account, uint amount) external;\\r\\n    function pendingReward(uint vID, address account) external view returns(uint);\\r\\n    function balanceOf(uint vID, address account) external view returns(uint);\\r\\n    function balanceOfAt(uint vID, address account, uint blockNo) external view returns(uint);\\r\\n    function updateReward(uint vID, uint assetAmount) external;\\r\\n    function claimReward(uint vID, address account) external;\\r\\n\\r\\n    /**\\r\\n    @dev Queries user deposit info for the given vault.\\r\\n    @param vID the vault ID to query.\\r\\n    @param account the user account to query.\\r\\n     */\\r\\n    function getUserInfo(uint vID, address account) external view returns(UserInfo memory result);\\r\\n    function getVaultInfo(uint vID, address account) external view returns(VaultInfo memory);\\r\\n    function getVaultOption(uint vID) external view returns(bytes memory);\\r\\n    function setVaultOption(uint vID, bytes calldata option) external;\\r\\n}\\r\\n\\r\\ninterface IBotVaultManagerEvent is IBotVaultEvent {\\r\\n    event OpenVault(uint vID, VaultData data);\\r\\n    event DestroyVault(uint vID);\\r\\n    event RegisterHandler(bytes4 vaultType, address handler);\\r\\n    event BotManagerUpdated(address indexed botManager);\\r\\n}\\r\\n\\r\\ninterface IBotVaultManager is IBotVault, IBotVaultManagerEvent {\\r\\n    function vaultOf(uint vID) external view returns(VaultData memory result);\\r\\n    function validVault(uint vID) external view returns(bool);\\r\\n    function createVault(VaultData calldata data) external returns(uint);\\r\\n    function destroyVault(uint vID) external;\\r\\n    function vaultId(address botToken, uint8 vaultIndex) external pure returns(uint);\\r\\n    function registerHandler(bytes4 vaultType, IBotVault handler) external;\\r\\n    function botManager() external view returns(address);\\r\\n    function setBotManager(address account) external;\\r\\n    function snapshot(uint vID) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotComponent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nbytes32 constant IDABotFarmingModuleID = keccak256(\\\"farming.module\\\");\\r\\nbytes32 constant IDABotFundManagerModuleID = keccak256('fundmanager.module');\\r\\nbytes32 constant IDABotStakingModuleID = keccak256(\\\"staking.module\\\");\\r\\nbytes32 constant IDABotGovernModuleID = keccak256('governance.module');\\r\\nbytes32 constant IDABotSettingModuleID = keccak256('setting.module');\\r\\nbytes32 constant IDABotWhitelistModuleID = keccak256(\\\"whitelist.module\\\");\\r\\n\\r\\nbytes32 constant GovTokenHandlerID = keccak256('govtokenimpl.dabot.module');\\r\\nbytes32 constant CertTokenHandlerID = keccak256('certtokenimpl.dabot.module');\\r\\n\\r\\nbytes32 constant BOT_CERT_TOKEN_COOLDOWN_HANDLER_ID = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\nbytes32 constant BOT_CERT_TOKEN_TEMPLATE_ID = keccak256(\\\"certificate-token.dabot.module\\\");\\r\\nbytes32 constant BOT_GOV_TOKEN_TEMPLATE_ID = keccak256(\\\"governance-token.dabot.module\\\");\\r\\n\\r\\n//bytes32 constant BOT_MODULE_COOLDOWN_LOCKER = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\ninterface IDABotComponent {   \\r\\n    function moduleInfo() external view returns(string memory name, string memory version, bytes32 moduleId);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotGovernToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotGovernToken is IERC20 {\\r\\n\\r\\n    function isGovernToken() external view returns(bool);\\r\\n    \\r\\n    function owner() external view returns(address);\\r\\n    function asset() external view returns (IERC20);\\r\\n    function value(uint amount) external view returns(uint);\\r\\n    function mint(address account, uint amount) external;\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    function snapshot() external;\\r\\n    function totalSupplyAt(uint256 snapshotId) external view returns(uint256);\\r\\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBotVault.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../../common/IRoboFiFactory.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\n\\r\\ninterface IDABotManagerEvent {\\r\\n    event BotRemoved(address indexed bot);\\r\\n    event BotDeployed(uint botId, address indexed bot, BotDetail detail); \\r\\n    event TemplateRegistered(address indexed template, string name, string version, uint8 templateType);\\r\\n}\\r\\n\\r\\ninterface IDABotManager is IDABotManagerEvent {\\r\\n    \\r\\n    function configurator() external view returns(IConfigurator);\\r\\n    function vaultManager() external view returns(IBotVaultManager);\\r\\n    function addTemplate(address template) external;\\r\\n    function templates() external view returns(address[] memory);\\r\\n    function isRegisteredTemplate(address template) external view returns(bool);\\r\\n    function isRegisteredBot(address botAccount) external view returns(bool);\\r\\n    function totalBots() external view returns(uint);\\r\\n    function botIdOf(string calldata qualifiedName) external view returns(int);\\r\\n    function queryBots(uint[] calldata botId) external view returns(BotDetail[] memory output);\\r\\n    function deployBot(address template, \\r\\n                        string calldata symbol, \\r\\n                        string calldata name,\\r\\n                        BotModuleInitData[] calldata initData\\r\\n                        ) external;\\r\\n    function snapshot(address botAccount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IDABotComponent.sol\\\";\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n@dev An common interface of a DABot module.\\r\\n */\\r\\ninterface IDABotModule is IDABotComponent {\\r\\n    event ModuleRegistered(string name, bytes32 moduleId, address indexed moduleAddress);\\r\\n    \\r\\n    function onRegister(address moduleAddress) external;\\r\\n    function onInitialize(bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nuint constant WHITELIST_CHECK_STAKE_USERS = 1;\\r\\nuint constant WHITELIST_CHECK_GOV_USERS = 2;\\r\\n\\r\\ninterface IDABotWhitelistModuleEvent {\\r\\n    event WhitelistScope(uint scope);\\r\\n    event WhitelistAdd(address indexed account, uint scope);\\r\\n    event WhitelistRemove(address indexed account);\\r\\n}\\r\\n\\r\\ninterface IDABotWhitelistModule is IDABotWhitelistModuleEvent {\\r\\n\\r\\n    function whitelistScope() external view returns(uint);\\r\\n    function setWhitelistScope(uint scope) external;\\r\\n    function addWhitelist(address account, uint scope) external;\\r\\n    function removeWhitelist(address account) external;\\r\\n    function isWhitelist(address acount, uint scope) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/whitelist/DABotWhitelistLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IDABotWhitelist.sol\\\";\\r\\n\\r\\nstruct BotWhitelistData {\\r\\n    uint scope;    // an integer flag to determine the scope where whitelist is apply\\r\\n    mapping(address => uint) whitelist;\\r\\n}\\r\\n\\r\\nlibrary DABotWhitelistLib {\\r\\n\\r\\n    bytes32 constant WHITELIST_STORAGE_POSITION = keccak256(\\\"whitelist.dabot.storage\\\");\\r\\n\\r\\n    function whitelist() internal pure returns(BotWhitelistData storage ds) {\\r\\n        bytes32 position = WHITELIST_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isWhitelist(address account, uint scope) internal view returns(bool) {\\r\\n        BotWhitelistData storage data = whitelist();\\r\\n        if (data.scope & scope == 0)\\r\\n            return true;\\r\\n        return (data.whitelist[account] & scope) > 0;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/whitelist/DABotWhitelistModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IDABotWhitelist.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../DABotModule.sol\\\";\\r\\n\\r\\ncontract DABotWhitelistModule is DABotModule, IDABotWhitelistModuleEvent {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    function _onRegister(address moduleAddress) internal override {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        ds.registerModule(IDABotWhitelistModuleID, moduleAddress); \\r\\n        bytes4[5] memory selectors =  [\\r\\n            IDABotWhitelistModule.whitelistScope.selector,\\r\\n            IDABotWhitelistModule.setWhitelistScope.selector,\\r\\n            IDABotWhitelistModule.addWhitelist.selector,\\r\\n            IDABotWhitelistModule.removeWhitelist.selector,\\r\\n            IDABotWhitelistModule.isWhitelist.selector\\r\\n        ];\\r\\n        for (uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = IDABotWhitelistModuleID;\\r\\n\\r\\n        emit ModuleRegistered(\\\"IDABotWhitelistModule\\\", IDABotWhitelistModuleID, moduleAddress);\\r\\n    }\\r\\n\\r\\n    function _initialize(bytes calldata data) internal override {\\r\\n    }\\r\\n\\r\\n    function moduleInfo() external pure override returns(string memory name, string memory version, bytes32 moduleId) {\\r\\n        name = \\\"DABotWhitelistModule\\\";\\r\\n        version = \\\"v0.1.211202\\\";\\r\\n        moduleId = IDABotWhitelistModuleID;\\r\\n    }\\r\\n\\r\\n    function whitelistScope() external view returns(uint) {\\r\\n        BotWhitelistData storage data = DABotWhitelistLib.whitelist();\\r\\n        return data.scope;\\r\\n    }\\r\\n\\r\\n    function setWhitelistScope(uint scope) external onlyBotOwner {\\r\\n        BotWhitelistData storage data = DABotWhitelistLib.whitelist();\\r\\n        data.scope = scope;\\r\\n        emit WhitelistScope(scope);\\r\\n    }\\r\\n\\r\\n    function addWhitelist(address account, uint scope) external onlyBotOwner {\\r\\n        require(account != address(0), Errors.BWL_ACCOUNT_IS_ZERO);\\r\\n        BotWhitelistData storage data = DABotWhitelistLib.whitelist();\\r\\n        data.whitelist[account] = scope;\\r\\n        emit WhitelistAdd(account, scope);\\r\\n    }\\r\\n\\r\\n    function removeWhitelist(address account) external onlyBotOwner {\\r\\n        require(account != address(0), Errors.BWL_ACCOUNT_IS_ZERO);\\r\\n        BotWhitelistData storage data = DABotWhitelistLib.whitelist();\\r\\n        data.whitelist[account] = 0;\\r\\n        emit WhitelistRemove(account);\\r\\n    }\\r\\n\\r\\n    function isWhitelist(address account, uint scope) external view returns(bool) {\\r\\n        require(account != address(0), Errors.BWL_ACCOUNT_IS_ZERO);\\r\\n        return DABotWhitelistLib.isWhitelist(account, scope);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/token/IRoboFiERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IRoboFiERC20 is IERC20 {\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"WhitelistAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"WhitelistScope\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"addWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"isWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onInitialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"}],\"name\":\"onRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"setWhitelistScope\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistScope\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DABotWhitelistModule", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}