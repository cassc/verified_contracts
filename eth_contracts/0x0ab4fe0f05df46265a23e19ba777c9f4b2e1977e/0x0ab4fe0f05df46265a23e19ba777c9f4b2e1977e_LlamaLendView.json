{"SourceCode": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\n\n\n\n\n\n\n\n\n\ncontract MainnetLlamaLendAddresses {\n    address internal constant BYTES_TRANSIENT_STORAGE = 0xB3FE6f712c8B8c64CD2780ce714A36e7640DDf0f;\n    address internal constant LLAMALEND_FACTORY = 0xeA6876DDE9e3467564acBeE1Ed5bac88783205E0;\n}\n\n\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nabstract contract IBytesTransientStorage {\n    function setBytesTransiently(bytes calldata) public virtual;\n    function getBytesTransiently() public virtual returns (bytes memory);\n}\n\n\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\n\n\n\ninterface IAGG {\n    function rate() external view returns (uint256);\n    function rate(address) external view returns (uint256);\n    function rate0() external view returns (uint256);\n    function target_debt_fraction() external view returns (uint256);\n    function sigma() external view returns (int256);\n    function peg_keepers(uint256) external view returns (address); \n}\n\n\n\n\n\n\ninterface ILLAMMA {\n    function active_band_with_skip() external view returns (int256);\n    function get_sum_xy(address) external view returns (uint256[2] memory);\n    function get_xy(address) external view returns (uint256[][2] memory);\n    function get_p() external view returns (uint256);\n    function read_user_tick_numbers(address) external view returns (int256[2] memory);\n    function p_oracle_up(int256) external view returns (uint256);\n    function p_oracle_down(int256) external view returns (uint256);\n    function p_current_up(int256) external view returns (uint256);\n    function p_current_down(int256) external view returns (uint256);\n    function bands_x(int256) external view returns (uint256);\n    function bands_y(int256) external view returns (uint256);\n    function get_base_price() external view returns (uint256);\n    function price_oracle() external view returns (uint256);\n    function active_band() external view returns (int256);\n    function A() external view returns (uint256);\n    function min_band() external view returns (int256);\n    function max_band() external view returns (int256);\n    function rate() external view returns (uint256);\n    function exchange(uint256 i, uint256 j, uint256 in_amount, uint256 min_amount) external returns (uint256[2] memory);\n    function coins(uint256 i) external view returns (address);\n    function user_state(address _user) external view returns (uint256[4] memory);\n}\n\n\n\n\n\n\ninterface ILlamaLendController {\n    function create_loan(uint256 _collateralAmount, uint256 _debtAmount, uint256 _nBands) external payable;\n    function create_loan_extended(uint256 _collateralAmount, uint256 _debtAmount, uint256 _nBands, address _callbacker, uint256[] memory _callbackArgs) external payable;\n\n    /// @dev all functions below: if _collateralAmount is 0 will just return\n    function add_collateral(uint256 _collateralAmount) external payable;\n    function add_collateral(uint256 _collateralAmount, address _for) external payable;\n\n    function remove_collateral(uint256 _collateralAmount) external;\n    /// @param _useEth relevant only for ETH collateral pools (currently not deployed)\n    function remove_collateral(uint256 _collateralAmount, bool _useEth) external;\n\n    /// @dev all functions below: if _debtAmount is 0 will just return\n    function borrow_more(uint256 _collateralAmount, uint256 _debtAmount) external payable;\n    function borrow_more_extended(uint256 _collateralAmount, uint256 _debt, address _callbacker, uint256[] memory _callbackArgs) external payable;\n\n    /// @dev if _debtAmount > debt will do full repay\n    function repay(uint256 _debtAmount) external payable;\n    function repay(uint256 _debtAmount, address _for) external payable;\n    /// @param _maxActiveBand Don't allow active band to be higher than this (to prevent front-running the repay)\n    function repay(uint256 _debtAmount, address _for, int256 _maxActiveBand) external payable;\n    function repay(uint256 _debtAmount, address _for, int256 _maxActiveBand, bool _useEth) external payable;\n    function repay_extended(address _callbacker, uint256[] memory _callbackArgs) external;\n\n    function liquidate(address user, uint256 min_x) external;\n    function liquidate(address user, uint256 min_x, bool _useEth) external;\n    function liquidate_extended(address user, uint256 min_x, uint256 frac, bool use_eth, address callbacker, uint256[] memory _callbackArgs) external;\n\n\n    /// GETTERS\n    function amm() external view returns (address);\n    function monetary_policy() external view returns (address);\n    function collateral_token() external view returns (address);\n    function borrowed_token() external view returns (address);\n    function debt(address) external view returns (uint256);\n    function total_debt() external view returns (uint256);\n    function health_calculator(address, int256, int256, bool, uint256) external view returns (int256);\n    function health_calculator(address, int256, int256, bool) external view returns (int256);\n    function health(address) external view returns (int256);\n    function health(address, bool) external view returns (int256);\n    function max_borrowable(uint256 collateralAmount, uint256 nBands) external view returns (uint256);\n    function min_collateral(uint256 debtAmount, uint256 nBands) external view returns (uint256);\n    function calculate_debt_n1(uint256, uint256, uint256) external view returns (int256);\n    function minted() external view returns (uint256);\n    function redeemed() external view returns (uint256);\n    function amm_price() external view returns (uint256);\n    function user_state(address) external view returns (uint256[4] memory);\n    function user_prices(address) external view returns (uint256[2] memory);\n    function loan_exists(address) external view returns (bool);\n    function liquidation_discount() external view returns (uint256);\n    function factory() external view returns (address);\n    function loan_discount() external view returns (uint256);\n}\n\n\n\n\n\n\n\ninterface ILlamaLendFactory {\n    function controllers(uint256) external view returns (address);\n}\n\n\n\n\n\n\n\nabstract contract IWETH {\n    function allowance(address, address) public virtual view returns (uint256);\n\n    function balanceOf(address) public virtual view returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool);\n\n    function deposit() public payable virtual;\n\n    function withdraw(uint256) public virtual;\n}\n\n\n\n\n\n\n\nlibrary Address {\n    //insufficient balance\n    error InsufficientBalance(uint256 available, uint256 required);\n    //unable to send value, recipient may have reverted\n    error SendingValueFail();\n    //insufficient balance for call\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\n    //call to non-contract\n    error NonContractCall();\n    \n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        uint256 balance = address(this).balance;\n        if (balance < amount){\n            revert InsufficientBalance(balance, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!(success)){\n            revert SendingValueFail();\n        }\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        uint256 balance = address(this).balance;\n        if (balance < value){\n            revert InsufficientBalanceForCall(balance, value);\n        }\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        if (!(isContract(target))){\n            revert NonContractCall();\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n\n\n\n\n\n\n\n\nlibrary TokenUtils {\n    using SafeERC20 for IERC20;\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Only approves the amount if allowance is lower than amount, does not decrease allowance\n    function approveToken(\n        address _tokenAddr,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_tokenAddr == ETH_ADDR) return;\n\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\n        }\n    }\n\n    function pullTokensIfNeeded(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // handle max uint amount\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, _from);\n        }\n\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        }\n\n        return _amount;\n    }\n\n    function withdrawTokens(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, address(this));\n        }\n\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\n            if (_token != ETH_ADDR) {\n                IERC20(_token).safeTransfer(_to, _amount);\n            } else {\n                (bool success, ) = _to.call{value: _amount}(\"\");\n                require(success, \"Eth send fail\");\n            }\n        }\n\n        return _amount;\n    }\n\n    function depositWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).deposit{value: _amount}();\n    }\n\n    function withdrawWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).withdraw(_amount);\n    }\n\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\n        if (_tokenAddr == ETH_ADDR) {\n            return _acc.balance;\n        } else {\n            return IERC20(_tokenAddr).balanceOf(_acc);\n        }\n    }\n\n    function getTokenDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return IERC20(_token).decimals();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract LlamaLendHelper is MainnetLlamaLendAddresses, DSMath {\n    using TokenUtils for address;\n\n    error InvalidLlamaLendController();\n\n    IBytesTransientStorage constant transientStorage = IBytesTransientStorage(BYTES_TRANSIENT_STORAGE);\n    ILlamaLendFactory constant factory = ILlamaLendFactory(LLAMALEND_FACTORY);\n\n    bytes4 constant LLAMALEND_SWAPPER_ID = bytes4(keccak256(\"LlamaLendSwapper\"));\n\n    function isControllerValid(address _controllerAddr, uint256 _controllerId) public view returns (bool) {\n        return (factory.controllers(_controllerId) == _controllerAddr);\n    }\n\n    function getCollateralRatio(address _user, address _controllerAddr) public view returns (uint256 collRatio, bool isInSoftLiquidation) {\n        // fetch users debt\n        uint256 debt = ILlamaLendController(_controllerAddr).debt(_user);\n        // no position can exist without debt\n        if (debt == 0) return (0, false);\n        (uint256 debtAssetCollAmount, uint256 collAmount) = getCollAmountsFromAMM(_controllerAddr, _user);\n        // if user has debt asset as coll he is currently underwater\n        if (debtAssetCollAmount > 0) isInSoftLiquidation = true;\n\n        // fetch collToken oracle price\n        address amm = ILlamaLendController(_controllerAddr).amm();\n        uint256 oraclePrice = ILLAMMA(amm).price_oracle();\n        // calculate collAmount as WAD (18 decimals)\n        address collToken = ILlamaLendController(_controllerAddr).collateral_token();\n        uint256 assetDec = IERC20(collToken).decimals();\n        uint256 collAmountWAD = assetDec > 18 ? (collAmount / 10 ** (assetDec - 18)) : (collAmount * 10 ** (18 - assetDec));\n        \n        collRatio = wdiv(wmul(collAmountWAD, oraclePrice) + debtAssetCollAmount, debt);\n    }\n\n    function _sendLeftoverFunds(\n        address _collToken,\n        address _debtToken,\n        uint256 _collStartingBalance,\n        uint256 _debtStartingBalance,\n        address _to\n    ) internal returns (uint256 collTokenReceived, uint256 debtTokenReceived) {\n        collTokenReceived = _collToken.getBalance(address(this)) - _collStartingBalance;\n        debtTokenReceived = _debtToken.getBalance(address(this)) - _debtStartingBalance;\n        _collToken.withdrawTokens(_to, collTokenReceived);\n        _debtToken.withdrawTokens(_to, debtTokenReceived);\n    }\n\n    function userMaxWithdraw(\n        address _controllerAddress,\n        address _user\n    ) public view returns (uint256 maxWithdraw) {\n        uint256[4] memory userState = ILlamaLendController(_controllerAddress).user_state(_user);\n        return\n            userState[0] -\n            ILlamaLendController(_controllerAddress).min_collateral(userState[2], userState[3]);\n    }\n\n    function getCollAmountsFromAMM(\n        address _controllerAddress,\n        address _user\n    ) public view returns (uint256 debtAssetCollAmount, uint256 collAssetCollAmount) {\n        address llammaAddress = ILlamaLendController(_controllerAddress).amm();\n        uint256[2] memory xy = ILLAMMA(llammaAddress).get_sum_xy(_user);\n        debtAssetCollAmount = xy[0];\n        collAssetCollAmount = xy[1];\n    }\n}\n\n\n\n\n\n\ninterface IERC4626 is IERC20 {\n    function deposit(uint256 _assets, address _receiver) external returns (uint256 shares);\n    function mint(uint256 _shares, address _receiver) external returns (uint256 assets);\n    function withdraw(uint256 _assets, address _receiver, address _owner) external returns (uint256 shares);\n    function redeem(uint256 _shares, address _receiver, address _owner) external returns (uint256 assets);\n\n    function previewDeposit(uint256 _assets) external view returns (uint256 shares);\n    function previewMint(uint256 _shares) external view returns (uint256 assets);\n    function previewWithdraw(uint256 _assets) external view returns (uint256 shares);\n    function previewRedeem(uint256 _shares) external view returns (uint256 assets);\n\n    function convertToAssets(uint256 _shares) external view returns (uint256 assets);\n\n    function totalAssets() external view returns (uint256);\n\n    function asset() external view returns (address);\n}\n\n\n\n\n\n\n\ninterface ILlamaLendVault {\n    function borrow_apr() external view returns (uint256);\n    function lend_apr() external view returns (uint256);\n}\n\n\n\n\n\n\n\n\n\n\ncontract LlamaLendView is LlamaLendHelper {\n  struct Band {\n    int256 id;\n    uint256 lowPrice;\n    uint256 highPrice;\n    uint256 collAmount;\n    uint256 debtAmount;\n  }\n\n  struct CreateLoanData {\n    int256 health;\n    uint256 minColl;\n    uint256 maxBorrow;\n    Band[] bands;\n  }\n\n  struct GlobalData {\n    address collateralToken;\n    address debtToken;\n    uint256 decimals;\n    int256 activeBand;\n    uint256 A;\n    uint256 totalDebt;\n    uint256 ammPrice;\n    uint256 basePrice;\n    uint256 oraclePrice;\n    uint256 minted;\n    uint256 redeemed;\n    uint256 monetaryPolicyRate;\n    uint256 ammRate;\n    int256 minBand;\n    int256 maxBand;\n    uint256 borrowApr;\n    uint256 lendApr;\n    uint256 debtTokenTotalSupply;\n    uint256 debtTokenLeftToBorrow;\n    uint256 loanDiscount;\n  }\n\n  struct UserData {\n    bool loanExists;\n    uint256 collateralPrice;\n    uint256 marketCollateralAmount;\n    uint256 debtTokenCollateralAmount;\n    uint256 debtAmount;\n    uint256 N;\n    uint256 priceLow;\n    uint256 priceHigh;\n    uint256 liquidationDiscount;\n    int256 health;\n    int256[2] bandRange;\n    uint256[][2] usersBands;\n    uint256 collRatio;\n    bool isInSoftLiquidation;\n    uint256 debtTokenSuppliedShares;\n    uint256 debtTokenSuppliedAssets;\n  }\n\n  function userData(address market, address user) external view returns (UserData memory) {\n      ILlamaLendController ctrl = ILlamaLendController(market);\n      uint256 debtTokenSuppliedShares = IERC20(ctrl.factory()).balanceOf(user);\n      uint256 debtTokenSuppliedAssets = IERC4626(ctrl.factory()).convertToAssets(debtTokenSuppliedShares);\n      ILLAMMA amm = ILLAMMA(ctrl.amm());\n\n      if (!ctrl.loan_exists(user)) {\n        int256[2] memory bandRange = [int256(0), int256(0)];\n        uint256[][2] memory usersBands;\n\n        return UserData({\n          loanExists: false,\n          collateralPrice: 0,\n          marketCollateralAmount: 0,\n          debtTokenCollateralAmount: 0,\n          debtAmount: 0,\n          N: 0,\n          priceLow: 0,\n          priceHigh: 0,\n          liquidationDiscount: 0,\n          health: 0,\n          bandRange: bandRange,\n          usersBands: usersBands,\n          collRatio: 0,\n          isInSoftLiquidation: false,\n          debtTokenSuppliedShares: debtTokenSuppliedShares,\n          debtTokenSuppliedAssets: debtTokenSuppliedAssets\n        });\n      }\n\n      uint256[4] memory amounts = ctrl.user_state(user);\n      uint256[2] memory prices = ctrl.user_prices(user);\n      (uint256 collRatio, bool isInSoftLiquidation) = getCollateralRatio(user, market);\n\n      return UserData({\n        loanExists: ctrl.loan_exists(user),\n        collateralPrice: amm.price_oracle(),\n        marketCollateralAmount: amounts[0],\n        debtTokenCollateralAmount: amounts[1],\n        debtAmount: amounts[2],\n        N: amounts[3],\n        priceLow: prices[1],\n        priceHigh: prices[0],\n        liquidationDiscount: ctrl.liquidation_discount(),\n        health: ctrl.health(user, true),\n        bandRange: amm.read_user_tick_numbers(user),\n        usersBands: amm.get_xy(user),\n        collRatio: collRatio,\n        isInSoftLiquidation: isInSoftLiquidation,\n        debtTokenSuppliedShares: debtTokenSuppliedShares,\n        debtTokenSuppliedAssets: debtTokenSuppliedAssets\n      });\n  }\n\n  function globalData(address market) external view returns (GlobalData memory) {\n      ILlamaLendController ctrl = ILlamaLendController(market);\n      IAGG agg = IAGG(ctrl.monetary_policy());\n      ILLAMMA amm = ILLAMMA(ctrl.amm());\n      address collTokenAddr = ctrl.collateral_token();\n      address debtTokenAddr = ctrl.borrowed_token();\n\n      return GlobalData({\n        collateralToken: collTokenAddr,\n        debtToken: debtTokenAddr,\n        decimals: IERC20(collTokenAddr).decimals(),\n        activeBand: amm.active_band(),\n        A: amm.A(),\n        totalDebt: ctrl.total_debt(),\n        ammPrice: ctrl.amm_price(),\n        basePrice: amm.get_base_price(),\n        oraclePrice: amm.price_oracle(),\n        minted: ctrl.minted(),\n        redeemed: ctrl.redeemed(),\n        monetaryPolicyRate: agg.rate(market),\n        ammRate: amm.rate(),\n        minBand: amm.min_band(),\n        maxBand: amm.max_band(),\n        lendApr: ILlamaLendVault(ctrl.factory()).lend_apr(),\n        borrowApr:  ILlamaLendVault(ctrl.factory()).borrow_apr(),\n        debtTokenTotalSupply: IERC4626(ctrl.factory()).totalAssets(),\n        debtTokenLeftToBorrow: IERC20(debtTokenAddr).balanceOf(market),\n        loanDiscount: ctrl.loan_discount()\n    });\n  }\n\n  function getBandData(address market, int256 n) external view returns (Band memory) {\n      ILlamaLendController ctrl = ILlamaLendController(market);\n      ILLAMMA lama = ILLAMMA(ctrl.amm());\n\n      return Band(n, lama.p_oracle_down(n), lama.p_oracle_up(n), lama.bands_y(n), lama.bands_x(n));\n  }\n  \n  function getBandsData(address market, int256 from, int256 to) public view returns (Band[] memory) {\n      ILlamaLendController ctrl = ILlamaLendController(market);\n      ILLAMMA lama = ILLAMMA(ctrl.amm());\n      Band[] memory bands = new Band[](uint256(to-from+1));\n      for (int256 i = from; i <= to; i++) {\n          bands[uint256(i-from)] = Band(i, lama.p_oracle_down(i), lama.p_oracle_up(i), lama.bands_y(i), lama.bands_x(i));\n      }\n\n      return bands;\n  }\n\n  function createLoanData(address market, uint256 collateral, uint256 debt, uint256 N) external view returns (CreateLoanData memory) {\n    ILlamaLendController ctrl = ILlamaLendController(market);\n\n    uint256 collForHealthCalc = collateral;\n\n    int health = healthCalculator(market, address(0x00), int256(collForHealthCalc), int256(debt), true, N);\n\n    int256 n1 = ctrl.calculate_debt_n1(collateral, debt, N);\n    int256 n2 = n1 + int256(N) - 1;\n\n    Band[] memory bands = getBandsData(market, n1, n2);\n\n    return CreateLoanData({\n      health: health,\n      minColl: ctrl.min_collateral(debt, N),\n      maxBorrow: ctrl.max_borrowable(collateral, N),\n      bands: bands\n    });\n  }\n\n  function maxBorrow(address market, uint256 collateral, uint256 N) external view returns (uint256) {\n    ILlamaLendController ctrl = ILlamaLendController(market);\n    return ctrl.max_borrowable(collateral, N);\n  }\n\n  function minCollateral(address market, uint256 debt, uint256 N) external view returns (uint256) {\n    ILlamaLendController ctrl = ILlamaLendController(market);\n    return ctrl.min_collateral(debt, N);\n  }\n\n  function getBandsDataForPosition(address market, uint256 collateral, uint256 debt, uint256 N) external view returns (Band[] memory bands) {\n    ILlamaLendController ctrl = ILlamaLendController(market);\n\n    int256 n1 = ctrl.calculate_debt_n1(collateral, debt, N);\n    int256 n2 = n1 + int256(N) - 1;\n\n    bands = getBandsData(market, n1, n2);\n  }\n\n  function healthCalculator(address market, address user, int256 collChange, int256 debtChange, bool isFull, uint256 numBands) public view returns (int256 health) {\n    ILlamaLendController ctrl = ILlamaLendController(market);\n\n    health =  ctrl.health_calculator(user, collChange, debtChange, isFull, numBands);\n  }\n}\n", "ABI": "[{\"inputs\":[],\"name\":\"InvalidLlamaLendController\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"createLoanData\",\"outputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"health\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"minColl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrow\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"id\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LlamaLendView.Band[]\",\"name\":\"bands\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LlamaLendView.CreateLoanData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"n\",\"type\":\"int256\"}],\"name\":\"getBandData\",\"outputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"id\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LlamaLendView.Band\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"from\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"to\",\"type\":\"int256\"}],\"name\":\"getBandsData\",\"outputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"id\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LlamaLendView.Band[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"getBandsDataForPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"id\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LlamaLendView.Band[]\",\"name\":\"bands\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controllerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCollAmountsFromAMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debtAssetCollAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAssetCollAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controllerAddr\",\"type\":\"address\"}],\"name\":\"getCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isInSoftLiquidation\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"globalData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"activeBand\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ammPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monetaryPolicyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ammRate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minBand\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"maxBand\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"borrowApr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lendApr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenLeftToBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanDiscount\",\"type\":\"uint256\"}],\"internalType\":\"struct LlamaLendView.GlobalData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"collChange\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"debtChange\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"isFull\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"numBands\",\"type\":\"uint256\"}],\"name\":\"healthCalculator\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"health\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controllerAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_controllerId\",\"type\":\"uint256\"}],\"name\":\"isControllerValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"maxBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"minCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"loanExists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketCollateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenCollateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceLow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceHigh\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationDiscount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"health\",\"type\":\"int256\"},{\"internalType\":\"int256[2]\",\"name\":\"bandRange\",\"type\":\"int256[2]\"},{\"internalType\":\"uint256[][2]\",\"name\":\"usersBands\",\"type\":\"uint256[][2]\"},{\"internalType\":\"uint256\",\"name\":\"collRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isInSoftLiquidation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenSuppliedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenSuppliedAssets\",\"type\":\"uint256\"}],\"internalType\":\"struct LlamaLendView.UserData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controllerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userMaxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LlamaLendView", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}