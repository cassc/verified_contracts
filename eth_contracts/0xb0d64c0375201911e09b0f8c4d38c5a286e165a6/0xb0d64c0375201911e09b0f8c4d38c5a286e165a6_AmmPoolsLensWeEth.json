{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Interface of the AmmPoolsLensWstEth contract.\ninterface IAmmPoolsLensWeEth {\n    /// @notice Retrieves the exchange rate between weEth and ipUsdm using the AmmLibEth library.\n    /// @return The exchange rate calculated based on the balance of weEth in the AMM Treasury and the total supply of ipUsdm.\n    /// @dev This function acts as a wrapper around the `getExchangeRate`.\n    function getIpWeEthExchangeRate() external view returns (uint256);\n}\n\n/// @notice Interface of the AmmTreasury contract.\ninterface IAmmTreasuryBaseV1 {\n    /// @notice Gets router address.\n    function router() external view returns (address);\n\n    /// @notice Retrieves the version number of the contract.\n    /// @return The version number of the contract.\n    /// @dev This function provides a way to access the version information of the contract.\n    /// Currently, the version is set to 1.\n    function getVersion() external pure returns (uint256);\n\n    /// @notice Gets the balance of the liquidity pool.\n    /// @dev Liquidity Pool balance not take into account following balances: collateral, ipor publication fee, treasury\n    function getLiquidityPoolBalance() external view returns (uint256);\n\n    /// @notice Pauses the contract and revokes the approval of stEth tokens for the router.\n    /// @dev This function can only be called by the pause guardian.\n    /// It revokes the approval of stEth tokens for the router and then pauses the contract.\n    /// require Caller must be the pause guardian.\n    function pause() external;\n\n    /// @notice Unpauses the contract and forcefully approves the router to transfer an unlimited amount of stEth tokens.\n    /// @dev This function can only be called by the contract owner.\n    /// It unpauses the contract and then forcefully sets the approval of stEth tokens for the router to the maximum possible value.\n    /// require Caller must be the contract owner.\n    function unpause() external;\n\n    /// @notice Checks if the given account is a pause guardian.\n    /// @param account Address to be checked.\n    /// @return A boolean indicating whether the provided account is a pause guardian.\n    /// @dev This function queries the PauseManager to determine if the provided account is a pause guardian.\n    function isPauseGuardian(address account) external view returns (bool);\n\n    /// @notice Adds a new pause guardian to the contract.\n    /// @param guardians List Addresses of the accounts to be added as a pause guardian.\n    /// @dev This function can only be called by the contract owner.\n    /// It delegates the addition of a new pause guardian to the PauseManager.\n    /// require Caller must be the contract owner.\n    function addPauseGuardians(address[] calldata guardians) external;\n\n    /// @notice Removes an existing pause guardian from the contract.\n    /// @param guardians List addresses of the accounts to be removed as a pause guardian.\n    /// @dev This function can only be called by the contract owner.\n    /// It delegates the removal of a pause guardian to the PauseManager.\n    /// require Caller must be the contract owner.\n    function removePauseGuardians(address[] calldata guardians) external;\n}\n\n/// @title Interface for interaction with Asset Management DSR smart contract.\n/// @notice Asset Management is responsible for delegating assets stored in AmmTreasury to Asset Management and forward to money market where they can earn interest.\ninterface IAssetManagement {\n    /// @notice Gets total balance of AmmTreasury, transferred assets to Asset Management.\n    /// @return Total balance for specific account given as a parameter, represented in 18 decimals.\n    function totalBalance() external view returns (uint256);\n\n    /// @notice Deposits ERC20 underlying assets to AssetManagement. Function available only for AmmTreasury.\n    /// @dev Emits {Deposit} event from AssetManagement, emits {Transfer} event from ERC20 asset.\n    /// Input and output values are represented in 18 decimals.\n    /// @param amount amount deposited by AmmTreasury to AssetManagement.\n    /// @return vaultBalance current balance including amount deposited on AssteManagement.\n    /// @return depositedAmount final deposited amount.\n    function deposit(uint256 amount) external returns (uint256 vaultBalance, uint256 depositedAmount);\n\n    /// @notice Withdraws declared amount of asset from AssetManagement to AmmTreasury. Function available only for AmmTreasury.\n    /// @dev Emits {Withdraw} event from AssetManagement, emits {Transfer} event from ERC20 asset.\n    /// All input and output values are represented in 18 decimals.\n    /// @param amount deposited amount of underlying asset represented in 18 decimals.\n    /// @return withdrawnAmount final withdrawn amount of asset from AssetManagement, can be different than input amount due to passing time.\n    /// @return vaultBalance current asset balance on AssetManagement\n    function withdraw(uint256 amount) external returns (uint256 withdrawnAmount, uint256 vaultBalance);\n\n    /// @notice Withdraws all of the asset from AssetManagement to AmmTreasury. Function available only for AmmTreasury.\n    /// @dev Emits {Withdraw} event from AssetManagement, emits {Transfer} event from ERC20 asset.\n    /// Output values are represented in 18 decimals.\n    /// @return withdrawnAmount final withdrawn amount of the asset.\n    /// @return vaultBalance current asset's balance on AssetManagement\n    function withdrawAll() external returns (uint256 withdrawnAmount, uint256 vaultBalance);\n\n    /// @notice Emitted after AmmTreasury has executed deposit function.\n    /// @param from account address from which assets are transferred\n    /// @param to account address where assets are transferred to\n    /// @param amount of asset transferred from AmmTreasury to AssetManagement, represented in 18 decimals\n    event Deposit(address from, address to, uint256 amount);\n\n    /// @notice Emitted when AmmTreasury executes withdraw function.\n    /// @param to account address where assets are transferred to\n    /// @param amount of asset transferred from AmmTreasury to AssetManagement, represented in 18 decimals\n    event Withdraw(address to, uint256 amount);\n}\n\n/// @title Types used in AmmStorage smart contract\nlibrary AmmStorageTypes {\n    /// @notice struct representing swap's ID and direction\n    /// @dev direction = 0 - Pay Fixed - Receive Floating, direction = 1 - Receive Fixed - Pay Floating\n    struct IporSwapId {\n        /// @notice Swap's ID\n        uint256 id;\n        /// @notice Swap's direction, 0 - Pay Fixed Receive Floating, 1 - Receive Fixed Pay Floating\n        uint8 direction;\n    }\n\n    /// @notice Struct containing extended balance information.\n    /// @dev extended information includes: opening fee balance, liquidation deposit balance,\n    /// IPOR publication fee balance, treasury balance, all values are with 18 decimals\n    struct ExtendedBalancesMemory {\n        /// @notice Swap's balance for Pay Fixed leg\n        uint256 totalCollateralPayFixed;\n        /// @notice Swap's balance for Receive Fixed leg\n        uint256 totalCollateralReceiveFixed;\n        /// @notice Liquidity Pool's Balance\n        uint256 liquidityPool;\n        /// @notice AssetManagement's (Asset Management) balance\n        uint256 vault;\n        /// @notice IPOR publication fee balance. This balance is used to subsidise the oracle operations\n        uint256 iporPublicationFee;\n        /// @notice Balance of the DAO's treasury. Fed by portion of the opening fee set by the DAO\n        uint256 treasury;\n    }\n\n    /// @notice A struct with parameters required to calculate SOAP for pay fixed and receive fixed legs.\n    /// @dev Committed to the memory.\n    struct SoapIndicators {\n        /// @notice Value of interest accrued on a fixed leg of all derivatives for this particular type of swap.\n        /// @dev Represented in 18 decimals.\n        uint256 hypotheticalInterestCumulative;\n        /// @notice Sum of all swaps' notional amounts for a given leg.\n        /// @dev Represented in 18 decimals.\n        uint256 totalNotional;\n        /// @notice Sum of all IBTs on a given leg.\n        /// @dev Represented in 18 decimals.\n        uint256 totalIbtQuantity;\n        /// @notice The notional-weighted average interest rate of all swaps on a given leg combined.\n        /// @dev Represented in 18 decimals.\n        uint256 averageInterestRate;\n        /// @notice EPOCH timestamp of when the most recent rebalancing took place\n        uint256 rebalanceTimestamp;\n    }\n}\n\n/// @title Struct used across various interfaces in IPOR Protocol.\nlibrary IporTypes {\n    /// @notice enum describing Swap's state, ACTIVE - when the swap is opened, INACTIVE when it's closed\n    enum SwapState {\n        INACTIVE,\n        ACTIVE\n    }\n\n    /// @notice enum describing Swap's duration, 28 days, 60 days or 90 days\n    enum SwapTenor {\n        DAYS_28,\n        DAYS_60,\n        DAYS_90\n    }\n\n    /// @notice The struct describing the IPOR and its params calculated for the time when it was most recently updated and the change that took place since the update.\n    /// Namely, the interest that would be computed into IBT should the rebalance occur.\n    struct  AccruedIpor {\n        /// @notice IPOR Index Value\n        /// @dev value represented in 18 decimals\n        uint256 indexValue;\n        /// @notice IBT Price (IBT - Interest Bearing Token). For more information refer to the documentation:\n        /// https://ipor-labs.gitbook.io/ipor-labs/interest-rate-derivatives/ibt\n        /// @dev value represented in 18 decimals\n        uint256 ibtPrice;\n    }\n\n    /// @notice Struct representing balances used internally for asset calculations\n    /// @dev all balances in 18 decimals\n    struct AmmBalancesMemory {\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Fixed & Receive Floating leg.\n        uint256 totalCollateralPayFixed;\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Floating & Receive Fixed leg.\n        uint256 totalCollateralReceiveFixed;\n        /// @notice Liquidity Pool Balance. This balance is where the liquidity from liquidity providers and the opening fee are accounted for,\n        /// @dev Amount of opening fee accounted in this balance is defined by _OPENING_FEE_FOR_TREASURY_PORTION_RATE param.\n        uint256 liquidityPool;\n        /// @notice Vault's balance, describes how much asset has been transferred to Asset Management Vault (AssetManagement)\n        uint256 vault;\n    }\n\n    struct AmmBalancesForOpenSwapMemory {\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Fixed & Receive Floating leg.\n        uint256 totalCollateralPayFixed;\n        /// @notice Total notional amount of all swaps on  Pay Fixed leg (denominated in 18 decimals).\n        uint256 totalNotionalPayFixed;\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Floating & Receive Fixed leg.\n        uint256 totalCollateralReceiveFixed;\n        /// @notice Total notional amount of all swaps on  Receive Fixed leg (denominated in 18 decimals).\n        uint256 totalNotionalReceiveFixed;\n        /// @notice Liquidity Pool Balance.\n        uint256 liquidityPool;\n    }\n\n    struct SpreadInputs {\n        //// @notice Swap's assets DAI/USDC/USDT\n        address asset;\n        /// @notice Swap's notional value\n        uint256 swapNotional;\n        /// @notice demand spread factor used in demand spread calculation\n        uint256 demandSpreadFactor;\n        /// @notice Base spread\n        int256 baseSpreadPerLeg;\n        /// @notice Swap's balance for Pay Fixed leg\n        uint256 totalCollateralPayFixed;\n        /// @notice Swap's balance for Receive Fixed leg\n        uint256 totalCollateralReceiveFixed;\n        /// @notice Liquidity Pool's Balance\n        uint256 liquidityPoolBalance;\n        /// @notice Ipor index value at the time of swap creation\n        uint256 iporIndexValue;\n        // @notice fixed rate cap for given leg for offered rate without demandSpread in 18 decimals\n        uint256 fixedRateCapPerLeg;\n    }\n}\n\nlibrary Constants {\n    uint256 public constant MAX_VALUE = type(uint256).max;\n    uint256 public constant WAD_LEVERAGE_1000 = 1_000e18;\n    uint256 public constant YEAR_IN_SECONDS = 365 days;\n    uint256 public constant MAX_CHUNK_SIZE = 50;\n}\n\n/// @title Errors which occur inside AmmTreasury's method execution.\nlibrary AmmErrors {\n    // 300-399-AMM\n    /// @notice Liquidity Pool balance is equal 0.\n    string public constant LIQUIDITY_POOL_IS_EMPTY = \"IPOR_300\";\n\n    /// @notice Liquidity Pool balance is too low, should be equal or higher than 0.\n    string public constant LIQUIDITY_POOL_AMOUNT_TOO_LOW = \"IPOR_301\";\n\n    /// @notice Liquidity Pool Collateral Ratio exceeded. Liquidity Pool Collateral Ratio is higher than configured in AmmTreasury maximum liquidity pool collateral ratio.\n    string public constant LP_COLLATERAL_RATIO_EXCEEDED = \"IPOR_302\";\n\n    /// @notice Liquidity Pool Collateral Ratio Per Leg exceeded. Liquidity Pool Collateral Ratio per leg is higher than configured in AmmTreasury maximum liquidity pool collateral ratio per leg.\n    string public constant LP_COLLATERAL_RATIO_PER_LEG_EXCEEDED = \"IPOR_303\";\n\n    /// @notice Liquidity Pool Balance is too high\n    string public constant LIQUIDITY_POOL_BALANCE_IS_TOO_HIGH = \"IPOR_304\";\n\n    /// @notice Swap cannot be closed because liquidity pool is too low for payid out cash. Situation should never happen where Liquidity Pool is insolvent.\n    string public constant CANNOT_CLOSE_SWAP_LP_IS_TOO_LOW = \"IPOR_305\";\n\n    /// @notice Swap id used in input has incorrect value (like 0) or not exists.\n    string public constant INCORRECT_SWAP_ID = \"IPOR_306\";\n\n    /// @notice Swap has incorrect status.\n    string public constant INCORRECT_SWAP_STATUS = \"IPOR_307\";\n\n    /// @notice Leverage given as a parameter when opening swap is lower than configured in AmmTreasury minimum leverage.\n    string public constant LEVERAGE_TOO_LOW = \"IPOR_308\";\n\n    /// @notice Leverage given as a parameter when opening swap is higher than configured in AmmTreasury maxumum leverage.\n    string public constant LEVERAGE_TOO_HIGH = \"IPOR_309\";\n\n    /// @notice Total amount given as a parameter when opening swap is too low. Cannot be equal zero.\n    string public constant TOTAL_AMOUNT_TOO_LOW = \"IPOR_310\";\n\n    /// @notice Total amount given as a parameter when opening swap is lower than sum of liquidation deposit amount and ipor publication fee.\n    string public constant TOTAL_AMOUNT_LOWER_THAN_FEE = \"IPOR_311\";\n\n    /// @notice Amount of collateral used to open swap is higher than configured in AmmTreasury max swap collateral amount\n    string public constant COLLATERAL_AMOUNT_TOO_HIGH = \"IPOR_312\";\n\n    /// @notice Acceptable fixed interest rate defined by traded exceeded.\n    string public constant ACCEPTABLE_FIXED_INTEREST_RATE_EXCEEDED = \"IPOR_313\";\n\n    /// @notice Swap Notional Amount is higher than Total Notional for specific leg.\n    string public constant SWAP_NOTIONAL_HIGHER_THAN_TOTAL_NOTIONAL = \"IPOR_314\";\n\n    /// @notice Number of swaps per leg which are going to be liquidated is too high, is higher than configured in AmmTreasury liquidation leg limit.\n    string public constant MAX_LENGTH_LIQUIDATED_SWAPS_PER_LEG_EXCEEDED = \"IPOR_315\";\n\n    /// @notice Sum of SOAP and Liquidity Pool Balance is lower than zero.\n    /// @dev SOAP can be negative, Sum of SOAP and Liquidity Pool Balance can be negative, but this is undesirable.\n    string public constant SOAP_AND_LP_BALANCE_SUM_IS_TOO_LOW = \"IPOR_316\";\n\n    /// @notice Calculation timestamp is earlier than last SOAP rebalance timestamp.\n    string public constant CALC_TIMESTAMP_LOWER_THAN_SOAP_REBALANCE_TIMESTAMP = \"IPOR_317\";\n\n    /// @notice Calculation timestamp is lower than  Swap's open timestamp.\n    string public constant CALC_TIMESTAMP_LOWER_THAN_SWAP_OPEN_TIMESTAMP = \"IPOR_318\";\n\n    /// @notice Closing timestamp is lower than Swap's open timestamp.\n    string public constant CLOSING_TIMESTAMP_LOWER_THAN_SWAP_OPEN_TIMESTAMP = \"IPOR_319\";\n\n    /// @notice Swap cannot be closed because sender is not a buyer nor liquidator.\n    string public constant CANNOT_CLOSE_SWAP_SENDER_IS_NOT_BUYER_NOR_LIQUIDATOR = \"IPOR_320\";\n\n    /// @notice Interest from Strategy is below zero.\n    string public constant INTEREST_FROM_STRATEGY_EXCEEDED_THRESHOLD = \"IPOR_321\";\n\n    /// @notice IPOR publication fee balance is too low.\n    string public constant PUBLICATION_FEE_BALANCE_IS_TOO_LOW = \"IPOR_322\";\n\n    /// @notice The caller must be the Token Manager (Smart Contract responsible for managing token total supply).\n    string public constant CALLER_NOT_TOKEN_MANAGER = \"IPOR_323\";\n\n    /// @notice Deposit amount is too low.\n    string public constant DEPOSIT_AMOUNT_IS_TOO_LOW = \"IPOR_324\";\n\n    /// @notice Vault balance is lower than deposit value.\n    string public constant VAULT_BALANCE_LOWER_THAN_DEPOSIT_VALUE = \"IPOR_325\";\n\n    /// @notice Treasury balance is too low.\n    string public constant TREASURY_BALANCE_IS_TOO_LOW = \"IPOR_326\";\n\n    /// @notice Swap cannot be closed because closing timestamp is lower than swap's open timestamp in general.\n    string public constant CANNOT_CLOSE_SWAP_CLOSING_IS_TOO_EARLY = \"IPOR_327\";\n\n    /// @notice Swap cannot be closed because closing timestamp is lower than swap's open timestamp for buyer.\n    string public constant CANNOT_CLOSE_SWAP_CLOSING_IS_TOO_EARLY_FOR_BUYER = \"IPOR_328\";\n\n    /// @notice Swap cannot be closed and unwind because is too late\n    string public constant CANNOT_UNWIND_CLOSING_TOO_LATE = \"IPOR_329\";\n\n    /// @notice Unsupported swap tenor\n    string public constant UNSUPPORTED_SWAP_TENOR = \"IPOR_330\";\n\n    /// @notice Sender is not AMM (is not a IporProtocolRouter contract)\n    string public constant SENDER_NOT_AMM = \"IPOR_331\";\n\n    /// @notice Storage id is not time weighted notional group\n    string public constant STORAGE_ID_IS_NOT_TIME_WEIGHTED_NOTIONAL = \"IPOR_332\";\n\n    /// @notice Spread function is not supported\n    string public constant FUNCTION_NOT_SUPPORTED = \"IPOR_333\";\n\n    /// @notice Unsupported direction\n    string public constant UNSUPPORTED_DIRECTION = \"IPOR_334\";\n\n    /// @notice Invalid notional\n    string public constant INVALID_NOTIONAL = \"IPOR_335\";\n\n    /// @notice Average interest rate cannot be zero when open swap\n    string public constant AVERAGE_INTEREST_RATE_WHEN_OPEN_SWAP_CANNOT_BE_ZERO = \"IPOR_336\";\n\n    /// @notice Average interest rate cannot be zero when close swap\n    string public constant AVERAGE_INTEREST_RATE_WHEN_CLOSE_SWAP_CANNOT_BE_ZERO = \"IPOR_337\";\n\n    /// @notice Submit ETH to stETH contract failed.\n    string public constant STETH_SUBMIT_FAILED = \"IPOR_338\";\n\n    /// @notice Collateral is not sufficient to cover unwind swap\n    string public constant COLLATERAL_IS_NOT_SUFFICIENT_TO_COVER_UNWIND_SWAP = \"IPOR_339\";\n\n    /// @notice Error when withdraw from asset management is not enough to cover transfer amount to buyer and/or beneficiary\n    string public constant ASSET_MANAGEMENT_WITHDRAW_NOT_ENOUGH = \"IPOR_340\";\n\n    /// @notice Swap cannot be closed with unwind because action is too early, depends on value of configuration parameter `timeAfterOpenAllowedToCloseSwapWithUnwinding`\n    string public constant CANNOT_CLOSE_SWAP_WITH_UNWIND_ACTION_IS_TOO_EARLY = \"IPOR_341\";\n}\n\nlibrary IporErrors {\n    /// @notice Error when address is wrong\n    error WrongAddress(string errorCode, address wrongAddress, string message);\n\n    /// @notice Error when amount is wrong\n    error WrongAmount(string errorCode, uint256 value);\n\n    /// @notice Error when caller is not an ipor protocol router\n    error CallerNotIporProtocolRouter(string errorCode, address caller);\n\n    /// @notice Error when caller is not a pause guardian\n    error CallerNotPauseGuardian(string errorCode, address caller);\n\n    /// @notice Error when caller is not a AmmTreasury contract\n    error CallerNotAmmTreasury(string errorCode, address caller);\n\n    /// @notice Error when given direction is not supported\n    error UnsupportedDirection(string errorCode, uint256 direction);\n\n    /// @notice Error when given asset is not supported\n    error UnsupportedAsset(string errorCode, address asset);\n\n    /// @notice Error when given asset is not supported\n    error UnsupportedAssetPair(string errorCode, address poolAsset, address inputAsset);\n\n    /// @notice Error when given module is not supported\n    error UnsupportedModule(string errorCode, address asset);\n\n    /// @notice Error when given tenor is not supported\n    error UnsupportedTenor(string errorCode, uint256 tenor);\n\n    /// @notice Error when Input Asset total amount is too low\n    error InputAssetTotalAmountTooLow(string errorCode, uint256 value);\n\n    /// @dev Error appears if user/account doesn't have enough balance to open a swap with a specific totalAmount\n    error InputAssetBalanceTooLow(string errorCode, address inputAsset, uint256 inputAssetBalance, uint256 totalAmount);\n\n    // 000-199 - general codes\n\n    /// @notice General problem, address is wrong\n    string public constant WRONG_ADDRESS = \"IPOR_000\";\n\n    /// @notice General problem. Wrong decimals\n    string public constant WRONG_DECIMALS = \"IPOR_001\";\n\n    /// @notice General problem, addresses mismatch\n    string public constant ADDRESSES_MISMATCH = \"IPOR_002\";\n\n    /// @notice Sender's asset balance is too low to transfer and to open a swap\n    string public constant SENDER_ASSET_BALANCE_TOO_LOW = \"IPOR_003\";\n\n    /// @notice Value is not greater than zero\n    string public constant VALUE_NOT_GREATER_THAN_ZERO = \"IPOR_004\";\n\n    /// @notice Input arrays length mismatch\n    string public constant INPUT_ARRAYS_LENGTH_MISMATCH = \"IPOR_005\";\n\n    /// @notice Amount is too low to transfer\n    string public constant NOT_ENOUGH_AMOUNT_TO_TRANSFER = \"IPOR_006\";\n\n    /// @notice msg.sender is not an appointed owner, so cannot confirm his appointment to be an owner of a specific smart contract\n    string public constant SENDER_NOT_APPOINTED_OWNER = \"IPOR_007\";\n\n    /// @notice only Router can have access to function\n    string public constant CALLER_NOT_IPOR_PROTOCOL_ROUTER = \"IPOR_008\";\n\n    /// @notice Chunk size is equal to zero\n    string public constant CHUNK_SIZE_EQUAL_ZERO = \"IPOR_009\";\n\n    /// @notice Chunk size is too big\n    string public constant CHUNK_SIZE_TOO_BIG = \"IPOR_010\";\n\n    /// @notice Caller is not a pause guardian\n    string public constant CALLER_NOT_PAUSE_GUARDIAN = \"IPOR_011\";\n\n    /// @notice Request contains invalid method signature, which is not supported by the Ipor Protocol Router\n    string public constant ROUTER_INVALID_SIGNATURE = \"IPOR_012\";\n\n    /// @notice Only AMM Treasury can have access to function\n    string public constant CALLER_NOT_AMM_TREASURY = \"IPOR_013\";\n\n    /// @notice Caller is not an owner\n    string public constant CALLER_NOT_OWNER = \"IPOR_014\";\n\n    /// @notice Method is paused\n    string public constant METHOD_PAUSED = \"IPOR_015\";\n\n    /// @notice Reentrancy appears\n    string public constant REENTRANCY = \"IPOR_016\";\n\n    /// @notice Asset is not supported\n    string public constant ASSET_NOT_SUPPORTED = \"IPOR_017\";\n\n    /// @notice Return back ETH failed in Ipor Protocol Router\n    string public constant ROUTER_RETURN_BACK_ETH_FAILED = \"IPOR_018\";\n\n    /// @notice Risk indicators are expired\n    string public constant RISK_INDICATORS_EXPIRED = \"IPOR_019\";\n\n    /// @notice Signature is invalid for risk indicators\n    string public constant RISK_INDICATORS_SIGNATURE_INVALID = \"IPOR_020\";\n\n    /// @notice Input Asset used by user is not supported\n    string public constant INPUT_ASSET_NOT_SUPPORTED = \"IPOR_021\";\n\n    /// @notice Module Asset Management is not supported\n    string public constant UNSUPPORTED_MODULE_ASSET_MANAGEMENT = \"IPOR_022\";\n}\n\nlibrary IporMath {\n    uint256 private constant RAY = 1e27;\n\n    //@notice Division with rounding up on last position, x, and y is with MD\n    function division(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x + (y / 2)) / y;\n    }\n\n    function divisionInt(int256 x, int256 y) internal pure returns (int256 z) {\n        uint256 absX = uint256(x < 0 ? -x : x);\n        uint256 absY = uint256(y < 0 ? -y : y);\n\n        // Use bitwise XOR to get the sign on MBS bit then shift to LSB\n        // sign == 0x0000...0000 ==  0 if the number is non-negative\n        // sign == 0xFFFF...FFFF == -1 if the number is negative\n        int256 sign = (x ^ y) >> 255;\n\n        uint256 divAbs;\n        uint256 remainder;\n\n        unchecked {\n            divAbs = absX / absY;\n            remainder = absX % absY;\n        }\n        // Check if we need to round\n        if (sign < 0) {\n            // remainder << 1 left shift is equivalent to multiplying by 2\n            if (remainder << 1 > absY) {\n                ++divAbs;\n            }\n        } else {\n            if (remainder << 1 >= absY) {\n                ++divAbs;\n            }\n        }\n\n        // (sign | 1) is cheaper than (sign < 0) ? -1 : 1;\n        unchecked {\n            z = int256(divAbs) * (sign | 1);\n        }\n    }\n\n    function divisionWithoutRound(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x / y;\n    }\n\n    function convertWadToAssetDecimals(uint256 value, uint256 assetDecimals) internal pure returns (uint256) {\n        if (assetDecimals == 18) {\n            return value;\n        } else if (assetDecimals > 18) {\n            return value * 10 ** (assetDecimals - 18);\n        } else {\n            return division(value, 10 ** (18 - assetDecimals));\n        }\n    }\n\n    function convertWadToAssetDecimalsWithoutRound(\n        uint256 value,\n        uint256 assetDecimals\n    ) internal pure returns (uint256) {\n        if (assetDecimals == 18) {\n            return value;\n        } else if (assetDecimals > 18) {\n            return value * 10 ** (assetDecimals - 18);\n        } else {\n            return divisionWithoutRound(value, 10 ** (18 - assetDecimals));\n        }\n    }\n\n    function convertToWad(uint256 value, uint256 assetDecimals) internal pure returns (uint256) {\n        if (value > 0) {\n            if (assetDecimals == 18) {\n                return value;\n            } else if (assetDecimals > 18) {\n                return division(value, 10 ** (assetDecimals - 18));\n            } else {\n                return value * 10 ** (18 - assetDecimals);\n            }\n        } else {\n            return value;\n        }\n    }\n\n    function absoluteValue(int256 value) internal pure returns (uint256) {\n        return (uint256)(value < 0 ? -value : value);\n    }\n\n    function percentOf(uint256 value, uint256 rate) internal pure returns (uint256) {\n        return division(value * rate, 1e18);\n    }\n\n    /// @notice Calculates x^n where x and y are represented in RAY (27 decimals)\n    /// @param x base, represented in 27 decimals\n    /// @param n exponent, represented in 27 decimals\n    /// @return z x^n represented in 27 decimals\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := RAY\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := RAY\n                }\n                default {\n                    z := x\n                }\n                let half := div(RAY, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, RAY)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, RAY)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n/*\n * ABDK Math Quad Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\n\n/**\n * Smart contract library of mathematical functions operating with IEEE 754\n * quadruple-precision binary floating-point numbers (quadruple precision\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n * represented by bytes16 type.\n */\nlibrary ABDKMathQuad {\n  /*\n   * 0.\n   */\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n\n  /*\n   * -0.\n   */\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n\n  /*\n   * +Infinity.\n   */\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\n\n  /*\n   * -Infinity.\n   */\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\n\n  /*\n   * Canonical NaN value.\n   */\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n\n  /**\n   * Convert signed 256-bit integer number into quadruple precision number.\n   *\n   * @param x signed 256-bit integer number\n   * @return quadruple precision number\n   */\n  function fromInt (int256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint256 (x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 256-bit integer number\n   * rounding towards zero.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 256-bit integer number\n   */\n  function toInt (bytes16 x) internal pure returns (int256) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      require (exponent <= 16638); // Overflow\n      if (exponent < 16383) return 0; // Underflow\n\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16495) result >>= 16495 - exponent;\n      else if (exponent > 16495) result <<= exponent - 16495;\n\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (result); // We rely on overflow behavior here\n      } else {\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (result);\n      }\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into quadruple precision number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return quadruple precision number\n   */\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        uint256 result = x;\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into unsigned 256-bit integer number\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n   * without error, because they are rounded to zero.\n   *\n   * @param x quadruple precision number\n   * @return unsigned 256-bit integer number\n   */\n  function toUInt (bytes16 x) internal pure returns (uint256) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      if (exponent < 16383) return 0; // Underflow\n\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\n\n      require (exponent <= 16638); // Overflow\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16495) result >>= 16495 - exponent;\n      else if (exponent > 16495) result <<= exponent - 16495;\n\n      return result;\n    }\n  }\n\n  /**\n   * Convert signed 128.128 bit fixed point number into quadruple precision\n   * number.\n   *\n   * @param x signed 128.128 bit fixed point number\n   * @return quadruple precision number\n   */\n  function from128x128 (int256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint256 (x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 128.128 bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 128.128 bit fixed point number\n   */\n  function to128x128 (bytes16 x) internal pure returns (int256) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      require (exponent <= 16510); // Overflow\n      if (exponent < 16255) return 0; // Underflow\n\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16367) result >>= 16367 - exponent;\n      else if (exponent > 16367) result <<= exponent - 16367;\n\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (result); // We rely on overflow behavior here\n      } else {\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (result);\n      }\n    }\n  }\n\n  /**\n   * Convert signed 64.64 bit fixed point number into quadruple precision\n   * number.\n   *\n   * @param x signed 64.64 bit fixed point number\n   * @return quadruple precision number\n   */\n  function from64x64 (int128 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint128 (x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 64.64 bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 64.64 bit fixed point number\n   */\n  function to64x64 (bytes16 x) internal pure returns (int128) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      require (exponent <= 16446); // Overflow\n      if (exponent < 16319) return 0; // Underflow\n\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16431) result >>= 16431 - exponent;\n      else if (exponent > 16431) result <<= exponent - 16431;\n\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n        require (result <= 0x80000000000000000000000000000000);\n        return -int128 (int256 (result)); // We rely on overflow behavior here\n      } else {\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (int256 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert octuple precision number into quadruple precision number.\n   *\n   * @param x octuple precision number\n   * @return quadruple precision number\n   */\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\n    unchecked {\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\n\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFFF) {\n        if (significand > 0) return NaN;\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n      }\n\n      if (exponent > 278526)\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n      else if (exponent < 245649)\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\n      else if (exponent < 245761) {\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\n        exponent = 0;\n      } else {\n        significand >>= 124;\n        exponent -= 245760;\n      }\n\n      uint128 result = uint128 (significand | exponent << 112);\n      if (negative) result |= 0x80000000000000000000000000000000;\n\n      return bytes16 (result);\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into octuple precision number.\n   *\n   * @param x quadruple precision number\n   * @return octuple precision number\n   */\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\n      else if (exponent == 0) {\n        if (result > 0) {\n          uint256 msb = mostSignificantBit (result);\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          exponent = 245649 + msb;\n        }\n      } else {\n        result <<= 124;\n        exponent += 245760;\n      }\n\n      result |= exponent << 236;\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n      return bytes32 (result);\n    }\n  }\n\n  /**\n   * Convert double precision number into quadruple precision number.\n   *\n   * @param x double precision number\n   * @return quadruple precision number\n   */\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\n    unchecked {\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\n\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\n      else if (exponent == 0) {\n        if (result > 0) {\n          uint256 msb = mostSignificantBit (result);\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          exponent = 15309 + msb;\n        }\n      } else {\n        result <<= 60;\n        exponent += 15360;\n      }\n\n      result |= exponent << 112;\n      if (x & 0x8000000000000000 > 0)\n        result |= 0x80000000000000000000000000000000;\n\n      return bytes16 (uint128 (result));\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into double precision number.\n   *\n   * @param x quadruple precision number\n   * @return double precision number\n   */\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\n    unchecked {\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\n\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFF) {\n        if (significand > 0) return 0x7FF8000000000000; // NaN\n        else return negative ?\n            bytes8 (0xFFF0000000000000) : // -Infinity\n            bytes8 (0x7FF0000000000000); // Infinity\n      }\n\n      if (exponent > 17406)\n        return negative ?\n            bytes8 (0xFFF0000000000000) : // -Infinity\n            bytes8 (0x7FF0000000000000); // Infinity\n      else if (exponent < 15309)\n        return negative ?\n            bytes8 (0x8000000000000000) : // -0\n            bytes8 (0x0000000000000000); // 0\n      else if (exponent < 15361) {\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\n        exponent = 0;\n      } else {\n        significand >>= 60;\n        exponent -= 15360;\n      }\n\n      uint64 result = uint64 (significand | exponent << 52);\n      if (negative) result |= 0x8000000000000000;\n\n      return bytes8 (result);\n    }\n  }\n\n  /**\n   * Test whether given quadruple precision number is NaN.\n   *\n   * @param x quadruple precision number\n   * @return true if x is NaN, false otherwise\n   */\n  function isNaN (bytes16 x) internal pure returns (bool) {\n    unchecked {\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\n        0x7FFF0000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Test whether given quadruple precision number is positive or negative\n   * infinity.\n   *\n   * @param x quadruple precision number\n   * @return true if x is positive or negative infinity, false otherwise\n   */\n  function isInfinity (bytes16 x) internal pure returns (bool) {\n    unchecked {\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\n        0x7FFF0000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \n   *\n   * @param x quadruple precision number\n   * @return sign of x\n   */\n  function sign (bytes16 x) internal pure returns (int8) {\n    unchecked {\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      if (absoluteX == 0) return 0;\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\n      else return 1;\n    }\n  }\n\n  /**\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\n   * arguments are infinities of the same sign. \n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return sign (x - y)\n   */\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\n    unchecked {\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      // Not infinities of the same sign\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\n\n      if (x == y) return 0;\n      else {\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\n\n        if (negativeX) {\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\n          else return -1; \n        } else {\n          if (negativeY) return 1;\n          else return absoluteX > absoluteY ? int8 (1) : -1;\n        }\n      }\n    }\n  }\n\n  /**\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\n   * anything. \n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return true if x equals to y, false otherwise\n   */\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\n    unchecked {\n      if (x == y) {\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\n          0x7FFF0000000000000000000000000000;\n      } else return false;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Special values behave in the following way:\n   *\n   * NaN + x = NaN for any x.\n   * Infinity + x = Infinity for any finite x.\n   * -Infinity + x = -Infinity for any finite x.\n   * Infinity + Infinity = Infinity.\n   * -Infinity + -Infinity = -Infinity.\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) { \n          if (x == y) return x;\n          else return NaN;\n        } else return x; \n      } else if (yExponent == 0x7FFF) return y;\n      else {\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n        else {\n          int256 delta = int256 (xExponent) - int256 (yExponent);\n  \n          if (xSign == ySign) {\n            if (delta > 112) return x;\n            else if (delta > 0) ySignifier >>= uint256 (delta);\n            else if (delta < -112) return y;\n            else if (delta < 0) {\n              xSignifier >>= uint256 (-delta);\n              xExponent = yExponent;\n            }\n  \n            xSignifier += ySignifier;\n  \n            if (xSignifier >= 0x20000000000000000000000000000) {\n              xSignifier >>= 1;\n              xExponent += 1;\n            }\n  \n            if (xExponent == 0x7FFF)\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else {\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  \n              return bytes16 (uint128 (\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\n                  (xExponent << 112) |\n                  xSignifier)); \n            }\n          } else {\n            if (delta > 0) {\n              xSignifier <<= 1;\n              xExponent -= 1;\n            } else if (delta < 0) {\n              ySignifier <<= 1;\n              xExponent = yExponent - 1;\n            }\n\n            if (delta > 112) ySignifier = 1;\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\n            else if (delta < -112) xSignifier = 1;\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\n\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\n            else {\n              xSignifier = ySignifier - xSignifier;\n              xSign = ySign;\n            }\n\n            if (xSignifier == 0)\n              return POSITIVE_ZERO;\n\n            uint256 msb = mostSignificantBit (xSignifier);\n\n            if (msb == 113) {\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n              xExponent += 1;\n            } else if (msb < 112) {\n              uint256 shift = 112 - msb;\n              if (xExponent > shift) {\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                xExponent -= shift;\n              } else {\n                xSignifier <<= xExponent - 1;\n                xExponent = 0;\n              }\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (xExponent == 0x7FFF)\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else return bytes16 (uint128 (\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\n                (xExponent << 112) |\n                xSignifier));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x - y.  Special values behave in the following way:\n   *\n   * NaN - x = NaN for any x.\n   * Infinity - x = Infinity for any finite x.\n   * -Infinity - x = -Infinity for any finite x.\n   * Infinity - -Infinity = Infinity.\n   * -Infinity - Infinity = -Infinity.\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      return add (x, y ^ 0x80000000000000000000000000000000);\n    }\n  }\n\n  /**\n   * Calculate x * y.  Special values behave in the following way:\n   *\n   * NaN * x = NaN for any x.\n   * Infinity * x = Infinity for any finite positive x.\n   * Infinity * x = -Infinity for any finite negative x.\n   * -Infinity * x = -Infinity for any finite positive x.\n   * -Infinity * x = Infinity for any finite negative x.\n   * Infinity * 0 = NaN.\n   * -Infinity * 0 = NaN.\n   * Infinity * Infinity = Infinity.\n   * Infinity * -Infinity = -Infinity.\n   * -Infinity * Infinity = -Infinity.\n   * -Infinity * -Infinity = Infinity.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) {\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n          else return NaN;\n        } else {\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n          else return x ^ y & 0x80000000000000000000000000000000;\n        }\n      } else if (yExponent == 0x7FFF) {\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n          else return y ^ x & 0x80000000000000000000000000000000;\n      } else {\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        xSignifier *= ySignifier;\n        if (xSignifier == 0)\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n              NEGATIVE_ZERO : POSITIVE_ZERO;\n\n        xExponent += yExponent;\n\n        uint256 msb =\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\n          mostSignificantBit (xSignifier);\n\n        if (xExponent + msb < 16496) { // Underflow\n          xExponent = 0;\n          xSignifier = 0;\n        } else if (xExponent + msb < 16608) { // Subnormal\n          if (xExponent < 16496)\n            xSignifier >>= 16496 - xExponent;\n          else if (xExponent > 16496)\n            xSignifier <<= xExponent - 16496;\n          xExponent = 0;\n        } else if (xExponent + msb > 49373) {\n          xExponent = 0x7FFF;\n          xSignifier = 0;\n        } else {\n          if (msb > 112)\n            xSignifier >>= msb - 112;\n          else if (msb < 112)\n            xSignifier <<= 112 - msb;\n\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n          xExponent = xExponent + msb - 16607;\n        }\n\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n            xExponent << 112 | xSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y.  Special values behave in the following way:\n   *\n   * NaN / x = NaN for any x.\n   * x / NaN = NaN for any x.\n   * Infinity / x = Infinity for any finite non-negative x.\n   * Infinity / x = -Infinity for any finite negative x including -0.\n   * -Infinity / x = -Infinity for any finite non-negative x.\n   * -Infinity / x = Infinity for any finite negative x including -0.\n   * x / Infinity = 0 for any finite non-negative x.\n   * x / -Infinity = -0 for any finite non-negative x.\n   * x / Infinity = -0 for any finite non-negative x including -0.\n   * x / -Infinity = 0 for any finite non-negative x including -0.\n   * \n   * Infinity / Infinity = NaN.\n   * Infinity / -Infinity = -NaN.\n   * -Infinity / Infinity = -NaN.\n   * -Infinity / -Infinity = NaN.\n   *\n   * Division by zero behaves in the following way:\n   *\n   * x / 0 = Infinity for any finite positive x.\n   * x / -0 = -Infinity for any finite positive x.\n   * x / 0 = -Infinity for any finite negative x.\n   * x / -0 = Infinity for any finite negative x.\n   * 0 / 0 = NaN.\n   * 0 / -0 = NaN.\n   * -0 / 0 = NaN.\n   * -0 / -0 = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) return NaN;\n        else return x ^ y & 0x80000000000000000000000000000000;\n      } else if (yExponent == 0x7FFF) {\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\n      } else {\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) {\n          if (xSignifier != 0) {\n            uint shift = 226 - mostSignificantBit (xSignifier);\n\n            xSignifier <<= shift;\n\n            xExponent = 1;\n            yExponent += shift - 114;\n          }\n        }\n        else {\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n        }\n\n        xSignifier = xSignifier / ySignifier;\n        if (xSignifier == 0)\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n              NEGATIVE_ZERO : POSITIVE_ZERO;\n\n        assert (xSignifier >= 0x1000000000000000000000000000);\n\n        uint256 msb =\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\n\n        if (xExponent + msb > yExponent + 16497) { // Overflow\n          xExponent = 0x7FFF;\n          xSignifier = 0;\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\n          xExponent = 0;\n          xSignifier = 0;\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\n          if (xExponent + 16380 > yExponent)\n            xSignifier <<= xExponent + 16380 - yExponent;\n          else if (xExponent + 16380 < yExponent)\n            xSignifier >>= yExponent - xExponent - 16380;\n\n          xExponent = 0;\n        } else { // Normal\n          if (msb > 112)\n            xSignifier >>= msb - 112;\n\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n          xExponent = xExponent + msb + 16269 - yExponent;\n        }\n\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n            xExponent << 112 | xSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate -x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function neg (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return x ^ 0x80000000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Calculate |x|.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function abs (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    }\n  }\n\n  /**\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\n      else {\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n        if (xExponent == 0x7FFF) return x;\n        else {\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          if (xExponent == 0) xExponent = 1;\n          else xSignifier |= 0x10000000000000000000000000000;\n\n          if (xSignifier == 0) return POSITIVE_ZERO;\n\n          bool oddExponent = xExponent & 0x1 == 0;\n          xExponent = xExponent + 16383 >> 1;\n\n          if (oddExponent) {\n            if (xSignifier >= 0x10000000000000000000000000000)\n              xSignifier <<= 113;\n            else {\n              uint256 msb = mostSignificantBit (xSignifier);\n              uint256 shift = (226 - msb) & 0xFE;\n              xSignifier <<= shift;\n              xExponent -= shift - 112 >> 1;\n            }\n          } else {\n            if (xSignifier >= 0x10000000000000000000000000000)\n              xSignifier <<= 112;\n            else {\n              uint256 msb = mostSignificantBit (xSignifier);\n              uint256 shift = (225 - msb) & 0xFE;\n              xSignifier <<= shift;\n              xExponent -= shift - 112 >> 1;\n            }\n          }\n\n          uint256 r = 0x10000000000000000000000000000;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\n          uint256 r1 = xSignifier / r;\n          if (r1 < r) r = r1;\n\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \n      else {\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n        if (xExponent == 0x7FFF) return x;\n        else {\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          if (xExponent == 0) xExponent = 1;\n          else xSignifier |= 0x10000000000000000000000000000;\n\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\n\n          bool resultNegative;\n          uint256 resultExponent = 16495;\n          uint256 resultSignifier;\n\n          if (xExponent >= 0x3FFF) {\n            resultNegative = false;\n            resultSignifier = xExponent - 0x3FFF;\n            xSignifier <<= 15;\n          } else {\n            resultNegative = true;\n            if (xSignifier >= 0x10000000000000000000000000000) {\n              resultSignifier = 0x3FFE - xExponent;\n              xSignifier <<= 15;\n            } else {\n              uint256 msb = mostSignificantBit (xSignifier);\n              resultSignifier = 16493 - msb;\n              xSignifier <<= 127 - msb;\n            }\n          }\n\n          if (xSignifier == 0x80000000000000000000000000000000) {\n            if (resultNegative) resultSignifier += 1;\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\n            resultSignifier <<= shift;\n            resultExponent -= shift;\n          } else {\n            uint256 bb = resultNegative ? 1 : 0;\n            while (resultSignifier < 0x10000000000000000000000000000) {\n              resultSignifier <<= 1;\n              resultExponent -= 1;\n  \n              xSignifier *= xSignifier;\n              uint256 b = xSignifier >> 255;\n              resultSignifier += b ^ bb;\n              xSignifier >>= 127 + b;\n            }\n          }\n\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function ln (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\n    }\n  }\n\n  /**\n   * Calculate 2^x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\n      else if (xExponent > 16397)\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n      else if (xExponent < 16255)\n        return 0x3FFF0000000000000000000000000000;\n      else {\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        if (xExponent > 16367)\n          xSignifier <<= xExponent - 16367;\n        else if (xExponent < 16367)\n          xSignifier >>= 16367 - xExponent;\n\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\n          return POSITIVE_ZERO;\n\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n          return POSITIVE_INFINITY;\n\n        uint256 resultExponent = xSignifier >> 128;\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xNegative && xSignifier != 0) {\n          xSignifier = ~xSignifier;\n          resultExponent += 1;\n        }\n\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\n\n        if (!xNegative) {\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          resultExponent += 0x3FFF;\n        } else if (resultExponent <= 0x3FFE) {\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          resultExponent = 0x3FFF - resultExponent;\n        } else {\n          resultSignifier = resultSignifier >> resultExponent - 16367;\n          resultExponent = 0;\n        }\n\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate e^x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function exp (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n    }\n  }\n\n  /**\n   * Get index of the most significant non-zero bit in binary representation of\n   * x.  Reverts if x is zero.\n   *\n   * @return index of the most significant non-zero bit in binary representation\n   *         of x\n   */\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\n    unchecked {\n      require (x > 0);\n\n      uint256 result = 0;\n\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\n      if (x >= 0x10000) { x >>= 16; result += 16; }\n      if (x >= 0x100) { x >>= 8; result += 8; }\n      if (x >= 0x10) { x >>= 4; result += 4; }\n      if (x >= 0x4) { x >>= 2; result += 2; }\n      if (x >= 0x2) result += 1; // No need to shift x anymore\n\n      return result;\n    }\n  }\n}\n\n/// @title Interface of ipToken - Liquidity Pool Token managed by Router in IPOR Protocol for a given asset.\n/// For more information refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/liquidity-provisioning#liquidity-tokens\ninterface IIpToken is IERC20 {\n    /// @notice Gets the asset / stablecoin address which is associated with particular ipToken smart contract instance\n    /// @return asset / stablecoin address\n    function getAsset() external view returns (address);\n\n    /// @notice Gets the Token Manager's address.\n    function getTokenManager() external view returns (address);\n\n    /// @notice Sets token manager's address. IpToken contract Owner only\n    /// @dev only Token Manager can mint or burn ipTokens. Function emits `TokenManagerChanged` event.\n    /// @param newTokenManager Token Managers's address\n    function setTokenManager(address newTokenManager) external;\n\n    /// @notice Creates the ipTokens in the `amount` given and assigns them to the `account`\n    /// @dev Emits {Transfer} from ERC20 asset and {Mint} event from ipToken\n    /// @param account to which the created ipTokens were assigned\n    /// @param amount volume of ipTokens created\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns the `amount` of ipTokens from `account`, reducing the total supply\n    /// @dev Emits {Transfer} from ERC20 asset and {Burn} event from ipToken\n    /// @param account from which burned ipTokens are taken\n    /// @param amount volume of ipTokens that will be burned, represented in 18 decimals\n    function burn(address account, uint256 amount) external;\n\n    /// @notice Emitted after the `amount` ipTokens were mint and transferred to `account`.\n    /// @param account address where ipTokens are transferred after minting\n    /// @param amount of ipTokens minted, represented in 18 decimals\n    event Mint(address indexed account, uint256 amount);\n\n    /// @notice Emitted after `amount` ipTokens were transferred from `account` and burnt.\n    /// @param account address from which ipTokens are transferred to be burned\n    /// @param amount volume of ipTokens burned\n    event Burn(address indexed account, uint256 amount);\n\n    /// @notice Emitted when Token Manager address is changed by its owner.\n    /// @param newTokenManager new address of Token Manager\n    event TokenManagerChanged(address indexed newTokenManager);\n}\n\n/// @title Interface for interaction with IporOracle, smart contract responsible for managing IPOR Index.\ninterface IIporOracle {\n    /// @notice Structure representing parameters required to update an IPOR index for a given asset.\n    /// @dev This structure is used in the `updateIndexes` method to provide necessary details for updating IPOR indexes.\n    ///      For assets other than '_stEth', the 'quasiIbtPrice' field is not utilized in the update process.\n    /// @param asset The address of the underlying asset/stablecoin supported by the IPOR Protocol.\n    /// @param indexValue The new value of the IPOR index to be set for the specified asset.\n    /// @param updateTimestamp The timestamp at which the index value is updated, used to calculate accrued interest.\n    /// @param quasiIbtPrice The quasi interest-bearing token (IBT) price, applicable only for the '_stEth' asset.\n    ///                      Represents a specialized value used in calculations for staked Ethereum.\n    struct UpdateIndexParams {\n        address asset;\n        uint256 indexValue;\n        uint256 updateTimestamp;\n        uint256 quasiIbtPrice;\n    }\n\n    /// @notice Returns current version of IporOracle's\n    /// @dev Increase number when implementation inside source code is different that implementation deployed on Mainnet\n    /// @return current IporOracle version\n    function getVersion() external pure returns (uint256);\n\n    /// @notice Gets IPOR Index indicators for a given asset\n    /// @dev all returned values represented in 18 decimals\n    /// @param asset underlying / stablecoin address supported in Ipor Protocol\n    /// @return indexValue IPOR Index value for a given asset calculated for time lastUpdateTimestamp\n    /// @return ibtPrice Interest Bearing Token Price for a given IPOR Index calculated for time lastUpdateTimestamp\n    /// @return lastUpdateTimestamp Last IPOR Index update done by off-chain service\n    /// @dev For calculation accrued IPOR Index indicators (indexValue and ibtPrice) for a specified timestamp use {getAccruedIndex} function.\n    /// Method {getIndex} calculates IPOR Index indicators for a moment when last update was done by off-chain service,\n    /// this timestamp is stored in lastUpdateTimestamp variable.\n    function getIndex(\n        address asset\n    ) external view returns (uint256 indexValue, uint256 ibtPrice, uint256 lastUpdateTimestamp);\n\n    /// @notice Gets accrued IPOR Index indicators for a given timestamp and asset.\n    /// @param calculateTimestamp time of accrued IPOR Index calculation\n    /// @param asset underlying / stablecoin address supported by IPOR Protocol.\n    /// @return accruedIpor structure {IporTypes.AccruedIpor}\n    /// @dev ibtPrice included in accruedIpor structure is calculated using continuous compounding interest formula\n    function getAccruedIndex(\n        uint256 calculateTimestamp,\n        address asset\n    ) external view returns (IporTypes.AccruedIpor memory accruedIpor);\n\n    /// @notice Calculates accrued Interest Bearing Token price for a given asset and timestamp.\n    /// @param asset underlying / stablecoin address supported by IPOR Protocol.\n    /// @param calculateTimestamp time of accrued Interest Bearing Token price calculation\n    /// @return accrued IBT price, represented in 18 decimals\n    function calculateAccruedIbtPrice(address asset, uint256 calculateTimestamp) external view returns (uint256);\n\n    /// @notice Updates the Indexes based on the provided parameters.\n    /// It is marked as 'onlyUpdater' meaning it has restricted access, and 'whenNotPaused' indicating it only operates when the contract is not paused.\n    /// @param indexesToUpdate An array of `IIporOracle.UpdateIndexParams` to be updated.\n    /// The structure typically contains fields like 'asset', 'indexValue', 'updateTimestamp', and 'quasiIbtPrice'.\n    /// However, 'updateTimestamp' and 'quasiIbtPrice' are not used in this function.\n    function updateIndexes(UpdateIndexParams[] calldata indexesToUpdate) external;\n\n    /// @notice Updates both the Indexes and the Quasi IBT (Interest Bearing Token) Price based on the provided parameters.\n    /// @param indexesToUpdate An array of `IIporOracle.UpdateIndexParams` to be updated.\n    /// The structure contains fields such as 'asset', 'indexValue', 'updateTimestamp', and 'quasiIbtPrice', all of which are utilized in this update process.\n    function updateIndexesAndQuasiIbtPrice(IIporOracle.UpdateIndexParams[] calldata indexesToUpdate) external;\n\n    /// @notice Adds new Updater. Updater has right to update IPOR Index. Function available only for Owner.\n    /// @param newUpdater new updater address\n    function addUpdater(address newUpdater) external;\n\n    /// @notice Removes Updater. Function available only for Owner.\n    /// @param updater updater address\n    function removeUpdater(address updater) external;\n\n    /// @notice Checks if given account is an Updater.\n    /// @param account account for checking\n    /// @return 0 if account is not updater, 1 if account is updater.\n    function isUpdater(address account) external view returns (uint256);\n\n    /// @notice Adds new asset which IPOR Protocol will support. Function available only for Owner.\n    /// @param newAsset new asset address\n    /// @param updateTimestamp Time when start to accrue interest for Interest Bearing Token price.\n    function addAsset(address newAsset, uint256 updateTimestamp) external;\n\n    /// @notice Removes asset which IPOR Protocol will not support. Function available only for Owner.\n    /// @param asset  underlying / stablecoin address which current is supported by IPOR Protocol.\n    function removeAsset(address asset) external;\n\n    /// @notice Checks if given asset is supported by IPOR Protocol.\n    /// @param asset underlying / stablecoin address\n    function isAssetSupported(address asset) external view returns (bool);\n\n    /// @notice Emmited when Charlie update IPOR Index.\n    /// @param asset underlying / stablecoin address\n    /// @param indexValue IPOR Index value represented in 18 decimals\n    /// @param quasiIbtPrice quasi Interest Bearing Token price represented in 18 decimals.\n    /// @param updateTimestamp moment when IPOR Index was updated.\n    event IporIndexUpdate(address asset, uint256 indexValue, uint256 quasiIbtPrice, uint256 updateTimestamp);\n\n    /// @notice event emitted when IPOR Index Updater is added by Owner\n    /// @param newUpdater new Updater address\n    event IporIndexAddUpdater(address newUpdater);\n\n    /// @notice event emitted when IPOR Index Updater is removed by Owner\n    /// @param updater updater address\n    event IporIndexRemoveUpdater(address updater);\n\n    /// @notice event emitted when new asset is added by Owner to list of assets supported in IPOR Protocol.\n    /// @param newAsset new asset address\n    /// @param updateTimestamp update timestamp\n    event IporIndexAddAsset(address newAsset, uint256 updateTimestamp);\n\n    /// @notice event emitted when asset is removed by Owner from list of assets supported in IPOR Protocol.\n    /// @param asset asset address\n    event IporIndexRemoveAsset(address asset);\n}\n\nlibrary IporContractValidator {\n    function checkAddress(address addr) internal pure returns (address) {\n        require(addr != address(0), IporErrors.WRONG_ADDRESS);\n        return addr;\n    }\n}\n\n/// @title Interface of the CloseSwap Lens.\ninterface IAmmCloseSwapLens {\n    /// @notice Structure representing the configuration of the AmmCloseSwapService for a given pool (asset).\n    struct AmmCloseSwapServicePoolConfiguration {\n        /// @notice asset address\n        address asset;\n        /// @notice asset decimals\n        uint256 decimals;\n        /// @notice Amm Storage contract address\n        address ammStorage;\n        /// @notice Amm Treasury contract address\n        address ammTreasury;\n        /// @notice Asset Management contract address, for stETH is empty, because stETH doesn't have asset management module\n        address assetManagement;\n        /// @notice Spread address, for USDT, USDC, DAI is a spread router address, for stETH is a spread address\n        address spread;\n        /// @notice Unwinding Fee Rate for unwinding the swap, represented in 18 decimals, 1e18 = 100%\n        uint256 unwindingFeeRate;\n        /// @notice Unwinding Fee Rate for unwinding the swap, part earmarked for the treasury, represented in 18 decimals, 1e18 = 100%\n        uint256 unwindingFeeTreasuryPortionRate;\n        /// @notice Max number of swaps (per leg) that can be liquidated in one call, represented without decimals\n        uint256 maxLengthOfLiquidatedSwapsPerLeg;\n        /// @notice Time before maturity when the community is allowed to close the swap, represented in seconds\n        uint256 timeBeforeMaturityAllowedToCloseSwapByCommunity;\n        /// @notice Time before maturity then the swap owner can close it, for tenor 28 days, represented in seconds\n        uint256 timeBeforeMaturityAllowedToCloseSwapByBuyerTenor28days;\n        /// @notice Time before maturity then the swap owner can close it, for tenor 60 days, represented in seconds\n        uint256 timeBeforeMaturityAllowedToCloseSwapByBuyerTenor60days;\n        /// @notice Time before maturity then the swap owner can close it, for tenor 90 days, represented in seconds\n        uint256 timeBeforeMaturityAllowedToCloseSwapByBuyerTenor90days;\n        /// @notice Min liquidation threshold allowing community to close the swap ahead of maturity, represented in 18 decimals\n        uint256 minLiquidationThresholdToCloseBeforeMaturityByCommunity;\n        /// @notice Min liquidation threshold allowing the owner to close the swap ahead of maturity, represented in 18 decimals\n        uint256 minLiquidationThresholdToCloseBeforeMaturityByBuyer;\n        /// @notice Min leverage of the virtual swap used in unwinding, represented in 18 decimals\n        uint256 minLeverage;\n        /// @notice Time after open swap when it is allowed to close swap with unwinding, for tenor 28 days, represented in seconds\n        uint256 timeAfterOpenAllowedToCloseSwapWithUnwindingTenor28days;\n        /// @notice Time after open swap when it is allowed to close swap with unwinding, for tenor 60 days, represented in seconds\n        uint256 timeAfterOpenAllowedToCloseSwapWithUnwindingTenor60days;\n        /// @notice Time after open swap when it is allowed to close swap with unwinding, for tenor 90 days, represented in seconds\n        uint256 timeAfterOpenAllowedToCloseSwapWithUnwindingTenor90days;\n    }\n\n    /// @notice Returns the configuration of the AmmCloseSwapService for a given pool (asset).\n    /// @param asset asset address\n    /// @return AmmCloseSwapServicePoolConfiguration struct representing the configuration of the AmmCloseSwapService for a given pool (asset).\n    function getAmmCloseSwapServicePoolConfiguration(\n        address asset\n    ) external view returns (AmmCloseSwapServicePoolConfiguration memory);\n\n    /// @notice Returns the closing swap details for a given swap and closing timestamp.\n    /// @param asset asset address\n    /// @param account account address for which are returned closing swap details, for example closableStatus depends on the account\n    /// @param direction swap direction\n    /// @param swapId swap id\n    /// @param closeTimestamp closing timestamp\n    /// @param riskIndicatorsInput risk indicators input\n    /// @return closingSwapDetails struct representing the closing swap details for a given swap and closing timestamp.\n    function getClosingSwapDetails(\n        address asset,\n        address account,\n        AmmTypes.SwapDirection direction,\n        uint256 swapId,\n        uint256 closeTimestamp,\n        AmmTypes.CloseSwapRiskIndicatorsInput calldata riskIndicatorsInput\n    ) external view returns (AmmTypes.ClosingSwapDetails memory closingSwapDetails);\n}\n\n/// @title Types used in interfaces strictly related to AMM (Automated Market Maker).\n/// @dev Used by IAmmTreasury and IAmmStorage interfaces.\nlibrary AmmTypes {\n    /// @notice Struct describing AMM Pool's core addresses.\n    struct AmmPoolCoreModel {\n        /// @notice asset address\n        address asset;\n        /// @notice asset decimals\n        uint256 assetDecimals;\n        /// @notice ipToken address associated to the asset\n        address ipToken;\n        /// @notice AMM Storage address\n        address ammStorage;\n        /// @notice AMM Treasury address\n        address ammTreasury;\n        /// @notice Asset Management address\n        address assetManagement;\n        /// @notice IPOR Oracle address\n        address iporOracle;\n    }\n\n    /// @notice Structure which represents Swap's data that will be saved in the storage.\n    /// Refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/ipor-swaps for more information.\n    struct NewSwap {\n        /// @notice Account / trader who opens the Swap\n        address buyer;\n        /// @notice Epoch timestamp of when position was opened by the trader.\n        uint256 openTimestamp;\n        /// @notice Swap's collateral amount.\n        /// @dev value represented in 18 decimals\n        uint256 collateral;\n        /// @notice Swap's notional amount.\n        /// @dev value represented in 18 decimals\n        uint256 notional;\n        /// @notice Quantity of Interest Bearing Token (IBT) at moment when position was opened.\n        /// @dev value represented in 18 decimals\n        uint256 ibtQuantity;\n        /// @notice Fixed interest rate at which the position has been opened.\n        /// @dev value represented in 18 decimals\n        uint256 fixedInterestRate;\n        /// @notice Liquidation deposit is retained when the swap is opened. It is then paid back to agent who closes the derivative at maturity.\n        /// It can be both trader or community member. Trader receives the deposit back when he chooses to close the derivative before maturity.\n        /// @dev value represented WITHOUT 18 decimals for USDT, USDC, DAI pool. Notice! Value represented in 6 decimals for stETH pool.\n        /// @dev Example value in 6 decimals: 25000000 (in 6 decimals) = 25 stETH = 25.000000\n        uint256 liquidationDepositAmount;\n        /// @notice Opening fee amount part which is allocated in Liquidity Pool Balance. This fee is calculated as a rate of the swap's collateral.\n        /// @dev value represented in 18 decimals\n        uint256 openingFeeLPAmount;\n        /// @notice Opening fee amount part which is allocated in Treasury Balance. This fee is calculated as a rate of the swap's collateral.\n        /// @dev value represented in 18 decimals\n        uint256 openingFeeTreasuryAmount;\n        /// @notice Swap's tenor, 0 - 28 days, 1 - 60 days or 2 - 90 days\n        IporTypes.SwapTenor tenor;\n    }\n\n    /// @notice Struct representing swap item, used for listing and in internal calculations\n    struct Swap {\n        /// @notice Swap's unique ID\n        uint256 id;\n        /// @notice Swap's buyer\n        address buyer;\n        /// @notice Swap opening epoch timestamp\n        uint256 openTimestamp;\n        /// @notice Swap's tenor\n        IporTypes.SwapTenor tenor;\n        /// @notice Index position of this Swap in an array of swaps' identification associated to swap buyer\n        /// @dev Field used for gas optimization purposes, it allows for quick removal by id in the array.\n        /// During removal the last item in the array is switched with the one that just has been removed.\n        uint256 idsIndex;\n        /// @notice Swap's collateral\n        /// @dev value represented in 18 decimals\n        uint256 collateral;\n        /// @notice Swap's notional amount\n        /// @dev value represented in 18 decimals\n        uint256 notional;\n        /// @notice Swap's notional amount denominated in the Interest Bearing Token (IBT)\n        /// @dev value represented in 18 decimals\n        uint256 ibtQuantity;\n        /// @notice Fixed interest rate at which the position has been opened\n        /// @dev value represented in 18 decimals\n        uint256 fixedInterestRate;\n        /// @notice Liquidation deposit amount\n        /// @dev value represented in 18 decimals\n        uint256 liquidationDepositAmount;\n        /// @notice State of the swap\n        /// @dev 0 - INACTIVE, 1 - ACTIVE\n        IporTypes.SwapState state;\n    }\n\n    /// @notice Struct representing amounts related to Swap that is presently being opened.\n    /// @dev all values represented in 18 decimals\n    struct OpenSwapAmount {\n        /// @notice Total Amount of asset that is sent from buyer to AmmTreasury when opening swap.\n        uint256 totalAmount;\n        /// @notice Swap's collateral\n        uint256 collateral;\n        /// @notice Swap's notional\n        uint256 notional;\n        /// @notice Opening Fee - part allocated as a profit of the Liquidity Pool\n        uint256 openingFeeLPAmount;\n        /// @notice  Part of the fee set aside for subsidizing the oracle that publishes IPOR rate. Flat fee set by the DAO.\n        /// @notice Opening Fee - part allocated in Treasury balance. Part of the fee set asside for subsidising the oracle that publishes IPOR rate. Flat fee set by the DAO.\n        uint256 openingFeeTreasuryAmount;\n        /// @notice Fee set aside for subsidizing the oracle that publishes IPOR rate. Flat fee set by the DAO.\n        uint256 iporPublicationFee;\n        /// @notice Liquidation deposit is retained when the swap is opened. Value represented in 18 decimals.\n        uint256 liquidationDepositAmount;\n    }\n\n    /// @notice Structure describes one swap processed by closeSwaps method, information about swap ID and flag if this swap was closed during execution closeSwaps method.\n    struct IporSwapClosingResult {\n        /// @notice Swap ID\n        uint256 swapId;\n        /// @notice Flag describe if swap was closed during this execution\n        bool closed;\n    }\n\n    /// @notice Technical structure used for storing information about amounts used during redeeming assets from liquidity pool.\n    struct RedeemAmount {\n        /// @notice Asset amount represented in 18 decimals\n        /// @dev Asset amount is a sum of wadRedeemFee and wadRedeemAmount\n        uint256 wadAssetAmount;\n        /// @notice Redeemed amount represented in decimals of asset\n        uint256 redeemAmount;\n        /// @notice Redeem fee value represented in 18 decimals\n        uint256 wadRedeemFee;\n        /// @notice Redeem amount represented in 18 decimals\n        uint256 wadRedeemAmount;\n    }\n\n    struct UnwindParams {\n        /// @notice Risk Indicators Inputs signer\n        address messageSigner;\n        /// @notice Spread Router contract address\n        address spreadRouter;\n        address ammStorage;\n        address ammTreasury;\n        SwapDirection direction;\n        uint256 closeTimestamp;\n        int256 swapPnlValueToDate;\n        uint256 indexValue;\n        Swap swap;\n        IAmmCloseSwapLens.AmmCloseSwapServicePoolConfiguration poolCfg;\n        CloseSwapRiskIndicatorsInput riskIndicatorsInputs;\n    }\n\n    /// @notice Swap direction (long = Pay Fixed and Receive a Floating or short = receive fixed and pay a floating)\n    enum SwapDirection {\n        /// @notice When taking the \"long\" position the trader will pay a fixed rate and receive a floating rate.\n        /// for more information refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/ipor-swaps\n        PAY_FIXED_RECEIVE_FLOATING,\n        /// @notice When taking the \"short\" position the trader will pay a floating rate and receive a fixed rate.\n        PAY_FLOATING_RECEIVE_FIXED\n    }\n    /// @notice List of closable statuses for a given swap\n    /// @dev Closable status is a one of the following values:\n    /// 0 - Swap is closable\n    /// 1 - Swap is already closed\n    /// 2 - Swap state required Buyer or Liquidator to close. Sender is not Buyer nor Liquidator.\n    /// 3 - Cannot close swap, closing is too early for Community\n    /// 4 - Cannot close swap with unwind because action is too early from the moment when swap was opened, validation based on Close Service configuration\n    enum SwapClosableStatus {\n        SWAP_IS_CLOSABLE,\n        SWAP_ALREADY_CLOSED,\n        SWAP_REQUIRED_BUYER_OR_LIQUIDATOR_TO_CLOSE,\n        SWAP_CANNOT_CLOSE_CLOSING_TOO_EARLY_FOR_COMMUNITY,\n        SWAP_CANNOT_CLOSE_WITH_UNWIND_ACTION_IS_TOO_EARLY\n    }\n\n    /// @notice Collection of swap attributes connected with IPOR Index and swap itself.\n    /// @dev all values are in 18 decimals\n    struct IporSwapIndicator {\n        /// @notice IPOR Index value at the time of swap opening\n        uint256 iporIndexValue;\n        /// @notice IPOR Interest Bearing Token (IBT) price at the time of swap opening\n        uint256 ibtPrice;\n        /// @notice Swap's notional denominated in IBT\n        uint256 ibtQuantity;\n        /// @notice Fixed interest rate at which the position has been opened,\n        /// it is quote from spread documentation\n        uint256 fixedInterestRate;\n    }\n\n    /// @notice Risk indicators calculated for swap opening\n    struct OpenSwapRiskIndicators {\n        /// @notice Maximum collateral ratio in general\n        uint256 maxCollateralRatio;\n        /// @notice Maximum collateral ratio for a given leg\n        uint256 maxCollateralRatioPerLeg;\n        /// @notice Maximum leverage for a given leg\n        uint256 maxLeveragePerLeg;\n        /// @notice Base Spread for a given leg (without demand part)\n        int256 baseSpreadPerLeg;\n        /// @notice Fixed rate cap\n        uint256 fixedRateCapPerLeg;\n        /// @notice Demand spread factor used to calculate demand spread\n        uint256 demandSpreadFactor;\n    }\n\n    /// @notice Risk indicators calculated for swap opening\n    struct RiskIndicatorsInputs {\n        /// @notice Maximum collateral ratio in general\n        uint256 maxCollateralRatio;\n        /// @notice Maximum collateral ratio for a given leg\n        uint256 maxCollateralRatioPerLeg;\n        /// @notice Maximum leverage for a given leg\n        uint256 maxLeveragePerLeg;\n        /// @notice Base Spread for a given leg (without demand part)\n        int256 baseSpreadPerLeg;\n        /// @notice Fixed rate cap\n        uint256 fixedRateCapPerLeg;\n        /// @notice Demand spread factor used to calculate demand spread\n        uint256 demandSpreadFactor;\n        /// @notice expiration date in seconds\n        uint256 expiration;\n        /// @notice signature of data (maxCollateralRatio, maxCollateralRatioPerLeg,maxLeveragePerLeg,baseSpreadPerLeg,fixedRateCapPerLeg,demandSpreadFactor,expiration,asset,tenor,direction)\n        /// asset - address\n        /// tenor - uint256\n        /// direction - uint256\n        bytes signature;\n    }\n\n    struct CloseSwapRiskIndicatorsInput {\n        RiskIndicatorsInputs payFixed;\n        RiskIndicatorsInputs receiveFixed;\n    }\n\n    /// @notice Structure containing information about swap's closing status, unwind values and PnL for a given swap and time.\n    struct ClosingSwapDetails {\n        /// @notice Swap's closing status\n        AmmTypes.SwapClosableStatus closableStatus;\n        /// @notice Flag indicating if swap unwind is required\n        bool swapUnwindRequired;\n        /// @notice Swap's unwind PnL Value, part of PnL corresponded to virtual swap (unwinded swap), represented in 18 decimals\n        int256 swapUnwindPnlValue;\n        /// @notice Unwind opening fee amount it is a sum of `swapUnwindFeeLPAmount` and `swapUnwindFeeTreasuryAmount`\n        uint256 swapUnwindOpeningFeeAmount;\n        /// @notice Part of unwind opening fee allocated as a profit of the Liquidity Pool\n        uint256 swapUnwindFeeLPAmount;\n        /// @notice Part of unwind opening fee allocated in Treasury Balance\n        uint256 swapUnwindFeeTreasuryAmount;\n        /// @notice Final Profit and Loss which takes into account the swap unwind and limits the PnL to the collateral amount. Represented in 18 decimals.\n        int256 pnlValue;\n    }\n}\n\n/// @notice The types used in the AmmTreasury's interface.\n/// @dev All values, where applicable, are represented in 18 decimals.\nlibrary AmmInternalTypes {\n    struct PnlValueStruct {\n        /// @notice PnL Value of the swap.\n        int256 pnlValue;\n        /// @notice flag indicating if unwind is required when closing swap.\n        bool swapUnwindRequired;\n        /// @notice Unwind amount of the swap.\n        int256 swapUnwindAmount;\n        /// @notice Unwind fee of the swap that will be added to the AMM liquidity pool balance.\n        uint256 swapUnwindFeeLPAmount;\n        /// @notice Unwind fee of the swap that will be added to the AMM treasury balance.\n        uint256 swapUnwindFeeTreasuryAmount;\n    }\n\n    struct BeforeOpenSwapStruct {\n        /// @notice Sum of all asset transferred when opening swap. It includes the collateral, fees and deposits.\n        /// @dev The amount is represented in 18 decimals regardless of the decimals of the asset.\n        uint256 wadTotalAmount;\n        /// @notice Swap's collateral.\n        uint256 collateral;\n        /// @notice Swap's notional amount.\n        uint256 notional;\n        /// @notice The part of the opening fee that will be added to the liquidity pool balance.\n        uint256 openingFeeLPAmount;\n        /// @notice Part of the opening fee that will be added to the treasury balance.\n        uint256 openingFeeTreasuryAmount;\n        /// @notice Amount of asset set aside for the oracle subsidization.\n        uint256 iporPublicationFeeAmount;\n        /// @notice Refundable deposit blocked for the entity that will close the swap.\n        /// For more information on how the liquidations work refer to the documentation.\n        /// https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/liquidations\n        /// @dev value represented without decimals for USDT, USDC, DAI, with 6 decimals for stETH, as an integer.\n        uint256 liquidationDepositAmount;\n        /// @notice The struct describing the IPOR and its params calculated for the time when it was most recently updated and the change that took place since the update.\n        /// Namely, the interest that would be computed into IBT should the rebalance occur.\n        IporTypes.AccruedIpor accruedIpor;\n    }\n\n    /// @notice Risk indicators context data\n    struct RiskIndicatorsContext {\n        /// @notice Asset address for which the risk indicators are calculated.\n        address asset;\n        /// @notice Tenor of the swap.\n        IporTypes.SwapTenor tenor;\n        /// @notice AMM Liquidity Pool balance.\n        uint256 liquidityPoolBalance;\n        /// @notice AMM Min Leverage allowed for a swap.\n        uint256 minLeverage;\n    }\n\n    /// @notice Spread context data\n    struct SpreadContext {\n        /// @notice Asset address for which the spread is calculated.\n        address asset;\n        /// @notice Signature of spread method used to calculate spread.\n        bytes4 spreadFunctionSig;\n        /// @notice Tenor of the swap.\n        IporTypes.SwapTenor tenor;\n        /// @notice Swap's notional\n        uint256 notional;\n        /// @notice Minimum leverage allowed for a swap.\n        uint256 minLeverage;\n        /// @notice Ipor Index Value\n        uint256 indexValue;\n        /// @notice Risk Indicators data for a opened swap used to calculate spread.\n        AmmTypes.OpenSwapRiskIndicators riskIndicators;\n        /// @notice AMM Balance for a opened swap used to calculate spread.\n        IporTypes.AmmBalancesForOpenSwapMemory balance;\n    }\n\n    /// @notice Open swap item - element of linked list of swaps\n    struct OpenSwapItem {\n        /// @notice Swap ID\n        uint32 swapId;\n        /// @notcie Next swap ID in linked list\n        uint32 nextSwapId;\n        /// @notice Previous swap ID in linked list\n        uint32 previousSwapId;\n        /// @notice Timestamp of the swap opening\n        uint32 openSwapTimestamp;\n    }\n\n    /// @notice Open swap list structure\n    struct OpenSwapList {\n        /// @notice Head swap ID\n        uint32 headSwapId;\n        /// @notice Swaps mapping, where key is swap ID\n        mapping(uint32 => OpenSwapItem) swaps;\n    }\n}\n\nlibrary InterestRates {\n    using SafeCast for uint256;\n\n    /// @notice Adds interest to given value using continuous compounding formula: v2 = value * e^(interestRate * time)\n    /// @param value value to which interest is added, value represented in 18 decimals\n    /// @param interestRatePeriodMultiplication interest rate * time, interest rate in 18 decimals, time in seconds\n    /// @return value with interest, value represented in 18 decimals\n    function addContinuousCompoundInterestUsingRatePeriodMultiplication(\n        uint256 value,\n        uint256 interestRatePeriodMultiplication\n    ) internal pure returns (uint256) {\n        uint256 interestRateYearsMultiplication = IporMath.division(\n            interestRatePeriodMultiplication,\n            Constants.YEAR_IN_SECONDS\n        );\n        bytes16 floatValue = _toQuadruplePrecision(value, 1e18);\n        bytes16 floatIpm = _toQuadruplePrecision(interestRateYearsMultiplication, 1e18);\n        bytes16 valueWithInterest = ABDKMathQuad.mul(floatValue, ABDKMathQuad.exp(floatIpm));\n        return _toUint256(valueWithInterest);\n    }\n\n    /// @notice Adds interest to given value using continuous compounding formula: v2 = value * e^(interestRate * time)\n    /// @param value value to which interest is added, value represented in 18 decimals\n    /// @param interestRatePeriodMultiplication interest rate * time, interest rate in 18 decimals, time in seconds\n    /// @return value with interest, value represented in 18 decimals\n    function addContinuousCompoundInterestUsingRatePeriodMultiplicationInt(\n        int256 value,\n        int256 interestRatePeriodMultiplication\n    ) internal pure returns (int256) {\n        int256 interestRateYearsMultiplication = IporMath.divisionInt(\n            interestRatePeriodMultiplication,\n            Constants.YEAR_IN_SECONDS.toInt256()\n        );\n        bytes16 floatValue = _toQuadruplePrecisionInt(value, 1e18);\n        bytes16 floatIpm = _toQuadruplePrecisionInt(interestRateYearsMultiplication, 1e18);\n        bytes16 valueWithInterest = ABDKMathQuad.mul(floatValue, ABDKMathQuad.exp(floatIpm));\n        return _toInt256(valueWithInterest);\n    }\n\n    /// @notice Calculates interest to given value using continuous compounding formula: v2 = value * e^(interestRate * time)\n    /// @param value value to which interest is added, value represented in 18 decimals\n    /// @param interestRatePeriodMultiplication interest rate * time, interest rate in 18 decimals, time in seconds\n    /// @return interest, value represented in 18 decimals\n    function calculateContinuousCompoundInterestUsingRatePeriodMultiplication(\n        uint256 value,\n        uint256 interestRatePeriodMultiplication\n    ) internal pure returns (uint256) {\n        return\n            addContinuousCompoundInterestUsingRatePeriodMultiplication(value, interestRatePeriodMultiplication) - value;\n    }\n\n    /// @notice Calculates interest to given value using continuous compounding formula: v2 = value * e^(interestRate * time)\n    /// @param value value to which interest is added, value represented in 18 decimals\n    /// @param interestRatePeriodMultiplication interest rate * time, interest rate in 18 decimals, time in seconds\n    /// @return interest, value represented in 18 decimals\n    function calculateContinuousCompoundInterestUsingRatePeriodMultiplicationInt(\n        int256 value,\n        int256 interestRatePeriodMultiplication\n    ) internal pure returns (int256) {\n        return\n            addContinuousCompoundInterestUsingRatePeriodMultiplicationInt(value, interestRatePeriodMultiplication) -\n            value;\n    }\n\n    /// @dev Quadruple precision, 128 bits\n    function _toQuadruplePrecision(uint256 number, uint256 decimals) private pure returns (bytes16) {\n        if (number % decimals > 0) {\n            /// @dev during calculation this value is lost in the conversion\n            number += 1;\n        }\n        bytes16 nominator = ABDKMathQuad.fromUInt(number);\n        bytes16 denominator = ABDKMathQuad.fromUInt(decimals);\n        bytes16 fraction = ABDKMathQuad.div(nominator, denominator);\n        return fraction;\n    }\n\n    /// @dev Quadruple precision, 128 bits\n    function _toQuadruplePrecisionInt(int256 number, int256 decimals) private pure returns (bytes16) {\n        if (number % decimals > 0) {\n            /// @dev during calculation this value is lost in the conversion\n            number += 1;\n        }\n        bytes16 nominator = ABDKMathQuad.fromInt(number);\n        bytes16 denominator = ABDKMathQuad.fromInt(decimals);\n        bytes16 fraction = ABDKMathQuad.div(nominator, denominator);\n        return fraction;\n    }\n\n    function _toUint256(bytes16 value) private pure returns (uint256) {\n        bytes16 decimals = ABDKMathQuad.fromUInt(1e18);\n        bytes16 resultD18 = ABDKMathQuad.mul(value, decimals);\n        return ABDKMathQuad.toUInt(resultD18);\n    }\n\n    function _toInt256(bytes16 value) private pure returns (int256) {\n        bytes16 decimals = ABDKMathQuad.fromUInt(1e18);\n        bytes16 resultD18 = ABDKMathQuad.mul(value, decimals);\n        return ABDKMathQuad.toInt(resultD18);\n    }\n}\n\n/// @title Interface for interaction with the IPOR AMM Storage, contract responsible for managing AMM storage.\ninterface IAmmStorage {\n    /// @notice Returns the current version of AmmTreasury Storage\n    /// @dev Increase number when the implementation inside source code is different that the implementation deployed on the Mainnet\n    /// @return current AmmTreasury Storage version, integer\n    function getVersion() external pure returns (uint256);\n\n    /// @notice Gets the configuration of the IPOR AMM Storage.\n    /// @return ammTreasury address of the AmmTreasury contract\n    /// @return router address of the IPOR Protocol Router contract\n    function getConfiguration() external view returns (address ammTreasury, address router);\n\n    /// @notice Gets last swap ID.\n    /// @dev swap ID is incremented when new position is opened, last swap ID is used in Pay Fixed and Receive Fixed swaps.\n    /// @dev ID is global for all swaps, regardless if they are Pay Fixed or Receive Fixed in tenor 28, 60 or 90 days.\n    /// @return last swap ID, integer\n    function getLastSwapId() external view returns (uint256);\n\n    /// @notice Gets the last opened swap for a given tenor and direction.\n    /// @param tenor tenor of the swap\n    /// @param direction direction of the swap: 0 for Pay Fixed, 1 for Receive Fixed\n    /// @return last opened swap {AmmInternalTypes.OpenSwapItem}\n    function getLastOpenedSwap(\n        IporTypes.SwapTenor tenor,\n        uint256 direction\n    ) external view returns (AmmInternalTypes.OpenSwapItem memory);\n\n    /// @notice Gets the AMM balance struct\n    /// @dev Balance contains:\n    /// # Pay Fixed Total Collateral\n    /// # Receive Fixed Total Collateral\n    /// # Liquidity Pool and Vault balances.\n    /// @return balance structure {IporTypes.AmmBalancesMemory}\n    function getBalance() external view returns (IporTypes.AmmBalancesMemory memory);\n\n    /// @notice Gets the balance for open swap\n    /// @dev Balance contains:\n    /// # Pay Fixed Total Collateral\n    /// # Receive Fixed Total Collateral\n    /// # Liquidity Pool balance\n    /// # Total Notional Pay Fixed\n    /// # Total Notional Receive Fixed\n    /// @return balance structure {IporTypes.AmmBalancesForOpenSwapMemory}\n    function getBalancesForOpenSwap() external view returns (IporTypes.AmmBalancesForOpenSwapMemory memory);\n\n    /// @notice Gets the balance with the extended information: IPOR publication fee balance and Treasury balance.\n    /// @return balance structure {AmmStorageTypes.ExtendedBalancesMemory}\n    function getExtendedBalance() external view returns (AmmStorageTypes.ExtendedBalancesMemory memory);\n\n    /// @notice gets the SOAP indicators.\n    /// @dev SOAP is a Sum Of All Payouts, aka undealised PnL.\n    /// @return indicatorsPayFixed structure {AmmStorageTypes.SoapIndicators} indicators for Pay Fixed swaps\n    /// @return indicatorsReceiveFixed structure {AmmStorageTypes.SoapIndicators} indicators for Receive Fixed swaps\n    function getSoapIndicators()\n        external\n        view\n        returns (\n            AmmStorageTypes.SoapIndicators memory indicatorsPayFixed,\n            AmmStorageTypes.SoapIndicators memory indicatorsReceiveFixed\n        );\n\n    /// @notice Gets swap based on the direction and swap ID.\n    /// @param direction direction of the swap: 0 for Pay Fixed, 1 for Receive Fixed\n    /// @param swapId swap ID\n    /// @return swap structure {AmmTypes.Swap}\n    function getSwap(AmmTypes.SwapDirection direction, uint256 swapId) external view returns (AmmTypes.Swap memory);\n\n    /// @notice Gets the active Pay-Fixed swaps for a given account address.\n    /// @param account account address\n    /// @param offset offset for paging\n    /// @param chunkSize page size for paging\n    /// @return totalCount total number of active Pay-Fixed swaps\n    /// @return swaps array where each element has structure {AmmTypes.Swap}\n    function getSwapsPayFixed(\n        address account,\n        uint256 offset,\n        uint256 chunkSize\n    ) external view returns (uint256 totalCount, AmmTypes.Swap[] memory swaps);\n\n    /// @notice Gets the active Receive-Fixed swaps for a given account address.\n    /// @param account account address\n    /// @param offset offset for paging\n    /// @param chunkSize page size for paging\n    /// @return totalCount total number of active Receive Fixed swaps\n    /// @return swaps array where each element has structure {AmmTypes.Swap}\n    function getSwapsReceiveFixed(\n        address account,\n        uint256 offset,\n        uint256 chunkSize\n    ) external view returns (uint256 totalCount, AmmTypes.Swap[] memory swaps);\n\n    /// @notice Gets the active Pay-Fixed and Receive-Fixed swaps IDs for a given account address.\n    /// @param account account address\n    /// @param offset offset for paging\n    /// @param chunkSize page size for paging\n    /// @return totalCount total number of active Pay-Fixed and Receive-Fixed IDs.\n    /// @return ids array where each element has structure {AmmStorageTypes.IporSwapId}\n    function getSwapIds(\n        address account,\n        uint256 offset,\n        uint256 chunkSize\n    ) external view returns (uint256 totalCount, AmmStorageTypes.IporSwapId[] memory ids);\n\n    /// @notice adds liquidity to the Liquidity Pool. Function available only to Router.\n    /// @param account account address executing request for redeem asset amount\n    /// @param assetAmount amount of asset added to balance of Liquidity Pool, represented in 18 decimals\n    /// @param cfgMaxLiquidityPoolBalance max liquidity pool balance taken from AmmPoolsService configuration, represented in 18 decimals.\n    /// @dev Function is only available to AmmPoolsService, can be executed only by IPOR Protocol Router as internal interaction.\n    function addLiquidityInternal(address account, uint256 assetAmount, uint256 cfgMaxLiquidityPoolBalance) external;\n\n    /// @notice subtract liquidity from the Liquidity Pool. Function available only to Router.\n    /// @param assetAmount amount of asset subtracted from Liquidity Pool, represented in 18 decimals\n    /// @dev Function is only available to AmmPoolsService, it can be executed only by IPOR Protocol Router as internal interaction.\n    function subtractLiquidityInternal(uint256 assetAmount) external;\n\n    /// @notice Updates structures in storage: balance, swaps, SOAP indicators when new Pay-Fixed swap is opened.\n    /// @dev Function is only available to AmmOpenSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\n    /// @param newSwap new swap structure {AmmTypes.NewSwap}\n    /// @param cfgIporPublicationFee publication fee amount taken from AmmTreasury configuration, represented in 18 decimals.\n    /// @return new swap ID\n    function updateStorageWhenOpenSwapPayFixedInternal(\n        AmmTypes.NewSwap memory newSwap,\n        uint256 cfgIporPublicationFee\n    ) external returns (uint256);\n\n    /// @notice Updates structures in the storage: balance, swaps, SOAP indicators when new Receive-Fixed swap is opened.\n    /// @dev Function is only available to AmmOpenSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\n    /// @param newSwap new swap structure {AmmTypes.NewSwap}\n    /// @param cfgIporPublicationFee publication fee amount taken from AmmTreasury configuration, represented in 18 decimals.\n    /// @return new swap ID\n    function updateStorageWhenOpenSwapReceiveFixedInternal(\n        AmmTypes.NewSwap memory newSwap,\n        uint256 cfgIporPublicationFee\n    ) external returns (uint256);\n\n    /// @notice Updates structures in the storage: balance, swaps, SOAP indicators when closing Pay-Fixed swap.\n    /// @dev Function is only available to AmmCloseSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\n    /// @param swap The swap structure containing IPOR swap information.\n    /// @param pnlValue The amount that the trader has earned or lost on the swap, represented in 18 decimals.\n    /// pnValue can be negative, pnlValue NOT INCLUDE potential unwind fee.\n    /// @param swapUnwindFeeLPAmount unwind fee which is accounted on AMM Liquidity Pool balance.\n    /// @param swapUnwindFeeTreasuryAmount unwind fee which is accounted on AMM Treasury balance.\n    /// @param closingTimestamp The moment when the swap was closed.\n    /// @return closedSwap A memory struct representing the closed swap.\n    function updateStorageWhenCloseSwapPayFixedInternal(\n        AmmTypes.Swap memory swap,\n        int256 pnlValue,\n        uint256 swapUnwindFeeLPAmount,\n        uint256 swapUnwindFeeTreasuryAmount,\n        uint256 closingTimestamp\n    ) external returns (AmmInternalTypes.OpenSwapItem memory closedSwap);\n\n    /// @notice Updates structures in the storage: swaps, balances, SOAP indicators when closing Receive-Fixed swap.\n    /// @dev Function is only available to AmmCloseSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\n    /// @param swap The swap structure containing IPOR swap information.\n    /// @param pnlValue The amount that the trader has earned or lost on the swap, represented in 18 decimals.\n    /// pnValue can be negative, pnlValue NOT INCLUDE potential unwind fee.\n    /// @param swapUnwindFeeLPAmount unwind fee which is accounted on AMM Liquidity Pool balance.\n    /// @param swapUnwindFeeTreasuryAmount unwind fee which is accounted on AMM Treasury balance.\n    /// @param closingTimestamp The moment when the swap was closed.\n    /// @return closedSwap A memory struct representing the closed swap.\n    function updateStorageWhenCloseSwapReceiveFixedInternal(\n        AmmTypes.Swap memory swap,\n        int256 pnlValue,\n        uint256 swapUnwindFeeLPAmount,\n        uint256 swapUnwindFeeTreasuryAmount,\n        uint256 closingTimestamp\n    ) external returns (AmmInternalTypes.OpenSwapItem memory closedSwap);\n\n    /// @notice Updates the balance when the AmmPoolsService withdraws AmmTreasury's assets from the AssetManagement.\n    /// @dev Function is only available to the AmmTreasury contract.\n    /// @param withdrawnAmount asset amount that was withdrawn from AssetManagement to AmmTreasury by AmmPoolsService, represented in 18 decimals.\n    /// @param vaultBalance Asset Management Vault (AssetManagement) balance, represented in 18 decimals\n    function updateStorageWhenWithdrawFromAssetManagement(uint256 withdrawnAmount, uint256 vaultBalance) external;\n\n    /// @notice Updates the balance when AmmPoolsService deposits AmmTreasury's assets to AssetManagement. Function is only available to AmmTreasury.\n    /// @param depositAmount asset amount deposited from AmmTreasury to AssetManagement by AmmPoolsService, represented in 18 decimals.\n    /// @param vaultBalance actual Asset Management Vault(AssetManagement) balance , represented in 18 decimals\n    function updateStorageWhenDepositToAssetManagement(uint256 depositAmount, uint256 vaultBalance) external;\n\n    /// @notice Updates the balance when AmmPoolsService transfers AmmTreasury's assets to Oracle Treasury's multisig wallet.\n    /// @dev Function is only available to the AmmGovernanceService, can be executed only by IPOR Protocol Router as internal interaction.\n    /// @param transferredAmount asset amount transferred to Charlie Treasury multisig wallet.\n    function updateStorageWhenTransferToCharlieTreasuryInternal(uint256 transferredAmount) external;\n\n    /// @notice Updates the balance when AmmPoolsService transfers AmmTreasury's assets to Treasury's multisig wallet.\n    /// @dev Function is only available to the AmmGovernanceService, can be executed only by IPOR Protocol Router as internal interaction.\n    /// @param transferredAmount asset amount transferred to Treasury's multisig wallet.\n    function updateStorageWhenTransferToTreasuryInternal(uint256 transferredAmount) external;\n}\n\n/// @title Basic logic related with SOAP indicators\nlibrary SoapIndicatorLogic {\n    using SafeCast for uint256;\n    using InterestRates for uint256;\n\n    /// @notice Calculate the SOAP for pay fixed leg\n    /// @param si SOAP indicators\n    /// @param calculateTimestamp timestamp to calculate the SOAP\n    /// @param ibtPrice IBT price\n    /// @return SOAP for pay fixed leg\n    function calculateSoapPayFixed(\n        AmmStorageTypes.SoapIndicators memory si,\n        uint256 calculateTimestamp,\n        uint256 ibtPrice\n    ) internal pure returns (int256) {\n        return\n            IporMath.division(si.totalIbtQuantity * ibtPrice, 1e18).toInt256() -\n            (si.totalNotional + calculateHyphoteticalInterestTotal(si, calculateTimestamp)).toInt256();\n    }\n\n    /// @notice Calculate the SOAP for receive fixed leg\n    /// @param si SOAP indicators\n    /// @param calculateTimestamp timestamp to calculate the SOAP\n    /// @param ibtPrice IBT price\n    /// @return SOAP for receive fixed leg\n    function calculateSoapReceiveFixed(\n        AmmStorageTypes.SoapIndicators memory si,\n        uint256 calculateTimestamp,\n        uint256 ibtPrice\n    ) internal pure returns (int256) {\n        return\n            (si.totalNotional + calculateHyphoteticalInterestTotal(si, calculateTimestamp)).toInt256() -\n            IporMath.division(si.totalIbtQuantity * ibtPrice, 1e18).toInt256();\n    }\n\n    /// @notice Calculate hypothetical interest total, value that is used to calculate the SOAP\n    /// @param si SOAP indicators\n    /// @param calculateTimestamp timestamp to calculate the value\n    /// @return hypothetical interest total\n    function calculateHyphoteticalInterestTotal(\n        AmmStorageTypes.SoapIndicators memory si,\n        uint256 calculateTimestamp\n    ) internal pure returns (uint256) {\n        return\n            si.hypotheticalInterestCumulative +\n            calculateHypotheticalInterestDelta(\n                calculateTimestamp,\n                si.rebalanceTimestamp,\n                si.totalNotional + si.hypotheticalInterestCumulative,\n                si.averageInterestRate\n            );\n    }\n\n    /// @notice Calculate hypothetical interest delta, value that is used to calculate the SOAP\n    /// @param calculateTimestamp timestamp to calculate the value\n    /// @param lastRebalanceTimestamp last rebalance timestamp\n    /// @param totalNotional total notional\n    /// @param averageInterestRate average interest rate\n    /// @return hypothetical interest delta\n    function calculateHypotheticalInterestDelta(\n        uint256 calculateTimestamp,\n        uint256 lastRebalanceTimestamp,\n        uint256 totalNotional,\n        uint256 averageInterestRate\n    ) internal pure returns (uint256) {\n        require(\n            calculateTimestamp >= lastRebalanceTimestamp,\n            AmmErrors.CALC_TIMESTAMP_LOWER_THAN_SOAP_REBALANCE_TIMESTAMP\n        );\n        return\n            totalNotional.calculateContinuousCompoundInterestUsingRatePeriodMultiplication(\n                averageInterestRate * (calculateTimestamp - lastRebalanceTimestamp)\n            );\n    }\n}\n\n/// @title AMM basic logic library\nlibrary AmmLib {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SoapIndicatorLogic for AmmStorageTypes.SoapIndicators;\n\n    /// @notice Gets AMM exchange rate\n    /// @param model AMM model skeleton of the pool\n    /// @return AMM exchange rate\n    function getExchangeRate(AmmTypes.AmmPoolCoreModel memory model) internal view returns (uint256) {\n        return getExchangeRate(model, getAccruedBalance(model).liquidityPool);\n    }\n\n    /// @notice Gets AMM exchange rate\n    /// @param model AMM model skeleton of the pool\n    /// @param liquidityPoolBalance liquidity pool balance\n    /// @return AMM exchange rate\n    /// @dev For gas optimization with additional param liquidityPoolBalance with already calculated value\n    function getExchangeRate(\n        AmmTypes.AmmPoolCoreModel memory model,\n        uint256 liquidityPoolBalance\n    ) internal view returns (uint256) {\n        (, , int256 soap) = getSoap(model);\n\n        int256 balance = liquidityPoolBalance.toInt256() - soap;\n        require(balance >= 0, AmmErrors.SOAP_AND_LP_BALANCE_SUM_IS_TOO_LOW);\n\n        uint256 ipTokenTotalSupply = IIpToken(model.ipToken).totalSupply();\n\n        if (ipTokenTotalSupply > 0) {\n            return IporMath.division(balance.toUint256() * 1e18, ipTokenTotalSupply);\n        } else {\n            return 1e18;\n        }\n    }\n\n    /// @notice Gets AMM SOAP Sum Of All Payouts\n    /// @param model AMM model skeleton of the pool\n    /// @return soapPayFixed SOAP Pay Fixed\n    /// @return soapReceiveFixed SOAP Receive Fixed\n    /// @return soap SOAP Sum Of All Payouts\n    function getSoap(\n        AmmTypes.AmmPoolCoreModel memory model\n    ) internal view returns (int256 soapPayFixed, int256 soapReceiveFixed, int256 soap) {\n        uint256 timestamp = block.timestamp;\n        (\n            AmmStorageTypes.SoapIndicators memory indicatorsPayFixed,\n            AmmStorageTypes.SoapIndicators memory indicatorsReceiveFixed\n        ) = IAmmStorage(model.ammStorage).getSoapIndicators();\n\n        uint256 ibtPrice = IIporOracle(model.iporOracle).calculateAccruedIbtPrice(model.asset, timestamp);\n        soapPayFixed = indicatorsPayFixed.calculateSoapPayFixed(timestamp, ibtPrice);\n        soapReceiveFixed = indicatorsReceiveFixed.calculateSoapReceiveFixed(timestamp, ibtPrice);\n        soap = soapPayFixed + soapReceiveFixed;\n    }\n\n    /// @notice Gets accrued balance of the pool\n    /// @param model AMM model skeleton of the pool\n    /// @return accrued balance of the pool\n    /// @dev balance takes into consideration asset management vault balance and their accrued interest\n    function getAccruedBalance(\n        AmmTypes.AmmPoolCoreModel memory model\n    ) internal view returns (IporTypes.AmmBalancesMemory memory) {\n        require(model.ammTreasury != address(0), string.concat(IporErrors.WRONG_ADDRESS, \" ammTreasury\"));\n        IporTypes.AmmBalancesMemory memory accruedBalance = IAmmStorage(model.ammStorage).getBalance();\n\n        uint256 actualVaultBalance = IAssetManagement(model.assetManagement).totalBalance();\n        int256 liquidityPool = accruedBalance.liquidityPool.toInt256() +\n            actualVaultBalance.toInt256() -\n            accruedBalance.vault.toInt256();\n\n        require(liquidityPool >= 0, AmmErrors.LIQUIDITY_POOL_AMOUNT_TOO_LOW);\n        accruedBalance.liquidityPool = liquidityPool.toUint256();\n        accruedBalance.vault = actualVaultBalance;\n        return accruedBalance;\n    }\n}\n\n/// @dev It is not recommended to use lens contract directly, should be used only through IporProtocolRouter.\ncontract AmmPoolsLensWeEth is IAmmPoolsLensWeEth {\n    using IporContractValidator for address;\n    using AmmLib for AmmTypes.AmmPoolCoreModel;\n\n    address public immutable weEth;\n    address public immutable ipWeEth;\n    address public immutable ammTreasuryWeEth;\n    address public immutable ammStorageWeEth;\n    address public immutable iporOracle;\n\n    constructor(\n        address weEthInput,\n        address ipWeEthInput,\n        address ammTreasuryWeEthInput,\n        address ammStorageWeEthInput,\n        address iporOracleInput\n    ) {\n        weEth = weEthInput.checkAddress();\n        ipWeEth = ipWeEthInput.checkAddress();\n        ammTreasuryWeEth = ammTreasuryWeEthInput.checkAddress();\n        ammStorageWeEth = ammStorageWeEthInput.checkAddress();\n        iporOracle = iporOracleInput.checkAddress();\n    }\n\n    function getIpWeEthExchangeRate() external view returns (uint256) {\n        AmmTypes.AmmPoolCoreModel memory model = AmmTypes.AmmPoolCoreModel({\n            asset: weEth,\n            assetDecimals: 18,\n            ipToken: ipWeEth,\n            ammStorage: ammStorageWeEth,\n            ammTreasury: ammTreasuryWeEth,\n            assetManagement: address(0),\n            iporOracle: iporOracle\n        });\n        uint256 liquidityPoolBalance = IAmmTreasuryBaseV1(ammTreasuryWeEth).getLiquidityPoolBalance();\n        return model.getExchangeRate(liquidityPoolBalance);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"weEthInput\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ipWeEthInput\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammTreasuryWeEthInput\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammStorageWeEthInput\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"iporOracleInput\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ammStorageWeEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ammTreasuryWeEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIpWeEthExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ipWeEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iporOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AmmPoolsLensWeEth", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000cd5fe23c85820f7b72d0926fc9b05b43e359b7ee000000000000000000000000ac5b04988bc71bee96f8d93040777db3ef166125000000000000000000000000cc2ff2d38666723ea56c122097f6215b90d7419600000000000000000000000077fe3a8e8d1d73df54ca07674bf1bd6c5841e3b5000000000000000000000000421c69eaa54646294db30026aee80d01988a6876", "EVMVersion": "shanghai", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": ""}