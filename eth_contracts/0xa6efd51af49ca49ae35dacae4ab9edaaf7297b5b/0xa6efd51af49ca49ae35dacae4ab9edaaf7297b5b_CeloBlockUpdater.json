{"SourceCode": "// Sources flattened with hardhat v2.22.0 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: AML AND MIT\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol@v4.9.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.9.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.9.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol@v4.9.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n\r\n// File contracts/block/celo/CeloVerifier.sol\r\n\r\n// Original license: SPDX_License_Identifier: AML\r\n//\r\n// Copyright 2017 Christian Reitwiessner\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to\r\n// deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n// sell copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n// IN THE SOFTWARE.\r\n\r\n// 2019 OKIMS\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Pairing {\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct G1Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n\r\n    // Encoding of field elements is: X[0] * z + X[1]\r\n    struct G2Point {\r\n        uint256[2] X;\r\n        uint256[2] Y;\r\n    }\r\n\r\n    /*\r\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\r\n     */\r\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\r\n        // The prime q in the base field F_q for G1\r\n        if (p.X == 0 && p.Y == 0) {\r\n            return G1Point(0, 0);\r\n        } else {\r\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @return The sum of two points of G1\r\n     */\r\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success\r\n            case 0 {\r\n                invalid()\r\n            }\r\n        }\r\n\r\n        require(success, \"pairing-add-failed\");\r\n    }\r\n\r\n    /*\r\n     * @return The product of a point on G1 and a scalar, i.e.\r\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\r\n     *         points p.\r\n     */\r\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success\r\n            case 0 {\r\n                invalid()\r\n            }\r\n        }\r\n        require(success, \"pairing-mul-failed\");\r\n    }\r\n\r\n    /* @return The result of computing the pairing check\r\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\r\n     *         For example,\r\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\r\n     */\r\n    function pairing(\r\n        G1Point memory a1,\r\n        G2Point memory a2,\r\n        G1Point memory b1,\r\n        G2Point memory b2,\r\n        G1Point memory c1,\r\n        G2Point memory c2,\r\n        G1Point memory d1,\r\n        G2Point memory d2\r\n    ) internal view returns (bool) {\r\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\r\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\r\n        uint256 inputSize = 24;\r\n        uint256[] memory input = new uint256[](inputSize);\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 j = i * 6;\r\n            input[j + 0] = p1[i].X;\r\n            input[j + 1] = p1[i].Y;\r\n            input[j + 2] = p2[i].X[0];\r\n            input[j + 3] = p2[i].X[1];\r\n            input[j + 4] = p2[i].Y[0];\r\n            input[j + 5] = p2[i].Y[1];\r\n        }\r\n\r\n        uint256[1] memory out;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success\r\n            case 0 {\r\n                invalid()\r\n            }\r\n        }\r\n\r\n        require(success, \"pairing-opcode-failed\");\r\n\r\n        return out[0] != 0;\r\n    }\r\n}\r\n\r\ncontract CeloVerifier {\r\n    using Pairing for *;\r\n\r\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct VerifyingKey {\r\n        Pairing.G1Point alfa1;\r\n        Pairing.G2Point beta2;\r\n        Pairing.G2Point gamma2;\r\n        Pairing.G2Point delta2;\r\n        Pairing.G1Point[2] IC;\r\n    }\r\n\r\n    struct Proof {\r\n        Pairing.G1Point A;\r\n        Pairing.G2Point B;\r\n        Pairing.G1Point C;\r\n    }\r\n\r\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\r\n        vk.alfa1 = Pairing.G1Point(\r\n            uint256(8670602023544135918920748683086155953571783330717691938066332422925923906783),\r\n            uint256(7756274098553970965095809733841851252441441266386459603998307767419443293278)\r\n        );\r\n        vk.beta2 = Pairing.G2Point(\r\n            [\r\n                uint256(16130188479334235147497606212216761393852555096690128287292333557465633667217),\r\n                uint256(2714796124216245424279806293028042480167182265452659602073998940445537349363)\r\n            ],\r\n            [\r\n                uint256(15633668108651818271962595318384055417384787797924873291759104079741162656478),\r\n                uint256(15909361217857119522696669439623235114077424130686289611288466007781197872698)\r\n            ]\r\n        );\r\n        vk.gamma2 = Pairing.G2Point(\r\n            [\r\n                uint256(364335034220074446208557989017478148606089486411019431445628564568077677593),\r\n                uint256(12333224946111547221065579521616839086079818863975782718425907412600433284856)\r\n            ],\r\n            [\r\n                uint256(18450742147687701552799809738650889640447511527735006704049116274075815614083),\r\n                uint256(20759328800310466802417535567044499802574868318897430174261077065734702971516)\r\n            ]\r\n        );\r\n        vk.delta2 = Pairing.G2Point(\r\n            [\r\n                uint256(1347288778500277163149671841576921775605326843905070364039824975899177311406),\r\n                uint256(17039965339387879411440382568029511406756095203062068287294368715052883153053)\r\n            ],\r\n            [\r\n                uint256(4623609318960856493950501799196769901793313186187194383299734838672853381016),\r\n                uint256(5705362505223347990175626935934411215580221175200735840583813177850048892598)\r\n            ]\r\n        );\r\n        vk.IC[0] = Pairing.G1Point(\r\n            uint256(18364353533181305313816519457704998570719932598244244981001252573874061212224),\r\n            uint256(665986571482040251699929900245029727540415994637579772250515006519703779373)\r\n        );\r\n        vk.IC[1] = Pairing.G1Point(\r\n            uint256(1255770839189555614835783801843475600645818351909679549305856203706646911428),\r\n            uint256(5102377551556747798676667750771921373965421906250162398720477416134099553118)\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @returns Whether the proof is valid given the hardcoded verifying key\r\n     *          above and the public inputs\r\n     */\r\n    function verifyProof(\r\n        uint256[2] memory a,\r\n        uint256[2][2] memory b,\r\n        uint256[2] memory c,\r\n        uint256[1] memory input\r\n    ) public view returns (bool r) {\r\n        Proof memory proof;\r\n        proof.A = Pairing.G1Point(a[0], a[1]);\r\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\r\n        proof.C = Pairing.G1Point(c[0], c[1]);\r\n\r\n        VerifyingKey memory vk = verifyingKey();\r\n\r\n        // Compute the linear combination vk_x\r\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\r\n\r\n        // Make sure that proof.A, B, and C are each less than the prime q\r\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\r\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\r\n\r\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\r\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\r\n\r\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\r\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\r\n\r\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\r\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\r\n\r\n        // Make sure that every input is less than the snark scalar field\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\r\n            vk_x = Pairing.plus(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));\r\n        }\r\n\r\n        vk_x = Pairing.plus(vk_x, vk.IC[0]);\r\n\r\n        return\r\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interface/IBlockUpdater.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBlockUpdater {\r\n    event ImportBlock(uint256 identifier, bytes32 blockHash, bytes32 receiptHash);\r\n\r\n    function importBlock(bytes calldata _proof) external;\r\n\r\n    function checkBlock(bytes32 _blockHash, bytes32 _receiptsRoot) external view returns (bool);\r\n\r\n    function checkBlockConfirmation(bytes32 _blockHash, bytes32 _receiptsRoot) external view returns (bool, uint256);\r\n}\r\n\r\n\r\n// File contracts/block/celo/CeloBlockUpdater.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\n\r\n\r\n\r\ncontract CeloBlockUpdater is IBlockUpdater, Initializable, OwnableUpgradeable, CeloVerifier {\r\n    event ImportValidator(uint256 indexed epoch, uint256 indexed blockNumber, bytes32 blockHash, bytes32 receiptHash);\r\n    event ModBlockConfirmation(uint256 oldBlockConfirmation, uint256 newBlockConfirmation);\r\n\r\n    struct ParsedInput {\r\n        uint256 blockNumber;\r\n        uint256 blockConfirmation;\r\n        bytes32 blockHash;\r\n        bytes32 receiptHash;\r\n        bytes32 signingValidatorSetHash;\r\n        bytes32 nextValidatorSetHash;\r\n    }\r\n\r\n    struct ZkProof {\r\n        uint256[2] a;\r\n        uint256[2][2] b;\r\n        uint256[2] c;\r\n        uint256[8] inputs;\r\n    }\r\n\r\n    uint256 public currentEpoch;\r\n\r\n    uint256 public minBlockConfirmation;\r\n\r\n    // epoch=>validatorHash\r\n    mapping(uint256 => bytes32) public validatorHashes;\r\n\r\n    // blockHash=>receiptsRoot =>BlockConfirmation\r\n    mapping(bytes32 => mapping(bytes32 => uint256)) public blockInfos;\r\n\r\n    function initialize(\r\n        uint256 _epoch,\r\n        bytes32 _epochValidatorSetHash,\r\n        uint256 _minBlockConfirmation) public initializer {\r\n        __Ownable_init();\r\n        validatorHashes[_epoch] = _epochValidatorSetHash;\r\n        minBlockConfirmation = _minBlockConfirmation;\r\n        currentEpoch = _epoch;\r\n    }\r\n\r\n    function importNextValidatorSet(bytes calldata _proof) external {\r\n        _importNextValidatorSet(_proof);\r\n    }\r\n\r\n    function BatchImportNextValidatorSet(bytes[] calldata _proof) external {\r\n        for (uint256 i = 0; i < _proof.length; i++) {\r\n            _importNextValidatorSet(_proof[i]);\r\n        }\r\n    }\r\n\r\n    function importBlock(bytes calldata _proof) external {\r\n        _importBlock(_proof);\r\n    }\r\n\r\n    function BatchImportBlock(bytes[] calldata _proof) external {\r\n        for (uint256 i = 0; i < _proof.length; i++) {\r\n            _importBlock(_proof[i]);\r\n        }\r\n    }\r\n\r\n    function checkBlock(bytes32 _blockHash, bytes32 _receiptHash) external view returns (bool) {\r\n        (bool exist,) = _checkBlock(_blockHash, _receiptHash);\r\n        return exist;\r\n    }\r\n\r\n    function checkBlockConfirmation(bytes32 _blockHash, bytes32 _receiptHash) external view returns (bool, uint256) {\r\n        (bool exist,uint256 blockConfirmation) = _checkBlock(_blockHash, _receiptHash);\r\n        return (exist, blockConfirmation);\r\n    }\r\n\r\n    function _checkBlock(bytes32 _blockHash, bytes32 _receiptHash) internal view returns (bool, uint256) {\r\n        uint256 blockConfirmation = blockInfos[_blockHash][_receiptHash];\r\n        if (blockConfirmation > 0) {\r\n            return (true, blockConfirmation);\r\n        }\r\n        return (false, blockConfirmation);\r\n    }\r\n\r\n\r\n    function _importNextValidatorSet(bytes memory _proof) internal {\r\n        ZkProof memory proofData;\r\n        (proofData.a, proofData.b, proofData.c, proofData.inputs) = abi.decode(_proof, (uint256[2], uint256[2][2], uint256[2], uint256[8]));\r\n        ParsedInput memory parsedInput = _parseInput(proofData.inputs);\r\n        uint256 epoch = _computeEpoch(parsedInput.blockNumber);\r\n        uint256 nextEpoch = epoch + 1;\r\n        require(parsedInput.nextValidatorSetHash != bytes32(0), \"invalid nextValidatorSetHash\");\r\n        require(parsedInput.signingValidatorSetHash != bytes32(0), \"invalid signingValidatorSetHash\");\r\n        require(parsedInput.blockConfirmation >= minBlockConfirmation, \"Not enough block confirmations\");\r\n        require(validatorHashes[epoch] != bytes32(0), \"epoch no upload\");\r\n        require(validatorHashes[nextEpoch] == bytes32(0), \"epoch already exist\");\r\n        uint256[1] memory compressInput;\r\n        compressInput[0] = _hashInput(proofData.inputs);\r\n        require(verifyProof(proofData.a, proofData.b, proofData.c, compressInput), \"invalid proof\");\r\n        validatorHashes[nextEpoch] = parsedInput.nextValidatorSetHash;\r\n        currentEpoch = nextEpoch;\r\n        blockInfos[parsedInput.blockHash][parsedInput.receiptHash] = parsedInput.blockConfirmation;\r\n        emit ImportValidator(nextEpoch, parsedInput.blockNumber, parsedInput.blockHash, parsedInput.receiptHash);\r\n    }\r\n\r\n    function _importBlock(bytes memory _proof) internal {\r\n        ZkProof memory proofData;\r\n        (proofData.a, proofData.b, proofData.c, proofData.inputs) = abi.decode(_proof, (uint256[2], uint256[2][2], uint256[2], uint256[8]));\r\n        ParsedInput memory parsedInput = _parseInput(proofData.inputs);\r\n\r\n        require(parsedInput.blockConfirmation >= minBlockConfirmation, \"Not enough block confirmations\");\r\n        (bool exist,uint256 blockConfirmation) = _checkBlock(parsedInput.blockHash, parsedInput.receiptHash);\r\n        if (exist && parsedInput.blockConfirmation <= blockConfirmation) {\r\n            revert(\"already exist\");\r\n        }\r\n        uint256 epoch = _computeEpoch(parsedInput.blockNumber);\r\n        require(validatorHashes[epoch] == parsedInput.signingValidatorSetHash, \"epoch no upload\");\r\n\r\n        uint256[1] memory compressInput;\r\n        compressInput[0] = _hashInput(proofData.inputs);\r\n        require(verifyProof(proofData.a, proofData.b, proofData.c, compressInput), \"invalid proof\");\r\n        blockInfos[parsedInput.blockHash][parsedInput.receiptHash] = parsedInput.blockConfirmation;\r\n        emit ImportBlock(parsedInput.blockNumber, parsedInput.blockHash, parsedInput.receiptHash);\r\n    }\r\n\r\n    function _parseInput(uint256[8] memory _inputs) internal pure returns (ParsedInput memory)    {\r\n        ParsedInput memory result;\r\n        result.blockNumber = _inputs[0];\r\n        result.blockHash = bytes32((_inputs[2] << 128) | _inputs[1]);\r\n        result.receiptHash = bytes32((_inputs[4] << 128) | _inputs[3]);\r\n        result.signingValidatorSetHash = bytes32(_inputs[5]);\r\n        result.nextValidatorSetHash = bytes32(_inputs[6]);\r\n        result.blockConfirmation = _inputs[7];\r\n        return result;\r\n    }\r\n\r\n    function _hashInput(uint256[8] memory _inputs) internal pure returns (uint256) {\r\n        uint256 computedHash = uint256(keccak256(abi.encodePacked(_inputs[0], _inputs[1], _inputs[2],\r\n            _inputs[3], _inputs[4], _inputs[5], _inputs[6], _inputs[7])));\r\n        return computedHash / 256;\r\n    }\r\n\r\n    function _computeEpoch(uint256 blockNumber) internal pure returns (uint256) {\r\n        return (blockNumber + 17280 - 1) / 17280;\r\n    }\r\n\r\n    //----------------------------------------------------------------------------------\r\n    // onlyOwner\r\n    function setBlockConfirmation(uint256 _minBlockConfirmation) external onlyOwner {\r\n        emit ModBlockConfirmation(minBlockConfirmation, _minBlockConfirmation);\r\n        minBlockConfirmation = _minBlockConfirmation;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"receiptHash\",\"type\":\"bytes32\"}],\"name\":\"ImportBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"receiptHash\",\"type\":\"bytes32\"}],\"name\":\"ImportValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBlockConfirmation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBlockConfirmation\",\"type\":\"uint256\"}],\"name\":\"ModBlockConfirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_proof\",\"type\":\"bytes[]\"}],\"name\":\"BatchImportBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_proof\",\"type\":\"bytes[]\"}],\"name\":\"BatchImportNextValidatorSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"blockInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_receiptHash\",\"type\":\"bytes32\"}],\"name\":\"checkBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_receiptHash\",\"type\":\"bytes32\"}],\"name\":\"checkBlockConfirmation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"importBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"importNextValidatorSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_epochValidatorSetHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_minBlockConfirmation\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBlockConfirmation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBlockConfirmation\",\"type\":\"uint256\"}],\"name\":\"setBlockConfirmation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[1]\",\"name\":\"input\",\"type\":\"uint256[1]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CeloBlockUpdater", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://edc9637826058f88fd6a491339b6f0426cd8aaa6931ed5eb8f6423d2f5066973"}