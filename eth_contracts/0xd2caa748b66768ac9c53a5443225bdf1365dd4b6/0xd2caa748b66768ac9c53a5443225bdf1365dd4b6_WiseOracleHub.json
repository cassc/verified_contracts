{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/WiseOracleHub/WiseOracleHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\n/**\\n * @author Christoph Krpoun\\n * @author Ren\u00e9 Hochmuth\\n * @author Vitally Marinchenko\\n */\\n\\nimport \\\"./OracleHelper.sol\\\";\\nimport \\\"../OwnableMaster.sol\\\";\\n\\n/**\\n * @dev WiseOracleHub is an onchain extension for price feeds (chainLink or others).\\n * The master address is owned by a timelock contract which itself is secured by a\\n * multisig. Only the master can add new price feed <-> address pairs to the contract.\\n *\\n * One advantage is the linking of price feeds to their underlying token address.\\n * Therefore, users can get the current USD value of a token by just knowing the token\\n * address when calling {latestResolver}. It takes the answer from {latestRoundData}\\n * for chainLink oracles as recommended from chainLink.\\n *\\n * NOTE: If you want to propose adding an own developed price feed it is\\n * mandatory to wrap its answer into a function mimicking {latestRoundData}\\n * (See {latestResolver} implementation).\\n *\\n * Additionally, the oracleHub provides so called heartbeat checks if a token gets\\n * still updated in expected time intervall.\\n *\\n */\\n\\ncontract WiseOracleHub is OracleHelper, OwnableMaster {\\n\\n    constructor()\\n        Declarations()\\n        OwnableMaster(msg.sender)\\n    {}\\n\\n    /**\\n     * @dev Returns USD values decimals\\n     * meaning that 1.00 USD <=> 1E18.\\n     */\\n    function decimalsUSD()\\n        external\\n        pure\\n        returns (uint8)\\n    {\\n        return _decimalsUSD;\\n    }\\n\\n    /**\\n     * @dev Returns priceFeed latest USD value\\n     * by passing the underlying token address.\\n     */\\n    function latestResolver(\\n        address _tokenAddress\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        (\\n                ,\\n                int256 answer,\\n                ,\\n                ,\\n\\n            ) = priceFeed[_tokenAddress].latestRoundData();\\n\\n        return uint256(answer);\\n    }\\n\\n    /**\\n     * @dev Returns priceFeed decimals by\\n     * passing the underlying token address.\\n     */\\n    function decimals(\\n        address _tokenAddress\\n    )\\n        public\\n        view\\n        returns (uint8)\\n    {\\n        return priceFeed[_tokenAddress].decimals();\\n    }\\n\\n    function getTokenDecimals(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (uint8)\\n    {\\n        return _tokenDecimals[_tokenAddress];\\n    }\\n\\n    /**\\n     * @dev Returns USD value of a given token\\n     * amount in order of 1E18 decimal precision.\\n     */\\n    function getTokensInUSD(\\n        address _tokenAddress,\\n        uint256 _amount\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint8 tokenDecimals = _tokenDecimals[\\n            _tokenAddress\\n        ];\\n\\n        return _decimalsUSD < tokenDecimals\\n            ? _amount\\n                * latestResolver(_tokenAddress)\\n                / 10 ** decimals(_tokenAddress)\\n                / 10 ** (tokenDecimals - _decimalsUSD)\\n            : _amount\\n                * 10 ** (_decimalsUSD - tokenDecimals)\\n                * latestResolver(_tokenAddress)\\n                / 10 ** decimals(_tokenAddress);\\n    }\\n\\n    /**\\n     * @dev Converts USD value of a token into token amount with a\\n     * current price. The order of the argument _usdValue is 1E18.\\n     */\\n    function getTokensFromUSD(\\n        address _tokenAddress,\\n        uint256 _usdValue\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint8 tokenDecimals = _tokenDecimals[\\n            _tokenAddress\\n        ];\\n\\n        return _decimalsUSD < tokenDecimals\\n            ? _usdValue\\n                * 10 ** (tokenDecimals - _decimalsUSD)\\n                * 10 ** decimals(_tokenAddress)\\n                / latestResolver(_tokenAddress)\\n            : _usdValue\\n                * 10 ** decimals(_tokenAddress)\\n                / latestResolver(_tokenAddress)\\n                / 10 ** (_decimalsUSD - tokenDecimals);\\n    }\\n\\n    /**\\n     * @dev Adds priceFeed for a token.\\n     * Can't overwrite existing mappings.\\n     * Master is a timelock contract.\\n     */\\n    function addOracle(\\n        address _tokenAddress,\\n        IPriceFeed _priceFeedAddress,\\n        address[] memory _underlyingFeedTokens\\n    )\\n        external\\n        onlyMaster\\n    {\\n        _addOracle(\\n            _tokenAddress,\\n            _priceFeedAddress,\\n            _underlyingFeedTokens\\n        );\\n    }\\n\\n    /**\\n     * @dev Adds priceFeeds for tokens.\\n     * Can't overwrite existing mappings.\\n     * Master is a timelock contract.\\n     */\\n    function addOracleBulk(\\n        address[] memory _tokenAddresses,\\n        IPriceFeed[] memory _priceFeedAddresses,\\n        address[][] memory _underlyingFeedTokens\\n    )\\n        external\\n        onlyMaster\\n    {\\n        for (uint8 i = 0; i < _tokenAddresses.length; ++i) {\\n            _addOracle(\\n                _tokenAddresses[i],\\n                _priceFeedAddresses[i],\\n                _underlyingFeedTokens[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Looks at the maximal last 50 rounds and\\n     * takes second highest value to avoid counting\\n     * offline time of chainlink as valid heartbeat.\\n     */\\n    function recalibratePreview(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _recalibratePreview(\\n            _tokenAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Check if chainLink feed was\\n     * updated within expected timeFrame.\\n     * If length of {underlyingFeedTokens}\\n     * is greater than zero it checks the\\n     * heartbeat of all base feeds of the\\n     * derivate oracle.\\n     */\\n    function chainLinkIsDead(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (bool state)\\n    {\\n        uint256 length = underlyingFeedTokens[_tokenAddress].length;\\n\\n        if (length == 0) {\\n            return _chainLinkIsDead(\\n                _tokenAddress\\n            );\\n        }\\n\\n        for (uint8 i = 0; i < length; ++i) {\\n\\n            state = _chainLinkIsDead(\\n                underlyingFeedTokens[_tokenAddress][i]\\n            );\\n\\n            if (state == true) {\\n                break;\\n            }\\n        }\\n\\n        return state;\\n    }\\n\\n    /**\\n     * @dev Recalibrates expected\\n     * heartbeat for a pricing feed.\\n     */\\n    function recalibrate(\\n        address _tokenAddress\\n    )\\n        external\\n    {\\n        _recalibrate(\\n            _tokenAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Bulk function to recalibrate\\n     * the heartbeat for several tokens.\\n     */\\n    function recalibrateBulk(\\n        address[] memory _tokenAddresses\\n    )\\n        external\\n    {\\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\\n            _recalibrate(\\n                _tokenAddresses[i]\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OwnableMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nerror NotMaster();\\nerror NotProposed();\\n\\ncontract OwnableMaster {\\n\\n    address public master;\\n    address public proposedMaster;\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    modifier onlyProposed() {\\n        _onlyProposed();\\n        _;\\n    }\\n\\n    function _onlyMaster()\\n        private\\n        view\\n    {\\n        if (msg.sender == master) {\\n            return;\\n        }\\n\\n        revert NotMaster();\\n    }\\n\\n    modifier onlyMaster() {\\n        _onlyMaster();\\n        _;\\n    }\\n\\n    function _onlyProposed()\\n        private\\n        view\\n    {\\n        if (msg.sender == proposedMaster) {\\n            return;\\n        }\\n\\n        revert NotProposed();\\n    }\\n\\n    constructor(\\n        address _master\\n    ) {\\n        master = _master;\\n    }\\n\\n    /**\\n     * @dev Allows to propose next master.\\n     * Must be claimed by proposer.\\n     */\\n    function proposeOwner(\\n        address _proposedOwner\\n    )\\n        external\\n        onlyMaster\\n    {\\n        proposedMaster = _proposedOwner;\\n    }\\n\\n    /**\\n     * @dev Allows to claim master role.\\n     * Must be called by proposer.\\n     */\\n    function claimOwnership()\\n        external\\n        onlyProposed\\n    {\\n        master = proposedMaster;\\n    }\\n\\n    /**\\n     * @dev Removes master role.\\n     * No ability to be in control.\\n     */\\n    function renounceOwnership()\\n        external\\n        onlyMaster\\n    {\\n        master = ZERO_ADDRESS;\\n        proposedMaster = ZERO_ADDRESS;\\n    }\\n}\"\r\n    },\r\n    \"contracts/WiseOracleHub/OracleHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./Declarations.sol\\\";\\n\\nabstract contract OracleHelper is Declarations {\\n\\n    /**\\n     * @dev Adds priceFeed for a given token.\\n     */\\n    function _addOracle(\\n        address _tokenAddress,\\n        IPriceFeed _priceFeedAddress,\\n        address[] memory _underlyingFeedTokens\\n    )\\n        internal\\n    {\\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\\n            priceFeed[_tokenAddress] = _priceFeedAddress;\\n\\n            _tokenDecimals[_tokenAddress] = IERC20(\\n                _tokenAddress\\n            ).decimals();\\n\\n            underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\\n\\n            return;\\n        }\\n\\n        revert OracleAlreadySet(\\n            {\\n                feed: priceFeed[_tokenAddress]\\n            }\\n        );\\n    }\\n\\n    /**\\n     * @dev Stores expected heartbeat\\n     * value for a pricing feed token.\\n     */\\n    function _recalibrate(\\n        address _tokenAddress\\n    )\\n        internal\\n    {\\n        heartBeat[_tokenAddress] = _recalibratePreview(\\n            _tokenAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Check if chainLink feed was\\n     * updated within expected timeFrame\\n     * for single {_tokenAddress}.\\n     */\\n    function _chainLinkIsDead(\\n        address _tokenAddress\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        uint256 upd = latestRoundData(\\n            _tokenAddress\\n        );\\n\\n        upd = block.timestamp > upd\\n            ? block.timestamp - upd\\n            : block.timestamp;\\n\\n        return upd > heartBeat[_tokenAddress];\\n    }\\n\\n    /**\\n     * @dev Recalibrates expected\\n     * heartbeat for a pricing feed.\\n     */\\n    function _recalibratePreview(\\n        address _tokenAddress\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint80 latestAggregatorRoundId = _getLatestAggregatorRoundId(\\n            _tokenAddress\\n        );\\n\\n        uint80 iterationCount = _getIterationCount(\\n            latestAggregatorRoundId\\n        );\\n\\n        if (iterationCount < 2) {\\n            revert SampleTooSmall(\\n                {\\n                    size: iterationCount\\n                }\\n            );\\n        }\\n\\n        uint16 phaseId = _getPhaseId(\\n            _tokenAddress\\n        );\\n\\n        uint256 latestTimestamp = _getRoundTimestamp(\\n            _tokenAddress,\\n            phaseId,\\n            latestAggregatorRoundId\\n        );\\n\\n        uint256 currentDiff;\\n        uint256 currentBiggest;\\n        uint256 currentSecondBiggest;\\n\\n        for (uint80 i = 1; i < iterationCount; ++i) {\\n\\n            uint256 currentTimestamp = _getRoundTimestamp(\\n                _tokenAddress,\\n                phaseId,\\n                latestAggregatorRoundId - i\\n            );\\n\\n            currentDiff = latestTimestamp\\n                - currentTimestamp;\\n\\n            latestTimestamp = currentTimestamp;\\n\\n            if (currentDiff >= currentBiggest) {\\n\\n                currentSecondBiggest = currentBiggest;\\n                currentBiggest = currentDiff;\\n\\n            } else if (currentDiff > currentSecondBiggest && currentDiff < currentBiggest) {\\n                currentSecondBiggest = currentDiff;\\n            }\\n        }\\n\\n        return currentSecondBiggest;\\n    }\\n\\n    /**\\n     * @dev Determines number of iterations\\n     * needed during heartbeat recalibration.\\n     */\\n    function _getIterationCount(\\n        uint80 _latestAggregatorRoundId\\n    )\\n        internal\\n        pure\\n        returns (uint80 res)\\n    {\\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\\n            ? _latestAggregatorRoundId\\n            : MAX_ROUND_COUNT;\\n    }\\n\\n    /**\\n     * @dev Fetches timestamp of a byteshifted\\n     * aggregatorRound with specific phaseId.\\n     */\\n    function _getRoundTimestamp(\\n        address _tokenAddress,\\n        uint16 _phaseId,\\n        uint80 _aggregatorRoundId\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        (\\n            ,\\n            ,\\n            ,\\n            uint256 timestamp,\\n        ) = priceFeed[_tokenAddress].getRoundData(\\n                getRoundIdByByteShift(\\n                    _phaseId,\\n                    _aggregatorRoundId\\n                )\\n            );\\n\\n        return timestamp;\\n    }\\n\\n    /**\\n     * @dev Determines info for the heartbeat update\\n     * mechanism for chainlink oracles, roundIds.\\n     */\\n    function _getLatestAggregatorRoundId(\\n        address _tokenAddress\\n    )\\n        internal\\n        view\\n        returns (uint80)\\n    {\\n        (   uint80 roundId,\\n            ,\\n            ,\\n            ,\\n        ) = priceFeed[_tokenAddress].latestRoundData();\\n\\n        return roundId;\\n    }\\n\\n    /**\\n     * @dev Determines info for the heartbeat update\\n     * mechanism for chainlink oracles, shifted roundIds.\\n     */\\n    function getRoundIdByByteShift(\\n        uint16 _phaseId,\\n        uint80 _aggregatorRoundId\\n    )\\n        public\\n        pure\\n        returns (uint80)\\n    {\\n        return uint80(\\n            uint256(_phaseId) << 64 | _aggregatorRoundId\\n        );\\n    }\\n\\n    /**\\n     * @dev Routing phaseId from chainLink.\\n     * Returns phaseId by passing underlying token address.\\n     */\\n    function _getPhaseId(\\n        address _tokenAddress\\n    )\\n        internal\\n        view\\n        returns (uint16)\\n    {\\n        return priceFeed[_tokenAddress].phaseId();\\n    }\\n\\n    /**\\n     * @dev Routing latest round data from chainLink.\\n     * Returns latestRoundData by passing underlying token address.\\n     */\\n    function latestRoundData(\\n        address _tokenAddress\\n    )\\n        public\\n        view\\n        returns (uint256 upd)\\n    {\\n        (   ,\\n            ,\\n            ,\\n            upd\\n            ,\\n        ) = priceFeed[_tokenAddress].latestRoundData();\\n    }\\n}\"\r\n    },\r\n    \"contracts/WiseOracleHub/Declarations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"../InterfaceHub/IERC20.sol\\\";\\nimport \\\"../InterfaceHub/IPriceFeed.sol\\\";\\n\\nerror SampleTooSmall(\\n    uint256 size\\n);\\n\\nerror OracleAlreadySet(\\n    IPriceFeed feed\\n);\\n\\ncontract Declarations {\\n\\n    // -- Constant values --\\n\\n    // Target Decimals of the returned USD values.\\n    uint8 constant _decimalsUSD = 18;\\n\\n    // Number of last rounds which are checked for heartbeat.\\n    uint80 constant MAX_ROUND_COUNT = 50;\\n\\n    // Value address used for empty feed comparison.\\n    IPriceFeed constant ZERO_FEED = IPriceFeed(\\n        address(0x0)\\n    );\\n\\n    // -- Mapping values --\\n\\n    // Stores decimals of specific ERC20 token.\\n    mapping(address => uint8) _tokenDecimals;\\n\\n    // Stores the price feed address from oracle sources.\\n    mapping(address => IPriceFeed) public priceFeed;\\n\\n    // Stores the time between chainLink heartbeats.\\n    mapping(address => uint256) public heartBeat;\\n\\n    // Mapping underlying feed token for multi token derivate oracle\\n    mapping(address => address[]) public underlyingFeedTokens;\\n}\"\r\n    },\r\n    \"contracts/InterfaceHub/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\ninterface IPriceFeed {\\n\\n    function decimals()\\n        external\\n        view\\n        returns (uint8);\\n\\n    function description()\\n        external\\n        view\\n        returns (string memory);\\n\\n    function version()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRoundData(\\n        uint80 _roundId\\n    )\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestAnswer()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function phaseId()\\n        external\\n        view\\n        returns(\\n            uint16 phaseId\\n        );\\n\\n    function aggregator()\\n        external\\n        view\\n        returns (address);\\n}\"\r\n    },\r\n    \"contracts/InterfaceHub/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\ninterface IERC20 {\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(\\n        address _account\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function transfer(\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function decimals()\\n        external\\n        view\\n        returns (uint8);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event  Deposit(\\n        address indexed dst,\\n        uint wad\\n    );\\n\\n    event  Withdrawal(\\n        address indexed src,\\n        uint wad\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotMaster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProposed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"OracleAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"SampleTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"contract IPriceFeed\",\"name\":\"_priceFeedAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_underlyingFeedTokens\",\"type\":\"address[]\"}],\"name\":\"addOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"contract IPriceFeed[]\",\"name\":\"_priceFeedAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_underlyingFeedTokens\",\"type\":\"address[][]\"}],\"name\":\"addOracleBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"chainLinkIsDead\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimalsUSD\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_phaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"_aggregatorRoundId\",\"type\":\"uint80\"}],\"name\":\"getRoundIdByByteShift\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdValue\",\"type\":\"uint256\"}],\"name\":\"getTokensFromUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getTokensInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"heartBeat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"latestResolver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"upd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"recalibrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"recalibrateBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"recalibratePreview\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"underlyingFeedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WiseOracleHub", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}