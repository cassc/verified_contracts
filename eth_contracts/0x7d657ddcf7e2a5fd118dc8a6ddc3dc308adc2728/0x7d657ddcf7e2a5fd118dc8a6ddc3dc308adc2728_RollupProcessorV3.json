{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/processors/RollupProcessorV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec.\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport {IVerifier} from \\\"../interfaces/IVerifier.sol\\\";\\nimport {IRollupProcessorV2, IRollupProcessor} from \\\"rollup-encoder/interfaces/IRollupProcessorV2.sol\\\";\\nimport {IDefiBridge} from \\\"../interfaces/IDefiBridge.sol\\\";\\n\\nimport {Decoder} from \\\"../Decoder.sol\\\";\\nimport {AztecTypes} from \\\"rollup-encoder/libraries/AztecTypes.sol\\\";\\n\\nimport {TokenTransfers} from \\\"../libraries/TokenTransfers.sol\\\";\\nimport {RollupProcessorLibrary} from \\\"rollup-encoder/libraries/RollupProcessorLibrary.sol\\\";\\nimport {SafeCast} from \\\"../libraries/SafeCast.sol\\\";\\n\\n/**\\n * @title Rollup Processor\\n * @dev Smart contract responsible for processing Aztec zkRollups, relaying them to a verifier\\n *      contract for validation and performing all the relevant ERC20 token transfers\\n */\\ncontract RollupProcessorV3 is IRollupProcessorV2, Decoder, Initializable, AccessControl {\\n    using SafeCast for uint256;\\n    /*----------------------------------------\\n      ERROR TAGS\\n      ----------------------------------------*/\\n\\n    error PAUSED();\\n    error NOT_PAUSED();\\n    error LOCKED_NO_REENTER();\\n    error INVALID_PROVIDER();\\n    error THIRD_PARTY_CONTRACTS_FLAG_NOT_SET();\\n    error INSUFFICIENT_DEPOSIT();\\n    error INVALID_ADDRESS_NO_CODE();\\n    error INVALID_ASSET_GAS();\\n    error INVALID_ASSET_ID();\\n    error INVALID_ASSET_ADDRESS();\\n    error INVALID_BRIDGE_GAS();\\n    error INVALID_BRIDGE_CALL_DATA();\\n    error INVALID_BRIDGE_ADDRESS();\\n    error INVALID_ESCAPE_BOUNDS();\\n    error INCONSISTENT_BRIDGE_CALL_DATA();\\n    error BRIDGE_WITH_IDENTICAL_INPUT_ASSETS(uint256 inputAssetId);\\n    error BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS(uint256 outputAssetId);\\n    error ZERO_TOTAL_INPUT_VALUE();\\n    error ARRAY_OVERFLOW();\\n    error MSG_VALUE_WRONG_AMOUNT();\\n    error INSUFFICIENT_ETH_PAYMENT();\\n    error WITHDRAW_TO_ZERO_ADDRESS();\\n    error DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE();\\n    error INSUFFICIENT_TOKEN_APPROVAL();\\n    error NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET(uint256 outputValue);\\n    error INCORRECT_STATE_HASH(bytes32 oldStateHash, bytes32 newStateHash);\\n    error INCORRECT_DATA_START_INDEX(uint256 providedIndex, uint256 expectedIndex);\\n    error INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH(\\n        bytes32 providedDefiInteractionHash, bytes32 expectedDefiInteractionHash\\n    );\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n    error PROOF_VERIFICATION_FAILED();\\n    error PENDING_CAP_SURPASSED();\\n    error DAILY_CAP_SURPASSED();\\n\\n    /*----------------------------------------\\n      EVENTS\\n      ----------------------------------------*/\\n    event OffchainData(uint256 indexed rollupId, uint256 chunk, uint256 totalChunks, address sender);\\n    event RollupProcessed(uint256 indexed rollupId, bytes32[] nextExpectedDefiHashes, address sender);\\n    event DefiBridgeProcessed(\\n        uint256 indexed encodedBridgeCallData,\\n        uint256 indexed nonce,\\n        uint256 totalInputValue,\\n        uint256 totalOutputValueA,\\n        uint256 totalOutputValueB,\\n        bool result,\\n        bytes errorReason\\n    );\\n    event AsyncDefiBridgeProcessed(\\n        uint256 indexed encodedBridgeCallData, uint256 indexed nonce, uint256 totalInputValue\\n    );\\n    event Deposit(uint256 indexed assetId, address indexed depositorAddress, uint256 depositValue);\\n    event AssetAdded(uint256 indexed assetId, address indexed assetAddress, uint256 assetGasLimit);\\n    event BridgeAdded(uint256 indexed bridgeAddressId, address indexed bridgeAddress, uint256 bridgeGasLimit);\\n    event RollupProviderUpdated(address indexed providerAddress, bool valid);\\n    event VerifierUpdated(address indexed verifierAddress);\\n    event AllowThirdPartyContractsUpdated(bool allowed);\\n    event DefiBridgeProxyUpdated(address defiBridgeProxy);\\n    event Paused(address account);\\n    event Unpaused(address account);\\n    event DelayBeforeEscapeHatchUpdated(uint32 delay);\\n    event AssetCapUpdated(uint256 assetId, uint256 pendingCap, uint256 dailyCap);\\n    event CappedUpdated(bool isCapped);\\n\\n    /*----------------------------------------\\n      STRUCTS\\n      ----------------------------------------*/\\n\\n    // @dev ALLOW_ASYNC_REENTER lock is present to allow calling of `processAsyncDefiInteraction(...)` from within\\n    //      bridge's `convert(...)` method.\\n    enum Lock {\\n        UNLOCKED,\\n        ALLOW_ASYNC_REENTER,\\n        LOCKED\\n    }\\n\\n    /**\\n     * @dev RollupState struct contains the following data:\\n     *\\n     * | bit offset   | num bits    | description |\\n     * | ---          | ---         | ---         |\\n     * | 0            | 160         | PLONK verifier contract address |\\n     * | 160          | 32          | datasize: number of filled entries in note tree |\\n     * | 192          | 16          | asyncDefiInteractionHashes.length : number of entries in asyncDefiInteractionHashes array |\\n     * | 208          | 16          | defiInteractionHashes.length : number of entries in defiInteractionHashes array |\\n     * | 224          | 8           | Lock enum used to guard against reentrancy attacks (minimum value to store in is uint8)\\n     * |\u00a0232          | 8           | pause flag, true if contract is paused, false otherwise\\n     * | 240          | 8           | capped flag, true if assets should check cap, false otherwise\\n     *\\n     * Note: (RollupState struct gets packed to 1 storage slot -> bit offset signifies location withing the 256 bit string)\\n     */\\n    struct RollupState {\\n        IVerifier verifier;\\n        uint32 datasize;\\n        uint16 numAsyncDefiInteractionHashes;\\n        uint16 numDefiInteractionHashes;\\n        Lock lock;\\n        bool paused;\\n        bool capped;\\n    }\\n\\n    /**\\n     * @dev Contains information that describes a specific call to a bridge\\n     */\\n    struct FullBridgeCallData {\\n        uint256 bridgeAddressId;\\n        address bridgeAddress;\\n        uint256 inputAssetIdA;\\n        uint256 inputAssetIdB;\\n        uint256 outputAssetIdA;\\n        uint256 outputAssetIdB;\\n        uint256 auxData;\\n        bool firstInputVirtual;\\n        bool secondInputVirtual;\\n        bool firstOutputVirtual;\\n        bool secondOutputVirtual;\\n        bool secondInputInUse;\\n        bool secondOutputInUse;\\n        uint256 bridgeGasLimit;\\n    }\\n\\n    /**\\n     * @dev Represents an asynchronous DeFi bridge interaction that has not been resolved\\n     * @param encodedBridgeCallData bit-string encoded bridge call data\\n     * @param totalInputValue number of tokens/wei sent to the bridge\\n     */\\n    struct PendingDefiBridgeInteraction {\\n        uint256 encodedBridgeCallData;\\n        uint256 totalInputValue;\\n    }\\n\\n    /**\\n     * @dev Container for the results of a DeFi interaction\\n     * @param outputValueA amount of output asset A returned from the interaction\\n     * @param outputValueB amount of output asset B returned from the interaction (0 if asset B unused)\\n     * @param isAsync true if the interaction is asynchronous, false otherwise\\n     * @param success true if the call succeeded, false otherwise\\n     */\\n    struct BridgeResult {\\n        uint256 outputValueA;\\n        uint256 outputValueB;\\n        bool isAsync;\\n        bool success;\\n    }\\n\\n    /**\\n     * @dev Container for the inputs of a DeFi interaction\\n     * @param totalInputValue number of tokens/wei sent to the bridge\\n     * @param interactionNonce the unique id of the interaction\\n     * @param auxData additional input specific to the type of interaction\\n     */\\n    struct InteractionInputs {\\n        uint256 totalInputValue;\\n        uint256 interactionNonce;\\n        uint64 auxData;\\n    }\\n\\n    /**\\n     * @dev Container for asset cap restrictions\\n     * @dev Caps used to limit usefulness of using Aztec to \\\"wash\\\" larger hacks\\n     * @param available The amount of tokens that can be deposited, bounded by `dailyCap * 10 ** decimals`.\\n     * @param lastUpdatedTimestamp The timestamp of the last deposit with caps activated\\n     * @param pendingCap The cap for each individual pending deposit measured in whole tokens\\n     * @param dailyCap The cap for total amount that can be added to `available` in 24 hours, measured in whole tokens\\n     * @param precision The number of decimals in the precision for specific asset.\\n     */\\n    struct AssetCap {\\n        uint128 available;\\n        uint32 lastUpdatedTimestamp;\\n        uint32 pendingCap;\\n        uint32 dailyCap;\\n        uint8 precision;\\n    }\\n\\n    /*----------------------------------------\\n      FUNCTION SELECTORS (PRECOMPUTED)\\n      ----------------------------------------*/\\n    // DEFI_BRIDGE_PROXY_CONVERT_SELECTOR = function signature of:\\n    //   function convert(\\n    //       address,\\n    //       AztecTypes.AztecAsset memory inputAssetA,\\n    //       AztecTypes.AztecAsset memory inputAssetB,\\n    //       AztecTypes.AztecAsset memory outputAssetA,\\n    //       AztecTypes.AztecAsset memory outputAssetB,\\n    //       uint256 totalInputValue,\\n    //       uint256 interactionNonce,\\n    //       uint256 auxData,\\n    //       uint256 ethPaymentsSlot\\n    //       address rollupBeneficary)\\n    // N.B. this is the selector of the 'convert' function of the DefiBridgeProxy contract.\\n    //      This has a different interface to the IDefiBridge.convert function\\n    bytes4 private constant DEFI_BRIDGE_PROXY_CONVERT_SELECTOR = 0x4bd947a8;\\n\\n    bytes4 private constant INVALID_ADDRESS_NO_CODE_SELECTOR = 0x21409272; // bytes4(keccak256('INVALID_ADDRESS_NO_CODE()'));\\n\\n    bytes4 private constant ARRAY_OVERFLOW_SELECTOR = 0x58a4ab0e; // bytes4(keccak256('ARRAY_OVERFLOW()'));\\n\\n    /*----------------------------------------\\n      CONSTANT STATE VARIABLES\\n      ----------------------------------------*/\\n    uint256 private constant ETH_ASSET_ID = 0; // if assetId == ETH_ASSET_ID, treat as native ETH and not ERC20 token\\n\\n    // starting root hash of the DeFi interaction result Merkle tree\\n    bytes32 private constant INIT_DEFI_ROOT = 0x2e4ab7889ab3139204945f9e722c7a8fdb84e66439d787bd066c3d896dba04ea;\\n\\n    bytes32 private constant DEFI_BRIDGE_PROCESSED_SIGHASH =\\n        0x692cf5822a02f5edf084dc7249b3a06293621e069f11975ed70908ed10ed2e2c;\\n\\n    bytes32 private constant ASYNC_BRIDGE_PROCESSED_SIGHASH =\\n        0x38ce48f4c2f3454bcf130721f25a4262b2ff2c8e36af937b30edf01ba481eb1d;\\n\\n    // We need to cap the amount of gas sent to the DeFi bridge contract for two reasons:\\n    // 1. To provide consistency to rollup providers around costs,\\n    // 2. to prevent griefing attacks where a bridge consumes all our gas.\\n    uint256 private constant MIN_BRIDGE_GAS_LIMIT = 35000;\\n    uint256 private constant MIN_ERC20_GAS_LIMIT = 55000;\\n    uint256 private constant MAX_BRIDGE_GAS_LIMIT = 5000000;\\n    uint256 private constant MAX_ERC20_GAS_LIMIT = 1500000;\\n\\n    // Bit offsets and bit masks used to extract values from `uint256 encodedBridgeCallData` to FullBridgeCallData struct\\n    uint256 private constant INPUT_ASSET_ID_A_SHIFT = 32;\\n    uint256 private constant INPUT_ASSET_ID_B_SHIFT = 62;\\n    uint256 private constant OUTPUT_ASSET_ID_A_SHIFT = 92;\\n    uint256 private constant OUTPUT_ASSET_ID_B_SHIFT = 122;\\n    uint256 private constant BITCONFIG_SHIFT = 152;\\n    uint256 private constant AUX_DATA_SHIFT = 184;\\n    uint256 private constant VIRTUAL_ASSET_ID_FLAG_SHIFT = 29;\\n    uint256 private constant VIRTUAL_ASSET_ID_FLAG = 0x2000_0000; // 2 ** 29\\n    uint256 private constant MASK_THIRTY_TWO_BITS = 0xffff_ffff;\\n    uint256 private constant MASK_THIRTY_BITS = 0x3fff_ffff;\\n    uint256 private constant MASK_SIXTY_FOUR_BITS = 0xffff_ffff_ffff_ffff;\\n\\n    // Offsets and masks used to encode/decode the rollupState storage variable of RollupProcessor\\n    uint256 private constant DATASIZE_BIT_OFFSET = 160;\\n    uint256 private constant ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET = 192;\\n    uint256 private constant DEFIINTERACTIONHASHES_BIT_OFFSET = 208;\\n    uint256 private constant ARRAY_LENGTH_MASK = 0x3ff; // 1023\\n    uint256 private constant DATASIZE_MASK = 0xffff_ffff;\\n\\n    // the value of hashing a 'zeroed' DeFi interaction result\\n    bytes32 private constant DEFI_RESULT_ZERO_HASH = 0x2d25a1e3a51eb293004c4b56abe12ed0da6bca2b4a21936752a85d102593c1b4;\\n\\n    // roles used in access control\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\\\"EMERGENCY_ROLE\\\");\\n    bytes32 public constant LISTER_ROLE = keccak256(\\\"LISTER_ROLE\\\");\\n    bytes32 public constant RESUME_ROLE = keccak256(\\\"RESUME_ROLE\\\");\\n\\n    // bounds used for escape hatch\\n    uint256 public immutable escapeBlockLowerBound;\\n    uint256 public immutable escapeBlockUpperBound;\\n\\n    /*----------------------------------------\\n      STATE VARIABLES\\n      ----------------------------------------*/\\n    RollupState internal rollupState;\\n\\n    // An array of addresses of supported ERC20 tokens\\n    address[] internal supportedAssets;\\n\\n    // An array of addresses of supported bridges\\n    // @dev `bridgeAddressId` is an index of the bridge's address in this array incremented by 1\\n    address[] internal supportedBridges;\\n\\n    // A mapping from index to async interaction hash (emulates an array)\\n    // @dev next index is stored in `RollupState.numAsyncDefiInteractionHashes`\\n    mapping(uint256 => bytes32) public asyncDefiInteractionHashes;\\n\\n    // A mapping from index to interaction hash (emulates an array)\\n    // @dev next index is stored in the `RollupState.numDefiInteractionHashes`\\n    mapping(uint256 => bytes32) public defiInteractionHashes;\\n\\n    // A mapping from assetId to a mapping of userAddress to the user's public pending balance\\n    mapping(uint256 => mapping(address => uint256)) public userPendingDeposits;\\n\\n    // A mapping from user's address to a mapping of proof hashes to a boolean which indicates approval\\n    mapping(address => mapping(bytes32 => bool)) public depositProofApprovals;\\n\\n    // A hash of the latest rollup state\\n    bytes32 public override(IRollupProcessor) rollupStateHash;\\n\\n    // An address of DefiBridgeProxy contract\\n    address public override(IRollupProcessor) defiBridgeProxy;\\n\\n    // A flag indicating whether addresses without a LISTER role can list assets and bridges\\n    // Note: will be set to true once Aztec Connect is no longer in BETA\\n    bool public allowThirdPartyContracts;\\n\\n    // A mapping from an address to a boolean which indicates whether address is an approved rollup provider\\n    // @dev A rollup provider is an address which is allowed to call `processRollup(...)` out of escape hatch window.\\n    mapping(address => bool) public rollupProviders;\\n\\n    // A mapping from interactionNonce to PendingDefiBridgeInteraction struct\\n    mapping(uint256 => PendingDefiBridgeInteraction) public pendingDefiInteractions;\\n\\n    // A mapping from interactionNonce to ETH amount which was received for that interaction.\\n    // interaction\\n    mapping(uint256 => uint256) public ethPayments;\\n\\n    // A mapping from an `assetId` to a gas limit\\n    mapping(uint256 => uint256) public assetGasLimits;\\n\\n    // A mapping from a `bridgeAddressId` to a gas limit\\n    mapping(uint256 => uint256) public bridgeGasLimits;\\n\\n    // A hash of hashes of pending DeFi interactions, the notes of which are expected to be added in the 'next' rollup\\n    bytes32 public override(IRollupProcessor) prevDefiInteractionsHash;\\n\\n    // The timestamp of the last rollup that was performed by a rollup provider\\n    uint32 public lastRollupTimeStamp;\\n    // The delay in seconds from `lastRollupTimeStamp` until the escape hatch can be used.\\n    uint32 public delayBeforeEscapeHatch;\\n\\n    mapping(uint256 => AssetCap) public caps;\\n\\n    /*----------------------------------------\\n      MODIFIERS\\n      ----------------------------------------*/\\n    /**\\n     * @notice A modifier forbidding functions from being called by addresses without LISTER role when Aztec Connect\\n     *         is still in BETA (`allowThirdPartyContracts` variable set to false)\\n     */\\n    modifier checkThirdPartyContractStatus() {\\n        if (!hasRole(LISTER_ROLE, msg.sender) && !allowThirdPartyContracts) {\\n            revert THIRD_PARTY_CONTRACTS_FLAG_NOT_SET();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice A modifier reverting if this contract is paused\\n     */\\n    modifier whenNotPaused() {\\n        if (rollupState.paused) {\\n            revert PAUSED();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice A modifier reverting if this contract is NOT paused\\n     */\\n    modifier whenPaused() {\\n        if (!rollupState.paused) {\\n            revert NOT_PAUSED();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice A modifier reverting on any re-enter\\n     */\\n    modifier noReenter() {\\n        if (rollupState.lock != Lock.UNLOCKED) {\\n            revert LOCKED_NO_REENTER();\\n        }\\n        rollupState.lock = Lock.LOCKED;\\n        _;\\n        rollupState.lock = Lock.UNLOCKED;\\n    }\\n\\n    /**\\n     * @notice A modifier reverting on any re-enter but allowing async to be called\\n     */\\n    modifier allowAsyncReenter() {\\n        if (rollupState.lock != Lock.UNLOCKED) {\\n            revert LOCKED_NO_REENTER();\\n        }\\n        rollupState.lock = Lock.ALLOW_ASYNC_REENTER;\\n        _;\\n        rollupState.lock = Lock.UNLOCKED;\\n    }\\n\\n    /**\\n     * @notice A modifier reverting if re-entering after locking, but passes if unlocked or if async is re-enter is\\n     *         allowed\\n     */\\n    modifier noReenterButAsync() {\\n        Lock lock = rollupState.lock;\\n        if (lock == Lock.ALLOW_ASYNC_REENTER) {\\n            _;\\n        } else if (lock == Lock.UNLOCKED) {\\n            rollupState.lock = Lock.ALLOW_ASYNC_REENTER;\\n            _;\\n            rollupState.lock = Lock.UNLOCKED;\\n        } else {\\n            revert LOCKED_NO_REENTER();\\n        }\\n    }\\n\\n    /**\\n     * @notice A modifier which reverts if a given `_assetId` represents a virtual asset\\n     * @param _assetId 30-bit integer that describes the asset\\n     * @dev If _assetId's 29th bit is set, it represents a virtual asset with no ERC20 equivalent\\n     *      Virtual assets are used by the bridges to track non-token data. E.g. to represent a loan.\\n     *      If an _assetId is *not* a virtual asset, its ERC20 address can be recovered from\\n     *      `supportedAssets[_assetId]`\\n     */\\n    modifier validateAssetIdIsNotVirtual(uint256 _assetId) {\\n        if (_assetId > 0x1fffffff) {\\n            revert INVALID_ASSET_ID();\\n        }\\n        _;\\n    }\\n\\n    /*----------------------------------------\\n      CONSTRUCTORS & INITIALIZERS\\n      ----------------------------------------*/\\n    /**\\n     * @notice Constructor sets escape hatch window and ensure that the implementation cannot be initialized\\n     * @param _escapeBlockLowerBound a block number which defines a start of the escape hatch window\\n     * @param _escapeBlockUpperBound a block number which defines an end of the escape hatch window\\n     */\\n    constructor(uint256 _escapeBlockLowerBound, uint256 _escapeBlockUpperBound) {\\n        if (_escapeBlockLowerBound == 0 || _escapeBlockLowerBound >= _escapeBlockUpperBound) {\\n            revert INVALID_ESCAPE_BOUNDS();\\n        }\\n\\n        // Set storage in implementation.\\n        // Disable initializers to ensure no-one can call initialize on implementation directly\\n        // Pause to limit possibility for user error\\n        _disableInitializers();\\n        rollupState.paused = true;\\n\\n        // Set immutables (part of code) so will be used in proxy calls as well\\n        escapeBlockLowerBound = _escapeBlockLowerBound;\\n        escapeBlockUpperBound = _escapeBlockUpperBound;\\n    }\\n\\n    /**\\n     * @notice Initialiser function which emulates constructor behaviour for upgradeable contracts\\n     */\\n    function initialize() external reinitializer(getImplementationVersion()) {\\n        rollupState.capped = true;\\n        lastRollupTimeStamp = uint32(block.timestamp);\\n    }\\n\\n    /*----------------------------------------\\n      MUTATING FUNCTIONS WITH ACCESS CONTROL\\n      ----------------------------------------*/\\n    /**\\n     * @notice A function which allow the holders of the EMERGENCY_ROLE role to pause the contract\\n     */\\n    function pause() public override(IRollupProcessor) whenNotPaused onlyRole(EMERGENCY_ROLE) noReenter {\\n        rollupState.paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allow the holders of the RESUME_ROLE to unpause the contract.\\n     */\\n    function unpause() public override(IRollupProcessor) whenPaused onlyRole(RESUME_ROLE) noReenter {\\n        rollupState.paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of OWNER_ROLE to set the capped flag\\n     * @dev When going from uncapped to capped, will update `lastRollupTimeStamp`\\n     * @param _isCapped a flag indicating whether caps are used or not\\n     */\\n    function setCapped(bool _isCapped) external onlyRole(OWNER_ROLE) noReenter {\\n        if (_isCapped == rollupState.capped) return;\\n\\n        if (_isCapped) {\\n            lastRollupTimeStamp = uint32(block.timestamp);\\n        }\\n\\n        rollupState.capped = _isCapped;\\n        emit CappedUpdated(_isCapped);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of OWNER_ROLE to add and remove a rollup provider.\\n     * @param _provider an address of the rollup provider\\n     * @param _valid a flag indicating whether `_provider` is valid\\n     */\\n    function setRollupProvider(address _provider, bool _valid)\\n        external\\n        override(IRollupProcessor)\\n        onlyRole(OWNER_ROLE)\\n        noReenter\\n    {\\n        rollupProviders[_provider] = _valid;\\n        emit RollupProviderUpdated(_provider, _valid);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of the LISTER_ROLE to update asset caps\\n     * @param _assetId The asset id to update the cap for\\n     * @param _pendingCap The pending cap in whole tokens\\n     * @param _dailyCap The daily \\\"accrual\\\" to available deposits in whole tokens\\n     * @param _precision The precision (decimals) to multiply the caps with\\n     */\\n    function setAssetCap(uint256 _assetId, uint32 _pendingCap, uint32 _dailyCap, uint8 _precision)\\n        external\\n        onlyRole(LISTER_ROLE)\\n        noReenter\\n    {\\n        caps[_assetId] = AssetCap({\\n            available: (uint256(_dailyCap) * 10 ** _precision).toU128(),\\n            lastUpdatedTimestamp: uint32(block.timestamp),\\n            pendingCap: _pendingCap,\\n            dailyCap: _dailyCap,\\n            precision: _precision\\n        });\\n\\n        emit AssetCapUpdated(_assetId, _pendingCap, _dailyCap);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of the OWNER_ROLE to specify the delay before escapehatch is possible\\n     * @param _delay the delay in seconds between last rollup by a provider, and escape hatch being possible\\n     */\\n    function setDelayBeforeEscapeHatch(uint32 _delay) external onlyRole(OWNER_ROLE) noReenter {\\n        delayBeforeEscapeHatch = _delay;\\n        emit DelayBeforeEscapeHatchUpdated(_delay);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of OWNER_ROLE to set the address of the PLONK verification smart\\n     *  (         contract\\n     * @param _verifier an address of the verification smart contract\\n     */\\n    function setVerifier(address _verifier) public override(IRollupProcessor) onlyRole(OWNER_ROLE) noReenter {\\n        if (_verifier.code.length == 0) {\\n            revert INVALID_ADDRESS_NO_CODE();\\n        }\\n\\n        rollupState.verifier = IVerifier(_verifier);\\n        emit VerifierUpdated(_verifier);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of OWNER_ROLE to set `allowThirdPartyContracts` flag\\n     * @param _allowThirdPartyContracts A flag indicating true if allowing third parties to register, false otherwise\\n     */\\n    function setAllowThirdPartyContracts(bool _allowThirdPartyContracts)\\n        external\\n        override(IRollupProcessor)\\n        onlyRole(OWNER_ROLE)\\n        noReenter\\n    {\\n        allowThirdPartyContracts = _allowThirdPartyContracts;\\n        emit AllowThirdPartyContractsUpdated(_allowThirdPartyContracts);\\n    }\\n\\n    /**\\n     * @notice A function which allows holders of OWNER_ROLE to set address of `DefiBridgeProxy` contract\\n     * @param _defiBridgeProxy an address of `DefiBridgeProxy` contract\\n     */\\n    function setDefiBridgeProxy(address _defiBridgeProxy)\\n        public\\n        override(IRollupProcessor)\\n        onlyRole(OWNER_ROLE)\\n        noReenter\\n    {\\n        if (_defiBridgeProxy.code.length == 0) {\\n            revert INVALID_ADDRESS_NO_CODE();\\n        }\\n        defiBridgeProxy = _defiBridgeProxy;\\n        emit DefiBridgeProxyUpdated(_defiBridgeProxy);\\n    }\\n\\n    /**\\n     * @notice Registers an ERC20 token as a supported asset\\n     * @param _token address of the ERC20 token\\n     * @param _gasLimit gas limit used when transferring the token (in withdraw or transferFee)\\n     */\\n    function setSupportedAsset(address _token, uint256 _gasLimit)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        checkThirdPartyContractStatus\\n        noReenter\\n    {\\n        if (_token.code.length == 0) {\\n            revert INVALID_ADDRESS_NO_CODE();\\n        }\\n        if (_gasLimit < MIN_ERC20_GAS_LIMIT || _gasLimit > MAX_ERC20_GAS_LIMIT) {\\n            revert INVALID_ASSET_GAS();\\n        }\\n\\n        supportedAssets.push(_token);\\n        uint256 assetId = supportedAssets.length;\\n        assetGasLimits[assetId] = _gasLimit;\\n        emit AssetAdded(assetId, _token, assetGasLimits[assetId]);\\n    }\\n\\n    /**\\n     * @dev Appends a bridge contract to the supportedBridges\\n     * @param _bridge address of the bridge contract\\n     * @param _gasLimit gas limit forwarded to the DefiBridgeProxy to perform convert\\n     */\\n    function setSupportedBridge(address _bridge, uint256 _gasLimit)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        checkThirdPartyContractStatus\\n        noReenter\\n    {\\n        if (_bridge.code.length == 0) {\\n            revert INVALID_ADDRESS_NO_CODE();\\n        }\\n        if (_gasLimit < MIN_BRIDGE_GAS_LIMIT || _gasLimit > MAX_BRIDGE_GAS_LIMIT) {\\n            revert INVALID_BRIDGE_GAS();\\n        }\\n\\n        supportedBridges.push(_bridge);\\n        uint256 bridgeAddressId = supportedBridges.length;\\n        bridgeGasLimits[bridgeAddressId] = _gasLimit;\\n        emit BridgeAdded(bridgeAddressId, _bridge, bridgeGasLimits[bridgeAddressId]);\\n    }\\n\\n    /**\\n     * @notice A function which processes a rollup\\n     * @dev Rollup processing consists of decoding a rollup, verifying the corresponding proof and updating relevant\\n     *      state variables\\n     * @dev The `encodedProofData` is unnamed param as we are reading it directly from calldata when decoding\\n     *      and creating the `proofData` in `Decoder::decodeProof()`.\\n     * @dev For the rollup to be processed `msg.sender` has to be an authorised rollup provider or escape hatch has\\n     *      to be open\\n     * @dev This function always transfers fees to the `rollupBeneficiary` encoded in the proof data\\n     *\\n     * @param - cryptographic proof data associated with a rollup\\n     * @param _signatures a byte array of secp256k1 ECDSA signatures, authorising a transfer of tokens from\\n     *                    the publicOwner for the particular inner proof in question\\n     *\\n     * Structure of each signature in the bytes array is:\\n     * 0x00 - 0x20 : r\\n     * 0x20 - 0x40 : s\\n     * 0x40 - 0x60 : v (in form: 0x0000....0001b for example)\\n     */\\n    function processRollup(bytes calldata, /* encodedProofData */ bytes calldata _signatures)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        allowAsyncReenter\\n    {\\n        (bytes memory proofData, uint256 numTxs, uint256 publicInputsHash) = decodeProof();\\n        address rollupBeneficiary = extractRollupBeneficiary(proofData);\\n\\n        processRollupProof(proofData, _signatures, numTxs, publicInputsHash, rollupBeneficiary);\\n\\n        transferFee(proofData, rollupBeneficiary);\\n    }\\n\\n    /*----------------------------------------\\n      PUBLIC/EXTERNAL MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    /**\\n     * @notice A function used by bridges to send ETH to the RollupProcessor during an interaction\\n     * @param _interactionNonce an interaction nonce that used as an ID of this payment\\n     */\\n    function receiveEthFromBridge(uint256 _interactionNonce) external payable override(IRollupProcessor) {\\n        assembly {\\n            // ethPayments[interactionNonce] += msg.value\\n            mstore(0x00, _interactionNonce)\\n            mstore(0x20, ethPayments.slot)\\n            let slot := keccak256(0x00, 0x40)\\n            // no need to check for overflows as this would require sending more than the blockchain's total supply of ETH!\\n            sstore(slot, add(sload(slot), callvalue()))\\n        }\\n    }\\n\\n    /**\\n     * @notice A function which approves a proofHash to spend the user's pending deposited funds\\n     * @dev this function is one way and must be called by the owner of the funds\\n     * @param _proofHash keccak256 hash of the inner proof public inputs\\n     */\\n    function approveProof(bytes32 _proofHash) public override(IRollupProcessor) whenNotPaused {\\n        // asm implementation to reduce compiled bytecode size\\n        assembly {\\n            // depositProofApprovals[msg.sender][_proofHash] = true;\\n            mstore(0x00, caller())\\n            mstore(0x20, depositProofApprovals.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, _proofHash)\\n            sstore(keccak256(0x00, 0x40), 1)\\n        }\\n    }\\n\\n    /**\\n     * @notice A function which deposits funds to the contract\\n     * @dev This is the first stage of a 2 stage deposit process. In the second stage funds are claimed by the user on\\n     *      L2.\\n     * @param _assetId asset ID which was assigned during asset registration\\n     * @param _amount token deposit amount\\n     * @param _owner address that can spend the deposited funds\\n     * @param _proofHash 32 byte transaction id that can spend the deposited funds\\n     */\\n    function depositPendingFunds(uint256 _assetId, uint256 _amount, address _owner, bytes32 _proofHash)\\n        external\\n        payable\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        noReenter\\n    {\\n        // Perform sanity checks on user input\\n        if (_assetId == ETH_ASSET_ID && msg.value != _amount) {\\n            revert MSG_VALUE_WRONG_AMOUNT();\\n        }\\n        if (_assetId != ETH_ASSET_ID && msg.value != 0) {\\n            revert DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE();\\n        }\\n\\n        increasePendingDepositBalance(_assetId, _owner, _amount);\\n\\n        if (_proofHash != 0) approveProof(_proofHash);\\n\\n        emit Deposit(_assetId, _owner, _amount);\\n\\n        if (_assetId != ETH_ASSET_ID) {\\n            address assetAddress = getSupportedAsset(_assetId);\\n            // check user approved contract to transfer funds, so can throw helpful error to user\\n            if (IERC20(assetAddress).allowance(msg.sender, address(this)) < _amount) {\\n                revert INSUFFICIENT_TOKEN_APPROVAL();\\n            }\\n            TokenTransfers.safeTransferFrom(assetAddress, msg.sender, address(this), _amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice A function used to publish data that doesn't need to be accessible on-chain\\n     * @dev This function can be called multiple times to work around maximum tx size limits\\n     * @dev The data is expected to be reconstructed by the client\\n     * @param _rollupId rollup id this data is related to\\n     * @param _chunk the chunk number, from 0 to totalChunks-1.\\n     * @param _totalChunks the total number of chunks.\\n     * @param - the data\\n     */\\n    function offchainData(uint256 _rollupId, uint256 _chunk, uint256 _totalChunks, bytes calldata /* offchainTxData */ )\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n    {\\n        emit OffchainData(_rollupId, _chunk, _totalChunks, msg.sender);\\n    }\\n\\n    /**\\n     * @notice A function which process async bridge interaction\\n     * @param _interactionNonce unique id of the interaction\\n     * @return true if successful, false otherwise\\n     */\\n    function processAsyncDefiInteraction(uint256 _interactionNonce)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        noReenterButAsync\\n        returns (bool)\\n    {\\n        uint256 encodedBridgeCallData;\\n        uint256 totalInputValue;\\n        assembly {\\n            mstore(0x00, _interactionNonce)\\n            mstore(0x20, pendingDefiInteractions.slot)\\n            let interactionPtr := keccak256(0x00, 0x40)\\n\\n            encodedBridgeCallData := sload(interactionPtr)\\n            totalInputValue := sload(add(interactionPtr, 0x01))\\n        }\\n        if (encodedBridgeCallData == 0) {\\n            revert INVALID_BRIDGE_CALL_DATA();\\n        }\\n        FullBridgeCallData memory fullBridgeCallData = getFullBridgeCallData(encodedBridgeCallData);\\n\\n        (\\n            AztecTypes.AztecAsset memory inputAssetA,\\n            AztecTypes.AztecAsset memory inputAssetB,\\n            AztecTypes.AztecAsset memory outputAssetA,\\n            AztecTypes.AztecAsset memory outputAssetB\\n        ) = getAztecAssetTypes(fullBridgeCallData, _interactionNonce);\\n\\n        // Extract the bridge address from the encodedBridgeCallData\\n        IDefiBridge bridgeContract;\\n        assembly {\\n            mstore(0x00, supportedBridges.slot)\\n            let bridgeSlot := keccak256(0x00, 0x20)\\n\\n            bridgeContract := and(encodedBridgeCallData, 0xffffffff)\\n            bridgeContract := sload(add(bridgeSlot, sub(bridgeContract, 0x01)))\\n            bridgeContract := and(bridgeContract, ADDRESS_MASK)\\n        }\\n        if (address(bridgeContract) == address(0)) {\\n            revert INVALID_BRIDGE_ADDRESS();\\n        }\\n\\n        // delete pendingDefiInteractions[interactionNonce]\\n        // N.B. only need to delete 1st slot value `encodedBridgeCallData`. Deleting vars costs gas post-London\\n        // setting encodedBridgeCallData to 0 is enough to cause future calls with this interaction nonce to fail\\n        pendingDefiInteractions[_interactionNonce].encodedBridgeCallData = 0;\\n\\n        // Copy some variables to front of stack to get around stack too deep errors\\n        InteractionInputs memory inputs =\\n            InteractionInputs(totalInputValue, _interactionNonce, uint64(fullBridgeCallData.auxData));\\n        (uint256 outputValueA, uint256 outputValueB, bool interactionCompleted) = bridgeContract.finalise(\\n            inputAssetA, inputAssetB, outputAssetA, outputAssetB, inputs.interactionNonce, inputs.auxData\\n        );\\n\\n        if (!interactionCompleted) {\\n            pendingDefiInteractions[inputs.interactionNonce].encodedBridgeCallData = encodedBridgeCallData;\\n            return false;\\n        }\\n\\n        if (outputValueB > 0 && outputAssetB.assetType == AztecTypes.AztecAssetType.NOT_USED) {\\n            revert NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET(outputValueB);\\n        }\\n\\n        if (outputValueA == 0 && outputValueB == 0) {\\n            // issue refund.\\n            transferTokensAsync(address(bridgeContract), inputAssetA, inputs.totalInputValue, inputs.interactionNonce);\\n            transferTokensAsync(address(bridgeContract), inputAssetB, inputs.totalInputValue, inputs.interactionNonce);\\n        } else {\\n            // transfer output tokens to rollup contract\\n            transferTokensAsync(address(bridgeContract), outputAssetA, outputValueA, inputs.interactionNonce);\\n            transferTokensAsync(address(bridgeContract), outputAssetB, outputValueB, inputs.interactionNonce);\\n        }\\n\\n        // compute defiInteractionHash and push it onto the asyncDefiInteractionHashes array\\n        bool result;\\n        assembly {\\n            // Load values from `input` (to get around stack too deep)\\n            let inputValue := mload(inputs)\\n            let nonce := mload(add(inputs, 0x20))\\n            result := iszero(and(eq(outputValueA, 0), eq(outputValueB, 0)))\\n\\n            // Compute defi interaction hash\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, encodedBridgeCallData)\\n            mstore(add(mPtr, 0x20), nonce)\\n            mstore(add(mPtr, 0x40), inputValue)\\n            mstore(add(mPtr, 0x60), outputValueA)\\n            mstore(add(mPtr, 0x80), outputValueB)\\n            mstore(add(mPtr, 0xa0), result)\\n            pop(staticcall(gas(), 0x2, mPtr, 0xc0, 0x00, 0x20))\\n            let defiInteractionHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n\\n            // Load sync and async array lengths from rollup state\\n            let state := sload(rollupState.slot)\\n            // asyncArrayLen = rollupState.numAsyncDefiInteractionHashes\\n            let asyncArrayLen := and(ARRAY_LENGTH_MASK, shr(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n            // defiArrayLen = rollupState.numDefiInteractionHashes\\n            let defiArrayLen := and(ARRAY_LENGTH_MASK, shr(DEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n\\n            // check that size of asyncDefiInteractionHashes isn't such that\\n            // adding 1 to it will make the next block's defiInteractionHashes length hit 512\\n            if gt(add(add(1, asyncArrayLen), defiArrayLen), 512) {\\n                mstore(0, ARRAY_OVERFLOW_SELECTOR)\\n                revert(0, 0x4)\\n            }\\n\\n            // asyncDefiInteractionHashes[asyncArrayLen] = defiInteractionHash\\n            mstore(0x00, asyncArrayLen)\\n            mstore(0x20, asyncDefiInteractionHashes.slot)\\n            sstore(keccak256(0x00, 0x40), defiInteractionHash)\\n\\n            // increase asyncDefiInteractionHashes.length by 1\\n            let oldState := and(not(shl(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n            let newState := or(oldState, shl(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, add(asyncArrayLen, 0x01)))\\n\\n            sstore(rollupState.slot, newState)\\n        }\\n        emit DefiBridgeProcessed(\\n            encodedBridgeCallData,\\n            inputs.interactionNonce,\\n            inputs.totalInputValue,\\n            outputValueA,\\n            outputValueB,\\n            result,\\n            \\\"\\\"\\n            );\\n\\n        return true;\\n    }\\n\\n    /*----------------------------------------\\n      INTERNAL/PRIVATE MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    /**\\n     * @notice A function which increasees pending deposit amount in the `userPendingDeposits` mapping\\n     * @dev Implemented in assembly in order to reduce compiled bytecode size and improve gas costs\\n     * @param _assetId asset ID which was assigned during asset registration\\n     * @param _owner address that can spend the deposited funds\\n     * @param _amount deposit token amount\\n     */\\n    function increasePendingDepositBalance(uint256 _assetId, address _owner, uint256 _amount)\\n        internal\\n        validateAssetIdIsNotVirtual(_assetId)\\n    {\\n        uint256 pending = userPendingDeposits[_assetId][_owner];\\n\\n        if (rollupState.capped) {\\n            AssetCap memory cap = caps[_assetId];\\n            uint256 precision = 10 ** cap.precision;\\n\\n            if (cap.pendingCap == 0 || pending + _amount > uint256(cap.pendingCap) * precision) {\\n                revert PENDING_CAP_SURPASSED();\\n            }\\n\\n            if (cap.dailyCap == 0) {\\n                revert DAILY_CAP_SURPASSED();\\n            } else {\\n                // Increase the available amount, capped by dailyCap\\n                uint256 capVal = uint256(cap.dailyCap) * precision;\\n                uint256 rate = capVal / 1 days;\\n                cap.available += (rate * (block.timestamp - cap.lastUpdatedTimestamp)).toU128();\\n                if (cap.available > capVal) {\\n                    cap.available = capVal.toU128();\\n                }\\n                if (_amount > cap.available) {\\n                    revert DAILY_CAP_SURPASSED();\\n                }\\n                // Update available and timestamp\\n                cap.available -= _amount.toU128();\\n                cap.lastUpdatedTimestamp = uint32(block.timestamp);\\n                caps[_assetId] = cap;\\n            }\\n        }\\n\\n        userPendingDeposits[_assetId][_owner] = pending + _amount;\\n    }\\n\\n    /**\\n     * @notice A function which decreases pending deposit amount in the `userPendingDeposits` mapping\\n     * @dev Implemented in assembly in order to reduce compiled bytecode size and improve gas costs\\n     * @param _assetId asset ID which was assigned during asset registration\\n     * @param _owner address that owns the pending deposit\\n     * @param _amount amount of tokens to decrease pending by\\n     */\\n    function decreasePendingDepositBalance(uint256 _assetId, address _owner, uint256 _amount)\\n        internal\\n        validateAssetIdIsNotVirtual(_assetId)\\n    {\\n        bool insufficientDeposit = false;\\n        assembly {\\n            // userPendingDeposit = userPendingDeposits[_assetId][_owner]\\n            mstore(0x00, _assetId)\\n            mstore(0x20, userPendingDeposits.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, _owner)\\n            let userPendingDepositSlot := keccak256(0x00, 0x40)\\n            let userPendingDeposit := sload(userPendingDepositSlot)\\n\\n            insufficientDeposit := lt(userPendingDeposit, _amount)\\n\\n            let newDeposit := sub(userPendingDeposit, _amount)\\n\\n            sstore(userPendingDepositSlot, newDeposit)\\n        }\\n\\n        if (insufficientDeposit) {\\n            revert INSUFFICIENT_DEPOSIT();\\n        }\\n    }\\n\\n    /**\\n     * @notice A function that processes a rollup proof\\n     * @dev Processing a rollup proof consists of:\\n     *          1) Verifying the proof's correctness,\\n     *          2) using the provided proof data to update rollup state + merkle roots,\\n     *          3) validate/enacting any deposits/withdrawals,\\n     *          4) processing bridge calls.\\n     * @param _proofData decoded rollup proof data\\n     * @param _signatures ECDSA signatures from users authorizing deposit transactions\\n     * @param _numTxs the number of transactions in the block\\n     * @param _publicInputsHash the SHA256 hash of the proof's public inputs\\n     * @param _rollupBeneficiary The address to be paid any subsidy for bridge calls and rollup fees\\n     */\\n    function processRollupProof(\\n        bytes memory _proofData,\\n        bytes memory _signatures,\\n        uint256 _numTxs,\\n        uint256 _publicInputsHash,\\n        address _rollupBeneficiary\\n    ) internal {\\n        uint256 rollupId = verifyProofAndUpdateState(_proofData, _publicInputsHash);\\n        processDepositsAndWithdrawals(_proofData, _numTxs, _signatures);\\n        bytes32[] memory nextDefiHashes = processBridgeCalls(_proofData, _rollupBeneficiary);\\n        emit RollupProcessed(rollupId, nextDefiHashes, msg.sender);\\n    }\\n\\n    /**\\n     * @notice A function which verifies zk proof and updates the contract's state variables\\n     * @dev encodedProofData is read from calldata passed into the transaction and differs from `_proofData`\\n     * @param _proofData decoded rollup proof data\\n     * @param _publicInputsHash a hash of public inputs (computed by `Decoder.sol`)\\n     * @return rollupId id of the rollup which is being processed\\n     */\\n    function verifyProofAndUpdateState(bytes memory _proofData, uint256 _publicInputsHash)\\n        internal\\n        returns (uint256 rollupId)\\n    {\\n        // Verify the rollup proof.\\n        //\\n        // We manually call the verifier contract via assembly to save on gas costs and to reduce contract bytecode size\\n        assembly {\\n            /**\\n             * Validate correctness of zk proof.\\n             *\\n             * 1st Item is to format verifier calldata.\\n             *\\n             */\\n\\n            // The `encodedProofData` (in calldata) contains the concatenation of\\n            // encoded 'broadcasted inputs' and the actual zk proof data.\\n            // (The `boadcasted inputs` is converted into a 32-byte SHA256 hash, which is\\n            // validated to equal the first public inputs of the zk proof. This is done in `Decoder.sol`).\\n            // We need to identify the location in calldata that points to the start of the zk proof data.\\n\\n            // Step 1: compute size of zk proof data and its calldata pointer.\\n            /**\\n             * Data layout for `bytes encodedProofData`...\\n             *\\n             *             0x00 : 0x20 : length of array\\n             *             0x20 : 0x20 + header : root rollup header data\\n             *             0x20 + header : 0x24 + header : X, the length of encoded inner join-split public inputs\\n             *             0x24 + header : 0x24 + header + X : (inner join-split public inputs)\\n             *             0x24 + header + X : 0x28 + header + X : Y, the length of the zk proof data\\n             *             0x28 + header + X : 0x28 + haeder + X + Y : zk proof data\\n             *\\n             *             We need to recover the numeric value of `0x28 + header + X` and `Y`\\n             *\\n             */\\n            // Begin by getting length of encoded inner join-split public inputs.\\n            // `calldataload(0x04)` points to start of bytes array. Add 0x24 to skip over length param and function signature.\\n            // The calldata param 4 bytes *after* the header is the length of the pub inputs array. However it is a packed 4-byte param.\\n            // To extract it, we subtract 24 bytes from the calldata pointer and mask off all but the 4 least significant bytes.\\n            let encodedInnerDataSize :=\\n                and(calldataload(add(add(calldataload(0x04), 0x24), sub(ROLLUP_HEADER_LENGTH, 0x18))), 0xffffffff)\\n\\n            // add 8 bytes to skip over the two packed params that follow the rollup header data\\n            // broadcastedDataSize = inner join-split pubinput size + header size\\n            let broadcastedDataSize := add(add(ROLLUP_HEADER_LENGTH, 8), encodedInnerDataSize)\\n\\n            // Compute zk proof data size by subtracting broadcastedDataSize from overall length of bytes encodedProofsData\\n            let zkProofDataSize := sub(calldataload(add(calldataload(0x04), 0x04)), broadcastedDataSize)\\n\\n            // Compute calldata pointer to start of zk proof data by adding calldata offset to broadcastedDataSize\\n            // (+0x24 skips over function signature and length param of bytes encodedProofData)\\n            let zkProofDataPtr := add(broadcastedDataSize, add(calldataload(0x04), 0x24))\\n\\n            // Step 2: Format calldata for verifier contract call.\\n\\n            // Get free memory pointer - we copy calldata into memory starting here\\n            let dataPtr := mload(0x40)\\n\\n            // We call the function `verify(bytes,uint256)`\\n            // The function signature is 0xac318c5d\\n            // Calldata map is:\\n            // 0x00 - 0x04 : 0xac318c5d\\n            // 0x04 - 0x24 : 0x40 (number of bytes between 0x04 and the start of the `proofData` array at 0x44)\\n            // 0x24 - 0x44 : publicInputsHash\\n            // 0x44 - .... : proofData\\n            mstore8(dataPtr, 0xac)\\n            mstore8(add(dataPtr, 0x01), 0x31)\\n            mstore8(add(dataPtr, 0x02), 0x8c)\\n            mstore8(add(dataPtr, 0x03), 0x5d)\\n            mstore(add(dataPtr, 0x04), 0x40)\\n            mstore(add(dataPtr, 0x24), _publicInputsHash)\\n            mstore(add(dataPtr, 0x44), zkProofDataSize) // length of zkProofData bytes array\\n            calldatacopy(add(dataPtr, 0x64), zkProofDataPtr, zkProofDataSize) // copy the zk proof data into memory\\n\\n            // Step 3: Call our verifier contract. It does not return any values, but will throw an error if the proof is not valid\\n            // i.e. verified == false if proof is not valid\\n            let verifierAddress := and(sload(rollupState.slot), ADDRESS_MASK)\\n            if iszero(extcodesize(verifierAddress)) {\\n                mstore(0, INVALID_ADDRESS_NO_CODE_SELECTOR)\\n                revert(0, 0x4)\\n            }\\n            let proof_verified := staticcall(gas(), verifierAddress, dataPtr, add(zkProofDataSize, 0x64), 0x00, 0x00)\\n\\n            // Check the proof is valid!\\n            if iszero(proof_verified) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Validate and update state hash\\n        rollupId = validateAndUpdateMerkleRoots(_proofData);\\n    }\\n\\n    /**\\n     * @notice Extracts roots from public inputs and validate that they are inline with current contract `rollupState`\\n     * @param _proofData decoded rollup proof data\\n     * @return rollup id\\n     * @dev To make the circuits happy, we want to only insert at the next subtree. The subtrees that we are using are\\n     *      28 leafs in size. They could be smaller but we just want them to be of same size for circuit related\\n     *      reasons.\\n     *          When we have the case that the `storedDataSize % numDataLeaves == 0`, we are perfectly dividing. This\\n     *      means that the incoming rollup matches perfectly with a boundry of the next subtree.\\n     *          When this is not the case, we have to compute an offset that we then apply so that the full state can\\n     *      be built with a bunch of same-sized trees (when the rollup is not full we insert a tree with some zero\\n     *      leaves). This offset can be computed as `numDataLeaves - (storedDataSize % numDataLeaves)` and is,\\n     *      essentially, how big a \\\"space\\\" we should leave so that the currently inserted subtree ends exactly at\\n     *      the subtree boundry. The value is always >= 0. In the function below we won\u2019t hit the zero case, because\\n     *      that would be cought by the \\\"if-branch\\\".\\n     *\\n     *      Example: We have just had 32 rollups of size 28 (`storedDataSize = 896`). Now there is a small rollup with\\n     *      only 6 transactions. We are not perfectly dividing, hence we compute the offset as `6 - 896 % 6 = 4`.\\n     *      The start index is `896 + 4 = 900`. With the added leaves, the stored data size now becomes `906`.\\n     *          Now, comes another full rollup (28 txs). We compute `906 % 28 = 10`. The value is non-zero which means\\n     *      that we don\u2019t perfectly divide and have to compute an offset `28 - 906 % 28 = 18`. The start index is\\n     *      `906 + 18 = 924`. Notice that `924 % 28 == 0`, so this will land us exactly at a location where everything\\n     *      in the past could have been subtrees of size 28.\\n     */\\n    function validateAndUpdateMerkleRoots(bytes memory _proofData) internal returns (uint256) {\\n        (uint256 rollupId, bytes32 oldStateHash, bytes32 newStateHash, uint32 numDataLeaves, uint32 dataStartIndex) =\\n            computeRootHashes(_proofData);\\n\\n        if (oldStateHash != rollupStateHash) {\\n            revert INCORRECT_STATE_HASH(oldStateHash, newStateHash);\\n        }\\n\\n        unchecked {\\n            uint32 storedDataSize = rollupState.datasize;\\n            // Ensure we are inserting at the next subtree boundary.\\n            if (storedDataSize % numDataLeaves == 0) {\\n                if (dataStartIndex != storedDataSize) {\\n                    revert INCORRECT_DATA_START_INDEX(dataStartIndex, storedDataSize);\\n                }\\n            } else {\\n                uint256 expected = storedDataSize + numDataLeaves - (storedDataSize % numDataLeaves);\\n                if (dataStartIndex != expected) {\\n                    revert INCORRECT_DATA_START_INDEX(dataStartIndex, expected);\\n                }\\n            }\\n\\n            rollupStateHash = newStateHash;\\n            rollupState.datasize = dataStartIndex + numDataLeaves;\\n        }\\n        return rollupId;\\n    }\\n\\n    /**\\n     * @notice A function which processes deposits and withdrawls\\n     * @param _proofData decoded rollup proof data\\n     * @param _numTxs number of transactions rolled up in the proof\\n     * @param _signatures byte array of secp256k1 ECDSA signatures, authorising a transfer of tokens\\n     */\\n    function processDepositsAndWithdrawals(bytes memory _proofData, uint256 _numTxs, bytes memory _signatures)\\n        internal\\n    {\\n        uint256 sigIndex = 0x00;\\n        uint256 proofDataPtr;\\n        uint256 end;\\n        assembly {\\n            // add 0x20 to skip over 1st member of the bytes type (the length field).\\n            // Also skip over the rollup header.\\n            proofDataPtr := add(ROLLUP_HEADER_LENGTH, add(_proofData, 0x20))\\n\\n            // compute the position of proofDataPtr after we iterate through every transaction\\n            end := add(proofDataPtr, mul(_numTxs, TX_PUBLIC_INPUT_LENGTH))\\n        }\\n\\n        // This is a bit of a hot loop, we iterate over every tx to determine whether to process deposits or withdrawals.\\n        while (proofDataPtr < end) {\\n            // extract the minimum information we need to determine whether to skip this iteration\\n            uint256 publicValue;\\n            assembly {\\n                publicValue := mload(add(proofDataPtr, 0xa0))\\n            }\\n            if (publicValue > 0) {\\n                uint256 proofId;\\n                uint256 assetId;\\n                address publicOwner;\\n                assembly {\\n                    proofId := mload(proofDataPtr)\\n                    assetId := mload(add(proofDataPtr, 0xe0))\\n                    publicOwner := mload(add(proofDataPtr, 0xc0))\\n                }\\n\\n                if (proofId == 1) {\\n                    // validate user has approved deposit\\n                    bytes32 digest;\\n                    assembly {\\n                        // compute the tx id to check if user has approved tx\\n                        digest := keccak256(proofDataPtr, TX_PUBLIC_INPUT_LENGTH)\\n                    }\\n                    // check if there is an existing entry in depositProofApprovals\\n                    // if there is, no further work required.\\n                    // we don't need to clear `depositProofApprovals[publicOwner][digest]` because proofs cannot be re-used.\\n                    // A single proof describes the creation of 2 output notes and the addition of 2 input note nullifiers\\n                    // (both of these nullifiers can be categorised as \\\"fake\\\". They may not map to existing notes but are still inserted in the nullifier set)\\n                    // Replaying the proof will fail to satisfy the rollup circuit's non-membership check on the input nullifiers.\\n                    // We avoid resetting `depositProofApprovals` because that would cost additional gas post-London hard fork.\\n                    if (!depositProofApprovals[publicOwner][digest]) {\\n                        // extract and validate signature\\n                        // we can create a bytes memory container for the signature without allocating new memory,\\n                        // by overwriting the previous 32 bytes in the `signatures` array with the 'length' of our synthetic byte array (96)\\n                        // we store the memory we overwrite in `temp`, so that we can restore it\\n                        bytes memory signature;\\n                        uint256 temp;\\n                        assembly {\\n                            // set `signature` to point to 32 bytes less than the desired `r, s, v` values in `signatures`\\n                            signature := add(_signatures, sigIndex)\\n                            // cache the memory we're about to overwrite\\n                            temp := mload(signature)\\n                            // write in a 96-byte 'length' parameter into the `signature` bytes array\\n                            mstore(signature, 0x60)\\n                        }\\n\\n                        bytes32 hashedMessage = RollupProcessorLibrary.getSignedMessageForTxId(digest);\\n\\n                        RollupProcessorLibrary.validateShieldSignatureUnpacked(hashedMessage, signature, publicOwner);\\n                        // restore the memory we overwrote\\n                        assembly {\\n                            mstore(signature, temp)\\n                            sigIndex := add(sigIndex, 0x60)\\n                        }\\n                    }\\n                    decreasePendingDepositBalance(assetId, publicOwner, publicValue);\\n                }\\n\\n                if (proofId == 2) {\\n                    withdraw(publicValue, publicOwner, assetId);\\n                }\\n            }\\n            // don't check for overflow, would take > 2^200 iterations of this loop for that to happen!\\n            unchecked {\\n                proofDataPtr += TX_PUBLIC_INPUT_LENGTH;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice A function which pulls tokens from a bridge\\n     * @dev Calls `transferFrom` if asset is of type ERC20. If asset is ETH we validate a payment has been made\\n     *      against the provided interaction nonce. This function is used by `processAsyncDefiInteraction`.\\n     * @param _bridge address of bridge contract we're transferring tokens from\\n     * @param _asset the AztecAsset being transferred\\n     * @param _outputValue the expected value transferred\\n     * @param _interactionNonce the defi interaction nonce of the interaction\\n     */\\n    function transferTokensAsync(\\n        address _bridge,\\n        AztecTypes.AztecAsset memory _asset,\\n        uint256 _outputValue,\\n        uint256 _interactionNonce\\n    ) internal {\\n        if (_outputValue == 0) {\\n            return;\\n        }\\n        if (_asset.assetType == AztecTypes.AztecAssetType.ETH) {\\n            if (_outputValue > ethPayments[_interactionNonce]) {\\n                revert INSUFFICIENT_ETH_PAYMENT();\\n            }\\n            ethPayments[_interactionNonce] = 0;\\n        } else if (_asset.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            address tokenAddress = _asset.erc20Address;\\n            TokenTransfers.safeTransferFrom(tokenAddress, _bridge, address(this), _outputValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice A function which transfers fees to the `_feeReceiver`\\n     * @dev Note: function will not revert if underlying transfers fails\\n     * @param _proofData decoded rollup proof data\\n     * @param _feeReceiver fee beneficiary as described by the rollup provider\\n     */\\n    function transferFee(bytes memory _proofData, address _feeReceiver) internal {\\n        for (uint256 i = 0; i < NUMBER_OF_ASSETS;) {\\n            uint256 txFee = extractTotalTxFee(_proofData, i);\\n            if (txFee > 0) {\\n                uint256 assetId = extractFeeAssetId(_proofData, i);\\n                if (assetId == ETH_ASSET_ID) {\\n                    // We explicitly do not throw if this call fails, as this opens up the possiblity of griefing\\n                    // attacks --> engineering a failed fee would invalidate an entire rollup block. As griefing could\\n                    // be done by consuming all gas in the `_feeReceiver` fallback only 50K gas is forwarded. We are\\n                    // forwarding a bit more gas than in the withdraw function because this code will only be hit\\n                    // at most once each rollup-block and we want to give the provider a bit more flexibility.\\n                    assembly {\\n                        pop(call(50000, _feeReceiver, txFee, 0, 0, 0, 0))\\n                    }\\n                } else {\\n                    address assetAddress = getSupportedAsset(assetId);\\n                    TokenTransfers.transferToDoNotBubbleErrors(\\n                        assetAddress, _feeReceiver, txFee, assetGasLimits[assetId]\\n                    );\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal utility function which withdraws funds from the contract to a receiver address\\n     * @param _withdrawValue - value being withdrawn from the contract\\n     * @param _receiver - address receiving public ERC20 tokens\\n     * @param _assetId - ID of the asset for which a withdrawal is being performed\\n     * @dev The function doesn't throw if the inner call fails, as this opens up the possiblity of griefing attacks\\n     *      -> engineering a failed withdrawal would invalidate an entire rollup block.\\n     *      A griefing attack could be done by consuming all gas in the `_receiver` fallback and for this reason we\\n     *      only forward 30K gas. This still allows the recipient to handle accounting if recipient is a contract.\\n     *      The user should ensure their withdrawal will succeed or they will lose the funds.\\n     */\\n    function withdraw(uint256 _withdrawValue, address _receiver, uint256 _assetId) internal {\\n        if (_receiver == address(0)) {\\n            revert WITHDRAW_TO_ZERO_ADDRESS();\\n        }\\n        if (_assetId == 0) {\\n            assembly {\\n                pop(call(30000, _receiver, _withdrawValue, 0, 0, 0, 0))\\n            }\\n            // payable(_receiver).call{gas: 30000, value: _withdrawValue}('');\\n        } else {\\n            address assetAddress = getSupportedAsset(_assetId);\\n            TokenTransfers.transferToDoNotBubbleErrors(\\n                assetAddress, _receiver, _withdrawValue, assetGasLimits[_assetId]\\n            );\\n        }\\n    }\\n\\n    /*----------------------------------------\\n      PUBLIC/EXTERNAL NON-MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    /**\\n     * @notice Get implementation's version number\\n     * @return version version number of the implementation\\n     */\\n    function getImplementationVersion() public view virtual returns (uint8 version) {\\n        return 3;\\n    }\\n\\n    /**\\n     * @notice Get true if the contract is paused, false otherwise\\n     * @return isPaused - True if paused, false otherwise\\n     */\\n    function paused() external view override(IRollupProcessor) returns (bool isPaused) {\\n        return rollupState.paused;\\n    }\\n\\n    /**\\n     * @notice Gets the number of filled entries in the data tree\\n     * @return dataSize number of filled entries in the data tree (equivalent to the number of notes created on L2)\\n     */\\n    function getDataSize() public view override(IRollupProcessor) returns (uint256 dataSize) {\\n        return rollupState.datasize;\\n    }\\n\\n    /**\\n     * @notice Returns true if deposits are capped, false otherwise\\n     * @return capped - True if deposits are capped, false otherwise\\n     */\\n    function getCapped() public view override(IRollupProcessorV2) returns (bool capped) {\\n        return rollupState.capped;\\n    }\\n\\n    /**\\n     * @notice Gets the number of pending defi interactions that have resolved but have not yet been added into the\\n     *         DeFi tree\\n     * @return - the number of pending interactions\\n     * @dev This value can never exceed 512. This limit is set in order to prevent griefing attacks - `processRollup`\\n     *      iterates through `asyncDefiInteractionHashes` and copies their values into `defiInteractionHashes`. Loop\\n     *      is bounded to < 512 so that tx does not exceed block gas limit.\\n     */\\n    function getPendingDefiInteractionHashesLength() public view override(IRollupProcessor) returns (uint256) {\\n        return rollupState.numAsyncDefiInteractionHashes + rollupState.numDefiInteractionHashes;\\n    }\\n\\n    /**\\n     * @notice Gets the address of the PLONK verification smart contract\\n     * @return - address of the verification smart contract\\n     */\\n    function verifier() public view override(IRollupProcessor) returns (address) {\\n        return address(rollupState.verifier);\\n    }\\n\\n    /**\\n     * @notice Gets the number of supported bridges\\n     * @return - the number of supported bridges\\n     */\\n    function getSupportedBridgesLength() external view override(IRollupProcessor) returns (uint256) {\\n        return supportedBridges.length;\\n    }\\n\\n    /**\\n     * @notice Gets the bridge contract address for a given bridgeAddressId\\n     * @param _bridgeAddressId identifier used to denote a particular bridge\\n     * @return - the address of the matching bridge contract\\n     */\\n    function getSupportedBridge(uint256 _bridgeAddressId) public view override(IRollupProcessor) returns (address) {\\n        return supportedBridges[_bridgeAddressId - 1];\\n    }\\n\\n    /**\\n     * @notice Gets the number of supported assets\\n     * @return - the number of supported assets\\n     */\\n    function getSupportedAssetsLength() external view override(IRollupProcessor) returns (uint256) {\\n        return supportedAssets.length;\\n    }\\n\\n    /**\\n     * @notice Gets the ERC20 token address of a supported asset for a given `_assetId`\\n     * @param _assetId identifier used to denote a particular asset\\n     * @return - the address of the matching asset\\n     */\\n    function getSupportedAsset(uint256 _assetId)\\n        public\\n        view\\n        override(IRollupProcessor)\\n        validateAssetIdIsNotVirtual(_assetId)\\n        returns (address)\\n    {\\n        // If assetId == ETH_ASSET_ID (i.e. 0), this represents native ETH.\\n        // ERC20 token asset id values start at 1\\n        if (_assetId == ETH_ASSET_ID) {\\n            return address(0x0);\\n        }\\n        address result = supportedAssets[_assetId - 1];\\n        if (result == address(0)) {\\n            revert INVALID_ASSET_ADDRESS();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @notice Gets the status of the escape hatch.\\n     * @return True if escape hatch is open, false otherwise\\n     * @return The number of blocks until the next opening/closing of escape hatch\\n     */\\n    function getEscapeHatchStatus() public view override(IRollupProcessor) returns (bool, uint256) {\\n        uint256 blockNum = block.number;\\n\\n        bool isOpen = blockNum % escapeBlockUpperBound >= escapeBlockLowerBound;\\n        uint256 blocksRemaining = 0;\\n        if (isOpen) {\\n            if (block.timestamp < uint256(lastRollupTimeStamp) + delayBeforeEscapeHatch) {\\n                isOpen = false;\\n            }\\n            // num blocks escape hatch will remain open for\\n            blocksRemaining = escapeBlockUpperBound - (blockNum % escapeBlockUpperBound);\\n        } else {\\n            // num blocks until escape hatch will be opened\\n            blocksRemaining = escapeBlockLowerBound - (blockNum % escapeBlockUpperBound);\\n        }\\n        return (isOpen, blocksRemaining);\\n    }\\n\\n    /**\\n     * @notice Gets the number of defi interaction hashes\\n     * @dev A defi interaction hash represents a defi interaction that has resolved, but whose\\n     *      result data has not yet been added into the Aztec Defi Merkle tree. This step is needed in order to convert\\n     *      L2 Defi claim notes into L2 value notes.\\n     * @return - the number of pending defi interaction hashes\\n     */\\n    function getDefiInteractionHashesLength() public view override(IRollupProcessor) returns (uint256) {\\n        return rollupState.numDefiInteractionHashes;\\n    }\\n\\n    /**\\n     * @notice Gets the number of asynchronous defi interaction hashes\\n     * @dev A defi interaction hash represents an asynchronous defi interaction that has resolved, but whose interaction\\n     *      result data has not yet been added into the Aztec Defi Merkle tree. This step is needed in order to convert\\n     *      L2 Defi claim notes into L2 value notes.\\n     * @return - the number of pending async defi interaction hashes\\n     */\\n    function getAsyncDefiInteractionHashesLength() public view override(IRollupProcessor) returns (uint256) {\\n        return rollupState.numAsyncDefiInteractionHashes;\\n    }\\n\\n    /*----------------------------------------\\n      INTERNAL/PRIVATE NON-MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    /**\\n     * @notice A function which constructs a FullBridgeCallData struct based on values from `_encodedBridgeCallData`\\n     * @param _encodedBridgeCallData a bit-array that contains data describing a specific bridge call\\n     *\\n     * Structure of the bit array is as follows (starting at the least significant bit):\\n     * | bit range | parameter       | description |\\n     * | 0 - 32    | bridgeAddressId | The address ID. Bridge address = `supportedBridges[bridgeAddressId]` |\\n     * | 32 - 62   | inputAssetIdA   | First input asset ID. |\\n     * | 62 - 92   | inputAssetIdB   | Second input asset ID. Must be 0 if bridge does not have a 2nd input asset. |\\n     * | 92 - 122  | outputAssetIdA  | First output asset ID. |\\n     * | 122 - 152 | outputAssetIdB  | Second output asset ID. Must be 0 if bridge does not have a 2nd output asset. |\\n     * | 152 - 184 | bitConfig       | Bit-array that contains boolean bridge settings. |\\n     * | 184 - 248 | auxData         | 64 bits of custom data to be passed to the bridge contract. Structure of auxData\\n     *                                 is defined/checked by the bridge contract. |\\n     *\\n     * Structure of the `bitConfig` parameter is as follows\\n     * | bit | parameter               | description |\\n     * | 0   | secondInputInUse        | Does the bridge have a second input asset? |\\n     * | 1   | secondOutputInUse       | Does the bridge have a second output asset? |\\n     *\\n     * @dev Note: Virtual assets are assets that don't have an ERC20 token analogue and exist solely as notes within\\n     *            the Aztec network. They can be created/spent within bridge calls. They are used to enable bridges\\n     *            to track internally-defined data without having to mint a new token on-chain. An example use of\\n     *            a virtual asset would be a virtual loan asset that tracks an outstanding debt that must be repaid\\n     *            to recover a collateral deposited into the bridge.\\n     *\\n     * @return fullBridgeCallData a struct that contains information defining a specific bridge call\\n     */\\n    function getFullBridgeCallData(uint256 _encodedBridgeCallData)\\n        internal\\n        view\\n        returns (FullBridgeCallData memory fullBridgeCallData)\\n    {\\n        assembly {\\n            mstore(fullBridgeCallData, and(_encodedBridgeCallData, MASK_THIRTY_TWO_BITS)) // bridgeAddressId\\n            mstore(\\n                add(fullBridgeCallData, 0x40),\\n                and(shr(INPUT_ASSET_ID_A_SHIFT, _encodedBridgeCallData), MASK_THIRTY_BITS)\\n            ) // inputAssetIdA\\n            mstore(\\n                add(fullBridgeCallData, 0x60),\\n                and(shr(INPUT_ASSET_ID_B_SHIFT, _encodedBridgeCallData), MASK_THIRTY_BITS)\\n            ) // inputAssetIdB\\n            mstore(\\n                add(fullBridgeCallData, 0x80),\\n                and(shr(OUTPUT_ASSET_ID_A_SHIFT, _encodedBridgeCallData), MASK_THIRTY_BITS)\\n            ) // outputAssetIdA\\n            mstore(\\n                add(fullBridgeCallData, 0xa0),\\n                and(shr(OUTPUT_ASSET_ID_B_SHIFT, _encodedBridgeCallData), MASK_THIRTY_BITS)\\n            ) // outputAssetIdB\\n            mstore(\\n                add(fullBridgeCallData, 0xc0), and(shr(AUX_DATA_SHIFT, _encodedBridgeCallData), MASK_SIXTY_FOUR_BITS)\\n            ) // auxData\\n\\n            mstore(\\n                add(fullBridgeCallData, 0xe0),\\n                and(shr(add(INPUT_ASSET_ID_A_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), _encodedBridgeCallData), 1)\\n            ) // firstInputVirtual (30th bit of inputAssetIdA) == 1\\n            mstore(\\n                add(fullBridgeCallData, 0x100),\\n                and(shr(add(INPUT_ASSET_ID_B_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), _encodedBridgeCallData), 1)\\n            ) // secondInputVirtual (30th bit of inputAssetIdB) == 1\\n            mstore(\\n                add(fullBridgeCallData, 0x120),\\n                and(shr(add(OUTPUT_ASSET_ID_A_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), _encodedBridgeCallData), 1)\\n            ) // firstOutputVirtual (30th bit of outputAssetIdA) == 1\\n            mstore(\\n                add(fullBridgeCallData, 0x140),\\n                and(shr(add(OUTPUT_ASSET_ID_B_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), _encodedBridgeCallData), 1)\\n            ) // secondOutputVirtual (30th bit of outputAssetIdB) == 1\\n            let bitConfig := and(shr(BITCONFIG_SHIFT, _encodedBridgeCallData), MASK_THIRTY_TWO_BITS)\\n            // bitConfig = bit mask that contains bridge ID settings\\n            // bit 0 = second input asset in use?\\n            // bit 1 = second output asset in use?\\n            mstore(add(fullBridgeCallData, 0x160), eq(and(bitConfig, 1), 1)) // secondInputInUse (bitConfig & 1) == 1\\n            mstore(add(fullBridgeCallData, 0x180), eq(and(shr(1, bitConfig), 1), 1)) // secondOutputInUse ((bitConfig >> 1) & 1) == 1\\n        }\\n        fullBridgeCallData.bridgeAddress = supportedBridges[fullBridgeCallData.bridgeAddressId - 1];\\n        fullBridgeCallData.bridgeGasLimit = bridgeGasLimits[fullBridgeCallData.bridgeAddressId];\\n\\n        // potential conflicting states that are explicitly ruled out by circuit constraints:\\n        if (!fullBridgeCallData.secondInputInUse && fullBridgeCallData.inputAssetIdB > 0) {\\n            revert INCONSISTENT_BRIDGE_CALL_DATA();\\n        }\\n        if (!fullBridgeCallData.secondOutputInUse && fullBridgeCallData.outputAssetIdB > 0) {\\n            revert INCONSISTENT_BRIDGE_CALL_DATA();\\n        }\\n        if (\\n            fullBridgeCallData.secondInputInUse\\n                && (fullBridgeCallData.inputAssetIdA == fullBridgeCallData.inputAssetIdB)\\n        ) {\\n            revert BRIDGE_WITH_IDENTICAL_INPUT_ASSETS(fullBridgeCallData.inputAssetIdA);\\n        }\\n        // Outputs can both be virtual. In that case, their asset ids will both be 2 ** 29.\\n        bool secondOutputReal = fullBridgeCallData.secondOutputInUse && !fullBridgeCallData.secondOutputVirtual;\\n        if (secondOutputReal && fullBridgeCallData.outputAssetIdA == fullBridgeCallData.outputAssetIdB) {\\n            revert BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS(fullBridgeCallData.outputAssetIdA);\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the four input/output assets associated with a specific bridge call\\n     * @param _fullBridgeCallData a struct that contains information defining a specific bridge call\\n     * @param _interactionNonce interaction nonce of a corresponding bridge call\\n     * @dev `_interactionNonce` param is here because it is used as an ID of output virtual asset\\n     *\\n     * @return inputAssetA the first input asset\\n     * @return inputAssetB the second input asset\\n     * @return outputAssetA the first output asset\\n     * @return outputAssetB the second output asset\\n     */\\n    function getAztecAssetTypes(FullBridgeCallData memory _fullBridgeCallData, uint256 _interactionNonce)\\n        internal\\n        view\\n        returns (\\n            AztecTypes.AztecAsset memory inputAssetA,\\n            AztecTypes.AztecAsset memory inputAssetB,\\n            AztecTypes.AztecAsset memory outputAssetA,\\n            AztecTypes.AztecAsset memory outputAssetB\\n        )\\n    {\\n        if (_fullBridgeCallData.firstInputVirtual) {\\n            // asset id is a nonce of the interaction in which the virtual asset was created\\n            inputAssetA.id = _fullBridgeCallData.inputAssetIdA - VIRTUAL_ASSET_ID_FLAG;\\n            inputAssetA.erc20Address = address(0x0);\\n            inputAssetA.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else {\\n            inputAssetA.id = _fullBridgeCallData.inputAssetIdA;\\n            inputAssetA.erc20Address = getSupportedAsset(_fullBridgeCallData.inputAssetIdA);\\n            inputAssetA.assetType = inputAssetA.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        }\\n        if (_fullBridgeCallData.firstOutputVirtual) {\\n            // use nonce as asset id.\\n            outputAssetA.id = _interactionNonce;\\n            outputAssetA.erc20Address = address(0x0);\\n            outputAssetA.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else {\\n            outputAssetA.id = _fullBridgeCallData.outputAssetIdA;\\n            outputAssetA.erc20Address = getSupportedAsset(_fullBridgeCallData.outputAssetIdA);\\n            outputAssetA.assetType = outputAssetA.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        }\\n\\n        if (_fullBridgeCallData.secondInputVirtual) {\\n            // asset id is a nonce of the interaction in which the virtual asset was created\\n            inputAssetB.id = _fullBridgeCallData.inputAssetIdB - VIRTUAL_ASSET_ID_FLAG;\\n            inputAssetB.erc20Address = address(0x0);\\n            inputAssetB.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else if (_fullBridgeCallData.secondInputInUse) {\\n            inputAssetB.id = _fullBridgeCallData.inputAssetIdB;\\n            inputAssetB.erc20Address = getSupportedAsset(_fullBridgeCallData.inputAssetIdB);\\n            inputAssetB.assetType = inputAssetB.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        } else {\\n            inputAssetB.id = 0;\\n            inputAssetB.erc20Address = address(0x0);\\n            inputAssetB.assetType = AztecTypes.AztecAssetType.NOT_USED;\\n        }\\n\\n        if (_fullBridgeCallData.secondOutputVirtual) {\\n            // use nonce as asset id.\\n            outputAssetB.id = _interactionNonce;\\n            outputAssetB.erc20Address = address(0x0);\\n            outputAssetB.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else if (_fullBridgeCallData.secondOutputInUse) {\\n            outputAssetB.id = _fullBridgeCallData.outputAssetIdB;\\n            outputAssetB.erc20Address = getSupportedAsset(_fullBridgeCallData.outputAssetIdB);\\n            outputAssetB.assetType = outputAssetB.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        } else {\\n            outputAssetB.id = 0;\\n            outputAssetB.erc20Address = address(0x0);\\n            outputAssetB.assetType = AztecTypes.AztecAssetType.NOT_USED;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the length of the defi interaction hashes array and the number of pending interactions\\n     *\\n     * @return defiInteractionHashesLength the complete length of the defi interaction array\\n     * @return numPendingInteractions the current number of pending defi interactions\\n     * @dev `numPendingInteractions` is capped at `NUMBER_OF_BRIDGE_CALLS`\\n     */\\n    function getDefiHashesLengthsAndNumPendingInteractions()\\n        internal\\n        view\\n        returns (uint256 defiInteractionHashesLength, uint256 numPendingInteractions)\\n    {\\n        assembly {\\n            // retrieve the total length of the defi interactions array and also the number of pending interactions to a maximum of NUMBER_OF_BRIDGE_CALLS\\n            let state := sload(rollupState.slot)\\n            {\\n                defiInteractionHashesLength := and(ARRAY_LENGTH_MASK, shr(DEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n                numPendingInteractions := defiInteractionHashesLength\\n                if gt(numPendingInteractions, NUMBER_OF_BRIDGE_CALLS) {\\n                    numPendingInteractions := NUMBER_OF_BRIDGE_CALLS\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the set of hashes that comprise the current pending interactions and nextExpectedHash\\n     *\\n     * @return hashes the set of valid (i.e. non-zero) hashes that comprise the pending interactions\\n     * @return nextExpectedHash the hash of all hashes (including zero hashes) that comprise the pending interactions\\n     */\\n    function getPendingAndNextExpectedHashes()\\n        internal\\n        view\\n        returns (bytes32[] memory hashes, bytes32 nextExpectedHash)\\n    {\\n        /**\\n         * ----------------------------------------\\n         * Compute nextExpectedHash\\n         * -----------------------------------------\\n         *\\n         * The `defiInteractionHashes` mapping emulates an array that represents the\\n         * set of defi interactions from previous blocks that have been resolved.\\n         *\\n         * We need to take the interaction result data from each of the above defi interactions,\\n         * and add that data into the Aztec L2 merkle tree that contains defi interaction results\\n         * (the \\\"Defi Tree\\\". Its merkle root is one of the inputs to the storage variable `rollupStateHash`)\\n         *\\n         * It is the rollup provider's responsibility to perform these additions.\\n         * In the current block being processed, the rollup provider must take these pending interaction results,\\n         * create commitments to each result and insert each commitment into the next empty leaf of the defi tree.\\n         *\\n         * The following code validates that this has happened! This is how:\\n         *\\n         * Part 1: What are we checking?\\n         *\\n         * The rollup circuit will receive, as a private input from the rollup provider, the pending defi interaction\\n         * results\\n         * (`encodedBridgeCallData`, `totalInputValue`, `totalOutputValueA`, `totalOutputValueB`, `result`)\\n         * The rollup circuit will compute the SHA256 hash of each interaction result (the defiInteractionHash)\\n         * Finally the SHA256 hash of `NUMBER_OF_BRIDGE_CALLS` of these defiInteractionHash values is computed.\\n         * (if there are fewer than `NUMBER_OF_BRIDGE_CALLS` pending defi interaction results, the SHA256 hash of\\n         * an empty defi interaction result is used instead. i.e. all variable values are set to 0)\\n         * The computed SHA256 hash, the `pendingDefiInteractionHash`, is one of the broadcasted values that forms\\n         * the `publicInputsHash` public input to the rollup circuit.\\n         * When verifying a rollup proof, this smart contract will compute `publicInputsHash` from the input calldata.\\n         * The PLONK Verifier smart contract will then validate that our computed value for `publicInputHash` matches\\n         * the value used when generating the rollup proof.\\n         *\\n         * TLDR of the above: our proof data contains a variable called `pendingDefiInteractionHash`, which is\\n         * the CLAIMED VALUE of SHA256 hashing the SHA256 hashes of the defi interactions that have resolved but whose\\n         * data has not yet been added into the defi tree.\\n         *\\n         * Part 2: How do we check `pendingDefiInteractionHash` is correct???\\n         *\\n         * This contract will call `DefiBridgeProxy.convert` (via delegatecall) on every new defi interaction present\\n         * in the block. The return values from the bridge proxy contract are used to construct a defi interaction\\n         * result. Its hash is then computed and stored in `defiInteractionHashes`.\\n         *\\n         * N.B. It's very important that DefiBridgeProxy does not call selfdestruct, or makes a delegatecall out to\\n         *      a contract that can selfdestruct :o\\n         *\\n         * Similarly, when async defi interactions resolve, the interaction result is stored in\\n         * `asyncDefiInteractionHashes`. At the end of the processBridgeCalls function, the contents of the async array\\n         * is copied into `defiInteractionHashes` (i.e. async interaction results are delayed by 1 rollup block.\\n         * This is to prevent griefing attacks where the rollup state changes between the time taken for a rollup tx\\n         * to be constructed and the rollup tx to be mined)\\n         *\\n         * We use the contents of `defiInteractionHashes` to reconstruct `pendingDefiInteractionHash`, and validate it\\n         * matches the value present in calldata and therefore the value used in the rollup circuit when this block's\\n         * rollup proof was constructed. This validates that all of the required defi interaction results were added\\n         * into the defi tree by the rollup provider (the circuit logic enforces this, we just need to check the rollup\\n         * provider used the correct inputs)\\n         */\\n        (uint256 defiInteractionHashesLength, uint256 numPendingInteractions) =\\n            getDefiHashesLengthsAndNumPendingInteractions();\\n        uint256 offset = defiInteractionHashesLength - numPendingInteractions;\\n        assembly {\\n            // allocate the output array of hashes\\n            hashes := mload(0x40)\\n            let hashData := add(hashes, 0x20)\\n            // update the free memory pointer to point past the end of our array\\n            // our array will consume 32 bytes for the length field plus NUMBER_OF_BRIDGE_BYTES for all of the hashes\\n            mstore(0x40, add(hashes, add(NUMBER_OF_BRIDGE_BYTES, 0x20)))\\n            // set the length of hashes to only include the non-zero hash values\\n            // although this function will write all of the hashes into our allocated memory, we only want to return the non-zero hashes\\n            mstore(hashes, numPendingInteractions)\\n\\n            // Prepare the reusable part of the defi interaction hashes slot computation\\n            mstore(0x20, defiInteractionHashes.slot)\\n            let i := 0\\n\\n            // Iterate over numPendingInteractions (will be between 0 and NUMBER_OF_BRIDGE_CALLS)\\n            // Load defiInteractionHashes[offset + i] and store in memory\\n            // in order to compute SHA2 hash (nextExpectedHash)\\n            for {} lt(i, numPendingInteractions) { i := add(i, 0x01) } {\\n                // hashData[i] = defiInteractionHashes[offset + i]\\n                mstore(0x00, add(offset, i))\\n                mstore(add(hashData, mul(i, 0x20)), sload(keccak256(0x00, 0x40)))\\n            }\\n\\n            // If numPendingInteractions < NUMBER_OF_BRIDGE_CALLS, continue iterating up to NUMBER_OF_BRIDGE_CALLS, this time\\n            // inserting the \\\"zero hash\\\", the result of sha256(emptyDefiInteractionResult)\\n            for {} lt(i, NUMBER_OF_BRIDGE_CALLS) { i := add(i, 0x01) } {\\n                // hashData[i] = DEFI_RESULT_ZERO_HASH\\n                mstore(add(hashData, mul(i, 0x20)), DEFI_RESULT_ZERO_HASH)\\n            }\\n            pop(staticcall(gas(), 0x2, hashData, NUMBER_OF_BRIDGE_BYTES, 0x00, 0x20))\\n            nextExpectedHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n        }\\n    }\\n\\n    /**\\n     * @notice A function that processes bridge calls.\\n     * @dev 1. pop NUMBER_OF_BRIDGE_CALLS (if available) interaction hashes off of `defiInteractionHashes`,\\n     *         validate their hash (calculated at the end of the previous rollup and stored as\\n     *         nextExpectedDefiInteractionsHash) equals `numPendingInteractions` (this validates that rollup block\\n     *         has added these interaction results into the L2 data tree)\\n     *      2. iterate over rollup block's new defi interactions (up to NUMBER_OF_BRIDGE_CALLS). Trigger interactions\\n     *         by calling DefiBridgeProxy contract. Record results in either `defiInteractionHashes` (for synchrohnous\\n     *         txns) or, for async txns, the `pendingDefiInteractions` mapping\\n     *      3. copy the contents of `asyncInteractionHashes` into `defiInteractionHashes` && clear\\n     *         `asyncInteractionHashes`\\n     *      4. calculate the next value of nextExpectedDefiInteractionsHash from the new set of defiInteractionHashes\\n     * @param _proofData decoded rollup proof data\\n     * @param _rollupBeneficiary the address that should be paid any subsidy for processing a bridge call\\n     * @return nextExpectedHashes the set of non-zero hashes that comprise the current pending defi interactions\\n     */\\n    function processBridgeCalls(bytes memory _proofData, address _rollupBeneficiary)\\n        internal\\n        returns (bytes32[] memory nextExpectedHashes)\\n    {\\n        uint256 defiInteractionHashesLength;\\n        // Verify that nextExpectedDefiInteractionsHash equals the value given in the rollup\\n        // Then remove the set of pending hashes\\n        {\\n            // Extract the claimed value of previousDefiInteractionHash present in the proof data\\n            bytes32 providedDefiInteractionsHash = extractPrevDefiInteractionHash(_proofData);\\n\\n            // Validate the stored interactionHash matches the value used when making the rollup proof!\\n            if (providedDefiInteractionsHash != prevDefiInteractionsHash) {\\n                revert INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH(providedDefiInteractionsHash, prevDefiInteractionsHash);\\n            }\\n            uint256 numPendingInteractions;\\n            (defiInteractionHashesLength, numPendingInteractions) = getDefiHashesLengthsAndNumPendingInteractions();\\n            // numPendingInteraction equals the number of interactions expected to be in the given rollup\\n            // this is the length of the defiInteractionHashes array, capped at the NUM_BRIDGE_CALLS as per the following\\n            // numPendingInteractions = min(defiInteractionsHashesLength, numberOfBridgeCalls)\\n\\n            // Reduce DefiInteractionHashes.length by numPendingInteractions\\n            defiInteractionHashesLength -= numPendingInteractions;\\n\\n            assembly {\\n                // Update DefiInteractionHashes.length in storage\\n                let state := sload(rollupState.slot)\\n                let oldState := and(not(shl(DEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n                let newState := or(oldState, shl(DEFIINTERACTIONHASHES_BIT_OFFSET, defiInteractionHashesLength))\\n                sstore(rollupState.slot, newState)\\n            }\\n        }\\n        uint256 interactionNonce = getRollupId(_proofData) * NUMBER_OF_BRIDGE_CALLS;\\n\\n        // ### Process bridge calls\\n        uint256 proofDataPtr;\\n        assembly {\\n            proofDataPtr := add(_proofData, BRIDGE_CALL_DATAS_OFFSET)\\n        }\\n        BridgeResult memory bridgeResult;\\n        assembly {\\n            bridgeResult := mload(0x40)\\n            mstore(0x40, add(bridgeResult, 0x80))\\n        }\\n        for (uint256 i = 0; i < NUMBER_OF_BRIDGE_CALLS;) {\\n            uint256 encodedBridgeCallData;\\n            assembly {\\n                encodedBridgeCallData := mload(proofDataPtr)\\n            }\\n            if (encodedBridgeCallData == 0) {\\n                // no more bridges to call\\n                break;\\n            }\\n            uint256 totalInputValue;\\n            assembly {\\n                totalInputValue := mload(add(proofDataPtr, mul(0x20, NUMBER_OF_BRIDGE_CALLS)))\\n            }\\n            if (totalInputValue == 0) {\\n                revert ZERO_TOTAL_INPUT_VALUE();\\n            }\\n\\n            FullBridgeCallData memory fullBridgeCallData = getFullBridgeCallData(encodedBridgeCallData);\\n\\n            (\\n                AztecTypes.AztecAsset memory inputAssetA,\\n                AztecTypes.AztecAsset memory inputAssetB,\\n                AztecTypes.AztecAsset memory outputAssetA,\\n                AztecTypes.AztecAsset memory outputAssetB\\n            ) = getAztecAssetTypes(fullBridgeCallData, interactionNonce);\\n            assembly {\\n                // call the following function of DefiBridgeProxy via delegatecall...\\n                //     function convert(\\n                //          address bridgeAddress,\\n                //          AztecTypes.AztecAsset calldata inputAssetA,\\n                //          AztecTypes.AztecAsset calldata inputAssetB,\\n                //          AztecTypes.AztecAsset calldata outputAssetA,\\n                //          AztecTypes.AztecAsset calldata outputAssetB,\\n                //          uint256 totalInputValue,\\n                //          uint256 interactionNonce,\\n                //          uint256 auxInputData,\\n                //          uint256 ethPaymentsSlot,\\n                //          address rollupBeneficary\\n                //     )\\n\\n                // Construct the calldata we send to DefiBridgeProxy\\n                // mPtr = memory pointer. Set to free memory location (0x40)\\n                let mPtr := mload(0x40)\\n                // first 4 bytes is the function signature\\n                mstore(mPtr, DEFI_BRIDGE_PROXY_CONVERT_SELECTOR)\\n                mPtr := add(mPtr, 0x04)\\n\\n                let bridgeAddress := mload(add(fullBridgeCallData, 0x20))\\n                mstore(mPtr, bridgeAddress)\\n                mstore(add(mPtr, 0x20), mload(inputAssetA))\\n                mstore(add(mPtr, 0x40), mload(add(inputAssetA, 0x20)))\\n                mstore(add(mPtr, 0x60), mload(add(inputAssetA, 0x40)))\\n                mstore(add(mPtr, 0x80), mload(inputAssetB))\\n                mstore(add(mPtr, 0xa0), mload(add(inputAssetB, 0x20)))\\n                mstore(add(mPtr, 0xc0), mload(add(inputAssetB, 0x40)))\\n                mstore(add(mPtr, 0xe0), mload(outputAssetA))\\n                mstore(add(mPtr, 0x100), mload(add(outputAssetA, 0x20)))\\n                mstore(add(mPtr, 0x120), mload(add(outputAssetA, 0x40)))\\n                mstore(add(mPtr, 0x140), mload(outputAssetB))\\n                mstore(add(mPtr, 0x160), mload(add(outputAssetB, 0x20)))\\n                mstore(add(mPtr, 0x180), mload(add(outputAssetB, 0x40)))\\n                mstore(add(mPtr, 0x1a0), totalInputValue)\\n                mstore(add(mPtr, 0x1c0), interactionNonce)\\n\\n                let auxData := mload(add(fullBridgeCallData, 0xc0))\\n                mstore(add(mPtr, 0x1e0), auxData)\\n                mstore(add(mPtr, 0x200), ethPayments.slot)\\n                mstore(add(mPtr, 0x220), _rollupBeneficiary)\\n\\n                // Call the bridge proxy via delegatecall!\\n                // We want the proxy to share state with the rollup processor, as the proxy is the entity\\n                // sending/recovering tokens from the bridge contracts. We wrap this logic in a delegatecall so that\\n                // if the call fails (i.e. the bridge interaction fails), we can unwind bridge-interaction specific\\n                // state changes without reverting the entire transaction.\\n                let bridgeProxy := sload(defiBridgeProxy.slot)\\n                if iszero(extcodesize(bridgeProxy)) {\\n                    mstore(0, INVALID_ADDRESS_NO_CODE_SELECTOR)\\n                    revert(0, 0x4)\\n                }\\n                let success :=\\n                    delegatecall(\\n                        mload(add(fullBridgeCallData, 0x1a0)), // fullBridgeCallData.bridgeGasLimit\\n                        bridgeProxy,\\n                        sub(mPtr, 0x04),\\n                        0x244,\\n                        0,\\n                        0\\n                    )\\n                returndatacopy(mPtr, 0, returndatasize())\\n\\n                switch success\\n                case 1 {\\n                    mstore(bridgeResult, mload(mPtr)) // outputValueA\\n                    mstore(add(bridgeResult, 0x20), mload(add(mPtr, 0x20))) // outputValueB\\n                    mstore(add(bridgeResult, 0x40), mload(add(mPtr, 0x40))) // isAsync\\n                    mstore(add(bridgeResult, 0x60), 1) // success\\n                }\\n                default {\\n                    // If the call failed, mark this interaction as failed. No tokens have been exchanged, users can\\n                    // use the \\\"claim\\\" circuit to recover the initial tokens they sent to the bridge\\n                    mstore(bridgeResult, 0) // outputValueA\\n                    mstore(add(bridgeResult, 0x20), 0) // outputValueB\\n                    mstore(add(bridgeResult, 0x40), 0) // isAsync\\n                    mstore(add(bridgeResult, 0x60), 0) // success\\n                }\\n            }\\n\\n            if (!fullBridgeCallData.secondOutputInUse) {\\n                bridgeResult.outputValueB = 0;\\n            }\\n\\n            // emit events and update state\\n            assembly {\\n                // if interaction is Async, update pendingDefiInteractions\\n                // if interaction is synchronous, compute the interaction hash and add to defiInteractionHashes\\n                switch mload(add(bridgeResult, 0x40))\\n                // switch isAsync\\n                case 1 {\\n                    let mPtr := mload(0x40)\\n                    // emit AsyncDefiBridgeProcessed(indexed encodedBridgeCallData, indexed interactionNonce, totalInputValue)\\n                    {\\n                        mstore(mPtr, totalInputValue)\\n                        log3(mPtr, 0x20, ASYNC_BRIDGE_PROCESSED_SIGHASH, encodedBridgeCallData, interactionNonce)\\n                    }\\n                    // pendingDefiInteractions[interactionNonce] = PendingDefiBridgeInteraction(encodedBridgeCallData, totalInputValue)\\n                    mstore(0x00, interactionNonce)\\n                    mstore(0x20, pendingDefiInteractions.slot)\\n                    let pendingDefiInteractionsSlotBase := keccak256(0x00, 0x40)\\n\\n                    sstore(pendingDefiInteractionsSlotBase, encodedBridgeCallData)\\n                    sstore(add(pendingDefiInteractionsSlotBase, 0x01), totalInputValue)\\n                }\\n                default {\\n                    let mPtr := mload(0x40)\\n                    // prepare the data required to publish the DefiBridgeProcessed event, we will only publish it if\\n                    // isAsync == false\\n                    // async interactions that have failed, have their isAsync property modified to false above\\n                    // emit DefiBridgeProcessed(indexed encodedBridgeCallData, indexed interactionNonce, totalInputValue, outputValueA, outputValueB, success)\\n\\n                    {\\n                        mstore(mPtr, totalInputValue)\\n                        mstore(add(mPtr, 0x20), mload(bridgeResult)) // outputValueA\\n                        mstore(add(mPtr, 0x40), mload(add(bridgeResult, 0x20))) // outputValueB\\n                        mstore(add(mPtr, 0x60), mload(add(bridgeResult, 0x60))) // success\\n                        mstore(add(mPtr, 0x80), 0xa0) // position in event data block of `bytes` object\\n\\n                        if mload(add(bridgeResult, 0x60)) {\\n                            mstore(add(mPtr, 0xa0), 0)\\n                            log3(mPtr, 0xc0, DEFI_BRIDGE_PROCESSED_SIGHASH, encodedBridgeCallData, interactionNonce)\\n                        }\\n                        if iszero(mload(add(bridgeResult, 0x60))) {\\n                            mstore(add(mPtr, 0xa0), returndatasize())\\n                            let size := returndatasize()\\n                            let remainder := mul(iszero(iszero(size)), sub(32, mod(size, 32)))\\n                            returndatacopy(add(mPtr, 0xc0), 0, size)\\n                            mstore(add(mPtr, add(0xc0, size)), 0)\\n                            log3(\\n                                mPtr,\\n                                add(0xc0, add(size, remainder)),\\n                                DEFI_BRIDGE_PROCESSED_SIGHASH,\\n                                encodedBridgeCallData,\\n                                interactionNonce\\n                            )\\n                        }\\n                    }\\n                    // compute defiInteractionnHash\\n                    mstore(mPtr, encodedBridgeCallData)\\n                    mstore(add(mPtr, 0x20), interactionNonce)\\n                    mstore(add(mPtr, 0x40), totalInputValue)\\n                    mstore(add(mPtr, 0x60), mload(bridgeResult)) // outputValueA\\n                    mstore(add(mPtr, 0x80), mload(add(bridgeResult, 0x20))) // outputValueB\\n                    mstore(add(mPtr, 0xa0), mload(add(bridgeResult, 0x60))) // success\\n                    pop(staticcall(gas(), 0x2, mPtr, 0xc0, 0x00, 0x20))\\n                    let defiInteractionHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n\\n                    // defiInteractionHashes[defiInteractionHashesLength] = defiInteractionHash;\\n                    mstore(0x00, defiInteractionHashesLength)\\n                    mstore(0x20, defiInteractionHashes.slot)\\n                    sstore(keccak256(0x00, 0x40), defiInteractionHash)\\n\\n                    // Increase the length of defiInteractionHashes by 1\\n                    defiInteractionHashesLength := add(defiInteractionHashesLength, 0x01)\\n                }\\n\\n                // advance interactionNonce and proofDataPtr\\n                interactionNonce := add(interactionNonce, 0x01)\\n                proofDataPtr := add(proofDataPtr, 0x20)\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        assembly {\\n            /**\\n             * Cleanup\\n             *\\n             * 1. Copy asyncDefiInteractionHashes into defiInteractionHashes\\n             * 2. Update defiInteractionHashes.length\\n             * 2. Clear asyncDefiInteractionHashes.length\\n             */\\n            let state := sload(rollupState.slot)\\n\\n            let asyncDefiInteractionHashesLength :=\\n                and(ARRAY_LENGTH_MASK, shr(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n\\n            // Validate we are not overflowing our 1024 array size\\n            let arrayOverflow :=\\n                gt(add(asyncDefiInteractionHashesLength, defiInteractionHashesLength), ARRAY_LENGTH_MASK)\\n\\n            // Throw an error if defiInteractionHashesLength > ARRAY_LENGTH_MASK (i.e. is >= 1024)\\n            // should never hit this! If block `i` generates synchronous txns,\\n            // block 'i + 1' must process them.\\n            // Only way this array size hits 1024 is if we produce a glut of async interaction results\\n            // between blocks. HOWEVER we ensure that async interaction callbacks fail if they would increase\\n            // defiInteractionHashes length to be >= 512\\n            // Still, can't hurt to check...\\n            if arrayOverflow {\\n                mstore(0, ARRAY_OVERFLOW_SELECTOR)\\n                revert(0, 0x4)\\n            }\\n\\n            // Now, copy async hashes into defiInteractionHashes\\n\\n            // Cache the free memory pointer\\n            let freePtr := mload(0x40)\\n\\n            // Prepare the reusable parts of slot computation\\n            mstore(0x20, defiInteractionHashes.slot)\\n            mstore(0x60, asyncDefiInteractionHashes.slot)\\n            for { let i := 0 } lt(i, asyncDefiInteractionHashesLength) { i := add(i, 1) } {\\n                // defiInteractionHashesLength[defiInteractionHashesLength + i] = asyncDefiInteractionHashes[i]\\n                mstore(0x00, add(defiInteractionHashesLength, i))\\n                mstore(0x40, i)\\n                sstore(keccak256(0x00, 0x40), sload(keccak256(0x40, 0x40)))\\n            }\\n            // Restore the free memory pointer\\n            mstore(0x40, freePtr)\\n\\n            // clear defiInteractionHashesLength in state\\n            state := and(not(shl(DEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n\\n            // write new defiInteractionHashesLength in state\\n            state :=\\n                or(\\n                    shl(\\n                        DEFIINTERACTIONHASHES_BIT_OFFSET, add(asyncDefiInteractionHashesLength, defiInteractionHashesLength)\\n                    ),\\n                    state\\n                )\\n\\n            // clear asyncDefiInteractionHashesLength in state\\n            state := and(not(shl(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n\\n            // write new state\\n            sstore(rollupState.slot, state)\\n        }\\n\\n        // now we want to extract the next set of pending defi interaction hashes and calculate their hash to store\\n        // for the next rollup\\n        (bytes32[] memory hashes, bytes32 nextExpectedHash) = getPendingAndNextExpectedHashes();\\n        nextExpectedHashes = hashes;\\n        prevDefiInteractionsHash = nextExpectedHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\ninterface IVerifier {\\n    function verify(bytes memory _serializedProof, uint256 _publicInputsHash) external returns (bool);\\n\\n    function getVerificationKeyHash() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/rollup-encoder/src/interfaces/IRollupProcessorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IRollupProcessor} from \\\"./IRollupProcessor.sol\\\";\\n\\n// @dev For documentation of the functions within this interface see RollupProcessorV2 contract\\ninterface IRollupProcessorV2 is IRollupProcessor {\\n    function getCapped() external view returns (bool);\\n\\n    function defiInteractionHashes(uint256) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/core/interfaces/IDefiBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {AztecTypes} from \\\"rollup-encoder/libraries/AztecTypes.sol\\\";\\n\\ninterface IDefiBridge {\\n    /**\\n     * @notice A function which converts input assets to output assets.\\n     * @param _inputAssetA A struct detailing the first input asset\\n     * @param _inputAssetB A struct detailing the second input asset\\n     * @param _outputAssetA A struct detailing the first output asset\\n     * @param _outputAssetB A struct detailing the second output asset\\n     * @param _totalInputValue An amount of input assets transferred to the bridge (Note: \\\"total\\\" is in the name\\n     *                         because the value can represent summed/aggregated token amounts of users actions on L2)\\n     * @param _interactionNonce A globally unique identifier of this interaction/`convert(...)` call.\\n     * @param _auxData Bridge specific data to be passed into the bridge contract (e.g. slippage, nftID etc.)\\n     * @return outputValueA An amount of `_outputAssetA` returned from this interaction.\\n     * @return outputValueB An amount of `_outputAssetB` returned from this interaction.\\n     * @return isAsync A flag indicating if the interaction is async.\\n     * @dev This function is called from the RollupProcessor contract via the DefiBridgeProxy. Before this function is\\n     *      called _RollupProcessor_ contract will have sent you all the assets defined by the input params. This\\n     *      function is expected to convert input assets to output assets (e.g. on Uniswap) and return the amounts\\n     *      of output assets to be received by the _RollupProcessor_. If output assets are ERC20 tokens the bridge has\\n     *      to set _RollupProcessor_ as a spender before the interaction is finished. If some of the output assets is ETH\\n     *      it has to be sent to _RollupProcessor_ via the `receiveEthFromBridge(uint256 _interactionNonce)` method\\n     *      before the `convert(...)` function call finishes.\\n     * @dev If there are two input assets, equal amounts of both assets will be transferred to the bridge before this\\n     *      method is called.\\n     * @dev **BOTH** output assets could be virtual but since their `assetId` is currently assigned as\\n     *      `_interactionNonce` it would simply mean that more of the same virtual asset is minted.\\n     * @dev If this interaction is async the function has to return `(0, 0, true)`. Async interaction will be finalised at\\n     *      a later time and its output assets will be returned in a `IDefiBridge.finalise(...)` call.\\n     *\\n     */\\n    function convert(\\n        AztecTypes.AztecAsset calldata _inputAssetA,\\n        AztecTypes.AztecAsset calldata _inputAssetB,\\n        AztecTypes.AztecAsset calldata _outputAssetA,\\n        AztecTypes.AztecAsset calldata _outputAssetB,\\n        uint256 _totalInputValue,\\n        uint256 _interactionNonce,\\n        uint64 _auxData,\\n        address _rollupBeneficiary\\n    ) external payable returns (uint256 outputValueA, uint256 outputValueB, bool isAsync);\\n\\n    /**\\n     * @notice A function that finalises asynchronous interaction.\\n     * @param _inputAssetA A struct detailing the first input asset\\n     * @param _inputAssetB A struct detailing the second input asset\\n     * @param _outputAssetA A struct detailing the first output asset\\n     * @param _outputAssetB A struct detailing the second output asset\\n     * @param _interactionNonce A globally unique identifier of this interaction/`convert(...)` call.\\n     * @param _auxData Bridge specific data to be passed into the bridge contract (e.g. slippage, nftID etc.)\\n     * @return outputValueA An amount of `_outputAssetA` returned from this interaction.\\n     * @return outputValueB An amount of `_outputAssetB` returned from this interaction.\\n     * @return interactionComplete A flag indicating whether an async interaction was successfully completed/finalised.\\n     * @dev This function should use the `BridgeBase.onlyRollup()` modifier to ensure it can only be called from\\n     *      the `RollupProcessor.processAsyncDefiInteraction(uint256 _interactionNonce)` method.\\n     *\\n     */\\n    function finalise(\\n        AztecTypes.AztecAsset calldata _inputAssetA,\\n        AztecTypes.AztecAsset calldata _inputAssetB,\\n        AztecTypes.AztecAsset calldata _outputAssetA,\\n        AztecTypes.AztecAsset calldata _outputAssetB,\\n        uint256 _interactionNonce,\\n        uint64 _auxData\\n    ) external payable returns (uint256 outputValueA, uint256 outputValueB, bool interactionComplete);\\n}\\n\"\r\n    },\r\n    \"src/core/Decoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n/**\\n * ----------------------------------------\\n *  PROOF DATA SPECIFICATION\\n * ----------------------------------------\\n * Our input \\\"proof data\\\" is represented as a single byte array - we use custom encoding to encode the\\n * data associated with a rollup block. The encoded structure is as follows (excluding the length param of the bytes type):\\n *\\n *    | byte range      | num bytes        | name                             | description |\\n *    | ---             | ---              | ---                              | ---         |\\n *    | 0x00  - 0x20    | 32               | rollupId                         | Unique rollup block identifier. Equivalent to block number |\\n *    | 0x20  - 0x40    | 32               | rollupSize                       | Max number of transactions in the block |\\n *    | 0x40  - 0x60    | 32               | dataStartIndex                   | Position of the next empty slot in the Aztec data tree |\\n *    | 0x60  - 0x80    | 32               | oldDataRoot                      | Root of the data tree prior to rollup block's state updates |\\n *    | 0x80  - 0xa0    | 32               | newDataRoot                      | Root of the data tree after rollup block's state updates |\\n *    | 0xa0  - 0xc0    | 32               | oldNullRoot                      | Root of the nullifier tree prior to rollup block's state updates |\\n *    | 0xc0  - 0xe0    | 32               | newNullRoot                      | Root of the nullifier tree after rollup block's state updates |\\n *    | 0xe0  - 0x100   | 32               | oldDataRootsRoot                 | Root of the tree of data tree roots prior to rollup block's state updates |\\n *    | 0x100 - 0x120   | 32               | newDataRootsRoot                 | Root of the tree of data tree roots after rollup block's state updates |\\n *    | 0x120 - 0x140   | 32               | oldDefiRoot                      | Root of the defi tree prior to rollup block's state updates |\\n *    | 0x140 - 0x160   | 32               | newDefiRoot                      | Root of the defi tree after rollup block's state updates |\\n *    | 0x160 - 0x560   | 1024             | encodedBridgeCallDatas[NUMBER_OF_BRIDGE_CALLS]   | Size-32 array of encodedBridgeCallDatas for bridges being called in this block. If encodedBridgeCallData == 0, no bridge is called |\\n *    | 0x560 - 0x960   | 1024             | depositSums[NUMBER_OF_BRIDGE_CALLS] | Size-32 array of deposit values being sent to bridges which are called in this block |\\n *    | 0x960 - 0xb60   | 512              | assetIds[NUMBER_OF_ASSETS]         | Size-16 array of assetIds which correspond to assets being used to pay fees in this block |\\n *    | 0xb60 - 0xd60   | 512              | txFees[NUMBER_OF_ASSETS]           | Size-16 array of transaction fees paid to the rollup beneficiary, denominated in each assetId |\\n *    | 0xd60 - 0x1160  | 1024             | interactionNotes[NUMBER_OF_BRIDGE_CALLS] | Size-32 array of defi interaction result commitments that must be inserted into the defi tree at this rollup block |\\n *    | 0x1160 - 0x1180 | 32               | prevDefiInteractionHash          | A SHA256 hash of the data used to create each interaction result commitment. Used to validate correctness of interactionNotes |\\n *    | 0x1180 - 0x11a0 | 32               | rollupBeneficiary                | The address that the fees from this rollup block should be sent to. Prevents a rollup proof being taken from the transaction pool and having its fees redirected |\\n *    | 0x11a0 - 0x11c0 | 32               | numRollupTxs                     | Number of \\\"inner rollup\\\" proofs used to create the block proof. \\\"inner rollup\\\" circuits process 3-28 user txns, the outer rollup circuit processes 1-28 inner rollup proofs. |\\n *    | 0x11c0 - 0x11c4 | 4                | numRealTxs                       | Number of transactions in the rollup excluding right-padded padding proofs |\\n *    | 0x11c4 - 0x11c8 | 4                | encodedInnerTxData.length        | Number of bytes of encodedInnerTxData |\\n *    | 0x11c8 - end    | encodedInnerTxData.length | encodedInnerTxData      | Encoded inner transaction data. Contains encoded form of the broadcasted data associated with each tx in the rollup block |\\n *\\n */\\n\\n/**\\n * --------------------------------------------\\n *  DETERMINING THE NUMBER OF REAL TRANSACTIONS\\n * --------------------------------------------\\n * The `rollupSize` parameter describes the MAX number of txns in a block.\\n * However the block may not be full.\\n * Incomplete blocks will be padded with \\\"padding\\\" transactions that represent empty txns.\\n *\\n * The amount of end padding is not explicitly defined in `proofData`. It is derived.\\n * The encodedInnerTxData does not include tx data for the txns associated with this end padding.\\n * (it does include any padding transactions that are not part of the end padding, which can sometimes happen)\\n * When decoded, the transaction data for each transaction is a fixed size (256 bytes)\\n * Number of real transactions = rollupSize - (decoded tx data size / 256)\\n *\\n * The decoded transaction data associated with padding transactions is 256 zero bytes.\\n *\\n */\\n\\n/**\\n * @title Decoder\\n * @dev contains functions for decoding/extracting the encoded proof data passed in as calldata,\\n * as well as computing the SHA256 hash of the decoded data (publicInputsHash).\\n * The publicInputsHash is used to ensure the data passed in as calldata matches the data used within the rollup circuit\\n */\\ncontract Decoder {\\n    /*----------------------------------------\\n      CONSTANTS\\n      ----------------------------------------*/\\n    uint256 internal constant NUMBER_OF_ASSETS = 16; // max number of assets in a block\\n    uint256 internal constant NUMBER_OF_BRIDGE_CALLS = 32; // max number of bridge calls in a block\\n    uint256 internal constant NUMBER_OF_BRIDGE_BYTES = 1024; // NUMBER_OF_BRIDGE_CALLS * 32\\n    uint256 internal constant NUMBER_OF_PUBLIC_INPUTS_PER_TX = 8; // number of ZK-SNARK \\\"public inputs\\\" per join-split/account/claim transaction\\n    uint256 internal constant TX_PUBLIC_INPUT_LENGTH = 256; // byte-length of NUMBER_OF_PUBLIC_INPUTS_PER_TX. NUMBER_OF_PUBLIC_INPUTS_PER_TX * 32;\\n    uint256 internal constant ROLLUP_NUM_HEADER_INPUTS = 142; // 58; // number of ZK-SNARK \\\"public inputs\\\" that make up the rollup header 14 + (NUMBER_OF_BRIDGE_CALLS * 3) + (NUMBER_OF_ASSETS * 2);\\n    uint256 internal constant ROLLUP_HEADER_LENGTH = 4544; // 1856; // ROLLUP_NUM_HEADER_INPUTS * 32;\\n\\n    // ENCODED_PROOF_DATA_LENGTH_OFFSET = byte offset into the rollup header such that `numRealTransactions` occupies\\n    // the least significant 4 bytes of the 32-byte word being pointed to.\\n    // i.e. ROLLUP_HEADER_LENGTH - 28\\n    uint256 internal constant NUM_REAL_TRANSACTIONS_OFFSET = 4516;\\n\\n    // ENCODED_PROOF_DATA_LENGTH_OFFSET = byte offset into the rollup header such that `encodedInnerProofData.length` occupies\\n    // the least significant 4 bytes of the 32-byte word being pointed to.\\n    // i.e. ROLLUP_HEADER_LENGTH - 24\\n    uint256 internal constant ENCODED_PROOF_DATA_LENGTH_OFFSET = 4520;\\n\\n    // offset we add to `proofData` to point to the encodedBridgeCallDatas\\n    uint256 internal constant BRIDGE_CALL_DATAS_OFFSET = 0x180;\\n\\n    // offset we add to `proofData` to point to prevDefiInteractionhash\\n    uint256 internal constant PREVIOUS_DEFI_INTERACTION_HASH_OFFSET = 4480; // ROLLUP_HEADER_LENGTH - 0x40\\n\\n    // offset we add to `proofData` to point to rollupBeneficiary\\n    uint256 internal constant ROLLUP_BENEFICIARY_OFFSET = 4512; // ROLLUP_HEADER_LENGTH - 0x20\\n\\n    // CIRCUIT_MODULUS = group order of the BN254 elliptic curve. All arithmetic gates in our ZK-SNARK circuits are evaluated modulo this prime.\\n    // Is used when computing the public inputs hash - our SHA256 hash outputs are reduced modulo CIRCUIT_MODULUS\\n    uint256 internal constant CIRCUIT_MODULUS =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    // SHA256 hashes\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_1 =\\n        0x22dd983f8337d97d56071f7986209ab2ee6039a422242e89126701c6ee005af0;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_2 =\\n        0x076a27c79e5ace2a3d47f9dd2e83e4ff6ea8872b3c2218f66c92b89b55f36560;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_4 =\\n        0x2f0c70a5bf5460465e9902f9c96be324e8064e762a5de52589fdb97cbce3c6ee;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_8 =\\n        0x240ed0de145447ff0ceff2aa477f43e0e2ed7f3543ee3d8832f158ec76b183a9;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_16 =\\n        0x1c52c159b4dae66c3dcf33b44d4d61ead6bc4d260f882ac6ba34dccf78892ca4;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_32 =\\n        0x0df0e06ab8a02ce2ff08babd7144ab23ca2e99ddf318080cf88602eeb8913d44;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_64 =\\n        0x1f83672815ac9b3ca31732d641784035834e96b269eaf6a2e759bf4fcc8e5bfd;\\n\\n    uint256 internal constant ADDRESS_MASK = 0x00_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff;\\n\\n    /*----------------------------------------\\n      ERROR TAGS\\n      ----------------------------------------*/\\n    error ENCODING_BYTE_INVALID();\\n    error INVALID_ROLLUP_TOPOLOGY();\\n\\n    /*----------------------------------------\\n      DECODING FUNCTIONS\\n      ----------------------------------------*/\\n    /**\\n     * In `bytes proofData`, transaction data is appended after the rollup header data\\n     * Each transaction is described by 8 'public inputs' used to create a user transaction's ZK-SNARK proof\\n     * (i.e. there are 8 public inputs for each of the \\\"join-split\\\", \\\"account\\\" and \\\"claim\\\" circuits)\\n     * The public inputs are represented in calldata according to the following specification:\\n     *\\n     * | public input idx | calldata size (bytes) | variable description                         |\\n     * | 0                | 1                     | proofId - transaction type identifier        |\\n     * | 1                | 32                    | encrypted form of 1st output note            |\\n     * | 2                | 32                    | encrypted form of 2nd output note            |\\n     * | 3                | 32                    | nullifier of 1st input note                  |\\n     * | 4                | 32                    | nullifier of 2nd input note                  |\\n     * | 5                | 32                    | amount being deposited or withdrawn          |\\n     * | 6                | 20                    | address of depositor or withdraw destination |\\n     * | 7                | 4                     | assetId used in transaction                  |\\n     *\\n     * The following table maps proofId values to transaction types\\n     *\\n     *\\n     * | proofId | tx type     | description |\\n     * | ---     | ---         | ---         |\\n     * | 0       | padding     | empty transaction. Rollup blocks have a fixed number of txns. If number of real txns is less than block size, padding txns make up the difference |\\n     * | 1       | deposit     | deposit Eth/tokens into Aztec in exchange for encrypted Aztec notes |\\n     * | 2       | withdraw    | exchange encrypted Aztec notes for Eth/tokens sent to a public address |\\n     * | 3       | send        | private send |\\n     * | 4       | account     | creates an Aztec account |\\n     * | 5       | defiDeposit | deposit Eth/tokens into a L1 smart contract via a Defi bridge contract |\\n     * | 6       | defiClaim   | convert proceeds of defiDeposit tx back into encrypted Aztec notes |\\n     *\\n     * Most of the above transaction types do not use the full set of 8 public inputs (i.e. some are zero).\\n     * To save on calldata costs, we encode each transaction into the smallest payload possible.\\n     * In `decodeProof`, the encoded transaction data is decoded and written into memory\\n     *\\n     * As part of the decoding algorithms we must convert the 20-byte `publicOwner` and 4-byte `assetId` fields\\n     * into 32-byte EVM words\\n     *\\n     * The following functions perform transaction-specific decoding. The `proofId` field is decoded prior to calling these functions\\n     */\\n\\n    /**\\n     * @notice Decodes a padding tx\\n     * @param _inPtr location in calldata of the encoded transaction\\n     * @return - a location in calldata of the next encoded transaction\\n     *\\n     * @dev Encoded padding tx consists of 1 byte, the `proofId`\\n     *      The `proofId` has been written into memory before we called this function so there is nothing to copy\\n     *      Advance the calldatapointer by 1 byte to move to the next transaction\\n     */\\n    function paddingTx(uint256 _inPtr, uint256) internal pure returns (uint256) {\\n        unchecked {\\n            return (_inPtr + 0x1);\\n        }\\n    }\\n\\n    /**\\n     * @notice Decodes a deposit or a withdraw tx\\n     * @param _inPtr location in calldata of the encoded transaction\\n     * @param _outPtr location in memory to write the decoded transaction to\\n     * @return - location in calldata of the next encoded transaction\\n     *\\n     * @dev The deposit tx uses all 8 public inputs. All calldata is copied into memory.\\n     */\\n    function depositOrWithdrawTx(uint256 _inPtr, uint256 _outPtr) internal pure returns (uint256) {\\n        // Copy deposit calldata into memory\\n        assembly {\\n            // start copying into `outPtr + 0x20`, as `outPtr` points to `proofId`, which has already been written into memory\\n            calldatacopy(add(_outPtr, 0x20), add(_inPtr, 0x20), 0xa0) // noteCommitment{1, 2}, nullifier{1,2}, publicValue; 32*5 bytes\\n            calldatacopy(add(_outPtr, 0xcc), add(_inPtr, 0xc0), 0x14) // convert 20-byte `publicOwner` calldata variable into 32-byte EVM word\\n            calldatacopy(add(_outPtr, 0xfc), add(_inPtr, 0xd4), 0x4) // convert 4-byte `assetId` variable into 32-byte EVM word\\n        }\\n        // advance calldata ptr by 185 bytes\\n        unchecked {\\n            return (_inPtr + 0xb9);\\n        }\\n    }\\n\\n    /**\\n     * @notice Decodes a send-type tx\\n     * @param _inPtr location in calldata of the encoded transaction\\n     * @param _outPtr location in memory to write the decoded transaction to\\n     * @return - location in calldata of the next encoded transaction\\n     *\\n     * @dev The send tx has 0-values for `publicValue`, `publicOwner` and `assetId`\\n     *      No need to copy anything into memory for these fields as memory defaults to 0\\n     */\\n    function sendTx(uint256 _inPtr, uint256 _outPtr) internal pure returns (uint256) {\\n        assembly {\\n            calldatacopy(add(_outPtr, 0x20), add(_inPtr, 0x20), 0x80) // noteCommitment{1, 2}, nullifier{1,2}; 32*4 bytes\\n        }\\n        unchecked {\\n            return (_inPtr + 0x81);\\n        }\\n    }\\n\\n    /**\\n     * @notice Decodes an account creation tx\\n     * @param _inPtr location in calldata of the encoded transaction\\n     * @param _outPtr location in memory to write the decoded transaction to\\n     * @return - location in calldata of the next encoded transaction\\n     *\\n     * @dev The account tx has 0-values for `nullifier2`, `publicValue`, `publicOwner` and `assetId`\\n     *      No need to copy anything into memory for these fields as memory defaults to 0\\n     */\\n    function accountTx(uint256 _inPtr, uint256 _outPtr) internal pure returns (uint256) {\\n        assembly {\\n            calldatacopy(add(_outPtr, 0x20), add(_inPtr, 0x20), 0x80) // noteCommitment{1, 2}, nullifier{1,2}; 32*4 bytes\\n        }\\n        unchecked {\\n            return (_inPtr + 0x81);\\n        }\\n    }\\n\\n    /**\\n     * @notice Decodes a defi deposit or claim tx\\n     * @param _inPtr location in calldata of the encoded transaction\\n     * @param _outPtr location in memory to write the decoded transaction to\\n     * @return - location in calldata of the next encoded transaction\\n     *\\n     * @dev The defi deposit/claim tx has 0-values for `publicValue`, `publicOwner` and `assetId`\\n     *      No need to copy anything into memory for these fields as memory defaults to 0\\n     */\\n    function defiDepositOrClaimTx(uint256 _inPtr, uint256 _outPtr) internal pure returns (uint256) {\\n        assembly {\\n            calldatacopy(add(_outPtr, 0x20), add(_inPtr, 0x20), 0x80) // noteCommitment{1, 2}, nullifier{1,2}; 32*4 bytes\\n        }\\n        unchecked {\\n            return (_inPtr + 0x81);\\n        }\\n    }\\n\\n    /**\\n     * @notice Throws an error and reverts.\\n     * @dev If we hit this, there is a transaction whose proofId is invalid (i.e. not 0 to 7).\\n     */\\n    function invalidTx(uint256, uint256) internal pure returns (uint256) {\\n        revert ENCODING_BYTE_INVALID();\\n    }\\n\\n    /**\\n     * @notice Decodes the rollup block's proof data\\n     * @dev This function converts the proof data into a representation we can work with in memory\\n     *      In particular, encoded transaction calldata is decoded and written into memory\\n     *      The rollup header is copied from calldata into memory as well\\n     * @return proofData a memory pointer to the decoded proof data\\n     * @return numTxs number of transactions in the rollup, excluding end-padding transactions\\n     * @return publicInputsHash sha256 hash of the public inputs\\n     *\\n     * @dev The `publicInputsHash` is a sha256 hash of the public inputs associated with each transaction in the rollup.\\n     *      It is used to validate the correctness of the data being fed into the rollup circuit.\\n     *\\n     *      (There is a bit of nomenclature abuse here. Processing a public input in the verifier algorithm costs 150 gas,\\n     *      which adds up very quickly. Instead of this, we sha256 hash what used to be the \\\"public\\\" inputs and only set\\n     *      the hash to be public. We then make the old \\\"public\\\" inputs private in the rollup circuit, and validate their\\n     *      correctness by checking that their sha256 hash matches what we compute in the decodeProof function!\\n     */\\n    function decodeProof() internal view returns (bytes memory proofData, uint256 numTxs, uint256 publicInputsHash) {\\n        // declare some variables that will be set inside asm blocks\\n        uint256 dataSize; // size of our decoded transaction data, in bytes\\n        uint256 outPtr; // memory pointer to where we will write our decoded transaction data\\n        uint256 inPtr; // calldata pointer into our proof data\\n        uint256 rollupSize; // max number of transactions in the rollup block\\n        uint256 decodedTxDataStart;\\n\\n        {\\n            uint256 tailInPtr; // calldata pointer to the end of our proof data\\n\\n            /**\\n             * Let's build a function table!\\n             *\\n             * To decode our tx data, we need to iterate over every encoded transaction and call its\\n             * associated decoding function. If we did this via a `switch` statement this would be VERY expensive,\\n             * due to the large number of JUMPI instructions that would be called.\\n             *\\n             * Instead, we use function pointers.\\n             * The `proofId` field in our encoded proof data is an integer from 0-6,\\n             * we can use `proofId` to index a table of function pointers for our respective decoding functions.\\n             * This is much faster as there is no conditional branching!\\n             */\\n            function(uint256, uint256) pure returns (uint256) callfunc; // we're going to use `callfunc` as a function pointer\\n            // `functionTable` is a pointer to a table in memory, containing function pointers\\n            // Step 1: reserve memory for functionTable\\n            uint256 functionTable;\\n            assembly {\\n                functionTable := mload(0x40)\\n                mstore(0x40, add(functionTable, 0x100)) // reserve 256 bytes for function pointers\\n            }\\n            {\\n                // Step 2: copy function pointers into local variables so that inline asm code can access them\\n                function(uint256, uint256) pure returns (uint256) t0 = paddingTx;\\n                function(uint256, uint256) pure returns (uint256) t1 = depositOrWithdrawTx;\\n                function(uint256, uint256) pure returns (uint256) t3 = sendTx;\\n                function(uint256, uint256) pure returns (uint256) t4 = accountTx;\\n                function(uint256, uint256) pure returns (uint256) t5 = defiDepositOrClaimTx;\\n                function(uint256, uint256) pure returns (uint256) t7 = invalidTx;\\n\\n                // Step 3: write function pointers into the table!\\n                assembly {\\n                    mstore(functionTable, t0)\\n                    mstore(add(functionTable, 0x20), t1)\\n                    mstore(add(functionTable, 0x40), t1)\\n                    mstore(add(functionTable, 0x60), t3)\\n                    mstore(add(functionTable, 0x80), t4)\\n                    mstore(add(functionTable, 0xa0), t5)\\n                    mstore(add(functionTable, 0xc0), t5)\\n                    mstore(add(functionTable, 0xe0), t7) // a proofId of 7 is not a valid transaction type, set to invalidTx\\n                }\\n            }\\n            uint256 decodedTransactionDataSize;\\n            assembly {\\n                // Add encoded proof data size to dataSize, minus the 4 bytes of encodedInnerProofData.length.\\n                // Set inPtr to point to the length parameter of `bytes calldata proofData`\\n                inPtr := add(calldataload(0x04), 0x4) // `proofData = first input parameter. Calldata offset to proofData will be at 0x04. Add 0x04 to account for function signature.\\n\\n                // Advance inPtr to point to the start of `proofData`\\n                inPtr := add(inPtr, 0x20)\\n\\n                numTxs := and(calldataload(add(inPtr, NUM_REAL_TRANSACTIONS_OFFSET)), 0xffffffff)\\n                // Get encoded inner proof data size.\\n                // Add ENCODED_PROOF_DATA_LENGTH_OFFSET to inPtr to point to the correct variable in our header block,\\n                // mask off all but 4 least significant bytes as this is a packed 32-bit variable.\\n                let encodedInnerDataSize := and(calldataload(add(inPtr, ENCODED_PROOF_DATA_LENGTH_OFFSET)), 0xffffffff)\\n\\n                // Load up the rollup size from `proofData`\\n                rollupSize := calldataload(add(inPtr, 0x20))\\n\\n                // Compute the number of bytes our decoded proof data will take up.\\n                // i.e. num total txns in the rollup (including padding) * number of public inputs per transaction\\n                let decodedInnerDataSize := mul(rollupSize, TX_PUBLIC_INPUT_LENGTH)\\n\\n                // We want `dataSize` to equal: rollup header length + decoded tx length (excluding padding blocks)\\n                let numInnerRollups := calldataload(add(inPtr, sub(ROLLUP_HEADER_LENGTH, 0x20)))\\n                let numTxsPerRollup := div(rollupSize, numInnerRollups)\\n\\n                let numFilledBlocks := div(numTxs, numTxsPerRollup)\\n                numFilledBlocks := add(numFilledBlocks, iszero(eq(mul(numFilledBlocks, numTxsPerRollup), numTxs)))\\n\\n                decodedTransactionDataSize := mul(mul(numFilledBlocks, numTxsPerRollup), TX_PUBLIC_INPUT_LENGTH)\\n                dataSize := add(ROLLUP_HEADER_LENGTH, decodedTransactionDataSize)\\n\\n                // Allocate memory for `proofData`.\\n                proofData := mload(0x40)\\n                // Set free mem ptr to `dataSize` + 0x20 (to account for the 0x20 bytes for the length param of proofData)\\n                // This allocates memory whose size is equal to the rollup header size, plus the data required for\\n                // each transaction's decoded tx data (256 bytes * number of non-padding blocks).\\n                // Only reserve memory for blocks that contain non-padding proofs. These \\\"padding\\\" blocks don't need to be\\n                // stored in memory as we don't need their data for any computations.\\n                mstore(0x40, add(proofData, add(dataSize, 0x20)))\\n\\n                // Set `outPtr` to point to the `proofData` length parameter\\n                outPtr := proofData\\n                // Write `dataSize` into `proofData.length`\\n                mstore(outPtr, dataSize)\\n                // Advance `outPtr` to point to start of `proofData`\\n                outPtr := add(outPtr, 0x20)\\n\\n                // Copy rollup header data to `proofData`.\\n                calldatacopy(outPtr, inPtr, ROLLUP_HEADER_LENGTH)\\n                // Advance `outPtr` to point to the end of the header data (i.e. the start of the decoded inner transaction data)\\n                outPtr := add(outPtr, ROLLUP_HEADER_LENGTH)\\n\\n                // Advance `inPtr` to point to the start of our encoded inner transaction data.\\n                // Add (ROLLUP_HEADER_LENGTH + 0x08) to skip over the packed (numRealTransactions, encodedProofData.length) parameters\\n                inPtr := add(inPtr, add(ROLLUP_HEADER_LENGTH, 0x08))\\n\\n                // Set `tailInPtr` to point to the end of our encoded transaction data\\n                tailInPtr := add(inPtr, encodedInnerDataSize)\\n                // Set `decodedTxDataStart` pointer\\n                decodedTxDataStart := outPtr\\n            }\\n            /**\\n             * Start of decoding algorithm\\n             *\\n             * Iterate over every encoded transaction, load out the first byte (`proofId`) and use it to\\n             * jump to the relevant transaction's decoding function\\n             */\\n            assembly {\\n                // Subtract 31 bytes off of `inPtr`, so that the first byte of the encoded transaction data\\n                // is located at the least significant byte of calldataload(inPtr)\\n                // also adjust `tailInPtr` as we compare `inPtr` against `tailInPtr`\\n                inPtr := sub(inPtr, 0x1f)\\n                tailInPtr := sub(tailInPtr, 0x1f)\\n            }\\n            unchecked {\\n                for (; tailInPtr > inPtr;) {\\n                    assembly {\\n                        // For each tx, the encoding byte determines how we decode the tx calldata\\n                        // The encoding byte can take values from 0 to 7; we want to turn these into offsets that can index our function table.\\n                        // 1. Access encoding byte via `calldataload(inPtr)`. The least significant byte is our encoding byte. Mask off all but the 3 least sig bits\\n                        // 2. Shift left by 5 bits. This is equivalent to multiplying the encoding byte by 32.\\n                        // 3. The result will be 1 of 8 offset values (0x00, 0x20, ..., 0xe0) which we can use to retrieve the relevant function pointer from `functionTable`\\n                        let encoding := and(calldataload(inPtr), 7)\\n                        // Store `proofId` at `outPtr`.\\n                        mstore(outPtr, encoding) // proofId\\n\\n                        // Use `proofId` to extract the relevant function pointer from `functionTable`\\n                        callfunc := mload(add(functionTable, shl(5, encoding)))\\n                    }\\n                    // Call the decoding function. Return value will be next required value of inPtr\\n                    inPtr = callfunc(inPtr, outPtr);\\n                    // advance outPtr by the size of a decoded transaction\\n                    outPtr += TX_PUBLIC_INPUT_LENGTH;\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Compute the public inputs hash\\n         *\\n         * We need to take our decoded proof data and compute its SHA256 hash.\\n         * This hash is fed into our rollup proof as a public input.\\n         * If the hash does not match the SHA256 hash computed within the rollup circuit\\n         * on the equivalent parameters, the proof will reject.\\n         * This check ensures that the transaction data present in calldata are equal to\\n         * the transaction data values present in the rollup ZK-SNARK circuit.\\n         *\\n         * One complication is the structure of the SHA256 hash.\\n         * We slice transactions into chunks equal to the number of transactions in the \\\"inner rollup\\\" circuit\\n         * (a rollup circuit verifies multiple \\\"inner rollup\\\" circuits, which each verify 3-28 private user transactions.\\n         *  This tree structure helps parallelise proof construction)\\n         * We then SHA256 hash each transaction *chunk*\\n         * Finally we SHA256 hash the above SHA256 hashes to get our public input hash!\\n         *\\n         * We do the above instead of a straight hash of all of the transaction data,\\n         * because it's faster to parallelise proof construction if the majority of the SHA256 hashes are computed in\\n         * the \\\"inner rollup\\\" circuit and not the main rollup circuit.\\n         */\\n        // Step 1: compute the hashes that constitute the inner proofs data\\n        bool invalidRollupTopology;\\n        assembly {\\n            // We need to figure out how many rollup proofs are in this tx and how many user transactions are in each rollup\\n            let numRollupTxs := mload(add(proofData, ROLLUP_HEADER_LENGTH))\\n            let numJoinSplitsPerRollup := div(rollupSize, numRollupTxs)\\n            let rollupDataSize := mul(mul(numJoinSplitsPerRollup, NUMBER_OF_PUBLIC_INPUTS_PER_TX), 32)\\n\\n            // Compute the number of inner rollups that don't contain padding proofs\\n            let numNotEmptyInnerRollups := div(numTxs, numJoinSplitsPerRollup)\\n            numNotEmptyInnerRollups :=\\n                add(numNotEmptyInnerRollups, iszero(eq(mul(numNotEmptyInnerRollups, numJoinSplitsPerRollup), numTxs)))\\n            // Compute the number of inner rollups that only contain padding proofs!\\n            // For these \\\"empty\\\" inner rollups, we don't need to compute their public inputs hash directly,\\n            // we can use a precomputed value\\n            let numEmptyInnerRollups := sub(numRollupTxs, numNotEmptyInnerRollups)\\n\\n            let proofdataHashPtr := mload(0x40)\\n            // Copy the header data into the `proofdataHash`\\n            // Header start is at calldataload(0x04) + 0x24 (+0x04 to skip over func signature, +0x20 to skip over byte array length param)\\n            calldatacopy(proofdataHashPtr, add(calldataload(0x04), 0x24), ROLLUP_HEADER_LENGTH)\\n\\n            // Update pointer\\n            proofdataHashPtr := add(proofdataHashPtr, ROLLUP_HEADER_LENGTH)\\n\\n            // Compute the endpoint for the `proofdataHashPtr` (used as a loop boundary condition)\\n            let endPtr := add(proofdataHashPtr, mul(numNotEmptyInnerRollups, 0x20))\\n            // Iterate over the public inputs of each inner rollup proof and compute their SHA256 hash\\n\\n            // better solution here is ... iterate over number of non-padding rollup blocks\\n            // and hash those\\n            // for padding rollup blocks...just append the zero hash\\n            for {} lt(proofdataHashPtr, endPtr) { proofdataHashPtr := add(proofdataHashPtr, 0x20) } {\\n                // address(0x02) is the SHA256 precompile address\\n                if iszero(staticcall(gas(), 0x02, decodedTxDataStart, rollupDataSize, 0x00, 0x20)) {\\n                    revert(0x00, 0x00)\\n                }\\n\\n                mstore(proofdataHashPtr, mod(mload(0x00), CIRCUIT_MODULUS))\\n                decodedTxDataStart := add(decodedTxDataStart, rollupDataSize)\\n            }\\n\\n            // If there are empty inner rollups, we can use a precomputed hash\\n            // of their public inputs instead of computing it directly.\\n            if iszero(iszero(numEmptyInnerRollups)) {\\n                let zeroHash\\n                switch numJoinSplitsPerRollup\\n                case 32 { zeroHash := PADDING_ROLLUP_HASH_SIZE_32 }\\n                case 16 { zeroHash := PADDING_ROLLUP_HASH_SIZE_16 }\\n                case 64 { zeroHash := PADDING_ROLLUP_HASH_SIZE_64 }\\n                case 1 { zeroHash := PADDING_ROLLUP_HASH_SIZE_1 }\\n                case 2 { zeroHash := PADDING_ROLLUP_HASH_SIZE_2 }\\n                case 4 { zeroHash := PADDING_ROLLUP_HASH_SIZE_4 }\\n                case 8 { zeroHash := PADDING_ROLLUP_HASH_SIZE_8 }\\n                default { invalidRollupTopology := true }\\n\\n                endPtr := add(endPtr, mul(numEmptyInnerRollups, 0x20))\\n                for {} lt(proofdataHashPtr, endPtr) { proofdataHashPtr := add(proofdataHashPtr, 0x20) } {\\n                    mstore(proofdataHashPtr, zeroHash)\\n                }\\n            }\\n            // Compute SHA256 hash of header data + inner public input hashes\\n            let startPtr := mload(0x40)\\n            if iszero(staticcall(gas(), 0x02, startPtr, sub(proofdataHashPtr, startPtr), 0x00, 0x20)) {\\n                revert(0x00, 0x00)\\n            }\\n            publicInputsHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n        }\\n        if (invalidRollupTopology) {\\n            revert INVALID_ROLLUP_TOPOLOGY();\\n        }\\n    }\\n\\n    /**\\n     * @notice Extracts the `rollupId` param from the decoded proof data\\n     * @dev This represents the rollupId of the next valid rollup block\\n     * @param _proofData the decoded proof data\\n     * @return nextRollupId the expected id of the next rollup block\\n     */\\n    function getRollupId(bytes memory _proofData) internal pure returns (uint256 nextRollupId) {\\n        assembly {\\n            nextRollupId := mload(add(_proofData, 0x20))\\n        }\\n    }\\n\\n    /**\\n     * @notice Decodes the input merkle roots of `proofData` and computes rollupId && sha3 hash of roots && dataStartIndex\\n     * @dev The rollup's state is uniquely defined by the following variables:\\n     *          * The next empty location in the data root tree (rollupId + 1)\\n     *          * The next empty location in the data tree (dataStartIndex + rollupSize)\\n     *          * The root of the data tree\\n     *          * The root of the nullifier set\\n     *          * The root of the data root tree (tree containing all previous roots of the data tree)\\n     *          * The root of the defi tree\\n     *      Instead of storing all of these variables in storage (expensive!), we store a keccak256 hash of them.\\n     *      To validate the correctness of a block's state transition, we must perform the following:\\n     *          * Use proof broadcasted inputs to reconstruct the \\\"old\\\" state hash\\n     *          * Use proof broadcasted inputs to reconstruct the \\\"new\\\" state hash\\n     *          * Validate that the old state hash matches what is in storage\\n     *          * Set the old state hash to the new state hash\\n     *      N.B. we still store `dataSize` as a separate storage var as `proofData does not contain all\\n     *           neccessary information to reconstruct its old value.\\n     * @param _proofData cryptographic proofData associated with a rollup\\n     * @return rollupId\\n     * @return oldStateHash\\n     * @return newStateHash\\n     * @return numDataLeaves\\n     * @return dataStartIndex\\n     */\\n    function computeRootHashes(bytes memory _proofData)\\n        internal\\n        pure\\n        returns (\\n            uint256 rollupId,\\n            bytes32 oldStateHash,\\n            bytes32 newStateHash,\\n            uint32 numDataLeaves,\\n            uint32 dataStartIndex\\n        )\\n    {\\n        assembly {\\n            let dataStart := add(_proofData, 0x20) // jump over first word, it's length of data\\n            numDataLeaves := shl(1, mload(add(dataStart, 0x20))) // rollupSize * 2 (2 notes per tx)\\n            dataStartIndex := mload(add(dataStart, 0x40))\\n\\n            // validate numDataLeaves && dataStartIndex are uint32s\\n            if or(gt(numDataLeaves, 0xffffffff), gt(dataStartIndex, 0xffffffff)) { revert(0, 0) }\\n            rollupId := mload(dataStart)\\n\\n            let mPtr := mload(0x40)\\n\\n            mstore(mPtr, rollupId) // old nextRollupId\\n            mstore(add(mPtr, 0x20), mload(add(dataStart, 0x60))) // oldDataRoot\\n            mstore(add(mPtr, 0x40), mload(add(dataStart, 0xa0))) // oldNullRoot\\n            mstore(add(mPtr, 0x60), mload(add(dataStart, 0xe0))) // oldRootRoot\\n            mstore(add(mPtr, 0x80), mload(add(dataStart, 0x120))) // oldDefiRoot\\n            oldStateHash := keccak256(mPtr, 0xa0)\\n\\n            mstore(mPtr, add(rollupId, 0x01)) // new nextRollupId\\n            mstore(add(mPtr, 0x20), mload(add(dataStart, 0x80))) // newDataRoot\\n            mstore(add(mPtr, 0x40), mload(add(dataStart, 0xc0))) // newNullRoot\\n            mstore(add(mPtr, 0x60), mload(add(dataStart, 0x100))) // newRootRoot\\n            mstore(add(mPtr, 0x80), mload(add(dataStart, 0x140))) // newDefiRoot\\n            newStateHash := keccak256(mPtr, 0xa0)\\n        }\\n    }\\n\\n    /**\\n     * @notice Extract the `prevDefiInteractionHash` from the proofData's rollup header\\n     * @param _proofData decoded rollup proof data\\n     * @return prevDefiInteractionHash the defiInteractionHash of the previous rollup block\\n     */\\n    function extractPrevDefiInteractionHash(bytes memory _proofData)\\n        internal\\n        pure\\n        returns (bytes32 prevDefiInteractionHash)\\n    {\\n        assembly {\\n            prevDefiInteractionHash := mload(add(_proofData, PREVIOUS_DEFI_INTERACTION_HASH_OFFSET))\\n        }\\n    }\\n\\n    /**\\n     * @notice Extracts the address we pay the rollup fee to from the proofData's rollup header\\n     * @dev Rollup beneficiary address is included as part of the ZK-SNARK circuit data, so that the rollup provider\\n     *      can explicitly define who should get the fee when they are generating the ZK-SNARK proof (instead of\\n     *      simply sending the fee to msg.sender).\\n     *      This prevents front-running attacks where an attacker can take somebody else's rollup proof from out of\\n     *      the tx pool and replay it, stealing the fee.\\n     * @param _proofData byte array of our input proof data\\n     * @return rollupBeneficiary the address we pay this rollup block's fee to\\n     */\\n    function extractRollupBeneficiary(bytes memory _proofData) internal pure returns (address rollupBeneficiary) {\\n        assembly {\\n            rollupBeneficiary := mload(add(_proofData, ROLLUP_BENEFICIARY_OFFSET))\\n            // Validate `rollupBeneficiary` is an address\\n            if gt(rollupBeneficiary, ADDRESS_MASK) { revert(0, 0) }\\n        }\\n    }\\n\\n    /**\\n     * @notice Extracts an `assetId` in which a fee is going to be paid from a rollup block\\n     * @dev The rollup block contains up to 16 different assets, which can be recovered from the rollup header data.\\n     * @param _proofData byte array of our input proof data\\n     * @param _idx index of the asset we want (assetId = header.assetIds[_idx])\\n     * @return assetId 30-bit identifier of an asset. The ERC20 token address is obtained via the mapping `supportedAssets[assetId]`,\\n     */\\n    function extractFeeAssetId(bytes memory _proofData, uint256 _idx) internal pure returns (uint256 assetId) {\\n        assembly {\\n            assetId :=\\n                mload(\\n                    add(add(add(_proofData, BRIDGE_CALL_DATAS_OFFSET), mul(0x40, NUMBER_OF_BRIDGE_CALLS)), mul(0x20, _idx))\\n                )\\n            // Validate `assetId` is a uint32!\\n            if gt(assetId, 0xffffffff) { revert(0, 0) }\\n        }\\n    }\\n\\n    /**\\n     * @notice Extracts the transaction fee for a given asset which is to be paid to the rollup beneficiary\\n     * @dev The total fee is the sum of the individual fees paid by each transaction in the rollup block.\\n     *      This sum is computed directly in the rollup circuit, and is present in the rollup header data.\\n     * @param _proofData byte array of decoded rollup proof data\\n     * @param _idx The index of the asset the fee is denominated in\\n     * @return totalTxFee total rollup block transaction fee for a given asset\\n     */\\n    function extractTotalTxFee(bytes memory _proofData, uint256 _idx) internal pure returns (uint256 totalTxFee) {\\n        assembly {\\n            totalTxFee := mload(add(add(add(_proofData, 0x380), mul(0x40, NUMBER_OF_BRIDGE_CALLS)), mul(0x20, _idx)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rollup-encoder/src/libraries/AztecTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary AztecTypes {\\n    enum AztecAssetType {\\n        NOT_USED,\\n        ETH,\\n        ERC20,\\n        VIRTUAL\\n    }\\n\\n    struct AztecAsset {\\n        uint256 id;\\n        address erc20Address;\\n        AztecAssetType assetType;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/libraries/TokenTransfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title TokenTransfers\\n * @dev Provides functions to safely call `transfer` and `transferFrom` methods on ERC20 tokens,\\n * as well as the ability to call `transfer` and `transferFrom` without bubbling up errors\\n */\\nlibrary TokenTransfers {\\n    error INVALID_ADDRESS_NO_CODE();\\n\\n    bytes4 private constant INVALID_ADDRESS_NO_CODE_SELECTOR = 0x21409272; // bytes4(keccak256('INVALID_ADDRESS_NO_CODE()'));\\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb; // bytes4(keccak256('transfer(address,uint256)'));\\n    bytes4 private constant TRANSFER_FROM_SELECTOR = 0x23b872dd; // bytes4(keccak256('transferFrom(address,address,uint256)'));\\n\\n    /**\\n     * @dev Safely call ERC20.transfer, handles tokens that do not throw on transfer failure or do not return transfer result\\n     * @param tokenAddress Where does the token live?\\n     * @param to Who are we sending tokens to?\\n     * @param amount How many tokens are we transferring?\\n     */\\n    function safeTransferTo(address tokenAddress, address to, uint256 amount) internal {\\n        // The ERC20 token standard states that:\\n        // 1. failed transfers must throw\\n        // 2. the result of the transfer (success/fail) is returned as a boolean\\n        // Some token contracts don't implement the spec correctly and will do one of the following:\\n        // 1. Contract does not throw if transfer fails, instead returns false\\n        // 2. Contract throws if transfer fails, but does not return any boolean value\\n        // We can check for these by evaluating the following:\\n        // | call succeeds? (c) | return value (v) | returndatasize == 0 (r)| interpreted result |\\n        // | ---                | ---              | ---                    | ---                |\\n        // | false              | false            | false                  | transfer fails     |\\n        // | false              | false            | true                   | transfer fails     |\\n        // | false              | true             | false                  | transfer fails     |\\n        // | false              | true             | true                   | transfer fails     |\\n        // | true               | false            | false                  | transfer fails     |\\n        // | true               | false            | true                   | transfer succeeds  |\\n        // | true               | true             | false                  | transfer succeeds  |\\n        // | true               | true             | true                   | transfer succeeds  |\\n        //\\n        // i.e. failure state = !(c && (r || v))\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, TRANSFER_SELECTOR)\\n            mstore(add(ptr, 0x4), to)\\n            mstore(add(ptr, 0x24), amount)\\n            if iszero(extcodesize(tokenAddress)) {\\n                mstore(0, INVALID_ADDRESS_NO_CODE_SELECTOR)\\n                revert(0, 0x4)\\n            }\\n            let call_success := call(gas(), tokenAddress, 0, ptr, 0x44, 0x00, 0x20)\\n            let result_success := or(iszero(returndatasize()), and(mload(0), 1))\\n            if iszero(and(call_success, result_success)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely call ERC20.transferFrom, handles tokens that do not throw on transfer failure or do not return transfer result\\n     * @param tokenAddress Where does the token live?\\n     * @param source Who are we transferring tokens from\\n     * @param target Who are we transferring tokens to?\\n     * @param amount How many tokens are being transferred?\\n     */\\n    function safeTransferFrom(address tokenAddress, address source, address target, uint256 amount) internal {\\n        assembly {\\n            // call tokenAddress.transferFrom(source, target, value)\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, TRANSFER_FROM_SELECTOR)\\n            mstore(add(mPtr, 0x04), source)\\n            mstore(add(mPtr, 0x24), target)\\n            mstore(add(mPtr, 0x44), amount)\\n            if iszero(extcodesize(tokenAddress)) {\\n                mstore(0, INVALID_ADDRESS_NO_CODE_SELECTOR)\\n                revert(0, 0x4)\\n            }\\n            let call_success := call(gas(), tokenAddress, 0, mPtr, 0x64, 0x00, 0x20)\\n            let result_success := or(iszero(returndatasize()), and(mload(0), 1))\\n            if iszero(and(call_success, result_success)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls ERC(tokenAddress).transfer(to, amount). Errors are ignored! Use with caution!\\n     * @param tokenAddress Where does the token live?\\n     * @param to Who are we sending to?\\n     * @param amount How many tokens are being transferred?\\n     * @param gasToSend Amount of gas to send the contract. If value is 0, function uses gas() instead\\n     */\\n    function transferToDoNotBubbleErrors(address tokenAddress, address to, uint256 amount, uint256 gasToSend)\\n        internal\\n    {\\n        assembly {\\n            let callGas := gas()\\n            if gasToSend { callGas := gasToSend }\\n            let ptr := mload(0x40)\\n            mstore(ptr, TRANSFER_SELECTOR)\\n            mstore(add(ptr, 0x4), to)\\n            mstore(add(ptr, 0x24), amount)\\n            pop(call(callGas, tokenAddress, 0, ptr, 0x44, 0x00, 0x00))\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls ERC(tokenAddress).transferFrom(source, target, amount). Errors are ignored! Use with caution!\\n     * @param tokenAddress Where does the token live?\\n     * @param source Who are we transferring tokens from\\n     * @param target Who are we transferring tokens to?\\n     * @param amount How many tokens are being transferred?\\n     * @param gasToSend Amount of gas to send the contract. If value is 0, function uses gas() instead\\n     */\\n    function transferFromDoNotBubbleErrors(\\n        address tokenAddress,\\n        address source,\\n        address target,\\n        uint256 amount,\\n        uint256 gasToSend\\n    ) internal {\\n        assembly {\\n            let callGas := gas()\\n            if gasToSend { callGas := gasToSend }\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, TRANSFER_FROM_SELECTOR)\\n            mstore(add(mPtr, 0x04), source)\\n            mstore(add(mPtr, 0x24), target)\\n            mstore(add(mPtr, 0x44), amount)\\n            pop(call(callGas, tokenAddress, 0, mPtr, 0x64, 0x00, 0x00))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rollup-encoder/src/libraries/RollupProcessorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary RollupProcessorLibrary {\\n    error SIGNATURE_ADDRESS_IS_ZERO();\\n    error SIGNATURE_RECOVERY_FAILED();\\n    error INVALID_SIGNATURE();\\n\\n    /**\\n     * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n     * to prevent signature malleability based attacks\\n     * @param digest - Hashed data being signed over.\\n     * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n     * @param signer - Address that signs the signature.\\n     */\\n    function validateSignature(bytes32 digest, bytes memory signature, address signer) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        if (signer == address(0x0)) {\\n            revert SIGNATURE_ADDRESS_IS_ZERO();\\n        }\\n\\n        // prepend \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" to the digest to create the signed message\\n        bytes32 message;\\n        assembly {\\n            mstore(0, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(add(0, 28), digest)\\n            message := keccak256(0, 60)\\n        }\\n        assembly {\\n            let mPtr := mload(0x40)\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(mPtr, message)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := shr(248, mload(add(signature, 0x60))) // bitshifting, to resemble padLeft\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n             * Original memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     r\\n             * signature + 0x40 : signature + 0x60     s\\n             * signature + 0x60 : signature + 0x80     v\\n             * Desired memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     v\\n             * signature + 0x40 : signature + 0x60     r\\n             * signature + 0x60 : signature + 0x80     s\\n             */\\n\\n            // store s\\n            mstore(add(mPtr, 0x60), s)\\n            // store r\\n            mstore(add(mPtr, 0x40), mload(add(signature, 0x20)))\\n            // store v\\n            mstore(add(mPtr, 0x20), v)\\n            result :=\\n                and(\\n                    and(\\n                        // validate s is in lower half order\\n                        lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                        and(\\n                            // validate signature length == 0x41\\n                            eq(byteLength, 0x41),\\n                            // validate v == 27 or v == 28\\n                            or(eq(v, 27), eq(v, 28))\\n                        )\\n                    ),\\n                    // validate call to ecrecover precompile succeeds\\n                    staticcall(gas(), 0x01, mPtr, 0x80, mPtr, 0x20)\\n                )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(message, mload(mPtr))\\n            case 0 { recoveredSigner := mload(mPtr) }\\n            mstore(mPtr, byteLength) // and put the byte length back where it belongs\\n\\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n        if (!result) {\\n            revert SIGNATURE_RECOVERY_FAILED();\\n        }\\n        if (recoveredSigner != signer) {\\n            revert INVALID_SIGNATURE();\\n        }\\n    }\\n\\n    /**\\n     * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n     * to prevent signature malleability based attacks\\n     * This 'Unpacked' version expects 'signature' to be a 96-byte array.\\n     * i.e. the `v` parameter occupies a full 32 bytes of memory, not 1 byte\\n     * @param hashedMessage - Hashed data being signed over. This function only works if the message has been pre formated to EIP https://eips.ethereum.org/EIPS/eip-191\\n     * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n     * @param signer - Address that signs the signature.\\n     */\\n    function validateShieldSignatureUnpacked(bytes32 hashedMessage, bytes memory signature, address signer)\\n        internal\\n        view\\n    {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        if (signer == address(0x0)) {\\n            revert SIGNATURE_ADDRESS_IS_ZERO();\\n        }\\n        assembly {\\n            // There's a little trick we can pull. We expect `signature` to be a byte array, of length 0x60, with\\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `signature`.\\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\\n            // load length as a temporary variable\\n            // N.B. we mutate the signature by re-ordering r, s, and v!\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(signature, hashedMessage)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := mload(add(signature, 0x60))\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n             * Original memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     r\\n             * signature + 0x40 : signature + 0x60     s\\n             * signature + 0x60 : signature + 0x80     v\\n             * Desired memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     v\\n             * signature + 0x40 : signature + 0x60     r\\n             * signature + 0x60 : signature + 0x80     s\\n             */\\n\\n            // move s to v position\\n            mstore(add(signature, 0x60), s)\\n            // move r to s position\\n            mstore(add(signature, 0x40), mload(add(signature, 0x20)))\\n            // move v to r position\\n            mstore(add(signature, 0x20), v)\\n            result :=\\n                and(\\n                    and(\\n                        // validate s is in lower half order\\n                        lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                        and(\\n                            // validate signature length == 0x60 (unpacked)\\n                            eq(byteLength, 0x60),\\n                            // validate v == 27 or v == 28\\n                            or(eq(v, 27), eq(v, 28))\\n                        )\\n                    ),\\n                    // validate call to ecrecover precompile succeeds\\n                    staticcall(gas(), 0x01, signature, 0x80, signature, 0x20)\\n                )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(hashedMessage, mload(signature))\\n            case 0 { recoveredSigner := mload(signature) }\\n            mstore(signature, byteLength) // and put the byte length back where it belongs\\n\\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n        if (!result) {\\n            revert SIGNATURE_RECOVERY_FAILED();\\n        }\\n        if (recoveredSigner != signer) {\\n            revert INVALID_SIGNATURE();\\n        }\\n    }\\n\\n    /**\\n     * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n     * to prevent signature malleability based attacks\\n     * This 'Unpacked' version expects 'signature' to be a 96-byte array.\\n     * i.e. the `v` parameter occupies a full 32 bytes of memory, not 1 byte\\n     * @param digest - Hashed data being signed over.\\n     * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n     * @param signer - Address that signs the signature.\\n     */\\n    function validateUnpackedSignature(bytes32 digest, bytes memory signature, address signer) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        if (signer == address(0x0)) {\\n            revert SIGNATURE_ADDRESS_IS_ZERO();\\n        }\\n\\n        // prepend \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" to the digest to create the signed message\\n        bytes32 message;\\n        assembly {\\n            mstore(0, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(28, digest)\\n            message := keccak256(0, 60)\\n        }\\n        assembly {\\n            // There's a little trick we can pull. We expect `signature` to be a byte array, of length 0x60, with\\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `signature`.\\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\\n            // load length as a temporary variable\\n            // N.B. we mutate the signature by re-ordering r, s, and v!\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(signature, message)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := mload(add(signature, 0x60))\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n             * Original memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     r\\n             * signature + 0x40 : signature + 0x60     s\\n             * signature + 0x60 : signature + 0x80     v\\n             * Desired memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     v\\n             * signature + 0x40 : signature + 0x60     r\\n             * signature + 0x60 : signature + 0x80     s\\n             */\\n\\n            // move s to v position\\n            mstore(add(signature, 0x60), s)\\n            // move r to s position\\n            mstore(add(signature, 0x40), mload(add(signature, 0x20)))\\n            // move v to r position\\n            mstore(add(signature, 0x20), v)\\n            result :=\\n                and(\\n                    and(\\n                        // validate s is in lower half order\\n                        lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                        and(\\n                            // validate signature length == 0x60 (unpacked)\\n                            eq(byteLength, 0x60),\\n                            // validate v == 27 or v == 28\\n                            or(eq(v, 27), eq(v, 28))\\n                        )\\n                    ),\\n                    // validate call to ecrecover precompile succeeds\\n                    staticcall(gas(), 0x01, signature, 0x80, signature, 0x20)\\n                )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(message, mload(signature))\\n            case 0 { recoveredSigner := mload(signature) }\\n            mstore(signature, byteLength) // and put the byte length back where it belongs\\n\\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n        if (!result) {\\n            revert SIGNATURE_RECOVERY_FAILED();\\n        }\\n        if (recoveredSigner != signer) {\\n            revert INVALID_SIGNATURE();\\n        }\\n    }\\n\\n    /**\\n     * Convert a bytes32 into an ASCII encoded hex string\\n     * @param input bytes32 variable\\n     * @return result hex-encoded string\\n     */\\n    function toHexString(bytes32 input) public pure returns (string memory result) {\\n        if (uint256(input) == 0x00) {\\n            assembly {\\n                result := mload(0x40)\\n                mstore(result, 0x40)\\n                mstore(add(result, 0x20), 0x3030303030303030303030303030303030303030303030303030303030303030)\\n                mstore(add(result, 0x40), 0x3030303030303030303030303030303030303030303030303030303030303030)\\n                mstore(0x40, add(result, 0x60))\\n            }\\n            return result;\\n        }\\n        assembly {\\n            result := mload(0x40)\\n            let table := add(result, 0x60)\\n\\n            // Store lookup table that maps an integer from 0 to 99 into a 2-byte ASCII equivalent\\n            // Store lookup table that maps an integer from 0 to ff into a 2-byte ASCII equivalent\\n            mstore(add(table, 0x1e), 0x3030303130323033303430353036303730383039306130623063306430653066)\\n            mstore(add(table, 0x3e), 0x3130313131323133313431353136313731383139316131623163316431653166)\\n            mstore(add(table, 0x5e), 0x3230323132323233323432353236323732383239326132623263326432653266)\\n            mstore(add(table, 0x7e), 0x3330333133323333333433353336333733383339336133623363336433653366)\\n            mstore(add(table, 0x9e), 0x3430343134323433343434353436343734383439346134623463346434653466)\\n            mstore(add(table, 0xbe), 0x3530353135323533353435353536353735383539356135623563356435653566)\\n            mstore(add(table, 0xde), 0x3630363136323633363436353636363736383639366136623663366436653666)\\n            mstore(add(table, 0xfe), 0x3730373137323733373437353736373737383739376137623763376437653766)\\n            mstore(add(table, 0x11e), 0x3830383138323833383438353836383738383839386138623863386438653866)\\n            mstore(add(table, 0x13e), 0x3930393139323933393439353936393739383939396139623963396439653966)\\n            mstore(add(table, 0x15e), 0x6130613161326133613461356136613761386139616161626163616461656166)\\n            mstore(add(table, 0x17e), 0x6230623162326233623462356236623762386239626162626263626462656266)\\n            mstore(add(table, 0x19e), 0x6330633163326333633463356336633763386339636163626363636463656366)\\n            mstore(add(table, 0x1be), 0x6430643164326433643464356436643764386439646164626463646464656466)\\n            mstore(add(table, 0x1de), 0x6530653165326533653465356536653765386539656165626563656465656566)\\n            mstore(add(table, 0x1fe), 0x6630663166326633663466356636663766386639666166626663666466656666)\\n            /**\\n             * Convert `input` into ASCII.\\n             *\\n             * Slice 2 base-10  digits off of the input, use to index the ASCII lookup table.\\n             *\\n             * We start from the least significant digits, write results into mem backwards,\\n             * this prevents us from overwriting memory despite the fact that each mload\\n             * only contains 2 byteso f useful data.\\n             *\\n             */\\n\\n            let base := input\\n            function slice(v, tableptr) {\\n                mstore(0x1e, mload(add(tableptr, shl(1, and(v, 0xff)))))\\n                mstore(0x1c, mload(add(tableptr, shl(1, and(shr(8, v), 0xff)))))\\n                mstore(0x1a, mload(add(tableptr, shl(1, and(shr(16, v), 0xff)))))\\n                mstore(0x18, mload(add(tableptr, shl(1, and(shr(24, v), 0xff)))))\\n                mstore(0x16, mload(add(tableptr, shl(1, and(shr(32, v), 0xff)))))\\n                mstore(0x14, mload(add(tableptr, shl(1, and(shr(40, v), 0xff)))))\\n                mstore(0x12, mload(add(tableptr, shl(1, and(shr(48, v), 0xff)))))\\n                mstore(0x10, mload(add(tableptr, shl(1, and(shr(56, v), 0xff)))))\\n                mstore(0x0e, mload(add(tableptr, shl(1, and(shr(64, v), 0xff)))))\\n                mstore(0x0c, mload(add(tableptr, shl(1, and(shr(72, v), 0xff)))))\\n                mstore(0x0a, mload(add(tableptr, shl(1, and(shr(80, v), 0xff)))))\\n                mstore(0x08, mload(add(tableptr, shl(1, and(shr(88, v), 0xff)))))\\n                mstore(0x06, mload(add(tableptr, shl(1, and(shr(96, v), 0xff)))))\\n                mstore(0x04, mload(add(tableptr, shl(1, and(shr(104, v), 0xff)))))\\n                mstore(0x02, mload(add(tableptr, shl(1, and(shr(112, v), 0xff)))))\\n                mstore(0x00, mload(add(tableptr, shl(1, and(shr(120, v), 0xff)))))\\n            }\\n\\n            mstore(result, 0x40)\\n            slice(base, table)\\n            mstore(add(result, 0x40), mload(0x1e))\\n            base := shr(128, base)\\n            slice(base, table)\\n            mstore(add(result, 0x20), mload(0x1e))\\n            mstore(0x40, add(result, 0x60))\\n        }\\n    }\\n\\n    function getSignedMessageForTxId(bytes32 txId) internal pure returns (bytes32 hashedMessage) {\\n        // we know this string length is 64 bytes\\n        string memory txIdHexString = toHexString(txId);\\n\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(add(mPtr, 32), \\\"\\\\x19Ethereum Signed Message:\\\\n210\\\")\\n            mstore(add(mPtr, 61), \\\"Signing this message will allow \\\")\\n            mstore(add(mPtr, 93), \\\"your pending funds to be spent i\\\")\\n            mstore(add(mPtr, 125), \\\"n Aztec transaction:\\\\n\\\\n0x\\\")\\n            mstore(add(mPtr, 149), mload(add(txIdHexString, 0x20)))\\n            mstore(add(mPtr, 181), mload(add(txIdHexString, 0x40)))\\n            mstore(add(mPtr, 213), \\\"\\\\n\\\\nIMPORTANT: Only sign the messa\\\")\\n            mstore(add(mPtr, 245), \\\"ge if you trust the client\\\")\\n            hashedMessage := keccak256(add(mPtr, 32), 239)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec.\\npragma solidity >=0.8.4;\\n\\nlibrary SafeCast {\\n    error SAFE_CAST_OVERFLOW();\\n\\n    function toU128(uint256 a) internal pure returns (uint128) {\\n        if (a > type(uint128).max) revert SAFE_CAST_OVERFLOW();\\n        return uint128(a);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rollup-encoder/src/interfaces/IRollupProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n// @dev For documentation of the functions within this interface see RollupProcessor contract\\ninterface IRollupProcessor {\\n    /*----------------------------------------\\n      MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function setRollupProvider(address _provider, bool _valid) external;\\n\\n    function setVerifier(address _verifier) external;\\n\\n    function setAllowThirdPartyContracts(bool _allowThirdPartyContracts) external;\\n\\n    function setDefiBridgeProxy(address _defiBridgeProxy) external;\\n\\n    function setSupportedAsset(address _token, uint256 _gasLimit) external;\\n\\n    function setSupportedBridge(address _bridge, uint256 _gasLimit) external;\\n\\n    function processRollup(bytes calldata _encodedProofData, bytes calldata _signatures) external;\\n\\n    function receiveEthFromBridge(uint256 _interactionNonce) external payable;\\n\\n    function approveProof(bytes32 _proofHash) external;\\n\\n    function depositPendingFunds(uint256 _assetId, uint256 _amount, address _owner, bytes32 _proofHash)\\n        external\\n        payable;\\n\\n    function offchainData(uint256 _rollupId, uint256 _chunk, uint256 _totalChunks, bytes calldata _offchainTxData)\\n        external;\\n\\n    function processAsyncDefiInteraction(uint256 _interactionNonce) external returns (bool);\\n\\n    /*----------------------------------------\\n      NON-MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    function rollupStateHash() external view returns (bytes32);\\n\\n    function userPendingDeposits(uint256 _assetId, address _user) external view returns (uint256);\\n\\n    function defiBridgeProxy() external view returns (address);\\n\\n    function prevDefiInteractionsHash() external view returns (bytes32);\\n\\n    function paused() external view returns (bool);\\n\\n    function verifier() external view returns (address);\\n\\n    function getDataSize() external view returns (uint256);\\n\\n    function getPendingDefiInteractionHashesLength() external view returns (uint256);\\n\\n    function getDefiInteractionHashesLength() external view returns (uint256);\\n\\n    function getAsyncDefiInteractionHashesLength() external view returns (uint256);\\n\\n    function getSupportedBridge(uint256 _bridgeAddressId) external view returns (address);\\n\\n    function getSupportedBridgesLength() external view returns (uint256);\\n\\n    function getSupportedAssetsLength() external view returns (uint256);\\n\\n    function getSupportedAsset(uint256 _assetId) external view returns (address);\\n\\n    function getEscapeHatchStatus() external view returns (bool, uint256);\\n\\n    function assetGasLimits(uint256 _bridgeAddressId) external view returns (uint256);\\n\\n    function bridgeGasLimits(uint256 _bridgeAddressId) external view returns (uint256);\\n\\n    function allowThirdPartyContracts() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"core/=src/core/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"mocks/=src/test/mocks/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"rollup-encoder/=lib/rollup-encoder/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@uniswap/v2-periphery/=lib/v2-periphery/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"bridge-deployments/=lib/aztec-connect-bridges/src/deployment/\",\r\n      \"bridge-tests/=lib/aztec-connect-bridges/src/test/\",\r\n      \"bridge-interfaces/=lib/aztec-connect-bridges/src/interfaces/\",\r\n      \"aztec-connect-bridges/=lib/aztec-connect-bridges/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_escapeBlockLowerBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_escapeBlockUpperBound\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ARRAY_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAssetId\",\"type\":\"uint256\"}],\"name\":\"BRIDGE_WITH_IDENTICAL_INPUT_ASSETS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAssetId\",\"type\":\"uint256\"}],\"name\":\"BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DAILY_CAP_SURPASSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ENCODING_BYTE_INVALID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INCONSISTENT_BRIDGE_CALL_DATA\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedIndex\",\"type\":\"uint256\"}],\"name\":\"INCORRECT_DATA_START_INDEX\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"providedDefiInteractionHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedDefiInteractionHash\",\"type\":\"bytes32\"}],\"name\":\"INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"oldStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newStateHash\",\"type\":\"bytes32\"}],\"name\":\"INCORRECT_STATE_HASH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_DEPOSIT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_ETH_PAYMENT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_TOKEN_APPROVAL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ADDRESS_NO_CODE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ASSET_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ASSET_GAS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ASSET_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BRIDGE_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BRIDGE_CALL_DATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BRIDGE_GAS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ESCAPE_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROVIDER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ROLLUP_TOPOLOGY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_SIGNATURE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LOCKED_NO_REENTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MSG_VALUE_WRONG_AMOUNT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outputValue\",\"type\":\"uint256\"}],\"name\":\"NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PAUSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAUSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PENDING_CAP_SURPASSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PROOF_VERIFICATION_FAILED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PUBLIC_INPUTS_HASH_VERIFICATION_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SAFE_CAST_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SIGNATURE_ADDRESS_IS_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SIGNATURE_RECOVERY_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"THIRD_PARTY_CONTRACTS_FLAG_NOT_SET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WITHDRAW_TO_ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_TOTAL_INPUT_VALUE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"AllowThirdPartyContractsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGasLimit\",\"type\":\"uint256\"}],\"name\":\"AssetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingCap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dailyCap\",\"type\":\"uint256\"}],\"name\":\"AssetCapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"encodedBridgeCallData\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInputValue\",\"type\":\"uint256\"}],\"name\":\"AsyncDefiBridgeProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bridgeAddressId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeGasLimit\",\"type\":\"uint256\"}],\"name\":\"BridgeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isCapped\",\"type\":\"bool\"}],\"name\":\"CappedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"encodedBridgeCallData\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInputValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalOutputValueA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalOutputValueB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"errorReason\",\"type\":\"bytes\"}],\"name\":\"DefiBridgeProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"defiBridgeProxy\",\"type\":\"address\"}],\"name\":\"DefiBridgeProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"delay\",\"type\":\"uint32\"}],\"name\":\"DelayBeforeEscapeHatchUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rollupId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chunk\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalChunks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OffchainData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rollupId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"nextExpectedDefiHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RollupProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"providerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"RollupProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifierAddress\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LISTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESUME_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowThirdPartyContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofHash\",\"type\":\"bytes32\"}],\"name\":\"approveProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetGasLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"asyncDefiInteractionHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bridgeGasLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"caps\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"available\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pendingCap\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"dailyCap\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiBridgeProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defiInteractionHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayBeforeEscapeHatch\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_proofHash\",\"type\":\"bytes32\"}],\"name\":\"depositPendingFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"depositProofApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escapeBlockLowerBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escapeBlockUpperBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethPayments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsyncDefiInteractionHashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCapped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"capped\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dataSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefiInteractionHashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEscapeHatchStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementationVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingDefiInteractionHashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getSupportedAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedAssetsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bridgeAddressId\",\"type\":\"uint256\"}],\"name\":\"getSupportedBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedBridgesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRollupTimeStamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rollupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chunk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalChunks\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"offchainData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingDefiInteractions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"encodedBridgeCallData\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInputValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prevDefiInteractionsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interactionNonce\",\"type\":\"uint256\"}],\"name\":\"processAsyncDefiInteraction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"processRollup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interactionNonce\",\"type\":\"uint256\"}],\"name\":\"receiveEthFromBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rollupProviders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupStateHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowThirdPartyContracts\",\"type\":\"bool\"}],\"name\":\"setAllowThirdPartyContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_pendingCap\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_dailyCap\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_precision\",\"type\":\"uint8\"}],\"name\":\"setAssetCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isCapped\",\"type\":\"bool\"}],\"name\":\"setCapped\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defiBridgeProxy\",\"type\":\"address\"}],\"name\":\"setDefiBridgeProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_delay\",\"type\":\"uint32\"}],\"name\":\"setDelayBeforeEscapeHatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_valid\",\"type\":\"bool\"}],\"name\":\"setRollupProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"setSupportedAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"setSupportedBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPendingDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RollupProcessorV3", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000008700000000000000000000000000000000000000000000000000000000000000960", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}