{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n#########################################################\\n# ____    _    ____  _____ ____    _    ___    __   __  #\\n#| __ )  / \\\\  / ___|| ____|  _ \\\\  / \\\\  |_ _|  / /___\\\\ \\\\ #\\n#|  _ \\\\ / _ \\\\ \\\\___ \\\\|  _| | | | |/ _ \\\\  | |  / /_____\\\\ \\\\#\\n#| |_) / ___ \\\\ ___) | |___| |_| / ___ \\\\ | |  \\\\ \\\\_____/ /#\\n#|____/_/___\\\\_\\\\____/|_____|____/_/_  \\\\_\\\\___|  \\\\_\\\\   /_/ #\\n#| __ )|  _ \\\\|_ _|  _ \\\\ / ___| ____|                    #\\n#|  _ \\\\| |_) || || | | | |  _|  _|                      #\\n#| |_) |  _ < | || |_| | |_| | |___                     #\\n#|____/|_| \\\\_\\\\___|____/ \\\\____|_____|                    #\\n#########################################################   \\n# BRIDGE REWARDS - Bridge.sol - www.getbased.ai         #\\n#########################################################\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ninterface IERC20 {\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ninterface IERC721 {\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n}\\n\\ncontract BasedAIBridge is ReentrancyGuard, Pausable {\\n    IERC20 public pepeCoin;\\n    IERC721 public brainNFT;\\n    address public owner;\\n    address public pepeCoinAddress;\\n    bool public mainnetLive;\\n    uint256 public startTime;\\n\\n    struct Stake {\\n        address tokenAddress;\\n        uint256 amount;\\n        uint256 timestamp;\\n        uint256 rate;\\n        uint256[] brainIds;\\n    }\\n\\n    struct TokenConfig {\\n        uint256 initialRate;\\n        uint256 rateIncreaseAmount;\\n        uint256 rateIncreaseInterval;\\n        bool isSupported;\\n    }\\n\\n    mapping(address => Stake[]) public stakes;\\n    mapping(address => uint256) public credits;\\n    mapping(address => bool) public hasStaked;\\n    mapping(address => uint256) public lastKnownCredits;\\n    address[] public stakers;\\n    mapping(address => TokenConfig) public tokenConfigs;\\n    mapping(address => uint256) public finalScores; \\n\\n    event Staked(address indexed user, address tokenAddress, uint256 amount, uint256 timestamp, uint256 rate);\\n    event BrainStaked(address indexed user, uint256 tokenId, uint256 timestamp, uint256 rate);\\n    event MainnetActivated();\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event BrainWithdrawn(address indexed user, uint256 tokenId);\\n    event CreditsUpdated(address indexed user, uint256 credits);\\n    event FinalScoreRecorded(address indexed user, uint256 finalScore);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner can call this function.\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        pepeCoinAddress = 0xA9E8aCf069C58aEc8825542845Fd754e41a9489A;\\n        pepeCoin = IERC20(0xA9E8aCf069C58aEc8825542845Fd754e41a9489A);\\n        brainNFT = IERC721(0xA9E8aCf069C58aEc8825542845Fd754e41a9489A);\\n        owner = msg.sender;\\n        mainnetLive = false;\\n        startTime = block.timestamp;\\n\\n        tokenConfigs[0xA9E8aCf069C58aEc8825542845Fd754e41a9489A] = TokenConfig({\\n            initialRate: 500,\\n            rateIncreaseAmount: 0,\\n            rateIncreaseInterval: 30 days,\\n            isSupported: true\\n        });\\n    }\\n\\n    // For user with TFT Enforcer\\n    function getCurrentRate(address tokenAddress) public view returns (uint256) {\\n        TokenConfig storage config = tokenConfigs[tokenAddress];\\n        uint256 timeElapsed = block.timestamp - startTime;\\n        uint256 periods = timeElapsed / config.rateIncreaseInterval;\\n        return config.initialRate + (config.rateIncreaseAmount * periods);\\n    }\\n\\n    function setBasedBrainNFT(address tokenAddress) external onlyOwner {\\n        brainNFT = IERC721(tokenAddress);\\n    }\\n\\n    function addOrUpdateToken(address tokenAddress, uint256 _initialRate, uint256 _rateIncreaseAmount, uint256 _rateIncreaseInterval) external onlyOwner {\\n        tokenConfigs[tokenAddress] = TokenConfig({\\n            initialRate: _initialRate, // 500 for Pepecoin, 5000 for Brain Specific Token, 5 for Brain Credits, 5800 for $BASED, 1000 for FHE-ORDERBOOK Brain Token\\n            rateIncreaseAmount: _rateIncreaseAmount,\\n            rateIncreaseInterval: _rateIncreaseInterval,\\n            isSupported: true\\n        });\\n    }\\n\\n    function removeToken(address tokenAddress) external onlyOwner {\\n        tokenConfigs[tokenAddress].isSupported = false;\\n    }\\n\\n    function stake(address tokenAddress, uint256 _amount) external whenNotPaused nonReentrant {\\n        require(_amount > 0, \\\"Amount must be greater than zero\\\");\\n        require(tokenConfigs[tokenAddress].isSupported, \\\"Token is not supported for staking\\\");\\n        require(!mainnetLive, \\\"Mainnet is live!\\\");\\n\\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), _amount);\\n        uint256 currentRate = tokenConfigs[tokenAddress].initialRate;\\n\\n        // Empty brain array\\n        uint256[] memory brainIds = new uint256[](0);\\n        \\n        // Recover all credits if in the first 30 days\\n        if (block.timestamp - startTime <= 30 days) {\\n            credits[msg.sender] += lastKnownCredits[msg.sender];\\n            lastKnownCredits[msg.sender] = 0;\\n        }\\n        \\n        _addStake(msg.sender, tokenAddress, _amount, brainIds, currentRate);\\n    }\\n\\n    function _addStake(address _staker, address _tokenAddress, uint256 _amount, uint256[] memory _brainIds, uint256 _rate) private {\\n        if (!hasStaked[_staker]) {\\n            hasStaked[_staker] = true;\\n            stakers.push(_staker);\\n        }\\n\\n        stakes[_staker].push(Stake({\\n            tokenAddress: _tokenAddress,\\n            amount: _amount,\\n            timestamp: block.timestamp,\\n            rate: _rate,\\n            brainIds: _brainIds\\n        }));\\n        emit Staked(_staker, _tokenAddress, _amount, block.timestamp, _rate);\\n    }\\n\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\\n        require(tokenAddress != pepeCoinAddress, \\\"Unable to remove prebriged PepeCoin\\\");\\n        IERC20(tokenAddress).transfer(owner, tokenAmount);\\n    }\\n\\n    function recoverERC721(address tokenAddress, uint256 tokenId) external onlyOwner {\\n        IERC721(tokenAddress).transferFrom(address(this), owner, tokenId);\\n    }\\n\\n    function stakeBrain(uint256 _tokenId) external whenNotPaused nonReentrant {\\n        require(brainNFT.ownerOf(_tokenId) == msg.sender, \\\"Not the owner of the Brain\\\");\\n        require(!mainnetLive, \\\"Mainnet is live!\\\");\\n        brainNFT.transferFrom(msg.sender, address(this), _tokenId);\\n        uint256 currentRate = tokenConfigs[address(pepeCoin)].initialRate;\\n\\n        uint256[] memory brainIds = new uint256[](1);\\n        brainIds[0] = _tokenId;\\n\\n        _addStake(msg.sender, address(pepeCoin), 100000 * (10 ** 18), brainIds, currentRate);\\n        emit BrainStaked(msg.sender, _tokenId, block.timestamp, currentRate);\\n    }\\n\\n    function withdraw() external whenNotPaused nonReentrant {\\n        uint256 totalStaked = 0;\\n        uint256 stakeCount = stakes[msg.sender].length;\\n        \\n        // make sure the users credits are calculated.\\n        if (block.timestamp - startTime <= 30 days) {\\n            // Store any previous credit balances\\n            lastKnownCredits[msg.sender] = credits[msg.sender];\\n            // Update the credit table to the latest\\n            updateCredits(msg.sender);\\n            // Combine the old and new updated credits\\n            lastKnownCredits[msg.sender] += credits[msg.sender];\\n        }\\n\\n        for (uint i = stakeCount; i > 0; i--) {\\n            uint index = i - 1;\\n            Stake storage stake = stakes[msg.sender][index];\\n            totalStaked += stake.amount;\\n\\n            // If it is a Brain they can only withdraw the Brain\\n            if (stake.brainIds.length == 0) {\\n                IERC20(stake.tokenAddress).transfer(msg.sender, stake.amount);\\n                emit Withdrawn(msg.sender, stake.amount);\\n            }\\n            \\n            // Transfer any Brain NFTs back to the user\\n            for (uint j = 0; j < stake.brainIds.length; j++) {\\n                brainNFT.transferFrom(address(this), msg.sender, stake.brainIds[j]);\\n                emit BrainWithdrawn(msg.sender, stake.brainIds[j]);\\n            }\\n            \\n            stakes[msg.sender][index] = stakes[msg.sender][stakes[msg.sender].length - 1];\\n            stakes[msg.sender].pop();\\n        }\\n\\n        require(totalStaked > 0, \\\"Nothing to remove from BasedAI bridge\\\");\\n        credits[msg.sender] = 0;\\n\\n    }\\n\\n    function triggerMainnetLive() external onlyOwner {\\n        mainnetLive = true;\\n        for (uint i = 0; i < stakers.length; i++) {\\n            finalScores[stakers[i]] = getCredits(stakers[i]) + credits[stakers[i]];\\n            finalScores[stakers[i]] += lastKnownCredits[stakers[i]];\\n            emit FinalScoreRecorded(stakers[i], finalScores[stakers[i]]);\\n        }\\n        emit MainnetActivated();\\n    }\\n\\n    function getFinalScore(address staker) public view returns (uint256) {\\n        require(mainnetLive, \\\"BasedAI Mainnet is not live yet\\\");\\n        return finalScores[staker];\\n    }\\n\\n    function getCredits(address staker) private view returns (uint256) {\\n        uint256 totalCredits = 0;\\n        for (uint i = 0; i < stakes[staker].length; i++) {\\n            totalCredits += calculateCredits(stakes[staker][i]);\\n        }\\n        return totalCredits;\\n    }\\n\\n    function updateCredits(address staker) private {\\n        uint256 totalCredits = 0;\\n        for (uint i = 0; i < stakes[staker].length; i++) {\\n            totalCredits += calculateCredits(stakes[staker][i]);\\n        }\\n        credits[staker] = totalCredits;\\n    }\\n\\n    function calculateCredits(Stake memory stake) private view returns (uint256) {\\n        uint256 durationInSeconds = block.timestamp - stake.timestamp;\\n        uint256 accruedCredits = (stake.amount / stake.rate) * durationInSeconds / 86400; \\n        return accruedCredits;\\n    }\\n\\n    function calculateTotalCredits(address staker) public view returns (uint256) {\\n        if (mainnetLive) return finalScores[staker];\\n        uint256 totalCredits = 0;\\n        for (uint i = 0; i < stakes[staker].length; i++) {\\n            totalCredits += calculateCredits(stakes[staker][i]);\\n        }\\n        // add any leftover credits collected if they participated in Brain burn or Brain credits\\n        totalCredits += lastKnownCredits[staker];\\n        totalCredits += credits[staker];\\n        return totalCredits;\\n    }\\n\\n    // Credits the user recovers if they restake. \\n    function calculateReturnCredits(address staker) public view returns (uint256) {\\n        if (mainnetLive) return finalScores[staker];\\n        return lastKnownCredits[staker];\\n    }\\n\\n    // calculates from a current stake how much a user has earned \\n    function calculateCreditsPerToken(address staker, address _tokenAddress) public view returns (uint256) {\\n        require(!mainnetLive, \\\"Mainnet is live, claim all rewards.\\\");\\n        uint256 totalCredits = 0;\\n        for (uint i = 0; i < stakes[staker].length; i++) {\\n            if (stakes[staker][i].tokenAddress == _tokenAddress) {\\n                totalCredits += calculateCredits(stakes[staker][i]);\\n            }\\n        }\\n        return totalCredits;\\n    }\\n\\n    function setCreditsForAddress(address _user, uint256 _credits) external onlyOwner {\\n        credits[_user] = _credits;\\n        emit CreditsUpdated(_user, _credits);\\n    }\\n\\n    function getStakedAmount(address user, address tokenAddress) public view returns (uint256) {\\n        uint256 totalStaked = 0;\\n        for (uint i = 0; i < stakes[user].length; i++) {\\n            if (stakes[user][i].tokenAddress == tokenAddress) {\\n                totalStaked += stakes[user][i].amount;\\n            }\\n        }\\n        return totalStaked;\\n    }\\n\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n}\\n\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"BrainStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"BrainWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"credits\",\"type\":\"uint256\"}],\"name\":\"CreditsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalScore\",\"type\":\"uint256\"}],\"name\":\"FinalScoreRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MainnetActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rateIncreaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rateIncreaseInterval\",\"type\":\"uint256\"}],\"name\":\"addOrUpdateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brainNFT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"calculateCreditsPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"calculateReturnCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"calculateTotalCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"credits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"finalScores\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getCurrentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getFinalScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastKnownCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainnetLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pepeCoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pepeCoinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"recoverERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setBasedBrainNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"}],\"name\":\"setCreditsForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"stakeBrain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenConfigs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateIncreaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateIncreaseInterval\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerMainnetLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BasedAIBridge", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}