{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IUpgradable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidCodeHash();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n    error NotProxy();\\n\\n    event Upgraded(address indexed newImplementation);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    // Get current owner\\n    function owner() external view returns (address);\\n\\n    function contractId() external pure returns (bytes32);\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external;\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IUpgradable.sol';\\n\\nabstract contract Upgradable is IUpgradable {\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert NotOwner();\\n        _;\\n    }\\n\\n    function owner() public view returns (address owner_) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            owner_ := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        if (newOwner == address(0)) revert InvalidOwner();\\n\\n        emit OwnershipTransferred(newOwner);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_OWNER_SLOT, newOwner)\\n        }\\n    }\\n\\n    function implementation() public view returns (address implementation_) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external override onlyOwner {\\n        if (IUpgradable(newImplementation).contractId() != IUpgradable(this).contractId())\\n            revert InvalidImplementation();\\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\\n\\n        if (params.length > 0) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(this.setup.selector, params));\\n\\n            if (!success) revert SetupFailed();\\n        }\\n\\n        emit Upgraded(newImplementation);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\\n        }\\n    }\\n\\n    function setup(bytes calldata data) external override {\\n        // Prevent setup from being called on the implementation\\n        if (implementation() == address(0)) revert NotProxy();\\n\\n        _setup(data);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function _setup(bytes calldata data) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ISquidFeeCollector {\\n    event FeeCollected(address token, address integrator, uint256 squidFee, uint256 integratorFee);\\n    event FeeWithdrawn(address token, address account, uint256 amount);\\n\\n    error TransferFailed();\\n    error ExcessiveIntegratorFee();\\n\\n    function collectFee(address token, uint256 amountToTax, address integratorAddress, uint256 integratorFee) external;\\n\\n    function withdrawFee(address token) external;\\n\\n    function getBalance(address token, address account) external view returns (uint256 accountBalance);\\n}\\n\"\r\n    },\r\n    \"contracts/router/SquidFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {Upgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol\\\";\\nimport {ISquidFeeCollector} from \\\"../interfaces/ISquidFeeCollector.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract SquidFeeCollector is ISquidFeeCollector, Upgradable {\\n    bytes32 private constant BALANCES_PREFIX = keccak256(\\\"SquidFeeCollector.balances\\\");\\n    bytes32 private constant SPECIFIC_FEES_PREFIX = keccak256(\\\"SquidFeeCollector.specificFees\\\");\\n    address public immutable squidTeam;\\n    // Value expected with 2 decimals\\n    /// eg. 825 is 8.25%\\n    uint256 public immutable squidDefaultFee;\\n\\n    error ZeroAddressProvided();\\n\\n    constructor(address _squidTeam, uint256 _squidDefaultFee) {\\n        if (_squidTeam == address(0)) revert ZeroAddressProvided();\\n\\n        squidTeam = _squidTeam;\\n        squidDefaultFee = _squidDefaultFee;\\n    }\\n\\n    /// @param integratorFee Value expected with 2 decimals\\n    /// eg. 825 is 8.25%\\n    function collectFee(address token, uint256 amountToTax, address integratorAddress, uint256 integratorFee) external {\\n        if (integratorFee > 1000) revert ExcessiveIntegratorFee();\\n\\n        uint256 specificFee = getSpecificFee(integratorAddress);\\n        uint256 squidFee = specificFee == 0 ? squidDefaultFee : specificFee;\\n\\n        uint256 baseFeeAmount = (amountToTax * integratorFee) / 10000;\\n        uint256 squidFeeAmount = (baseFeeAmount * squidFee) / 10000;\\n        uint256 integratorFeeAmount = baseFeeAmount - squidFeeAmount;\\n\\n        _safeTransferFrom(token, msg.sender, baseFeeAmount);\\n        _setBalance(token, squidTeam, getBalance(token, squidTeam) + squidFeeAmount);\\n        _setBalance(token, integratorAddress, getBalance(token, integratorAddress) + integratorFeeAmount);\\n\\n        emit FeeCollected(token, integratorAddress, squidFeeAmount, integratorFeeAmount);\\n    }\\n\\n    function withdrawFee(address token) external {\\n        uint256 balance = getBalance(token, msg.sender);\\n        _setBalance(token, msg.sender, 0);\\n        _safeTransfer(token, msg.sender, balance);\\n\\n        emit FeeWithdrawn(token, msg.sender, balance);\\n    }\\n\\n    function setSpecificFee(address integrator, uint256 fee) external onlyOwner {\\n        bytes32 slot = _computeSpecificFeeSlot(integrator);\\n        assembly {\\n            sstore(slot, fee)\\n        }\\n    }\\n\\n    function getBalance(address token, address account) public view returns (uint256 value) {\\n        bytes32 slot = _computeBalanceSlot(token, account);\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function getSpecificFee(address integrator) public view returns (uint256 value) {\\n        bytes32 slot = _computeSpecificFeeSlot(integrator);\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function contractId() external pure returns (bytes32 id) {\\n        id = keccak256(\\\"squid-fee-collector\\\");\\n    }\\n\\n    function _setBalance(address token, address account, uint256 amount) private {\\n        bytes32 slot = _computeBalanceSlot(token, account);\\n        assembly {\\n            sstore(slot, amount)\\n        }\\n    }\\n\\n    function _computeBalanceSlot(address token, address account) private pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encodePacked(BALANCES_PREFIX, token, account));\\n    }\\n\\n    function _computeSpecificFeeSlot(address integrator) private pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encodePacked(SPECIFIC_FEES_PREFIX, integrator));\\n    }\\n\\n    function _safeTransferFrom(address token, address from, uint256 amount) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _safeTransfer(address token, address to, uint256 amount) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_squidTeam\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_squidDefaultFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExcessiveIntegratorFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCodeHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetupFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressProvided\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"squidFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"integratorFee\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToTax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"integratorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"integratorFee\",\"type\":\"uint256\"}],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"}],\"name\":\"getSpecificFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setSpecificFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"squidDefaultFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"squidTeam\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"newImplementationCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SquidFeeCollector", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "0000000000000000000000007178d1a731a245f7620daa6db6111ef531a91d0d0000000000000000000000000000000000000000000000000000000000001388", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}