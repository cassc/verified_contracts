{"SourceCode": "// Sources flattened with hardhat v2.22.2 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only AND MIT\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol@v1.4.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// End consumer library.\r\nlibrary Client {\r\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\r\n  struct EVMTokenAmount {\r\n    address token; // token address on the local chain.\r\n    uint256 amount; // Amount of tokens.\r\n  }\r\n\r\n  struct Any2EVMMessage {\r\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\r\n    uint64 sourceChainSelector; // Source chain selector.\r\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\r\n    bytes data; // payload sent in original message.\r\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\r\n  }\r\n\r\n  // If extraArgs is empty bytes, the default is 200k gas limit.\r\n  struct EVM2AnyMessage {\r\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\r\n    bytes data; // Data payload\r\n    EVMTokenAmount[] tokenAmounts; // Token transfers\r\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\r\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\r\n  }\r\n\r\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\r\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\r\n  struct EVMExtraArgsV1 {\r\n    uint256 gasLimit;\r\n  }\r\n\r\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\r\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol@v1.4.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouterClient {\r\n  error UnsupportedDestinationChain(uint64 destChainSelector);\r\n  error InsufficientFeeTokenAmount();\r\n  error InvalidMsgValue();\r\n\r\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\r\n  /// @param chainSelector The chain to check.\r\n  /// @return supported is true if it is supported, false if not.\r\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\r\n\r\n  /// @notice Gets a list of all supported tokens which can be sent or received\r\n  /// to/from a given chain id.\r\n  /// @param chainSelector The chainSelector.\r\n  /// @return tokens The addresses of all tokens that are supported.\r\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\r\n\r\n  /// @param destinationChainSelector The destination chainSelector\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return fee returns execution fee for the message\r\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\r\n  /// @dev Reverts with appropriate reason upon invalid message.\r\n  function getFee(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage memory message\r\n  ) external view returns (uint256 fee);\r\n\r\n  /// @notice Request a message to be sent to the destination chain\r\n  /// @param destinationChainSelector The destination chain ID\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return messageId The message ID\r\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\r\n  /// the overpayment with no refund.\r\n  /// @dev Reverts with appropriate reason upon invalid message.\r\n  function ccipSend(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage calldata message\r\n  ) external payable returns (bytes32);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.8.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.8.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/Pausable.sol@v4.8.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File contracts/helpers/AddressHelper.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @notice Emitted when the account is not a contract\r\n * @param account The account address\r\n */\r\nerror NonContractAddressError(address account);\r\n\r\n/**\r\n * @notice Function to check if the account is a contract\r\n * @return The account contract status flag\r\n */\r\nfunction isContract(address _account) view returns (bool) {\r\n    return _account.code.length > 0;\r\n}\r\n\r\n/**\r\n * @notice Function to require an account to be a contract\r\n */\r\nfunction requireContract(address _account) view {\r\n    if (!isContract(_account)) {\r\n        revert NonContractAddressError(_account);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Function to require an account to be a contract or a zero address\r\n */\r\nfunction requireContractOrZeroAddress(address _account) view {\r\n    if (_account != address(0)) {\r\n        requireContract(_account);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Constants.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @dev The default token decimals value\r\n */\r\nuint256 constant DECIMALS_DEFAULT = 18;\r\n\r\n/**\r\n * @dev The maximum uint256 value for swap amount limit settings\r\n */\r\nuint256 constant INFINITY = type(uint256).max;\r\n\r\n/**\r\n * @dev The default limit of account list size\r\n */\r\nuint256 constant LIST_SIZE_LIMIT_DEFAULT = 100;\r\n\r\n/**\r\n * @dev The limit of swap router list size\r\n */\r\nuint256 constant LIST_SIZE_LIMIT_ROUTERS = 200;\r\n\r\n/**\r\n * @dev The factor for percentage settings. Example: 100 is 0.1%\r\n */\r\nuint256 constant MILLIPERCENT_FACTOR = 100_000;\r\n\r\n/**\r\n * @dev The de facto standard address to denote the native token\r\n */\r\naddress constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n\r\n// File contracts/helpers/TransferHelper.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @notice Emitted when an approval action fails\r\n */\r\nerror SafeApproveError();\r\n\r\n/**\r\n * @notice Emitted when a transfer action fails\r\n */\r\nerror SafeTransferError();\r\n\r\n/**\r\n * @notice Emitted when a transferFrom action fails\r\n */\r\nerror SafeTransferFromError();\r\n\r\n/**\r\n * @notice Emitted when a transfer of the native token fails\r\n */\r\nerror SafeTransferNativeError();\r\n\r\n/**\r\n * @notice Safely approve the token to the account\r\n * @param _token The token address\r\n * @param _to The token approval recipient address\r\n * @param _value The token approval amount\r\n */\r\nfunction safeApprove(address _token, address _to, uint256 _value) {\r\n    // 0x095ea7b3 is the selector for \"approve(address,uint256)\"\r\n    (bool success, bytes memory data) = _token.call(\r\n        abi.encodeWithSelector(0x095ea7b3, _to, _value)\r\n    );\r\n\r\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n    if (!condition) {\r\n        revert SafeApproveError();\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Safely transfer the token to the account\r\n * @param _token The token address\r\n * @param _to The token transfer recipient address\r\n * @param _value The token transfer amount\r\n */\r\nfunction safeTransfer(address _token, address _to, uint256 _value) {\r\n    // 0xa9059cbb is the selector for \"transfer(address,uint256)\"\r\n    (bool success, bytes memory data) = _token.call(\r\n        abi.encodeWithSelector(0xa9059cbb, _to, _value)\r\n    );\r\n\r\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n    if (!condition) {\r\n        revert SafeTransferError();\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Safely transfer the token between the accounts\r\n * @param _token The token address\r\n * @param _from The token transfer source address\r\n * @param _to The token transfer recipient address\r\n * @param _value The token transfer amount\r\n */\r\nfunction safeTransferFrom(address _token, address _from, address _to, uint256 _value) {\r\n    // 0x23b872dd is the selector for \"transferFrom(address,address,uint256)\"\r\n    (bool success, bytes memory data) = _token.call(\r\n        abi.encodeWithSelector(0x23b872dd, _from, _to, _value)\r\n    );\r\n\r\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n    if (!condition) {\r\n        revert SafeTransferFromError();\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Safely transfer the native token to the account\r\n * @param _to The native token transfer recipient address\r\n * @param _value The native token transfer amount\r\n */\r\nfunction safeTransferNative(address _to, uint256 _value) {\r\n    (bool success, ) = _to.call{ value: _value }(new bytes(0));\r\n\r\n    if (!success) {\r\n        revert SafeTransferNativeError();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITokenBalance.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @title ITokenBalance\r\n * @notice Token balance interface\r\n */\r\ninterface ITokenBalance {\r\n    /**\r\n     * @notice Getter of the token balance by the account\r\n     * @param _account The account address\r\n     * @return Token balance\r\n     */\r\n    function balanceOf(address _account) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/DataStructures.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @notice Optional value structure\r\n * @dev Is used in mappings to allow zero values\r\n * @param isSet Value presence flag\r\n * @param value Numeric value\r\n */\r\nstruct OptionalValue {\r\n    bool isSet;\r\n    uint256 value;\r\n}\r\n\r\n/**\r\n * @notice Key-to-value structure\r\n * @dev Is used as an array parameter item to perform multiple key-value settings\r\n * @param key Numeric key\r\n * @param value Numeric value\r\n */\r\nstruct KeyToValue {\r\n    uint256 key;\r\n    uint256 value;\r\n}\r\n\r\n/**\r\n * @notice Key-to-value structure for address values\r\n * @dev Is used as an array parameter item to perform multiple key-value settings with address values\r\n * @param key Numeric key\r\n * @param value Address value\r\n */\r\nstruct KeyToAddressValue {\r\n    uint256 key;\r\n    address value;\r\n}\r\n\r\n/**\r\n * @notice Address-to-flag structure\r\n * @dev Is used as an array parameter item to perform multiple settings\r\n * @param account Account address\r\n * @param flag Flag value\r\n */\r\nstruct AccountToFlag {\r\n    address account;\r\n    bool flag;\r\n}\r\n\r\n/**\r\n * @notice Emitted when a list exceeds the size limit\r\n */\r\nerror ListSizeLimitError();\r\n\r\n/**\r\n * @notice Sets or updates a value in a combined map (a mapping with a key list and key index mapping)\r\n * @param _map The mapping reference\r\n * @param _keyList The key list reference\r\n * @param _keyIndexMap The key list index mapping reference\r\n * @param _key The numeric key\r\n * @param _value The address value\r\n * @param _sizeLimit The map and list size limit\r\n * @return isNewKey True if the key was just added, otherwise false\r\n */\r\nfunction combinedMapSet(\r\n    mapping(uint256 => address) storage _map,\r\n    uint256[] storage _keyList,\r\n    mapping(uint256 => OptionalValue) storage _keyIndexMap,\r\n    uint256 _key,\r\n    address _value,\r\n    uint256 _sizeLimit\r\n) returns (bool isNewKey) {\r\n    isNewKey = !_keyIndexMap[_key].isSet;\r\n\r\n    if (isNewKey) {\r\n        uniqueListAdd(_keyList, _keyIndexMap, _key, _sizeLimit);\r\n    }\r\n\r\n    _map[_key] = _value;\r\n}\r\n\r\n/**\r\n * @notice Removes a value from a combined map (a mapping with a key list and key index mapping)\r\n * @param _map The mapping reference\r\n * @param _keyList The key list reference\r\n * @param _keyIndexMap The key list index mapping reference\r\n * @param _key The numeric key\r\n * @return isChanged True if the combined map was changed, otherwise false\r\n */\r\nfunction combinedMapRemove(\r\n    mapping(uint256 => address) storage _map,\r\n    uint256[] storage _keyList,\r\n    mapping(uint256 => OptionalValue) storage _keyIndexMap,\r\n    uint256 _key\r\n) returns (bool isChanged) {\r\n    isChanged = _keyIndexMap[_key].isSet;\r\n\r\n    if (isChanged) {\r\n        delete _map[_key];\r\n        uniqueListRemove(_keyList, _keyIndexMap, _key);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Adds a value to a unique value list (a list with value index mapping)\r\n * @param _list The list reference\r\n * @param _indexMap The value index mapping reference\r\n * @param _value The numeric value\r\n * @param _sizeLimit The list size limit\r\n * @return isChanged True if the list was changed, otherwise false\r\n */\r\nfunction uniqueListAdd(\r\n    uint256[] storage _list,\r\n    mapping(uint256 => OptionalValue) storage _indexMap,\r\n    uint256 _value,\r\n    uint256 _sizeLimit\r\n) returns (bool isChanged) {\r\n    isChanged = !_indexMap[_value].isSet;\r\n\r\n    if (isChanged) {\r\n        if (_list.length >= _sizeLimit) {\r\n            revert ListSizeLimitError();\r\n        }\r\n\r\n        _indexMap[_value] = OptionalValue(true, _list.length);\r\n        _list.push(_value);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Removes a value from a unique value list (a list with value index mapping)\r\n * @param _list The list reference\r\n * @param _indexMap The value index mapping reference\r\n * @param _value The numeric value\r\n * @return isChanged True if the list was changed, otherwise false\r\n */\r\nfunction uniqueListRemove(\r\n    uint256[] storage _list,\r\n    mapping(uint256 => OptionalValue) storage _indexMap,\r\n    uint256 _value\r\n) returns (bool isChanged) {\r\n    OptionalValue storage indexItem = _indexMap[_value];\r\n\r\n    isChanged = indexItem.isSet;\r\n\r\n    if (isChanged) {\r\n        uint256 itemIndex = indexItem.value;\r\n        uint256 lastIndex = _list.length - 1;\r\n\r\n        if (itemIndex != lastIndex) {\r\n            uint256 lastValue = _list[lastIndex];\r\n            _list[itemIndex] = lastValue;\r\n            _indexMap[lastValue].value = itemIndex;\r\n        }\r\n\r\n        _list.pop();\r\n        delete _indexMap[_value];\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Adds a value to a unique address value list (a list with value index mapping)\r\n * @param _list The list reference\r\n * @param _indexMap The value index mapping reference\r\n * @param _value The address value\r\n * @param _sizeLimit The list size limit\r\n * @return isChanged True if the list was changed, otherwise false\r\n */\r\nfunction uniqueAddressListAdd(\r\n    address[] storage _list,\r\n    mapping(address => OptionalValue) storage _indexMap,\r\n    address _value,\r\n    uint256 _sizeLimit\r\n) returns (bool isChanged) {\r\n    isChanged = !_indexMap[_value].isSet;\r\n\r\n    if (isChanged) {\r\n        if (_list.length >= _sizeLimit) {\r\n            revert ListSizeLimitError();\r\n        }\r\n\r\n        _indexMap[_value] = OptionalValue(true, _list.length);\r\n        _list.push(_value);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Removes a value from a unique address value list (a list with value index mapping)\r\n * @param _list The list reference\r\n * @param _indexMap The value index mapping reference\r\n * @param _value The address value\r\n * @return isChanged True if the list was changed, otherwise false\r\n */\r\nfunction uniqueAddressListRemove(\r\n    address[] storage _list,\r\n    mapping(address => OptionalValue) storage _indexMap,\r\n    address _value\r\n) returns (bool isChanged) {\r\n    OptionalValue storage indexItem = _indexMap[_value];\r\n\r\n    isChanged = indexItem.isSet;\r\n\r\n    if (isChanged) {\r\n        uint256 itemIndex = indexItem.value;\r\n        uint256 lastIndex = _list.length - 1;\r\n\r\n        if (itemIndex != lastIndex) {\r\n            address lastValue = _list[lastIndex];\r\n            _list[itemIndex] = lastValue;\r\n            _indexMap[lastValue].value = itemIndex;\r\n        }\r\n\r\n        _list.pop();\r\n        delete _indexMap[_value];\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Adds or removes a value to/from a unique address value list (a list with value index mapping)\r\n * @dev The list size limit is checked on items adding only\r\n * @param _list The list reference\r\n * @param _indexMap The value index mapping reference\r\n * @param _value The address value\r\n * @param _flag The value inclusion flag\r\n * @param _sizeLimit The list size limit\r\n * @return isChanged True if the list was changed, otherwise false\r\n */\r\nfunction uniqueAddressListUpdate(\r\n    address[] storage _list,\r\n    mapping(address => OptionalValue) storage _indexMap,\r\n    address _value,\r\n    bool _flag,\r\n    uint256 _sizeLimit\r\n) returns (bool isChanged) {\r\n    return\r\n        _flag\r\n            ? uniqueAddressListAdd(_list, _indexMap, _value, _sizeLimit)\r\n            : uniqueAddressListRemove(_list, _indexMap, _value);\r\n}\r\n\r\n\r\n// File contracts/roles/RoleBearers.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n/**\r\n * @title RoleBearers\r\n * @notice Base contract that implements role-based access control\r\n * @dev A custom implementation providing full role bearer lists\r\n */\r\nabstract contract RoleBearers {\r\n    mapping(bytes32 /*roleKey*/ => address[] /*roleBearers*/) private roleBearerTable;\r\n    mapping(bytes32 /*roleKey*/ => mapping(address /*account*/ => /*DataStructures.*/OptionalValue /*status*/))\r\n        private roleBearerIndexTable;\r\n\r\n    function _setRoleBearer(bytes32 _roleKey, address _account, bool _value) internal {\r\n        /*DataStructures.*/uniqueAddressListUpdate(\r\n            roleBearerTable[_roleKey],\r\n            roleBearerIndexTable[_roleKey],\r\n            _account,\r\n            _value,\r\n            /*Constants.*/LIST_SIZE_LIMIT_DEFAULT\r\n        );\r\n    }\r\n\r\n    function _isRoleBearer(bytes32 _roleKey, address _account) internal view returns (bool) {\r\n        return roleBearerIndexTable[_roleKey][_account].isSet;\r\n    }\r\n\r\n    function _roleBearerCount(bytes32 _roleKey) internal view returns (uint256) {\r\n        return roleBearerTable[_roleKey].length;\r\n    }\r\n\r\n    function _fullRoleBearerList(bytes32 _roleKey) internal view returns (address[] memory) {\r\n        return roleBearerTable[_roleKey];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/roles/ManagerRole.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n/**\r\n * @title ManagerRole\r\n * @notice Base contract that implements the Manager role.\r\n * The manager role is a high-permission role for core team members only.\r\n * Managers can set vaults and routers addresses, fees, cross-chain protocols,\r\n * and other parameters for Interchain (cross-chain) swaps and single-network swaps.\r\n * Please note, the manager role is unique for every contract,\r\n * hence different addresses may be assigned as managers for different contracts.\r\n */\r\nabstract contract ManagerRole is Ownable, RoleBearers {\r\n    bytes32 private constant ROLE_KEY = keccak256('Manager');\r\n\r\n    /**\r\n     * @notice Emitted when the Manager role status for the account is updated\r\n     * @param account The account address\r\n     * @param value The Manager role status flag\r\n     */\r\n    event SetManager(address indexed account, bool indexed value);\r\n\r\n    /**\r\n     * @notice Emitted when the Manager role status for the account is renounced\r\n     * @param account The account address\r\n     */\r\n    event RenounceManagerRole(address indexed account);\r\n\r\n    /**\r\n     * @notice Emitted when the caller is not a Manager role bearer\r\n     */\r\n    error OnlyManagerError();\r\n\r\n    /**\r\n     * @dev Modifier to check if the caller is a Manager role bearer\r\n     */\r\n    modifier onlyManager() {\r\n        if (!isManager(msg.sender)) {\r\n            revert OnlyManagerError();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Manager role status for the account\r\n     * @param _account The account address\r\n     * @param _value The Manager role status flag\r\n     */\r\n    function setManager(address _account, bool _value) public onlyOwner {\r\n        _setRoleBearer(ROLE_KEY, _account, _value);\r\n\r\n        emit SetManager(_account, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Renounces the Manager role\r\n     */\r\n    function renounceManagerRole() external onlyManager {\r\n        _setRoleBearer(ROLE_KEY, msg.sender, false);\r\n\r\n        emit RenounceManagerRole(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the Manager role bearer count\r\n     * @return The Manager role bearer count\r\n     */\r\n    function managerCount() external view returns (uint256) {\r\n        return _roleBearerCount(ROLE_KEY);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the complete list of the Manager role bearers\r\n     * @return The complete list of the Manager role bearers\r\n     */\r\n    function fullManagerList() external view returns (address[] memory) {\r\n        return _fullRoleBearerList(ROLE_KEY);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the Manager role bearer status\r\n     * @param _account The account address\r\n     */\r\n    function isManager(address _account) public view returns (bool) {\r\n        return _isRoleBearer(ROLE_KEY, _account);\r\n    }\r\n\r\n    function _initRoles(\r\n        address _owner,\r\n        address[] memory _managers,\r\n        bool _addOwnerToManagers\r\n    ) internal {\r\n        address ownerAddress = _owner == address(0) ? msg.sender : _owner;\r\n\r\n        for (uint256 index; index < _managers.length; index++) {\r\n            setManager(_managers[index], true);\r\n        }\r\n\r\n        if (_addOwnerToManagers && !isManager(ownerAddress)) {\r\n            setManager(ownerAddress, true);\r\n        }\r\n\r\n        if (ownerAddress != msg.sender) {\r\n            transferOwnership(ownerAddress);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/mixins/BalanceManagementMixin.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BalanceManagementMixin\r\n * @notice The balance management mix-in logic\r\n */\r\nabstract contract BalanceManagementMixin is ManagerRole {\r\n    /**\r\n     * @notice Emitted when the specified token is reserved\r\n     */\r\n    error ReservedTokenError();\r\n\r\n    /**\r\n     * @notice Performs the token cleanup\r\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\r\n     * @param _tokenAddress The address of the token\r\n     * @param _to The token transfer recipient address\r\n     */\r\n    function cleanup(address _tokenAddress, address _to) external virtual onlyManager {\r\n        _cleanupWithAmount(_tokenAddress, _to, tokenBalance(_tokenAddress));\r\n    }\r\n\r\n    /**\r\n     * @notice Performs the token cleanup using the provided amount\r\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\r\n     * @param _tokenAddress The address of the token\r\n     * @param _to The token transfer recipient address\r\n     * @param _tokenAmount The amount of the token\r\n     */\r\n    function cleanupWithAmount(\r\n        address _tokenAddress,\r\n        address _to,\r\n        uint256 _tokenAmount\r\n    ) external virtual onlyManager {\r\n        _cleanupWithAmount(_tokenAddress, _to, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the token balance of the current contract\r\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\r\n     * @param _tokenAddress The address of the token\r\n     * @return The token balance of the current contract\r\n     */\r\n    function tokenBalance(address _tokenAddress) public view virtual returns (uint256) {\r\n        if (_tokenAddress == /*Constants.*/NATIVE_TOKEN_ADDRESS) {\r\n            return address(this).balance;\r\n        } else {\r\n            return ITokenBalance(_tokenAddress).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the reserved token flag\r\n     * @dev Override to add reserved token addresses\r\n     * @param _tokenAddress The address of the token\r\n     * @return The reserved token flag\r\n     */\r\n    function isReservedToken(address _tokenAddress) public view virtual returns (bool) {\r\n        // The function returns false by default.\r\n        // The explicit return statement is omitted to avoid the unused parameter warning.\r\n        // See https://github.com/ethereum/solidity/issues/5295\r\n    }\r\n\r\n    function _cleanupWithAmount(\r\n        address _tokenAddress,\r\n        address _to,\r\n        uint256 _tokenAmount\r\n    ) internal virtual {\r\n        if (isReservedToken(_tokenAddress)) {\r\n            revert ReservedTokenError();\r\n        }\r\n\r\n        if (_tokenAddress == /*Constants.*/NATIVE_TOKEN_ADDRESS) {\r\n            /*TransferHelper.*/safeTransferNative(_to, _tokenAmount);\r\n        } else {\r\n            /*TransferHelper.*/safeTransfer(_tokenAddress, _to, _tokenAmount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Pausable.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @notice Base contract that implements the emergency pause mechanism\r\n */\r\nabstract contract PausableContract is Pausable, ManagerRole {\r\n    /**\r\n     * @notice Enter pause state\r\n     */\r\n    function pause() external onlyManager whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Exit pause state\r\n     */\r\n    function unpause() external onlyManager whenPaused {\r\n        _unpause();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/SystemVersionId.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @title SystemVersionId\r\n * @notice Base contract providing the system version identifier\r\n */\r\nabstract contract SystemVersionId {\r\n    /**\r\n     * @dev The system version identifier\r\n     */\r\n    uint256 public constant SYSTEM_VERSION_ID = uint256(keccak256('Initial'));\r\n}\r\n\r\n\r\n// File contracts/bridge/chainlink-ccip/core/InterportCCIPBridgeCore.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title InterportCCIPBridgeCore\r\n * @notice The core logic of the cross-chain bridging with Chainlink CCIP\r\n */\r\nabstract contract InterportCCIPBridgeCore is SystemVersionId, PausableContract, BalanceManagementMixin {\r\n    /**\r\n     * @notice Chain ID pair structure\r\n     * @param standardId The standard EVM chain ID\r\n     * @param ccipId The CCIP chain selector\r\n     */\r\n    struct ChainIdPair {\r\n        uint256 standardId;\r\n        uint64 ccipId;\r\n    }\r\n\r\n    /**\r\n     * @dev CCIP endpoint address\r\n     */\r\n    address public endpoint;\r\n\r\n    /**\r\n     * @dev The correspondence between standard EVM chain IDs and CCIP chain selectors\r\n     */\r\n    mapping(uint256 /*standardId*/ => uint64 /*ccipId*/) public standardToCcipChainId;\r\n\r\n    /**\r\n     * @dev The correspondence between CCIP chain selectors and standard EVM chain IDs\r\n     */\r\n    mapping(uint64 /*ccipId*/ => uint256 /*standardId*/) public ccipToStandardChainId;\r\n\r\n    /**\r\n     * @notice Emitted when the cross-chain endpoint contract reference is set\r\n     * @param endpointAddress The address of the cross-chain endpoint contract\r\n     */\r\n    event SetEndpoint(address indexed endpointAddress);\r\n\r\n    /**\r\n     * @notice Emitted when a chain ID pair is added or updated\r\n     * @param standardId The standard EVM chain ID\r\n     * @param ccipId The CCIP chain selector\r\n     */\r\n    event SetChainIdPair(uint256 indexed standardId, uint64 indexed ccipId);\r\n\r\n    /**\r\n     * @notice Emitted when a chain ID pair is removed\r\n     * @param standardId The standard EVM chain ID\r\n     * @param ccipId The CCIP chain selector\r\n     */\r\n    event RemoveChainIdPair(uint256 indexed standardId, uint64 indexed ccipId);\r\n\r\n    /**\r\n     * @notice Emitted when there is no registered CCIP chain selector matching the standard EVM chain ID\r\n     */\r\n    error CcipChainIdNotSetError();\r\n\r\n    /**\r\n     * @notice Emitted when the provided call value is not sufficient for the message processing\r\n     */\r\n    error SendValueError();\r\n\r\n    /**\r\n     * @notice Emitted when the caller is not the CCIP endpoint\r\n     */\r\n    error OnlyEndpointError();\r\n\r\n    /**\r\n     * @dev Modifier to check if the caller is the CCIP endpoint\r\n     */\r\n    modifier onlyEndpoint() {\r\n        if (msg.sender != endpoint) {\r\n            revert OnlyEndpointError();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the contract\r\n     * @param _endpointAddress The cross-chain endpoint address\r\n     * @param _chainIdPairs The correspondence between standard EVM chain IDs and CCIP chain selectors\r\n     * @param _owner The address of the initial owner of the contract\r\n     * @param _managers The addresses of initial managers of the contract\r\n     * @param _addOwnerToManagers The flag to optionally add the owner to the list of managers\r\n     */\r\n    constructor(\r\n        address _endpointAddress,\r\n        ChainIdPair[] memory _chainIdPairs,\r\n        address _owner,\r\n        address[] memory _managers,\r\n        bool _addOwnerToManagers\r\n    ) {\r\n        _setEndpoint(_endpointAddress);\r\n\r\n        for (uint256 index; index < _chainIdPairs.length; index++) {\r\n            ChainIdPair memory chainIdPair = _chainIdPairs[index];\r\n\r\n            _setChainIdPair(chainIdPair.standardId, chainIdPair.ccipId);\r\n        }\r\n\r\n        _initRoles(_owner, _managers, _addOwnerToManagers);\r\n    }\r\n\r\n    /**\r\n     * @notice The standard \"receive\" function\r\n     * @dev Is payable to allow receiving native token funds\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Sets the cross-chain endpoint contract reference\r\n     * @param _endpointAddress The address of the cross-chain endpoint contract\r\n     */\r\n    function setEndpoint(address _endpointAddress) external onlyManager {\r\n        _setEndpoint(_endpointAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds or updates registered chain ID pairs\r\n     * @param _chainIdPairs The list of chain ID pairs\r\n     */\r\n    function setChainIdPairs(ChainIdPair[] calldata _chainIdPairs) external onlyManager {\r\n        for (uint256 index; index < _chainIdPairs.length; index++) {\r\n            ChainIdPair calldata chainIdPair = _chainIdPairs[index];\r\n\r\n            _setChainIdPair(chainIdPair.standardId, chainIdPair.ccipId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes registered chain ID pairs\r\n     * @param _standardChainIds The list of standard EVM chain IDs\r\n     */\r\n    function removeChainIdPairs(uint256[] calldata _standardChainIds) external onlyManager {\r\n        for (uint256 index; index < _standardChainIds.length; index++) {\r\n            uint256 standardId = _standardChainIds[index];\r\n\r\n            _removeChainIdPair(standardId);\r\n        }\r\n    }\r\n\r\n    function _ccipSend(\r\n        uint64 _targetCcipChainId,\r\n        Client.EVM2AnyMessage memory _ccipMessage,\r\n        uint256 _ccipSendValue\r\n    ) internal virtual returns (bytes32 ccipMessageId) {\r\n        if (msg.value < _ccipSendValue) {\r\n            revert SendValueError();\r\n        }\r\n\r\n        return\r\n            IRouterClient(endpoint).ccipSend{ value: _ccipSendValue }(\r\n                _targetCcipChainId,\r\n                _ccipMessage\r\n            );\r\n    }\r\n\r\n    function _setEndpoint(address _endpoint) internal virtual {\r\n        /*AddressHelper.*/requireContract(_endpoint);\r\n\r\n        endpoint = _endpoint;\r\n\r\n        emit SetEndpoint(_endpoint);\r\n    }\r\n\r\n    function _setChainIdPair(uint256 _standardId, uint64 _ccipId) internal virtual {\r\n        standardToCcipChainId[_standardId] = _ccipId;\r\n        ccipToStandardChainId[_ccipId] = _standardId;\r\n\r\n        emit SetChainIdPair(_standardId, _ccipId);\r\n    }\r\n\r\n    function _removeChainIdPair(uint256 _standardId) internal virtual {\r\n        uint64 ccipId = standardToCcipChainId[_standardId];\r\n\r\n        delete standardToCcipChainId[_standardId];\r\n        delete ccipToStandardChainId[ccipId];\r\n\r\n        emit RemoveChainIdPair(_standardId, ccipId);\r\n    }\r\n\r\n    function _checkChainId(uint256 _chainId) internal view virtual returns (uint64 ccipChainId) {\r\n        ccipChainId = standardToCcipChainId[_chainId];\r\n\r\n        if (ccipChainId == 0) {\r\n            revert CcipChainIdNotSetError();\r\n        }\r\n    }\r\n\r\n    function _ccipGetFee(\r\n        uint64 _targetCcipChainId,\r\n        Client.EVM2AnyMessage memory _ccipMessage\r\n    ) internal view virtual returns (uint256 fee) {\r\n        return IRouterClient(endpoint).getFee(_targetCcipChainId, _ccipMessage);\r\n    }\r\n\r\n    function _createCcipMessage(\r\n        address _receiverAddress, // The receiver may be an EOA or a contract\r\n        bytes memory _data,\r\n        Client.EVMTokenAmount[] memory _tokenAmounts,\r\n        uint256 _targetGasLimit\r\n    ) internal pure virtual returns (Client.EVM2AnyMessage memory) {\r\n        return\r\n            Client.EVM2AnyMessage({\r\n                receiver: abi.encode(_receiverAddress), // ABI-encoded receiver address\r\n                data: _data,\r\n                tokenAmounts: _tokenAmounts,\r\n                extraArgs: Client._argsToBytes(\r\n                    Client.EVMExtraArgsV1({ gasLimit: _targetGasLimit })\r\n                ),\r\n                feeToken: address(0) // Native token\r\n            });\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.8.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bridge/chainlink-ccip/InterportCCIPTokenBridge.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title InterportCCIPTokenBridge\r\n * @notice The contract bridges ERC-20 tokens with Chainlink CCIP\r\n */\r\ncontract InterportCCIPTokenBridge is InterportCCIPBridgeCore, ReentrancyGuard {\r\n    /**\r\n     * @notice The \"bridgeTokens\" action parameters\r\n     * @param targetChainId The message target chain ID (EVM)\r\n     * @param targetRecipient The address of the recipient on the target chain\r\n     * @param tokenAmounts Token amount data\r\n     */\r\n    struct TokenBridgeAction {\r\n        uint256 targetChainId;\r\n        address targetRecipient;\r\n        Client.EVMTokenAmount[] tokenAmounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Token bridge action source event\r\n     * @param targetChainId The ID of the target chain\r\n     * @param sourceSender The address of the user on the source chain\r\n     * @param targetRecipient The address of the recipient on the target chain\r\n     * @param tokenAmounts Token amount data\r\n     * @param reserve The reserve amount\r\n     * @param ccipMessageId The CCIP message ID\r\n     * @param timestamp The timestamp of the action (in seconds)\r\n     */\r\n    event TokenBridgeActionSource(\r\n        uint256 targetChainId,\r\n        address indexed sourceSender,\r\n        address targetRecipient,\r\n        Client.EVMTokenAmount[] tokenAmounts,\r\n        uint256 reserve,\r\n        bytes32 indexed ccipMessageId,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @notice Initializes the contract\r\n     * @param _endpointAddress The cross-chain endpoint address\r\n     * @param _chainIdPairs The correspondence between standard EVM chain IDs and CCIP chain selectors\r\n     * @param _owner The address of the initial owner of the contract\r\n     * @param _managers The addresses of initial managers of the contract\r\n     * @param _addOwnerToManagers The flag to optionally add the owner to the list of managers\r\n     */\r\n    constructor(\r\n        address _endpointAddress,\r\n        ChainIdPair[] memory _chainIdPairs,\r\n        address _owner,\r\n        address[] memory _managers,\r\n        bool _addOwnerToManagers\r\n    )\r\n        InterportCCIPBridgeCore(\r\n            _endpointAddress,\r\n            _chainIdPairs,\r\n            _owner,\r\n            _managers,\r\n            _addOwnerToManagers\r\n        )\r\n    {}\r\n\r\n    /**\r\n     * @notice Cross-chain bridging of ERC-20 tokens\r\n     * @param _action The action parameters\r\n     * @param _ccipSendValue The CCIP processing value\r\n     */\r\n    function bridgeTokens(\r\n        TokenBridgeAction calldata _action,\r\n        uint256 _ccipSendValue\r\n    ) external payable whenNotPaused nonReentrant returns (bytes32 ccipMessageId) {\r\n        uint64 targetCcipChainId = _checkChainId(_action.targetChainId);\r\n\r\n        for (uint256 index; index < _action.tokenAmounts.length; index++) {\r\n            Client.EVMTokenAmount calldata tokenAmountData = _action.tokenAmounts[index];\r\n\r\n            /*TransferHelper.*/safeTransferFrom(\r\n                tokenAmountData.token,\r\n                msg.sender,\r\n                address(this),\r\n                tokenAmountData.amount\r\n            );\r\n\r\n            /*TransferHelper.*/safeApprove(tokenAmountData.token, endpoint, tokenAmountData.amount);\r\n        }\r\n\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        Client.EVM2AnyMessage memory ccipMessage = _createCcipMessage(\r\n            _action.targetRecipient,\r\n            new bytes(0),\r\n            _action.tokenAmounts,\r\n            0\r\n        );\r\n\r\n        // Send the message\r\n        ccipMessageId = _ccipSend(targetCcipChainId, ccipMessage, _ccipSendValue);\r\n\r\n        for (uint256 index; index < _action.tokenAmounts.length; index++) {\r\n            /*TransferHelper.*/safeApprove(_action.tokenAmounts[index].token, endpoint, 0);\r\n        }\r\n\r\n        emit TokenBridgeActionSource(\r\n            _action.targetChainId,\r\n            msg.sender,\r\n            _action.targetRecipient,\r\n            _action.tokenAmounts,\r\n            msg.value - _ccipSendValue,\r\n            ccipMessageId,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Cross-chain message fee estimation\r\n     * @param _action The action parameters\r\n     * @return Message fee\r\n     */\r\n    function messageFee(TokenBridgeAction calldata _action) external view returns (uint256) {\r\n        uint64 targetCcipChainId = _checkChainId(_action.targetChainId);\r\n\r\n        Client.EVM2AnyMessage memory ccipMessage = _createCcipMessage(\r\n            _action.targetRecipient,\r\n            new bytes(0),\r\n            _action.tokenAmounts,\r\n            0\r\n        );\r\n\r\n        return _ccipGetFee(targetCcipChainId, ccipMessage);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpointAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"standardId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"ccipId\",\"type\":\"uint64\"}],\"internalType\":\"struct InterportCCIPBridgeCore.ChainIdPair[]\",\"name\":\"_chainIdPairs\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_managers\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_addOwnerToManagers\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CcipChainIdNotSetError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListSizeLimitError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NonContractAddressError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyEndpointError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyManagerError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReservedTokenError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeApproveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferNativeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SendValueError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"standardId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ccipId\",\"type\":\"uint64\"}],\"name\":\"RemoveChainIdPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RenounceManagerRole\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"standardId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ccipId\",\"type\":\"uint64\"}],\"name\":\"SetChainIdPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"endpointAddress\",\"type\":\"address\"}],\"name\":\"SetEndpoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sourceSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetRecipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ccipMessageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenBridgeActionSource\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SYSTEM_VERSION_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetRecipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct InterportCCIPTokenBridge.TokenBridgeAction\",\"name\":\"_action\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_ccipSendValue\",\"type\":\"uint256\"}],\"name\":\"bridgeTokens\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ccipMessageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"ccipToStandardChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"cleanup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"cleanupWithAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fullManagerList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"isReservedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetRecipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct InterportCCIPTokenBridge.TokenBridgeAction\",\"name\":\"_action\",\"type\":\"tuple\"}],\"name\":\"messageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_standardChainIds\",\"type\":\"uint256[]\"}],\"name\":\"removeChainIdPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagerRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"standardId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"ccipId\",\"type\":\"uint64\"}],\"internalType\":\"struct InterportCCIPBridgeCore.ChainIdPair[]\",\"name\":\"_chainIdPairs\",\"type\":\"tuple[]\"}],\"name\":\"setChainIdPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpointAddress\",\"type\":\"address\"}],\"name\":\"setEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"standardToCcipChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InterportCCIPTokenBridge", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000080226fc0ee2b096224eeac085bb9a8cba1146f7d00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000072e28c7f34100afefc399fcc0ae041b8fe5841ae000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000045849994fc9c7b1500000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000009d70576d8e253bcf000000000000000000000000000000000000000000000000000000000000a86a000000000000000000000000000000000000000000000000594862ae1802b3d50000000000000000000000000000000000000000000000000000000000000089000000000000000000000000000000000000000000000000383a1891ae1915b1000000000000000000000000000000000000000000000000000000000000a4b100000000000000000000000000000000000000000000000044ae84d8e9a374440000000000000000000000000000000000000000000000000000000000002105000000000000000000000000000000000000000000000000dda641cfe44aff82000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000033d343f77863cab80000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8b9addf1ae51c37ec2d5cfe70f70e6259c7a77c47915b29a9b300d6540a90765"}