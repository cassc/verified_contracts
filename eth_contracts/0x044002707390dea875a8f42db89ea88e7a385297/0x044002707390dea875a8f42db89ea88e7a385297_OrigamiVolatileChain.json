{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@prb/math/src/Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n// Common.sol\\n//\\n// Common mathematical functions needed by both SD59x18 and UD60x18. Note that these global functions do not\\n// always operate with SD59x18 and UD60x18 numbers.\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CUSTOM ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\\n\\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\\n\\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\\nerror PRBMath_MulDivSigned_InputTooSmall();\\n\\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @dev The maximum value a uint128 number can have.\\nuint128 constant MAX_UINT128 = type(uint128).max;\\n\\n/// @dev The maximum value a uint40 number can have.\\nuint40 constant MAX_UINT40 = type(uint40).max;\\n\\n/// @dev The unit number, which the decimal precision of the fixed-point types.\\nuint256 constant UNIT = 1e18;\\n\\n/// @dev The unit number inverted mod 2^256.\\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\\n/// bit in the binary representation of `UNIT`.\\nuint256 constant UNIT_LPOTD = 262144;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(uint256 x) pure returns (uint256 result) {\\n    unchecked {\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\n        result = 0x800000000000000000000000000000000000000000000000;\\n\\n        // The following logic multiplies the result by $\\\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\\n        //\\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\\n        // we know that `x & 0xFF` is also 1.\\n        if (x & 0xFF00000000000000 > 0) {\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000000000 > 0) {\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000000000 > 0) {\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000 > 0) {\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000 > 0) {\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00 > 0) {\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF > 0) {\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n        }\\n\\n        // In the code snippet below, two operations are executed simultaneously:\\n        //\\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\\n        //\\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\\n        // integer part, $2^n$.\\n        result *= UNIT;\\n        result >>= (191 - (x >> 64));\\n    }\\n}\\n\\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\\n///\\n/// @dev See the note on \\\"msb\\\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\\n///\\n/// Each step in this implementation is equivalent to this high-level code:\\n///\\n/// ```solidity\\n/// if (x >= 2 ** 128) {\\n///     x >>= 128;\\n///     result += 128;\\n/// }\\n/// ```\\n///\\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\\n///\\n/// The Yul instructions used below are:\\n///\\n/// - \\\"gt\\\" is \\\"greater than\\\"\\n/// - \\\"or\\\" is the OR bitwise operator\\n/// - \\\"shl\\\" is \\\"shift left\\\"\\n/// - \\\"shr\\\" is \\\"shift right\\\"\\n///\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\n/// @return result The index of the most significant bit as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction msb(uint256 x) pure returns (uint256 result) {\\n    // 2^128\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^64\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^32\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^16\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(4, gt(x, 0xFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^8\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(3, gt(x, 0xFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^4\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(2, gt(x, 0xF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^2\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(1, gt(x, 0x3))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^1\\n    // No need to shift x any more.\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := gt(x, 0x1)\\n        result := or(result, factor)\\n    }\\n}\\n\\n/// @notice Calculates x*y\u00f7denominator with 512-bit precision.\\n///\\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - The denominator must not be zero.\\n/// - The result must fit in uint256.\\n///\\n/// @param x The multiplicand as a uint256.\\n/// @param y The multiplier as a uint256.\\n/// @param denominator The divisor as a uint256.\\n/// @return result The result as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / denominator;\\n        }\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    if (prod1 >= denominator) {\\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // 512 by 256 division\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        // Compute remainder using the mulmod Yul instruction.\\n        remainder := mulmod(x, y, denominator)\\n\\n        // Subtract 256 bit number from 512-bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n    }\\n\\n    unchecked {\\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\\n        uint256 lpotdod = denominator & (~denominator + 1);\\n        uint256 flippedLpotdod;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Factor powers of two out of denominator.\\n            denominator := div(denominator, lpotdod)\\n\\n            // Divide [prod1 prod0] by lpotdod.\\n            prod0 := div(prod0, lpotdod)\\n\\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n        }\\n\\n        // Shift in bits from prod1 into prod0.\\n        prod0 |= prod1 * flippedLpotdod;\\n\\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n        // four bits. That is, denominator * inv = 1 mod 2^4.\\n        uint256 inverse = (3 * denominator) ^ 2;\\n\\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n        // in modular arithmetic, doubling the correct bits in each step.\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inverse;\\n    }\\n}\\n\\n/// @notice Calculates x*y\u00f71e18 with 512-bit precision.\\n///\\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\\n///\\n/// Notes:\\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\\n/// - The result is rounded toward zero.\\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\\n///\\n/// $$\\n/// \\\\begin{cases}\\n///     x * y = MAX\\\\_UINT256 * UNIT \\\\\\\\\\n///     (x * y) \\\\% UNIT \\\\geq \\\\frac{UNIT}{2}\\n/// \\\\end{cases}\\n/// $$\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {mulDiv}.\\n/// - The result must fit in uint256.\\n///\\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\\n    uint256 prod0;\\n    uint256 prod1;\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / UNIT;\\n        }\\n    }\\n\\n    if (prod1 >= UNIT) {\\n        revert PRBMath_MulDiv18_Overflow(x, y);\\n    }\\n\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        remainder := mulmod(x, y, UNIT)\\n        result :=\\n            mul(\\n                or(\\n                    div(sub(prod0, remainder), UNIT_LPOTD),\\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\\n                ),\\n                UNIT_INVERSE\\n            )\\n    }\\n}\\n\\n/// @notice Calculates x*y\u00f7denominator with 512-bit precision.\\n///\\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {mulDiv}.\\n/// - None of the inputs can be `type(int256).min`.\\n/// - The result must fit in int256.\\n///\\n/// @param x The multiplicand as an int256.\\n/// @param y The multiplier as an int256.\\n/// @param denominator The divisor as an int256.\\n/// @return result The result as an int256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n        revert PRBMath_MulDivSigned_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x, y and the denominator.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    uint256 dAbs;\\n    unchecked {\\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n    }\\n\\n    // Compute the absolute value of x*y\u00f7denominator. The result must fit in int256.\\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\\n    if (resultAbs > uint256(type(int256).max)) {\\n        revert PRBMath_MulDivSigned_Overflow(x, y);\\n    }\\n\\n    // Get the signs of x, y and the denominator.\\n    uint256 sx;\\n    uint256 sy;\\n    uint256 sd;\\n    assembly (\\\"memory-safe\\\") {\\n        // \\\"sgt\\\" is the \\\"signed greater than\\\" assembly instruction and \\\"sub(0,1)\\\" is -1 in two's complement.\\n        sx := sgt(x, sub(0, 1))\\n        sy := sgt(y, sub(0, 1))\\n        sd := sgt(denominator, sub(0, 1))\\n    }\\n\\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\\n    // If there are, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - If x is not a perfect square, the result is rounded down.\\n/// - Credits to OpenZeppelin for the explanations in comments below.\\n///\\n/// @param x The uint256 number for which to calculate the square root.\\n/// @return result The result as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(uint256 x) pure returns (uint256 result) {\\n    if (x == 0) {\\n        return 0;\\n    }\\n\\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of x is a power of 2 such that we have:\\n    //\\n    // $$\\n    // msb(x) <= x <= 2*msb(x)$\\n    // $$\\n    //\\n    // We write $msb(x)$ as $2^k$, and we get:\\n    //\\n    // $$\\n    // k = log_2(x)\\n    // $$\\n    //\\n    // Thus, we can write the initial inequality as:\\n    //\\n    // $$\\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\\\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\\\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\\n    // $$\\n    //\\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\\n    uint256 xAux = uint256(x);\\n    result = 1;\\n    if (xAux >= 2 ** 128) {\\n        xAux >>= 128;\\n        result <<= 64;\\n    }\\n    if (xAux >= 2 ** 64) {\\n        xAux >>= 64;\\n        result <<= 32;\\n    }\\n    if (xAux >= 2 ** 32) {\\n        xAux >>= 32;\\n        result <<= 16;\\n    }\\n    if (xAux >= 2 ** 16) {\\n        xAux >>= 16;\\n        result <<= 8;\\n    }\\n    if (xAux >= 2 ** 8) {\\n        xAux >>= 8;\\n        result <<= 4;\\n    }\\n    if (xAux >= 2 ** 4) {\\n        xAux >>= 4;\\n        result <<= 2;\\n    }\\n    if (xAux >= 2 ** 2) {\\n        result <<= 1;\\n    }\\n\\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\\n    // precision into the expected uint128 result.\\n    unchecked {\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n\\n        // If x is not a perfect square, round the result toward zero.\\n        uint256 roundedResult = x / result;\\n        if (result >= roundedResult) {\\n            result = roundedResult;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/oracle/OrigamiOracleBase.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (common/oracle/OrigamiOracleBase.sol)\\n\\nimport { IOrigamiOracle } from \\\"contracts/interfaces/common/oracle/IOrigamiOracle.sol\\\";\\nimport { CommonEventsAndErrors } from \\\"contracts/libraries/CommonEventsAndErrors.sol\\\";\\nimport { OrigamiMath } from \\\"contracts/libraries/OrigamiMath.sol\\\";\\n\\n/**\\n * @title OrigamiOracleBase\\n * @notice Common base logic for Origami Oracle's\\n */\\nabstract contract OrigamiOracleBase is IOrigamiOracle {\\n    using OrigamiMath for uint256;\\n\\n    /**\\n     * @notice The address used to reference the baseAsset for amount conversions\\n     */\\n    address public immutable override baseAsset;\\n\\n    /**\\n     * @notice The address used to reference the quoteAsset for amount conversions\\n     */\\n    address public immutable override quoteAsset;\\n\\n    /**\\n     * @notice The number of decimals of precision the oracle price is returned as\\n     */\\n    uint8 public constant override decimals = 18;\\n\\n    /**\\n     * @notice The precision that the cross rate oracle price is returned as: `10^decimals`\\n     */\\n    uint256 public constant override precision = 1e18;\\n\\n    /**\\n     * @notice When converting from baseAsset<->quoteAsset, the fixed point amounts\\n     * need to be scaled by this amount.\\n     */\\n    uint256 public immutable assetScalingFactor;\\n\\n    /**\\n     * @notice A human readable description for this origami oracle\\n     */\\n    string public override description;\\n\\n    constructor(BaseOracleParams memory params) {\\n        description = params.description;\\n        baseAsset = params.baseAssetAddress;\\n        quoteAsset = params.quoteAssetAddress;\\n        if (params.quoteAssetDecimals > decimals + params.baseAssetDecimals) revert CommonEventsAndErrors.InvalidParam();\\n        assetScalingFactor = 10 ** (decimals + params.baseAssetDecimals - params.quoteAssetDecimals);\\n    }\\n\\n    /**\\n     * @notice Return the latest oracle price, to `decimals` precision\\n     * @dev This may still revert - eg if deemed stale, div by 0, negative price\\n     * @param priceType What kind of price - Spot or Historic\\n     * @param roundingMode Round the price at each intermediate step such that the final price rounds in the specified direction.\\n     */\\n    function latestPrice(\\n        PriceType priceType, \\n        OrigamiMath.Rounding roundingMode\\n    ) public virtual override view returns (uint256 price);\\n\\n    /**\\n     * @notice Same as `latestPrice()` but for two separate prices from this oracle\\t\\n     */\\n    function latestPrices(\\n        PriceType priceType1, \\n        OrigamiMath.Rounding roundingMode1,\\n        PriceType priceType2, \\n        OrigamiMath.Rounding roundingMode2\\n    ) external virtual override view returns (\\n        uint256 /*price1*/, \\n        uint256 /*price2*/, \\n        address /*oracleBaseAsset*/,\\n        address /*oracleQuoteAsset*/\\n    ) {\\n        return (\\n            latestPrice(priceType1, roundingMode1),\\n            latestPrice(priceType2, roundingMode2),\\n            baseAsset,\\n            quoteAsset\\n        );\\n    }\\n\\n    /**\\n     * @notice Convert either the baseAsset->quoteAsset or quoteAsset->baseAsset\\n     * @dev The `fromAssetAmount` needs to be in it's natural fixed point precision (eg USDC=6dp)\\n     * The `toAssetAmount` will also be returned in it's natural fixed point precision\\n     */\\n    function convertAmount(\\n        address fromAsset,\\n        uint256 fromAssetAmount,\\n        PriceType priceType,\\n        OrigamiMath.Rounding roundingMode \\n    ) external override view returns (uint256 toAssetAmount) {\\n        if (fromAsset == baseAsset) {\\n            // The numerator needs to round in the same way to be conservative\\n            uint256 _price = latestPrice(\\n                priceType, \\n                roundingMode\\n            );\\n\\n            return fromAssetAmount.mulDiv(\\n                _price,\\n                assetScalingFactor,\\n                roundingMode\\n            );\\n        } else if (fromAsset == quoteAsset) {\\n            // The denominator needs to round in the opposite way to be conservative\\n            uint256 _price = latestPrice(\\n                priceType, \\n                roundingMode == OrigamiMath.Rounding.ROUND_UP ? OrigamiMath.Rounding.ROUND_DOWN : OrigamiMath.Rounding.ROUND_UP\\n            );\\n\\n            if (_price == 0) revert InvalidPrice(address(this), int256(_price));\\n            return fromAssetAmount.mulDiv(\\n                assetScalingFactor,\\n                _price,\\n                roundingMode\\n            );\\n        }\\n\\n        revert CommonEventsAndErrors.InvalidToken(fromAsset);\\n    }\\n\\n    /**\\n     * @notice Match whether a pair of assets match the base and quote asset on this oracle, in either order\\n     */\\n    function matchAssets(address asset1, address asset2) public view returns (bool) {\\n        return (\\n            (asset1 == baseAsset && asset2 == quoteAsset) ||\\n            (asset2 == baseAsset && asset1 == quoteAsset)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/oracle/OrigamiVolatileChainlinkOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (common/oracle/OrigamiVolatileChainlinkOracle.sol)\\n\\nimport { IAggregatorV3Interface } from \\\"contracts/interfaces/external/chainlink/IAggregatorV3Interface.sol\\\";\\nimport { OrigamiOracleBase } from \\\"contracts/common/oracle/OrigamiOracleBase.sol\\\";\\nimport { Range } from \\\"contracts/libraries/Range.sol\\\";\\nimport { OrigamiMath } from \\\"contracts/libraries/OrigamiMath.sol\\\";\\nimport { Chainlink } from \\\"contracts/libraries/Chainlink.sol\\\";\\n\\n/**\\n * @title OrigamiVolatileChainlinkOracle\\n * @notice A vanilla proxy to the chainlink price with no extra validation except for oracle staleness.\\n * Both the spot price and historic reference price uses the Chainlink Oracle price\\n * \\n * @dev Note the Chainlink lib is only suitable for mainnet. If a Chainlink Oracle is required on\\n * an L2, then it should also take the sequencer staleness into consideration.\\n * eg: https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\\n */\\ncontract OrigamiVolatileChainlinkOracle is OrigamiOracleBase {\\n    using Range for Range.Data;\\n    using OrigamiMath for uint256;\\n\\n    /**\\n     * @notice The Chainlink oracle for spot and the historic reference price\\n     */\\n    IAggregatorV3Interface public immutable priceOracle;\\n\\n    /**\\n     * @notice True if the `priceOracle` price should be scaled down by `pricePrecisionScalar` to match `decimals`\\n     */\\n    bool public immutable pricePrecisionScaleDown;\\n\\n    /**\\n     * @notice How much to scale up/down the `priceOracle` price to match cross rate oracle `decimals`\\n     */\\n    uint128 public immutable pricePrecisionScalar;\\n\\n    /**\\n     * @notice How many seconds are allowed to pass before the Chainlink `priceOracle` price is determined as stale.\\n     * @dev eg https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd is guaranteed to update at least daily\\n     * So can be set to something like 86_400+300\\n     */\\n    uint128 public immutable priceStalenessThreshold;\\n\\n    /**\\n     * @notice When using Redstone 'chainlink-like' oracle interfaces, the roundId\\n     * returned may be unused, and so validation isn't required in that case.\\n     */\\n    bool public immutable validateRoundId;\\n\\n    /**\\n     * @notice When using Origami 'chainlink-like' oracle interfaces, the lastUpdatedAt\\n     * returned may be unused, and so validation isn't required in that case.\\n     */\\n    bool public immutable validateLastUpdatedAt;\\n\\n    constructor (\\n        BaseOracleParams memory baseParams,\\n        address _priceOracle,\\n        uint128 _priceStalenessThreshold,\\n        bool _validateRoundId,\\n        bool _validateLastUpdatedAt\\n    )\\n        OrigamiOracleBase(baseParams)\\n    {\\n        priceOracle = IAggregatorV3Interface(_priceOracle);\\n        priceStalenessThreshold = _priceStalenessThreshold;\\n        (pricePrecisionScalar, pricePrecisionScaleDown) = Chainlink.scalingFactor(\\n            priceOracle, \\n            decimals\\n        );\\n        validateRoundId = _validateRoundId;\\n        validateLastUpdatedAt = _validateLastUpdatedAt;\\n    }\\n\\n    /**\\n     * @notice Return the latest oracle price, to `decimals` precision\\n     * @dev This may still revert if deemed stale or it returns a negative price\\n     */\\n    function latestPrice(\\n        PriceType /*priceType*/, \\n        OrigamiMath.Rounding roundingMode\\n    ) public override view returns (uint256 price) {\\n        // There isn't a separate historic reference price, so return the same price for both SPOT and HISTORIC\\n        price = Chainlink.price(\\n            Chainlink.Config(\\n                priceOracle, \\n                pricePrecisionScaleDown, \\n                pricePrecisionScalar,\\n                priceStalenessThreshold, \\n                validateRoundId,\\n                validateLastUpdatedAt\\n            ),\\n            roundingMode\\n        );\\n    }\\n\\n    /**\\n     * @notice Same as `latestPrice()` but for two separate prices from this oracle\\t\\n     */\\n    function latestPrices(\\n        PriceType priceType1, \\n        OrigamiMath.Rounding roundingMode1,\\n        PriceType priceType2, \\n        OrigamiMath.Rounding roundingMode2\\n    ) external override view returns (\\n        uint256 /*price1*/, \\n        uint256 /*price2*/, \\n        address /*oracleBaseAsset*/,\\n        address /*oracleQuoteAsset*/\\n    ) {\\n        uint256 price1 = latestPrice(priceType1, roundingMode1);\\n\\n        // Save a second oracle lookup if the rounding modes are the same.\\n        uint256 price2 = roundingMode1 == roundingMode2\\n            ? price1\\n            : latestPrice(priceType2, roundingMode2);\\n\\n        return (\\n            price1,\\n            price2,\\n            baseAsset,\\n            quoteAsset\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/common/oracle/IOrigamiOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (interfaces/common/oracle/IOrigamiOracle.sol)\\n\\nimport { OrigamiMath } from \\\"contracts/libraries/OrigamiMath.sol\\\";\\n\\n/**\\n * @notice An oracle which returns prices for pairs of assets, where an asset\\n * could refer to a token (eg DAI) or a currency (eg USD)\\n * Convention is the same as the FX market. Given the DAI/USD pair:\\n *   - DAI = Base Asset (LHS of pair)\\n *   - USD = Quote Asset (RHS of pair)\\n * This price defines how many USD you get if selling 1 DAI\\n *\\n * Further, an oracle can define two PriceType's:\\n *   - SPOT_PRICE: The latest spot price, for example from a chainlink oracle\\n *   - HISTORIC_PRICE: An expected (eg 1:1 peg) or calculated historic price (eg TWAP)\\n *\\n * For assets which do are not tokens (eg USD), an internal address reference will be used\\n * since this is for internal purposes only\\n */\\ninterface IOrigamiOracle {\\n    error InvalidPrice(address oracle, int256 price);\\n    error InvalidOracleData(address oracle);\\n    error StalePrice(address oracle, uint256 lastUpdatedAt, int256 price);\\n    error UnknownPriceType(uint8 priceType);\\n    error BelowMinValidRange(address oracle, uint256 price, uint128 floor);\\n    error AboveMaxValidRange(address oracle, uint256 price, uint128 ceiling);\\n\\n    event ValidPriceRangeSet(uint128 validFloor, uint128 validCeiling);\\n\\n    enum PriceType {\\n        /// @notice The current spot price of this Oracle\\n        SPOT_PRICE,\\n\\n        /// @notice The historic price of this Oracle. \\n        /// It may be a fixed expectation (eg DAI/USD would be fixed to 1)\\n        /// or use a TWAP or some other moving average, etc.\\n        HISTORIC_PRICE\\n    }\\n\\n    /**\\n     * @dev Wrapped in a struct to remove stack-too-deep constraints\\n     */\\n    struct BaseOracleParams {\\n        string description;\\n        address baseAssetAddress;\\n        uint8 baseAssetDecimals;\\n        address quoteAssetAddress;\\n        uint8 quoteAssetDecimals;\\n    }\\n\\n    /**\\n     * @notice The address used to reference the baseAsset for amount conversions\\n     */\\n    function baseAsset() external view returns (address);\\n\\n    /**\\n     * @notice The address used to reference the quoteAsset for amount conversions\\n     */\\n    function quoteAsset() external view returns (address);\\n\\n    /**\\n     * @notice The number of decimals of precision the price is returned as\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @notice The precision that the cross rate oracle price is returned as: `10^decimals`\\n     */\\n    function precision() external view returns (uint256);\\n\\n    /**\\n     * @notice A human readable description for this oracle\\n     */\\n    function description() external view returns (string memory);\\n\\n    /**\\n     * @notice Return the latest oracle price, to `decimals` precision\\n     * @dev This may still revert - eg if deemed stale, div by 0, negative price\\n     * @param priceType What kind of price - Spot or Historic\\n     * @param roundingMode Round the price at each intermediate step such that the final price rounds in the specified direction.\\n     */\\n    function latestPrice(\\n        PriceType priceType, \\n        OrigamiMath.Rounding roundingMode\\n    ) external view returns (uint256 price);\\n\\n    /**\\n     * @notice Same as `latestPrice()` but for two separate prices from this oracle\\t\\n     */\\n    function latestPrices(\\n        PriceType priceType1, \\n        OrigamiMath.Rounding roundingMode1,\\n        PriceType priceType2, \\n        OrigamiMath.Rounding roundingMode2\\n    ) external view returns (\\n        uint256 price1, \\n        uint256 price2, \\n        address oracleBaseAsset,\\n        address oracleQuoteAsset\\n    );\\n\\n    /**\\n     * @notice Convert either the baseAsset->quoteAsset or quoteAsset->baseAsset\\n     * @dev The `fromAssetAmount` needs to be in it's natural fixed point precision (eg USDC=6dp)\\n     * The `toAssetAmount` will also be returned in it's natural fixed point precision\\n     */\\n    function convertAmount(\\n        address fromAsset,\\n        uint256 fromAssetAmount,\\n        PriceType priceType,\\n        OrigamiMath.Rounding roundingMode\\n    ) external view returns (uint256 toAssetAmount);\\n\\n    /**\\n     * @notice Match whether a pair of assets match the base and quote asset on this oracle, in either order\\n     */\\n    function matchAssets(address asset1, address asset2) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/chainlink/IAggregatorV3Interface.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (interfaces/external/chainlink/IAggregatorV3Interface.sol)\\n\\ninterface IAggregatorV3Interface {\\n    function latestRoundData() external view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Chainlink.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (libraries/Chainlink.sol)\\n\\nimport { IAggregatorV3Interface } from \\\"contracts/interfaces/external/chainlink/IAggregatorV3Interface.sol\\\";\\nimport { IOrigamiOracle } from \\\"contracts/interfaces/common/oracle/IOrigamiOracle.sol\\\";\\nimport { OrigamiMath } from \\\"contracts/libraries/OrigamiMath.sol\\\";\\n\\n/**\\n * @notice A helper library to safely query prices from Chainlink oracles and scale them \\n * \\n * @dev Note this Chainlink lib is only suitable for mainnet. If a Chainlink Oracle is required on\\n * an L2, then it should also take the sequencer staleness into consideration.\\n * eg: https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\\n */\\nlibrary Chainlink {\\n    using OrigamiMath for uint256;\\n\\n    struct Config {\\n        IAggregatorV3Interface oracle;\\n        bool scaleDown;\\n        uint128 scalar;\\n        uint256 stalenessThreshold;\\n        bool validateRoundId;\\n        bool validateLastUpdatedAt;\\n    }\\n\\n    /**\\n     * @notice Query a price from a Chainlink oracle interface and perform sanity checks\\n     * The oracle price is scaled to the expected Origami precision (18dp)\\n     */\\n    function price(\\n        Config memory self,\\n        OrigamiMath.Rounding roundingMode\\n    ) internal view returns (uint256) {\\n        (uint80 roundId, int256 feedValue, , uint256 lastUpdatedAt,) = self.oracle.latestRoundData();\\n\\n        // Invalid chainlink parameters\\n        if (self.validateRoundId && roundId == 0) revert IOrigamiOracle.InvalidOracleData(address(self.oracle));\\n        if (self.validateLastUpdatedAt) {\\n            if (lastUpdatedAt == 0) revert IOrigamiOracle.InvalidOracleData(address(self.oracle));\\n\\n            // Check for future time or if it's too stale\\n            if (lastUpdatedAt > block.timestamp) revert IOrigamiOracle.InvalidOracleData(address(self.oracle));\\n            unchecked {\\n                if (block.timestamp - lastUpdatedAt > self.stalenessThreshold) {\\n                    revert IOrigamiOracle.StalePrice(address(self.oracle), lastUpdatedAt, feedValue);\\n                }\\n            }\\n        }\\n\\n        // Check for negative price\\n        if (feedValue < 0) revert IOrigamiOracle.InvalidPrice(address(self.oracle), feedValue);\\n\\n        return self.scaleDown \\n            ? uint256(feedValue).scaleDown(self.scalar, roundingMode)\\n            : uint256(feedValue).scaleUp(self.scalar);\\n    }\\n\\n    /**\\n     * @notice Calculate the scaling factor to convert the chainlink oracle decimals to\\n     * our targetDecimals (18dp)\\n     */\\n    function scalingFactor(\\n        IAggregatorV3Interface oracle,\\n        uint8 targetDecimals\\n    ) internal view returns (uint128 scalar, bool scaleDown) {\\n        uint8 oracleDecimals = oracle.decimals();\\n\\n        unchecked {\\n            if (oracleDecimals <= targetDecimals) {\\n                // Scale up (no-op if sourcePrecision == pricePrecision)\\n                scalar = uint128(10) ** (targetDecimals - oracleDecimals);\\n            } else {\\n                // scale down\\n                scalar = uint128(10) ** (oracleDecimals - targetDecimals);\\n                scaleDown = true;\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/CommonEventsAndErrors.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (libraries/CommonEventsAndErrors.sol)\\n\\n/// @notice A collection of common events and errors thrown within the Origami contracts\\nlibrary CommonEventsAndErrors {\\n    error InsufficientBalance(address token, uint256 required, uint256 balance);\\n    error InvalidToken(address token);\\n    error InvalidParam();\\n    error InvalidAddress(address addr);\\n    error InvalidAmount(address token, uint256 amount);\\n    error ExpectedNonZero();\\n    error Slippage(uint256 minAmountExpected, uint256 actualAmount);\\n    error IsPaused();\\n    error UnknownExecuteError(bytes returndata);\\n    error InvalidAccess();\\n    error BreachedMaxTotalSupply(uint256 totalSupply, uint256 maxTotalSupply);\\n\\n    event TokenRecovered(address indexed to, address indexed token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OrigamiMath.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (libraries/OrigamiMath.sol)\\n\\nimport { mulDiv as prbMulDiv, PRBMath_MulDiv_Overflow } from \\\"@prb/math/src/Common.sol\\\";\\nimport { CommonEventsAndErrors } from \\\"contracts/libraries/CommonEventsAndErrors.sol\\\";\\n\\n/**\\n * @notice Utilities to operate on fixed point math multipliation and division\\n * taking rounding into consideration\\n */\\nlibrary OrigamiMath {\\n    enum Rounding {\\n        ROUND_DOWN,\\n        ROUND_UP\\n    }\\n\\n    uint256 public constant BASIS_POINTS_DIVISOR = 10_000;\\n\\n    function scaleUp(uint256 amount, uint256 scalar) internal pure returns (uint256) {\\n        // Special case for scalar == 1, as it's common for token amounts to not need\\n        // scaling if decimal places are the same\\n        return scalar == 1 ? amount : amount * scalar;\\n    }\\n\\n    function scaleDown(\\n        uint256 amount, \\n        uint256 scalar, \\n        Rounding roundingMode\\n    ) internal pure returns (uint256 result) {\\n        // Special case for scalar == 1, as it's common for token amounts to not need\\n        // scaling if decimal places are the same\\n        unchecked {\\n            if (scalar == 1) {\\n                result = amount;\\n            } else if (roundingMode == Rounding.ROUND_DOWN) {\\n                result = amount / scalar;\\n            } else {\\n                // ROUND_UP uses the same logic as OZ Math.ceilDiv()\\n                result = amount == 0 ? 0 : (amount - 1) / scalar + 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision,\\n     * rounding up\\n     */\\n    function mulDiv(\\n        uint256 x, \\n        uint256 y, \\n        uint256 denominator,\\n        Rounding roundingMode\\n    ) internal pure returns (uint256 result) {\\n        result = prbMulDiv(x, y, denominator);\\n        if (roundingMode == Rounding.ROUND_UP) {\\n            if (mulmod(x, y, denominator) != 0) {\\n                if (result < type(uint256).max) {\\n                    unchecked {\\n                        result = result + 1;\\n                    }\\n                } else {\\n                    revert PRBMath_MulDiv_Overflow(x, y, denominator);\\n                }\\n            }\\n        }\\n    }\\n\\n    function subtractBps(\\n        uint256 inputAmount, \\n        uint256 basisPoints,\\n        Rounding roundingMode\\n    ) internal pure returns (uint256 result) {\\n        uint256 numeratorBps;\\n        unchecked {\\n            numeratorBps = BASIS_POINTS_DIVISOR - basisPoints;\\n        }\\n\\n        result = basisPoints < BASIS_POINTS_DIVISOR\\n            ? mulDiv(\\n                inputAmount,\\n                numeratorBps, \\n                BASIS_POINTS_DIVISOR, \\n                roundingMode\\n            ) : 0;\\n    }\\n\\n    function addBps(\\n        uint256 inputAmount,\\n        uint256 basisPoints,\\n        Rounding roundingMode\\n    ) internal pure returns (uint256 result) {\\n        uint256 numeratorBps;\\n        unchecked {\\n            numeratorBps = BASIS_POINTS_DIVISOR + basisPoints;\\n        }\\n\\n        // Round up for max amounts out expected\\n        result = mulDiv(\\n            inputAmount,\\n            numeratorBps, \\n            BASIS_POINTS_DIVISOR, \\n            roundingMode\\n        );\\n    }\\n\\n    /**\\n     * @notice Split the `inputAmount` into two parts based on the `basisPoints` fraction.\\n     * eg: 3333 BPS (33.3%) can be used to split an input amount of 600 into: (result=400, removed=200).\\n     * @dev The rounding mode is applied to the `result`\\n     */\\n    function splitSubtractBps(\\n        uint256 inputAmount, \\n        uint256 basisPoints,\\n        Rounding roundingMode\\n    ) internal pure returns (uint256 result, uint256 removed) {\\n        result = subtractBps(inputAmount, basisPoints, roundingMode);\\n        unchecked {\\n            removed = inputAmount - result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Reverse the fractional amount of an input.\\n     * eg: For 3333 BPS (33.3%) and the remainder=400, the result is 600\\n     */\\n    function inverseSubtractBps(\\n        uint256 remainderAmount, \\n        uint256 basisPoints,\\n        Rounding roundingMode\\n    ) internal pure returns (uint256 result) {\\n        if (basisPoints == 0) return remainderAmount; // gas shortcut for 0\\n        if (basisPoints >= BASIS_POINTS_DIVISOR) revert CommonEventsAndErrors.InvalidParam();\\n\\n        uint256 denominatorBps;\\n        unchecked {\\n            denominatorBps = BASIS_POINTS_DIVISOR - basisPoints;\\n        }\\n        result = mulDiv(\\n            remainderAmount,\\n            BASIS_POINTS_DIVISOR, \\n            denominatorBps, \\n            roundingMode\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculate the relative difference of a value to a reference\\n     * @dev `value` and `referenceValue` must have the same precision\\n     * The denominator is always the referenceValue\\n     */\\n    function relativeDifferenceBps(\\n        uint256 value,\\n        uint256 referenceValue,\\n        Rounding roundingMode\\n    ) internal pure returns (uint256) {\\n        if (referenceValue == 0) revert CommonEventsAndErrors.InvalidParam();\\n\\n        uint256 absDelta;\\n        unchecked {\\n            absDelta = value < referenceValue\\n                ? referenceValue - value\\n                : value - referenceValue;\\n        }\\n\\n        return mulDiv(\\n            absDelta,\\n            BASIS_POINTS_DIVISOR,\\n            referenceValue,\\n            roundingMode\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Range.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Origami (libraries/Range.sol)\\n\\n/**\\n * @notice A helper library to track a valid range from floor <= x <= ceiling\\n */\\nlibrary Range {\\n    error InvalidRange(uint128 floor, uint128 ceiling);\\n\\n    struct Data {\\n        uint128 floor;\\n        uint128 ceiling;\\n    }\\n\\n    function set(Data storage range, uint128 floor, uint128 ceiling) internal {\\n        if (floor > ceiling) {\\n            revert InvalidRange(floor, ceiling);\\n        }\\n        range.floor = floor;\\n        range.ceiling = ceiling;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"baseAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"baseAssetDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"quoteAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"quoteAssetDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IOrigamiOracle.BaseOracleParams\",\"name\":\"baseParams\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_priceStalenessThreshold\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_validateRoundId\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_validateLastUpdatedAt\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"ceiling\",\"type\":\"uint128\"}],\"name\":\"AboveMaxValidRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"floor\",\"type\":\"uint128\"}],\"name\":\"BelowMinValidRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"InvalidOracleData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv_Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedAt\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"StalePrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"priceType\",\"type\":\"uint8\"}],\"name\":\"UnknownPriceType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"validFloor\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"validCeiling\",\"type\":\"uint128\"}],\"name\":\"ValidPriceRangeSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"assetScalingFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum IOrigamiOracle.PriceType\",\"name\":\"priceType\",\"type\":\"uint8\"},{\"internalType\":\"enum OrigamiMath.Rounding\",\"name\":\"roundingMode\",\"type\":\"uint8\"}],\"name\":\"convertAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toAssetAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IOrigamiOracle.PriceType\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum OrigamiMath.Rounding\",\"name\":\"roundingMode\",\"type\":\"uint8\"}],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IOrigamiOracle.PriceType\",\"name\":\"priceType1\",\"type\":\"uint8\"},{\"internalType\":\"enum OrigamiMath.Rounding\",\"name\":\"roundingMode1\",\"type\":\"uint8\"},{\"internalType\":\"enum IOrigamiOracle.PriceType\",\"name\":\"priceType2\",\"type\":\"uint8\"},{\"internalType\":\"enum OrigamiMath.Rounding\",\"name\":\"roundingMode2\",\"type\":\"uint8\"}],\"name\":\"latestPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset2\",\"type\":\"address\"}],\"name\":\"matchAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IAggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePrecisionScalar\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePrecisionScaleDown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceStalenessThreshold\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validateLastUpdatedAt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validateRoundId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OrigamiVolatileChainlinkOracle", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000b2b18e668ce6326760e3b063f72684fdf2a2d58200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000fae103dc9cf190ed75350761e95403b7b8afa6c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000b7273774554482f57455448000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}