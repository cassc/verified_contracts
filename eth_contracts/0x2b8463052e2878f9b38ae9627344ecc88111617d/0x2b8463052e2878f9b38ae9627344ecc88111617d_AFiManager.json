{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\"},\"AFiManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAFi.sol\\\";\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport {OwnableDelayModule} from \\\"./OwnableDelayModule.sol\\\";\\nimport {ReentrancyGuard} from \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./ArrayUtils.sol\\\";\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\nimport \\\"./IPassiveRebal.sol\\\";\\nimport {IUniswapOracleV3} from \\\"./IUniswapV3.sol\\\";\\n\\n/**\\n * @title AFiManager.\\n * @notice Manager conntract for handling rebalancing and adding/updating team wallets in the AFi contracts.\\n * @dev Error codes: AFM01: Caller is not MultiSig. AFM02: Cannot be address zero. AFM03: Teamwallet already present. AFM04: Previous and current active status cannot be the same.\\n */\\ncontract AFiManager is OwnableDelayModule, ReentrancyGuard {\\n  using ArrayUtils for uint[];\\n  using ArrayUtils for address[];\\n  using SafeERC20 for IERC20;\\n\\n  address internal rebal;\\n  uint256 internal preDepositsStablesInUSD;\\n  mapping(address =\\u003e bool) public isQueueWithdrawUnstakingPaused;\\n\\n  uint256 public rebalfee = 500;\\n  uint256 public rebalFeeUpperLimit = 5000;\\n\\n  bool internal paused;\\n  address[] private _uTokensAfterRebalance;\\n  address[] public tokens;\\n  uint[] internal defaultProportion;\\n  address internal afiOracle;\\n  address internal constant UNISWAP_EXCHANGE =\\n    0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n  mapping(address =\\u003e mapping(address =\\u003e bool)) internal underlyingExists;\\n  mapping(address =\\u003e bool) internal isUnderlyingCommon;\\n  address public rebalanceController;\\n\\n  struct RebalanceData {\\n    IAFi aFiContract;\\n    IAFiStorage _aFiStorage;\\n    IERC20 depositToken;\\n    address newUToken;\\n    address uTokenToRemove;\\n    uint256 scenario;\\n    address[] uTokensAfterS1; // uTokens array after scenario 1 rebalancing\\n    uint256[] uTokenProportions;\\n    uint256[] defaultProportion;\\n    uint256 uTokenToRemoveIndex;\\n  }\\n\\n  event Rebalance(IAFi indexed _aFiContract, uint8 _scenario);\\n  event AddTeamWalletInAFi(address indexed aFiContract, address _wallet);\\n  event WithdrawFromPool(address indexed _aFiContract, address uToken);\\n  event AFiManagerSwap(\\n    IAFi indexed _aFiContract,\\n    address _fromToken,\\n    address _toToken,\\n    uint _amount\\n  );\\n  event SetActiveRebalStatus(address indexed _aFiContract, bool status);\\n  event RebalanceUnderlyingTokens(\\n    address indexed aFiContract,\\n    address _aFiStorage,\\n    address[] newUnderlyingTokens,\\n    address stableCoin,\\n    uint managerFee\\n  );\\n  event UTokenProportionUpdated(\\n    address indexed aFiContract,\\n    uint256[] uTokenProportions\\n  );\\n\\n  /**\\n   * @param account Address of the account that paused the contract.\\n   */\\n  event Paused(address account);\\n  /**\\n   * @param account Address of the account that unpaused the contract.\\n   */\\n  event Unpaused(address account);\\n\\n  modifier contractUnpaused() {\\n    require(!paused, \\\"AM08\\\");\\n    _;\\n  }\\n\\n  modifier contractPaused() {\\n    require(paused, \\\"AM09\\\");\\n    _;\\n  }\\n\\n  function compareInt(uint256 val1, uint256 val2) internal pure {\\n    require(val1 == val2, \\\"AM11\\\");\\n  }\\n\\n  function compareAddress(address add1, address add2) internal pure {\\n    require(add1 == add2, \\\"AM002\\\");\\n  }\\n\\n  /**\\n   * @notice To pause the contract.\\n   * @dev Requirements: It can only be invoked by owner.\\n   */\\n  function pause() external contractUnpaused onlyOwner {\\n    paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  /**\\n   * @notice To resume/unpause the contract.\\n   * @dev Requirements: It can only be invoked by the owner.\\n   */\\n  function unPause() external contractPaused onlyOwner {\\n    paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n\\n  function validateGreaterEqual(uint256 val1, uint256 val2) internal pure {\\n    require(val1 \\u003e= val2, \\\"AFS19\\\");\\n  }\\n\\n  function addressCheck(address add1, address add2) internal pure {\\n    require(add1 != add2, \\\"AM04\\\"); //solhint-disable-line reason-string\\n  }\\n\\n  /**\\n   * @notice Returns the pause status of the contract.\\n   * @return bool pause status of the contract.\\n   */\\n  function getPauseStatus() external view returns (bool) {\\n    return paused;\\n  }\\n\\n  function isPresentCheck(bool isPresent) internal pure {\\n    if (isPresent) revert(\\\"AFM03\\\");\\n  }\\n\\n  function setRebalanceController(address _rebalanceController) external onlyOwner {\\n    addressCheck(_rebalanceController, address(0));\\n    rebalanceController = _rebalanceController;\\n  }\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @dev The wallet must not be address zero. The wallet must not be present.\\n   * @param _aFiStorage Address of AFiStorage contract.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address that has to be added in the `teamWallets` array.\\n   */\\n  function addTeamWalletInAFi(\\n    IAFiStorage _aFiStorage,\\n    address aFiContract,\\n    address _wallet\\n  ) external nonReentrant onlyOwner contractUnpaused {\\n    require(_wallet != address(0), \\\"AFM02\\\");\\n    (, bool isPresent) = _aFiStorage.getTeamWalletDetails(aFiContract, _wallet);\\n    isPresentCheck(isPresent);\\n    _aFiStorage.addTeamWallet(aFiContract, _wallet, true, true);\\n    emit AddTeamWalletInAFi(aFiContract, _wallet);\\n  }\\n\\n  /**\\n   * @notice To rebalance the underlying tokens.\\n   */\\n  function rebalance(\\n    bytes memory data,\\n    RebalanceData memory rebalData,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount,\\n    uint stableAmountOut, // length of array should be \\u003e1 in second scenario\\n    uint256 _rebalFeeToDeduct\\n  ) external nonReentrant contractUnpaused {\\n    compareAddress(msg.sender, rebalanceController);\\n    require(rebalData.scenario \\u003c 3 \\u0026\\u0026 rebalData.scenario \\u003e 0, \\\"AM05\\\");\\n    require(rebalData.uTokenToRemove != address(rebalData.depositToken), \\\"AM010\\\");\\n    require(\\n      rebalData._aFiStorage.isAFiActiveRebalanced(address(rebalData.aFiContract)),\\n      \\\"AM00\\\"\\n    );\\n    (, rebal, ) = IAFi(rebalData.aFiContract).getTVLandRebalContractandType();\\n    address[] memory uTokens = IAFi(rebalData.aFiContract).getUTokens();\\n\\n    // Validate uTokenToRemove and uTokenToRemoveIndex\\n    require(uTokens[rebalData.uTokenToRemoveIndex] == rebalData.uTokenToRemove, \\\"AM12\\\");\\n\\n    if (rebalData.scenario == 2) {\\n      (, bool present) = ArrayUtils.indexOf(uTokens, rebalData.newUToken);\\n      isPresentCheck(present);\\n      validateNewUTokenData(data, rebalData.newUToken);\\n    }else {\\n      require(uTokens.length \\u003e 1, \\\"AM032\\\");\\n    }\\n\\n    uint totalReturnedDepositToken;\\n    {\\n      totalReturnedDepositToken = rebalData.depositToken.balanceOf(\\n        address(rebalData.aFiContract)\\n      );\\n      rebalData._aFiStorage._withdrawAll(\\n        address(rebalData.aFiContract),\\n        rebalData.uTokenToRemove\\n      );\\n\\n      convertToStable(\\n        rebalData.aFiContract,\\n        rebalData.uTokenToRemove,\\n        address(rebalData.depositToken),\\n        deadline,\\n        stableAmountOut\\n      );\\n\\n      checkRebalFeesandDeduct(\\n        _rebalFeeToDeduct,\\n        address(rebalData.depositToken),\\n        rebalData.aFiContract\\n      );\\n\\n      totalReturnedDepositToken =\\n        rebalData.depositToken.balanceOf(address(rebalData.aFiContract)) -\\n        totalReturnedDepositToken;\\n    }\\n    (address[] memory inputStables, address[] memory nonOverlappingITokens) = IAFi(\\n      rebalData.aFiContract\\n    ).getInputToken();\\n\\n    updateInputTokenData(\\n      address(rebalData.aFiContract),\\n      address(rebalData._aFiStorage),\\n      rebalData.uTokenToRemove,\\n      inputStables,\\n      nonOverlappingITokens\\n    );\\n    \\n    defaultProportion = rebalData.defaultProportion;\\n    (, rebalData.defaultProportion) = rebalData.aFiContract.getProportions();\\n\\n    bool isNewTokenPresent;\\n    {\\n      if (rebalData.scenario == 1) {\\n        if (\\n          IPassiveRebal(rebal).getRebalStrategyNumber(address(rebalData.aFiContract)) ==\\n          1\\n        ) {\\n          (rebalData.uTokenProportions, ) = updateProportion(\\n            address(rebalData.aFiContract),\\n            rebalData._aFiStorage,\\n            uTokens\\n          );\\n        } else {\\n          rebalData.uTokenProportions = rebalData.defaultProportion;\\n        }\\n        // investInOtherUTokens\\n        rebalData.uTokensAfterS1 = scenario1Investments(\\n          rebalData,\\n          uTokens,\\n          totalReturnedDepositToken,\\n          deadline,\\n          minimumReturnAmount\\n        );\\n\\n        rebalData.aFiContract.updateuTokAndProp(rebalData.uTokensAfterS1);\\n      } else {\\n        (inputStables, nonOverlappingITokens) = IAFi(rebalData.aFiContract)\\n          .getInputToken();\\n\\n        rebalData.aFiContract.updatePoolData(data);\\n        (, isNewTokenPresent) = ArrayUtils.indexOf(\\n          nonOverlappingITokens,\\n          rebalData.newUToken\\n        );\\n\\n        if (isNewTokenPresent) {\\n          nonOverlappingITokens = removeFromNonOverlappingITokens(\\n            nonOverlappingITokens,\\n            rebalData.newUToken\\n          );\\n        }\\n        // Update nonOverlappingITokens in AFiBase\\n        IAFi(rebalData.aFiContract).updateInputTokens(nonOverlappingITokens);\\n\\n        uTokens = scenario2Investments(\\n          rebalData.depositToken,\\n          rebalData.uTokenToRemoveIndex,\\n          rebalData.aFiContract,\\n          uTokens,\\n          rebalData.newUToken,\\n          totalReturnedDepositToken,\\n          deadline,\\n          minimumReturnAmount\\n        );\\n\\n        (rebalData.uTokenProportions, ) = updateProportion(\\n          address(rebalData.aFiContract),\\n          rebalData._aFiStorage,\\n          uTokens\\n        );\\n        updateAFiData(\\n          rebalData.aFiContract,\\n          uTokens,\\n          defaultProportion,\\n          rebalData.uTokenProportions\\n        );\\n      }\\n    }\\n  }\\n\\n  function updateAFiData(\\n    IAFi afiContract,\\n    address[] memory uTokens,\\n    uint256[] memory dp,\\n    uint256[] memory cp\\n  ) internal {\\n    afiContract.updateDp(dp, cp);\\n    afiContract.updateuTokAndProp(uTokens);\\n  }\\n\\n  function updateInputTokenData(\\n    address aFiContract,\\n    address _aFiStorage,\\n    address uTokenToRemove,\\n    address[] memory inputStables,\\n    address[] memory nonOverlappingITokens\\n  ) internal {\\n    // Check if uTokenToRemove exists in inputStables\\n    (, bool isInputStable) = ArrayUtils.indexOf(inputStables, uTokenToRemove);\\n\\n    if (isInputStable) {\\n      // Clear preDepositedInputTokens and add uTokenToRemove to nonOverlappingITokens\\n      IAFiStorage(_aFiStorage).deletePreDepositedInputToken(\\n        aFiContract,\\n        uTokenToRemove,\\n        IAFi(aFiContract).getcSwapCounter()\\n      );\\n      // Add uTokenToRemove to nonOverlappingITokens if not already present\\n      nonOverlappingITokens = addToNonOverlappingITokens(\\n        nonOverlappingITokens,\\n        uTokenToRemove\\n      );\\n      // Update nonOverlappingITokens in AFiBase\\n      IAFi(aFiContract).updateInputTokens(nonOverlappingITokens);\\n    }\\n  }\\n\\n  function addToNonOverlappingITokens(\\n    address[] memory _nonOverlappingITokens,\\n    address token\\n  ) internal pure returns (address[] memory) {\\n    (, bool isPresent) = ArrayUtils.indexOf(_nonOverlappingITokens, token);\\n    if (!isPresent) {\\n      address[] memory newTokens = new address[](_nonOverlappingITokens.length + 1);\\n      for (uint i = 0; i \\u003c _nonOverlappingITokens.length; i++) {\\n        newTokens[i] = _nonOverlappingITokens[i];\\n      }\\n      newTokens[_nonOverlappingITokens.length] = token;\\n      return newTokens;\\n    }\\n    return _nonOverlappingITokens;\\n  }\\n\\n  function removeFromNonOverlappingITokens(\\n    address[] memory _nonOverlappingITokens,\\n    address token\\n  ) internal pure returns (address[] memory) {\\n    (, bool isPresent) = ArrayUtils.indexOf(_nonOverlappingITokens, token);\\n    if (isPresent) {\\n      return ArrayUtils.remove(_nonOverlappingITokens, token);\\n    }\\n    return _nonOverlappingITokens;\\n  }\\n\\n  /**\\n   * @notice To invest tokens as per scenario 1.\\n   * @dev 1 =\\u003e Remove all DepositToken from U1 \\u0026 Invest into U2, U3.\\n   */\\n  function scenario1Investments(\\n    RebalanceData memory rebalData,\\n    address[] memory uTokens,\\n    uint totalReturnedDepositToken,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount\\n  ) internal returns (address[] memory rbtoUTokens) {\\n    uint256 _denominator;\\n    uint256 swapAmount;\\n    // Calculate the denominator as per the updated proportions\\n    for (uint i = 0; i \\u003c uTokens.length; i++) {\\n      if (i != rebalData.uTokenToRemoveIndex) {\\n        _denominator += rebalData.defaultProportion[i];\\n        //we have scenario from struct while declaring another varibale gettin stack to deep\\n        rebalData.scenario += rebalData.uTokenProportions[i];\\n      }\\n    }\\n\\n    // Invest the totalReturnedDepositToken as per the proportions\\n    address midTok;\\n    uint256[] memory defaultTokens = new uint256[](uTokens.length - 1);\\n    rbtoUTokens = new address[](uTokens.length - 1);\\n\\n    for (uint j = 0; j \\u003c uTokens.length; j++) {\\n      if (j != rebalData.uTokenToRemoveIndex) {\\n        uint256 proportion = (rebalData.defaultProportion[j] * 10000000) / _denominator;\\n\\n        if (j \\u003e rebalData.uTokenToRemoveIndex) {\\n          defaultTokens[j - 1] = proportion;\\n          rbtoUTokens[j - 1] = uTokens[j];\\n        } else {\\n          rbtoUTokens[j] = uTokens[j];\\n          defaultTokens[j] = proportion;\\n        }\\n\\n        midTok = IUniswapOracleV3(afiOracle).getMidToken(uTokens[j]);\\n\\n        swapAmount =\\n          (rebalData.uTokenProportions[j] * totalReturnedDepositToken) /\\n          rebalData.scenario;\\n\\n        aFiManagerSwap(\\n          address(rebalData.depositToken),\\n          uTokens[j],\\n          swapAmount,\\n          rebalData.aFiContract,\\n          deadline,\\n          midTok,\\n          minimumReturnAmount[j]\\n        );\\n      }\\n    }\\n    (rebalData.uTokenProportions, ) = updateProportion(\\n      address(rebalData.aFiContract),\\n      rebalData._aFiStorage,\\n      rbtoUTokens\\n    );\\n\\n    rebalData.aFiContract.updateDp(defaultTokens, rebalData.uTokenProportions);\\n    emit Rebalance(rebalData.aFiContract, 1);\\n\\n    return rbtoUTokens;\\n  }\\n\\n  /**\\n   * @notice To invest tokens as per scenario 2.\\n   * @dev 2 =\\u003e Remove all DepositToken from U1, invest all in U4.\\n   * @param uTokenToRemoveIndex Index of the underlying token that has to be set to inactive.\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param uTokens An array of underlying tokens.\\n   * @param newUToken Address of the new underlying token.\\n   */\\n  function scenario2Investments(\\n    IERC20 depositToken,\\n    uint uTokenToRemoveIndex,\\n    IAFi aFiContract,\\n    address[] memory uTokens,\\n    address newUToken,\\n    uint totalReturnedDepositToken,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount\\n  ) internal returns (address[] memory rbtoUTokens) {\\n    {\\n      rbtoUTokens = new address[](uTokens.length);\\n\\n      for (uint j = 0; j \\u003c uTokens.length; j++) {\\n        if (j != uTokenToRemoveIndex) {\\n          if (j \\u003c uTokenToRemoveIndex) {\\n            rbtoUTokens[j] = uTokens[j];\\n          } else {\\n            rbtoUTokens[j - 1] = uTokens[j];\\n          }\\n        }\\n      }\\n\\n      rbtoUTokens[rbtoUTokens.length - 1] = newUToken;\\n      _uTokensAfterRebalance = rbtoUTokens;\\n      address midTok = IUniswapOracleV3(afiOracle).getMidToken(newUToken);\\n      aFiManagerSwap(\\n        address(depositToken),\\n        newUToken,\\n        totalReturnedDepositToken,\\n        aFiContract,\\n        deadline,\\n        midTok,\\n        minimumReturnAmount[0]\\n      );\\n    }\\n\\n    emit Rebalance(aFiContract, 2);\\n  }\\n\\n  /**\\n   * @notice Gateway for initiating a Swap from the AFiManager contract.\\n   * @dev The contract must not be paused. It can only be invoked by the AFiManager contract.\\n   * @param from The source token which is swapped for the destination token.\\n   * @param to The destination token to which the from token is swapped into.\\n   * @param amount Amount of from token for swapping.\\n   */\\n  function aFiManagerSwap(\\n    address from,\\n    address to,\\n    uint amount,\\n    IAFi aFiContract,\\n    uint256 deadline,\\n    address midTok,\\n    uint minimumReturnAmount\\n  ) internal {\\n    {\\n      // Initiate Swap via UniswapV3\\n      aFiContract.swapViaStorageOrManager(\\n        from,\\n        to,\\n        amount,\\n        deadline,\\n        midTok,\\n        minimumReturnAmount\\n      );\\n    }\\n\\n    emit AFiManagerSwap(aFiContract, from, to, amount);\\n  }\\n\\n  function validateNewUTokenData(bytes memory _data, address newUToken) internal pure {\\n    IAFi.PoolsData memory pooldata = abi.decode(_data, (IAFi.PoolsData));\\n    IAFi.UnderlyingData memory uniData = abi.decode(\\n      pooldata.underlyingData,\\n      (IAFi.UnderlyingData)\\n    );\\n    require(\\n      pooldata._underlyingTokensProportion.length == pooldata._compound.length \\u0026\\u0026\\n        pooldata._compound.length == pooldata.compoundV3Comet.length \\u0026\\u0026\\n        pooldata.compoundV3Comet.length == pooldata._aaveToken.length,\\n      \\\"AFM05\\\"\\n    );\\n    compareInt(uniData._underlyingTokens.length, 1);\\n    compareInt(pooldata._underlyingTokensProportion[0], 0);\\n    require(uniData._underlyingTokens[0] == newUToken, \\\"AFM08\\\");\\n  }\\n\\n  /**\\n   * @notice  To toggle Active Rebalace status of afiContract to either active/inactive.\\n   * @dev The contract must not be paused.It can invoke by owner\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param _aFiStorage Address of the AFi Storage Contract.\\n   * @param status, bool value for rebalance status of afiContract.\\n   */\\n  function setActiveRebalStatus(\\n    IAFiStorage _aFiStorage,\\n    address aFiContract,\\n    bool status\\n  ) external nonReentrant onlyOwner contractUnpaused {\\n    _aFiStorage.setActiveRebalancedStatus(aFiContract, status);\\n    emit SetActiveRebalStatus(aFiContract, status);\\n  }\\n\\n  struct AlgoRebalanceData {\\n    IAFi aFiContract;\\n    IAFiStorage _aFiStorage;\\n    bytes underlyingData;\\n    address[] newUnderlyingOracle;\\n    address[] prevUnderlying;\\n    address stableCoin;\\n    uint managerFee;\\n    uint deadline;\\n    uint[] minimumReturnAmount;\\n    uint[] minimumUnderlyingAmount;\\n  }\\n\\n  function balance(address tok, address target) internal view returns (uint256) {\\n    return IERC20(tok).balanceOf(target);\\n  }\\n\\n  /**\\n   * @notice To rebalance the underlying tokens in an algo product.\\n   * @dev Remove all DepositToken from multiple underlying tokens \\u0026 Invest into new underlying tokens.\\n   */\\n  // Algo Rebalance 1\\n  function rebalanceUnderlyingTokens(\\n    AlgoRebalanceData memory rebalanceData,\\n    IAFi.SwapParameters memory csParams\\n  ) external contractUnpaused {\\n    compareAddress(msg.sender, rebalanceController);\\n    require(rebalanceData.newUnderlyingOracle.length \\u003c= 10, \\\"AM07\\\");\\n\\n    rebalanceData.prevUnderlying = rebalanceData.aFiContract.getUTokens();\\n    checkProductType(rebalanceData.aFiContract);\\n    (, rebal, ) = IAFi(rebalanceData.aFiContract).getTVLandRebalContractandType();\\n    (address[] memory iToken, ) = IAFi(rebalanceData.aFiContract).getInputToken();\\n    (iToken, ) = IAFi(rebalanceData.aFiContract).getInputToken();\\n    IPassiveRebal(rebal).initUniStructure(iToken, rebalanceData.underlyingData);\\n\\n    IAFi.UnderlyingData memory underlyingUniData = abi.decode(\\n      rebalanceData.underlyingData,\\n      (IAFi.UnderlyingData)\\n    );\\n    uint stableCoinBalance = balance(\\n      rebalanceData.stableCoin,\\n      address(rebalanceData.aFiContract)\\n    );\\n    uint sameUnderlyingCount = rebalanceAlgo(\\n      rebalanceData.aFiContract,\\n      rebalanceData.underlyingData,\\n      rebalanceData.newUnderlyingOracle,\\n      rebalanceData.prevUnderlying\\n    );\\n    swapUnderlying(\\n      rebalanceData,\\n      underlyingUniData._underlyingTokens,\\n      sameUnderlyingCount,\\n      stableCoinBalance,\\n      (rebalanceData.prevUnderlying.length ==\\n        underlyingUniData._underlyingTokens.length)\\n    );\\n\\n    uint256[] memory newProp = new uint256[](\\n      underlyingUniData._underlyingTokens.length\\n    );\\n    (newProp, ) = updateProportion(\\n      address(rebalanceData.aFiContract),\\n      rebalanceData._aFiStorage,\\n      underlyingUniData._underlyingTokens\\n    );\\n\\n    updateAFiData(\\n      rebalanceData.aFiContract,\\n      underlyingUniData._underlyingTokens,\\n      newProp,\\n      newProp\\n    );\\n    doCswap(rebalanceData.aFiContract, csParams, rebalanceData._aFiStorage);\\n\\n    emit RebalanceUnderlyingTokens(\\n      address(rebalanceData.aFiContract),\\n      address(rebalanceData._aFiStorage),\\n      underlyingUniData._underlyingTokens,\\n      rebalanceData.stableCoin,\\n      rebalanceData.managerFee\\n    );\\n  }\\n\\n  function doCswap(\\n    IAFi afiContract,\\n    IAFi.SwapParameters memory csParams,\\n    IAFiStorage aFiStorage\\n  ) internal {\\n    (address[] memory _iToken, ) = afiContract.getInputToken();\\n    uint256 totalPreDepBalance;\\n    for (uint i = 0; i \\u003c _iToken.length; i++) {\\n      totalPreDepBalance += getPredepBalInUSDC(\\n        _iToken[i],\\n        address(afiContract),\\n        aFiStorage\\n      );\\n    }\\n\\n    if (totalPreDepBalance \\u003e= afiContract.getPreSwapDepositLimit()) {\\n      IUniswapOracleV3(afiOracle).cumulativeSwap(csParams);\\n    }\\n  }\\n\\n  function setafiOracleContract(address _afiOracle) external onlyOwner {\\n    addressCheck(_afiOracle, address(0));\\n    afiOracle = _afiOracle;\\n  }\\n\\n  /**\\n   * @notice Sets the rebalance Manager fee upper.\\n   * @dev Only the contract owner can call this function.\\n   * @param _rebalFeeUpperLimit New algo fee maximum limit.\\n   */\\n  function setRebalFeeUpperLimit(uint256 _rebalFeeUpperLimit) external onlyOwner {\\n    rebalFeeUpperLimit = _rebalFeeUpperLimit;\\n  }\\n\\n  /**\\n   * @notice Sets the rebalance fee.\\n   * @dev Only the contract owner can call this function.\\n   * @param _rebalfee New rebalance fee.\\n   */\\n  function setRebalFee(uint256 _rebalfee) external onlyOwner {\\n    require(_rebalfee \\u003c= rebalFeeUpperLimit, \\\"AFMO111\\\");\\n    rebalfee = _rebalfee;\\n  }\\n\\n  function rebalanceAlgo(\\n    IAFi aFiContract,\\n    bytes memory uniData,\\n    address[] memory newUnderlyingOracle,\\n    address[] memory prevUnderlying\\n  ) internal returns (uint256) {\\n    bool exist;\\n    uint sameUnderlyingCount;\\n\\n    (, rebal, ) = aFiContract.getTVLandRebalContractandType();\\n\\n    IAFi.UnderlyingData memory underlyingUniData = abi.decode(\\n      uniData,\\n      (IAFi.UnderlyingData)\\n    );\\n\\n    for (uint i = 0; i \\u003c prevUnderlying.length; i++) {\\n      underlyingExists[address(aFiContract)][prevUnderlying[i]] = true;\\n    }\\n\\n    for (uint i = 0; i \\u003c underlyingUniData._underlyingTokens.length; i++) {\\n      if (prevUnderlying.length == underlyingUniData._underlyingTokens.length) {\\n        exist = checkIfUTokenExist(\\n          address(aFiContract),\\n          underlyingUniData._underlyingTokens[i]\\n        );\\n        if (exist) {\\n          isUnderlyingCommon[underlyingUniData._underlyingTokens[i]] = true;\\n          delete exist;\\n          sameUnderlyingCount++;\\n        }\\n      }\\n      IPassiveRebal(rebal).updateOracleData(\\n        underlyingUniData._underlyingTokens[i],\\n        newUnderlyingOracle[i]\\n      );\\n    }\\n    IUniswapOracleV3(afiOracle).updateMidToken(\\n      underlyingUniData._underlyingTokens,\\n      underlyingUniData._underlyingUniPoolToken\\n    );\\n    return sameUnderlyingCount;\\n  }\\n\\n  function swapUnderlying(\\n    AlgoRebalanceData memory rebalanceData,\\n    address[] memory uTokensToAdd,\\n    uint _sameUnderlying,\\n    uint oldBalance,\\n    bool isLengthEqual\\n  ) internal {\\n    address midTok;\\n    uint rebalanceAmount;\\n    uint stableCoinBalance;\\n    if (isLengthEqual) {\\n      for (uint i = 0; i \\u003c rebalanceData.prevUnderlying.length; i++) {\\n        if (!isUnderlyingCommon[rebalanceData.prevUnderlying[i]]) {\\n          rebalanceAmount = balance(\\n            rebalanceData.prevUnderlying[i],\\n            address(rebalanceData.aFiContract)\\n          );\\n          midTok = IUniswapOracleV3(afiOracle).getMidToken(\\n            rebalanceData.prevUnderlying[i]\\n          );\\n\\n          // Get Deposit token back from the UToken that is going to be rebalanced\\n          aFiManagerSwap(\\n            rebalanceData.prevUnderlying[i],\\n            rebalanceData.stableCoin,\\n            rebalanceAmount,\\n            rebalanceData.aFiContract,\\n            rebalanceData.deadline,\\n            midTok,\\n            rebalanceData.minimumReturnAmount[i]\\n          );\\n        }\\n      }\\n      checkRebalFeesandDeduct(\\n        rebalanceData.managerFee,\\n        rebalanceData.stableCoin,\\n        rebalanceData.aFiContract\\n      );\\n\\n      stableCoinBalance = ((\\n        balance(rebalanceData.stableCoin, address(rebalanceData.aFiContract))\\n      ) - (oldBalance));\\n      rebalanceAmount = (stableCoinBalance) / (uTokensToAdd.length - _sameUnderlying);\\n\\n      for (uint i = 0; i \\u003c uTokensToAdd.length; i++) {\\n        if (!isUnderlyingCommon[uTokensToAdd[i]]) {\\n          midTok = IUniswapOracleV3(afiOracle).getMidToken(uTokensToAdd[i]);\\n\\n          // Swap stable token into into new underlying tokens in same proportions\\n          aFiManagerSwap(\\n            rebalanceData.stableCoin,\\n            uTokensToAdd[i],\\n            rebalanceAmount,\\n            rebalanceData.aFiContract,\\n            rebalanceData.deadline,\\n            midTok,\\n            rebalanceData.minimumUnderlyingAmount[i]\\n          );\\n        } else {\\n          delete isUnderlyingCommon[uTokensToAdd[i]];\\n        }\\n      }\\n    } else {\\n      //  When prevUnderlying length is not equal.All existing underlying token will be swapped\\n      for (uint i = 0; i \\u003c rebalanceData.prevUnderlying.length; i++) {\\n        rebalanceAmount = balance(\\n          rebalanceData.prevUnderlying[i],\\n          address(rebalanceData.aFiContract)\\n        );\\n        midTok = IUniswapOracleV3(afiOracle).getMidToken(\\n          rebalanceData.prevUnderlying[i]\\n        );\\n\\n        // Get Deposit token back from the UToken that is going to be rebalanced\\n        aFiManagerSwap(\\n          rebalanceData.prevUnderlying[i],\\n          rebalanceData.stableCoin,\\n          rebalanceAmount,\\n          rebalanceData.aFiContract,\\n          rebalanceData.deadline,\\n          midTok,\\n          rebalanceData.minimumReturnAmount[i]\\n        );\\n      }\\n\\n      checkRebalFeesandDeduct(\\n        rebalanceData.managerFee,\\n        rebalanceData.stableCoin,\\n        rebalanceData.aFiContract\\n      );\\n\\n      stableCoinBalance = ((\\n        balance(rebalanceData.stableCoin, address(rebalanceData.aFiContract))\\n      ) - (oldBalance));\\n\\n      rebalanceAmount = (stableCoinBalance) / (uTokensToAdd.length);\\n\\n      //stable coin swap into new underlying tokens\\n      for (uint i = 0; i \\u003c uTokensToAdd.length; i++) {\\n        midTok = IUniswapOracleV3(afiOracle).getMidToken(uTokensToAdd[i]);\\n        // Swap stable into into new underlying tokens\\n        aFiManagerSwap(\\n          rebalanceData.stableCoin,\\n          uTokensToAdd[i],\\n          rebalanceAmount,\\n          rebalanceData.aFiContract,\\n          rebalanceData.deadline,\\n          midTok,\\n          rebalanceData.minimumUnderlyingAmount[i]\\n        );\\n      }\\n    }\\n\\n    for (uint256 i = 0; i \\u003c rebalanceData.prevUnderlying.length; i++) {\\n      delete underlyingExists[address(rebalanceData.aFiContract)][\\n        rebalanceData.prevUnderlying[i]\\n      ];\\n    }\\n  }\\n\\n  function checkRebalFeesandDeduct(\\n    uint256 fee,\\n    address stableCoin,\\n    IAFi aficontract\\n  ) internal {\\n    require(fee / (10 ** IERC20(stableCoin).decimals()) \\u003c= rebalfee, \\\"AB35\\\");\\n    aficontract.sendProfitOrFeeToManager(msg.sender, fee, stableCoin);\\n  }\\n\\n  // emergency withdraw from pools\\n  function withdrawFromPool(\\n    IAFiStorage _afiStorage,\\n    IAFi aFiContract,\\n    address underlyinToken\\n  ) external nonReentrant onlyOwner contractUnpaused {\\n    _afiStorage._withdrawAll(address(aFiContract), underlyinToken);\\n    emit WithdrawFromPool(address(aFiContract), underlyinToken);\\n  }\\n\\n  /**\\n   * @notice gets the new proportions of the underlying tokens in an afiContract.\\n   * @param aFiContract indicates address of afiContract\\n   * @param _aFiStorage indicates address of afiStorage.\\n   * @param uTok array of new uTokens for logging.\\n   */\\n  function updateProportion(\\n    address aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address[] memory uTok\\n  ) internal view returns (uint256[] memory prop, uint256 totalProp) {\\n    uint256 totalBalance;\\n    for (uint i = 0; i \\u003c uTok.length; i++) {\\n      totalBalance += (_aFiStorage.calcPoolValue(uTok[i], aFiContract) -\\n        getPredepBalInUSDC(uTok[i], aFiContract, _aFiStorage));\\n    }\\n    prop = new uint256[](uTok.length);\\n\\n    //Update Proportions\\n    unchecked {\\n      for (uint j = 0; j \\u003c uTok.length; j++) {\\n        prop[j] =\\n          ((_aFiStorage.calcPoolValue(uTok[j], aFiContract) -\\n            getPredepBalInUSDC(uTok[j], aFiContract, _aFiStorage)) * (10000000)) /\\n          (totalBalance);\\n        totalProp = totalProp + prop[j];\\n      }\\n    }\\n    return (prop, totalProp);\\n  }\\n\\n  function getPredepBalInUSDC(\\n    address tok,\\n    address aFiContract,\\n    IAFiStorage _aFiStorage\\n  ) internal view returns (uint256 tokPredepInUSD) {\\n    uint256 temp;\\n    uint256 multiplier;\\n\\n    (temp, multiplier) = _aFiStorage.getPriceInUSDC(tok);\\n    uint256 depTok = _aFiStorage.getPreSwapDepositsTokens(\\n      aFiContract,\\n      IAFi(aFiContract).getcSwapCounter(),\\n      tok\\n    );\\n\\n    tokPredepInUSD = (depTok) * (uint(temp));\\n    temp = _aFiStorage.validateAndGetDecimals(tok);\\n    tokPredepInUSD = ((tokPredepInUSD * (10 ** temp)) / (multiplier));\\n  }\\n\\n  /**\\n   * @notice Checks the existence status of a token in an aFi contract.\\n   * @param uTok Address of the token to check.\\n   * @return bool Whether the token exists or not.\\n   */\\n  function checkIfUTokenExist(\\n    address afiContract,\\n    address uTok\\n  ) internal view returns (bool) {\\n    return underlyingExists[afiContract][uTok];\\n  }\\n\\n  function updateStableUnitsInUSD(\\n    uint256 _preDepositsStablesInUSD\\n  ) external returns (uint256) {\\n    compareAddress(msg.sender, rebalanceController);\\n    preDepositsStablesInUSD = _preDepositsStablesInUSD;\\n    return _preDepositsStablesInUSD;\\n  }\\n\\n  /**\\n   * @notice Returns a new array of underlying token, token proportion and default proption that to be used by the AFiBase.\\n   * @param aFiContract address of the afiContract.\\n   * @param aFiContract address of the AFiStorage.\\n   * @return underlyingTokenProportions array of new proportion.\\n   */\\n  function getUTokenProportion(\\n    address aFiContract,\\n    address _aFiStorage\\n  )\\n    external\\n    view\\n    returns (uint256[] memory underlyingTokenProportions, uint256 totalProp)\\n  {\\n    (, address rebalAddress, ) = IAFi(aFiContract).getTVLandRebalContractandType();\\n    compareAddress(msg.sender, rebalAddress);\\n\\n    (underlyingTokenProportions, totalProp) = updateProportion(\\n      aFiContract,\\n      IAFiStorage(_aFiStorage),\\n      IAFi(aFiContract).getUTokens()\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculates the total value of pre-swap deposits in USD.\\n   * @dev Internal function used to determine the total value of pre-swap deposits in USD.\\n   * @param aFiContract Instance of the aFi contract.\\n   * @param _aFiStorage Instance of the aFiStorage contract.\\n   * @return totalPreDepositInUSD The total value of pre-swap deposits in USD.\\n   */\\n  function inputTokenUSD(\\n    IAFi aFiContract,\\n    uint256 cSwapCounter,\\n    IAFiStorage _aFiStorage\\n  ) public view returns (uint256 totalPreDepositInUSD) {\\n    (address[] memory _iToken, ) = aFiContract.getInputToken();\\n    uint256 depTok;\\n    uint uTokensDecimal;\\n    uint256 price;\\n    uint256 multiplier;\\n\\n    for (uint i = 0; i \\u003c _iToken.length; i++) {\\n      (depTok) = _aFiStorage.getPreSwapDepositsTokens(\\n        address(aFiContract),\\n        cSwapCounter,\\n        address(_iToken[i])\\n      );\\n      if (depTok \\u003e 0) {\\n        uTokensDecimal = IERC20(_iToken[i]).decimals();\\n        (price, multiplier) = _aFiStorage.getPriceInUSDC(_iToken[i]);\\n\\n        validateGreaterEqual(18, uTokensDecimal);\\n        uTokensDecimal = 18 - uTokensDecimal;\\n        totalPreDepositInUSD += (((depTok) * (10 ** uTokensDecimal) * (uint(price))) /\\n          (multiplier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Performs an emergency rebalance of the aFi contract.\\n   * @dev Only the contract owner can call this function, and it must not be reentrant.\\n   * @param aFiContract Instance of the aFi contract.\\n   * @param _aFiStorage Instance of the aFiStorage contract.\\n   * @param uTokenToRemove Address of the uToken to be removed.\\n   * @param defProp Array of default uTokens proportion to be updated.\\n   */\\n  function emergencyRebalance(\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address uTokenToRemove,\\n    uint256[] memory defProp\\n  ) external nonReentrant onlyOwner contractUnpaused {\\n    rebalanceInternal(aFiContract, _aFiStorage, uTokenToRemove, defProp);\\n  }\\n\\n  function rebalanceInternal(\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address uTokenToRemove,\\n    uint256[] memory defProp\\n  ) internal {\\n    address[] memory uTok = aFiContract.getUTokens();\\n\\n    (uint index, ) = ArrayUtils.indexOf(uTok, uTokenToRemove);\\n\\n    for (uint i = 0; i \\u003c uTok.length; i++) {\\n      if (i \\u003e= index \\u0026\\u0026 i != (uTok.length - 1)) {\\n        uTok[i] = uTok[i + 1];\\n      }\\n\\n      if (i == (uTok.length - 1)) {\\n        assembly {\\n          mstore(uTok, sub(mload(uTok), 1))\\n        }\\n      }\\n    }\\n\\n    compareInt(uTok.length, defProp.length);\\n\\n    _aFiStorage._withdrawAll(address(aFiContract), uTokenToRemove);\\n\\n    // Update input token data after removing the uToken\\n    (\\n      address[] memory inputStables,\\n      address[] memory nonOverlappingITokens\\n    ) = aFiContract.getInputToken();\\n \\n    (, , uint256 productType) = aFiContract.getTVLandRebalContractandType();\\n    if(productType != 3){\\n      updateInputTokenData(\\n        address(aFiContract),\\n        address(_aFiStorage),\\n        uTokenToRemove,\\n        inputStables,\\n        nonOverlappingITokens\\n      );\\n    }\\n   \\n    updateAFiData(aFiContract, uTok, defProp, defProp);\\n  }\\n\\n  function checkProductType(IAFi afiContract) internal {\\n    (, , uint256 productType) = afiContract.getTVLandRebalContractandType();\\n    compareInt(productType, 3);\\n  }\\n\\n  /**\\n   * @notice Performs an algo type 2 rebalance of the aFi contract.\\n   * @dev Only the contract owner can call this function, and it must not be reentrant.\\n   * @param aFiContract address of the aFi contract.\\n   * @param _aFiStorage address of the aFiStorage contract.\\n   * @param uTokenToRemove Address of the uToken to be removed.\\n   * @param defProp Array of default uTokens proportion to be updated.\\n   * @param deadline uint256 deadline to perform swaps on uniswapV3.\\n   * @param stableamountOut uint256 minimum amount out value of the depositTok after swap.\\n   */\\n  // Algo Rebalance 2\\n  function algoRebalance2(\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address uTokenToRemove,\\n    uint256[] memory defProp,\\n    address depositTok,\\n    uint256 deadline,\\n    uint256 stableamountOut\\n  ) external nonReentrant contractUnpaused {\\n    compareAddress(msg.sender, rebalanceController);\\n\\n    (address[] memory inputStables, ) = aFiContract.getInputToken();\\n    (, bool present) = ArrayUtils.indexOf(inputStables, depositTok);\\n    require(present, \\\"AM003\\\");\\n\\n    rebalanceInternal(aFiContract, _aFiStorage, uTokenToRemove, defProp);\\n\\n    uint256 balToConsider = convertToStable(\\n      aFiContract,\\n      uTokenToRemove,\\n      depositTok,\\n      deadline,\\n      stableamountOut\\n    );\\n\\n    if(uTokenToRemove == depositTok){\\n      balToConsider = _aFiStorage.getPreSwapDepositsTokens(\\n        address(aFiContract),\\n        aFiContract.getcSwapCounter(),\\n        uTokenToRemove\\n      );\\n    }\\n\\n    balToConsider = balance(depositTok, address(aFiContract)) - balToConsider;\\n\\n    _aFiStorage.setPreDepositedInputTokenInRebalance(\\n      address(aFiContract),\\n      aFiContract.getcSwapCounter(),\\n      balToConsider,\\n      depositTok\\n    );\\n\\n    isQueueWithdrawUnstakingPaused[address(aFiContract)] = true;\\n  }\\n\\n  function pauseQueueWithdrawUnstaking(address afiContract, bool status) external {\\n    require(msg.sender == afiOracle, \\\"AM012\\\");\\n    isQueueWithdrawUnstakingPaused[afiContract] = status;\\n  }\\n\\n  function reInitializeVault(\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    bytes memory uniData,\\n    address[] memory uTokens,\\n    address[] memory oracles,\\n    uint256[] memory defaultProp,\\n    uint256[] memory currentProp,\\n    IAFi.SwapParameters memory csParams\\n  ) external contractUnpaused {\\n    compareAddress(msg.sender, rebalanceController);\\n    require(aFiContract.getUTokens().length == 0, \\\"AM15\\\");\\n    require(uTokens.length \\u003c= 10, \\\"AM0009\\\");\\n    checkProductType((aFiContract));\\n    IAFi.UnderlyingData memory underlyingUniData = abi.decode(\\n      uniData,\\n      (IAFi.UnderlyingData)\\n    );\\n    updateAFiData(aFiContract, uTokens, defaultProp, currentProp);\\n    (, rebal, ) = IAFi(aFiContract).getTVLandRebalContractandType();\\n    (address[] memory iToken, ) = IAFi(aFiContract).getInputToken();\\n    (iToken, ) = IAFi(aFiContract).getInputToken();\\n    IPassiveRebal(rebal).initUniStructure(iToken, uniData);\\n    IUniswapOracleV3(afiOracle).updateMidToken(\\n      underlyingUniData._underlyingTokens,\\n      underlyingUniData._underlyingUniPoolToken\\n    );\\n    for (uint256 i; i \\u003c uTokens.length; i++) {\\n      IPassiveRebal(rebal).updateOracleData(\\n        underlyingUniData._underlyingTokens[i],\\n        oracles[i]\\n      );\\n    }\\n    aFiContract.reinitializeHappened(true);\\n    doCswap(aFiContract, csParams, _aFiStorage);\\n  }\\n\\n  function convertToStable(\\n    IAFi aFiContract,\\n    address uTokenToRemove,\\n    address depositTok,\\n    uint256 deadline,\\n    uint256 stableamountOut\\n  ) internal returns (uint256 _stableBalToConsider) {\\n    require(balance(uTokenToRemove, address(aFiContract)) \\u003e 0, \\\"AM06\\\");\\n\\n    // To avoid stack too deep error\\n    // Get Deposit token back from the UToken that is going to be rebalanced\\n    address midTok = IUniswapOracleV3(afiOracle).getMidToken(uTokenToRemove);\\n\\n    _stableBalToConsider = balance(depositTok, address(aFiContract));\\n\\n    if(uTokenToRemove != depositTok){\\n      aFiManagerSwap(\\n        uTokenToRemove,\\n        depositTok,\\n        balance(uTokenToRemove, address(aFiContract)),\\n        aFiContract,\\n        deadline,\\n        midTok,\\n        stableamountOut\\n      );\\n    }\\n  }\\n}\\n\"},\"ArrayUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\n// Reference: https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\\nlibrary ArrayUtils {\\n  /**\\n   * Deletes address at index and fills the spot with the last address.\\n   * Order is preserved.\\n   */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopAddress(address[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopUint256(uint[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sumOfMArrays(\\n    uint[] memory A,\\n    uint[] memory B\\n  ) internal pure returns (uint[] memory sum) {\\n    sum = new uint[](A.length);\\n    for (uint i = 0; i \\u003c A.length; i++) {\\n      sum[i] = A[i] + B[i];\\n    }\\n    return sum;\\n  }\\n\\n  /**\\n   * Finds the index of the first occurrence of the given element.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns (index and isIn) for the first occurrence starting from index 0\\n   */\\n  function indexOf(address[] memory A, address a) internal pure returns (uint, bool) {\\n    uint length = A.length;\\n    for (uint i = 0; i \\u003c length; i++) {\\n      if (A[i] == a) {\\n        return (i, true);\\n      }\\n    }\\n    return (type(uint).max, false);\\n  }\\n\\n  /**\\n   * Returns true if the value is present in the list. Uses indexOf internally.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns isIn for the first occurrence starting from index 0\\n   */\\n  function contains(address[] memory A, address a) internal pure returns (bool) {\\n    (, bool isIn) = indexOf(A, a);\\n    return isIn;\\n  }\\n\\n  /**\\n   * Returns true if there are 2 elements that are the same in an array\\n   * @param A The input array to search\\n   * @return Returns boolean for the first occurrence of a duplicate\\n   */\\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\\n    require(A.length \\u003e 0, \\\"A is empty\\\");\\n\\n    for (uint i = 0; i \\u003c A.length - 1; i++) {\\n      address current = A[i];\\n      for (uint j = i + 1; j \\u003c A.length; j++) {\\n        if (current == A[j]) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   * @return Returns the array with the object removed.\\n   */\\n  function remove(\\n    address[] memory A,\\n    address a\\n  ) internal pure returns (address[] memory) {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      (address[] memory _A, ) = pop(A, index);\\n      return _A;\\n    }\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   */\\n  function removeStorage(address[] storage A, address a) internal {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      uint lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\\n      if (index != lastIndex) {\\n        A[index] = A[lastIndex];\\n      }\\n      A.pop();\\n    }\\n  }\\n\\n  /**\\n   * Removes specified index from array\\n   * @param A The input array to search\\n   * @param index The index to remove\\n   * @return Returns the new array and the removed entry\\n   */\\n  function pop(\\n    address[] memory A,\\n    uint index\\n  ) internal pure returns (address[] memory, address) {\\n    uint length = A.length;\\n    require(index \\u003c A.length, \\\"Index must be \\u003c A length\\\");\\n    address[] memory newAddresses = new address[](length - 1);\\n    for (uint i = 0; i \\u003c index; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = index + 1; j \\u003c length; j++) {\\n      newAddresses[j - 1] = A[j];\\n    }\\n    return (newAddresses, A[index]);\\n  }\\n\\n  /**\\n   * Returns the combination of the two arrays\\n   * @param A The first array\\n   * @param B The second array\\n   * @return Returns A extended by B\\n   */\\n  function extend(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure returns (address[] memory) {\\n    uint aLength = A.length;\\n    uint bLength = B.length;\\n    address[] memory newAddresses = new address[](aLength + bLength);\\n    for (uint i = 0; i \\u003c aLength; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = 0; j \\u003c bLength; j++) {\\n      newAddresses[aLength + j] = B[j];\\n    }\\n    return newAddresses;\\n  }\\n\\n  /**\\n   * Validate that address and uint array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of uint\\n   */\\n  function validatePairsWithArray(address[] memory A, uint[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bool array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bool\\n   */\\n  function validatePairsWithArray(address[] memory A, bool[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and string array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of strings\\n   */\\n  function validatePairsWithArray(address[] memory A, string[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address array lengths match, and calling address array are not empty\\n   * and contain no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of addresses\\n   */\\n  function validatePairsWithArray(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bytes array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bytes\\n   */\\n  function validatePairsWithArray(address[] memory A, bytes[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate address array is not empty and contains no duplicate elements.\\n   *\\n   * @param A          Array of addresses\\n   */\\n  function _validateLengthAndUniqueness(address[] memory A) internal pure {\\n    require(A.length \\u003e 0, \\\"Array length must be \\u003e 0\\\");\\n    require(!hasDuplicate(A), \\\"Cannot duplicate addresses\\\");\\n  }\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\"},\"draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account\\u0027s ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\\u0027t\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\\u0027s tokens,\\n     * given ``owner``\\u0027s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``\\u0027s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``\\u0027s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"},\"IAFi.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Extended as IERC20} from \\\"./IERC20Extended.sol\\\";\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./IPassiveRebal.sol\\\";\\n\\n/**\\n * @title PassiveRebal.\\n * @notice Interface of the Passive Rebalance contract.\\n */\\ninterface PassiveRebal {\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    address _aFiStorage,\\n    address[] memory _tokens,\\n    uint256 strategy\\n  ) external returns (uint[] memory proportions, uint256);\\n\\n  function getPauseStatus() external returns (bool);\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n}\\n\\ninterface IAFiOracle {\\n  function uniswapV3Oracle(\\n    address afiContract,\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint _amountIn,\\n    uint _maxTime,\\n    address middleToken,\\n    uint256 minimumReturnAmount\\n  ) external returns (bytes memory swapParams);\\n}\\n\\ninterface IAFiManager {\\n  function updateUTokenProportion(\\n    address aFiContract,\\n    address aFiStorage\\n  ) external returns (uint256[] memory);\\n\\n  function inputTokenUSD(\\n    IAFi aFiContract,\\n    uint256 cSwapCounter,\\n    IAFiStorage _aFiStorage\\n  ) external view returns (uint256 totalPreDepositInUSD);\\n\\n  function rebalanceController() external view returns(address);\\n  function pauseQueueWithdrawUnstaking(address afiContract,bool status) external;\\n  function isQueueWithdrawUnstakingPaused(address afiContract) external view returns(bool);\\n}\\n\\n/**\\n * @title IAFi.\\n * @notice Interface of the AToken.\\n */\\ninterface IAFi {\\n\\n  struct UnderlyingData {\\n    address[] _underlyingTokens; //uTokens\\n    address[] _underlyingUniPoolToken; //uToken - MiddleToken\\n  }\\n\\n  struct PoolsData {\\n    address[] _depositStableCoin;\\n    address[] _depositCoinOracle;\\n    bytes underlyingData;\\n    address[] _compound;\\n    address[] _aaveToken;\\n    address[] _priceOracles;\\n    uint[] _underlyingTokensProportion;\\n    address[] compoundV3Comet;\\n    uint _typeOfProduct;\\n  }\\n\\n  struct SwapParameters {\\n    address afiContract;\\n    address oToken;\\n    uint256 cSwapFee;\\n    uint256 cSwapCounter;\\n    address[] depositTokens;\\n    uint256[] minimumReturnAmount;\\n    uint256[] iMinimumReturnAmount; // minimum amount out expcted after swaps For deposit tokens\\n    address[] underlyingTokens;\\n    uint256[] newProviders;\\n    uint _deadline;\\n    address[] cometToClaim;\\n    address[] cometRewardTokens;\\n    uint256[] rewardTokenMinReturnAmounts;\\n  }\\n\\n  /**\\n   * @notice Function to initialize the data, owner and afi token related data.\\n   * @dev the function should be called once only by factory\\n   * @param newOwner indicates the owner of the created afi product.\\n   * @param _name indicates the name of the afi Token\\n   * @param _symbol indicates symbol of the the afi Token.\\n   * @param data indicates the encoded data that follows the PoolsData struct format.\\n   * @param _isActiveRebalanced indicates the active rebalance status of the afi contract.\\n   * @param _aFiStorage indicates the afi storage contract address.\\n   */\\n  function initialize(\\n    address newOwner,\\n    string memory _name,\\n    string memory _symbol,\\n    bytes memory data,\\n    bool _isActiveRebalanced,\\n    IAFiStorage _aFiStorage,\\n    address[] memory _commonInputTokens\\n  ) external;\\n\\n  /**\\n   * @notice Function to initialize accepted tokens in deposit and withdraw functions.\\n   * @dev  the function should be called once only by factory\\n   * @param iToken indicates the array of the accepted token addressess.\\n   */\\n  function initializeToken(\\n    address[] memory iToken,\\n    address[] memory _teamWallets,\\n    IPassiveRebal _rebalContract,\\n    address _aFiManager\\n  ) external;\\n\\n  function getcSwapCounter() external view returns(uint256);\\n\\n  /**\\n   * @notice Returns the array of underlying tokens.\\n   * @return uTokensArray Array of underlying tokens.\\n   */\\n  function getUTokens() external view returns (address[] memory uTokensArray);\\n\\n  function swapViaStorageOrManager(\\n    address from,\\n    address to,\\n    uint amount,\\n    uint deadline,\\n    address midTok,\\n    uint minimumReturnAmount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Returns the paused status of the contract.\\n   */\\n  function isPaused() external view returns (bool, bool);\\n\\n  function getProportions()\\n    external\\n    view\\n    returns (uint[] memory, uint[] memory);\\n\\n  /**\\n   * @notice Updates the pool data during Active Rebalance.\\n   * @param data that follows PoolsData format indicates the data of the token being rebalanced in Active Rebalance.\\n   */\\n  function updatePoolData(bytes memory data) external;\\n\\n  function sendProfitOrFeeToManager(\\n    address wallet,\\n    uint profitShare,\\n    address oToken\\n  ) external;\\n\\n  function _supplyCompV3(address tok, uint amount) external;\\n\\n  function _supplyAave(address tok, uint amount) external;\\n\\n  function _supplyCompound(address tok, uint amount) external;\\n\\n  function _withdrawAave(address tok, uint amount) external;\\n\\n  function _withdrawCompoundV3(address tok, uint amount) external;\\n\\n  function _withdrawCompound(address tok, uint amount) external;\\n\\n  function getTVLandRebalContractandType()\\n    external\\n    view\\n  returns (uint256, address, uint256);\\n\\n  function getInputToken() external view returns (address[] memory, address[] memory);\\n\\n  function swap(\\n    address inputToken,\\n    address uTok,\\n    uint256 amountAsPerProportion,\\n    uint _deadline,\\n    address middleToken,\\n    uint256 minimumReturnAmount\\n  ) external returns (uint256);\\n\\n  function updateDp(\\n    uint256[] memory _defaultProportion,\\n    uint256[] memory _uTokensProportion\\n  ) external;\\n\\n  function updateuTokAndProp(\\n    address[] memory _uTokens\\n  ) external;\\n\\n  function underlyingTokensStaking(address[] memory _depositTokens) external returns(uint256 _totalProp);\\n\\n  function depositUserNav(address user) external view returns (uint256);\\n\\n  function setUnstakeData(uint256 totalQueuedShares) external returns (address[] memory, address[] memory, uint256, uint256);\\n\\n  function isOTokenWhitelisted(address oToken) external view returns (bool);\\n\\n  function validateWithdraw(address user, address oToken, uint256 _shares) external;\\n\\n function updateLockedTokens(\\n    address user,\\n    uint256 amount,\\n    bool lock,\\n    bool queue,\\n    bool unqueue,\\n    uint256 newNAV\\n  ) external;\\n\\n  function checkTVL(bool _updateTVL) external;\\n\\n  function updateInputTokens(address[] memory _inputTokens) external;\\n  \\n  function reinitializeHappened(bool status) external;\\n\\n  function getPreSwapDepositLimit() external view returns(uint256);\\n\\n  function pauseUnpauseDeposit(bool status) external;\\n}\"},\"IAFiStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IAFiStorage.\\n * @notice Interface of the AFiStorage.\\n */\\n\\ninterface IIEarnManager {\\n  function recommend(\\n    address _token,\\n    address afiBase,\\n    address afiStorage\\n  ) external view returns (string memory choice, uint capr, uint aapr, uint dapr);\\n}\\n\\ninterface IAFiStorage {\\n  /**\\n   * @notice Struct representing investor details.\\n   * @param isPresent Boolean indicating whether an investor exists.\\n   * @param uTokenBalance Investor underlying token balance.\\n   * @param investedAmount Amount of StableCoin invested in the underlying token\\n   */\\n  struct Investor {\\n    bool isPresent;\\n    uint depositNAV;\\n    uint redemptionNAV;\\n  }\\n\\n  struct RedemptionParams {\\n        address baseContract;\\n        uint r;\\n        address oToken;\\n        uint256 cSwapCounter;\\n        address[] uTokens;\\n        address[] iTokens;\\n        uint256 deadline;\\n        uint256[] minimumReturnAmount;\\n        uint256 _pool;\\n        uint256 tSupply;\\n        uint256 depositNAV;\\n    }\\n\\n  /**\\n   * @notice Struct representing TeamWallet details.\\n   * @param isPresent Boolean indicating whether a wallet exists.\\n   * @param isActive Boolean indicating whether a wallet is active.\\n   * @param walletAddress Wallet address.\\n   */\\n  struct TeamWallet {\\n    bool isPresent;\\n    bool isActive;\\n    address walletAddress;\\n  }\\n\\n  /**\\n   * @notice Struct representing Rebalance details.\\n   * @param scenario Scenario can be either of 0, 1 or 2.\\n   * @param rebalancedUToken Address of the underlying token that is rebalanced.\\n   * @param rebalancedToUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   */\\n  struct RebalanceDetails {\\n    uint8 scenario;\\n    address rebalancedUToken;\\n    address[] rebalancedToUTokens;\\n  }\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletActive(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletAdd(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @notice Returns the team wallet details.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address\\n   * @return isPresent Boolean indicating the present status of the wallet.\\n   * @return isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   */\\n  function getTeamWalletDetails(\\n    address aFiContract,\\n    address _wallet\\n  ) external view returns (bool isPresent, bool isActive);\\n\\n\\n\\n   function handleRedemption(RedemptionParams memory params, uint _shares, uint swapMethod) external  returns (uint256 redemptionFromContract);\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address that has to be added in the `teamWallets` array.\\n   * @param isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @param isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function addTeamWallet(\\n    address aFiContract,\\n    address _wallet,\\n    bool isActive,\\n    bool isPresent\\n  ) external;\\n\\n  /**\\n   * @notice Returns the team wallets for an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _teamWallets Array of teamWallets.\\n   */\\n  function getTeamWalletsOfAFi(\\n    address aFiContract\\n  ) external view returns (address[] memory _teamWallets);\\n\\n  /**\\n   * @notice Sets the address for team wallets.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _teamWallets Array of addresses for the team wallets.\\n   */\\n  function setTeamWallets(address aFiContract, address[] memory _teamWallets) external;\\n\\n  /**\\n   * @notice Sets the status for the AFi in the storage contract.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param active status for afiContracts.\\n   */\\n  function setAFiActive(address aFiContract, bool active) external;\\n\\n  /**\\n   * @notice Sets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param status indicating active rebalance status of the AFi contract.\\n   */\\n  function setActiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  /**\\n   * @notice gets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _isActiveRebalanced bool indicating active rebalance status of the AFi contract.\\n   */\\n  function isAFiActiveRebalanced(\\n    address aFiContract\\n  ) external view returns (bool _isActiveRebalanced);\\n\\n  function getTotalActiveWallets(address aFiContract) external view returns (uint);\\n\\n  function calcPoolValue(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint);\\n\\n  function calculateBalanceOfUnderlying(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint);\\n\\n  function calculatePoolInUsd(address afiContract) external view returns (uint);\\n\\n  function afiSync(\\n    address afiContract,\\n    address tok,\\n    address aaveTok,\\n    address compV3Comet,\\n    address compTok\\n  ) external;\\n\\n  function getPriceInUSDC(\\n    address tok\\n  ) external view returns (uint256, uint256);\\n\\n  function validateAndGetDecimals(address tok) external view returns (uint256);\\n\\n  function getStakedStatus(\\n    address aFiContract,\\n    address uToken\\n  ) external view returns (bool);\\n\\n  function rearrange(address aFiContract,address[] memory underlyingTokens, uint256[] memory newProviders) external;\\n\\n  function swapForOtherProduct(\\n    address afiContract,\\n    uint r,\\n    address oToken,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount,\\n    address[] memory uToken\\n  ) external returns (uint256);\\n\\n  function _withdrawAll(address afiContract, address tok) external returns(bool);\\n  function getAFiOracle() external view returns(address);\\n\\n  function calculateRedemptionFromContract(\\n    address afiContract,\\n    address tok,\\n    uint256 r\\n  ) external view returns (uint256, bool, uint256, uint256, uint256);\\n\\n\\n\\n  function tvlRead(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint, uint256);\\n\\n  function getPreSwapDepositsTokens(\\n    address aFiContract,\\n    uint256 _cSwapCounter,\\n    address stableToken\\n  ) external view returns (uint256);\\n\\n  function setPreDepositedInputToken(uint256 _cSwapCounter, uint256 _amount,address _oToken) external;\\n  function setPreDepositedInputTokenInRebalance(\\n    address aficontract,\\n    uint256 _cSwapCounter,\\n    uint256 _amount,\\n    address _oToken\\n  ) external;\\n\\n  function convertInUSDAndTok(\\n    address tok,\\n    uint256 amt,\\n    bool usd\\n  ) external view returns (uint256);\\n\\n  function calculateShares(\\n    address afiContract,\\n    uint256 amount,\\n    uint256 prevPool,\\n    uint256 _totalSupply,\\n    address iToken,\\n    uint256 currentDepositNAV,\\n    uint256 prevBalance\\n  ) external view returns (uint256 shares, uint256 newDepositNAV);\\n\\n  function deletePreDepositedInputToken(\\n    address aFiContract,\\n    address oToken,\\n    uint256 currentCounter\\n  )external;\\n\\n  function doSwapForThewhiteListRemoval(\\n    address tok,\\n    uint256 _cSwapCounter,\\n    address swapToken,\\n    uint256 deadline,\\n    uint256 minAmountOut\\n  ) external;\\n\\n  function isSwapMethodPaused(address afiContract,uint swapMethod) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\"},\"IERC20Extended.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Extended is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\"},\"IPassiveRebal.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.0;\\n\\ninterface IPassiveRebal {\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    address _aFiStorage,\\n    address[] memory _tokens,\\n    uint256 strategy\\n  ) external returns (uint[] memory proportions, uint256 totalProp);\\n\\n  function getPauseStatus() external returns (bool);\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n\\n  function uniswapV3Oracle(\\n    address afiContract,\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint _amountIn,\\n    uint _maxTime,\\n    address middleToken,\\n    uint256 minimumReturnAmount\\n  ) external returns (bytes memory swapParams);\\n  function getPool(address tok, address midTok) external view returns (address);\\n\\n  function upDateInputTokPool(address[] memory iToken, bytes memory uniData) external;\\n\\n  function getPriceOracle(address tok) external view returns (address);\\n\\n  function updateOracleData(\\n    address _uToken,\\n    address _oracleAddress\\n  ) external;\\n\\n   function removeToken(\\n    address[] memory _nonOverlappingITokens,\\n    address token\\n  ) external pure returns (address[] memory);\\n\\n  function initUniStructure(\\n    address[] memory inputTokens,\\n    bytes memory _poolData\\n  ) external;\\n}\\n\"},\"IUNISWAP.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Router {\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\"},\"IUniswapV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./IUniswapV3Factory.sol\\\";\\nimport \\\"./IAFi.sol\\\";\\n\\ninterface IUniswapOracleV3 {\\n  function PERIOD() external returns (uint256);\\n  function factory() external returns (address);\\n  function getTotalProfit() external view returns (uint256);\\n  function getDaoProfit() external view returns (uint256);\\n  function update(address _tokenIn, address _tokenOut) external;\\n\\n  function quotePrice(IAFi aFiContract,address _tokenIn, address _depositToken, uint256 _amount) external view returns (uint256 price);\\n\\n\\n  function consult(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut\\n  ) external view returns (uint256 _amountOut);\\n\\n  function estimateAmountOut(\\n    address tokenIn,\\n    uint128 amountIn,\\n    address tokenOut\\n  ) external view returns (uint amountOut);\\n\\n  function estimateAmountOutMin(\\n    address tokenIn,\\n    uint128 amountIn,\\n    address tokenOut,\\n    address pool\\n  ) external view returns (uint amountOut);\\n\\n  function updateAndConsult(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut\\n  ) external returns (uint256 _amountOut);\\n\\n  function checkUnderlyingPool(address token) external view returns (bool hasPool);\\n  function getStalePriceDelay(address aFiContract, address uToken) external view returns(uint256);\\n  function getPriceAndDecimals(address aFiContract, address uToken, address feed) external view returns(int256 , uint8 );\\n  function getPriceInUSDC(address tok) external view returns (uint256, uint256);\\n  function getMidToken(address tok) external view returns (address);\\n  function updateMidToken(address[] memory tok, address[] memory midTok) external;\\n  function setRedeemData(address _oToken, uint256 _batchWithdrawCounter, uint256 _totalShares, uint256 _oTokenUnits) external;\\n  function getControllers(address afiContract) external view returns(address, address);\\n  function cumulativeSwap(\\n    IAFi.SwapParameters memory params\\n  ) external;\\n}\\n\"},\"IUniswapV3Factory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n  /// @notice Emitted when the owner of the factory is changed\\n  /// @param oldOwner The owner before the owner was changed\\n  /// @param newOwner The owner after the owner was changed\\n  event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n  /// @notice Emitted when a pool is created\\n  /// @param token0 The first token of the pool by address sort order\\n  /// @param token1 The second token of the pool by address sort order\\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n  /// @param tickSpacing The minimum number of ticks between initialized ticks\\n  /// @param pool The address of the created pool\\n  event PoolCreated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint24 indexed fee,\\n    int24 tickSpacing,\\n    address pool\\n  );\\n\\n  /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n  /// @param fee The enabled fee, denominated in hundredths of a bip\\n  /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n  event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n  /// @notice Returns the current owner of the factory\\n  /// @dev Can be changed by the current owner via setOwner\\n  /// @return The address of the factory owner\\n  function owner() external view returns (address);\\n\\n  /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n  /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n  /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n  /// @return The tick spacing\\n  function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n  /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n  /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n  /// @param tokenA The contract address of either token0 or token1\\n  /// @param tokenB The contract address of the other token\\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n  /// @return pool The pool address\\n  function getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee\\n  ) external view returns (address pool);\\n\\n  /// @notice Creates a pool for the given two tokens and fee\\n  /// @param tokenA One of the two tokens in the desired pool\\n  /// @param tokenB The other of the two tokens in the desired pool\\n  /// @param fee The desired fee for the pool\\n  /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n  /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n  /// are invalid.\\n  /// @return pool The address of the newly created pool\\n  function createPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee\\n  ) external returns (address pool);\\n\\n  /// @notice Updates the owner of the factory\\n  /// @dev Must be called by the current owner\\n  /// @param _owner The new owner of the factory\\n  function setOwner(address _owner) external;\\n\\n  /// @notice Enables a fee amount with the given tickSpacing\\n  /// @dev Fee amounts may never be removed once enabled\\n  /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n  /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n  function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\\ninterface IUniswapV3Pool {\\n  function observe(\\n    uint32[] calldata secondsAgos\\n  ) external\\n    view\\n    returns (\\n      int56[] memory tickCumulatives,\\n      uint160[] memory secondsPerLiquidityCumulativeX128s\\n    );\\n\\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n  function fee() external returns(uint24);\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address internal _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    // /**\\n    //  * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n    //  * Can only be called by the current owner.\\n    //  */\\n    // function transferOwnership(address newOwner) public virtual override onlyOwner {\\n    //     _pendingOwner = newOwner;\\n    //     emit OwnershipTransferStarted(owner(), newOwner);\\n    // }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\"},\"OwnableDelayModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\ncontract OwnableDelayModule is Ownable2Step {\\n  address internal delayModule;\\n\\n  constructor() {\\n    delayModule = msg.sender;\\n  }\\n\\n  function isDelayModule() internal view {\\n    require(msg.sender == delayModule, \\\"NA\\\");\\n  }\\n\\n  function setDelayModule(address _delayModule) external {\\n    isDelayModule();\\n    require(_delayModule != address(0), \\\"ODZ\\\");\\n    delayModule = _delayModule;\\n  }\\n\\n  function getDelayModule() external view returns (address) {\\n    return delayModule;\\n  }\\n\\n  /**\\n   * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public override {\\n    isDelayModule();\\n    _pendingOwner = newOwner;\\n    emit OwnershipTransferStarted(owner(), newOwner);\\n  }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"},\"SafeERC20.sol\":{\"content\":\"    // SPDX-License-Identifier: MIT\\n    // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\n    pragma solidity ^0.8.0;\\n\\n    import \\\"./IERC20.sol\\\";\\n    import \\\"./draft-IERC20Permit.sol\\\";\\n    import \\\"./Address.sol\\\";\\n\\n    /**\\n    * @title SafeERC20\\n    * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n    * contract returns false). Tokens that return no value (and instead revert or\\n    * throw on failure) are also supported, non-reverting calls are assumed to be\\n    * successful.\\n    * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n    * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n    */\\n    library SafeERC20 {\\n        using Address for address;\\n\\n        function safeTransfer(\\n            IERC20 token,\\n            address to,\\n            uint256 value\\n        ) internal {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n        }\\n\\n        function safeTransferFrom(\\n            IERC20 token,\\n            address from,\\n            address to,\\n            uint256 value\\n        ) internal {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n        }\\n\\n        /**\\n        * @dev Deprecated. This function has issues similar to the ones found in\\n        * {IERC20-approve}, and its usage is discouraged.\\n        *\\n        * Whenever possible, use {safeIncreaseAllowance} and\\n        * {safeDecreaseAllowance} instead.\\n        */\\n        function safeApprove(\\n            IERC20 token,\\n            address spender,\\n            uint256 value\\n        ) internal {\\n            // safeApprove should only be called when setting an initial allowance,\\n            // or when resetting it to zero. To increase and decrease it, use\\n            // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n            require(\\n                (value == 0) || (token.allowance(address(this), spender) == 0),\\n                \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n            );\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n        }\\n\\n        function safeIncreaseAllowance(\\n            IERC20 token,\\n            address spender,\\n            uint256 value\\n        ) internal {\\n            uint256 newAllowance = token.allowance(address(this), spender) + value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n\\n        function safeDecreaseAllowance(\\n            IERC20 token,\\n            address spender,\\n            uint256 value\\n        ) internal {\\n            unchecked {\\n                uint256 oldAllowance = token.allowance(address(this), spender);\\n                require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n                uint256 newAllowance = oldAllowance - value;\\n                _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n            }\\n        }\\n\\n        function safePermit(\\n            IERC20Permit token,\\n            address owner,\\n            address spender,\\n            uint256 value,\\n            uint256 deadline,\\n            uint8 v,\\n            bytes32 r,\\n            bytes32 s\\n        ) internal {\\n            uint256 nonceBefore = token.nonces(owner);\\n            token.permit(owner, spender, value, deadline, v, r, s);\\n            uint256 nonceAfter = token.nonces(owner);\\n            require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n        }\\n\\n        /**\\n        * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n        * on the return value: the return value is optional (but if data is returned, it must not be false).\\n        * @param token The token targeted by the call.\\n        * @param data The call data (encoded using abi.encode or one of its variants).\\n        */\\n        function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n            // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n            // we\\u0027re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n            // the target address contains contract code and also asserts for success in the low-level call.\\n\\n            bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n            if (returndata.length \\u003e 0) {\\n                // Return data is optional\\n                require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n            }\\n        }\\n    }\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\n    }\\n}\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IAFi\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AFiManagerSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"AddTeamWalletInAFi\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IAFi\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_scenario\",\"type\":\"uint8\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newUnderlyingTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stableCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managerFee\",\"type\":\"uint256\"}],\"name\":\"RebalanceUnderlyingTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetActiveRebalStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"uTokenProportions\",\"type\":\"uint256[]\"}],\"name\":\"UTokenProportionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"WithdrawFromPool\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addTeamWalletInAFi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uTokenToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"defProp\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"depositTok\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableamountOut\",\"type\":\"uint256\"}],\"name\":\"algoRebalance2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uTokenToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"defProp\",\"type\":\"uint256[]\"}],\"name\":\"emergencyRebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelayModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aFiStorage\",\"type\":\"address\"}],\"name\":\"getUTokenProportion\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"underlyingTokenProportions\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalProp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"}],\"name\":\"inputTokenUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPreDepositInUSD\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isQueueWithdrawUnstakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"pauseQueueWithdrawUnstaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"uniData\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"uTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"oracles\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"defaultProp\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"currentProp\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"depositTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"iMinimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"underlyingTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newProviders\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"cometToClaim\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"cometRewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardTokenMinReturnAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IAFi.SwapParameters\",\"name\":\"csParams\",\"type\":\"tuple\"}],\"name\":\"reInitializeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalFeeUpperLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Extended\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newUToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uTokenToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"scenario\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"uTokensAfterS1\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"uTokenProportions\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"defaultProportion\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"uTokenToRemoveIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct AFiManager.RebalanceData\",\"name\":\"rebalData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"stableAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebalFeeToDeduct\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"underlyingData\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"newUnderlyingOracle\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"prevUnderlying\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"stableCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"managerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumUnderlyingAmount\",\"type\":\"uint256[]\"}],\"internalType\":\"struct AFiManager.AlgoRebalanceData\",\"name\":\"rebalanceData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"depositTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"iMinimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"underlyingTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newProviders\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"cometToClaim\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"cometRewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardTokenMinReturnAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IAFi.SwapParameters\",\"name\":\"csParams\",\"type\":\"tuple\"}],\"name\":\"rebalanceUnderlyingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setActiveRebalStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delayModule\",\"type\":\"address\"}],\"name\":\"setDelayModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rebalfee\",\"type\":\"uint256\"}],\"name\":\"setRebalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rebalFeeUpperLimit\",\"type\":\"uint256\"}],\"name\":\"setRebalFeeUpperLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rebalanceController\",\"type\":\"address\"}],\"name\":\"setRebalanceController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_afiOracle\",\"type\":\"address\"}],\"name\":\"setafiOracleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_preDepositsStablesInUSD\",\"type\":\"uint256\"}],\"name\":\"updateStableUnitsInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFiStorage\",\"name\":\"_afiStorage\",\"type\":\"address\"},{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyinToken\",\"type\":\"address\"}],\"name\":\"withdrawFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AFiManager", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "180", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0cfc36e18152d06e7d5db98b26c57334e118c11e7561008f9350e9c2b334b09d"}