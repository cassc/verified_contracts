{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/TLUniversalDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\nimport {Clones} from \\\"openzeppelin/proxy/Clones.sol\\\";\\n\\n/// @title TLUniversalDeployer.sol\\n/// @notice Transient Labs universal deployer - a contract factory allowing for easy deployment of TL contracts\\n/// @dev This contract uses deterministic contract deployments (CREATE2)\\n/// @author transientlabs.xyz\\n/// @custom:version 1.0.0\\ncontract TLUniversalDeployer is Ownable {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Custom Types\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Struct defining a contract version that is deployable\\n    /// @param id A human readable string showing the version identifier\\n    /// @param address The implementation address\\n    struct ContractVersion {\\n        string id;\\n        address implementation;\\n    }\\n\\n    /// @dev Struct defining a contract that is deployable\\n    /// @param created A boolean spcifying if the cloneable contract struct has been created or not\\n    /// @param cType The contract type (human readable - ex: ERC721TL)\\n    /// @param versions An array of `ContractVersion` structs that are deployable\\n    struct DeployableContract {\\n        bool created;\\n        string cType;\\n        ContractVersion[] versions;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                State Variables\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    string public constant VERSION = \\\"1.0.0\\\";\\n    mapping(bytes32 => DeployableContract) private _deployableContracts; // keccak256(name) -> DeployableContract\\n    bytes32[] private _deployableContractKeys;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    Events\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Event emitted whenever a contract is deployed\\n    /// @param sender The msg sender\\n    /// @param deployedContract The address of the deployed contract\\n    /// @param implementation The address of the implementation contract\\n    /// @param cType The type of contract deployed\\n    /// @param version The version of contract deployed\\n    event ContractDeployed(\\n        address indexed sender,\\n        address indexed deployedContract,\\n        address indexed implementation,\\n        string cType,\\n        string version\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Custom Errors\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Not a valid contract name\\n    error InvalidDeployableContract();\\n\\n    /// @dev Initialization failed\\n    error InitializationFailed();\\n\\n    /// @dev Contract already created\\n    error ContractAlreadyCreated();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Constructor\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @param initOwner The initial owner of the contract\\n    constructor(address initOwner) Ownable(initOwner) {}\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Deploy Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Function to deploy the latest version of a deployable contract\\n    /// @param contractType The contract type to deploy\\n    /// @param initializationCode The initialization code to call after contract deployment\\n    function deploy(string calldata contractType, bytes calldata initializationCode) external {\\n        // get DeployableContract\\n        bytes32 dcId = keccak256(bytes(contractType));\\n        DeployableContract memory dc = _deployableContracts[dcId];\\n\\n        // verify contract is valid\\n        if (!dc.created) revert InvalidDeployableContract();\\n\\n        // get latest version\\n        ContractVersion memory cv = dc.versions[dc.versions.length - 1];\\n\\n        // deploy\\n        _deploy(dc, cv, initializationCode);\\n    }\\n\\n    /// @notice Function to deploy the latest version of a cloneable contract\\n    /// @param contractType The contract type to deploy\\n    /// @param initializationCode The initialization code to call after contract deployment\\n    /// @param versionIndex The indeex of the `ContractVersion` to deploy\\n    function deploy(string calldata contractType, bytes calldata initializationCode, uint256 versionIndex) external {\\n        // get DeployableContract\\n        bytes32 dcId = keccak256(bytes(contractType));\\n        DeployableContract memory dc = _deployableContracts[dcId];\\n\\n        // verify cloneable contract is valid\\n        if (!dc.created) revert InvalidDeployableContract();\\n        if (versionIndex >= dc.versions.length) revert InvalidDeployableContract();\\n\\n        // get latest version\\n        ContractVersion memory cv = dc.versions[versionIndex];\\n\\n        // deploy\\n        _deploy(dc, cv, initializationCode);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Admin Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Function to add a contract type and/or version\\n    /// @dev Restricted to only owner\\n    /// @param contractType The contract type to save this under\\n    /// @param version The version to push to the DeployableContract struct\\n    function addDeployableContract(string calldata contractType, ContractVersion calldata version) external onlyOwner {\\n        // get DeployableContract\\n        bytes32 dcId = keccak256(bytes(contractType));\\n        DeployableContract storage dc = _deployableContracts[dcId];\\n\\n        // if the contract type has not been created, create. e\\n        // else, skip and just push version.\\n        if (!dc.created) {\\n            dc.created = true;\\n            dc.cType = contractType;\\n            _deployableContractKeys.push(dcId);\\n        }\\n\\n        // push version\\n        dc.versions.push(version);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Public Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Function to get contracts that can be deployed\\n    function getDeployableContracts() external view returns (string[] memory) {\\n        string[] memory dcs = new string[](_deployableContractKeys.length);\\n        for (uint256 i = 0; i < _deployableContractKeys.length; i++) {\\n            dcs[i] = _deployableContracts[_deployableContractKeys[i]].cType;\\n        }\\n\\n        return dcs;\\n    }\\n\\n    /// @notice Function to get a specific contract type\\n    /// @dev Does not revert for a `contractType` that doesn't exist\\n    /// @param contractType The contract type to look up\\n    function getDeployableContract(string calldata contractType) external view returns (DeployableContract memory) {\\n        bytes32 dcId = keccak256(bytes(contractType));\\n        DeployableContract memory dc = _deployableContracts[dcId];\\n\\n        return dc;\\n    }\\n\\n    /// @notice Function to predict the address at which a contract would be deployed\\n    /// @dev Predicts for the latest implementation\\n    /// @param sender The sender of the contract deployment transaction\\n    /// @param contractType The contract type to deploy\\n    /// @param initializationCode The initialization code to call after contract deployment\\n    function predictDeployedContractAddress(\\n        address sender,\\n        string calldata contractType,\\n        bytes calldata initializationCode\\n    ) external view returns (address) {\\n        // get DeployableContract\\n        bytes32 dcId = keccak256(bytes(contractType));\\n        DeployableContract memory dc = _deployableContracts[dcId];\\n\\n        // verify contract is valid\\n        if (!dc.created) revert InvalidDeployableContract();\\n\\n        // get latest version\\n        ContractVersion memory cv = dc.versions[dc.versions.length - 1];\\n\\n        // create salt by hashing the sender and init code\\n        bytes32 salt = keccak256(abi.encodePacked(sender, initializationCode));\\n\\n        // predict\\n        return Clones.predictDeterministicAddress(cv.implementation, salt);\\n    }\\n\\n    /// @notice Function to predict the address at which a contract would be deployed\\n    /// @dev Predicts for a specific implementation\\n    /// @param sender The sender of the contract deployment transaction\\n    /// @param contractType The contract type to deploy\\n    /// @param initializationCode The initialization code to call after contract deployment\\n    /// @param versionIndex The indeex of the `ContractVersion` to deploy\\n    function predictDeployedContractAddress(\\n        address sender,\\n        string calldata contractType,\\n        bytes calldata initializationCode,\\n        uint256 versionIndex\\n    ) external view returns (address) {\\n        // get DeployableContract\\n        bytes32 dcId = keccak256(bytes(contractType));\\n        DeployableContract memory dc = _deployableContracts[dcId];\\n\\n        // verify contract is valid\\n        if (!dc.created) revert InvalidDeployableContract();\\n        if (versionIndex >= dc.versions.length) revert InvalidDeployableContract();\\n\\n        // get latest version\\n        ContractVersion memory cv = dc.versions[versionIndex];\\n\\n        // create salt by hashing the sender and init code\\n        bytes32 salt = keccak256(abi.encodePacked(sender, initializationCode));\\n\\n        // predict\\n        return Clones.predictDeterministicAddress(cv.implementation, salt);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                Private Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Private function to deploy contracts\\n    function _deploy(DeployableContract memory dc, ContractVersion memory cv, bytes memory initializationCode)\\n        private\\n    {\\n        // create salt by hashing the sender and init code\\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, initializationCode));\\n\\n        // clone\\n        address deployedContract = Clones.cloneDeterministic(cv.implementation, salt);\\n\\n        // initialize\\n        (bool success,) = deployedContract.call(initializationCode);\\n        if (!success) revert InitializationFailed();\\n\\n        // emit event\\n        emit ContractDeployed(msg.sender, deployedContract, cv.implementation, dc.cType, cv.id);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ContractAlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDeployableContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"cType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"internalType\":\"struct TLUniversalDeployer.ContractVersion\",\"name\":\"version\",\"type\":\"tuple\"}],\"name\":\"addDeployableContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"initializationCode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"versionIndex\",\"type\":\"uint256\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"getDeployableContract\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"created\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"cType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"internalType\":\"struct TLUniversalDeployer.ContractVersion[]\",\"name\":\"versions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TLUniversalDeployer.DeployableContract\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeployableContracts\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"initializationCode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"versionIndex\",\"type\":\"uint256\"}],\"name\":\"predictDeployedContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"predictDeployedContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TLUniversalDeployer", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000077b35947d508012589a91ca4c9d168824376cc7d", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}