{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/fundraising/contracts/fundraising/initializers/cross-chain/layer-zero/LayerZeroSenderAddNetwork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/**************************************\\n\\n    security-contact:\\n    - security@angelblock.io\\n\\n    maintainers:\\n    - marcin@angelblock.io\\n    - piotr@angelblock.io\\n    - mikolaj@angelblock.io\\n    - sebastian@angelblock.io\\n\\n    contributors:\\n    - domenico@angelblock.io\\n\\n**************************************/\\n\\n// local imports\\nimport { LibCrossChainEvmConfiguration } from \\\"../../../libraries/storage/cross-chain/LibCrossChainEvmConfiguration.sol\\\";\\nimport { LibLayerZeroSender } from \\\"../../../libraries/storage/cross-chain/layer-zero/LibLayerZeroSender.sol\\\";\\n\\n/**************************************\\n\\n    Fundraising initializer for LayerZero sender\\n\\n **************************************/\\n\\n/// @dev Initializer for LayerZero Bridge that adds new supported network id\\ncontract LayerZeroSenderAddNetwork {\\n    // -----------------------------------------------------------------------\\n    //                              Structs\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Argument struct\\n    /// @param supportedLayerZeroChainId LayerZero source chain id\\n    /// @param supportedNativeChainId Native source chain id\\n    /// @param destinationFundraisingAddress Address of the fundraising on the source chain\\n    /// @param supportedFunctions // Supported functions in bytes4\\n    struct Arguments {\\n        uint16 supportedLayerZeroChainId;\\n        uint256 supportedNativeChainId;\\n        address destinationFundraisingAddress;\\n        bytes4[] supportedFunctions;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //                              Functions\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev External init function for a delegate call.\\n    /// @param _args Arguments struct\\n    function init(Arguments calldata _args) external {\\n        // set fundraising\\n        LibCrossChainEvmConfiguration.setFundraising(_args.supportedNativeChainId, _args.destinationFundraisingAddress);\\n\\n        // set network\\n        LibLayerZeroSender.setNetwork(_args.supportedNativeChainId, _args.supportedLayerZeroChainId);\\n\\n        // set supported functions\\n        for (uint i = 0; i < _args.supportedFunctions.length; i++) {\\n            LibCrossChainEvmConfiguration.setSupportedFunction(_args.supportedNativeChainId, _args.supportedFunctions[i], true);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fundraising/contracts/fundraising/libraries/storage/cross-chain/LibCrossChainEvmConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/**************************************\\n\\n    security-contact:\\n    - security@angelblock.io\\n\\n    maintainers:\\n    - marcin@angelblock.io\\n    - piotr@angelblock.io\\n    - mikolaj@angelblock.io\\n    - sebastian@angelblock.io\\n\\n    contributors:\\n    - domenico@angelblock.io\\n\\n**************************************/\\n\\n/// @notice Library containing cross-chain EVM configuration\\nlibrary LibCrossChainEvmConfiguration {\\n    // -----------------------------------------------------------------------\\n    //                              Constants\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Cross-chain EVM configuration storage pointer.\\n    bytes32 internal constant CC_EVM_CONFIG_STORAGE_POSITION = keccak256(\\\"angelblock.cc.evm.config\\\");\\n\\n    // -----------------------------------------------------------------------\\n    //                              Structs\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Cross-chain EVM configuration storage struct.\\n    /// @param fundraisings Mapping of native chain id to fundraising address on the given chain\\n    /// @param supportedFunctions Mapping of native chain id to supported 4 byte signature of function\\n    struct EvmConfigurationStorage {\\n        mapping(uint256 => address) fundraisings;\\n        mapping(uint256 => mapping(bytes4 => bool)) supportedFunctions;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //                              Diamond storage\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Function returning cross-chain evm configuration storage at storage pointer slot.\\n    /// @return ecs EvmConfigurationStorage struct instance at storage pointer position\\n    function evmConfigurationStorage() internal pure returns (EvmConfigurationStorage storage ecs) {\\n        // declare position\\n        bytes32 position = CC_EVM_CONFIG_STORAGE_POSITION;\\n\\n        // set slot to position\\n        assembly {\\n            ecs.slot := position\\n        }\\n\\n        // explicit return\\n        return ecs;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //                              Getters\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Diamond storage getter: Fundraising address.\\n    /// @param _nativeChainId ID of the chain\\n    /// @return Address of the fundraising\\n    function getFundraising(uint256 _nativeChainId) internal view returns (address) {\\n        // return\\n        return evmConfigurationStorage().fundraisings[_nativeChainId];\\n    }\\n\\n    /// @dev Diamond storage getter: Supported function.\\n    /// @param _nativeChainId ID of the chain\\n    /// @param _supportedFunctionSelector Selector of function\\n    /// @return True if function is supported\\n    function getSupportedFunction(uint256 _nativeChainId, bytes4 _supportedFunctionSelector) internal view returns (bool) {\\n        // return\\n        return evmConfigurationStorage().supportedFunctions[_nativeChainId][_supportedFunctionSelector];\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //                              Setters\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Diamond storage setter: Fundraising address.\\n    /// @param _nativeChainId ID of the chain\\n    /// @param _fundraising Address of the fundraising\\n    function setFundraising(uint256 _nativeChainId, address _fundraising) internal {\\n        // set fundraising\\n        evmConfigurationStorage().fundraisings[_nativeChainId] = _fundraising;\\n    }\\n\\n    /// @dev Diamond storage setter: Supported function.\\n    /// @param _nativeChainId ID of the chain\\n    /// @param _supportedFunctionSelector Selector of function\\n    /// @param _isSupported Boolean if function is supported\\n    function setSupportedFunction(uint256 _nativeChainId, bytes4 _supportedFunctionSelector, bool _isSupported) internal {\\n        // set supported function\\n        evmConfigurationStorage().supportedFunctions[_nativeChainId][_supportedFunctionSelector] = _isSupported;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fundraising/contracts/fundraising/libraries/storage/cross-chain/layer-zero/LibLayerZeroSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/**************************************\\n\\n    security-contact:\\n    - security@angelblock.io\\n\\n    maintainers:\\n    - marcin@angelblock.io\\n    - piotr@angelblock.io\\n    - mikolaj@angelblock.io\\n    - sebastian@angelblock.io\\n\\n    contributors:\\n    - domenico@angelblock.io\\n\\n**************************************/\\n\\n/// @notice Library containing necessary information for sending messages via LayerZero\\nlibrary LibLayerZeroSender {\\n    // -----------------------------------------------------------------------\\n    //                              Storage pointer\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Raise storage pointer.\\n    bytes32 internal constant LZ_SENDER_STORAGE_POSITION = keccak256(\\\"angelblock.cc.lz.sender\\\");\\n\\n    // -----------------------------------------------------------------------\\n    //                              Structs\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev LayerZero sender struct.\\n    /// @param refundAddress Refund address\\n    /// @param networks Mapping of native network id to LZ network id for supported networks\\n    struct LayerZeroSenderStorage {\\n        address refundAddress;\\n        mapping(uint256 => uint16) networks;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //                              Storage\\n    // -----------------------------------------------------------------------\\n\\n    // diamond storage getter\\n    function lzSenderStorage() internal pure returns (LayerZeroSenderStorage storage lzs) {\\n        // declare position\\n        bytes32 position = LZ_SENDER_STORAGE_POSITION;\\n\\n        // set slot to position\\n        assembly {\\n            lzs.slot := position\\n        }\\n\\n        // explicit return\\n        return lzs;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //                              Getters / setters\\n    // -----------------------------------------------------------------------\\n\\n    /// @dev Diamond storage getter: refund address.\\n    /// @return Refund address\\n    function getRefundAddress() internal view returns (address) {\\n        // return\\n        return lzSenderStorage().refundAddress;\\n    }\\n\\n    /// @dev Diamond storage getter: network.\\n    /// @param _nativeChainId Native chain id for given network\\n    /// @return LayerZero network id\\n    function getNetwork(uint256 _nativeChainId) internal view returns (uint16) {\\n        // return\\n        return lzSenderStorage().networks[_nativeChainId];\\n    }\\n\\n    /// @dev Diamond storage setter: refund address.\\n    /// @param _refundAddress New refund address for LayerZero calls\\n    function setRefundAddress(address _refundAddress) internal {\\n        lzSenderStorage().refundAddress = _refundAddress;\\n    }\\n\\n    /// @dev Diamond storage setter: network.\\n    /// @param _nativeChainId Native chain id\\n    /// @param _layerZeroChainId Network chain id in LayerZero format\\n    function setNetwork(uint256 _nativeChainId, uint16 _layerZeroChainId) internal {\\n        lzSenderStorage().networks[_nativeChainId] = _layerZeroChainId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=src/fundraising/node_modules/@openzeppelin/\",\r\n      \"ds-test/=src/fundraising/node_modules/ds-test/src/\",\r\n      \"forge-std/=src/fundraising/node_modules/forge-std/src/\",\r\n      \"layer-zero/=src/fundraising/node_modules/layer-zero/\",\r\n      \"murky/=src/fundraising/node_modules/murky/\",\r\n      \"stringutils/=node_modules/stringutils/src/\",\r\n      \"permit2/=node_modules/permit2/src/\",\r\n      \"base58-solidity/=src/fundraising/node_modules/base58-solidity/\",\r\n      \"ethereum-xcm-v3/=src/fundraising/node_modules/ethereum-xcm-v3/\",\r\n      \"hardhat/=src/fundraising/node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=src/fundraising/node_modules/murky/lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"supportedLayerZeroChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"supportedNativeChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destinationFundraisingAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"supportedFunctions\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct LayerZeroSenderAddNetwork.Arguments\",\"name\":\"_args\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LayerZeroSenderAddNetwork", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}