{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/potted_renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\nimport \\\"base64-sol/base64.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\n\\r\\nimport \\\"./potted_types.sol\\\";\\r\\n\\r\\ninterface PPdata {\\r\\n    function getAllPotted() external view returns (PottedTypes.Potted[] memory);\\r\\n    function getAllBranch() external view returns (PottedTypes.Branch[] memory);\\r\\n    function getAllBlossom() external view returns (PottedTypes.Blossom[] memory);\\r\\n    function getAllBg() external view returns (PottedTypes.Bg[] memory);\\r\\n    function getPottedImages() external view returns (bytes[] memory);\\r\\n    function getBranchImages() external view returns (bytes[] memory);\\r\\n    function getBlossomImages() external view returns (bytes[] memory);\\r\\n    function getBgImages() external view returns (bytes[] memory);\\r\\n    function getUnreveal() external view returns (bytes[] memory);\\r\\n}\\r\\n\\r\\ncontract PPRenderer is Ownable {\\r\\n    address public coreContract;\\r\\n    PPdata public ppData = PPdata(0xEA5fdE024930A9ac6DAD8AB8e7FA2B17512754e1);\\r\\n    uint[] pottedCoverage = [0,1,2,3,4,5,6,7,9,10,11,13,14,15,17,19,21,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21];\\r\\n    uint[] branchCoverage = [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,20,21,22,23,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23];\\r\\n    uint[] blossomCoverage = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24];\\r\\n    uint[] bgCoverage = [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,4,4];\\r\\n    uint constant cW = 64;\\r\\n    uint constant cH = 96;\\r\\n\\r\\n    modifier onlyCore {\\r\\n        require(msg.sender == coreContract);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function drawPotted(PottedTypes.MyPotted memory myPotted) private view returns (string memory) {\\r\\n      bytes[] memory imageData = ppData.getPottedImages();\\r\\n      return string(abi.encodePacked(\\r\\n        '<image x=\\\"',Strings.toString(myPotted.potted.x),'\\\" y=\\\"',Strings.toString(myPotted.potted.y),'\\\" width=\\\"',Strings.toString(myPotted.potted.width),'\\\" height=\\\"',Strings.toString(myPotted.potted.height),'\\\" image-rendering=\\\"pixelated\\\" xlink:href=\\\"data:image/png;base64,',Base64.encode(bytes(imageData[myPotted.potted.id])),'\\\"/>'\\r\\n      ));\\r\\n    }\\r\\n\\r\\n    function drawBranch(PottedTypes.MyPotted memory myPotted) private view returns (string memory) {\\r\\n      bytes[] memory imageData = ppData.getBranchImages();\\r\\n      return string(abi.encodePacked(\\r\\n        '<image x=\\\"',Strings.toString(myPotted.branch.x),'\\\" y=\\\"',Strings.toString(myPotted.branch.y),'\\\" width=\\\"',Strings.toString(myPotted.branch.width),'\\\" height=\\\"',Strings.toString(myPotted.branch.height),'\\\" image-rendering=\\\"pixelated\\\" xlink:href=\\\"data:image/png;base64,',Base64.encode(bytes(imageData[myPotted.branch.id])),'\\\"/>'\\r\\n      ));\\r\\n    }\\r\\n\\r\\n    function drawBlossom(PottedTypes.MyPotted memory myPotted, PottedTypes.Gene memory gene) private view returns (string memory) {\\r\\n      uint blossomCount = (gene.dna + gene.revealNum - 1) % myPotted.branch.pointX.length;\\r\\n      uint nonce;\\r\\n\\r\\n      string memory bloosomSvgString = '';\\r\\n      for (uint i = 0; i < blossomCount; i++) {\\r\\n        uint randomBlossom = (gene.dna + gene.revealNum + i + 1) % myPotted.blossom.childs.length;\\r\\n\\r\\n        uint randomPos = uint(keccak256(abi.encodePacked(gene.dna + gene.revealNum, nonce))) % blossomCount;\\r\\n        nonce++;\\r\\n\\r\\n        bloosomSvgString = string(abi.encodePacked(\\r\\n          bloosomSvgString,\\r\\n          '<image x=\\\"',Strings.toString(myPotted.branch.pointX[randomPos] - (myPotted.blossom.width[randomBlossom] / 2)),'\\\" y=\\\"',Strings.toString(myPotted.branch.pointY[randomPos] - (myPotted.blossom.height[randomBlossom] / 2)),'\\\" width=\\\"',Strings.toString(myPotted.blossom.width[randomBlossom]),'\\\" height=\\\"',Strings.toString(myPotted.blossom.height[randomBlossom]),'\\\" image-rendering=\\\"pixelated\\\" xlink:href=\\\"data:image/png;base64,',Base64.encode(bytes(ppData.getBlossomImages()[myPotted.blossom.childs[randomBlossom]])),'\\\"/>'\\r\\n        ));\\r\\n      }\\r\\n\\r\\n      return bloosomSvgString;\\r\\n    }\\r\\n\\r\\n    function drawBg(PottedTypes.MyPotted memory myPotted) private view returns (string memory) {\\r\\n      bytes[] memory imageData = ppData.getBgImages();\\r\\n      return string(abi.encodePacked(\\r\\n        '<image x=\\\"0\\\" y=\\\"0\\\" width=\\\"',Strings.toString(cW),'\\\" height=\\\"',Strings.toString(cH),'\\\" image-rendering=\\\"pixelated\\\" xlink:href=\\\"data:image/png;base64,',Base64.encode(bytes(imageData[myPotted.bg.id])),'\\\"/>'\\r\\n      ));\\r\\n    }\\r\\n\\r\\n    function drawUnreveal() private view returns (string memory) {\\r\\n      bytes[] memory imageData = ppData.getUnreveal();\\r\\n      return string(abi.encodePacked(\\r\\n        '<image x=\\\"0\\\" y=\\\"0\\\" width=\\\"',Strings.toString(cW),'\\\" height=\\\"',Strings.toString(cH),'\\\" image-rendering=\\\"pixelated\\\" xlink:href=\\\"data:image/gif;base64,',Base64.encode(bytes(imageData[0])),'\\\"/>'\\r\\n      ));      \\r\\n    }\\r\\n\\r\\n    function drawUnrevealPP(PottedTypes.Gene memory gene) external onlyCore view returns (string memory)  {\\r\\n      PottedTypes.MyPotted memory myPotted = getPP(gene);\\r\\n        return string(abi.encodePacked(\\r\\n          '<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 ',Strings.toString(cW),' ',Strings.toString(cH),'\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\r\\n          drawBg(myPotted),\\r\\n          drawPotted(myPotted),\\r\\n          drawUnreveal(),\\r\\n          \\\"</svg>\\\"\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    function drawRevealPP(PottedTypes.Gene memory gene) external onlyCore view returns (string memory) {\\r\\n      PottedTypes.MyPotted memory myPotted = getPP(gene);\\r\\n        return string(abi.encodePacked(\\r\\n          '<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 ',Strings.toString(cW),' ',Strings.toString(cH),'\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\r\\n          drawBg(myPotted),\\r\\n          drawPotted(myPotted),\\r\\n          drawBranch(myPotted),\\r\\n          drawBlossom(myPotted, gene),\\r\\n          \\\"</svg>\\\"\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    function drawNoBgPP(PottedTypes.Gene memory gene, uint resulotion) external onlyCore view returns (string memory) {\\r\\n      PottedTypes.MyPotted memory myPotted = getPP(gene);\\r\\n        return string(abi.encodePacked(\\r\\n          '<svg width=\\\"',Strings.toString(cW * resulotion),'\\\" height=\\\"',Strings.toString(cH * resulotion),'\\\" viewBox=\\\"0 0 ',Strings.toString(cW),' ',Strings.toString(cH),'\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\r\\n          drawPotted(myPotted),\\r\\n          drawBranch(myPotted),\\r\\n          drawBlossom(myPotted, gene),\\r\\n          \\\"</svg>\\\"\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    function getPP(PottedTypes.Gene memory gene) public view returns (PottedTypes.MyPotted memory) {\\r\\n      return PottedTypes.MyPotted(getPotted(gene), getBranch(gene), getBlossom(gene), getBg(gene));\\r\\n    }\\r\\n\\r\\n    function getPotted(PottedTypes.Gene memory gene) private view returns (PottedTypes.Potted memory) {\\r\\n      uint idx = (gene.dna + 1) % pottedCoverage.length;\\r\\n      return ppData.getAllPotted()[pottedCoverage[idx]];\\r\\n    }\\r\\n\\r\\n    function getBranch(PottedTypes.Gene memory gene) private view returns (PottedTypes.Branch memory) {\\r\\n      uint idx = (gene.dna + gene.revealNum + 2) % branchCoverage.length;\\r\\n      return ppData.getAllBranch()[branchCoverage[idx]];\\r\\n    }\\r\\n\\r\\n    function getBlossom(PottedTypes.Gene memory gene) private view returns (PottedTypes.Blossom memory) {\\r\\n      PottedTypes.Branch memory branch = getBranch(gene);\\r\\n\\r\\n      if (branch.unique != 0) {\\r\\n        return ppData.getAllBlossom()[branch.unique];\\r\\n      } else {\\r\\n        uint idx = (gene.dna + gene.revealNum + 3) % blossomCoverage.length;\\r\\n        return ppData.getAllBlossom()[blossomCoverage[idx]];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    function getBg(PottedTypes.Gene memory gene) private view returns (PottedTypes.Bg memory) {\\r\\n      uint idx = (gene.dna + 4) % bgCoverage.length;\\r\\n      return ppData.getAllBg()[bgCoverage[idx]];\\r\\n    }\\r\\n\\r\\n    function setDataContract(address _address) external onlyOwner {\\r\\n      ppData = PPdata(_address);\\r\\n    }\\r\\n\\r\\n    function setCoreContract(address _address) external onlyOwner {\\r\\n      coreContract = _address;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/potted_types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface PottedTypes {\\r\\n    struct Gene {\\r\\n        uint dna;\\r\\n        uint revealNum;\\r\\n        bool isReroll;\\r\\n    }\\r\\n\\r\\n    struct MyPotted {\\r\\n      Potted potted;\\r\\n      Branch branch;\\r\\n      Blossom blossom;\\r\\n      Bg bg;\\r\\n    }\\r\\n\\r\\n    struct Potted {\\r\\n      string traitName;\\r\\n      uint width;\\r\\n      uint height;\\r\\n      uint x;\\r\\n      uint y;\\r\\n      uint id;\\r\\n    }\\r\\n\\r\\n    struct Branch {\\r\\n      string traitName;\\r\\n      uint width;\\r\\n      uint height;\\r\\n      uint unique;\\r\\n      uint x;\\r\\n      uint y;\\r\\n      uint[] pointX;\\r\\n      uint[] pointY;\\r\\n      uint id;\\r\\n    }\\r\\n\\r\\n    // Each blossom max count <= branchPointX.length\\r\\n    struct Blossom {\\r\\n      string traitName;\\r\\n      uint[] width;\\r\\n      uint[] height;\\r\\n      uint[] childs;\\r\\n      uint id;\\r\\n    }\\r\\n\\r\\n    struct Bg {\\r\\n      string traitName;\\r\\n      uint id;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"coreContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReroll\",\"type\":\"bool\"}],\"internalType\":\"struct PottedTypes.Gene\",\"name\":\"gene\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"resulotion\",\"type\":\"uint256\"}],\"name\":\"drawNoBgPP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReroll\",\"type\":\"bool\"}],\"internalType\":\"struct PottedTypes.Gene\",\"name\":\"gene\",\"type\":\"tuple\"}],\"name\":\"drawRevealPP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReroll\",\"type\":\"bool\"}],\"internalType\":\"struct PottedTypes.Gene\",\"name\":\"gene\",\"type\":\"tuple\"}],\"name\":\"drawUnrevealPP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReroll\",\"type\":\"bool\"}],\"internalType\":\"struct PottedTypes.Gene\",\"name\":\"gene\",\"type\":\"tuple\"}],\"name\":\"getPP\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"traitName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct PottedTypes.Potted\",\"name\":\"potted\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"traitName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unique\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"pointX\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"pointY\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct PottedTypes.Branch\",\"name\":\"branch\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"traitName\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"width\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"height\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"childs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct PottedTypes.Blossom\",\"name\":\"blossom\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"traitName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct PottedTypes.Bg\",\"name\":\"bg\",\"type\":\"tuple\"}],\"internalType\":\"struct PottedTypes.MyPotted\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ppData\",\"outputs\":[{\"internalType\":\"contract PPdata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCoreContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setDataContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PPRenderer", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}