{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/ERC20/IERC20.sol\": {\r\n      \"content\": \"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\"\r\n    },\r\n    \"src/lib/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\n\\n/// @notice EIP712 helpers for permit2\\n/// @dev Maintains cross-chain replay protection in the event of a fork\\n/// @dev Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol\\ncontract EIP712 {\\n    // Cache the domain separator as an immutable value, but also store the chain id that it\\n    // corresponds to, in order to invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private constant _HASHED_NAME = keccak256(\\\"Permit2\\\"); // TODO: what name should we use here?\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    constructor() {\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME);\\n    }\\n\\n    /// @notice Returns the domain separator for the current chain.\\n    /// @dev Uses cached version if chainid and address are unchanged from construction.\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        return block.chainid == _CACHED_CHAIN_ID\\n            ? _CACHED_DOMAIN_SEPARATOR\\n            : _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME);\\n    }\\n\\n    /// @notice Builds a domain separator using the current chainId and contract address.\\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 nameHash) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, block.chainid, address(this)));\\n    }\\n\\n    /// @notice Creates an EIP-712 typed data hash\\n    function _hashTypedData(bytes32 dataHash) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), dataHash));\\n    }\\n}\"\r\n    },\r\n    \"src/lib/ISignatureTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SignatureTransfer\\n/// @notice Handles ERC20 token transfers through signature based actions\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface ISignatureTransfer {\\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\\n    /// @param maxAmount The maximum amount a spender can request to transfer\\n    error InvalidAmount(uint256 maxAmount);\\n\\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\\n    error LengthMismatch();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\\n\\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\\n    struct TokenPermissions {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount that can be spent\\n        uint256 amount;\\n    }\\n\\n    /// @notice The signed permit message for a single token transfer\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Specifies the recipient address and amount for batched transfers.\\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\\n    struct SignatureTransferDetails {\\n        // recipient address\\n        address to;\\n        // spender requested amount\\n        uint256 requestedAmount;\\n    }\\n\\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\\n    /// @dev It returns a uint256 bitmap\\n    /// @dev The index, or wordPosition is capped at type(uint248).max\\n    function nonceBitmap(address, uint256) external view returns (uint256);\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n\\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\\n    /// @dev The wordPos is maxed at type(uint248).max\\n    /// @param wordPos A number to index the nonceBitmap at\\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\\n}\"\r\n    },\r\n    \"src/lib/PermitHash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\nimport {ISignatureTransfer} from \\\"./ISignatureTransfer.sol\\\";\\n\\nlibrary PermitHash {\\n    bytes32 public constant _TOKEN_PERMISSIONS_TYPEHASH = keccak256(\\\"TokenPermissions(address token,uint256 amount)\\\");\\n\\n    bytes32 public constant _PERMIT_TRANSFER_FROM_TYPEHASH = keccak256(\\n        \\\"PermitTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline)TokenPermissions(address token,uint256 amount)\\\"\\n    );\\n\\n    string public constant _TOKEN_PERMISSIONS_TYPESTRING = \\\"TokenPermissions(address token,uint256 amount)\\\";\\n\\n    string public constant _PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB =\\n        \\\"PermitWitnessTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline,\\\";\\n\\n    function hash(ISignatureTransfer.PermitTransferFrom memory permit) internal view returns (bytes32) {\\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(permit.permitted);\\n        return keccak256(\\n            abi.encode(_PERMIT_TRANSFER_FROM_TYPEHASH, tokenPermissionsHash, msg.sender, permit.nonce, permit.deadline)\\n        );\\n    }\\n\\n    function hashWithWitness(\\n        ISignatureTransfer.PermitTransferFrom memory permit,\\n        bytes32 witness,\\n        string calldata witnessTypeString\\n    ) internal view returns (bytes32) {\\n        bytes32 typeHash = keccak256(abi.encodePacked(_PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB, witnessTypeString));\\n\\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(permit.permitted);\\n        return keccak256(abi.encode(typeHash, tokenPermissionsHash, msg.sender, permit.nonce, permit.deadline, witness));\\n    }\\n\\n    function _hashTokenPermissions(ISignatureTransfer.TokenPermissions memory permitted)\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_TOKEN_PERMISSIONS_TYPEHASH, permitted));\\n    }\\n}\"\r\n    },\r\n    \"src/lib/SignatureTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\nimport {ISignatureTransfer} from \\\"./ISignatureTransfer.sol\\\";\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {SignatureVerification} from \\\"./SignatureVerification.sol\\\";\\nimport {PermitHash} from \\\"./PermitHash.sol\\\";\\nimport {EIP712} from \\\"./EIP712.sol\\\";\\n\\ncontract SignatureTransfer is ISignatureTransfer, EIP712 {\\n\\n    using SignatureVerification for bytes;\\n    using PermitHash for PermitTransferFrom;\\n\\n    /// @inheritdoc ISignatureTransfer\\n    mapping(address => mapping(uint256 => uint256)) public nonceBitmap;\\n    mapping(address => mapping(uint256 => uint256)) public partialFills;\\n\\n    /// @notice Thrown when validating an inputted signature that is stale\\n    /// @param signatureDeadline The timestamp at which a signature is no longer valid\\n    error SignatureExpired(uint256 signatureDeadline);\\n\\n    /// @notice Thrown when validating that the inputted nonce has not been used\\n    error InvalidNonce();\\n\\n    error OverFilled();\\n\\n    function permitTransferFrom(PermitTransferFrom memory permit, SignatureTransferDetails calldata transferDetails, address owner, bytes calldata signature) external {\\n        _permitTransferFrom(permit, transferDetails, owner, permit.hash(), signature);\\n    }\\n\\n    /// @inheritdoc ISignatureTransfer\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external {\\n        _permitTransferFrom(permit, transferDetails, owner, permit.hashWithWitness(witness, witnessTypeString), signature);\\n    }\\n\\n    /**\\n     * Find a nonce that looks free given the data on the blockchain.\\n     * Of course, this method cannot take into account nonces of valid but unused permits.\\n     */\\n    function findFreeNonce(address owner, uint256 start) public view returns (uint256){\\n        while (!isFreeNonce(owner, start)){\\n            start++;\\n        }\\n        return start;\\n    }\\n\\n    function isFreeNonce(address owner, uint256 nonce) public view returns (bool){\\n        return !isUsedNonce(owner, nonce) && partialFills[owner][nonce] == 0;\\n    }\\n\\n    function isUsedNonce(address owner, uint256 nonce) public view returns (bool) {\\n        (uint256 wordPos, uint256 bitPos) = bitmapPositions(nonce);\\n        uint256 bit = 1 << bitPos;\\n        return nonceBitmap[owner][wordPos] & bit != 0;\\n    }\\n\\n    function getPermittedAmount(address owner, PermitTransferFrom calldata permit) public view returns (uint256) {\\n        if (isUsedNonce(owner, permit.nonce)) {\\n            return 0;\\n        } else {\\n            return permit.permitted.amount - partialFills[owner][permit.nonce];\\n        }\\n    }\\n\\n    /// @notice Transfers a token using a signed permit message.\\n    /// @param permit The permit data signed over by the owner\\n    /// @param dataHash The EIP-712 hash of permit data to include when checking signature\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function _permitTransferFrom(PermitTransferFrom memory permit, SignatureTransferDetails calldata transferDetails, address owner, bytes32 dataHash, bytes calldata signature) private {\\n        uint256 requestedAmount = transferDetails.requestedAmount;\\n\\n        if (block.timestamp > permit.deadline) revert SignatureExpired(permit.deadline);\\n\\n        _useUnorderedNonce(owner, permit.nonce, requestedAmount, permit.permitted.amount);\\n\\n        signature.verify(_hashTypedData(dataHash), owner);\\n\\n        IERC20(permit.permitted.token).transferFrom(owner, transferDetails.to, requestedAmount);\\n    }\\n\\n    /// @inheritdoc ISignatureTransfer\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external {\\n        nonceBitmap[msg.sender][wordPos] |= mask;\\n\\n        emit UnorderedNonceInvalidation(msg.sender, wordPos, mask);\\n    }\\n\\n    /// @notice Returns the index of the bitmap and the bit position within the bitmap. Used for unordered nonces\\n    /// @param nonce The nonce to get the associated word and bit positions\\n    /// @return wordPos The word position or index into the nonceBitmap\\n    /// @return bitPos The bit position\\n    /// @dev The first 248 bits of the nonce value is the index of the desired bitmap\\n    /// @dev The last 8 bits of the nonce value is the position of the bit in the bitmap\\n    function bitmapPositions(uint256 nonce) private pure returns (uint256 wordPos, uint256 bitPos) {\\n        wordPos = uint248(nonce >> 8);\\n        bitPos = uint8(nonce);\\n    }\\n\\n    /// @notice Checks whether a nonce is taken and sets the bit at the bit position in the bitmap at the word position\\n    /// @dev This function is used to manage nonces for transactions, ensuring that each nonce is used only once and tracking partial fills of orders.\\n    /// @param from The address to use the nonce at\\n    /// @param nonce The nonce to spend\\n    /// @param amount The amount being filled in the current transaction.\\n    /// @param max The maximum allowable fill amount for the nonce.\\n    function _useUnorderedNonce(address from, uint256 nonce, uint256 amount, uint256 max) internal {\\n        (uint256 wordPos, uint256 bitPos) = bitmapPositions(nonce);\\n        uint256 bit = 1 << bitPos;\\n        uint256 state = nonceBitmap[from][wordPos];\\n        if (state & bit != 0) revert InvalidNonce();\\n\\n        uint256 alreadyFilled = partialFills[from][nonce];\\n        if (alreadyFilled + amount > max) revert OverFilled();\\n        if (alreadyFilled + amount < max){\\n            partialFills[from][nonce] = alreadyFilled + amount;\\n        } else {\\n            if (alreadyFilled > 0) delete partialFills[from][nonce]; // get some gas back \\n            nonceBitmap[from][wordPos] |= bit; // flag done\\n        }\\n    }\\n}\"\r\n    },\r\n    \"src/lib/SignatureVerification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\nlibrary SignatureVerification {\\n    /// @notice Thrown when the passed in signature is not a valid length\\n    error InvalidSignatureLength();\\n\\n    /// @notice Thrown when the recovered signer is equal to the zero address\\n    error InvalidSignature();\\n\\n    /// @notice Thrown when the recovered signer does not equal the claimedSigner\\n    error InvalidSigner();\\n\\n    /// @notice Thrown when the recovered contract signature is incorrect\\n    error InvalidContractSignature();\\n\\n    bytes32 constant UPPER_BIT_MASK = (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n\\n    function verify(bytes calldata signature, bytes32 hash, address claimedSigner) internal view {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (claimedSigner.code.length == 0) {\\n            if (signature.length == 65) {\\n                (r, s) = abi.decode(signature, (bytes32, bytes32));\\n                v = uint8(signature[64]);\\n            } else if (signature.length == 64) {\\n                // EIP-2098\\n                bytes32 vs;\\n                (r, vs) = abi.decode(signature, (bytes32, bytes32));\\n                s = vs & UPPER_BIT_MASK;\\n                v = uint8(uint256(vs >> 255)) + 27;\\n            } else {\\n                revert InvalidSignatureLength();\\n            }\\n            address signer = ecrecover(hash, v, r, s);\\n            if (signer == address(0)) revert InvalidSignature();\\n            if (signer != claimedSigner) revert InvalidSigner();\\n        } else {\\n            bytes4 magicValue = IERC1271(claimedSigner).isValidSignature(hash, signature);\\n            if (magicValue != IERC1271.isValidSignature.selector) revert InvalidContractSignature();\\n        }\\n    }\\n}\\n\\ninterface IERC1271 {\\n    /// @dev Should return whether the signature provided is valid for the provided data\\n    /// @param hash      Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverFilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"signatureDeadline\",\"type\":\"uint256\"}],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"word\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"UnorderedNonceInvalidation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"findFreeNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.TokenPermissions\",\"name\":\"permitted\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"}],\"name\":\"getPermittedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wordPos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"invalidateUnorderedNonces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"isFreeNonce\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"isUsedNonce\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceBitmap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partialFills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.TokenPermissions\",\"name\":\"permitted\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.SignatureTransferDetails\",\"name\":\"transferDetails\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"permitTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.TokenPermissions\",\"name\":\"permitted\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.SignatureTransferDetails\",\"name\":\"transferDetails\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"witness\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"witnessTypeString\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"permitWitnessTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SignatureTransfer", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}