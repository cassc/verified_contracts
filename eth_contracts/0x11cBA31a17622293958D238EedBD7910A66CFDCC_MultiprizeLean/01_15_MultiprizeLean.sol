// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";

/// @title Multiprize lean contract
/// @author Luis Pando
/// @notice It consumes VRF v2 from Chainlink. It has the role
/// "operator" that is the one used by a backend app to make some calls
/// @dev It saves in an ordered array the player wallet and the current
/// entries count. So buying entries has a complexity of O(1)
/// For calculating the winners, from the huge random numbers generated by Chainlink
/// a normalized random is generated by using the module method, adding 1 to have
/// a random from 1 to entriesCount.
/// So next step is to perform a binary search on the ordered array to get the
/// winner
/// A raffle can have several prizes. So if the winner candidate has already won a prize
/// in the same raffle or is blacklisted, a new random number from the pool generated by
/// Chainlink is used to get a new winner candidate.
/// If there are no more random numbers in the pool, the algorithm will loop to the left
/// until a valid player (not a previous winner or blacklisted) is found
contract MultiprizeLean is
    AccessControl,
    ReentrancyGuard,
    VRFConsumerBaseV2,
    ConfirmedOwner
{
    ////////// CHAINLINK VRF v2 /////////////////

    VRFCoordinatorV2Interface COORDINATOR;

    // Your subscription ID.
    uint64 immutable s_subscriptionId;

    // Goerli coordinator. For other networks,
    // see https://docs.chain.link/docs/vrf-contracts/#configurations
    address immutable vrfCoordinator; // = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;

    // The gas lane to use, which specifies the maximum gas price to bump to.
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/docs/vrf-contracts/#configurations
    bytes32 immutable keyHash; // = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;

    // Depends on the number of requested values that you want sent to the
    // fulfillRandomWords() function. Storing each word costs about 20,000 gas,
    // so 100,000 is a safe default for this example contract. Test and adjust
    // this limit based on the network that you select, the size of the request,
    // and the processing of the callback request in the fulfillRandomWords()
    // function.
    uint32 callbackGasLimit = 2500000;

    // The default is 3, but you can set this higher.
    uint16 immutable requestConfirmations = 3;

    // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
    uint32 constant numWords = 20;

    address s_owner;

    uint32 constant MAX_NUM_PRIZES = 10;

    struct RequestStatus {
        bool exists; // whether a requestId exists
        uint256 id; // Metawin Id (the raffle Id)
        uint256 size; // total amount of entries. Used to normalize the random number generated
    }
    mapping(uint256 => RequestStatus) public s_requests; // map of requests sent to Chainlink

    event RequestSent(uint256 requestId, uint32 numWords);

    /////////////// END CHAINKINK VRF V2 //////////////

    error EntryNotAllowed(string errorType);

    event WinnersOfRaffle(
        uint256 indexed raffleId,
        WinnersStruct[] winnersList
    );

    event PrizePaidOutToStaker(
        uint256 indexed raffleId,
        address indexed seller,
        uint256 idPrize
    );

    // Event sent when the raffle is created by the operator
    event RaffleCreated(uint256 indexed raffleId);
    // Event sent when the owner of the nft stakes it for the raffle
    event RaffleStarted(uint256 indexed raffleId, address indexed seller);
    // Event sent when the raffle is finished (either early cashout or successful completion)
    event RaffleEnded(uint256 indexed raffleId, uint256 amountRaised);
    // Event sent a winner is calculated after doing a binary search on the entriesBought array
    event WinnerSelected(
        uint256 indexed raffleId,
        address indexed winner,
        uint256 randomNumber
    );
    // Event sent when one or more entries are sold (info from the price structure)
    event EntrySold(
        uint256 indexed raffleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId
    );
    // Event sent when a free entry is added by the operator
    event FreeEntry(
        uint256 indexed raffleId,
        address[] buyer,
        uint256 amount,
        uint256 currentSize
    );
    // Event sent when a raffle is asked to cancel by the operator
    event RaffleCancelled(uint256 indexed raffleId, uint256 amountRaised);
    // The raffle is closed successfully and the platform receives the fee
    event FeeTransferredToPlatform(
        uint256 indexed raffleId,
        uint256 amountTransferred
    );

    event EarlyCashoutTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event SetWinnerTriggered(uint256 indexed raffleId, uint256 amountRaised);
    // Emitted when an entry is cancelled
    event EntryCancelled(
        uint256 indexed raffleId,
        uint256 amountOfEntriesCanceled,
        address player
    );

    // Every raffle has a funding structure.
    struct FundingStructure {
        uint128 minimumFundsInWeis;
        uint128 desiredFundsInWeis;
    }
    mapping(uint256 => FundingStructure) public fundingList;

    struct BatchRaffleDTO {
        RaffleDTO raffleDTO;
        PriceStructure[] prices;
        PrizeStruct[] prizes;
    }

    struct RaffleDTO {
        ENTRY_TYPE entryType; // how to buy entries on the raffle. Directly, via the hamburger or both
        uint48 commissionInBasicPoints;
        uint48 maxEntriesPerUser; // maximum number of entries allowed per user, to avoid abuse
        uint48 totalEntriesCap; // Max amount of entries allowed. Some games will have only 2
        uint128 desiredFundsInWeis;
        uint128 minimumFundsInWeis;
    }

    // Main raffle data struct
    struct RaffleStruct {
        uint48 platformPercentage; // percentage of the funds raised that goes to the platform
        uint48 numOfPrizes; // amount of prizes this raffle will have
        uint48 cancellingDate; // If the raffle is cancelled, here is saved that date
    }
    // The main structure is an array of raffles
    RaffleStruct[] public raffles;
    /*  
    // Map that contains the number of entries each user has bought, to prevent abuse, and the claiming info
    struct ClaimStruct {
        uint48 numEntriesPerUser;
        bool claimed;
        uint256 amountSpentInWeis;
    }
    mapping(bytes32 => ClaimStruct) public claimsData;

    // Map with the addresses linked to a particular raffle + nft
    mapping(bytes32 => address) public requiredNFTWallets;
*/
    struct PriceStructure {
        uint256 id;
        uint48 numEntries;
        uint256 price;
    }
    mapping(uint256 => PriceStructure) public pricesList;

    struct EntryInfoStruct {
        STATUS status; // status of the raffle. Can be created, accepted, ended, etc
        ENTRY_TYPE entryType;
        uint48 entriesLength; // to easy frontend, the length of the entries array is saved here
        uint128 amountRaised; // funds raised so far in wei
    }
    // The main structure is an array of raffles
    EntryInfoStruct[] public rafflesEntryInfo;

    // All the different status a raffle can have
    enum STATUS {
        CREATED, // the operator creates the raffle
        ACCEPTED, // the seller stakes the nft for the raffle
        EARLY_CASHOUT, // the seller wants to cashout early
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // the operator sets a winner
        ENDED, // the raffle is finished, and NFT and funds were transferred
        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund
    }

    enum ENTRY_TYPE {
        ONLY_DIRECTLY,
        ONLY_EXTERNAL_CONTRACT,
        MIXED
    }

    // The operator role is operated by a backend application
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR");
    // requested by Hamburger. Role for the buy method of the hamburger (only that contract)
    bytes32 public constant MINTERCONTRACT_ROLE = keccak256("MINTERCONTRACT");

    // address of the wallet controlled by the platform that will receive the platform fee
    address payable public destinationWallet =
        payable(0x12334d915d254F1FFD3f7ea80bB5Eba5eA87Fb36);

    ///////////////// PRIZES ////////////////
    struct PrizeStruct {
        address seller;
        address collection;
        uint48 position;
        uint48 tokenId;
        uint48 id; // id of the prize in the external system
        uint128 amount;
    }
    mapping(uint256 => PrizeStruct[MAX_NUM_PRIZES]) public prizesData;

    struct WinnersStruct {
        uint256 idPrize;
        address player;
        uint256 randomNumber;
    }
    mapping(uint256 => WinnersStruct[]) public winnersList;

    ///////////////// PRIZES ////////////////
    struct EntriesBought {
        uint48 currentEntriesLength;
        address player;
    }
    mapping(uint256 => EntriesBought[]) public entriesList;

    constructor(
        uint64 subscriptionId,
        address _vrfCoordinator,
        bytes32 _keyHash
    ) VRFConsumerBaseV2(_vrfCoordinator) ConfirmedOwner(msg.sender) {
        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);
        vrfCoordinator = _vrfCoordinator;
        keyHash = _keyHash;
        s_owner = msg.sender;
        s_subscriptionId = subscriptionId;

        _setupRole(OPERATOR_ROLE, msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function callVRFAndGetRequestId() internal returns (uint256 requestId) {
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
        return requestId;
    }

    /// @dev this is the method that will be called by the smart contract to get a random number
    /// @param _id Id of the raffle
    /// @param _entriesSize length of the entries array of that raffle
    function getRandomNumber(
        uint256 _id,
        uint256 _entriesSize,
        uint256 requestId
    ) internal {
        s_requests[requestId] = RequestStatus({
            exists: true,
            id: _id,
            size: _entriesSize
        });

        emit RequestSent(requestId, numWords);
    }

    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        require(s_requests[_requestId].exists, "request not found");

        uint256 _raffleId = s_requests[_requestId].id;

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        RaffleStruct memory raffle = raffles[_raffleId];
        // Only when the raffle has been asked to be closed and the platform
        require(
            entryInfo.status == STATUS.EARLY_CASHOUT ||
                entryInfo.status == STATUS.CLOSING_REQUESTED,
            "Raffle in wrong status"
        );
        uint256 i;
        uint256 indexRandom;
        uint256 randomNumber;
        while (i < raffle.numOfPrizes) {
            PrizeStruct memory prize = prizesData[_raffleId][i];
            address winner;

            (winner, indexRandom, randomNumber) = getWinnerAddressFromRandom(
                _raffleId,
                _randomWords,
                entryInfo.entriesLength,
                indexRandom
            );

            // Modification 8.3.2023. If there are no more players available, payout the prizes to the stakers and close.
            if (winner == address(0) && indexRandom == 0 && randomNumber == 0) {
                returnRemainingPrizesToStakers(
                    i,
                    raffle.numOfPrizes,
                    _raffleId
                );
                break;
            }
            // there is a valid winner. Transfer the prize
            else {
                if (prize.collection != address(0)) {
                    IERC721 _asset = IERC721(prize.collection);
                    _asset.transferFrom(address(this), winner, prize.tokenId); // transfer the tokens to the winner
                } else if (
                    prize.collection == address(0) && prize.amount != 0
                ) {
                    (bool sentPrize, ) = winner.call{value: prize.amount}("");
                    require(sentPrize, "Failed to send Ether");
                }
            }

            ++i;
            addToWinnersList(_raffleId, prize.id, winner, randomNumber);
        }

        // All nfts and funds transferred. Close the raffle
        entryInfo.status = STATUS.ENDED;
        uint256 amountForPlatform = (entryInfo.amountRaised *
            raffle.platformPercentage) / 10000;
        uint256 amountForSeller = entryInfo.amountRaised - amountForPlatform;
        // transfer amount (75%) to the seller.
        address seller = prizesData[_raffleId][0].seller;
        (bool sent, ) = seller.call{value: amountForSeller}("");
        // transfer the amount to the platform
        (bool sent2, ) = destinationWallet.call{value: amountForPlatform}("");
        require(sent2 && sent, "Failed send Eth");

        emit RaffleEnded(_raffleId, entryInfo.amountRaised);

        emit WinnersOfRaffle(_raffleId, getWinnersData(_raffleId));
    }

    // @notice when the raffle has more prizes than players, the method that returns a winner will
    // return (address(0), 0, 0) to indicate there are no more winners available
    // At that moment X prizes of the Y available has been transferred to the winners
    // So the Y-X remaining prizes will be paid out to the stakers
    function returnRemainingPrizesToStakers(
        uint256 _currentPrizeIndex,
        uint256 _numOfPrizes,
        uint256 _raffleId
    ) internal {
        for (; _currentPrizeIndex < _numOfPrizes; ++_currentPrizeIndex) {
            PrizeStruct memory prize = prizesData[_raffleId][
                _currentPrizeIndex
            ];
            if (prize.collection != address(0)) {
                // transfer nft back to the owner
                IERC721 _asset = IERC721(prize.collection);
                _asset.transferFrom(address(this), prize.seller, prize.tokenId);
            }

            if (prize.amount > 0) {
                (bool sentPrize, ) = prize.seller.call{value: prize.amount}("");
                require(sentPrize, "Failed to send Ether");
            }
            emit PrizePaidOutToStaker(_raffleId, prize.seller, prize.id);
        }
    }

    //////////////////////////////////////////////

    /// @dev internal method to save the prizes in the chain
    /// @param _raffleId id of the competition
    /// @param _prizes array with the prizes data
    function savePrizes(
        uint256 _raffleId,
        PrizeStruct[] calldata _prizes
    ) internal onlyRole(OPERATOR_ROLE) {
        require(_prizes.length > 0, "No prizes");
        require(_prizes.length < numWords, "Too many prizes");

        uint48 prizesLength = uint48(_prizes.length);

        for (uint256 i; i < prizesLength; ++i) {
            PrizeStruct memory p = PrizeStruct({
                seller: _prizes[i].seller,
                amount: _prizes[i].amount,
                position: _prizes[i].position,
                collection: _prizes[i].collection,
                tokenId: _prizes[i].tokenId,
                id: _prizes[i].id
            });

            prizesData[_raffleId][i] = p;
        }
        RaffleStruct storage raffle = raffles[_raffleId];
        raffle.numOfPrizes = prizesLength;
    }

    /// @notice Creates a set of competitions. A competition can have several prizes
    /// either in ETH, NFTs or a mix of both
    /// @param _batchRafflesDTO array of BatchRaffleDTO, that contains prices, prizes, required colletions, etc.
    function createRaffle(
        BatchRaffleDTO[] calldata _batchRafflesDTO
    ) external onlyRole(OPERATOR_ROLE) {
        require(_batchRafflesDTO.length > 0, "No Raffles");
        for (uint256 i; i < _batchRafflesDTO.length; ++i) {
            RaffleDTO calldata _raffleDTO = _batchRafflesDTO[i].raffleDTO;

            require(_raffleDTO.maxEntriesPerUser > 0, "maxEntries is 0");
            require(
                _raffleDTO.commissionInBasicPoints <= 5000,
                "commission too high"
            );

            RaffleStruct memory raffle = RaffleStruct({
                platformPercentage: _raffleDTO.commissionInBasicPoints,
                cancellingDate: 0,
                numOfPrizes: 0
            });

            raffles.push(raffle);

            EntryInfoStruct memory entryInfo = EntryInfoStruct({
                status: STATUS.CREATED,
                entryType: _raffleDTO.entryType,
                amountRaised: 0,
                entriesLength: 0
            });
            rafflesEntryInfo.push(entryInfo);

            uint256 idRaffle = raffles.length - 1;

            require(_batchRafflesDTO[i].prices.length > 0, "No prices");
            for (uint256 j = 0; j < _batchRafflesDTO[i].prices.length; ++j) {
                require(
                    _batchRafflesDTO[i].prices[j].numEntries > 0,
                    "numEntries is 0"
                );

                PriceStructure memory p = PriceStructure({
                    id: idRaffle,
                    numEntries: _batchRafflesDTO[i].prices[j].numEntries,
                    price: _batchRafflesDTO[i].prices[j].price
                });
                pricesList[_batchRafflesDTO[i].prices[j].id] = p;
            }

            savePrizes(idRaffle, _batchRafflesDTO[i].prizes);

            fundingList[idRaffle] = FundingStructure({
                minimumFundsInWeis: _raffleDTO.minimumFundsInWeis,
                desiredFundsInWeis: _raffleDTO.desiredFundsInWeis
            });

            EntriesBought memory entryBought = EntriesBought({
                player: address(0),
                currentEntriesLength: 0
            });
            entriesList[idRaffle].push(entryBought);
            delete entriesList[idRaffle][0];

            emit RaffleCreated(idRaffle);
        }
    }

    /// @dev Everyone can call this method, as in previous versions
    /// It stakes the prizes in the contract
    /// @param _raffleIds array with the ids of the competitions to have prizes staked
    function stake(
        uint256[] calldata _raffleIds
    ) external payable nonReentrant {
        uint256 counterETH = 0;
        uint256 raffleIDsLength = _raffleIds.length;

        for (uint256 j; j < raffleIDsLength; ++j) {
            uint256 _raffleId = _raffleIds[j];
            RaffleStruct memory raffle = raffles[_raffleId];
            EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
            uint256 numOfPrizes = raffle.numOfPrizes;
            // Check if the raffle is already created
            require(entryInfo.status == STATUS.CREATED, "Raffle not CREATED");
            // check the raffle has already the prizes set
            require(numOfPrizes > 0, "Prizes not set");

            // first, stake the nfts
            for (uint256 i; i < numOfPrizes; ++i) {
                PrizeStruct memory prize = prizesData[_raffleId][i];
                // if it is an NFT (721 only)
                if (prize.collection != address(0)) {
                    IERC721 token = IERC721(prize.collection);
                    require(
                        token.ownerOf(prize.tokenId) == msg.sender,
                        "NFT is not owned by caller"
                    );
                    token.transferFrom(
                        msg.sender,
                        address(this),
                        prize.tokenId
                    ); // transfer the token to the contract
                }
                // if the prize is ETH, sum the amount
                if (prize.amount > 0) {
                    counterETH += prize.amount;
                }
            }

            entryInfo.status = STATUS.ACCEPTED;

            emit RaffleStarted(_raffleId, msg.sender);
        }
        require(counterETH == msg.value, "ETH Prize not staked");
    }

    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)
    /// one or more entries will be assigned to the player.
    /// Also it is checked the maximum number of entries per user is not reached
    /// As the method is payable, in msg.value there will be the amount paid by the user
    /// @notice If the operator set requiredNFTs when creating the raffle, only the owners of nft on that collection can make a call to this method. This will be
    /// used for special raffles
    /// @param _raffleId: id of the raffle
    /// @param _id: id of the price structure
    function buyEntry(uint256 _raffleId, uint256 _id) external payable {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        if (entryInfo.status != STATUS.ACCEPTED)
            revert EntryNotAllowed("Not in ACCEPTED");
        if (_id == 0) revert EntryNotAllowed("howMany is 0");
        PriceStructure memory priceStruct = pricesList[_id];
        if (priceStruct.id != _raffleId)
            revert EntryNotAllowed("Id not in raffleId");
        uint48 numEntries = priceStruct.numEntries;
        if (numEntries == 0) revert EntryNotAllowed("Id not supported");
        if (msg.value != priceStruct.price)
            revert EntryNotAllowed("msg.value must be equal to the price");
        if (entryInfo.entriesLength == 0) {
            // if is the first entry, added when creating the raffle, overwrite
            entriesList[_raffleId][0].player = msg.sender;
            entriesList[_raffleId][0].currentEntriesLength =
                entryInfo.entriesLength +
                priceStruct.numEntries;
        } else {
            EntriesBought memory entryBought = EntriesBought({
                player: msg.sender,
                currentEntriesLength: entryInfo.entriesLength +
                    priceStruct.numEntries
            });
            entriesList[_raffleId].push(entryBought);
        }

        entryInfo.amountRaised += uint128(msg.value);
        // update the field entriesLength, used in frontend to avoid making extra calls
        entryInfo.entriesLength =
            entryInfo.entriesLength +
            priceStruct.numEntries;

        emit EntrySold(_raffleId, msg.sender, entryInfo.entriesLength, _id); // 2377
    }

    // The operator can add free entries to the raffle
    /// @param _raffleId Id of the raffle
    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie
    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user
    function giveBatchEntriesForFree(
        uint256 _raffleId,
        address[] memory _freePlayers
    ) external onlyRole(OPERATOR_ROLE) {
        require(
            rafflesEntryInfo[_raffleId].status == STATUS.ACCEPTED,
            "Raffle is not in accepted"
        );

        uint256 freePlayersLength = _freePlayers.length;
        uint48 validPlayersCount = 0;
        for (uint256 i; i < freePlayersLength; ++i) {
            address entry = _freePlayers[i];
            // add a new element to the entriesBought array.
            // as this method only adds 1 entry per call, the amountbought is always 1
            addEntriesBought(
                _raffleId,
                entry,
                rafflesEntryInfo[_raffleId].entriesLength +
                    validPlayersCount +
                    1
            );

            ++validPlayersCount;
        }

        rafflesEntryInfo[_raffleId].entriesLength =
            rafflesEntryInfo[_raffleId].entriesLength +
            validPlayersCount;

        emit FreeEntry(
            _raffleId,
            _freePlayers,
            freePlayersLength,
            rafflesEntryInfo[_raffleId].entriesLength
        );
    }

    function setCashOutActions(
        uint256 _raffleId
    ) internal returns (EntryInfoStruct memory) {
        EntryInfoStruct storage raffle = rafflesEntryInfo[_raffleId];

        FundingStructure memory funding = fundingList[_raffleId];

        address seller = prizesData[_raffleId][0].seller;
        require(seller == msg.sender, "Not the seller");
        // Check if the raffle is already accepted
        require(
            raffle.status == STATUS.ACCEPTED,
            "Raffle not in accepted status"
        );
        require(
            raffle.amountRaised >= funding.minimumFundsInWeis,
            "Not enough funds raised"
        );

        raffle.status = STATUS.EARLY_CASHOUT;

        emit EarlyCashoutTriggered(_raffleId, raffle.amountRaised);

        return raffle;
    }

    function earlyCashOut(uint256 _raffleId) external onlyRole(OPERATOR_ROLE) {
        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);
        uint256 requestId = callVRFAndGetRequestId();
        getRandomNumber(_raffleId, raffle.entriesLength, requestId);
    }

    function setWinnerActions(
        uint256 _raffleId
    ) internal returns (EntryInfoStruct memory) {
        EntryInfoStruct storage raffle = rafflesEntryInfo[_raffleId];

        emit SetWinnerTriggered(_raffleId, raffle.amountRaised);

        FundingStructure memory funding = fundingList[_raffleId];
        // Check if the raffle is already accepted or is called again because early cashout failed
        require(raffle.status == STATUS.ACCEPTED, "Raffle in wrong status");
        require(
            raffle.amountRaised >= funding.minimumFundsInWeis,
            "Not enough funds raised"
        );

        require(
            funding.desiredFundsInWeis <= raffle.amountRaised,
            "Desired funds not raised"
        );
        raffle.status = STATUS.CLOSING_REQUESTED;

        return raffle;
    }

    /// @param _raffleId Id of the raffle
    /// @notice the operator finish the raffle, if the desired funds has been reached
    /// @dev it triggers Chainlink VRF2 consumer, and generates a random number that is normalized and checked that corresponds to a MW player
    function setWinner(uint256 _raffleId) external onlyRole(OPERATOR_ROLE) {
        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);
        uint256 requestId = callVRFAndGetRequestId();
        getRandomNumber(_raffleId, raffle.entriesLength, requestId);
    }

    /// @param _newAddress new address of the platform
    /// @dev Change the wallet of the platform. The one that will receive the platform fee when the raffle is closed.
    /// Only the admin can change this
    function setDestinationAddress(
        address payable _newAddress
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        destinationWallet = _newAddress;
    }

    /// @param _raffleId Id of the raffle
    /// @dev The operator can cancel the raffle. The NFT is sent back to the seller
    function cancelRaffle(
        uint256 _raffleId
    ) external nonReentrant onlyRole(OPERATOR_ROLE) {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        RaffleStruct storage raffle = raffles[_raffleId];

        // Dont cancel twice, or cancel an already ended raffle
        require(
            entryInfo.status != STATUS.ENDED &&
                entryInfo.status != STATUS.CANCELLED &&
                entryInfo.status != STATUS.EARLY_CASHOUT &&
                entryInfo.status != STATUS.CLOSING_REQUESTED &&
                entryInfo.status != STATUS.CANCEL_REQUESTED,
            "Wrong status"
        );

        // only if the raffle is in accepted status the NFT is staked and could have entries sold
        if (entryInfo.status == STATUS.ACCEPTED) {
            for (uint256 i; i < raffle.numOfPrizes; ++i) {
                PrizeStruct memory prize = prizesData[_raffleId][i];
                if (prize.collection != address(0)) {
                    // transfer nft to the owner
                    IERC721 _asset = IERC721(prize.collection);
                    _asset.transferFrom(
                        address(this),
                        prize.seller,
                        prize.tokenId
                    );
                }

                if (prize.amount > 0) {
                    (bool sentPrize, ) = prize.seller.call{value: prize.amount}(
                        ""
                    );
                    require(sentPrize, "Failed to send Ether");
                }
            }
        }

        (bool sent, ) = destinationWallet.call{value: entryInfo.amountRaised}(
            ""
        );
        require(sent, "Fail send Eth to MW");

        entryInfo.status = STATUS.CANCEL_REQUESTED;
        raffle.cancellingDate = uint48(block.timestamp);

        emit RaffleCancelled(_raffleId, entryInfo.amountRaised);
    }

    function setChainlinkVRFCallbackGasLimit(
        uint32 _newLimit
    ) external onlyRole("OPERATOR") {
        callbackGasLimit = _newLimit;
    }

    /*
    // Requested by Valerio Di Napoli.
    /// @param _raffleId id of the raffle
    /// @param _amountOfEntries amount of entries. Must be lower than maxEntriesPerUser
    /// @param _player The address of the player
    /// @notice Called by other contract created by Valerio, that minted an NFT and after that call this method
    /// @dev add entries but they are free so no payable
    function createFreeEntriesFromExternalContract(
        uint256 _raffleId,
        uint48 _amountOfEntries,
        address _player
    ) external onlyRole(MINTERCONTRACT_ROLE) {
        // if can buy run this code.
        bytes32 hash = keccak256(abi.encode(_player, _raffleId));

        RaffleStruct storage raffle = raffles[_raffleId];

        require(
            raffle.entryType == ENTRY_TYPE.ONLY_EXTERNAL_CONTRACT ||
                raffle.entryType == ENTRY_TYPE.MIXED,
            "Entry type not allowed"
        );

        winnersManager.addEntriesBought(
            _raffleId,
            _player,
            raffle.entriesLength + _amountOfEntries
        );
        // update the field entriesLength.
        raffle.entriesLength += _amountOfEntries;
        //update claim data
        claimsData[hash].numEntriesPerUser += _amountOfEntries;

        address[] memory players = new address[](1);
        players[0] = _player;
        emit FreeEntry(
            _raffleId,
            players,
            _amountOfEntries,
            raffle.entriesLength
        );
    }

    function getRaffleData(
        uint256 _idRaffle
    ) external view returns (RaffleStruct memory) {
        return raffles[_idRaffle];
    }

    function raffleNotInAcceptedState(
        uint256 _raffleId
    ) external view returns (bool) {
        RaffleStruct memory raffle = raffles[_raffleId];
        return (raffle.status != STATUS.ACCEPTED);
    }

    function playerIsBlacklisted(address _player) external view returns (bool) {
        return false;
    }
    */

    function findUpperBound(
        EntriesBought[] memory array,
        uint256 element
    ) internal pure returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid].currentEntriesLength > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].currentEntriesLength == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    function getWinnerLoopingToTheLeft(
        uint256 _raffleId,
        uint256 position,
        uint256 _randomNumber
    ) internal view returns (address candidate, uint256, uint256) {
        uint256 count = 0;
        uint256 i = position;
        EntriesBought[] memory localEntriesList = entriesList[_raffleId];
        uint256 entriesLength = localEntriesList.length;

        while (count < entriesLength) {
            if (i == entriesLength) i = position - 1;
            candidate = localEntriesList[i].player;
            //   emit NewCandidate(_raffleId, candidate, i);
            if (isValidCandidate(_raffleId, candidate))
                return (candidate, i, _randomNumber);
            if (i == 0) i = entriesLength - 1;
            else i = --i;
            ++count;
        }
        //revert("All users blacklisted");
        return (address(0), 0, 0);
    }

    function getWinnerAddressFromRandom(
        uint256 _raffleId,
        uint256[] memory _randomWords,
        uint256 entriesLength,
        uint256 randomIndex
    ) internal view returns (address, uint256, uint256) {
        address candidate = address(0);
        uint256 position = 0;
        uint256 _randomNumber = (_randomWords[randomIndex] % entriesLength) + 1;

        // general case. Find a candidate not winner before and not blacklisted
        do {
            // get a new candidate
            (candidate, position) = getCandidate(_raffleId, _randomNumber);
            // check if already a previous winner or blacklisted
            if (isValidCandidate(_raffleId, candidate))
                return (candidate, randomIndex, _randomNumber);
            else {
                //    emit AlreadyWinner(_raffleId, candidate, randomIndex);
                ++randomIndex;
                // check if all the random numbers has been used or not
                if (randomIndex == _randomWords.length) {
                    //limit reached
                    //    emit LimitReached(randomIndex, position);
                    break;
                } else {
                    _randomNumber =
                        (_randomWords[randomIndex] % entriesLength) +
                        1;
                }
            }
        } while (randomIndex - 1 <= _randomWords.length);

        // if all the random words were used and no viable candidate was found, run a loop
        // through the left. Otherwise, we have a viable candidate. Return it
        return getWinnerLoopingToTheLeft(_raffleId, position, _randomNumber);
    }

    function isValidCandidate(
        uint256 _idRaffle,
        address _candidate
    ) internal view returns (bool) {
        WinnersStruct[] memory localWinnersList = winnersList[_idRaffle];
        uint256 winnersLength = localWinnersList.length;
        if (_candidate == address(0)) return false;
        for (uint256 i; i < winnersLength; ++i) {
            if (localWinnersList[i].player == _candidate) {
                return false;
            }
        }
        return true;
    }

    function getCandidate(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) internal view returns (address, uint256) {
        EntriesBought[] memory localEntriesList = entriesList[_raffleId];

        uint256 position = findUpperBound(
            localEntriesList,
            _normalizedRandomNumber
        );

        return (localEntriesList[position].player, position);
    }

    function addEntriesBought(
        uint256 _raffleId,
        address _player,
        uint48 _currentEntriesLength
    ) internal {
        if (
            entriesList[_raffleId][0].currentEntriesLength == 0
        ) // if is the first entry, added when creating the raffle, overwrite
        {
            entriesList[_raffleId][0].player = _player;
            entriesList[_raffleId][0]
                .currentEntriesLength = _currentEntriesLength;
        } else {
            EntriesBought memory entryBought = EntriesBought({
                player: _player,
                currentEntriesLength: _currentEntriesLength
            });
            entriesList[_raffleId].push(entryBought);
        }
    }

    /// @dev if a player has been blacklisted, their entries must be void
    /// this has a cost in gas, but this makes cheaper in gas the callback from chainlink
    /// This method has to be called for every raffle of the blacklisted player
    /// @param _raffleId Id of the raffle
    /// @param entriesToCancel array that contains the index of the entries to cancel. 0 based
    /// @param _player blacklisted player who owns the entry to be voided

    function cancelEntry(
        uint256 _raffleId,
        uint256[] calldata entriesToCancel,
        address _player
    ) external onlyRole(OPERATOR_ROLE) {
        uint256 totalEntriesBoughtCancelled = 0;
        for (uint256 i; i < entriesToCancel.length; i++) {
            EntriesBought storage entry = entriesList[_raffleId][
                entriesToCancel[i]
            ];

            require(entry.player == _player, "Entry did not belong to player");

            entry.player = address(0);

            uint256 previousTotalEntriesLength;
            if (entriesToCancel[i] == 0) previousTotalEntriesLength = 0;
            else
                previousTotalEntriesLength = entriesList[_raffleId][
                    entriesToCancel[i] - 1
                ].currentEntriesLength;
            totalEntriesBoughtCancelled +=
                entry.currentEntriesLength -
                previousTotalEntriesLength;
        }
        emit EntryCancelled(_raffleId, totalEntriesBoughtCancelled, _player);
    }

    function addToWinnersList(
        uint256 _idRaffle,
        uint48 _idPrize,
        address _winner,
        uint256 _randomNumber
    ) internal {
        WinnersStruct memory winnerData = WinnersStruct({
            player: _winner,
            randomNumber: _randomNumber,
            idPrize: _idPrize
        });

        winnersList[_idRaffle].push(winnerData);
    }

    /// Views visible for everyone
    function getWinnersData(
        uint256 _idRaffle
    ) public view returns (WinnersStruct[] memory) {
        return winnersList[_idRaffle];
    }

    function getEntriesBought(
        uint256 _idRaffle
    ) public view returns (EntriesBought[] memory) {
        return entriesList[_idRaffle];
    }
}