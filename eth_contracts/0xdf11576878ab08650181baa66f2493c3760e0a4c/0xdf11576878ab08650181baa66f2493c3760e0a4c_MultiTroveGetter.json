{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/MultiTroveGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../interfaces/ITroveManager.sol\\\";\\nimport \\\"../interfaces/ISortedTroves.sol\\\";\\nimport \\\"../interfaces/IFactory.sol\\\";\\n\\n/*  Helper contract for grabbing Trove data for the front end. Not part of the WenCore Wen system. */\\ncontract MultiTroveGetter {\\n\\tstruct CombinedTroveData {\\n\\t\\taddress owner;\\n\\t\\tuint256 debt;\\n\\t\\tuint256 interest;\\n\\t\\tuint256 coll;\\n\\t\\tuint256 stake;\\n\\t\\tuint256 pendingCollateral;\\n\\t\\tuint256 pendingDebt;\\n\\t}\\n\\n\\tfunction getMultipleSortedTroves(ITroveManager troveManager, int _startIdx, uint256 _count) external view returns (CombinedTroveData[] memory _troves) {\\n\\t\\tISortedTroves sortedTroves = ISortedTroves(troveManager.sortedTroves());\\n\\t\\tuint256 startIdx;\\n\\t\\tbool descend;\\n\\n\\t\\tif (_startIdx >= 0) {\\n\\t\\t\\tstartIdx = uint256(_startIdx);\\n\\t\\t\\tdescend = true;\\n\\t\\t} else {\\n\\t\\t\\tstartIdx = uint256(-(_startIdx + 1));\\n\\t\\t\\tdescend = false;\\n\\t\\t}\\n\\n\\t\\tuint256 sortedTrovesSize = sortedTroves.getSize();\\n\\t\\tif (startIdx >= sortedTrovesSize) {\\n\\t\\t\\t_troves = new CombinedTroveData[](0);\\n\\t\\t} else {\\n\\t\\t\\tuint256 maxCount = sortedTrovesSize - startIdx;\\n\\t\\t\\tif (_count > maxCount) {\\n\\t\\t\\t\\t_count = maxCount;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (descend) {\\n\\t\\t\\t\\t_troves = _getMultipleSortedTrovesFromHead(troveManager, sortedTroves, startIdx, _count);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_troves = _getMultipleSortedTrovesFromTail(troveManager, sortedTroves, startIdx, _count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getMultipleSortedTrovesFromHead(ITroveManager troveManager, ISortedTroves sortedTroves, uint256 _startIdx, uint256 _count) internal view returns (CombinedTroveData[] memory _troves) {\\n\\t\\taddress currentTroveowner = sortedTroves.getFirst();\\n\\n\\t\\tfor (uint256 idx = 0; idx < _startIdx; ++idx) {\\n\\t\\t\\tcurrentTroveowner = sortedTroves.getNext(currentTroveowner);\\n\\t\\t}\\n\\n\\t\\t_troves = new CombinedTroveData[](_count);\\n\\n\\t\\tfor (uint256 idx = 0; idx < _count; ++idx) {\\n\\t\\t\\t_troves[idx].owner = currentTroveowner;\\n\\n\\t\\t\\tITroveManager.Trove memory trove = troveManager.getTrove(currentTroveowner);\\n\\t\\t\\t_troves[idx].debt = trove.debt;\\n\\t\\t\\t_troves[idx].coll = trove.coll;\\n\\t\\t\\t_troves[idx].stake = trove.stake;\\n\\t\\t\\t(_troves[idx].pendingCollateral, _troves[idx].pendingDebt) = troveManager.getPendingCollAndDebtRewards(currentTroveowner);\\n\\t\\t\\t_troves[idx].interest = troveManager.getTroveInterest(currentTroveowner, _troves[idx].debt + _troves[idx].pendingDebt);\\n\\t\\t\\tcurrentTroveowner = sortedTroves.getNext(currentTroveowner);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getMultipleSortedTrovesFromTail(ITroveManager troveManager, ISortedTroves sortedTroves, uint256 _startIdx, uint256 _count) internal view returns (CombinedTroveData[] memory _troves) {\\n\\t\\taddress currentTroveowner = sortedTroves.getLast();\\n\\n\\t\\tfor (uint256 idx = 0; idx < _startIdx; ++idx) {\\n\\t\\t\\tcurrentTroveowner = sortedTroves.getPrev(currentTroveowner);\\n\\t\\t}\\n\\n\\t\\t_troves = new CombinedTroveData[](_count);\\n\\n\\t\\tfor (uint256 idx = 0; idx < _count; ++idx) {\\n\\t\\t\\t_troves[idx].owner = currentTroveowner;\\n\\t\\t\\tITroveManager.Trove memory trove = troveManager.getTrove(currentTroveowner);\\n\\t\\t\\t_troves[idx].debt = trove.debt;\\n\\t\\t\\t_troves[idx].coll = trove.coll;\\n\\t\\t\\t_troves[idx].stake = trove.stake;\\n\\n\\t\\t\\t(_troves[idx].pendingCollateral, _troves[idx].pendingDebt) = troveManager.getPendingCollAndDebtRewards(currentTroveowner);\\n\\n\\t\\t\\t_troves[idx].interest = troveManager.getTroveInterest(currentTroveowner, _troves[idx].debt + _troves[idx].pendingDebt);\\n\\n\\t\\t\\tcurrentTroveowner = sortedTroves.getPrev(currentTroveowner);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IFactory {\\n\\t// commented values are suggested default parameters\\n\\tstruct DeploymentParams {\\n\\t\\tuint256 minuteDecayFactor; // 999037758833783000  (half life of 12 hours)\\n\\t\\tuint256 redemptionFeeFloor; // 1e18 / 1000 * 5  (0.5%)\\n\\t\\tuint256 maxRedemptionFee; // 1e18  (100%)\\n\\t\\tuint256 borrowingFeeFloor; // 1e18 / 1000 * 5  (0.5%)\\n\\t\\tuint256 maxBorrowingFee; // 1e18 / 100 * 5  (5%)\\n\\t\\tuint256 interestRateInBps; // 100 (1%)\\n\\t\\tuint256 maxDebt;\\n\\t\\tuint256 MCR; // 12 * 1e17  (120%)\\n\\t}\\n\\n\\tevent NewDeployment(address collateral, address priceFeed, address troveManager, address sortedTroves);\\n\\n\\tfunction deployNewInstance(address collateral, address priceFeed, address customTroveManagerImpl, address customSortedTrovesImpl, DeploymentParams calldata params) external;\\n\\n\\tfunction setImplementations(address _troveManagerImpl, address _sortedTrovesImpl) external;\\n\\n\\tfunction Wen_CORE() external view returns (address);\\n\\n\\tfunction borrowerOperations() external view returns (address);\\n\\n\\tfunction debtToken() external view returns (address);\\n\\n\\tfunction guardian() external view returns (address);\\n\\n\\tfunction liquidationManager() external view returns (address);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction sortedTrovesImpl() external view returns (address);\\n\\n\\tfunction stabilityPool() external view returns (address);\\n\\n\\tfunction troveManagerCount() external view returns (uint256);\\n\\n\\tfunction troveManagerImpl() external view returns (address);\\n\\n\\tfunction troveManagers(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IPriceFeed {\\n\\tevent NewOracleRegistered(address token, address chainlinkAggregator, bool isEthIndexed);\\n\\tevent PriceFeedStatusUpdated(address token, address oracle, bool isWorking);\\n\\tevent PriceRecordUpdated(address indexed token, uint256 _price);\\n\\n\\tfunction fetchPrice(address _token) external returns (uint256);\\n\\n\\tfunction setOracle(address _token, address _chainlinkOracle, bytes4 sharePriceSignature, uint8 sharePriceDecimals, bool _isEthIndexed) external;\\n\\n\\tfunction MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND() external view returns (uint256);\\n\\n\\tfunction RESPONSE_TIMEOUT() external view returns (uint256);\\n\\n\\tfunction TARGET_DIGITS() external view returns (uint256);\\n\\n\\tfunction guardian() external view returns (address);\\n\\n\\tfunction oracleRecords(address) external view returns (address chainLinkOracle, uint8 decimals, bytes4 sharePriceSignature, uint8 sharePriceDecimals, bool isFeedWorking, bool isEthIndexed);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction priceRecords(address) external view returns (uint96 scaledPrice, uint32 timestamp, uint32 lastUpdated, uint80 roundId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISortedTroves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface ISortedTroves {\\n\\tevent NodeAdded(address _id, uint256 _NICR);\\n\\tevent NodeRemoved(address _id);\\n\\n\\tfunction insert(address _id, uint256 _NICR, address _prevId, address _nextId) external;\\n\\n\\tfunction reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external;\\n\\n\\tfunction remove(address _id) external;\\n\\n\\tfunction setAddresses(address _troveManagerAddress) external;\\n\\n\\tfunction contains(address _id) external view returns (bool);\\n\\n\\tfunction data() external view returns (address head, address tail, uint256 size);\\n\\n\\tfunction findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (address, address);\\n\\n\\tfunction getFirst() external view returns (address);\\n\\n\\tfunction getLast() external view returns (address);\\n\\n\\tfunction getNext(address _id) external view returns (address);\\n\\n\\tfunction getPrev(address _id) external view returns (address);\\n\\n\\tfunction getSize() external view returns (uint256);\\n\\n\\tfunction isEmpty() external view returns (bool);\\n\\n\\tfunction troveManager() external view returns (address);\\n\\n\\tfunction validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITroveManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IWenBase.sol\\\";\\nimport \\\"./ISortedTroves.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\n\\ninterface ITroveManager is IWenBase {\\n\\t// Store the necessary data for a trove\\n\\tstruct Trove {\\n\\t\\tuint256 debt;\\n\\t\\tuint256 coll;\\n\\t\\tuint256 stake;\\n\\t\\tStatus status;\\n\\t\\tuint128 arrayIndex;\\n\\t}\\n\\n\\tstruct RedemptionTotals {\\n\\t\\tuint256 remainingDebt;\\n\\t\\tuint256 totalDebtToRedeem;\\n\\t\\tuint256 totalCollateralDrawn;\\n\\t\\tuint256 totalInterest;\\n\\t\\tuint256 collateralFee;\\n\\t\\tuint256 collateralToSendToRedeemer;\\n\\t\\tuint256 decayedBaseRate;\\n\\t\\tuint256 price;\\n\\t\\tuint256 totalDebtSupplyAtStart;\\n\\t}\\n\\n\\tstruct SingleRedemptionValues {\\n\\t\\tuint256 debtLot;\\n\\t\\tuint256 collateralLot;\\n\\t\\tuint256 interestLot;\\n\\t\\tbool cancelledPartial;\\n\\t}\\n\\n\\t// Object containing the collateral and debt snapshots for a given active trove\\n\\tstruct RewardSnapshot {\\n\\t\\tuint256 collateral;\\n\\t\\tuint256 debt;\\n\\t\\tuint256 interest;\\n\\t}\\n\\n\\tenum TroveManagerOperation {\\n\\t\\topen,\\n\\t\\tclose,\\n\\t\\tadjust,\\n\\t\\tliquidate,\\n\\t\\tredeemCollateral\\n\\t}\\n\\n\\tenum Status {\\n\\t\\tnonExistent,\\n\\t\\tactive,\\n\\t\\tclosedByOwner,\\n\\t\\tclosedByLiquidation,\\n\\t\\tclosedByRedemption\\n\\t}\\n\\n\\tevent InterestPaid(address _account, address _borrower, uint256 _interest);\\n\\tevent TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, TroveManagerOperation _operation);\\n\\tevent Redemption(uint256 _attemptedDebtAmount, uint256 _actualDebtAmount, uint256 _collateralSent, uint256 _InterestDebt, uint256 _collateralFee);\\n\\tevent BaseRateUpdated(uint256 _baseRate);\\n\\tevent LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\\n\\tevent TotalStakesUpdated(uint256 _newTotalStakes);\\n\\tevent SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\\n\\tevent LTermsUpdated(uint256 _L_collateral, uint256 _L_debt);\\n\\tevent TroveRewardSnapshotsUpdated(address borrower, uint256 _L_collateral, uint256 _L_debt);\\n\\tevent TroveInterestSnapshotsUpdated(address borrower, uint256 _L_interest);\\n\\tevent TroveIndexUpdated(address _borrower, uint256 _newIndex);\\n\\tevent CollateralSent(address _to, uint256 _amount);\\n\\tevent RewardClaimed(address indexed account, address indexed recipient, uint256 claimed);\\n\\n\\tfunction addCollateralSurplus(address borrower, uint256 collSurplus) external;\\n\\n\\tfunction applyPendingRewards(address _borrower) external returns (uint256 coll, uint256 debt);\\n\\n\\tfunction claimCollateral(address _receiver) external;\\n\\n\\tfunction closeTrove(address _borrower, address _receiver, uint256 collAmount, uint256 debtAmount) external;\\n\\n\\tfunction closeTroveByLiquidation(address _borrower) external;\\n\\n\\tfunction decayBaseRateAndGetBorrowingFee(uint256 _debt) external returns (uint256);\\n\\n\\tfunction decreaseDebtAndSendCollateral(address account, uint256 debt, uint256 coll) external;\\n\\n\\tfunction finalizeLiquidation(address _liquidator, uint256 _debt, uint256 _coll, uint256 _collSurplus, uint256 _debtGasComp, uint256 _collGasComp, uint256 _interest) external;\\n\\n\\tfunction getEntireSystemBalances() external returns (uint256, uint256, uint256);\\n\\n\\tfunction movePendingTroveRewardsToActiveBalances(uint256 _debt, uint256 _collateral) external;\\n\\n\\tfunction openTrove(address _borrower, uint256 _collateralAmount, uint256 _compositeDebt, uint256 NICR, address _upperHint, address _lowerHint) external returns (uint256 stake, uint256 arrayIndex);\\n\\n\\tfunction redeemCollateral(uint256 _debtAmount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint256 _partialRedemptionHintNICR, uint256 _maxIterations, uint256 _maxFeePercentage) external;\\n\\n\\tfunction setAddresses(address _priceFeedAddress, address _sortedTrovesAddress, IERC20 _collateralToken) external;\\n\\n\\tfunction setParameters(uint256 _minuteDecayFactor, uint256 _redemptionFeeFloor, uint256 _maxRedemptionFee, uint256 _borrowingFeeFloor, uint256 _maxBorrowingFee, uint256 _maxSystemDebt, uint256 _MCR, uint32 _interestRate) external;\\n\\n\\tfunction setPaused(bool _paused) external;\\n\\n\\tfunction setPriceFeed(address _priceFeedAddress) external;\\n\\n\\tfunction updateTroveFromAdjustment(bool _isDebtIncrease, uint256 _debtChange, uint256 _netDebtChange, bool _isCollIncrease, uint256 _collChange, address _upperHint, address _lowerHint, address _borrower, address _receiver) external returns (uint256, uint256, uint256);\\n\\n\\tfunction fetchPrice() external returns (uint256);\\n\\n\\tfunction distributeInterestDebt() external returns (uint256);\\n\\n\\tfunction repayInterest(address _account, address _borrower, uint256 _debt) external;\\n\\n\\tfunction BOOTSTRAP_PERIOD() external view returns (uint256);\\n\\n\\tfunction L_collateral() external view returns (uint256);\\n\\n\\tfunction L_debt() external view returns (uint256);\\n\\n\\tfunction MCR() external view returns (uint256);\\n\\n\\tfunction getTrove(address _borrower) external view returns (Trove memory);\\n\\n\\tfunction baseRate() external view returns (uint256);\\n\\n\\tfunction borrowerOperationsAddress() external view returns (address);\\n\\n\\tfunction borrowingFeeFloor() external view returns (uint256);\\n\\n\\tfunction collateralToken() external view returns (IERC20);\\n\\n\\tfunction defaultedCollateral() external view returns (uint256);\\n\\n\\tfunction defaultedDebt() external view returns (uint256);\\n\\n\\tfunction getBorrowingFee(uint256 _debt) external view returns (uint256);\\n\\n\\tfunction getBorrowingFeeWithDecay(uint256 _debt) external view returns (uint256);\\n\\n\\tfunction getBorrowingRate() external view returns (uint256);\\n\\n\\tfunction getBorrowingRateWithDecay() external view returns (uint256);\\n\\n\\tfunction getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);\\n\\n\\tfunction getEntireDebtAndColl(address _borrower) external view returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollateralReward);\\n\\n\\tfunction getEntireSystemColl() external view returns (uint256);\\n\\n\\tfunction getEntireSystemDebt() external view returns (uint256);\\n\\n\\tfunction getGlobalSystemDebt() external view returns (uint256);\\n\\n\\tfunction getTroveInterest(address _borrower, uint256 _debt) external view returns (uint256);\\n\\tfunction getRedemptionICR(address _borrower, uint256 _price) external view returns (uint256);\\n\\tfunction getNominalICR(address _borrower) external view returns (uint256);\\n\\n\\tfunction getPendingCollAndDebtRewards(address _borrower) external view returns (uint256, uint256);\\n\\n\\tfunction getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256);\\n\\n\\tfunction getRedemptionRate() external view returns (uint256);\\n\\n\\tfunction getRedemptionRateWithDecay() external view returns (uint256);\\n\\n\\tfunction getTotalActiveCollateral() external view returns (uint256);\\n\\n\\tfunction getTotalActiveDebt() external view returns (uint256);\\n\\n\\tfunction getTroveCollAndDebt(address _borrower) external view returns (uint256 coll, uint256 debt);\\n\\n\\tfunction getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);\\n\\n\\tfunction getTroveOwnersCount() external view returns (uint256);\\n\\n\\tfunction getTroveStake(address _borrower) external view returns (uint256);\\n\\n\\tfunction getTroveStatus(address _borrower) external view returns (uint256);\\n\\n\\tfunction hasPendingRewards(address _borrower) external view returns (bool);\\n\\n\\tfunction lastCollateralError_Redistribution() external view returns (uint256);\\n\\n\\tfunction lastDebtError_Redistribution() external view returns (uint256);\\n\\n\\tfunction lastFeeOperationTime() external view returns (uint256);\\n\\n\\tfunction liquidationManager() external view returns (address);\\n\\n\\tfunction maxBorrowingFee() external view returns (uint256);\\n\\n\\tfunction maxRedemptionFee() external view returns (uint256);\\n\\n\\tfunction maxSystemDebt() external view returns (uint256);\\n\\n\\tfunction minuteDecayFactor() external view returns (uint256);\\n\\n\\tfunction paused() external view returns (bool);\\n\\n\\tfunction redemptionFeeFloor() external view returns (uint256);\\n\\n\\tfunction getRewardSnapshots(address) external view returns (RewardSnapshot memory);\\n\\n\\tfunction priceFeed() external view returns (IPriceFeed);\\n\\n\\tfunction sortedTroves() external view returns (ISortedTroves);\\n\\n\\tfunction sunsetting() external view returns (bool);\\n\\n\\tfunction surplusBalances(address) external view returns (uint256);\\n\\n\\tfunction systemDeploymentTime() external view returns (uint256);\\n\\n\\tfunction totalCollateralSnapshot() external view returns (uint256);\\n\\n\\tfunction totalStakes() external view returns (uint256);\\n\\n\\tfunction totalStakesSnapshot() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWenBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IWenBase {\\n\\tfunction DECIMAL_PRECISION() external view returns(uint256);\\n\\n\\t// Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\\n\\tfunction CCR() external view returns(uint256); // 150%\\n\\n\\t// Amount of debt to be locked in gas pool on opening troves\\n\\tfunction DEBT_GAS_COMPENSATION() external view returns(uint256);\\n\\n\\tfunction PERCENT_DIVISOR() external view returns(uint256);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"troveManager\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"_startIdx\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getMultipleSortedTroves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiTroveGetter.CombinedTroveData[]\",\"name\":\"_troves\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiTroveGetter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}