{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LiquidityMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./ISwapsPair.sol\\\";\\nimport \\\"./ISwapsRouter.sol\\\";\\nimport \\\"./ISwapsFactory.sol\\\";\\nimport \\\"./LiquidityHelper.sol\\\";\\n\\ncontract LiquidityMaker is LiquidityHelper {\\n\\n    address immutable WETH_ADDRESS;\\n    address immutable ROUTER_ADDRESS;\\n\\n    IWETH public immutable WETH;\\n    ISwapsRouter public immutable ROUTER;\\n    ISwapsFactory public immutable FACTORY;\\n\\n    event SwapResults(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    event LiquidityAdded(\\n        uint256 tokenAmountA,\\n        uint256 tokenAmountB,\\n        uint256 tokenAmountLP,\\n        address indexed tokenA,\\n        address indexed tokenB,\\n        address indexed addedTo\\n    );\\n\\n    event CleanUp(\\n        uint256 tokenAmount,\\n        ISwapsERC20 indexed tokenAddress\\n    );\\n\\n    constructor(\\n        ISwapsRouter _router,\\n        ISwapsFactory _factory\\n    ) {\\n        ROUTER_ADDRESS = address(\\n            _router\\n        );\\n\\n        ROUTER = _router;\\n        FACTORY = _factory;\\n\\n        WETH_ADDRESS = ROUTER.WETH();\\n\\n        WETH = IWETH(\\n            WETH_ADDRESS\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Optimal one-sided supply using ETH\\n     * 1. Swaps optimal amount from ETH to ERC20\\n     * 2. Adds liquidity for ETH and Token pair\\n    */\\n    function makeLiquidity(\\n        address _tokenAddress,\\n        uint256 _expectedTokenAmount,\\n        uint256 _minimumLiquidityEther,\\n        uint256 _minimumLiquidityToken\\n    )\\n        external\\n        payable\\n        returns (uint256)\\n    {\\n        _wrapEther(\\n            msg.value\\n        );\\n\\n        return _makeLiquidity(\\n            WETH_ADDRESS,\\n            _tokenAddress,\\n            msg.value,\\n            _expectedTokenAmount,\\n            _minimumLiquidityEther,\\n            _minimumLiquidityToken,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Optimal one-sided supply using ERC20\\n     * 1. Swaps optimal amount from ERC20-A to ERC20-B\\n     * 2. Adds liquidity for _tokenA and _tokenB pair\\n    */\\n    function makeLiquidityDual(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _initialAmountA,\\n        uint256 _expectedAmountB,\\n        uint256 _minimumLiquidityA,\\n        uint256 _minimumLiquidityB\\n    )\\n        external\\n    {\\n        _safeTransferFrom(\\n            _tokenA,\\n            msg.sender,\\n            address(this),\\n            _initialAmountA\\n        );\\n\\n        _makeLiquidity(\\n            _tokenA,\\n            _tokenB,\\n            _initialAmountA,\\n            _expectedAmountB,\\n            _minimumLiquidityA,\\n            _minimumLiquidityB,\\n            msg.sender\\n        );\\n    }\\n\\n    function _makeLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _initialAmountA,\\n        uint256 _expectedAmountB,\\n        uint256 _minimumLiquidityA,\\n        uint256 _minimumLiquidityB,\\n        address _beneficiaryAddress\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        ISwapsPair pair = _getPair(\\n            _tokenA,\\n            _tokenB\\n        );\\n\\n        (\\n            uint256 reserve0,\\n            uint256 reserve1,\\n        ) = pair.getReserves();\\n\\n        uint256 swapAmount = pair.token0() == _tokenA\\n            ? getSwapAmount(reserve0, _initialAmountA)\\n            : getSwapAmount(reserve1, _initialAmountA);\\n\\n        uint256[] memory swapResults = _swapTokens(\\n            _tokenA,\\n            _tokenB,\\n            swapAmount,\\n            _expectedAmountB\\n        );\\n\\n        emit SwapResults(\\n            _tokenA,\\n            _tokenB,\\n            swapResults[0],\\n            swapResults[1]\\n        );\\n\\n        _addLiquidity(\\n            _tokenA,\\n            _tokenB,\\n            swapResults[0],\\n            swapResults[1],\\n            _minimumLiquidityA,\\n            _minimumLiquidityB,\\n            _beneficiaryAddress\\n        );\\n\\n        return swapAmount;\\n    }\\n\\n    /**\\n     * @dev\\n     * Uses swapExactTokensForTokens to split provided value\\n     * 1. Swaps optimal amount from _tokenIn to _tokenOut\\n     * return swap amounts as a result (input and ouput)\\n    */\\n    function _swapTokens(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _swapAmountIn,\\n        uint256 _expectedAmountOut\\n    )\\n        private\\n        returns (uint256[] memory)\\n    {\\n        if (ISwapsERC20(_tokenIn).allowance(address(this), ROUTER_ADDRESS) == 0) {\\n            _forceApprove(\\n                IERC20(_tokenIn),\\n                ROUTER_ADDRESS,\\n                MAX_VALUE\\n            );\\n        }\\n\\n        return ROUTER.swapExactTokensForTokens(\\n            _swapAmountIn,\\n            _expectedAmountOut,\\n            _makePath(\\n                _tokenIn,\\n                _tokenOut\\n            ),\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Adds liquidity for _tokenA and _tokenB pair\\n     * can send LP tokens to _beneficiary address\\n    */\\n    function _addLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountA,\\n        uint256 _amountB,\\n        uint256 _minTokenA,\\n        uint256 _minTokenB,\\n        address _beneficiary\\n    )\\n        private\\n    {\\n        _forceApprove(\\n            IERC20(_tokenB),\\n            ROUTER_ADDRESS,\\n            _amountB\\n        );\\n\\n        (\\n            uint256 tokenAmountA,\\n            uint256 tokenAmountB,\\n            uint256 tokenAmountLP\\n        ) = ROUTER.addLiquidity(\\n            _tokenA,\\n            _tokenB,\\n            _amountA,\\n            _amountB,\\n            _minTokenA,\\n            _minTokenB,\\n            _beneficiary,\\n            block.timestamp\\n        );\\n\\n        emit LiquidityAdded(\\n            tokenAmountA,\\n            tokenAmountB,\\n            tokenAmountLP,\\n            _tokenA,\\n            _tokenB,\\n            _beneficiary\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Read address of the pair\\n     * by calling FACTORY contract\\n    */\\n    function _getPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        private\\n        view\\n        returns (ISwapsPair)\\n    {\\n        return ISwapsPair(\\n            FACTORY.getPair(\\n                _tokenA,\\n                _tokenB\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Allows to wrap Ether\\n     * by calling WETH contract\\n    */\\n    function _wrapEther(\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        WETH.deposit{\\n            value: _amount\\n        }();\\n    }\\n\\n    /**\\n     * @dev\\n     * Allows to cleanup any tokens stuck\\n     * in the contract as leftover dust or\\n     * if accidentally sent to the contract\\n    */\\n    function cleanUp(\\n        ISwapsERC20 _token\\n    )\\n        external\\n    {\\n        uint256 balance = _token.balanceOf(\\n            address(this)\\n        );\\n\\n        _token.transfer(\\n            FACTORY.feeTo(),\\n            balance\\n        );\\n\\n        emit CleanUp(\\n            balance,\\n            _token\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\ninterface IWETH {\\n\\n    function deposit()\\n        external\\n        payable;\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function withdraw(\\n        uint256\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/ISwapsPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\nimport \\\"./ISwapsERC20.sol\\\";\\n\\ninterface ISwapsPair is ISwapsERC20 {\\n\\n    function MINIMUM_LIQUIDITY()\\n        external\\n        pure\\n        returns (uint256);\\n\\n    function factory()\\n        external\\n        view\\n        returns (address);\\n\\n    function token0()\\n        external\\n        view\\n        returns (address);\\n\\n    function token1()\\n        external\\n        view\\n        returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function price1CumulativeLast()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function kLast()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function mint(\\n        address _to\\n    )\\n        external\\n        returns (uint256 liquidity);\\n\\n    function burn(\\n        address _to\\n    )\\n        external\\n        returns (\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    function swap(\\n        uint256 _amount0Out,\\n        uint256 _amount1Out,\\n        address _to,\\n        bytes calldata _data\\n    )\\n        external;\\n\\n    function skim()\\n        external;\\n\\n    function initialize(\\n        address,\\n        address\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/ISwapsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\ninterface ISwapsRouter {\\n\\n    function WETH()\\n        external\\n        returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint[] memory amounts\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB\\n        );\\n\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    )\\n        external\\n        view\\n        returns (\\n            uint112 reserveA,\\n            uint112 reserveB,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function FACTORY()\\n        external\\n        view\\n        returns (address);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    )\\n        external\\n        pure\\n        returns (uint256 amountB);\\n\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    )\\n        external\\n        pure\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/ISwapsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\ninterface ISwapsFactory {\\n\\n    function feeTo()\\n        external\\n        view\\n        returns (address);\\n\\n    function feeToSetter()\\n        external\\n        view\\n        returns (address);\\n\\n    function getPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairsLength()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function createPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        returns (address pair);\\n\\n    function setFeeTo(\\n        address\\n    )\\n        external;\\n\\n    function setFeeToSetter(\\n        address\\n    )\\n        external;\\n\\n    function cloneTarget()\\n        external\\n        view\\n        returns (address target);\\n}\\n\"\r\n    },\r\n    \"contracts/LiquidityHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\ncontract LiquidityHelper {\\n\\n    uint256 constant MAX_VALUE = type(uint256).max;\\n    uint256 constant ZERO_VALUE = 0;\\n\\n    /**\\n     * @dev\\n     * Prepares path for the swap\\n     */\\n    function _makePath(\\n        address _tokenIn,\\n        address _tokenOut\\n    )\\n        internal\\n        pure\\n        returns (address[] memory path)\\n    {\\n        path = new address[](2);\\n\\n        path[0] = _tokenIn;\\n        path[1] = _tokenOut;\\n\\n        return path;\\n    }\\n\\n    /**\\n     * @dev\\n     * Allows to execute transferFrom for a token\\n     */\\n    function _safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        IERC20 token = IERC20(_token);\\n\\n        _callOptionalReturn(\\n            _token,\\n            abi.encodeWithSelector(\\n                token.transferFrom.selector,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(\\n        address _token,\\n        bytes memory _data\\n    )\\n        private\\n    {\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = _token.call(_data);\\n\\n        require(\\n            success,\\n            \\\"LiquidityHelper: CALL_FAILED\\\"\\n        );\\n\\n        if (returndata.length > 0) {\\n            require(\\n                abi.decode(\\n                    returndata,\\n                    (bool)\\n                ),\\n                \\\"LiquidityHelper: OPERATION_FAILED\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev\\n     * s = optimal swap amount\\n     * r = amount of reserve for token a\\n     * a = amount of token a the user currently has (not added to reserve yet)\\n     * f = swap fee percent\\n     * s = (sqrt(((2 - f)r)^2 + 4(1 - f)ar) - (2 - f)r) / (2(1 - f))\\n    */\\n    function getSwapAmount(\\n        uint256 _r,\\n        uint256 _a\\n    )\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (\\n            _sqrt(\\n                _r * (_r * 3988009 + _a * 3988000)\\n            ) - _r * 1997\\n        ) / 1994;\\n    }\\n\\n    /**\\n     * @dev\\n     * Calculates square root of the _y number\\n    */\\n    function _sqrt(\\n        uint256 _y\\n    )\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        if (_y > 3) {\\n            z = _y;\\n            uint256 x = _y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (_y / x + x) / 2;\\n            }\\n        } else if (_y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function _forceApprove(\\n        IERC20 _token,\\n        address _spender,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        bytes memory approvalCall = abi.encodeCall(\\n            _token.approve,\\n            (\\n                _spender,\\n                _value\\n            )\\n        );\\n\\n        if (!_callOptionalReturnBool(_token, approvalCall)) {\\n\\n            bytes memory zeroApprove = abi.encodeCall(\\n                _token.approve, (\\n                    _spender,\\n                    ZERO_VALUE\\n                )\\n            );\\n\\n            _callOptionalReturn(\\n                _token,\\n                zeroApprove\\n            );\\n\\n            _callOptionalReturn(\\n                _token,\\n                approvalCall\\n            );\\n        }\\n    }\\n\\n    function _callOptionalReturn(\\n        IERC20 _token,\\n        bytes memory _data\\n    )\\n        private\\n    {\\n        bytes memory returndata = _functionCall(\\n            address(_token),\\n            _data\\n        );\\n\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(\\n                address(_token)\\n            );\\n        }\\n    }\\n\\n    function _callOptionalReturnBool(\\n        IERC20 _token,\\n        bytes memory _data\\n    )\\n        private\\n        returns (bool)\\n    {\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = address(_token).call(_data);\\n\\n        return success\\n            && (returndata.length == 0 || abi.decode(returndata, (bool)))\\n            && address(_token).code.length > 0;\\n    }\\n\\n    function _functionCall(\\n        address _target,\\n        bytes memory _data\\n    )\\n        internal\\n        returns (bytes memory)\\n    {\\n        return _functionCallWithValue(\\n            _target,\\n            _data,\\n            ZERO_VALUE\\n        );\\n    }\\n\\n    function _functionCallWithValue(\\n        address _target,\\n        bytes memory _data,\\n        uint256 _value\\n    )\\n        internal\\n        returns (bytes memory)\\n    {\\n        if (address(this).balance < _value) {\\n            revert InsufficientBalance(\\n                address(this).balance,\\n                _value\\n            );\\n        }\\n\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = _target.call{\\n            value: _value\\n        }(_data);\\n\\n        return _verifyCallResultFromTarget(\\n            _target,\\n            success,\\n            returndata\\n        );\\n    }\\n\\n    function _verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    )\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        if (!success) {\\n            _revert(\\n                returndata\\n            );\\n        } else {\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(\\n                    target\\n                );\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    function _revert(\\n        bytes memory _returndata\\n    )\\n        private\\n        pure\\n    {\\n        if (_returndata.length > 0) {\\n            assembly {\\n                let returndata_size := mload(_returndata)\\n                revert(add(32, _returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ISwapsERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.25;\\n\\ninterface ISwapsERC20 {\\n\\n    function name()\\n        external\\n        pure\\n        returns (string memory);\\n\\n    function symbol()\\n        external\\n        pure\\n        returns (string memory);\\n\\n    function decimals()\\n        external\\n        pure\\n        returns (uint8);\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function DOMAIN_SEPARATOR()\\n        external\\n        view\\n        returns (bytes32);\\n\\n    function PERMIT_TYPEHASH()\\n        external\\n        pure\\n        returns (bytes32);\\n\\n    function nonces(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\ninterface IERC20 {\\n\\n    function balanceOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- BCOM --\\n\\npragma solidity =0.8.25;\\n\\nerror FailedCall();\\n\\nerror AddressEmptyCode(\\n    address target\\n);\\n\\nerror SafeERC20FailedOperation(\\n    address token\\n);\\n\\nerror InsufficientBalance(\\n    uint256 balance,\\n    uint256 value\\n);\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISwapsRouter\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"contract ISwapsFactory\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract ISwapsERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"CleanUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountLP\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addedTo\",\"type\":\"address\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"SwapResults\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract ISwapsFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract ISwapsRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapsERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"cleanUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_a\",\"type\":\"uint256\"}],\"name\":\"getSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expectedTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumLiquidityEther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumLiquidityToken\",\"type\":\"uint256\"}],\"name\":\"makeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialAmountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumLiquidityA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumLiquidityB\",\"type\":\"uint256\"}],\"name\":\"makeLiquidityDual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidityMaker", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000b4b0ea46fe0e9e8eab4afb765b527739f2718671000000000000000000000000ee3e9e46e34a27dc755a63e2849c9913ee1a06e2", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}