{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Relief.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n// Website: https://relief.fi\\n// Twitter: https://twitter.com/relief_erc314a\\n// Telegram: https://t.me/relief_erc314a\\n\\n/**\\n * @title ERC314a\\n * @dev Implementation of the ERC314a interface.\\n * ERC314 is a derivative of ERC20 which aims to integrate a liquidity pool on the token in order to enable native swaps, notably to reduce gas consumption.\\n * ERC413a is an improved version of ERC314, with the of a MEV Protection and other features.\\n */\\n\\ninterface IERC314a {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event AddLiquidity(uint32 _blockToUnlockLiquidity, uint256 value);\\n    event RemoveLiquidity(uint256 value);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out\\n    );\\n}\\n\\ncontract Relief is IERC314a {\\n    mapping(address account => uint256) private _balances;\\n\\n    uint256 private _totalSupply;\\n    uint256 public _maxWallet;\\n    uint32 public blockToUnlockLiquidity;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    address public owner;\\n    address public liquidityProvider;\\n\\n    bool public tradingEnable;\\n    bool public liquidityAdded;\\n    bool public maxWalletEnable;\\n\\n    uint256 presaleAmount;\\n\\n    bool public presaleEnable = false;\\n\\n    mapping(address account => uint32) private lastTransaction;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyLiquidityProvider() {\\n        require(\\n            msg.sender == liquidityProvider,\\n            \\\"You are not the liquidity provider\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Sets the values for {name}, {symbol} and {totalSupply}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint256 tokensToLiq_,\\n        uint256 tokensToPresale_,\\n        uint256 maxWallet_\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _totalSupply = totalSupply_;\\n        _maxWallet = maxWallet_;\\n        owner = tx.origin;\\n        tradingEnable = false;\\n        maxWalletEnable = true;\\n        presaleAmount = tokensToPresale_;\\n        _balances[address(this)] = tokensToLiq_;\\n        _balances[tx.origin] = totalSupply_ - tokensToLiq_ - tokensToPresale_;\\n        liquidityAdded = false;\\n    }\\n\\n    /**\\n     * @dev Sends the presale amount to the investors\\n     */\\n    function presale(address[] memory _investors) public onlyOwner {\\n        require(presaleEnable == false, \\\"Presale already enabled\\\");\\n        uint256 _amount = presaleAmount / _investors.length;\\n        for (uint256 i = 0; i < _investors.length; i++) {\\n            _balances[_investors[i]] += _amount;\\n        }\\n        presaleEnable = true;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     */\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have a balance of at least `value`.\\n     * - if the receiver is the contract, the caller must send the amount of tokens to sell\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        // sell or transfer\\n        if (to == address(this)) {\\n            sell(value, 0);\\n        } else {\\n            _transfer(msg.sender, to, value);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively burns if `to` is the zero address.\\n     * All customizations to transfers and burns should be done by overriding this function.\\n     * This function includes MEV protection, which prevents the same address from making two transactions in the same block.(lastTransaction)\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal virtual {\\n        require(\\n            lastTransaction[msg.sender] != block.number,\\n            \\\"You can't make two transactions in the same block\\\"\\n        );\\n\\n        lastTransaction[msg.sender] = uint32(block.number);\\n\\n        require(\\n            _balances[from] >= value,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n\\n        unchecked {\\n            _balances[from] = _balances[from] - value;\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of ETH and tokens in the contract, used for trading.\\n     */\\n    function getReserves() public view returns (uint256, uint256) {\\n        return (address(this).balance, _balances[address(this)]);\\n    }\\n\\n    /**\\n     * @dev Enables or disables trading.\\n     * @param _tradingEnable: true to enable trading, false to disable trading.\\n     * onlyOwner modifier\\n     */\\n    function enableTrading(bool _tradingEnable) external onlyOwner {\\n        tradingEnable = _tradingEnable;\\n    }\\n\\n    /**\\n     * @dev Enables or disables the max wallet.\\n     * @param _maxWalletEnable: true to enable max wallet, false to disable max wallet.\\n     * onlyOwner modifier\\n     */\\n    function enableMaxWallet(bool _maxWalletEnable) external onlyOwner {\\n        maxWalletEnable = _maxWalletEnable;\\n    }\\n\\n    /**\\n     * @dev Sets the max wallet.\\n     * @param _maxWallet_: the new max wallet.\\n     * onlyOwner modifier\\n     */\\n    function setMaxWallet(uint256 _maxWallet_) external onlyOwner {\\n        _maxWallet = _maxWallet_;\\n    }\\n\\n    /**\\n     * @dev Transfers the ownership of the contract to zero address\\n     * onlyOwner modifier\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Adds liquidity to the contract.\\n     * @param _blockToUnlockLiquidity: the block number to unlock the liquidity.\\n     * value: the amount of ETH to add to the liquidity.\\n     * onlyOwner modifier\\n     */\\n    function addLiquidity(\\n        uint32 _blockToUnlockLiquidity\\n    ) public payable onlyOwner {\\n        require(liquidityAdded == false, \\\"Liquidity already added\\\");\\n\\n        liquidityAdded = true;\\n\\n        require(msg.value > 0, \\\"No ETH sent\\\");\\n        require(block.number < _blockToUnlockLiquidity, \\\"Block number too low\\\");\\n\\n        blockToUnlockLiquidity = _blockToUnlockLiquidity;\\n        liquidityProvider = msg.sender;\\n\\n        emit AddLiquidity(_blockToUnlockLiquidity, msg.value);\\n    }\\n\\n    function extendLock(uint32 _newBlockToUnlock) public onlyOwner{\\n        require(_newBlockToUnlock > blockToUnlockLiquidity, \\\"Dev would never do that, nice try kid\\\");\\n        blockToUnlockLiquidity = _newBlockToUnlock;\\n    }\\n\\n    /**\\n     * @dev Removes liquidity from the contract.\\n     * onlyLiquidityProvider modifier\\n     */\\n    function removeLiquidity() public onlyLiquidityProvider {\\n        require(block.number > blockToUnlockLiquidity, \\\"Liquidity locked\\\");\\n\\n        tradingEnable = false;\\n\\n        payable(msg.sender).transfer(address(this).balance);\\n\\n        emit RemoveLiquidity(address(this).balance);\\n    }\\n\\n    /**\\n     * @dev Extends the liquidity lock, only if the new block number is higher than the current one.\\n     * @param _blockToUnlockLiquidity: the new block number to unlock the liquidity.\\n     * onlyLiquidityProvider modifier\\n     */\\n    function extendLiquidityLock(\\n        uint32 _blockToUnlockLiquidity\\n    ) public onlyLiquidityProvider {\\n        require(\\n            blockToUnlockLiquidity < _blockToUnlockLiquidity,\\n            \\\"You can't shorten duration\\\"\\n        );\\n\\n        blockToUnlockLiquidity = _blockToUnlockLiquidity;\\n    }\\n\\n    /**\\n     * @dev Estimates the amount of tokens or ETH to receive when buying or selling.\\n     * @param value: the amount of ETH or tokens to swap.\\n     * @param _buy: true if buying, false if selling.\\n     */\\n    function getAmountOut(\\n        uint256 value,\\n        bool _buy\\n    ) public view returns (uint256) {\\n        (uint256 reserveETH, uint256 reserveToken) = getReserves();\\n\\n        if (_buy) {\\n            return (value * reserveToken) / (reserveETH + value);\\n        } else {\\n            return (value * reserveETH) / (reserveToken + value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Buys tokens with ETH.\\n     * internal function\\n     */\\n    function buy(uint256 _minAmount) public payable {\\n        require(tradingEnable, \\\"Trading not enable\\\");\\n\\n        uint256 token_amount = getAmountOut(msg.value, true);\\n\\n        if (maxWalletEnable) {\\n            require(\\n                token_amount + _balances[msg.sender] <= _maxWallet,\\n                \\\"Max wallet exceeded\\\"\\n            );\\n        }\\n\\n        _transfer(address(this), msg.sender, token_amount);\\n\\n        require(token_amount >= _minAmount, \\\"Slippage too high\\\");\\n\\n        emit Swap(msg.sender, msg.value, 0, 0, token_amount);\\n    }\\n\\n    /**\\n     * @dev Sells tokens for ETH.\\n     * internal function\\n     */\\n    function sell(uint256 _sellAmount, uint256 _minReceived) public payable {\\n        require(tradingEnable, \\\"Trading not enable\\\");\\n\\n        uint256 ethAmount = getAmountOut(_sellAmount, false);\\n\\n        require(ethAmount > 0, \\\"Sell amount too low\\\");\\n        require(\\n            address(this).balance >= ethAmount,\\n            \\\"Insufficient ETH in reserves\\\"\\n        );\\n\\n        _transfer(msg.sender, address(this), _sellAmount);\\n        require(ethAmount >= _minReceived, \\\"Slippage too high\\\");\\n        payable(msg.sender).transfer(ethAmount);\\n\\n        emit Swap(msg.sender, 0, _sellAmount, ethAmount, 0);\\n    }\\n\\n    receive() external payable {\\n        buy(0);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensToLiq_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensToPresale_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWallet_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_blockToUnlockLiquidity\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_blockToUnlockLiquidity\",\"type\":\"uint32\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockToUnlockLiquidity\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_maxWalletEnable\",\"type\":\"bool\"}],\"name\":\"enableMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradingEnable\",\"type\":\"bool\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_blockToUnlockLiquidity\",\"type\":\"uint32\"}],\"name\":\"extendLiquidityLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newBlockToUnlock\",\"type\":\"uint32\"}],\"name\":\"extendLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_buy\",\"type\":\"bool\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"presale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReceived\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWallet_\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Relief", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000d3c21bcecceda1000000000000000000000000000000000000000000000000005f4a8c8375d155400000000000000000000000000000000000000000000000005f4a8c8375d1554000000000000000000000000000000000000000000000000000878678326eac900000000000000000000000000000000000000000000000000000000000000000000652454c4945460000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000652454c4945460000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}