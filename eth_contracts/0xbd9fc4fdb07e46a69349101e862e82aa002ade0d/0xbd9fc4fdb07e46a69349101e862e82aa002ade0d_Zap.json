{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Zap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.23;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IWETH} from \\\"./interfaces/IWETH.sol\\\";\\nimport {IWeETH} from \\\"./interfaces/IWeETH.sol\\\";\\nimport {IWstETH} from \\\"./interfaces/IWstETH.sol\\\";\\nimport {ISimpleStakingERC20} from \\\"./interfaces/ISimpleStakingERC20.sol\\\";\\n\\ncontract Zap {\\n    IWETH public immutable weth;\\n    IERC20 public immutable eETH;\\n    IERC20 public immutable stETH;\\n    IWeETH public immutable weETH;\\n    IWstETH public immutable wstETH;\\n    ISimpleStakingERC20 public immutable stakingContract;\\n\\n    constructor(address payable _weth, address _wstETH, address _weETH, address _stakingContract) {\\n        weth = IWETH(_weth);\\n        weETH = IWeETH(_weETH);\\n        wstETH = IWstETH(_wstETH);\\n        eETH = IERC20(weETH.eETH());\\n        stETH = IERC20(wstETH.stETH());\\n        stakingContract = ISimpleStakingERC20(_stakingContract);\\n\\n        eETH.approve(address(weETH), type(uint256).max);\\n        weth.approve(_stakingContract, type(uint256).max);\\n        stETH.approve(address(wstETH), type(uint256).max);\\n        weETH.approve(address(stakingContract), type(uint256).max);\\n        wstETH.approve(address(stakingContract), type(uint256).max);\\n    }\\n\\n    function ethZapIn() external payable {\\n        if (msg.value == 0) revert ISimpleStakingERC20.AMOUNT_NULL();\\n        // Wrap ETH to wETH\\n        weth.deposit{value: msg.value}();\\n\\n        // Deposit wETH to staking contract\\n        stakingContract.deposit(IERC20(address(weth)), msg.value, msg.sender);\\n    }\\n\\n    function stETHZapIn(uint256 _amount) external {\\n        if (_amount == 0) revert ISimpleStakingERC20.AMOUNT_NULL();\\n        // Transfer stETH from msg.sender to this contract, sometimes 1 or 2 wei can be missing.\\n        stETH.transferFrom(msg.sender, address(this), _amount);\\n\\n        // Deposit wstETH to staking contract\\n        stakingContract.deposit(IERC20(address(wstETH)), wstETH.wrap(stETH.balanceOf(address(this))), msg.sender);\\n    }\\n\\n    function eETHZapIn(uint256 _amount) external {\\n        if (_amount == 0) revert ISimpleStakingERC20.AMOUNT_NULL();\\n        // Transfer eETH from msg.sender to this contract, sometimes 1 or 2 wei can be missing.\\n        eETH.transferFrom(msg.sender, address(this), _amount);\\n\\n        // Deposit eETH to staking contract\\n        stakingContract.deposit(IERC20(address(weETH)), weETH.wrap(eETH.balanceOf(address(this))), msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\r\\n     * caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `value` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.23;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(address, address, uint256) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWeETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.23;\\n\\ninterface IWeETH {\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function eETH() external view returns (address);\\n    function liquidityPool() external view returns (address);\\n    function wrap(uint256 _stETHAmount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWstETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.23;\\n\\ninterface IWstETH {\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\\n    function stETH() external view returns (address);\\n    function wrap(uint256 _stETHAmount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISimpleStakingERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.23;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ISimpleStakingERC20 {\\n    /// @notice Struct to hold the supported booleans\\n    /// @param deposit true if deposit is supported\\n    /// @param withdraw true if withdraw is supported\\n    struct Supported {\\n        bool deposit;\\n        bool withdraw;\\n    }\\n\\n    /// @notice Error emitted when the amount is null\\n    error AMOUNT_NULL();\\n\\n    /// @notice Error emitted when the address is null\\n    error ADDRESS_NULL();\\n\\n    /// @notice Error emitted when the balance is insufficient\\n    error INSUFFICIENT_BALANCE();\\n\\n    /// @notice Error emitted when the token is not allowed\\n    error TOKEN_NOT_ALLOWED(IERC20 token);\\n\\n    /// @notice Event emitted when a token is added or removed\\n    /// @param token address of the token\\n    /// @param supported struct with deposit and withdraw booleans\\n    event SupportedToken(IERC20 indexed token, Supported supported);\\n\\n    /// @notice Event emitted when a deposit is made\\n    /// @param token address of the token\\n    /// @param staker address of the staker\\n    /// @param amount amount of the deposit\\n    event Deposit(IERC20 indexed token, address indexed staker, uint256 amount);\\n\\n    /// @notice Event emitted when a withdrawal is made\\n    /// @param token address of the token\\n    /// @param staker address of the staker\\n    /// @param amount amount of the withdrawal\\n    event Withdraw(IERC20 indexed token, address indexed staker, uint256 amount);\\n\\n    /// @notice Method to deposit tokens\\n    /// @dev token are transferred from the sender, and the receiver is credited\\n    /// @param _token address of the token\\n    /// @param _amount amount to deposit\\n    /// @param _receiver address of the receiver\\n    function deposit(IERC20 _token, uint256 _amount, address _receiver) external;\\n\\n    /// @notice Method to rescue tokens, only callable by the owner\\n    /// @dev difference between balance and internal balance is transferred to the owner\\n    /// @param _token address of the token\\n    function rescueERC20(IERC20 _token) external;\\n\\n    /// @notice Method to add or remove a token\\n    /// @dev only callable by the owner\\n    /// @param _token address of the token\\n    /// @param _supported struct with deposit and withdraw booleans\\n    function supportToken(IERC20 _token, Supported calldata _supported) external;\\n\\n    /// @notice Method to rescue tokens, only callable by the owner\\n    /// @dev token are transferred to the receiver and sender is credited\\n    /// @param _token address of the token\\n    /// @param _amount amount to withdraw\\n    /// @param _receiver address of the receiver\\n    function withdraw(IERC20 _token, uint256 _amount, address _receiver) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wstETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AMOUNT_NULL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"eETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"eETHZapIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethZapIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stETHZapIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"contract ISimpleStakingERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weETH\",\"outputs\":[{\"internalType\":\"contract IWeETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wstETH\",\"outputs\":[{\"internalType\":\"contract IWstETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Zap", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000cd5fe23c85820f7b72d0926fc9b05b43e359b7ee00000000000000000000000038d43a6cb8da0e855a42fb6b0733a0498531d774", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}