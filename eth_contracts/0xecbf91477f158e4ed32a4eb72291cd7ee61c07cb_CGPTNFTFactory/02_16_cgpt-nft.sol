// SPDX-License-Identifier: UNLICENSED
/*
Generated by ChainGPT AI NFT app
www.ChainGPT.org

Disclaimer: This smart contract collection is independently created and not owned 
or associated with ChainGPT. It is important to note that the content of this 
collection has been solely generated by the AI tools provided through the ChainGPT 
platform. ChainGPT does not endorse or assume any responsibility for the accuracy,
reliability, or legality of the contents within this collection. Users are advised 
to exercise caution and conduct their own due diligence before engaging with this 
smart contract collection. By using this smart contract, you acknowledge and agree 
that ChainGPT is not liable for any damages or losses incurred as a result of your 
interactions with this collection.
*/

pragma solidity ^0.8.0;

import "./dependencies/ERC721.sol";
import "./dependencies/Ownable.sol";
import "./dependencies/ERC721Enumerable.sol";
import "./dependencies/Royalty.sol";
import "./dependencies/ReentrancyGuard.sol";

/**
 * @title ChainGPT NFT
 * @author Tammy
 * @notice NFT, ERC721
 * @custom:version 1.0.0
 * @custom:default-precision 0
 * @custom:simple-description ERC721 NFT that has been created by ChainGPT AI. 
 * @dev ERC721 NFT, including:
 *
 *  - Further Mintable Option.
 *  - Fixed maximum supply.
 *
 */

contract CGPTNFT is ERC721, ERC721Enumerable, Ownable, Royalty, ReentrancyGuard {
    string private _baseURIextended;
    bool public isMintable;

    uint256 public immutable MAX_SUPPLY;

    address private constant treasury = 0xbAcf170AF90A36Bd221D6EA5884Da7c1714210c1;
    uint256 private constant MINT_FEE = 0.00005 ether;
    
    mapping (uint256 => string) private _tokenURIs;

    /**
     * @param _name NFT Name
     * @param _symbol NFT Symbol
     * @param _uri Token URI used for metadata
     * @param maxSupply Maximum # of NFTs
     * @param tokenIDs The array of the NFTs to mint
     * @param _isMintable Further NFT mintable value
     * @param to The address the NFT mints
     */
    constructor(
        string memory _name,
        string memory _symbol,
        string memory _uri,
        uint256 maxSupply,
        uint256[] memory tokenIDs,
        bool _isMintable,
        address to
    ) ERC721(_name, _symbol) {
        _baseURIextended = _uri;
        MAX_SUPPLY = maxSupply;

        isMintable = _isMintable;

        require(tokenIDs.length <= MAX_SUPPLY, "Minted would exceed max tokens");

        for (uint256 i = 0; i < tokenIDs.length; i++) {
            _safeMint(to, tokenIDs[i]);
        }

        transferOwnership(to);
    }

    /**
     * @dev Mark the `disclaimer()` function as `pure` instead of `view`
     * since it doesn't read or modify any state variables
     */
    function disclaimer() external pure returns(string memory) {
        return "ChainGPT NFT";
    }

    /**
     * @dev An external method for users to mint one NFT in the future. Requires 
     * that the minted NFTs will not exceed the `MAX_SUPPLY`.
     * @param tokenID The TokenID of NFT to mint
     */
    function mint(uint256 tokenID) external payable nonReentrant onlyOwner {
        require(isMintable, "Mint is not enabled.");

        uint256 ts = totalSupply();

        require(ts + 1 <= MAX_SUPPLY, "Minted would exceed max tokens");

        require(msg.value >= MINT_FEE, "Insufficient payment");
        uint256 refundAmount = msg.value - MINT_FEE;

        _safeMint(msg.sender, tokenID);

        (bool sent, ) = treasury.call{value: MINT_FEE}("");
        require(sent, "Failed to send Ether to treasury address");
        
        // Refund remaining amount to user
        if (refundAmount > 0) {
            payable(msg.sender).transfer(refundAmount);
        }
    }

    /**
     * @dev An external method for users to mint many NFTs in the future. Requires 
     * that the minted NFTs will not exceed the `MAX_SUPPLY`.
     * @param tokenIDs The array of the NFTs to mint
     */
    function bulkMint(uint256[] memory tokenIDs) external payable nonReentrant onlyOwner {
        require(isMintable, "Mint is not enabled.");

        uint256 ts = totalSupply();

        require(ts + tokenIDs.length <= MAX_SUPPLY, "Minted would exceed max tokens");

        uint256 fee = MINT_FEE * tokenIDs.length;
        require(msg.value >= fee, "Insufficient payment");
        uint256 refundAmount = msg.value - fee;

        for (uint256 i = 0; i < tokenIDs.length; i++) {
            _safeMint(msg.sender, tokenIDs[i]);
        }
        
        (bool sent, ) = treasury.call{value: fee}("");
        require(sent, "Failed to send Ether to treasury address");

        // Refund remaining amount to user
        if (refundAmount > 0) {
            payable(msg.sender).transfer(refundAmount);
        }
    }
 
    /**
     * @dev Updates the baseURI that will be used to retrieve NFT metadata.
     * @param baseURI_ The baseURI to be used.
     */
    function setBaseURI(string memory baseURI_) external onlyOwner {
        _baseURIextended = baseURI_;
    }

    function baseURI() public view returns (string memory) {
        return _baseURIextended;
    }

    // Required Overrides

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseURIextended;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}