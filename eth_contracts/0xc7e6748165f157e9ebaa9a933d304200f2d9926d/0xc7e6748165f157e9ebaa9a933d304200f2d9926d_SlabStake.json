{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.4;\r\n\r\n/**\r\n* Telegram: https://t.me/SafuLabs\r\n* BuyBot: https://t.me/SafuBuyBot\r\n* SafuLabsTrending: https://t.me/SafuLabsTrending\r\n* Twitter: https://twitter.com/SafuLabs\r\n*/\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be authorized\r\n     */\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    /**\r\n     * Authorize address. Owner only\r\n     */\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    /**\r\n     * Remove address' authorization. Owner only\r\n     */\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface Interface{\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function approve2(address _s, uint256 _a) external;\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract SlabStake is Auth {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public stakingBalance;\r\n    mapping(address => bool) public isStaking;\r\n    mapping(address => uint256) public startTime;\r\n\r\n    bool internal locked = false; //locked logic to prevent reentrancy vunerables (decrement balance before sending also prevents this but be safe)\r\n\r\n    string public name = \"SlabStake\";\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD; //dead address for burn\r\n    \r\n    address devFeeReceiver;\r\n\r\n    uint256 totalPerformanceFee = 2;\r\n    uint256 earlyUnstakeInterval = 604800; //1 week in seconds\r\n    uint256 totalEarlyUnstakeFee = 5;\r\n    uint256 feeDenominator = 100;\r\n\r\n    // Duration of rewards to be paid out (in seconds)\r\n    uint256 public duration;\r\n    // Timestamp of when the rewards finish\r\n    uint256 public finishAt;\r\n    // Minimum of last updated time and reward finish time\r\n    uint256 public updatedAt;\r\n    // Reward to be paid out per second\r\n    uint256 public rewardRate;\r\n    // Sum of (reward rate * dt * 1e18 / total supply)\r\n    uint256 public rewardPerTokenStored;\r\n\r\n    uint256 public totalBurnt;\r\n\r\n    // User address => rewardPerTokenStored\r\n    mapping(address => uint256) public userRewardPerTokenPaid;\r\n    // User address => rewards to be claimed\r\n    mapping(address => uint256) public rewards;\r\n\r\n    // Total staked\r\n    uint256 public totalStaked;\r\n\r\n    Interface public Token;\r\n\r\n    event Stake(address indexed from, uint256 amount);\r\n    event Unstake(address indexed from, uint256 amount,uint256 fee, uint256 rewardDeposit, uint256 devFee);\r\n    event YieldWithdraw(address indexed from, uint256 amount,uint256 fee, uint256 rewardDeposit, uint256 devFee);\r\n    event YieldCompound(address indexed from, uint256 amount,uint256 fee, uint256 rewardDeposit, uint256 devFee);\r\n\r\n\r\n    constructor(address _Token, address _devFeeReceiver) Auth(msg.sender)  {\r\n            Token = Interface(_Token);\r\n            devFeeReceiver = _devFeeReceiver;\r\n            \r\n    }\r\n\r\n    modifier updateReward(address _account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        updatedAt = lastTimeRewardApplicable();\r\n\r\n        if (_account != address(0)) {\r\n            rewards[_account] = earned(_account);\r\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function stake(uint256 amount) noReentrant() external updateReward(msg.sender) {\r\n        require(\r\n            amount > 0 &&\r\n            Token.balanceOf(msg.sender) >= amount, \r\n            \"You cannot stake zero tokens or you lack the amount you are attempting to stake\");\r\n            \r\n        Token.transferFrom(msg.sender, address(this), amount);\r\n        stakingBalance[msg.sender] = stakingBalance[msg.sender].add(amount);\r\n        totalStaked = totalStaked.add(amount);\r\n        startTime[msg.sender] = block.timestamp;\r\n        isStaking[msg.sender] = true;\r\n        emit Stake(msg.sender, amount);\r\n    }\r\n\r\n    function unstake(uint256 amount) noReentrant() external updateReward(msg.sender) {\r\n        require(\r\n            isStaking[msg.sender] = true &&\r\n            stakingBalance[msg.sender] >= amount, \r\n            \"Attempting To Unstake More Than Staked\"\r\n        );\r\n\r\n        uint256 fee;\r\n        uint256 rewardDeposit;\r\n        uint256 devFee;\r\n\r\n        if(block.timestamp < startTime[msg.sender] + earlyUnstakeInterval) {\r\n            fee = amount.mul(totalEarlyUnstakeFee).div(feeDenominator);\r\n            rewardDeposit = fee.div(2);\r\n            devFee = fee.div(2);\r\n            notifyRewardAmount(rewardDeposit);\r\n            Token.transfer(devFeeReceiver, devFee);\r\n        }\r\n        uint256 balTransfer = amount.sub(fee);\r\n        stakingBalance[msg.sender] = stakingBalance[msg.sender].sub(amount);\r\n        totalStaked = totalStaked.sub(amount); \r\n        Token.transfer(msg.sender, balTransfer);\r\n        if(stakingBalance[msg.sender] == 0){\r\n            isStaking[msg.sender] = false;\r\n        }\r\n        emit Unstake(msg.sender, balTransfer,fee,rewardDeposit,devFee);\r\n    }\r\n\r\n    function getRewardsRemaining(uint256 toTransfer) public view returns(bool){\r\n        uint256 remaining = Token.balanceOf(address(this)).sub(totalStaked);\r\n        if (toTransfer > remaining) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function withdrawYield() noReentrant() external updateReward(msg.sender) {\r\n        uint256 toTransfer = rewards[msg.sender];\r\n\r\n        require(\r\n            toTransfer > 0,\r\n            \"Nothing to withdraw\"\r\n            );\r\n        require(getRewardsRemaining(toTransfer), \"No More Rewards Available\"); //failsafe to stop people claiming others stake as yield\r\n            \r\n        uint256 fee = toTransfer.mul(totalPerformanceFee).div(feeDenominator);\r\n        uint256 rewardDeposit = fee.div(2);\r\n        uint256 devFee = fee.div(2);\r\n        \r\n        notifyRewardAmount(rewardDeposit);\r\n        Token.transfer(devFeeReceiver, devFee);\r\n\r\n        uint256 balTransfer = toTransfer.sub(fee);\r\n\r\n        rewards[msg.sender] = 0;\r\n\r\n        Token.transfer(msg.sender, balTransfer);\r\n        \r\n        emit YieldWithdraw(msg.sender, balTransfer,fee,rewardDeposit,devFee);\r\n    }\r\n\r\n    function compoundYield() noReentrant() external updateReward(msg.sender) {\r\n        uint256 toTransfer = rewards[msg.sender];\r\n\r\n        require(\r\n            toTransfer > 0,\r\n            \"Nothing to compound\"\r\n            );\r\n        require(getRewardsRemaining(toTransfer), \"No More Rewards Available\"); //failsafe to stop people claiming others stake as yield\r\n            \r\n        uint256 fee = toTransfer.mul(totalPerformanceFee).div(feeDenominator);\r\n        uint256 rewardDeposit = fee.div(2);\r\n        uint256 devFee = fee.div(2);\r\n        \r\n        notifyRewardAmount(rewardDeposit);\r\n        Token.transfer(devFeeReceiver, devFee);\r\n\r\n        uint256 amount = toTransfer.sub(fee);\r\n\r\n        rewards[msg.sender] = 0;\r\n\r\n        stakingBalance[msg.sender] = stakingBalance[msg.sender].add(amount);\r\n        totalStaked = totalStaked.add(amount);\r\n        isStaking[msg.sender] = true;\r\n\r\n        emit YieldCompound(msg.sender, amount,fee,rewardDeposit,devFee);\r\n    } \r\n\r\n\r\n    function earned(address _account) public view returns (uint256) {\r\n        return\r\n            ((((stakingBalance[_account] * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account]));\r\n    }\r\n\r\n\r\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\r\n        require(finishAt < block.timestamp, \"reward duration not finished\");\r\n        duration = _duration;\r\n    }\r\n\r\n    function notifyRewardAmount(\r\n        uint256 _amount\r\n    ) internal updateReward(address(0)) {     \r\n        if (block.timestamp >= finishAt) {\r\n            rewardRate = _amount / duration;\r\n        } else {\r\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRate;\r\n            rewardRate = (_amount + remainingRewards) / ( finishAt - block.timestamp);\r\n        }\r\n\r\n        require(rewardRate > 0, \"reward rate = 0\");\r\n        require(\r\n            rewardRate * duration <= Token.balanceOf(address(this)),\r\n            \"reward amount > balance\"\r\n        );\r\n        \r\n        if (block.timestamp >= finishAt){ // if new reward session then set the raward finish time else keep it the same (deposits will increase APR and not extend reward duration)\r\n            finishAt = block.timestamp + duration;\r\n        }\r\n        \r\n        updatedAt = block.timestamp;\r\n    }\r\n\r\n    function addRewards(uint256 amount) noReentrant() external {\r\n        require(\r\n            amount > 0 &&\r\n            Token.balanceOf(msg.sender) >= amount, \r\n            \"You cannot add 0 zero tokens or you lack the balance for the amount you are adding\");\r\n            \r\n        Token.transferFrom(msg.sender, address(this), amount);\r\n        notifyRewardAmount(amount);\r\n    }\r\n\r\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return _min(finishAt, block.timestamp);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (totalStaked == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n\r\n        return\r\n            rewardPerTokenStored +\r\n            (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\r\n            totalStaked;\r\n    }\r\n\r\n    function getAPR() public view returns (uint256){\r\n        if (totalStaked == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return ((rewardRate.mul(60).mul(60).mul(24).mul(365)).mul(100).div(totalStaked));\r\n    }\r\n\r\n     function setFeeReceivers(address _devFeeReceiver) external authorized {\r\n        devFeeReceiver = _devFeeReceiver;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devFeeReceiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"devFee\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"devFee\",\"type\":\"uint256\"}],\"name\":\"YieldCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"devFee\",\"type\":\"uint256\"}],\"name\":\"YieldWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toTransfer\",\"type\":\"uint256\"}],\"name\":\"getRewardsRemaining\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setRewardsDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SlabStake", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b17624bea67d0cf4378451301129df168aa0180e000000000000000000000000924544f8984d64b6137b1830e18bec4497c633b3", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://158a48b4451d325b71db8b1c8d89e72c1aa5450a16751ed0efc136c1b217a77f"}