{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Comptroller/LiquityMath.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n\\n// SPDX-License-Identifier: MIT\\n\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\nlibrary LiquityMath {\\n  using SafeMath for uint;\\n\\n  uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n  /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n   *\\n   * - Making it \u201ctoo high\u201d could lead to overflows.\\n   * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\n   *\\n   * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\\n   * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n   *\\n   */\\n  uint internal constant NICR_PRECISION = 1e20;\\n\\n  function _min(uint _a, uint _b) internal pure returns (uint) {\\n    return (_a < _b) ? _a : _b;\\n  }\\n\\n  function _max(uint _a, uint _b) internal pure returns (uint) {\\n    return (_a >= _b) ? _a : _b;\\n  }\\n\\n  /*\\n   * Multiply two decimal numbers and use normal rounding rules:\\n   * -round product up if 19'th mantissa digit >= 5\\n   * -round product down if 19'th mantissa digit < 5\\n   *\\n   * Used only inside the exponentiation, _decPow().\\n   */\\n  function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n    uint prod_xy = x.mul(y);\\n\\n    decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\\n  }\\n\\n  /*\\n   * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n   *\\n   * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n   *\\n   * Called by two functions that represent time in units of minutes:\\n   * 1) TroveManager._calcDecayedBaseRate\\n   * 2) CommunityIssuance._getCumulativeIssuanceFraction\\n   *\\n   * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n   * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n   *\\n   * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n   * negligibly different from just passing the cap, since:\\n   *\\n   * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n   * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n   */\\n  function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n    if (_minutes > 525600000) {\\n      _minutes = 525600000;\\n    } // cap to avoid overflow\\n\\n    if (_minutes == 0) {\\n      return DECIMAL_PRECISION;\\n    }\\n\\n    uint y = DECIMAL_PRECISION;\\n    uint x = _base;\\n    uint n = _minutes;\\n\\n    // Exponentiation-by-squaring\\n    while (n > 1) {\\n      if (n % 2 == 0) {\\n        x = decMul(x, x);\\n        n = n.div(2);\\n      } else {\\n        // if (n % 2 != 0)\\n        y = decMul(x, y);\\n        x = decMul(x, x);\\n        n = (n.sub(1)).div(2);\\n      }\\n    }\\n\\n    return decMul(x, y);\\n  }\\n\\n  function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\\n    return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\\n  }\\n\\n  function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\\n    if (_debt > 0) {\\n      return _coll.mul(NICR_PRECISION).div(_debt);\\n    }\\n    // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n    else {\\n      // if (_debt == 0)\\n      return 2 ** 256 - 1;\\n    }\\n  }\\n\\n  function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\\n    if (_debt > 0) {\\n      uint newCollRatio = _coll.mul(_price).div(_debt);\\n\\n      return newCollRatio;\\n    }\\n    // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n    else {\\n      // if (_debt == 0)\\n      return 2 ** 256 - 1;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/CToken/CErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\nimport './CToken.sol';\\nimport '../Interfaces/ICErc20.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\nimport '../Interfaces/ITimelock.sol';\\nimport '../Interfaces/IEIP712.sol';\\nimport '../Interfaces/IEIP20NonStandard.sol';\\n\\n/**\\n * @title Compound's CErc20 Contract\\n * @notice CTokens which wrap an EIP-20 underlying\\n * @author Compound\\n */\\ncontract CErc20 is CToken, ICErc20, Initializable {\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /**\\n   * @notice Initialize the new money market\\n   * @param underlying_ The address of the underlying asset\\n   * @param comptroller_ The address of the Comptroller\\n   * @param interestRateModel_ The address of the interest rate model\\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n   * @param name_ ERC-20 name of this token\\n   * @param symbol_ ERC-20 symbol of this token\\n   * @param decimals_ ERC-20 decimal precision of this token\\n   * @param admin_ Address of the administrator of this token\\n   */\\n  function initialize(\\n    address underlying_,\\n    address comptroller_,\\n    address interestRateModel_,\\n    uint256 initialExchangeRateMantissa_,\\n    string memory name_,\\n    string memory symbol_,\\n    uint8 decimals_,\\n    address payable admin_\\n  ) public virtual initializer {\\n    // CToken initialize does the bulk of the work\\n    CToken.init(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_);\\n\\n    // Set underlying and sanity check it\\n    if (underlying_ == address(0)) {\\n      revert InvalidAddress();\\n    }\\n    underlying = underlying_;\\n  }\\n\\n  function initializeVersion2() public virtual reinitializer(2) onlyAdmin {}\\n\\n  /*** User Interface ***/\\n\\n  /**\\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param mintAmount The amount of the underlying asset to supply\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function mint(uint256 mintAmount) external override returns (uint256) {\\n    (uint256 err, ) = mintInternal(mintAmount);\\n    return err;\\n  }\\n\\n  /**\\n   * @notice Sender redeems cTokens in exchange for the underlying asset\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param redeemTokens The number of cTokens to redeem into underlying\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeem(uint256 redeemTokens) external override returns (uint256) {\\n    return redeemInternal(redeemTokens);\\n  }\\n\\n  /**\\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param redeemAmount The amount of underlying to redeem\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemUnderlying(uint256 redeemAmount) external override returns (uint256) {\\n    return redeemUnderlyingInternal(redeemAmount);\\n  }\\n\\n  /**\\n   * @notice Sender borrows assets from the protocol to their own address\\n   * @param borrowAmount The amount of the underlying asset to borrow\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function borrow(uint256 borrowAmount) external override returns (uint256) {\\n    return borrowInternal(borrowAmount);\\n  }\\n\\n  /**\\n   * @notice Sender repays their own borrow\\n   * @param repayAmount The amount to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function repayBorrow(uint256 repayAmount) external override returns (uint256) {\\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\\n    return err;\\n  }\\n\\n  /**\\n   * @notice Sender repays a borrow belonging to borrower\\n   * @param borrower the account with the debt being paid off\\n   * @param repayAmount The amount to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override returns (uint256) {\\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\\n    return err;\\n  }\\n\\n  /**\\n   * @notice The sender liquidates the borrowers collateral.\\n   *  The collateral seized is transferred to the liquidator.\\n   * @param borrower The borrower of this cToken to be liquidated\\n   * @param repayAmount The amount of the underlying borrowed asset to repay\\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function liquidateBorrow(\\n    address borrower,\\n    uint256 repayAmount,\\n    address cTokenCollateral\\n  ) external override returns (uint256) {\\n    (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\\n    return err;\\n  }\\n\\n  /**\\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n   * @param token The address of the ERC-20 token to sweep\\n   */\\n  function sweepToken(IEIP20NonStandard token) external override {\\n    if (address(token) == underlying) {\\n      revert CantSweepUnderlying();\\n    }\\n    uint256 underlyingBalanceBefore = ICToken(underlying).balanceOf(address(this));\\n    uint256 balance = token.balanceOf(address(this));\\n    token.transfer(admin, balance);\\n    uint256 underlyingBalanceAfter = ICToken(underlying).balanceOf(address(this));\\n    if (underlyingBalanceBefore != underlyingBalanceAfter) {\\n      revert UnderlyingBalanceError();\\n    }\\n  }\\n\\n  /**\\n   * @notice The sender adds to reserves.\\n   * @param addAmount The amount fo underlying token to add as reserves\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _addReserves(uint256 addAmount) external override returns (uint256) {\\n    return _addReservesInternal(addAmount);\\n  }\\n\\n  /*** Safe Token ***/\\n\\n  /**\\n   * @notice Gets balance of this contract in terms of the underlying\\n   * @dev This excludes the value of the current message, if any\\n   * @return The quantity of underlying tokens owned by this contract\\n   */\\n  function getCashPrior() internal view virtual override returns (uint256) {\\n    // ICToken token = ICToken(underlying);\\n    // return token.balanceOf(address(this));\\n    return underlyingBalance;\\n  }\\n\\n  /**\\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n   *      This will revert due to insufficient balance or insufficient allowance.\\n   *      This function returns the actual amount received,\\n   *      which may be less than `amount` if there is a fee attached to the transfer.\\n   *\\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n   */\\n  function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\\n    IEIP20NonStandard token = IEIP20NonStandard(underlying);\\n    uint256 balanceBefore = ICToken(underlying).balanceOf(address(this));\\n    token.transferFrom(from, address(this), amount);\\n\\n    bool success;\\n    assembly {\\n      switch returndatasize()\\n      case 0 {\\n        // This is a non-standard ERC-20\\n        success := not(0) // set success to true\\n      }\\n      case 32 {\\n        // This is a compliant ERC-20\\n        returndatacopy(0, 0, 32)\\n        success := mload(0) // Set `success = returndata` of external call\\n      }\\n      default {\\n        // This is an excessively non-compliant ERC-20, revert.\\n        revert(0, 0)\\n      }\\n    }\\n    if (!success) {\\n      revert TokenTransferInFailed();\\n    }\\n\\n    // Calculate the amount that was *actually* transferred\\n    uint256 balanceAfter = ICToken(underlying).balanceOf(address(this));\\n    if (balanceAfter < balanceBefore) {\\n      revert TokenTransferInFailed();\\n    }\\n    uint256 finalAmount = balanceAfter - balanceBefore;\\n    underlyingBalance += finalAmount;\\n    return finalAmount; // underflow already checked above, just subtract\\n  }\\n\\n  /**\\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n   *      it is >= amount, this should not revert in normal conditions.\\n   *\\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n   */\\n  function doTransferOut(address payable to, uint256 amount) internal virtual override {\\n    IEIP20NonStandard token = IEIP20NonStandard(underlying);\\n    token.transfer(to, amount);\\n    underlyingBalance -= amount;\\n\\n    bool success;\\n    assembly {\\n      switch returndatasize()\\n      case 0 {\\n        // This is a non-standard ERC-20\\n        success := not(0) // set success to true\\n      }\\n      case 32 {\\n        // This is a compliant ERC-20\\n        returndatacopy(0, 0, 32)\\n        success := mload(0) // Set `success = returndata` of external call\\n      }\\n      default {\\n        // This is an excessively non-compliant ERC-20, reveforceApprovert.\\n        revert(0, 0)\\n      }\\n    }\\n    if (!success) {\\n      revert TokenTransferOutFailed();\\n    }\\n  }\\n\\n  function transferToTimelock(bool isBorrow, address to, uint256 underlyAmount) internal virtual override {\\n    address timelock = IComptroller(comptroller).timelock();\\n    bytes memory data = abi.encodeWithSignature('consumeValue(uint256)', underlyAmount);\\n    (bool success, ) = timelock.call(data);\\n    if (success) {\\n      // ITimelock(timelock).consumeValue(underlyAmount);\\n      doTransferOut(payable(to), underlyAmount);\\n    } else {\\n      doTransferOut(payable(timelock), underlyAmount);\\n      ITimelock(timelock).createAgreement(\\n        isBorrow ? ITimelock.TimeLockActionType.BORROW : ITimelock.TimeLockActionType.REDEEM,\\n        underlyAmount,\\n        to\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param mintAmount The amount of the underlying asset to supply\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function mintWithPermit(uint256 mintAmount, uint256 deadline, bytes memory signature) external returns (uint256) {\\n    IEIP712(underlying).permit(msg.sender, address(this), mintAmount, deadline, signature);\\n    (uint256 err, ) = mintInternal(mintAmount);\\n    return err;\\n  }\\n\\n  /**\\n   * @notice Sender repays their own borrow\\n   * @param repayAmount The amount to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function repayBorrowWithPermit(\\n    uint256 repayAmount,\\n    uint256 deadline,\\n    bytes memory signature\\n  ) external returns (uint256) {\\n    IEIP712(underlying).permit(msg.sender, address(this), repayAmount, deadline, signature);\\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\\n    return err;\\n  }\\n\\n  function isCToken() public pure virtual override returns (bool) {\\n    return true;\\n  }\\n  function isCEther() external pure virtual override returns (bool) {\\n    return false;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/CToken/CToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport '../Interfaces/IComptroller.sol';\\nimport '../Interfaces/IPriceOracle.sol';\\nimport '../Interfaces/IInterestRateModel.sol';\\nimport './CTokenStorage.sol';\\nimport '../Exponential/ExponentialNoErrorNew.sol';\\nimport '../Comptroller/LiquityMath.sol';\\nimport '../SumerErrors.sol';\\n\\n/**\\n * @title Compound's CToken Contract\\n * @notice Abstract base for CTokens\\n * @author Compound\\n */\\nabstract contract CToken is CTokenStorage, ExponentialNoErrorNew, SumerErrors {\\n  /*** Market Events ***/\\n\\n  /**\\n   * @notice Event emitted when interest is accrued\\n   */\\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\\n\\n  /**\\n   * @notice Event emitted when tokens are minted\\n   */\\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\\n\\n  /**\\n   * @notice Event emitted when tokens are redeemed\\n   */\\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\\n\\n  /**\\n   * @notice Event emitted when underlying is borrowed\\n   */\\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n  /**\\n   * @notice Event emitted when a borrow is repaid\\n   */\\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n  /**\\n   * @notice Event emitted when a borrow is liquidated\\n   */\\n  event LiquidateBorrow(\\n    address liquidator,\\n    address borrower,\\n    uint256 repayAmount,\\n    address cTokenCollateral,\\n    uint256 seizeTokens\\n  );\\n\\n  /*** Admin Events ***/\\n\\n  /**\\n   * @notice Event emitted when pendingAdmin is changed\\n   */\\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n  /**\\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\n   */\\n  event NewAdmin(address oldAdmin, address newAdmin);\\n\\n  /**\\n   * @notice Event emitted when comptroller is changed\\n   */\\n  event NewComptroller(address oldComptroller, address newComptroller);\\n\\n  /**\\n   * @notice Event emitted when interestRateModel is changed\\n   */\\n  event NewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\\n\\n  /**\\n   * @notice Event emitted when the reserve factor is changed\\n   */\\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\\n\\n  /**\\n   * @notice Event emitted when the reserves are added\\n   */\\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\\n\\n  /**\\n   * @notice Event emitted when the reserves are reduced\\n   */\\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\\n\\n  /**\\n   * @notice EIP20 Transfer event\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n  /**\\n   * @notice EIP20 Approval event\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n  event NewDiscountRate(uint256 oldDiscountRateMantissa, uint256 newDiscountRateMantissa);\\n\\n  event RedeemFaceValue(\\n    address indexed redeemer,\\n    address indexed provider,\\n    uint256 repayAmount,\\n    address seizeToken,\\n    uint256 seizeAmount, // user seize amount + protocol seize amount\\n    uint256 redemptionRateMantissa\\n  );\\n\\n  modifier onlyAdmin() {\\n    // Check caller is admin\\n    if (msg.sender != admin) {\\n      revert OnlyAdmin();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Initialize the money market\\n   * @param comptroller_ The address of the Comptroller\\n   * @param interestRateModel_ The address of the interest rate model\\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n   * @param name_ EIP-20 name of this token\\n   * @param symbol_ EIP-20 symbol of this token\\n   * @param decimals_ EIP-20 decimal precision of this token\\n   */\\n  function init(\\n    address comptroller_,\\n    address interestRateModel_,\\n    uint256 initialExchangeRateMantissa_,\\n    string memory name_,\\n    string memory symbol_,\\n    uint8 decimals_,\\n    address payable _admin\\n  ) internal {\\n    admin = _admin;\\n    if (accrualBlockTimestamp != 0 || borrowIndex != 0) {\\n      revert MarketCanOnlyInitializeOnce(); // market may only be initialized once\\n    }\\n\\n    // Set initial exchange rate\\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n    if (initialExchangeRateMantissa <= 0) {\\n      revert InvalidExchangeRate();\\n    } // initial exchange rate must be greater than zero\\n\\n    discountRateMantissa = 1e18; // default to be 100%\\n    reserveFactorMantissa = 1e17; // default to be 10%\\n    // Set the comptroller\\n    // Set market's comptroller to newComptroller\\n    comptroller = comptroller_;\\n\\n    // Emit NewComptroller(oldComptroller, newComptroller)\\n    emit NewComptroller(address(0), comptroller_);\\n\\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n    accrualBlockTimestamp = getBlockTimestamp();\\n    borrowIndex = 1e18;\\n\\n    // Set the interest rate model (depends on block number / borrow index)\\n    interestRateModel = interestRateModel_;\\n    emit NewMarketInterestRateModel(address(0), interestRateModel_);\\n\\n    name = name_;\\n    symbol = symbol_;\\n    decimals = decimals_;\\n\\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n    _notEntered = true;\\n  }\\n\\n  /**\\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n   * @dev Called by both `transfer` and `transferFrom` internally\\n   * @param spender The address of the account performing the transfer\\n   * @param src The address of the source account\\n   * @param dst The address of the destination account\\n   * @param tokens The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\\n    /* Fail if transfer not allowed */\\n    IComptroller(comptroller).transferAllowed(address(this), src, dst, tokens);\\n\\n    /* Do not allow self-transfers */\\n    if (src == dst) {\\n      revert TransferNotAllowed();\\n    }\\n\\n    /* Get the allowance, infinite for the account owner */\\n    uint256 startingAllowance = 0;\\n    if (spender == src) {\\n      startingAllowance = ~uint256(0);\\n    } else {\\n      startingAllowance = transferAllowances[src][spender];\\n    }\\n\\n    /* Do the calculations, checking for {under,over}flow */\\n    uint allowanceNew = startingAllowance - tokens;\\n    uint srcTokensNew = accountTokens[src] - tokens;\\n    uint dstTokensNew = accountTokens[dst] + tokens;\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    accountTokens[src] = srcTokensNew;\\n    accountTokens[dst] = dstTokensNew;\\n\\n    /* Eat some of the allowance (if necessary) */\\n    if (startingAllowance != ~uint256(0)) {\\n      transferAllowances[src][spender] = allowanceNew;\\n    }\\n\\n    /* We emit a Transfer event */\\n    emit Transfer(src, dst, tokens);\\n\\n    // unused function\\n    // comptroller.transferVerify(address(this), src, dst, tokens);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\\n    return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(0);\\n  }\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `src` to `dst`\\n   * @param src The address of the source account\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\\n    return transferTokens(msg.sender, src, dst, amount) == uint256(0);\\n  }\\n\\n  /**\\n   * @notice Approve `spender` to transfer up to `amount` from `src`\\n   * @dev This will overwrite the approval amount for `spender`\\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n   * @param spender The address of the account which may transfer tokens\\n   * @param amount The number of tokens that are approved (-1 means infinite)\\n   * @return Whether or not the approval succeeded\\n   */\\n  function approve(address spender, uint256 amount) external override returns (bool) {\\n    address src = msg.sender;\\n    transferAllowances[src][spender] = amount;\\n    emit Approval(src, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Get the current allowance from `owner` for `spender`\\n   * @param owner The address of the account which owns the tokens to be spent\\n   * @param spender The address of the account which may transfer tokens\\n   * @return The number of tokens allowed to be spent (-1 means infinite)\\n   */\\n  function allowance(address owner, address spender) external view override returns (uint256) {\\n    return transferAllowances[owner][spender];\\n  }\\n\\n  /**\\n   * @notice Get the token balance of the `owner`\\n   * @param owner The address of the account to query\\n   * @return The number of tokens owned by `owner`\\n   */\\n  function balanceOf(address owner) external view override returns (uint256) {\\n    return accountTokens[owner];\\n  }\\n\\n  /**\\n   * @notice Get the underlying balance of the `owner`\\n   * @dev This also accrues interest in a transaction\\n   * @param owner The address of the account to query\\n   * @return The amount of underlying owned by `owner`\\n   */\\n  function balanceOfUnderlying(address owner) external override returns (uint256) {\\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n  }\\n\\n  /**\\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n   * @param account Address of the account to snapshot\\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n   */\\n  function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256, uint256) {\\n    return (\\n      accountTokens[account],\\n      borrowBalanceStoredInternal(account),\\n      exchangeRateStoredInternal(),\\n      discountRateMantissa\\n    );\\n  }\\n\\n  /**\\n   * @dev Function to simply retrieve block number\\n   *  This exists mainly for inheriting test contracts to stub this result.\\n   */\\n  function getBlockTimestamp() internal view returns (uint256) {\\n    return block.timestamp;\\n  }\\n\\n  /**\\n   * @notice Returns the current per-block borrow interest rate for this cToken\\n   * @return The borrow interest rate per block, scaled by 1e18\\n   */\\n  function borrowRatePerBlock() external view override returns (uint256) {\\n    return IInterestRateModel(interestRateModel).getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\n  }\\n\\n  /**\\n   * @notice Returns the current per-block supply interest rate for this cToken\\n   * @return The supply interest rate per block, scaled by 1e18\\n   */\\n  function supplyRatePerBlock() external view override returns (uint256) {\\n    return\\n      IInterestRateModel(interestRateModel).getSupplyRate(\\n        getCashPrior(),\\n        totalBorrows,\\n        totalReserves,\\n        reserveFactorMantissa\\n      );\\n  }\\n\\n  /**\\n   * @notice Returns the current total borrows plus accrued interest\\n   * @return The total borrows with interest\\n   */\\n  function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\\n    accrueInterest();\\n    return totalBorrows;\\n  }\\n\\n  /**\\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n   * @param account The address whose balance should be calculated after updating borrowIndex\\n   * @return The calculated balance\\n   */\\n  function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\\n    accrueInterest();\\n    return borrowBalanceStored(account);\\n  }\\n\\n  /**\\n   * @notice Return the borrow balance of account based on stored data\\n   * @param account The address whose balance should be calculated\\n   * @return The calculated balance\\n   */\\n  function borrowBalanceStored(address account) public view override returns (uint256) {\\n    return borrowBalanceStoredInternal(account);\\n  }\\n\\n  /**\\n   * @notice Return the borrow balance of account based on stored data\\n   * @param account The address whose balance should be calculated\\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\\n   */\\n  function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\\n    /* Get borrowBalance and borrowIndex */\\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n     */\\n    if (borrowSnapshot.principal == 0) {\\n      return 0;\\n    }\\n\\n    /* Calculate new borrow balance using the interest index:\\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n     */\\n    uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n    return principalTimesIndex / borrowSnapshot.interestIndex;\\n  }\\n\\n  /**\\n   * @notice Accrue interest then return the up-to-date exchange rate\\n   * @return Calculated exchange rate scaled by 1e18\\n   */\\n  function exchangeRateCurrent() public override nonReentrant returns (uint256) {\\n    accrueInterest();\\n    return exchangeRateStored();\\n  }\\n\\n  /**\\n   * @notice Calculates the exchange rate from the underlying to the CToken\\n   * @dev This function does not accrue interest before calculating the exchange rate\\n   * @return Calculated exchange rate scaled by 1e18\\n   */\\n  function exchangeRateStored() public view override returns (uint256) {\\n    return exchangeRateStoredInternal();\\n  }\\n\\n  /**\\n   * @notice Calculates the exchange rate from the underlying to the CToken\\n   * @dev This function does not accrue interest before calculating the exchange rate\\n   * @return (error code, calculated exchange rate scaled by 1e18)\\n   */\\n  function exchangeRateStoredInternal() internal view returns (uint256) {\\n    if (!isCToken()) {\\n      return initialExchangeRateMantissa;\\n    }\\n\\n    uint _totalSupply = totalSupply;\\n    if (_totalSupply == 0) {\\n      /*\\n       * If there are no tokens minted:\\n       *  exchangeRate = initialExchangeRate\\n       */\\n      return initialExchangeRateMantissa;\\n    } else {\\n      /*\\n       * Otherwise:\\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n       */\\n      uint totalCash = getCashPrior();\\n      uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\\n      uint exchangeRate = (cashPlusBorrowsMinusReserves * expScale) / _totalSupply;\\n\\n      return exchangeRate;\\n    }\\n  }\\n\\n  /**\\n   * @notice Get cash balance of this cToken in the underlying asset\\n   * @return The quantity of underlying asset owned by this contract\\n   */\\n  function getCash() external view override returns (uint256) {\\n    return getCashPrior();\\n  }\\n\\n  /**\\n   * @notice Applies accrued interest to total borrows and reserves\\n   * @dev This calculates interest accrued from the last checkpointed block\\n   *   up to the current block and writes new checkpoint to storage.\\n   */\\n  function accrueInterest() public virtual override returns (uint256) {\\n    /* Remember the initial block number */\\n    uint256 currentBlockTimestamp = getBlockTimestamp();\\n    uint256 accrualBlockTimestampPrior = accrualBlockTimestamp;\\n\\n    /* Short-circuit accumulating 0 interest */\\n    if (accrualBlockTimestampPrior == currentBlockTimestamp) {\\n      return uint256(0);\\n    }\\n\\n    /* Read the previous values out of storage */\\n    uint256 cashPrior = getCashPrior();\\n    uint256 borrowsPrior = totalBorrows;\\n    uint256 reservesPrior = totalReserves;\\n    uint256 borrowIndexPrior = borrowIndex;\\n\\n    /* Calculate the current borrow interest rate */\\n    uint borrowRateMantissa = IInterestRateModel(interestRateModel).getBorrowRate(\\n      cashPrior,\\n      borrowsPrior,\\n      reservesPrior\\n    );\\n    // require(borrowRateMantissa <= borrowRateMaxMantissa, 'borrow rate is absurdly high');\\n\\n    /* Calculate the number of blocks elapsed since the last accrual */\\n    uint blockDelta = currentBlockTimestamp - accrualBlockTimestampPrior;\\n\\n    /*\\n     * Calculate the interest accumulated into borrows and reserves and the new index:\\n     *  simpleInterestFactor = borrowRate * blockDelta\\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n     */\\n\\n    Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n    uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n    uint totalBorrowsNew = interestAccumulated + borrowsPrior;\\n    uint totalReservesNew = mul_ScalarTruncateAddUInt(\\n      Exp({mantissa: reserveFactorMantissa}),\\n      interestAccumulated,\\n      reservesPrior\\n    );\\n    uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We write the previously calculated values into storage */\\n    accrualBlockTimestamp = currentBlockTimestamp;\\n    borrowIndex = borrowIndexNew;\\n    totalBorrows = totalBorrowsNew;\\n    totalReserves = totalReservesNew;\\n\\n    /* We emit an AccrueInterest event */\\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param mintAmount The amount of the underlying asset to supply\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\n   */\\n  function mintInternal(uint256 mintAmount) internal nonReentrant returns (uint256, uint256) {\\n    accrueInterest();\\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n    return mintFresh(msg.sender, mintAmount, true);\\n  }\\n\\n  /**\\n   * @notice User supplies assets into the market and receives cTokens in exchange\\n   * @dev Assumes interest has already been accrued up to the current block\\n   * @param minter The address of the account which is supplying the assets\\n   * @param mintAmount The amount of the underlying asset to supply\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\n   */\\n  function mintFresh(address minter, uint256 mintAmount, bool doTransfer) internal returns (uint256, uint256) {\\n    /* Fail if mint not allowed */\\n    IComptroller(comptroller).mintAllowed(address(this), minter, mintAmount);\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert MintMarketNotFresh();\\n    }\\n\\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     *  We call `doTransferIn` for the minter and the mintAmount.\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n     *  side-effects occurred. The function returns the amount actually transferred,\\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\\n     *  of cash.\\n     */\\n    uint actualMintAmount;\\n    if (doTransfer) {\\n      actualMintAmount = doTransferIn(minter, mintAmount);\\n    } else {\\n      actualMintAmount = mintAmount;\\n      underlyingBalance += mintAmount;\\n    }\\n\\n    /*\\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\\n     *  mintTokens = actualMintAmount / exchangeRate\\n     */\\n\\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n    /*\\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\n     *  totalSupplyNew = totalSupply + mintTokens\\n     *  accountTokensNew = accountTokens[minter] + mintTokens\\n     */\\n    totalSupply = totalSupply + mintTokens;\\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\\n\\n    /* We emit a Mint event, and a Transfer event */\\n    emit Mint(minter, actualMintAmount, mintTokens);\\n    emit Transfer(address(this), minter, mintTokens);\\n\\n    /* We call the defense hook */\\n    // unused function\\n    // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\\n\\n    return (uint256(0), actualMintAmount);\\n  }\\n\\n  /**\\n   * @notice Sender redeems cTokens in exchange for the underlying asset\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param redeemTokens The number of cTokens to redeem into underlying\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant returns (uint256) {\\n    accrueInterest();\\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n    return redeemFresh(payable(msg.sender), redeemTokens, 0, true);\\n  }\\n\\n  /**\\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant returns (uint256) {\\n    accrueInterest();\\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n    return redeemFresh(payable(msg.sender), 0, redeemAmount, true);\\n  }\\n\\n  /**\\n   * @notice User redeems cTokens in exchange for the underlying asset\\n   * @dev Assumes interest has already been accrued up to the current block\\n   * @param redeemer The address of the account which is redeeming the tokens\\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n   * @param checkTimelock true=check timelock, false=direct transfer\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemFresh(\\n    address payable redeemer,\\n    uint256 redeemTokensIn,\\n    uint256 redeemAmountIn,\\n    bool checkTimelock\\n  ) internal returns (uint256) {\\n    if (redeemTokensIn != 0 && redeemAmountIn != 0) {\\n      revert TokenInOrAmountInMustBeZero();\\n    }\\n\\n    /* exchangeRate = invoke Exchange Rate Stored() */\\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n\\n    uint redeemTokens;\\n    uint redeemAmount;\\n    /* If redeemTokensIn > 0: */\\n    if (redeemTokensIn > 0) {\\n      /*\\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\\n       *  redeemTokens = redeemTokensIn\\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n       */\\n      redeemTokens = redeemTokensIn;\\n      redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\\n    } else {\\n      /*\\n       * We get the current exchange rate and calculate the amount to be redeemed:\\n       *  redeemTokens = redeemAmountIn / exchangeRate\\n       *  redeemAmount = redeemAmountIn\\n       */\\n\\n      redeemTokens = div_(redeemAmountIn, exchangeRate);\\n      redeemAmount = redeemAmountIn;\\n    }\\n\\n    /* Fail if redeem not allowed */\\n    IComptroller(comptroller).redeemAllowed(address(this), redeemer, redeemTokens);\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert RedeemMarketNotFresh();\\n    }\\n\\n    /* Fail gracefully if protocol has insufficient cash */\\n    if (isCToken() && (getCashPrior() < redeemAmount)) {\\n      revert RedeemTransferOutNotPossible();\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We write previously calculated values into storage */\\n    totalSupply = totalSupply - redeemTokens;\\n    accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\\n\\n    /*\\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken has redeemAmount less of cash.\\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n     */\\n    // doTransferOut(redeemer, vars.redeemAmount);\\n    if (checkTimelock) {\\n      transferToTimelock(false, redeemer, redeemAmount);\\n    } else {\\n      doTransferOut(redeemer, redeemAmount);\\n    }\\n\\n    /* We emit a Transfer event, and a Redeem event */\\n    emit Transfer(redeemer, address(this), redeemTokens);\\n    emit Redeem(redeemer, redeemAmount, redeemTokens);\\n\\n    /* We call the defense hook */\\n    // IComptroller(comptroller).redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Sender borrows assets from the protocol to their own address\\n   * @param borrowAmount The amount of the underlying asset to borrow\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\\n    accrueInterest();\\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n    return borrowFresh(payable(msg.sender), borrowAmount, true);\\n  }\\n\\n  /**\\n   * @notice Users borrow assets from the protocol to their own address\\n   * @param borrowAmount The amount of the underlying asset to borrow\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function borrowFresh(address payable borrower, uint256 borrowAmount, bool doTransfer) internal returns (uint256) {\\n    /* Fail if borrow not allowed */\\n    IComptroller(comptroller).borrowAllowed(address(this), borrower, borrowAmount);\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert BorrowMarketNotFresh();\\n    }\\n\\n    /* Fail gracefully if protocol has insufficient underlying cash */\\n    if (isCToken() && (getCashPrior() < borrowAmount)) {\\n      revert BorrowCashNotAvailable();\\n    }\\n\\n    /*\\n     * We calculate the new borrower and total borrow balances, failing on overflow:\\n     *  accountBorrowsNew = accountBorrows + borrowAmount\\n     *  totalBorrowsNew = totalBorrows + borrowAmount\\n     */\\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n    uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n    uint totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We write the previously calculated values into storage */\\n    accountBorrows[borrower].principal = accountBorrowsNew;\\n    accountBorrows[borrower].interestIndex = borrowIndex;\\n    totalBorrows = totalBorrowsNew;\\n\\n    /*\\n     * We invoke doTransferOut for the borrower and the borrowAmount.\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken borrowAmount less of cash.\\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n     */\\n    // doTransferOut(borrower, borrowAmount);\\n\\n    if (doTransfer) {\\n      transferToTimelock(true, borrower, borrowAmount);\\n    } else {\\n      underlyingBalance -= borrowAmount;\\n    }\\n\\n    /* We emit a Borrow event */\\n    emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n    /* We call the defense hook */\\n    IComptroller(comptroller).borrowVerify(borrower, borrowAmount);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Sender repays their own borrow\\n   * @param repayAmount The amount to repay\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n   */\\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256, uint256) {\\n    accrueInterest();\\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n  }\\n\\n  /**\\n   * @notice Sender repays a borrow belonging to borrower\\n   * @param borrower the account with the debt being paid off\\n   * @param repayAmount The amount to repay\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n   */\\n  function repayBorrowBehalfInternal(\\n    address borrower,\\n    uint256 repayAmount\\n  ) internal nonReentrant returns (uint256, uint256) {\\n    accrueInterest();\\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\\n  }\\n\\n  /**\\n   * @notice Borrows are repaid by another user (possibly the borrower).\\n   * @param payer the account paying off the borrow\\n   * @param borrower the account with the debt being paid off\\n   * @param repayAmount the amount of underlying tokens being returned\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n   */\\n  function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256, uint256) {\\n    /* Fail if repayBorrow not allowed */\\n    IComptroller(comptroller).repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert RepayBorrowMarketNotFresh();\\n    }\\n\\n    /* We remember the original borrowerIndex for verification purposes */\\n    // uint256 borrowerIndex = accountBorrows[borrower].interestIndex;\\n\\n    /* We fetch the amount the borrower owes, with accumulated interest */\\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n\\n    /* If repayAmount == -1, repayAmount = accountBorrows */\\n    uint repayAmountFinal = LiquityMath._min(repayAmount, accountBorrowsPrev);\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     * We call doTransferIn for the payer and the repayAmount\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken holds an additional repayAmount of cash.\\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n     *   it returns the amount actually transferred, in case of a fee.\\n     */\\n    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\\n\\n    /*\\n     * We calculate the new borrower and total borrow balances, failing on underflow:\\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n     */\\n    uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n    uint totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n    /* We write the previously calculated values into storage */\\n    accountBorrows[borrower].principal = accountBorrowsNew;\\n    accountBorrows[borrower].interestIndex = borrowIndex;\\n    totalBorrows = totalBorrowsNew;\\n\\n    /* We emit a RepayBorrow event */\\n    emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n    /* We call the defense hook */\\n    // IComptroller(comptroller).repayBorrowVerify(address(this), payer, borrower, actualRepayAmount, borrowerIndex);\\n\\n    return (uint256(0), actualRepayAmount);\\n  }\\n\\n  /**\\n   * @notice The sender liquidates the borrowers collateral.\\n   *  The collateral seized is transferred to the liquidator.\\n   * @param borrower The borrower of this cToken to be liquidated\\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\\n   * @param repayAmount The amount of the underlying borrowed asset to repay\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n   */\\n  function liquidateBorrowInternal(\\n    address borrower,\\n    uint256 repayAmount,\\n    address cTokenCollateral\\n  ) internal nonReentrant returns (uint256, uint256) {\\n    accrueInterest();\\n    ICToken(cTokenCollateral).accrueInterest();\\n\\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n    return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\\n  }\\n\\n  /**\\n   * @notice The liquidator liquidates the borrowers collateral.\\n   *  The collateral seized is transferred to the liquidator.\\n   * @param borrower The borrower of this cToken to be liquidated\\n   * @param liquidator The address repaying the borrow and seizing collateral\\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\\n   * @param repayAmount The amount of the underlying borrowed asset to repay\\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n   */\\n  function liquidateBorrowFresh(\\n    address liquidator,\\n    address borrower,\\n    uint256 repayAmount,\\n    address cTokenCollateral\\n  ) internal returns (uint256, uint256) {\\n    /* Fail if liquidate not allowed */\\n    IComptroller(comptroller).liquidateBorrowAllowed(\\n      address(this),\\n      address(cTokenCollateral),\\n      liquidator,\\n      borrower,\\n      repayAmount\\n    );\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert LiquidateMarketNotFresh();\\n    }\\n\\n    /* Verify cTokenCollateral market's block number equals current block number */\\n    if (ICToken(cTokenCollateral).accrualBlockTimestamp() != getBlockTimestamp()) {\\n      revert LiquidateCollateralMarketNotFresh();\\n    }\\n\\n    /* Fail if borrower = liquidator */\\n    if (borrower == liquidator) {\\n      revert LiquidateBorrow_LiquidatorIsBorrower();\\n    }\\n\\n    /* Fail if repayAmount = 0 */\\n    if (repayAmount == 0) {\\n      revert LiquidateBorrow_RepayAmountIsZero();\\n    }\\n\\n    if (repayAmount == ~uint256(0)) {\\n      revert LiquidateBorrow_RepayAmountIsMax();\\n    }\\n\\n    /* Fail if repayBorrow fails */\\n    (, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We calculate the number of collateral tokens that will be seized */\\n    (, uint256 seizeTokens, uint256 seizeProfitTokens) = liquidateCalculateSeizeTokens(\\n      cTokenCollateral,\\n      actualRepayAmount\\n    );\\n\\n    /* Revert if borrower collateral token balance < seizeTokens */\\n    if (ICToken(cTokenCollateral).balanceOf(borrower) < seizeTokens) {\\n      revert LiquidateBorrow_SeizeTooMuch();\\n    }\\n\\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\n    if (cTokenCollateral == address(this)) {\\n      seizeInternal(address(this), liquidator, borrower, seizeTokens, seizeProfitTokens, false, uint256(0));\\n    } else {\\n      ICToken(cTokenCollateral).seize(liquidator, borrower, seizeTokens, seizeProfitTokens, false, uint256(0));\\n    }\\n\\n    /* We emit a LiquidateBorrow event */\\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\\n\\n    /* We call the defense hook */\\n    // unused function\\n    // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\\n\\n    return (uint256(0), actualRepayAmount);\\n  }\\n\\n  /**\\n   * @notice Transfers collateral tokens (this market) to the liquidator.\\n   * @dev Will fail unless called by another cToken during the process of liquidation.\\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n   * @param liquidator The account receiving seized collateral\\n   * @param borrower The account having collateral seized\\n   * @param seizeTokens The number of cTokens to seize in total (including profit)\\n   * @param seizeProfitTokens The number of cToken to seize as profit\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function seize(\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens,\\n    uint256 seizeProfitTokens,\\n    bool isRedemption,\\n    uint256 redemptionRateMantissa\\n  ) external override nonReentrant returns (uint256) {\\n    if (redemptionRateMantissa <= 0) {\\n      redemptionRateMantissa = 0;\\n    }\\n    if (redemptionRateMantissa > expScale) {\\n      redemptionRateMantissa = expScale;\\n    }\\n\\n    return\\n      seizeInternal(\\n        msg.sender,\\n        liquidator,\\n        borrower,\\n        seizeTokens,\\n        seizeProfitTokens,\\n        isRedemption,\\n        redemptionRateMantissa\\n      );\\n  }\\n\\n  /**\\n   * @notice Transfers collateral tokens (this market) to the liquidator.\\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\\n   * @param liquidator The account receiving seized collateral\\n   * @param borrower The account having collateral seized\\n   * @param seizeTokens The number of cTokens to seize\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function seizeInternal(\\n    address seizerToken,\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens,\\n    uint256 seizeProfitTokens,\\n    bool isRedemption,\\n    uint256 redemptionRateMantissa\\n  ) internal returns (uint256) {\\n    /* Fail if seize not allowed */\\n    IComptroller(comptroller).seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n\\n    /* Fail if borrower = liquidator */\\n    if (borrower == liquidator) {\\n      revert Seize_LiquidatorIsBorrower();\\n    }\\n\\n    /*\\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n     */\\n    uint protocolSeizeTokens;\\n    if (isRedemption) {\\n      // redemption: protocol seize = total seize * redemptionRate\\n      protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: redemptionRateMantissa}));\\n    } else {\\n      // liquidation: protocol seize = profit * liquidatiionShare 30%\\n      protocolSeizeTokens = mul_(seizeProfitTokens, Exp({mantissa: protocolSeizeShareMantissa}));\\n    }\\n    if (seizeTokens < protocolSeizeTokens) {\\n      revert NotEnoughForSeize();\\n    }\\n\\n    uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n    uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n    uint totalReservesNew = totalReserves + protocolSeizeAmount;\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We write the previously calculated values into storage */\\n    totalReserves = totalReservesNew;\\n    totalSupply = totalSupply - protocolSeizeTokens;\\n    accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n    accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n    /* Emit a Transfer event */\\n    emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n    emit Transfer(borrower, address(this), protocolSeizeTokens);\\n    emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\\n\\n    /* We call the defense hook */\\n    // unused function\\n    // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n\\n    if (isRedemption) {\\n      redeemFresh(payable(liquidator), liquidatorSeizeTokens, uint256(0), true);\\n    } else {\\n      redeemFresh(payable(liquidator), liquidatorSeizeTokens, uint256(0), false);\\n    }\\n\\n    return uint256(0);\\n  }\\n\\n  /*** Admin Functions ***/\\n\\n  /**\\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @param newPendingAdmin New pending admin.\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setPendingAdmin(address payable newPendingAdmin) external override onlyAdmin returns (uint256) {\\n    // Save current value, if any, for inclusion in log\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    // Store pendingAdmin with value newPendingAdmin\\n    if (newPendingAdmin == address(0)) {\\n      revert InvalidAddress();\\n    } // Address is Zero\\n    pendingAdmin = newPendingAdmin;\\n\\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n   * @dev Admin function for pending admin to accept role and update admin\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _acceptAdmin() external override returns (uint256) {\\n    // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n      revert OnlyPendingAdmin();\\n    }\\n\\n    // Save current values for inclusion in log\\n    address oldAdmin = admin;\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    // Store admin with value pendingAdmin\\n    admin = pendingAdmin;\\n\\n    // Clear the pending value\\n    pendingAdmin = payable(0);\\n\\n    emit NewAdmin(oldAdmin, admin);\\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Sets a new comptroller for the market\\n   * @dev Admin function to set a new comptroller\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setComptroller(address newComptroller) public override onlyAdmin returns (uint256) {\\n    address oldComptroller = comptroller;\\n    // Ensure invoke comptroller.isComptroller() returns true\\n    if (!IComptroller(newComptroller).isComptroller()) {\\n      revert InvalidComptroller(); // market method returned false\\n    }\\n\\n    // Set market's comptroller to newComptroller\\n    comptroller = newComptroller;\\n\\n    // Emit NewComptroller(oldComptroller, newComptroller)\\n    emit NewComptroller(oldComptroller, newComptroller);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n   * @dev Admin function to accrue interest and set a new reserve factor\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant returns (uint256) {\\n    accrueInterest();\\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n    return _setReserveFactorFresh(newReserveFactorMantissa);\\n  }\\n\\n  /**\\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n   * @dev Admin function to set a new reserve factor\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal onlyAdmin returns (uint256) {\\n    // Verify market's block number equals current block number\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert SetReservesFactorMarketNotFresh();\\n    }\\n\\n    // Check newReserveFactor \u2264 maxReserveFactor\\n    if (newReserveFactorMantissa > RESERVE_FACTOR_MAX_MANTISSA) {\\n      revert InvalidReserveFactor();\\n    }\\n\\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\\n    reserveFactorMantissa = newReserveFactorMantissa;\\n\\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice Accrues interest and reduces reserves by transferring from msg.sender\\n   * @param addAmount Amount of addition to reserves\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _addReservesInternal(uint256 addAmount) internal nonReentrant returns (uint256) {\\n    accrueInterest();\\n    // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\n    (uint256 error, ) = _addReservesFresh(addAmount);\\n    return error;\\n  }\\n\\n  /**\\n   * @notice Add reserves by transferring from caller\\n   * @dev Requires fresh interest accrual\\n   * @param addAmount Amount of addition to reserves\\n   * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\n   */\\n  function _addReservesFresh(uint256 addAmount) internal returns (uint256, uint256) {\\n    // totalReserves + actualAddAmount\\n    uint256 totalReservesNew;\\n    uint256 actualAddAmount;\\n\\n    // We fail gracefully unless market's block number equals current block number\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert AddReservesMarketNotFresh();\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     * We call doTransferIn for the caller and the addAmount\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken holds an additional addAmount of cash.\\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n     *  it returns the amount actually transferred, in case of a fee.\\n     */\\n\\n    actualAddAmount = doTransferIn(msg.sender, addAmount);\\n\\n    totalReservesNew = totalReserves + actualAddAmount;\\n\\n    /* Revert on overflow */\\n    if (totalReservesNew < totalReserves) {\\n      revert AddReservesOverflow();\\n    }\\n\\n    // Store reserves[n+1] = reserves[n] + actualAddAmount\\n    totalReserves = totalReservesNew;\\n\\n    /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\n    emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n    /* Return (NO_ERROR, actualAddAmount) */\\n    return (uint256(0), actualAddAmount);\\n  }\\n\\n  /**\\n   * @notice Accrues interest and reduces reserves by transferring to admin\\n   * @param reduceAmount Amount of reduction to reserves\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _reduceReserves(uint256 reduceAmount) external override nonReentrant returns (uint256) {\\n    accrueInterest();\\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n    return _reduceReservesFresh(reduceAmount);\\n  }\\n\\n  /**\\n   * @notice Reduces reserves by transferring to admin\\n   * @dev Requires fresh interest accrual\\n   * @param reduceAmount Amount of reduction to reserves\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _reduceReservesFresh(uint256 reduceAmount) internal onlyAdmin returns (uint256) {\\n    // totalReserves - reduceAmount\\n    uint256 totalReservesNew;\\n\\n    // We fail gracefully unless market's block number equals current block number\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert ReduceReservesMarketNotFresh();\\n    }\\n\\n    // Fail gracefully if protocol has insufficient underlying cash\\n    if (getCashPrior() < reduceAmount) {\\n      revert ReduceReservesCashNotAvailable();\\n    }\\n\\n    // Check reduceAmount \u2264 reserves[n] (totalReserves)\\n    if (reduceAmount > totalReserves) {\\n      revert InvalidReduceAmount();\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    totalReservesNew = totalReserves - reduceAmount;\\n\\n    // Store reserves[n+1] = reserves[n] - reduceAmount\\n    totalReserves = totalReservesNew;\\n\\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n    doTransferOut(admin, reduceAmount);\\n\\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\n\\n    return uint256(0);\\n  }\\n\\n  /**\\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n   * @dev Admin function to accrue interest and update the interest rate model\\n   * @param newInterestRateModel the new interest rate model to use\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setInterestRateModel(address newInterestRateModel) public override returns (uint256) {\\n    accrueInterest();\\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n    return _setInterestRateModelFresh(newInterestRateModel);\\n  }\\n\\n  /**\\n   * @notice updates the interest rate model (*requires fresh interest accrual)\\n   * @dev Admin function to update the interest rate model\\n   * @param newInterestRateModel the new interest rate model to use\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setInterestRateModelFresh(address newInterestRateModel) internal onlyAdmin returns (uint256) {\\n    // Used to store old model for use in the event that is emitted on success\\n    address oldInterestRateModel;\\n    // We fail gracefully unless market's block number equals current block number\\n    if (accrualBlockTimestamp != getBlockTimestamp()) {\\n      revert SetInterestRateModelMarketNotFresh();\\n    }\\n\\n    // Track the market's current interest rate model\\n    oldInterestRateModel = interestRateModel;\\n\\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n    if (!IInterestRateModel(interestRateModel).isInterestRateModel()) {\\n      revert InvalidInterestRateModel();\\n    }\\n\\n    // Set the interest rate model to newInterestRateModel\\n    interestRateModel = newInterestRateModel;\\n\\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n    return uint256(0);\\n  }\\n\\n  function _syncUnderlyingBalance() external virtual onlyAdmin {\\n    underlyingBalance = ICToken(underlying).balanceOf(address(this));\\n  }\\n\\n  /*** Safe Token ***/\\n\\n  /**\\n   * @notice Gets balance of this contract in terms of the underlying\\n   * @dev This excludes the value of the current message, if any\\n   * @return The quantity of underlying owned by this contract\\n   */\\n  function getCashPrior() internal view virtual returns (uint256);\\n\\n  /**\\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\n   *  This may revert due to insufficient balance or insufficient allowance.\\n   */\\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256);\\n\\n  /**\\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n   */\\n  function doTransferOut(address payable to, uint256 amount) internal virtual;\\n\\n  function transferToTimelock(bool isBorrow, address to, uint256 amount) internal virtual;\\n\\n  /*** Reentrancy Guard ***/\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   */\\n  modifier nonReentrant() {\\n    require(_notEntered, 're-entered'); // re-entered\\n    _notEntered = false;\\n    _;\\n    _notEntered = true; // get a gas-refund post-Istanbul\\n  }\\n\\n  /**\\n   * @notice Returns true if the given cToken market has been deprecated\\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\\n   */\\n  function isDeprecated() public view returns (bool) {\\n    (, uint8 assetGroupId, ) = IComptroller(comptroller).markets(address(this));\\n    return\\n      assetGroupId == 0 &&\\n      //borrowGuardianPaused[cToken] == true &&\\n      IComptroller(comptroller).marketConfig(address(this)).borrowPaused &&\\n      reserveFactorMantissa == 1e18;\\n  }\\n\\n  /**\\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n   * @dev Used in liquidation (called in ICToken(cToken).liquidateBorrowFresh)\\n   * @param cTokenCollateral The address of the collateral cToken\\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation, number of cTokenCollateral tokens to be seized as profit in a liquidation)\\n   */\\n  function liquidateCalculateSeizeTokens(\\n    address cTokenCollateral,\\n    uint256 actualRepayAmount\\n  ) public view returns (uint256, uint256, uint256) {\\n    (bool repayListed, uint8 repayTokenGroupId, ) = IComptroller(comptroller).markets(address(this));\\n    require(repayListed, 'repay token not listed');\\n    (bool seizeListed, uint8 seizeTokenGroupId, ) = IComptroller(comptroller).markets(cTokenCollateral);\\n    require(seizeListed, 'seize token not listed');\\n\\n    LiquidationIncentive memory liquidationIncentive = IComptroller(comptroller).liquidationIncentive();\\n\\n    // default is repaying heterogeneous assets\\n    uint256 liquidationIncentiveMantissa = uint256(liquidationIncentive.heteroPercent) * percentScale;\\n    if (repayTokenGroupId == seizeTokenGroupId) {\\n      if (CToken(address(this)).isCToken() == false) {\\n        // repaying sutoken\\n        liquidationIncentiveMantissa = uint256(liquidationIncentive.sutokenPercent) * percentScale;\\n      } else {\\n        // repaying homogeneous assets\\n        liquidationIncentiveMantissa = uint256(liquidationIncentive.homoPercent) * percentScale;\\n      }\\n    }\\n\\n    /* Read oracle prices for borrowed and collateral markets */\\n    uint256 priceBorrowedMantissa = IComptroller(comptroller).getUnderlyingPriceNormalized(address(this));\\n    uint256 priceCollateralMantissa = IComptroller(comptroller).getUnderlyingPriceNormalized(cTokenCollateral);\\n    /*\\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n     *  seizeTokens = seizeAmount / exchangeRate\\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n     */\\n    uint256 exchangeRateMantissa = ICToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\\n\\n    Exp memory numerator = mul_(\\n      Exp({mantissa: liquidationIncentiveMantissa + expScale}),\\n      Exp({mantissa: priceBorrowedMantissa})\\n    );\\n    Exp memory profitNumerator = mul_(\\n      Exp({mantissa: liquidationIncentiveMantissa}),\\n      Exp({mantissa: priceBorrowedMantissa})\\n    );\\n    Exp memory denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\\n\\n    Exp memory ratio = div_(numerator, denominator);\\n    Exp memory profitRatio = div_(profitNumerator, denominator);\\n\\n    uint256 seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\n    uint256 seizeProfitTokens = mul_ScalarTruncate(profitRatio, actualRepayAmount);\\n\\n    return (uint256(0), seizeTokens, seizeProfitTokens);\\n  }\\n\\n  function _setDiscountRate(uint256 discountRateMantissa_) external onlyAdmin returns (uint256) {\\n    uint256 oldDiscountRateMantissa_ = discountRateMantissa;\\n    discountRateMantissa = discountRateMantissa_;\\n    emit NewDiscountRate(oldDiscountRateMantissa_, discountRateMantissa_);\\n    return discountRateMantissa;\\n  }\\n\\n  function borrowAndDepositBack(address borrower, uint256 borrowAmount) external nonReentrant returns (uint256) {\\n    // only allowed to be called from su token\\n    if (CToken(msg.sender).isCToken()) {\\n      revert NotSuToken();\\n    }\\n    // only cToken has this function\\n    if (!isCToken()) {\\n      revert NotCToken();\\n    }\\n    if (!IComptroller(comptroller).isListed(msg.sender)) {\\n      revert MarketNotListed();\\n    }\\n    if (!IComptroller(comptroller).isListed(address(this))) {\\n      revert MarketNotListed();\\n    }\\n    return borrowAndDepositBackInternal(payable(borrower), borrowAmount);\\n  }\\n\\n  /**\\n   * @notice Sender borrows assets from the protocol and deposit all of them back to the protocol\\n   * @param borrowAmount The amount of the underlying asset to borrow and deposit\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function borrowAndDepositBackInternal(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\\n    accrueInterest();\\n    borrowFresh(borrower, borrowAmount, false);\\n    mintFresh(borrower, borrowAmount, false);\\n    return uint256(0);\\n  }\\n\\n  function getBorrowSnapshot(address borrower) external view returns (BorrowSnapshot memory) {\\n    return accountBorrows[borrower];\\n  }\\n\\n  function isCToken() public pure virtual returns (bool) {\\n    return true;\\n  }\\n  function isCEther() external pure virtual returns (bool) {\\n    return false;\\n  }\\n\\n  function initAccrualBlockTimestamp(address timeBasedInterestRateModel) public onlyAdmin {\\n    if (accrualBlockTimestamp == 0) {\\n      // make sure this interest rate model is time-based\\n      IInterestRateModel(timeBasedInterestRateModel).secondsPerYear();\\n\\n      // set timestamp to current\\n      accrualBlockTimestamp = getBlockTimestamp();\\n\\n      // update interest rate model to time-based\\n      interestRateModel = timeBasedInterestRateModel;\\n    } else {\\n      accrueInterest();\\n      if (accrualBlockTimestamp != getBlockTimestamp()) {\\n        revert InvalidTimestamp();\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/CToken/CTokenStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\nimport '../Interfaces/ICToken.sol';\\n\\nabstract contract CTokenStorage is ICToken {\\n  bool public isCTokenDeprecated; // 0\\n  bool public isCEtherDeprecated; // 0\\n  /// @dev Guard variable for re-entrancy checks\\n  bool internal _notEntered; // 0\\n\\n  /// @notice Underlying asset for this CToken\\n  address public underlying; // 0\\n\\n  /// @notice EIP-20 token name for this token\\n  string public name; // 1\\n\\n  /// @notice EIP-20 token symbol for this token\\n  string public symbol; // 2\\n\\n  /// @notice EIP-20 token decimals for this token\\n  uint8 public decimals; // 3\\n\\n  /// @dev Maximum borrow rate that can ever be applied (.0005% / block)\\n  uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16;\\n\\n  /// @dev Maximum fraction of interest that can be set aside for reserves\\n  uint256 internal constant RESERVE_FACTOR_MAX_MANTISSA = 1e18;\\n\\n  /// @notice Administrator for this contract\\n  address payable public admin; // 3\\n\\n  /// @notice Pending administrator for this contract\\n  address payable public pendingAdmin; // 4\\n\\n  /// @notice Contract which oversees inter-cToken operations\\n  address public comptroller; // 5\\n\\n  /// @notice Model which tells what the current interest rate should be\\n  address public interestRateModel; // 6\\n\\n  /// @dev Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\\n  uint256 internal initialExchangeRateMantissa; // 7\\n\\n  /// @notice Fraction of interest currently set aside for reserves\\n  uint256 public reserveFactorMantissa; // 8\\n\\n  /// @notice Block number that interest was last accrued at\\n  uint256 private gap; // 9\\n\\n  /// @notice Accumulator of the total earned interest rate since the opening of the market\\n  uint256 public borrowIndex; // 10\\n\\n  /// @notice Total amount of outstanding borrows of the underlying in this market\\n  uint256 public totalBorrows; // 11\\n\\n  /// @notice Total amount of reserves of the underlying held in this market\\n  uint256 public totalReserves; // 12\\n\\n  /// @notice Total number of tokens in circulation\\n  uint256 public override totalSupply; // 13\\n\\n  /// @dev Official record of token balances for each account\\n  mapping(address => uint256) internal accountTokens; // 14\\n\\n  /// @dev Approved token transfer amounts on behalf of others\\n  mapping(address => mapping(address => uint256)) internal transferAllowances; // 15\\n\\n  /// @notice Container for borrow balance information\\n  /// @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n  /// @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n  struct BorrowSnapshot {\\n    uint256 principal;\\n    uint256 interestIndex;\\n  }\\n\\n  /// @dev Mapping of account addresses to outstanding borrow balances\\n  mapping(address => BorrowSnapshot) internal accountBorrows; // 16\\n\\n  /// @notice Share of seized collateral that is added to reserves\\n  uint256 public constant protocolSeizeShareMantissa = 30e16; //30% of profit\\n\\n  uint256 public discountRateMantissa = 1e18; // 17\\n\\n  uint256 public underlyingBalance; // 18\\n\\n  uint256 public constant percentScale = 1e14;\\n\\n  // before upgrade, this slot was initialized and intializing\\n  uint256 private gap0; // 19\\n\\n  uint256 public override accrualBlockTimestamp; // 20\\n\\n  uint256[50] private gap1; // 21 - 70\\n}\\n\"\r\n    },\r\n    \"contracts/CToken/suErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\nimport '../Interfaces/IEIP20NonStandard.sol';\\nimport './CErc20.sol';\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\n/**\\n * @title Compound's suErc20 Contract\\n * @notice CTokens which wrap an EIP-20 underlying\\n * @author Compound\\n */\\ncontract suErc20 is CErc20 {\\n  /**\\n   * @notice Gets balance of this contract in terms of the underlying\\n   * @dev This excludes the value of the current message, if any\\n   * @return The quantity of underlying tokens owned by this contract\\n   */\\n  // function getCashPrior() internal view virtual override returns (uint256) {\\n  //   // ICToken token = ICToken(underlying);\\n  //   // return token.balanceOf(address(this));\\n  //   return underlyingBalance;\\n  // }\\n\\n  /**\\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n   *      This will revert due to insufficient balance or insufficient allowance.\\n   *      This function returns the actual amount received,\\n   *      which may be less than `amount` if there is a fee attached to the transfer.\\n   *\\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n   */\\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\\n    IEIP20NonStandard token = IEIP20NonStandard(underlying);\\n    token.burnFrom(from, amount);\\n\\n    bool success;\\n    assembly {\\n      switch returndatasize()\\n      case 0 {\\n        // This is a non-standard ERC-20\\n        success := not(0) // set success to true\\n      }\\n      case 32 {\\n        // This is a compliant ERC-20\\n        returndatacopy(0, 0, 32)\\n        success := mload(0) // Set `success = returndata` of external call\\n      }\\n      default {\\n        // This is an excessively non-compliant ERC-20, revert.\\n        revert(0, 0)\\n      }\\n    }\\n    if (!success) {\\n      revert TokenTransferInFailed();\\n    }\\n\\n    // Calculate the amount that was *actually* transferred\\n    return amount;\\n  }\\n\\n  /**\\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n   *      it is >= amount, this should not revert in normal conditions.\\n   *\\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n   */\\n  function doTransferOut(address payable to, uint256 amount) internal override {\\n    IEIP20NonStandard token = IEIP20NonStandard(underlying);\\n    token.mint(to, amount);\\n\\n    bool success;\\n    assembly {\\n      switch returndatasize()\\n      case 0 {\\n        // This is a non-standard ERC-20\\n        success := not(0) // set success to true\\n      }\\n      case 32 {\\n        // This is a compliant ERC-20\\n        returndatacopy(0, 0, 32)\\n        success := mload(0) // Set `success = returndata` of external call\\n      }\\n      default {\\n        // This is an excessively non-compliant ERC-20, revert.\\n        revert(0, 0)\\n      }\\n    }\\n    if (!success) {\\n      revert TokenTransferOutFailed();\\n    }\\n  }\\n\\n  function executeRedemption(\\n    address redeemer,\\n    address provider,\\n    uint256 repayAmount,\\n    address cTokenCollateral,\\n    uint256 seizeAmount,\\n    uint256 redemptionRateMantissa\\n  ) external nonReentrant returns (uint256) {\\n    if (msg.sender != IComptroller(comptroller).redemptionManager()) {\\n      revert OnlyRedemptionManager();\\n    }\\n\\n    if (this.isCToken()) {\\n      revert NotSuToken();\\n    }\\n\\n    uint256 cExRateMantissa = CErc20(cTokenCollateral).exchangeRateStored();\\n    uint256 cPriceMantissa = IComptroller(comptroller).getUnderlyingPriceNormalized(cTokenCollateral);\\n    uint256 csuPriceMantissa = IComptroller(comptroller).getUnderlyingPriceNormalized(address(this));\\n\\n    accrueInterest();\\n    ICToken(cTokenCollateral).accrueInterest();\\n\\n    uint256 seizeVal = (cPriceMantissa * seizeAmount * cExRateMantissa) / expScale / expScale;\\n    uint256 repayVal = (csuPriceMantissa * repayAmount) / expScale;\\n    if (seizeVal > repayVal) {\\n      revert RedemptionSeizeTooMuch();\\n    }\\n\\n    repayBorrowFresh(redeemer, provider, repayAmount);\\n    ICToken(cTokenCollateral).seize(redeemer, provider, seizeAmount, uint256(0), true, redemptionRateMantissa);\\n\\n    emit RedeemFaceValue(redeemer, provider, repayAmount, cTokenCollateral, seizeAmount, redemptionRateMantissa);\\n    return uint256(0);\\n  }\\n\\n  function protectedMint(\\n    address cTokenCollateral,\\n    uint256 cBorrowAmount,\\n    uint256 suBorrowAmount\\n  ) external nonReentrant returns (uint256) {\\n    if (!CToken(cTokenCollateral).isCToken()) {\\n      revert NotCToken();\\n    }\\n\\n    (, uint8 suGroupId, ) = IComptroller(comptroller).markets(address(this));\\n    (, uint8 cGroupId, ) = IComptroller(comptroller).markets(cTokenCollateral);\\n    if (suGroupId != cGroupId) {\\n      revert ProtectedMint_OnlyAllowAssetsInTheSameGroup();\\n    }\\n\\n    accrueInterest();\\n\\n    if (cBorrowAmount <= 0) {\\n      revert InvalidAmount();\\n    }\\n\\n    uint256 bnd = CToken(cTokenCollateral).borrowAndDepositBack(payable(msg.sender), cBorrowAmount);\\n    if (bnd != 0) {\\n      revert BorrowAndDepositBackFailed();\\n    }\\n    return borrowFresh(payable(msg.sender), suBorrowAmount, true);\\n  }\\n\\n  function isCToken() public pure override returns (bool) {\\n    return false;\\n  }\\n  function isCEther() external pure override returns (bool) {\\n    return false;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Exponential/ExponentialNoErrorNew.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoErrorNew {\\n  uint constant expScale = 1e18;\\n  uint constant doubleScale = 1e36;\\n\\n  struct Exp {\\n    uint mantissa;\\n  }\\n\\n  struct Double {\\n    uint mantissa;\\n  }\\n\\n  /**\\n   * @dev Truncates the given exp to a whole number value.\\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n   */\\n  function truncate(Exp memory exp) internal pure returns (uint) {\\n    // Note: We are not using careful math here as we're performing a division that cannot fail\\n    return exp.mantissa / expScale;\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\\n    Exp memory product = mul_(a, scalar);\\n    return truncate(product);\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n   */\\n  function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\\n    Exp memory product = mul_(a, scalar);\\n    return add_(truncate(product), addend);\\n  }\\n\\n  /**\\n   * @dev Checks if first Exp is less than second Exp.\\n   */\\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa < right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp <= right Exp.\\n   */\\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa <= right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp > right Exp.\\n   */\\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa > right.mantissa;\\n  }\\n\\n  /**\\n   * @dev returns true if Exp is exactly zero\\n   */\\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\\n    return value.mantissa == 0;\\n  }\\n\\n  function safe224(uint n, string memory errorMessage) internal pure returns (uint224) {\\n    require(n < 2 ** 224, errorMessage);\\n    return uint224(n);\\n  }\\n\\n  function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n    require(n < 2 ** 32, errorMessage);\\n    return uint32(n);\\n  }\\n\\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function add_(uint a, uint b) internal pure returns (uint) {\\n    return a + b;\\n  }\\n\\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function sub_(uint a, uint b) internal pure returns (uint) {\\n    return a - b;\\n  }\\n\\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n  }\\n\\n  function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: mul_(a.mantissa, b)});\\n  }\\n\\n  function mul_(uint a, Exp memory b) internal pure returns (uint) {\\n    return mul_(a, b.mantissa) / expScale;\\n  }\\n\\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n  }\\n\\n  function mul_(Double memory a, uint b) internal pure returns (Double memory) {\\n    return Double({mantissa: mul_(a.mantissa, b)});\\n  }\\n\\n  function mul_(uint a, Double memory b) internal pure returns (uint) {\\n    return mul_(a, b.mantissa) / doubleScale;\\n  }\\n\\n  function mul_(uint a, uint b) internal pure returns (uint) {\\n    return a * b;\\n  }\\n\\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n  }\\n\\n  function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: div_(a.mantissa, b)});\\n  }\\n\\n  function div_(uint a, Exp memory b) internal pure returns (uint) {\\n    return div_(mul_(a, expScale), b.mantissa);\\n  }\\n\\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n  }\\n\\n  function div_(Double memory a, uint b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(a.mantissa, b)});\\n  }\\n\\n  function div_(uint a, Double memory b) internal pure returns (uint) {\\n    return div_(mul_(a, doubleScale), b.mantissa);\\n  }\\n\\n  function div_(uint a, uint b) internal pure returns (uint) {\\n    return a / b;\\n  }\\n\\n  function fraction(uint a, uint b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport './IEIP20NonStandard.sol';\\n\\npragma solidity 0.8.19;\\n\\ninterface ICErc20 {\\n  /*** User Interface ***/\\n\\n  function mint(uint256 mintAmount) external returns (uint256);\\n\\n  function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n  function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\\n\\n  function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral) external returns (uint256);\\n\\n  function sweepToken(IEIP20NonStandard token) external;\\n\\n  /*** Admin Functions ***/\\n\\n  function _addReserves(uint256 addAmount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IComptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nenum Version {\\n  V0,\\n  V1,\\n  V2, // packed asset group\\n  V3, // added interMintRate into asset group\\n  V4 // use interMintSwitch instead of interMintRate\\n}\\n\\nstruct GroupVar {\\n  uint8 groupId;\\n  uint256 cDepositVal;\\n  uint256 cBorrowVal;\\n  uint256 suDepositVal;\\n  uint256 suBorrowVal;\\n  uint256 intraCRate;\\n  uint256 intraMintRate;\\n  uint256 intraSuRate;\\n  uint256 interCRate;\\n  uint256 interSuRate;\\n}\\n\\n/// @notice AssetGroup, contains information of groupName and rateMantissas\\nstruct AssetGroupDeprecated {\\n  uint8 groupId;\\n  string groupName;\\n  uint256 intraCRateMantissa;\\n  uint256 intraMintRateMantissa;\\n  uint256 intraSuRateMantissa;\\n  uint256 interCRateMantissa;\\n  uint256 interSuRateMantissa;\\n  bool exist;\\n}\\n\\n/// @notice NewAssetGroup, contains information of groupName and rateMantissas\\nstruct CompactAssetGroup {\\n  uint8 groupId;\\n  uint16 intraCRatePercent;\\n  uint16 intraMintRatePercent;\\n  uint16 intraSuRatePercent;\\n  uint16 interCRatePercent;\\n  uint16 interSuRatePercent;\\n}\\n\\nstruct GlobalConfig {\\n  uint16 closeFactorPercent; // percent decimals(4)\\n  uint32 minCloseValue; // usd value decimals(0)\\n  uint32 minSuBorrowValue; // usd value decimals(0)\\n  uint32 minWaitBeforeLiquidatable; // seconds decimals(0)\\n  uint8 largestGroupId;\\n}\\n\\nstruct MarketConfig {\\n  bool mintPaused;\\n  bool borrowPaused;\\n  bool transferPaused;\\n  bool seizePaused;\\n  uint120 borrowCap; //\\n  uint120 supplyCap;\\n}\\n\\nstruct LiquidationIncentive {\\n  uint16 heteroPercent;\\n  uint16 homoPercent;\\n  uint16 sutokenPercent;\\n}\\n\\ninterface IComptroller {\\n  /*** Assets You Are In ***/\\n  function isComptroller() external view returns (bool);\\n\\n  function markets(address) external view returns (bool, uint8, bool);\\n\\n  function getAllMarkets() external view returns (address[] memory);\\n\\n  function oracle() external view returns (address);\\n\\n  function redemptionManager() external view returns (address);\\n\\n  function enterMarkets(address[] calldata cTokens) external;\\n\\n  function exitMarket(address cToken) external;\\n\\n  // function getAssetsIn(address) external view returns (ICToken[] memory);\\n  function claimSumer(address) external;\\n\\n  function compAccrued(address) external view returns (uint256);\\n\\n  function getAssetsIn(address account) external view returns (address[] memory);\\n\\n  function timelock() external view returns (address);\\n\\n  function getUnderlyingPriceNormalized(address cToken) external view returns (uint256);\\n  /*** Policy Hooks ***/\\n\\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external;\\n\\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external;\\n  // function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\\n\\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external;\\n  function borrowVerify(address borrower, uint borrowAmount) external;\\n\\n  function repayBorrowAllowed(address cToken, address payer, address borrower, uint256 repayAmount) external;\\n  // function repayBorrowVerify(\\n  //   address cToken,\\n  //   address payer,\\n  //   address borrower,\\n  //   uint repayAmount,\\n  //   uint borrowerIndex\\n  // ) external;\\n\\n  function seizeAllowed(\\n    address cTokenCollateral,\\n    address cTokenBorrowed,\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens\\n  ) external;\\n  function seizeVerify(\\n    address cTokenCollateral,\\n    address cTokenBorrowed,\\n    address liquidator,\\n    address borrower,\\n    uint seizeTokens\\n  ) external;\\n\\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external;\\n\\n  /*** Liquidity/Liquidation Calculations ***/\\n\\n  function liquidationIncentive() external view returns (LiquidationIncentive memory);\\n\\n  function isListed(address asset) external view returns (bool);\\n\\n  function getHypotheticalAccountLiquidity(\\n    address account,\\n    address cTokenModify,\\n    uint256 redeemTokens,\\n    uint256 borrowAmount\\n  ) external view returns (uint256, uint256);\\n\\n  // function _getMarketBorrowCap(address cToken) external view returns (uint256);\\n\\n  /// @notice Emitted when an action is paused on a market\\n  event ActionPaused(address cToken, string action, bool pauseState);\\n\\n  /// @notice Emitted when borrow cap for a cToken is changed\\n  event NewBorrowCap(address indexed cToken, uint256 newBorrowCap);\\n\\n  /// @notice Emitted when borrow cap guardian is changed\\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\\n\\n  /// @notice Emitted when pause guardian is changed\\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\n\\n  event RemoveAssetGroup(uint8 indexed groupId, uint8 equalAssetsGroupNum);\\n\\n  function assetGroup(uint8 groupId) external view returns (CompactAssetGroup memory);\\n\\n  function marketConfig(address cToken) external view returns (MarketConfig memory);\\n\\n  function liquidateBorrowAllowed(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    address liquidator,\\n    address borrower,\\n    uint256 repayAmount\\n  ) external view;\\n  // function liquidateBorrowVerify(\\n  //   address cTokenBorrowed,\\n  //   address cTokenCollateral,\\n  //   address liquidator,\\n  //   address borrower,\\n  //   uint repayAmount,\\n  //   uint seizeTokens\\n  // ) external;\\n\\n  function globalConfig() external view returns (GlobalConfig memory);\\n\\n  function interMintAllowed() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface ICToken {\\n  /*** User Interface ***/\\n\\n  function transfer(address dst, uint256 amount) external returns (bool);\\n\\n  function transferFrom(address src, address dst, uint256 amount) external returns (bool);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function balanceOf(address owner) external view returns (uint256);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n  function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256);\\n\\n  function borrowRatePerBlock() external view returns (uint256);\\n\\n  function supplyRatePerBlock() external view returns (uint256);\\n\\n  function totalBorrowsCurrent() external returns (uint256);\\n\\n  function borrowBalanceCurrent(address account) external returns (uint256);\\n\\n  function borrowBalanceStored(address account) external view returns (uint256);\\n\\n  function exchangeRateCurrent() external returns (uint256);\\n\\n  function exchangeRateStored() external view returns (uint256);\\n\\n  function getCash() external view returns (uint256);\\n\\n  function accrueInterest() external returns (uint256);\\n\\n  // function accrualBlockNumber() external returns (uint256);\\n\\n  function seize(\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens,\\n    uint256 seizeProfitTokens,\\n    bool isRedemption,\\n    uint256 redemptionRateMantissa\\n  ) external returns (uint256);\\n\\n  /*** Admin Functions ***/\\n\\n  function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256);\\n\\n  function _acceptAdmin() external returns (uint256);\\n\\n  function _setComptroller(address newComptroller) external returns (uint256);\\n\\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\\n\\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\\n\\n  function _setInterestRateModel(address newInterestRateModel) external returns (uint256);\\n\\n  function _setDiscountRate(uint256 discountRateMantissa) external returns (uint256);\\n\\n  function accrualBlockTimestamp() external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface IEIP20NonStandard {\\n  /**\\n   * @notice Get the total number of tokens in circulation\\n   * @return The supply of tokens\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Gets the balance of the specified address\\n   * @param owner The address from which the balance will be retrieved\\n   * @return balance The balance\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  ///\\n  /// !!!!!!!!!!!!!!\\n  /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n  /// !!!!!!!!!!!!!!\\n  ///\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   */\\n  function transfer(address dst, uint256 amount) external;\\n\\n  ///\\n  /// !!!!!!!!!!!!!!\\n  /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n  /// !!!!!!!!!!!!!!\\n  ///\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `src` to `dst`\\n   * @param src The address of the source account\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   */\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Approve `spender` to transfer up to `amount` from `src`\\n   * @dev This will overwrite the approval amount for `spender`\\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n   * @param spender The address of the account which may transfer tokens\\n   * @param amount The number of tokens that are approved\\n   * @return success Whether or not the approval succeeded\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool success);\\n\\n  /**\\n   * @notice Get the current allowance from `owner` for `spender`\\n   * @param owner The address of the account which owns the tokens to be spent\\n   * @param spender The address of the account which may transfer tokens\\n   * @return remaining The number of tokens allowed to be spent\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   * See {ERC20-_mint}.\\n   * Requirements:\\n   * - the caller must have the `MINTER_ROLE`.\\n   */\\n  function mint(address to, uint256 amount) external;\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller.\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 amount) external;\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n   * allowance.\\n   * See {ERC20-_burn} and {ERC20-allowance}.\\n   * Requirements:\\n   * - the caller must have allowance for ``accounts``'s tokens of at least\\n   * `amount`.\\n   */\\n  function burnFrom(address account, uint256 amount) external;\\n\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IEIP712 {\\n  function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Compound's InterestRateModel Interface\\n * @author Compound\\n */\\ninterface IInterestRateModel {\\n  function isInterestRateModel() external view returns (bool);\\n  function secondsPerYear() external view returns (uint);\\n\\n  /**\\n   * @notice Calculates the current borrow interest rate per block\\n   * @param cash The total amount of cash the market has\\n   * @param borrows The total amount of borrows the market has outstanding\\n   * @param reserves The total amount of reserves the market has\\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n   */\\n  function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculates the current supply interest rate per block\\n   * @param cash The total amount of cash the market has\\n   * @param borrows The total amount of borrows the market has outstanding\\n   * @param reserves The total amount of reserves the market has\\n   * @param reserveFactorMantissa The current reserve factor the market has\\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n   */\\n  function getSupplyRate(\\n    uint256 cash,\\n    uint256 borrows,\\n    uint256 reserves,\\n    uint256 reserveFactorMantissa\\n  ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IPriceOracle {\\n  /**\\n   * @notice Get the underlying price of a cToken asset\\n   * @param cToken The cToken to get the underlying price of\\n   * @return The underlying asset price mantissa (scaled by 1e18).\\n   *  Zero means the price is unavailable.\\n   */\\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the underlying price of cToken asset (normalized)\\n   * = getUnderlyingPrice * (10 ** (18 - cToken.decimals))\\n   */\\n  function getUnderlyingPriceNormalized(address cToken_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface ITimelock {\\n  /** @notice Event emitted when a new time-lock agreement is created\\n   * @param agreementId ID of the created agreement\\n   * @param beneficiary Address of the beneficiary\\n   * @param asset Address of the asset\\n   * @param actionType Type of action for the time-lock\\n   * @param amount  amount\\n   * @param timestamp Timestamp when the assets entered timelock\\n   */\\n  event AgreementCreated(\\n    uint256 indexed agreementId,\\n    address indexed beneficiary,\\n    address indexed asset,\\n    TimeLockActionType actionType,\\n    uint256 amount,\\n    uint256 timestamp\\n  );\\n\\n  /** @notice Event emitted when a time-lock agreement is claimed\\n   * @param agreementId ID of the claimed agreement\\n   * @param beneficiary Beneficiary of the claimed agreement\\n   * @param asset Address of the asset\\n   * @param actionType Type of action for the time-lock\\n   * @param amount amount\\n   * @param beneficiary Address of the beneficiary\\n   */\\n  event AgreementClaimed(\\n    uint256 indexed agreementId,\\n    address indexed beneficiary,\\n    address indexed asset,\\n    TimeLockActionType actionType,\\n    uint256 amount\\n  );\\n\\n  /** @notice Event emitted when a time-lock agreement is frozen or unfrozen\\n   * @param agreementId ID of the affected agreement\\n   * @param value Indicates whether the agreement is frozen (true) or unfrozen (false)\\n   */\\n  event AgreementFrozen(uint256 agreementId, bool value);\\n\\n  /** @notice Event emitted when the entire TimeLock contract is frozen or unfrozen\\n   * @param value Indicates whether the contract is frozen (true) or unfrozen (false)\\n   */\\n  event TimeLockFrozen(bool value);\\n\\n  /**\\n   * @dev Emitted during rescueAgreement()\\n   * @param agreementId The rescued agreement Id\\n   * @param underlyToken The adress of the underlying token\\n   * @param to The address of the recipient\\n   * @param underlyAmount The amount being rescued\\n   **/\\n  event RescueAgreement(uint256 agreementId, address indexed underlyToken, address indexed to, uint256 underlyAmount);\\n\\n  enum TimeLockActionType {\\n    BORROW,\\n    REDEEM\\n  }\\n  struct Agreement {\\n    bool isFrozen;\\n    TimeLockActionType actionType;\\n    address cToken;\\n    address beneficiary;\\n    uint48 timestamp;\\n    uint256 agreementId;\\n    uint256 underlyAmount;\\n  }\\n\\n  function createAgreement(\\n    TimeLockActionType actionType,\\n    uint256 underlyAmount,\\n    address beneficiary\\n  ) external returns (uint256);\\n\\n  // function consumeValuePreview(uint256 underlyAmount, address cToken) external view returns (bool);\\n  function consumeValue(uint256 underlyAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/SumerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.19;\\n\\n/// @title Multicall2 - Aggregate results from multiple read-only function calls\\n/// @author Michael Elliot <mike@makerdao.com>\\n/// @author Joshua Levine <joshua@makerdao.com>\\n/// @author Nick Johnson <arachnid@notdot.net>\\n\\ncontract SumerErrors {\\n  error PriceError();\\n\\n  error RedemptionSignerNotInitialized();\\n  error NotEnoughForSeize();\\n  error NoRedemptionProvider();\\n  error MarketNotListed();\\n  error InsufficientShortfall();\\n  error TooMuchRepay();\\n  error InvalidMinSuBorrowValue();\\n  error BorrowValueMustBeLargerThanThreshold(uint256 usdThreshold);\\n  error MarketAlreadyListed();\\n  error InvalidAddress();\\n  error InvalidGroupId();\\n  error InvalidCloseFactor();\\n  error InvalidSuToken();\\n  error InvalidSignatureLength();\\n  error ExpiredSignature();\\n  error SenderMustBeCToken();\\n  error MintPaused();\\n  error BorrowPaused();\\n  error TransferPaused();\\n  error SeizePaused();\\n  error InsufficientCollateral();\\n  error EitherAssetOrDebtMustBeZeroInGroup(\\n    uint8 groupId,\\n    uint256 cDepositVal,\\n    uint256 suDepositVal,\\n    uint256 cBorrowVal,\\n    uint256 suBorrowVal\\n  );\\n  error EitherAssetOrDebtMustBeZero();\\n\\n  error OnlyAdminOrPauser();\\n\\n  // general errors\\n  error OnlyAdmin();\\n  error OnlyPendingAdmin();\\n  error OnlyRedemptionManager();\\n  error OnlyListedCToken();\\n  error OnlyCToken();\\n  error UnderlyingBalanceError();\\n  error MarketCanOnlyInitializeOnce();\\n  error CantSweepUnderlying();\\n  error TokenTransferInFailed();\\n  error TokenTransferOutFailed();\\n  error TransferNotAllowed();\\n  error TokenInOrAmountInMustBeZero();\\n  error AddReservesOverflow();\\n  error RedeemTransferOutNotPossible();\\n  error BorrowCashNotAvailable();\\n  error ReduceReservesCashNotAvailable();\\n  error InvalidDiscountRate();\\n  error InvalidExchangeRate();\\n  error InvalidReduceAmount();\\n  error InvalidReserveFactor();\\n  error InvalidComptroller();\\n  error InvalidInterestRateModel();\\n  error InvalidAmount();\\n  error InvalidInput();\\n  error BorrowAndDepositBackFailed();\\n  error InvalidSignatureForRedeemFaceValue();\\n\\n  error BorrowCapReached();\\n  error SupplyCapReached();\\n  error ComptrollerMismatch();\\n\\n  error MintMarketNotFresh();\\n  error BorrowMarketNotFresh();\\n  error RepayBorrowMarketNotFresh();\\n  error RedeemMarketNotFresh();\\n  error LiquidateMarketNotFresh();\\n  error LiquidateCollateralMarketNotFresh();\\n  error ReduceReservesMarketNotFresh();\\n  error SetInterestRateModelMarketNotFresh();\\n  error AddReservesMarketNotFresh();\\n  error SetReservesFactorMarketNotFresh();\\n  error CantExitMarketWithNonZeroBorrowBalance();\\n\\n  error InvalidTimestamp();\\n\\n  // error\\n  error NotCToken();\\n  error NotSuToken();\\n\\n  // error in liquidateBorrow\\n  error LiquidateBorrow_RepayAmountIsZero();\\n  error LiquidateBorrow_RepayAmountIsMax();\\n  error LiquidateBorrow_LiquidatorIsBorrower();\\n  error LiquidateBorrow_SeizeTooMuch();\\n\\n  // error in seize\\n  error Seize_LiquidatorIsBorrower();\\n\\n  // error in protected mint\\n  error ProtectedMint_OnlyAllowAssetsInTheSameGroup();\\n\\n  error RedemptionSeizeTooMuch();\\n\\n  error MinDelayNotReached();\\n\\n  error NotLiquidatableYet();\\n\\n  error InvalidBlockNumber();\\n  error ZeroAddressNotAllowed();\\n  error InterMintNotAllowed();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AddReservesMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddReservesOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowAndDepositBackFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowCapReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowCashNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdThreshold\",\"type\":\"uint256\"}],\"name\":\"BorrowValueMustBeLargerThanThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantExitMarketWithNonZeroBorrowBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantSweepUnderlying\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ComptrollerMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EitherAssetOrDebtMustBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"groupId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cDepositVal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suDepositVal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cBorrowVal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suBorrowVal\",\"type\":\"uint256\"}],\"name\":\"EitherAssetOrDebtMustBeZeroInGroup\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientCollateral\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientShortfall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterMintNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBlockNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCloseFactor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidComptroller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDiscountRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExchangeRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidGroupId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInterestRateModel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinSuBorrowValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReduceAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReserveFactor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureForRedeemFaceValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSuToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimestamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateBorrow_LiquidatorIsBorrower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateBorrow_RepayAmountIsMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateBorrow_RepayAmountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateBorrow_SeizeTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCollateralMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketAlreadyListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketCanOnlyInitializeOnce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketNotListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinDelayNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRedemptionProvider\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughForSeize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLiquidatableYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSuToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAdminOrPauser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyListedCToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRedemptionManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtectedMint_OnlyAllowAssetsInTheSameGroup\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemTransferOutNotPossible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedemptionSeizeTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedemptionSignerNotInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesCashNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepayBorrowMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeizePaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Seize_LiquidatorIsBorrower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderMustBeCToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetInterestRateModelMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetReservesFactorMarketNotFresh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyCapReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenInOrAmountInMustBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTransferInFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTransferOutFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooMuchRepay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnderlyingBalanceError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldComptroller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newComptroller\",\"type\":\"address\"}],\"name\":\"NewComptroller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDiscountRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDiscountRateMantissa\",\"type\":\"uint256\"}],\"name\":\"NewDiscountRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldInterestRateModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"NewMarketInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReserveFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seizeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redemptionRateMantissa\",\"type\":\"uint256\"}],\"name\":\"RedeemFaceValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"RepayBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"}],\"name\":\"_addReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"_reduceReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newComptroller\",\"type\":\"address\"}],\"name\":\"_setComptroller\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"discountRateMantissa_\",\"type\":\"uint256\"}],\"name\":\"_setDiscountRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"_setReserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_syncUnderlyingBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrowAndDepositBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountRateMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionRateMantissa\",\"type\":\"uint256\"}],\"name\":\"executeRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getBorrowSnapshot\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct CTokenStorage.BorrowSnapshot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timeBasedInterestRateModel\",\"type\":\"address\"}],\"name\":\"initAccrualBlockTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeVersion2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCEther\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCEtherDeprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCTokenDeprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDeprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"}],\"name\":\"liquidateBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateCalculateSeizeTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mintWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suBorrowAmount\",\"type\":\"uint256\"}],\"name\":\"protectedMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolSeizeShareMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"repayBorrowWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeProfitTokens\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRedemption\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"redemptionRateMantissa\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IEIP20NonStandard\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowsCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "suErc20", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}