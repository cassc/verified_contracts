{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/bridge/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/bridge/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\ninterface ILayerZeroReceiver {\\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n    // @param _srcChainId - the source endpoint identifier\\n    // @param _srcAddress - the source sending contract address from the source chain\\n    // @param _nonce - the ordered message nonce\\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/bridge/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/bridge/LayerZeroBridge.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\nimport \\\"./ILayerZeroReceiver.sol\\\";\\nimport \\\"./ILayerZeroEndpoint.sol\\\";\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\nimport \\\"./LayerZeroStorage.sol\\\";\\nimport \\\"../zksync/ReentrancyGuard.sol\\\";\\n\\n/// @title LayerZero bridge implementation of non-blocking model\\n/// @dev if message is blocking we should call `retryPayload` of endpoint to retry\\n/// the reasons for message blocking may be:\\n/// * `_dstAddress` is not deployed to dst chain, and we can deploy LayerZeroBridge to dst chain to fix it.\\n/// * lzReceive cost more gas than `_gasLimit` that endpoint send, and user should call `retryMessage` to fix it.\\n/// * lzReceive reverted unexpected, and we can fix bug and deploy a new contract to fix it.\\n/// @author zk.link\\ncontract LayerZeroBridge is ReentrancyGuard, LayerZeroStorage, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\\n\\n    // to avoid stack too deep\\n    struct LzBridgeParams {\\n        uint16 dstChainId; // the destination chainId\\n        address payable refundAddress; // native fees refund address if msg.value is too large\\n        address zroPaymentAddress; // if not zero user will use ZRO token to pay layerzero protocol fees(not oracle or relayer fees)\\n        bytes adapterParams; // see https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters\\n    }\\n\\n    modifier onlyEndpoint {\\n        require(msg.sender == address(endpoint), \\\"Require endpoint\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor {\\n        require(msg.sender == networkGovernor, \\\"Caller is not governor\\\");\\n        _;\\n    }\\n\\n    receive() external payable {\\n        // receive the refund eth from layerzero endpoint when send msg\\n    }\\n\\n    /// @param _governor The network governor of zkLink protocol\\n    /// @param _zklink The zklink contract address\\n    /// @param _endpoint The LayerZero endpoint\\n    constructor(address _governor, IZkLink _zklink, ILayerZeroEndpoint _endpoint) {\\n        initializeReentrancyGuard();\\n\\n        networkGovernor = _governor;\\n        zklink = _zklink;\\n        endpoint = _endpoint;\\n    }\\n\\n    //---------------------------UserApplication config----------------------------------------\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyGovernor {\\n        endpoint.setConfig(_version, _chainId, _configType, _config);\\n    }\\n\\n    function setSendVersion(uint16 _version) external override onlyGovernor {\\n        endpoint.setSendVersion(_version);\\n    }\\n\\n    function setReceiveVersion(uint16 _version) external override onlyGovernor {\\n        endpoint.setReceiveVersion(_version);\\n    }\\n\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyGovernor {\\n        endpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    /// @notice Set bridge destination\\n    /// @param dstChainId LayerZero chain id on other chains\\n    /// @param contractAddr LayerZeroBridge contract address on other chains\\n    function setDestination(uint16 dstChainId, bytes calldata contractAddr) external onlyGovernor {\\n        require(dstChainId != endpoint.getChainId(), \\\"Invalid dstChainId\\\");\\n        destinations[dstChainId] = contractAddr;\\n        emit UpdateDestination(dstChainId, contractAddr);\\n    }\\n\\n    /// @notice Estimate bridge ZkLink Block fees\\n    /// @param lzChainId the destination chainId\\n    /// @param syncHash the sync hash of stored block\\n    /// @param progress the sync progress\\n    /// @param useZro if true user will use ZRO token to pay layerzero protocol fees(not oracle or relayer fees)\\n    /// @param adapterParams see https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters\\n    function estimateZkLinkBlockBridgeFees(\\n        uint16 lzChainId,\\n        bytes32 syncHash,\\n        uint256 progress,\\n        bool useZro,\\n        bytes calldata adapterParams\\n    ) external view returns (uint nativeFee, uint zroFee) {\\n        bytes memory payload = buildZkLinkBlockBridgePayload(syncHash, progress);\\n        return endpoint.estimateFees(lzChainId, address(this), payload, useZro, adapterParams);\\n    }\\n\\n    /// @notice Bridge ZkLink block to other chain\\n    /// @param storedBlockInfo the block proved but not executed at the current chain\\n    /// @param dstChainIds dst chains to bridge, empty array will be reverted\\n    /// @param refundAddress native fees refund address if msg.value is too large\\n    /// @param zroPaymentAddress if not zero user will use ZRO token to pay layerzero protocol fees(not oracle or relayer fees)\\n    /// @param adapterParams see https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters\\n    function bridgeZkLinkBlock(\\n        IZkLink.StoredBlockInfo calldata storedBlockInfo,\\n        uint16[] memory dstChainIds,\\n        address payable refundAddress,\\n        address zroPaymentAddress,\\n        bytes memory adapterParams\\n    ) external nonReentrant payable {\\n        // ===Checks===\\n        require(dstChainIds.length > 0, \\\"No dst chain\\\");\\n\\n        // ===Interactions===\\n        bytes32 syncHash = storedBlockInfo.syncHash;\\n        uint256 progress = zklink.getSynchronizedProgress(storedBlockInfo);\\n\\n        uint256 originBalance = address(this).balance - msg.value; // underflow is impossible\\n        // before the last send, we send all balance of this contract and set refund address to this contract\\n        for (uint i = 0; i < dstChainIds.length - 1; ++i) { // overflow is impossible\\n            _bridgeZkLinkBlockProgress(syncHash, progress, dstChainIds[i], payable(address(this)), zroPaymentAddress, adapterParams, address(this).balance);\\n        }\\n        // for the last send, we send all left value exclude the origin balance of this contract and set refund address to `refundAddress`\\n        require(address(this).balance > originBalance, \\\"Msg value is not enough for the last send\\\");\\n        uint256 leftMsgValue = address(this).balance - originBalance; // underflow is impossible\\n        _bridgeZkLinkBlockProgress(syncHash, progress, dstChainIds[dstChainIds.length - 1], refundAddress, zroPaymentAddress, adapterParams, leftMsgValue);\\n    }\\n\\n    function _bridgeZkLinkBlockProgress(\\n        bytes32 syncHash,\\n        uint256 progress,\\n        uint16 dstChainId,\\n        address payable refundAddress,\\n        address zroPaymentAddress,\\n        bytes memory adapterParams,\\n        uint256 bridgeFee\\n    ) internal {\\n        // ===Checks===\\n        bytes memory trustedRemote = checkDstChainId(dstChainId);\\n\\n        // endpoint will check `refundAddress`, `zroPaymentAddress` and `adapterParams`\\n\\n        // ===Effects===\\n        uint64 nonce = endpoint.getOutboundNonce(dstChainId, address(this));\\n        emit SendSynchronizationProgress(dstChainId, nonce + 1, syncHash, progress);\\n\\n        // ===Interactions===\\n        // send LayerZero message\\n        bytes memory path = abi.encodePacked(trustedRemote, address(this));\\n        bytes memory payload = buildZkLinkBlockBridgePayload(syncHash, progress);\\n        // solhint-disable-next-line check-send-result\\n        endpoint.send{value:bridgeFee}(dstChainId, path, payload, refundAddress, zroPaymentAddress, adapterParams);\\n    }\\n\\n    /// @notice Receive the bytes payload from the source chain via LayerZero\\n    /// @dev lzReceive can only be called by endpoint\\n    /// @dev srcPath(in UltraLightNodeV2) = abi.encodePacked(srcAddress, dstAddress);\\n    function lzReceive(uint16 srcChainId, bytes calldata srcPath, uint64 nonce, bytes calldata payload) external override onlyEndpoint nonReentrant {\\n        // reject invalid src contract address\\n        bytes memory srcAddress = destinations[srcChainId];\\n        bytes memory path = abi.encodePacked(srcAddress, address(this));\\n        require(keccak256(path) == keccak256(srcPath), \\\"Invalid src\\\");\\n\\n        // try-catch all errors/exceptions\\n        // solhint-disable-next-line no-empty-blocks\\n        try this.nonblockingLzReceive(srcChainId, srcAddress, nonce, payload) {\\n            // do nothing\\n        } catch {\\n            // error / exception\\n            failedMessages[srcChainId][srcAddress][nonce] = keccak256(payload);\\n            emit MessageFailed(srcChainId, srcAddress, nonce, payload);\\n        }\\n    }\\n\\n    function nonblockingLzReceive(uint16 srcChainId, bytes calldata srcAddress, uint64 nonce, bytes calldata payload) public {\\n        // only internal transaction\\n        require(msg.sender == address(this), \\\"Caller must be this bridge\\\");\\n        _nonblockingLzReceive(srcChainId, srcAddress, nonce, payload);\\n    }\\n\\n    /// @notice Retry the failed message, payload hash must be exist\\n    function retryMessage(uint16 srcChainId, bytes calldata srcAddress, uint64 nonce, bytes calldata payload) external payable virtual nonReentrant {\\n        // assert there is message to retry\\n        bytes32 payloadHash = failedMessages[srcChainId][srcAddress][nonce];\\n        require(payloadHash != bytes32(0), \\\"No stored message\\\");\\n        require(keccak256(payload) == payloadHash, \\\"Invalid payload\\\");\\n        // clear the stored message\\n        failedMessages[srcChainId][srcAddress][nonce] = bytes32(0);\\n        // execute the message. revert if it fails again\\n        _nonblockingLzReceive(srcChainId, srcAddress, nonce, payload);\\n    }\\n\\n    function _nonblockingLzReceive(uint16 srcChainId, bytes calldata /**srcAddress**/, uint64 nonce, bytes calldata payload) internal {\\n        // unpack payload\\n        (bytes32 syncHash, uint256 progress) = abi.decode(payload, (bytes32, uint256));\\n        emit ReceiveSynchronizationProgress(srcChainId, nonce, syncHash, progress);\\n        zklink.receiveSynchronizationProgress(syncHash, progress);\\n    }\\n\\n    function checkDstChainId(uint16 dstChainId) internal view returns (bytes memory trustedRemote) {\\n        trustedRemote = destinations[dstChainId];\\n        require(trustedRemote.length > 0, \\\"Trust remote not exist\\\");\\n    }\\n\\n    function buildZkLinkBlockBridgePayload(bytes32 syncHash, uint256 progress) internal pure returns (bytes memory payload) {\\n        payload = abi.encode(syncHash, progress);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/bridge/LayerZeroStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\nimport \\\"./ILayerZeroEndpoint.sol\\\";\\nimport \\\"../interfaces/IZkLink.sol\\\";\\n\\n/// @title LayerZero bridge storage\\n/// @author zk.link\\n/// @dev Do not initialize any variables of this contract\\n/// Do not break the alignment of contract storage\\ncontract LayerZeroStorage {\\n    /// @notice ZkLink network governor\\n    address public networkGovernor;\\n    /// @notice zklink contract address\\n    IZkLink public zklink;\\n    /// @notice LayerZero endpoint that used to send and receive message\\n    ILayerZeroEndpoint public endpoint;\\n    /// @notice bridge contract address on other chains\\n    mapping(uint16 => bytes) public destinations;\\n    /// @notice failed message of lz non-blocking model\\n    /// @dev the struct of failedMessages is (srcChainId => srcAddress => nonce => payloadHash)\\n    /// srcChainId is the id of message source chain\\n    /// srcAddress is the trust remote address on the source chain who send message\\n    /// nonce is inbound message nonce\\n    /// payLoadHash is the keccak256 of message payload\\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\\n\\n    event UpdateDestination(uint16 indexed lzChainId, bytes destination);\\n    event MessageFailed(uint16 indexed srcChainId, bytes srcAddress, uint64 nonce, bytes payload);\\n    event SendSynchronizationProgress(uint16 indexed dstChainId, uint64 nonce, bytes32 syncHash, uint progress);\\n    event ReceiveSynchronizationProgress(uint16 indexed srcChainId, uint64 nonce, bytes32 syncHash, uint progress);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/interfaces/IZkLink.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title ZkLink interface contract\\n/// @author zk.link\\ninterface IZkLink {\\n    // stored block info of ZkLink\\n    struct StoredBlockInfo {\\n        uint32 blockNumber;\\n        uint64 priorityOperations;\\n        bytes32 pendingOnchainOperationsHash;\\n        uint256 timestamp;\\n        bytes32 stateHash;\\n        bytes32 commitment;\\n        bytes32 syncHash;\\n    }\\n\\n    /// @notice Get synchronized progress of zkLink contract known on deployed chain\\n    function getSynchronizedProgress(StoredBlockInfo memory block) external view returns (uint256 progress);\\n\\n    /// @notice Combine the `progress` of the other chains of a `syncHash` with self\\n    function receiveSynchronizationProgress(bytes32 syncHash, uint256 progress) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev Address of lock flag variable.\\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\\\"ReentrancyGuard\\\") - 1;\\n\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    function initializeReentrancyGuard() internal {\\n        uint256 lockSlotOldValue;\\n\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange every call to nonReentrant\\n        // will be cheaper.\\n        assembly {\\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\\n        }\\n\\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of double initialization\\n        require(lockSlotOldValue == 0, \\\"1B\\\");\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        uint256 _status;\\n        assembly {\\n            _status := sload(LOCK_FLAG_ADDRESS)\\n        }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status == _NOT_ENTERED);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\\n        }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"contract IZkLink\",\"name\":\"_zklink\",\"type\":\"address\"},{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"_endpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"MessageFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"syncHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"progress\",\"type\":\"uint256\"}],\"name\":\"ReceiveSynchronizationProgress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"syncHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"progress\",\"type\":\"uint256\"}],\"name\":\"SendSynchronizationProgress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"lzChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"destination\",\"type\":\"bytes\"}],\"name\":\"UpdateDestination\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"pendingOnchainOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct IZkLink.StoredBlockInfo\",\"name\":\"storedBlockInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint16[]\",\"name\":\"dstChainIds\",\"type\":\"uint16[]\"},{\"internalType\":\"address payable\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"name\":\"bridgeZkLinkBlock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"destinations\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"lzChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"syncHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"progress\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateZkLinkBlockBridgeFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"failedMessages\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcPath\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"nonblockingLzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"retryMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"contractAddr\",\"type\":\"bytes\"}],\"name\":\"setDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zklink\",\"outputs\":[{\"internalType\":\"contract IZkLink\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LayerZeroBridge", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000344a908d1a7b7d06b7ad7169c1db81fc9d496de9000000000000000000000000b86934fa6e53e15320911485c775d4ba4020fa5a00000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd675", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}