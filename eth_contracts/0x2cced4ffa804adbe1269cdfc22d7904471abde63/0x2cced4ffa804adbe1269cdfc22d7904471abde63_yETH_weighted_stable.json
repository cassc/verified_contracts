{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title yETH weighted stableswap pool\r\n@author 0xkorin, Yearn Finance\r\n@license GNU AGPLv3\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface ERC20Ext:\r\n    def decimals() -> uint8: view\r\n\r\ninterface RateProvider:\r\n    def rate(_asset: address) -> uint256: view\r\n\r\ninterface PoolToken:\r\n    def mint(_account: address, _value: uint256): nonpayable\r\n    def burn(_account: address, _value: uint256): nonpayable\r\n\r\ntoken: public(immutable(address))\r\nsupply: public(uint256)\r\namplification: public(uint256) # A f^n\r\nstaking: public(address)\r\nnum_assets: public(uint256)\r\nassets: public(address[MAX_NUM_ASSETS])\r\nrate_providers: public(address[MAX_NUM_ASSETS])\r\npacked_vbs: uint256[MAX_NUM_ASSETS] # x_i = b_i r_i (96) | r_i (80) | w_i (20) | target w_i (20) | lower (20) | upper (20)\r\nmanagement: public(address)\r\npending_management: public(address)\r\nguardian: public(address)\r\npaused: public(bool)\r\nkilled: public(bool)\r\nswap_fee_rate: public(uint256)\r\nramp_step: public(uint256)\r\nramp_last_time: public(uint256)\r\nramp_stop_time: public(uint256)\r\ntarget_amplification: public(uint256)\r\npacked_pool_vb: uint256 # vb_prod (128) | vb_sum (128)\r\n# vb_prod: pi, product term `product((w_i * D / x_i)^(w_i n))`\r\n# vb_sum: sigma, sum term `sum(x_i)`\r\n\r\nevent Swap:\r\n    account: indexed(address)\r\n    receiver: address\r\n    asset_in: indexed(uint256)\r\n    asset_out: indexed(uint256)\r\n    amount_in: uint256\r\n    amount_out: uint256\r\n\r\nevent AddLiquidity:\r\n    account: indexed(address)\r\n    receiver: indexed(address)\r\n    amounts_in: DynArray[uint256, MAX_NUM_ASSETS]\r\n    lp_amount: uint256\r\n\r\nevent RemoveLiquidity:\r\n    account: indexed(address)\r\n    receiver: indexed(address)\r\n    lp_amount: uint256\r\n\r\nevent RemoveLiquiditySingle:\r\n    account: indexed(address)\r\n    receiver: indexed(address)\r\n    asset: indexed(uint256)\r\n    amount_out: uint256\r\n    lp_amount: uint256\r\n\r\nevent RateUpdate:\r\n    asset: indexed(uint256)\r\n    rate: uint256\r\n\r\nevent Pause:\r\n    account: indexed(address)\r\n\r\nevent Unpause:\r\n    account: indexed(address)\r\n\r\nevent Kill: pass\r\n\r\nevent AddAsset:\r\n    index: uint256\r\n    asset: address\r\n    rate_provider: address\r\n    rate: uint256\r\n    weight: uint256\r\n    amount: uint256\r\n\r\nevent SetSwapFeeRate:\r\n    rate: uint256\r\n\r\nevent SetWeightBand:\r\n    asset: indexed(uint256)\r\n    lower: uint256\r\n    upper: uint256\r\n\r\nevent SetRateProvider:\r\n    asset: uint256\r\n    rate_provider: address\r\n\r\nevent SetRamp:\r\n    amplification: uint256\r\n    weights: DynArray[uint256, MAX_NUM_ASSETS]\r\n    duration: uint256\r\n    start: uint256\r\n\r\nevent SetRampStep:\r\n    ramp_step: uint256\r\n\r\nevent StopRamp: pass\r\n\r\nevent SetStaking:\r\n    staking: address\r\n\r\nevent PendingManagement:\r\n    management: address\r\n\r\nevent SetManagement:\r\n    management: address\r\n\r\nevent SetGuardian:\r\n    acount: indexed(address)\r\n    guardian: address\r\n\r\nPRECISION: constant(uint256) = 1_000_000_000_000_000_000\r\nMAX_NUM_ASSETS: constant(uint256) = 32\r\nALL_ASSETS_FLAG: constant(uint256) = 14528991250861404666834535435384615765856667510756806797353855100662256435713 # sum((i+1) << 8*i)\r\nPOOL_VB_MASK: constant(uint256) = 2**128 - 1\r\nPOOL_VB_SHIFT: constant(int128) = -128\r\n\r\nVB_MASK: constant(uint256) = 2**96 - 1\r\nRATE_MASK: constant(uint256) = 2**80 - 1\r\nRATE_SHIFT: constant(int128) = -96\r\nPACKED_WEIGHT_SHIFT: constant(int128) = -176\r\n\r\nWEIGHT_SCALE: constant(uint256) = 1_000_000_000_000\r\nWEIGHT_MASK: constant(uint256) = 2**20 - 1\r\nTARGET_WEIGHT_SHIFT: constant(int128) = -20\r\nLOWER_BAND_SHIFT: constant(int128) = -40\r\nUPPER_BAND_SHIFT: constant(int128) = -60\r\n\r\n# powers of 10\r\nE3: constant(int256)               = 1_000\r\nE6: constant(int256)               = E3 * E3\r\nE9: constant(int256)               = E3 * E6\r\nE12: constant(int256)              = E3 * E9\r\nE15: constant(int256)              = E3 * E12\r\nE17: constant(int256)              = 100 * E15\r\nE18: constant(int256)              = E3 * E15\r\nE20: constant(int256)              = 100 * E18\r\nE36: constant(int256)              = E18 * E18\r\nMAX_POW_REL_ERR: constant(uint256) = 100 # 1e-16\r\nMIN_NAT_EXP: constant(int256)      = -41 * E18\r\nMAX_NAT_EXP: constant(int256)      = 130 * E18\r\nLOG36_LOWER: constant(int256)      = E18 - E17\r\nLOG36_UPPER: constant(int256)      = E18 + E17\r\nMILD_EXP_BOUND: constant(uint256)  = 2**254 / 100_000_000_000_000_000_000\r\n\r\n# x_n = 2^(7-n), a_n = exp(x_n)\r\n# in 20 decimals for n >= 2\r\nX0: constant(int256)  = 128 * E18 # 18 decimals\r\nA0: constant(int256)  = 38_877_084_059_945_950_922_200 * E15 * E18 # no decimals\r\nX1: constant(int256)  = X0 / 2 # 18 decimals\r\nA1: constant(int256)  = 6_235_149_080_811_616_882_910 * E6 # no decimals\r\nX2: constant(int256)  = X1 * 100 / 2\r\nA2: constant(int256)  = 7_896_296_018_268_069_516_100 * E12\r\nX3: constant(int256)  = X2 / 2\r\nA3: constant(int256)  = 888_611_052_050_787_263_676 * E6\r\nX4: constant(int256)  = X3 / 2\r\nA4: constant(int256)  = 298_095_798_704_172_827_474 * E3\r\nX5: constant(int256)  = X4 / 2\r\nA5: constant(int256)  = 5_459_815_003_314_423_907_810\r\nX6: constant(int256)  = X5 / 2\r\nA6: constant(int256)  = 738_905_609_893_065_022_723\r\nX7: constant(int256)  = X6 / 2\r\nA7: constant(int256)  = 271_828_182_845_904_523_536\r\nX8: constant(int256)  = X7 / 2\r\nA8: constant(int256)  = 164_872_127_070_012_814_685\r\nX9: constant(int256)  = X8 / 2\r\nA9: constant(int256)  = 128_402_541_668_774_148_407\r\nX10: constant(int256) = X9 / 2\r\nA10: constant(int256) = 11_331_4845_306_682_631_683\r\nX11: constant(int256) = X10 / 2\r\nA11: constant(int256) = 1_064_49_445_891_785_942_956\r\n\r\n@external\r\ndef __init__(\r\n    _token: address, \r\n    _amplification: uint256,\r\n    _assets: DynArray[address, MAX_NUM_ASSETS], \r\n    _rate_providers: DynArray[address, MAX_NUM_ASSETS], \r\n    _weights: DynArray[uint256, MAX_NUM_ASSETS]\r\n):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _token The address of the pool LP token\r\n    @param _amplification The pool amplification factor (in 18 decimals)\r\n    @param _assets Array of addresses of tokens in the pool\r\n    @param _rate_providers Array of addresses of rate provider for each asset\r\n    @param _weights Weight of each asset (in 18 decimals)\r\n    @dev Only non-rebasing assets with 18 decimals are supported\r\n    @dev Weights need to sum to unity\r\n    \"\"\"\r\n    num_assets: uint256 = len(_assets)\r\n    assert num_assets >= 2\r\n    assert len(_rate_providers) == num_assets and len(_weights) == num_assets\r\n    assert _token != empty(address)\r\n    assert _amplification > 0\r\n\r\n    token = _token\r\n    self.amplification = _amplification\r\n    self.num_assets = num_assets\r\n    \r\n    weight_sum: uint256 = 0\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        assert _assets[asset] != empty(address)\r\n        assert ERC20Ext(_assets[asset]).decimals() == 18\r\n        self.assets[asset] = _assets[asset]\r\n        assert _rate_providers[asset] != empty(address)\r\n        self.rate_providers[asset] = _rate_providers[asset]\r\n        assert _weights[asset] > 0\r\n        packed_weight: uint256 = self._pack_weight(_weights[asset], _weights[asset], PRECISION, PRECISION)\r\n        self.packed_vbs[asset] = self._pack_vb(0, 0, packed_weight)\r\n        weight_sum += _weights[asset]\r\n    assert weight_sum == PRECISION\r\n\r\n    self.ramp_step = 1\r\n    self.management = msg.sender\r\n    self.guardian = msg.sender\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef swap(\r\n    _i: uint256, \r\n    _j: uint256, \r\n    _dx: uint256, \r\n    _min_dy: uint256, \r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Swap one pool asset for another\r\n    @param _i Index of the input asset\r\n    @param _j Index of the output asset\r\n    @param _dx Amount of input asset to take from caller\r\n    @param _min_dy Minimum amount of output asset to send\r\n    @param _receiver Account to receive the output asset\r\n    @return The amount of output asset sent\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    assert _i != _j # dev: same input and output asset\r\n    assert _i < num_assets and _j < num_assets # dev: index out of bounds\r\n    assert _dx > 0 # dev: zero amount\r\n\r\n    # update rates for from and to assets\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, vb_sum = self._update_rates(unsafe_add(_i, 1) | shift(unsafe_add(_j, 1), 8), vb_prod, vb_sum)\r\n    prev_vb_sum: uint256 = vb_sum\r\n\r\n    prev_vb_x: uint256 = 0\r\n    rate_x: uint256 = 0\r\n    packed_weight_x: uint256 = 0\r\n    prev_vb_x, rate_x, packed_weight_x = self._unpack_vb(self.packed_vbs[_i])\r\n    wn_x: uint256 = self._unpack_wn(packed_weight_x, num_assets)\r\n\r\n    prev_vb_y: uint256 = 0\r\n    rate_y: uint256 = 0\r\n    packed_weight_y: uint256 = 0\r\n    prev_vb_y, rate_y, packed_weight_y = self._unpack_vb(self.packed_vbs[_j])\r\n    wn_y: uint256 = self._unpack_wn(packed_weight_y, num_assets)\r\n\r\n    dx_fee: uint256 = _dx * self.swap_fee_rate / PRECISION\r\n    dvb_x: uint256 = (_dx - dx_fee) * rate_x / PRECISION\r\n    vb_x: uint256 = prev_vb_x + dvb_x\r\n    \r\n    # update x_i and remove x_j from variables\r\n    vb_prod = vb_prod * self._pow_up(prev_vb_y, wn_y) / self._pow_down(vb_x * PRECISION / prev_vb_x, wn_x)\r\n    vb_sum = vb_sum + dvb_x - prev_vb_y\r\n\r\n    # calulate new balance of out token\r\n    vb_y: uint256 = self._calc_vb(wn_y, prev_vb_y, self.supply, self.amplification, vb_prod, vb_sum)\r\n    vb_sum += vb_y\r\n\r\n    # check bands\r\n    self._check_bands(prev_vb_x * PRECISION / prev_vb_sum, vb_x * PRECISION / vb_sum, packed_weight_x)\r\n    self._check_bands(prev_vb_y * PRECISION / prev_vb_sum, vb_y * PRECISION / vb_sum, packed_weight_y)\r\n\r\n    dy: uint256 = (prev_vb_y - vb_y) * PRECISION / rate_y\r\n    assert dy >= _min_dy, \"slippage\"\r\n\r\n    if dx_fee > 0:\r\n        # add fee to pool\r\n        dvb_x = dx_fee * rate_x / PRECISION\r\n        vb_prod = vb_prod * PRECISION / self._pow_down((vb_x + dvb_x) * PRECISION / vb_x, wn_x)\r\n        vb_x += dvb_x\r\n        vb_sum += dvb_x\r\n\r\n    # update variables\r\n    self.packed_vbs[_i] = self._pack_vb(vb_x, rate_x, packed_weight_x)\r\n    self.packed_vbs[_j] = self._pack_vb(vb_y, rate_y, packed_weight_y)\r\n    vb_prod = vb_prod * PRECISION / self._pow_up(vb_y, wn_y)\r\n    \r\n    # mint fees\r\n    if dx_fee > 0:\r\n        supply: uint256 = 0\r\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\r\n\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n\r\n    # transfer tokens\r\n    assert ERC20(self.assets[_i]).transferFrom(msg.sender, self, _dx, default_return_value=True)\r\n    assert ERC20(self.assets[_j]).transfer(_receiver, dy, default_return_value=True)\r\n    log Swap(msg.sender, _receiver, _i, _j, _dx, dy)\r\n\r\n    return dy\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef swap_exact_out(\r\n    _i: uint256, \r\n    _j: uint256, \r\n    _dy: uint256, \r\n    _max_dx: uint256, \r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Swap one pool asset for another, with a fixed output amount\r\n    @param _i Index of the input asset\r\n    @param _j Index of the output asset\r\n    @param _dy Amount of output asset to send\r\n    @param _max_dx Maximum amount of input asset to take from caller\r\n    @param _receiver Account to receive the output asset\r\n    @return The amount of input asset taken\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    assert _i != _j # dev: same input and output asset\r\n    assert _i < num_assets and _j < num_assets # dev: index out of bounds\r\n    assert _dy > 0 # dev: zero amount\r\n\r\n    # update rates for from and to assets\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, vb_sum = self._update_rates(unsafe_add(_i, 1) | shift(unsafe_add(_j, 1), 8), vb_prod, vb_sum)\r\n    prev_vb_sum: uint256 = vb_sum\r\n\r\n    prev_vb_x: uint256 = 0\r\n    rate_x: uint256 = 0\r\n    packed_weight_x: uint256 = 0\r\n    prev_vb_x, rate_x, packed_weight_x = self._unpack_vb(self.packed_vbs[_i])\r\n    wn_x: uint256 = self._unpack_wn(packed_weight_x, num_assets)\r\n\r\n    prev_vb_y: uint256 = 0\r\n    rate_y: uint256 = 0\r\n    packed_weight_y: uint256 = 0\r\n    prev_vb_y, rate_y, packed_weight_y = self._unpack_vb(self.packed_vbs[_j])\r\n    wn_y: uint256 = self._unpack_wn(packed_weight_y, num_assets)\r\n\r\n    dvb_y: uint256 = _dy * rate_y / PRECISION\r\n    vb_y: uint256 = prev_vb_y - dvb_y\r\n\r\n    # update x_j and remove x_i from variables\r\n    vb_prod = vb_prod * self._pow_up(prev_vb_x, wn_x) / self._pow_down(vb_y * PRECISION / prev_vb_y, wn_y)\r\n    vb_sum = vb_sum - dvb_y - prev_vb_x\r\n\r\n    # calulate new balance of in token\r\n    vb_x: uint256 = self._calc_vb(wn_x, prev_vb_x, self.supply, self.amplification, vb_prod, vb_sum)\r\n    dx: uint256 = (vb_x - prev_vb_x) * PRECISION / rate_x\r\n    dx_fee: uint256 = self.swap_fee_rate\r\n    dx_fee = dx * dx_fee / (PRECISION - dx_fee)\r\n    dx += dx_fee\r\n    vb_x += dx_fee * rate_x / PRECISION\r\n    vb_sum += vb_x\r\n    assert dx <= _max_dx, \"slippage\"\r\n\r\n    # check bands\r\n    self._check_bands(prev_vb_x * PRECISION / prev_vb_sum, vb_x * PRECISION / vb_sum, packed_weight_x)\r\n    self._check_bands(prev_vb_y * PRECISION / prev_vb_sum, vb_y * PRECISION / vb_sum, packed_weight_y)\r\n\r\n    # update variables\r\n    self.packed_vbs[_i] = self._pack_vb(vb_x, rate_x, packed_weight_x)\r\n    self.packed_vbs[_j] = self._pack_vb(vb_y, rate_y, packed_weight_y)\r\n    vb_prod = vb_prod * PRECISION / self._pow_up(vb_x, wn_x)\r\n\r\n    # mint fees\r\n    if dx_fee > 0:\r\n        supply: uint256 = 0\r\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\r\n\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n\r\n    assert ERC20(self.assets[_i]).transferFrom(msg.sender, self, dx, default_return_value=True)\r\n    assert ERC20(self.assets[_j]).transfer(_receiver, _dy, default_return_value=True)\r\n    log Swap(msg.sender, _receiver, _i, _j, dx, _dy)\r\n\r\n    return dx\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(\r\n    _amounts: DynArray[uint256, MAX_NUM_ASSETS], \r\n    _min_lp_amount: uint256, \r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit assets into the pool\r\n    @param _amounts Array of amount for each asset to take from caller\r\n    @param _min_lp_amount Minimum amount of LP tokens to mint\r\n    @param _receiver Account to receive the LP tokens\r\n    @return The amount of LP tokens minted\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    assert len(_amounts) == num_assets\r\n\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n\r\n    prev_vb: uint256 = 0\r\n    rate: uint256 = 0\r\n    packed_weight: uint256 = 0\r\n\r\n    # find lowest relative increase in balance\r\n    assets: uint256 = 0\r\n    lowest: uint256 = max_value(uint256)\r\n    sh: int128 = 0\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        if _amounts[asset] > 0:\r\n            assets = assets | shift(unsafe_add(asset, 1), sh)\r\n            sh = unsafe_add(sh, 8)\r\n            if vb_sum > 0 and lowest > 0:\r\n                prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n                lowest = min(_amounts[asset] * rate / prev_vb, lowest)\r\n        else:\r\n            lowest = 0\r\n    assert sh > 0 # dev: need to deposit at least one asset\r\n\r\n    # update rates\r\n    vb_prod, vb_sum = self._update_rates(assets, vb_prod, vb_sum)\r\n    prev_supply: uint256 = self.supply\r\n\r\n    vb_prod_final: uint256 = vb_prod\r\n    vb_sum_final: uint256 = vb_sum\r\n    fee_rate: uint256 = self.swap_fee_rate / 2\r\n    prev_vb_sum: uint256 = vb_sum\r\n    prev_ratios: DynArray[uint256, MAX_NUM_ASSETS] = []\r\n    vb: uint256 = 0\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n\r\n        amount: uint256 = _amounts[asset]\r\n        if amount == 0:\r\n            assert prev_supply > 0 # dev: initial deposit amounts must be non-zero\r\n            continue\r\n\r\n        # update stored virtual balance\r\n        prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n        dvb: uint256 = amount * rate / PRECISION\r\n        vb = prev_vb + dvb\r\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\r\n\r\n        if prev_supply > 0:\r\n            prev_ratios.append(prev_vb * PRECISION / prev_vb_sum)\r\n            wn: uint256 = self._unpack_wn(packed_weight, num_assets)\r\n\r\n            # update product and sum of virtual balances\r\n            vb_prod_final = vb_prod_final * self._pow_up(prev_vb * PRECISION / vb, wn) / PRECISION\r\n            # the `D^n` factor will be updated in `_calc_supply()`\r\n            vb_sum_final += dvb\r\n\r\n            # remove fees from balance and recalculate sum and product\r\n            fee: uint256 = (dvb - prev_vb * lowest / PRECISION) * fee_rate / PRECISION\r\n            vb_prod = vb_prod * self._pow_up(prev_vb * PRECISION / (vb - fee), wn) / PRECISION\r\n            vb_sum += dvb - fee\r\n        assert ERC20(self.assets[asset]).transferFrom(msg.sender, self, amount, default_return_value=True)\r\n\r\n    supply: uint256 = prev_supply\r\n    if prev_supply == 0:\r\n        # initital deposit, calculate necessary variables\r\n        vb_prod, vb_sum = self._calc_vb_prod_sum()\r\n        assert vb_prod > 0 # dev: amounts must be non-zero\r\n        supply = vb_sum\r\n    else:\r\n        # check bands\r\n        j: uint256 = 0\r\n        for asset in range(MAX_NUM_ASSETS):\r\n            if asset == num_assets:\r\n                break\r\n            if _amounts[asset] == 0:\r\n                continue\r\n            vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n            self._check_bands(prev_ratios[j], vb * PRECISION / vb_sum_final, packed_weight)\r\n            j = unsafe_add(j, 1)\r\n\r\n    # mint LP tokens\r\n    supply, vb_prod = self._calc_supply(num_assets, supply, self.amplification, vb_prod, vb_sum, prev_supply == 0)\r\n    mint: uint256 = supply - prev_supply\r\n    assert mint > 0 and mint >= _min_lp_amount, \"slippage\"\r\n    PoolToken(token).mint(_receiver, mint)\r\n    log AddLiquidity(msg.sender, _receiver, _amounts, mint)\r\n\r\n    supply_final: uint256 = supply\r\n    if prev_supply > 0:\r\n        # mint fees\r\n        supply_final, vb_prod_final = self._calc_supply(num_assets, prev_supply, self.amplification, vb_prod_final, vb_sum_final, True)\r\n        PoolToken(token).mint(self.staking, supply_final - supply)\r\n    else:\r\n        vb_prod_final = vb_prod\r\n        vb_sum_final = vb_sum\r\n\r\n    self.supply = supply_final\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod_final, vb_sum_final)\r\n\r\n    return mint\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(\r\n    _lp_amount: uint256, \r\n    _min_amounts: DynArray[uint256, MAX_NUM_ASSETS], \r\n    _receiver: address = msg.sender\r\n):\r\n    \"\"\"\r\n    @notice Withdraw assets from the pool in a balanced manner\r\n    @param _lp_amount Amount of LP tokens to burn\r\n    @param _min_amounts Array of minimum amount of each asset to send\r\n    @param _receiver Account to receive the assets\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    assert len(_min_amounts) == num_assets\r\n\r\n    # update supply\r\n    prev_supply: uint256 = self.supply\r\n    supply: uint256 = prev_supply - _lp_amount\r\n    self.supply = supply\r\n    PoolToken(token).burn(msg.sender, _lp_amount)\r\n    log RemoveLiquidity(msg.sender, _receiver, _lp_amount)\r\n\r\n    # update necessary variables and transfer assets\r\n    vb_prod: uint256 = PRECISION\r\n    vb_sum: uint256 = 0\r\n\r\n    prev_vb: uint256 = 0\r\n    rate: uint256 = 0\r\n    packed_weight: uint256 = 0\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n        weight: uint256 = self._unpack_wn(packed_weight, 1)\r\n\r\n        dvb: uint256 = prev_vb * _lp_amount / prev_supply\r\n        vb: uint256 = prev_vb - dvb\r\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\r\n        \r\n        vb_prod = unsafe_div(unsafe_mul(vb_prod, self._pow_down(unsafe_div(unsafe_mul(supply, weight), vb), unsafe_mul(weight, num_assets))), PRECISION)\r\n        vb_sum = unsafe_add(vb_sum, vb)\r\n\r\n        amount: uint256 = dvb * PRECISION / rate\r\n        assert amount >= _min_amounts[asset], \"slippage\"\r\n        assert ERC20(self.assets[asset]).transfer(_receiver, amount, default_return_value=True)\r\n\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_single(\r\n    _asset: uint256, \r\n    _lp_amount: uint256, \r\n    _min_amount: uint256, \r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw a single asset from the pool\r\n    @param _asset Index of the asset to withdraw\r\n    @param _lp_amount Amount of LP tokens to burn\r\n    @param _min_amount Minimum amount of asset to send\r\n    @param _receiver Account to receive the asset\r\n    @return The amount of asset sent\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    assert _asset < num_assets # dev: index out of bounds\r\n\r\n    # update rate\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, vb_sum = self._update_rates(unsafe_add(_asset, 1), vb_prod, vb_sum)\r\n    prev_vb_sum: uint256 = vb_sum\r\n\r\n    # update supply\r\n    prev_supply: uint256 = self.supply\r\n    supply: uint256 = prev_supply - _lp_amount\r\n    self.supply = supply\r\n    PoolToken(token).burn(msg.sender, _lp_amount)\r\n\r\n    prev_vb: uint256 = 0\r\n    rate: uint256 = 0\r\n    packed_weight: uint256 = 0\r\n    prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[_asset])\r\n    wn: uint256 = self._unpack_wn(packed_weight, num_assets)\r\n\r\n    # update variables\r\n    vb_prod = vb_prod * self._pow_up(prev_vb, wn) / PRECISION\r\n    for i in range(MAX_NUM_ASSETS):\r\n        if i == num_assets:\r\n            break\r\n        vb_prod = vb_prod * supply / prev_supply\r\n    vb_sum = vb_sum - prev_vb\r\n\r\n    # calculate new balance of asset\r\n    vb: uint256 = self._calc_vb(wn, prev_vb, supply, self.amplification, vb_prod, vb_sum)\r\n    dvb: uint256 = prev_vb - vb\r\n    fee: uint256 = dvb * self.swap_fee_rate / 2 / PRECISION\r\n    dvb -= fee\r\n    vb += fee\r\n    dx: uint256 = dvb * PRECISION / rate\r\n    assert dx > _min_amount, \"slippage\"\r\n\r\n    # update variables\r\n    self.packed_vbs[_asset] = self._pack_vb(vb, rate, packed_weight)\r\n    vb_prod = vb_prod * PRECISION / self._pow_up(vb, wn)\r\n    vb_sum = vb_sum + vb\r\n\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        if asset == _asset:\r\n            self._check_bands(prev_vb * PRECISION / prev_vb_sum, vb * PRECISION / vb_sum, packed_weight)\r\n        else:\r\n            vb_loop: uint256 = 0\r\n            rate_loop: uint256 = 0\r\n            packed_weight_loop: uint256 = 0\r\n            vb_loop, rate_loop, packed_weight_loop = self._unpack_vb(self.packed_vbs[asset])\r\n            self._check_bands(vb_loop * PRECISION / prev_vb_sum, vb_loop * PRECISION / vb_sum, packed_weight_loop)\r\n\r\n    if fee > 0:\r\n        # mint fee\r\n        supply, vb_prod = self._update_supply(supply, vb_prod, vb_sum)\r\n\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n\r\n    assert ERC20(self.assets[_asset]).transfer(_receiver, dx, default_return_value=True)\r\n    log RemoveLiquiditySingle(msg.sender, _receiver, _asset, dx, _lp_amount)\r\n    return dx\r\n\r\n@external\r\ndef update_rates(_assets: DynArray[uint256, MAX_NUM_ASSETS]):\r\n    \"\"\"\r\n    @notice Update the stored rate of any of the pool's assets\r\n    @param _assets Array of indices of assets to update\r\n    @dev If no assets are passed in, every asset will be updated\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    assets: uint256 = 0\r\n    for i in range(MAX_NUM_ASSETS):\r\n        if i == len(_assets):\r\n            break\r\n        assert _assets[i] < num_assets # dev: index out of bounds\r\n        assets = assets | shift(_assets[i] + 1, unsafe_mul(8, convert(i, int128)))\r\n\r\n    if len(_assets) == 0:\r\n        assets = ALL_ASSETS_FLAG\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, vb_sum = self._update_rates(assets, vb_prod, vb_sum)\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n\r\n@external\r\ndef update_weights() -> bool:\r\n    \"\"\"\r\n    @notice Update weights and amplification factor, if possible\r\n    @return Boolean to indicate whether the weights and amplification factor have been updated\r\n    @dev Will only update the weights if a ramp is active and at least the minimum time step has been reached\r\n    \"\"\"\r\n    assert not self.paused # dev: paused\r\n    updated: bool = False\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, updated = self._update_weights(vb_prod)\r\n    if updated and vb_sum > 0:\r\n        supply: uint256 = 0\r\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\r\n        self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n    return updated\r\n\r\n@external\r\n@view\r\ndef vb_prod_sum() -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the pool's virtual balance product (pi) and sum (sigma)\r\n    @return Tuple with product and sum\r\n    \"\"\"\r\n    return self._unpack_pool_vb(self.packed_pool_vb)\r\n\r\n@external\r\n@view\r\ndef virtual_balance(_asset: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the virtual balance of an asset\r\n    @param _asset Index of the asset\r\n    @return Virtual balance of asset\r\n    \"\"\"\r\n    assert _asset < self.num_assets # dev: index out of bounds\r\n    return self.packed_vbs[_asset] & VB_MASK\r\n\r\n@external\r\n@view\r\ndef rate(_asset: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the rate of an asset\r\n    @param _asset Index of the asset\r\n    @return Rate of asset\r\n    \"\"\"\r\n    assert _asset < self.num_assets # dev: index out of bounds\r\n    return shift(self.packed_vbs[_asset], RATE_SHIFT) & RATE_MASK\r\n\r\n@external\r\n@view\r\ndef weight(_asset: uint256) -> (uint256, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the weight of an asset\r\n    @param _asset Index of the asset\r\n    @return Tuple with weight, target weight, lower band width and upper weight band width\r\n    @dev Does not take into account any active ramp\r\n    \"\"\"\r\n    assert _asset < self.num_assets # dev: index out of bounds\r\n    weight: uint256 = 0\r\n    target: uint256 = 0\r\n    lower: uint256 = 0\r\n    upper: uint256 = 0\r\n    weight, target, lower, upper = self._unpack_weight(shift(self.packed_vbs[_asset], PACKED_WEIGHT_SHIFT))\r\n    if self.ramp_last_time == 0:\r\n        target = weight\r\n    return weight, target, lower, upper\r\n\r\n@external\r\n@view\r\ndef packed_weight(_asset: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the packed weight of an asset in a packed format\r\n    @param _asset Index of the asset\r\n    @return Weight in packed format\r\n    @dev Does not take into account any active ramp\r\n    \"\"\"\r\n    assert _asset < self.num_assets # dev: index out of bounds\r\n    return shift(self.packed_vbs[_asset], PACKED_WEIGHT_SHIFT)\r\n\r\n# PRIVILEGED FUNCTIONS\r\n\r\n@external\r\ndef pause():\r\n    \"\"\"\r\n    @notice Pause the pool\r\n    \"\"\"\r\n    assert msg.sender == self.management or msg.sender == self.guardian\r\n    assert not self.paused # dev: already paused\r\n    self.paused = True\r\n    log Pause(msg.sender)\r\n\r\n@external\r\ndef unpause():\r\n    \"\"\"\r\n    @notice Unpause the pool\r\n    \"\"\"\r\n    assert msg.sender == self.management or msg.sender == self.guardian\r\n    assert self.paused # dev: not paused\r\n    assert not self.killed # dev: killed\r\n    self.paused = False\r\n    log Unpause(msg.sender)\r\n\r\n@external\r\ndef kill():\r\n    \"\"\"\r\n    @notice Kill the pool\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert self.paused # dev: not paused\r\n    assert not self.killed # dev: already killed\r\n    self.killed = True\r\n    log Kill()\r\n\r\n@external\r\ndef add_asset(\r\n    _asset: address, \r\n    _rate_provider: address, \r\n    _weight: uint256, \r\n    _lower: uint256, \r\n    _upper: uint256, \r\n    _amount: uint256, \r\n    _amplification: uint256,\r\n    _min_lp_amount: uint256,\r\n    _receiver: address = msg.sender\r\n):\r\n    \"\"\"\r\n    @notice Add a new asset to the pool\r\n    @param _asset Address of the asset to add\r\n    @param _rate_provider Rate provider for asset\r\n    @param _weight Weight of the new asset\r\n    @param _lower Lower band width\r\n    @param _upper Upper band width\r\n    @param _amount Amount of tokens\r\n    @param _amplification New pool amplification factor\r\n    @param _receiver Account to receive the LP tokens minted\r\n    @dev Can only be called if no ramp is currently active\r\n    @dev Every other asset will have their weight reduced pro rata\r\n    @dev Caller should assure that effective amplification before and after call are the same\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n\r\n    assert _amount > 0\r\n    prev_num_assets: uint256 = self.num_assets\r\n    assert prev_num_assets < MAX_NUM_ASSETS # dev: pool is full\r\n    assert _amplification > 0\r\n    assert self.ramp_last_time == 0 # dev: ramp active\r\n    assert self.supply > 0 # dev: pool empty\r\n\r\n    assert _weight > 0 and _weight <= PRECISION/100\r\n    assert _lower <= PRECISION\r\n    assert _upper <= PRECISION\r\n\r\n    # update weights for existing assets\r\n    num_assets: uint256 = prev_num_assets + 1\r\n    vb: uint256 = 0\r\n    rate: uint256 = 0\r\n    packed_weight: uint256 = 0\r\n    prev_weight: uint256 = 0\r\n    target: uint256 = 0\r\n    lower: uint256 = 0\r\n    upper: uint256 = 0\r\n    for i in range(MAX_NUM_ASSETS):\r\n        if i == prev_num_assets:\r\n            break\r\n        assert self.assets[i] != _asset # dev: asset already part of pool\r\n        vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[i])\r\n        prev_weight, target, lower, upper = self._unpack_weight(packed_weight)\r\n        packed_weight = self._pack_weight(unsafe_sub(prev_weight, unsafe_div(unsafe_mul(prev_weight, _weight), PRECISION)), target, lower, upper)\r\n        self.packed_vbs[i] = self._pack_vb(vb, rate, packed_weight)\r\n    \r\n    assert ERC20Ext(_asset).decimals() == 18\r\n    rate = RateProvider(_rate_provider).rate(_asset)\r\n    assert rate > 0 # dev: no rate\r\n\r\n    vb = _amount * rate / PRECISION\r\n    packed_weight = self._pack_weight(_weight, _weight, _lower, _upper)\r\n\r\n    # set parameters for new asset\r\n    self.num_assets = num_assets\r\n    self.assets[prev_num_assets] = _asset\r\n    self.rate_providers[prev_num_assets] = _rate_provider\r\n    self.packed_vbs[prev_num_assets] = self._pack_vb(vb, rate, packed_weight)\r\n\r\n    # recalculate variables\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._calc_vb_prod_sum()\r\n\r\n    # update supply\r\n    prev_supply: uint256 = self.supply\r\n    supply: uint256 = 0\r\n    supply, vb_prod = self._calc_supply(num_assets, vb_sum, _amplification, vb_prod, vb_sum, True)\r\n\r\n    self.amplification = _amplification\r\n    self.supply = supply\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n\r\n    assert ERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True)\r\n    assert supply > prev_supply\r\n    lp_amount: uint256 = unsafe_sub(supply, prev_supply)\r\n    assert lp_amount >= _min_lp_amount\r\n    PoolToken(token).mint(_receiver, lp_amount)\r\n    log AddAsset(prev_num_assets, _asset, _rate_provider, rate, _weight, _amount)\r\n\r\n@external\r\ndef rescue(_token: address, _receiver: address):\r\n    \"\"\"\r\n    @notice Rescue tokens from this contract\r\n    @param _token The token to be rescued\r\n    @param _receiver Receiver of rescued tokens\r\n    @dev Can't be used to rescue pool assets\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    num_assets: uint256 = self.num_assets\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        assert _token != self.assets[asset] # dev: cant rescue pool asset\r\n    amount: uint256 = ERC20(_token).balanceOf(self)\r\n    assert ERC20(_token).transfer(_receiver, amount, default_return_value=True)\r\n\r\n@external\r\ndef skim(_asset: uint256, _receiver: address):\r\n    \"\"\"\r\n    @notice Skim surplus of a pool asset\r\n    @param _asset Index of the asset\r\n    @param _receiver Receiver of skimmed tokens\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _asset < self.num_assets # dev: index out of bounds\r\n    vb: uint256 = 0\r\n    rate: uint256 = 0\r\n    packed_weight: uint256 = 0\r\n    vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[_asset])\r\n    expected: uint256 = vb * PRECISION / rate + 1\r\n    token_: address = self.assets[_asset]\r\n    actual: uint256 = ERC20(token_).balanceOf(self)\r\n    assert actual > expected # dev: no surplus\r\n    assert ERC20(token_).transfer(_receiver, actual - expected, default_return_value=True)\r\n\r\n@external\r\ndef set_swap_fee_rate(_fee_rate: uint256):\r\n    \"\"\"\r\n    @notice Set the swap fee rate\r\n    @param _fee_rate New swap fee rate (in 18 decimals)\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _fee_rate <= PRECISION / 100\r\n    self.swap_fee_rate = _fee_rate\r\n    log SetSwapFeeRate(_fee_rate)\r\n\r\n@external\r\ndef set_weight_bands(\r\n    _assets: DynArray[uint256, MAX_NUM_ASSETS], \r\n    _lower: DynArray[uint256, MAX_NUM_ASSETS], \r\n    _upper: DynArray[uint256, MAX_NUM_ASSETS]\r\n):\r\n    \"\"\"\r\n    @notice Set safety weight bands\r\n            If any user operation puts the weight outside of the bands, the transaction will revert\r\n    @param _assets Array of indices of the assets to set the bands for\r\n    @param _lower Array of widths of the lower band\r\n    @param _upper Array of widths of the upper band\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert len(_lower) == len(_assets) and len(_upper) == len(_assets)\r\n\r\n    num_assets: uint256 = self.num_assets\r\n    for i in range(MAX_NUM_ASSETS):\r\n        if i == len(_assets):\r\n            break\r\n        asset: uint256 = _assets[i]\r\n        assert asset < num_assets # dev: index out of bounds\r\n        assert _lower[i] <= PRECISION and _upper[i] <= PRECISION # dev: bands out of bounds\r\n\r\n        vb: uint256 = 0\r\n        rate: uint256 = 0\r\n        packed_weight: uint256 = 0\r\n        vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n        weight: uint256 = 0\r\n        target: uint256 = 0\r\n        lower: uint256 = 0\r\n        upper: uint256 = 0\r\n        weight, target, lower, upper = self._unpack_weight(packed_weight)\r\n        packed_weight = self._pack_weight(weight, target, _lower[i], _upper[i])\r\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\r\n        log SetWeightBand(asset, _lower[i], _upper[i])\r\n\r\n@external\r\ndef set_rate_provider(_asset: uint256, _rate_provider: address):\r\n    \"\"\"\r\n    @notice Set a rate provider for an asset\r\n    @param _asset Index of the assets\r\n    @param _rate_provider New rate provider for the asset\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _asset < self.num_assets # dev: index out of bounds\r\n\r\n    self.rate_providers[_asset] = _rate_provider\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, vb_sum = self._update_rates(_asset + 1, vb_prod, vb_sum)\r\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n    log SetRateProvider(_asset, _rate_provider)\r\n\r\n@external\r\ndef set_ramp(\r\n    _amplification: uint256, \r\n    _weights: DynArray[uint256, MAX_NUM_ASSETS], \r\n    _duration: uint256, \r\n    _start: uint256 = block.timestamp\r\n):\r\n    \"\"\"\r\n    @notice Schedule an amplification and/or weight change\r\n    @param _amplification New amplification factor (in 18 decimals)\r\n    @param _weights Array of new weight for each asset (in 18 decimals)\r\n    @param _duration Duration of the ramp (in seconds)\r\n    @param _start Ramp start time\r\n    @dev Effective amplification at any time is `self.amplification/f^n`\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n\r\n    num_assets: uint256 = self.num_assets\r\n    assert _amplification > 0\r\n    assert len(_weights) == num_assets\r\n    assert _start >= block.timestamp\r\n\r\n    updated: bool = False\r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = 0\r\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\r\n    vb_prod, updated = self._update_weights(vb_prod)\r\n    if updated:\r\n        supply: uint256 = 0\r\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\r\n        self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\r\n    \r\n    assert self.ramp_last_time == 0 # dev: ramp active\r\n\r\n    self.ramp_last_time = _start\r\n    self.ramp_stop_time = _start + _duration\r\n    \r\n    self.target_amplification = _amplification\r\n\r\n    total: uint256 = 0\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        assert _weights[asset] < PRECISION # dev: weight out of bounds\r\n        total += _weights[asset]\r\n\r\n        vb: uint256 = 0\r\n        rate: uint256 = 0\r\n        packed_weight: uint256 = 0\r\n        vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n        weight: uint256 = 0\r\n        target: uint256 = 0\r\n        lower: uint256 = 0\r\n        upper: uint256 = 0\r\n        weight, target, lower, upper = self._unpack_weight(packed_weight)\r\n        packed_weight = self._pack_weight(weight, _weights[asset], lower, upper)\r\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\r\n    assert total == PRECISION # dev: weights dont add up\r\n    log SetRamp(_amplification, _weights, _duration, _start)\r\n\r\n@external\r\ndef set_ramp_step(_ramp_step: uint256):\r\n    \"\"\"\r\n    @notice Set minimum time between ramp step\r\n    @param _ramp_step Minimum step time (in seconds)\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _ramp_step > 0\r\n    self.ramp_step = _ramp_step\r\n    log SetRampStep(_ramp_step)\r\n\r\n@external\r\ndef stop_ramp():\r\n    \"\"\"\r\n    @notice Stop an active ramp\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.ramp_last_time = 0\r\n    self.ramp_stop_time = 0\r\n    log StopRamp()\r\n\r\n@external\r\ndef set_staking(_staking: address):\r\n    \"\"\"\r\n    @notice Set the address that receives yield, slashings and swap fees\r\n    @param _staking New staking address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _staking != empty(address)\r\n    self.staking = _staking\r\n    log SetStaking(_staking)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice Set the pending management address. Needs to be accepted\r\n    by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice Accept management role. Can only be called by account \r\n    previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)\r\n\r\n@external\r\ndef set_guardian(_guardian: address):\r\n    \"\"\"\r\n    @notice Set the guardian address\r\n    @param _guardian New guardian address\r\n    \"\"\"\r\n    assert msg.sender == self.management or msg.sender == self.guardian\r\n    self.guardian = _guardian\r\n    log SetGuardian(msg.sender, _guardian)\r\n\r\n# INTERNAL FUNCTIONS\r\n\r\n@internal\r\ndef _update_rates(_assets: uint256, _vb_prod: uint256, _vb_sum: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Update rates of specific assets\r\n    @param _assets Integer where each byte represents an asset index offset by one\r\n    @param _vb_prod Product term (pi) before update\r\n    @param _vb_sum Sum term (sigma) before update\r\n    @return Tuple with new product and sum term\r\n    @dev Loops through the bytes in `_assets` until a zero or a number larger than the number of assets is encountered\r\n    @dev Update weights (if needed) prior to checking any rates\r\n    @dev Will recalculate supply and mint/burn to staking contract if any weight or rate has updated\r\n    @dev Will revert if any rate increases by more than 10%, unless called by management\r\n    \"\"\"\r\n    assert not self.paused, \"paused\"\r\n    \r\n    vb_prod: uint256 = 0\r\n    vb_sum: uint256 = _vb_sum\r\n    updated: bool = False\r\n    vb_prod, updated = self._update_weights(_vb_prod)\r\n    num_assets: uint256 = self.num_assets\r\n    for i in range(MAX_NUM_ASSETS):\r\n        asset: uint256 = shift(_assets, unsafe_mul(-8, convert(i, int128))) & 255\r\n        if asset == 0 or asset > num_assets:\r\n            break\r\n        asset = unsafe_sub(asset, 1)\r\n        provider: address = self.rate_providers[asset]\r\n\r\n        prev_vb: uint256 = 0\r\n        prev_rate: uint256 = 0\r\n        packed_weight: uint256 = 0\r\n        prev_vb, prev_rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n\r\n        rate: uint256 = RateProvider(provider).rate(self.assets[asset])\r\n        assert rate > 0 # dev: no rate\r\n        if rate == prev_rate:\r\n            # no rate change\r\n            continue\r\n\r\n        # cap upward rate movements to 10%\r\n        if rate > prev_rate * 11 / 10 and prev_rate > 0:\r\n            assert msg.sender == self.management # dev: rate increase cap\r\n\r\n        vb: uint256 = 0\r\n        if prev_rate > 0 and vb_sum > 0:\r\n            # factor out old rate and factor in new\r\n            wn: uint256 = self._unpack_wn(packed_weight, num_assets)\r\n            vb_prod = vb_prod * self._pow_up(prev_rate * PRECISION / rate, wn) / PRECISION\r\n            vb = prev_vb * rate / prev_rate\r\n            vb_sum = vb_sum + vb - prev_vb\r\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\r\n        log RateUpdate(asset, rate)\r\n\r\n    if not updated and vb_prod == _vb_prod and vb_sum == _vb_sum:\r\n        # no weight and no rate changes\r\n        return vb_prod, vb_sum\r\n\r\n    # recalculate supply and mint/burn token to staking address\r\n    supply: uint256 = 0\r\n    supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\r\n    return vb_prod, vb_sum\r\n\r\n@internal\r\ndef _update_weights(_vb_prod: uint256) -> (uint256, bool):\r\n    \"\"\"\r\n    @notice Apply a step in amplitude and weight ramp, if applicable\r\n    @param _vb_prod Product term (pi) before update\r\n    @return Tuple with new product term and flag indicating if a step has been taken\r\n    @dev Caller is responsible for updating supply if a step has been taken\r\n    \"\"\"\r\n    span: uint256 = self.ramp_last_time\r\n    duration: uint256 = self.ramp_stop_time\r\n    if span == 0 or span > block.timestamp or (block.timestamp - span < self.ramp_step and duration > block.timestamp):\r\n        # scenarios:\r\n        #  1) no ramp is active\r\n        #  2) ramp is scheduled for in the future\r\n        #  3) weights have been updated too recently and ramp hasnt finished yet\r\n        return _vb_prod, False\r\n\r\n    if block.timestamp < duration:\r\n        # ramp in progress\r\n        duration -= span\r\n        self.ramp_last_time = block.timestamp\r\n    else:\r\n        # ramp has finished\r\n        duration = 0\r\n        self.ramp_last_time = 0\r\n        self.ramp_stop_time = 0\r\n    span = block.timestamp - span\r\n    \r\n    # update amplification\r\n    current: uint256 = self.amplification\r\n    target: uint256 = self.target_amplification\r\n    if duration == 0:\r\n        current = target\r\n    else:\r\n        if current > target:\r\n            current = current - (current - target) * span / duration\r\n        else:\r\n            current = current + (target - current) * span / duration\r\n    self.amplification = current\r\n\r\n    # update weights\r\n    num_assets: uint256 = self.num_assets\r\n    vb: uint256 = 0\r\n    rate: uint256 = 0\r\n    packed_weight: uint256 = 0\r\n    lower: uint256 = 0\r\n    upper: uint256 = 0\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\r\n        current, target, lower, upper = self._unpack_weight(packed_weight)\r\n        if duration == 0:\r\n            current = target\r\n        else:\r\n            if current > target:\r\n                current -= (current - target) * span / duration\r\n            else:\r\n                current += (target - current) * span / duration\r\n        packed_weight = self._pack_weight(current, target, lower, upper)\r\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\r\n\r\n    vb_prod: uint256 = 0\r\n    supply: uint256 = self.supply\r\n    if supply > 0:\r\n        vb_prod = self._calc_vb_prod(supply)\r\n    return vb_prod, True\r\n\r\n@internal\r\ndef _update_supply(_supply: uint256, _vb_prod: uint256, _vb_sum: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Calculate supply and burn or mint difference from the staking contract\r\n    @param _supply Previous supply\r\n    @param _vb_prod Product term (pi)\r\n    @param _vb_sum Sum term (sigma)\r\n    @return Tuple with new supply and product term\r\n    \"\"\"\r\n    if _supply == 0:\r\n        return 0, _vb_prod\r\n\r\n    supply: uint256 = 0\r\n    vb_prod: uint256 = 0\r\n    supply, vb_prod = self._calc_supply(self.num_assets, _supply, self.amplification, _vb_prod, _vb_sum, True)\r\n    if supply > _supply:\r\n        PoolToken(token).mint(self.staking, supply - _supply)\r\n    elif supply < _supply:\r\n        PoolToken(token).burn(self.staking, _supply - supply)\r\n    self.supply = supply\r\n    return supply, vb_prod\r\n\r\n@internal\r\n@pure\r\ndef _check_bands(_prev_ratio: uint256, _ratio: uint256, _packed_weight: uint256):\r\n    \"\"\"\r\n    @notice Check whether asset is within safety band, or if previously outside, moves closer to it\r\n    @param _prev_ratio Asset ratio before user action\r\n    @param _ratio Asset ratio after user action\r\n    @param _packed_weight Packed weight\r\n    @dev Reverts if condition not met\r\n    \"\"\"\r\n    weight: uint256 = unsafe_mul(_packed_weight & WEIGHT_MASK, WEIGHT_SCALE)\r\n\r\n    # lower limit check\r\n    limit: uint256 = unsafe_mul(shift(_packed_weight, LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE)\r\n    if limit > weight:\r\n        limit = 0\r\n    else:\r\n        limit = unsafe_sub(weight, limit)\r\n    if _ratio < limit:\r\n        assert _ratio > _prev_ratio # dev: ratio below lower band\r\n        return\r\n\r\n    # upper limit check\r\n    limit = min(unsafe_add(weight, unsafe_mul(shift(_packed_weight, UPPER_BAND_SHIFT), WEIGHT_SCALE)), PRECISION)\r\n    if _ratio > limit:\r\n        assert _ratio < _prev_ratio # dev: ratio above upper band\r\n\r\n# MATH FUNCTIONS\r\n\r\n@internal\r\n@view\r\ndef _calc_vb_prod_sum() -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Calculate product term (pi) and sum term (sigma)\r\n    @return Tuple with product term and sum term\r\n    \"\"\"\r\n    s: uint256 = 0\r\n    num_assets: uint256 = self.num_assets\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        s = unsafe_add(s, self.packed_vbs[asset] & VB_MASK)\r\n    p: uint256 = self._calc_vb_prod(s)\r\n    return p, s\r\n\r\n@internal\r\n@view\r\ndef _calc_vb_prod(_s: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate product term (pi)\r\n    @param _s Supply to use in product term\r\n    @param Product term\r\n    \"\"\"\r\n    num_assets: uint256 = self.num_assets\r\n    p: uint256 = PRECISION\r\n    for asset in range(MAX_NUM_ASSETS):\r\n        if asset == num_assets:\r\n            break\r\n        vb: uint256 = 0\r\n        rate: uint256 = 0\r\n        weight: uint256 = 0\r\n        vb, rate, weight = self._unpack_vb(self.packed_vbs[asset])\r\n        weight = self._unpack_wn(weight, 1)\r\n        \r\n        assert weight > 0 and vb > 0 # dev: borked\r\n        # p = product((D * w_i / vb_i)^(w_i n))\r\n        p = unsafe_div(unsafe_mul(p, self._pow_down(unsafe_div(unsafe_mul(_s, weight), vb), unsafe_mul(weight, num_assets))), PRECISION)\r\n    return p\r\n\r\n@internal\r\n@pure\r\ndef _calc_supply(\r\n    _num_assets: uint256, \r\n    _supply: uint256, \r\n    _amplification: uint256,\r\n    _vb_prod: uint256, \r\n    _vb_sum: uint256, \r\n    _up: bool\r\n) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Calculate supply iteratively\r\n    @param _num_assets Number of assets in pool\r\n    @param _supply Supply as used in product term\r\n    @param _amplification Amplification factor `A f^n`\r\n    @param _vb_prod Product term (pi)\r\n    @param _vb_sum Sum term (sigma)\r\n    @param _up Whether to round up\r\n    @return Tuple with new supply and product term\r\n    \"\"\"\r\n    \r\n    # D[m+1] = (A f^n sigma - D[m] pi[m] )) / (A f^n - 1)\r\n    #        = (l - s r) / d\r\n\r\n    l: uint256 = _amplification # left: A f^n sigma\r\n    d: uint256 = l - PRECISION # denominator: A f^n - 1\r\n    l = l * _vb_sum\r\n    s: uint256 = _supply # supply: D[m]\r\n    r: uint256 = _vb_prod # right: pi[m]\r\n\r\n    for _ in range(255):\r\n        assert s > 0\r\n        sp: uint256 = unsafe_div(unsafe_sub(l, unsafe_mul(s, r)), d) # D[m+1] = (l - s * r) / d\r\n        # update product term pi[m+1] = (D[m+1]/D[m])^n pi[m]\r\n        for i in range(MAX_NUM_ASSETS):\r\n            if i == _num_assets:\r\n                break\r\n            r = unsafe_div(unsafe_mul(r, sp), s) # r * sp / s\r\n        delta: uint256 = 0\r\n        if sp >= s:\r\n            delta = unsafe_sub(sp, s)\r\n        else:\r\n            delta = unsafe_sub(s, sp)\r\n\r\n        if unsafe_div(unsafe_mul(delta, PRECISION), s) <= MAX_POW_REL_ERR:\r\n            delta = unsafe_div(unsafe_mul(sp, MAX_POW_REL_ERR), PRECISION)\r\n            if _up:\r\n                sp += delta\r\n            else:\r\n                sp -= delta\r\n            return sp, r\r\n        s = sp\r\n\r\n    raise # dev: no convergence\r\n\r\n@internal\r\n@pure\r\ndef _calc_vb(\r\n    _wn: uint256, \r\n    _y: uint256, \r\n    _supply: uint256, \r\n    _amplification: uint256,\r\n    _vb_prod: uint256, \r\n    _vb_sum: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate a single asset's virtual balance iteratively using Newton's method\r\n    @param _wn Asset weight times number of assets\r\n    @param _y Starting value\r\n    @param _supply Supply\r\n    @param _amplification Amplification factor `A f^n`\r\n    @param _vb_prod Intermediary product term (pi~), pi with previous balances factored out and new balance factored in\r\n    @param _vb_sum Intermediary sum term (sigma~), sigma with previous balances subtracted and new balance added\r\n    @return New asset virtual balance\r\n    \"\"\"\r\n\r\n    # y = x_j, sum' = sum(x_i, i != j), prod' = D^n w_j^(v_j) prod((w_i/x_i)^v_i, i != j)\r\n    # Iteratively find root of g(y) using Newton's method\r\n    # g(y) = y^(v_j + 1) + (sum' + (1 / (A f^n) - 1) D) y^(v_j) - D prod' / (A f^n)\r\n    #      = y^(v_j + 1) + b y^(v_j) - c\r\n    # y[n+1] = y[n] - g(y[n])/g'(y[n])\r\n    #        = (y[n]^2 + b (1 - q) y[n] + c q y[n]^(1 - v_j)) / ((q + 1) y[n] + b))\r\n\r\n    b: uint256 = _supply * PRECISION / _amplification # b' = sigma + D / (A f^n)\r\n    c: uint256 = _vb_prod * b / PRECISION # c = D / (A f^n) * pi\r\n    b += _vb_sum\r\n    q: uint256 = PRECISION * PRECISION / _wn # q = 1/v_i = 1/(w_i n)\r\n\r\n    y: uint256 = _y\r\n    for _ in range(255):\r\n        assert y > 0\r\n        yp: uint256 = (y + b + _supply * q / PRECISION + c * q / self._pow_up(y, _wn) - b * q / PRECISION - _supply) * y / (q * y / PRECISION + y + b - _supply)\r\n        delta: uint256 = 0\r\n        if yp >= y:\r\n            delta = yp - y\r\n        else:\r\n            delta = y - yp\r\n \r\n        if unsafe_div(unsafe_mul(delta, PRECISION), y) <= MAX_POW_REL_ERR:\r\n            yp += unsafe_div(unsafe_mul(yp, MAX_POW_REL_ERR), PRECISION)\r\n            return yp\r\n        y = yp\r\n    \r\n    raise # dev: no convergence\r\n\r\n@internal\r\n@pure\r\ndef _pack_vb(_vb: uint256, _rate: uint256, _packed_weight: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Pack virtual balance of asset along with other related variables\r\n    @param _vb Asset virtual balance\r\n    @param _rate Asset rate\r\n    @param _packed_weight Asset packed weight\r\n    @return Packed variable\r\n    \"\"\"\r\n    assert _vb <= VB_MASK and _rate <= RATE_MASK\r\n    return _vb | shift(_rate, -RATE_SHIFT) | shift(_packed_weight, -PACKED_WEIGHT_SHIFT)\r\n\r\n@internal\r\n@pure\r\ndef _unpack_vb(_packed: uint256) -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack variable to its components\r\n    @param _packed Packed variable\r\n    @return Tuple with virtual balance, rate and packed weight\r\n    \"\"\"\r\n    return _packed & VB_MASK, shift(_packed, RATE_SHIFT) & RATE_MASK, shift(_packed, PACKED_WEIGHT_SHIFT)\r\n\r\n@internal\r\n@pure\r\ndef _pack_weight(_weight: uint256, _target: uint256, _lower: uint256, _upper: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Pack weight with target and bands\r\n    @param _weight Weight (18 decimals)\r\n    @param _target Target weight (18 decimals)\r\n    @param _lower Lower band, allowed distance from weight in negative direction (18 decimals)\r\n    @param _upper Upper band, allowed distance from weight in positive direction (18 decimals)\r\n    @return Packed weight\r\n    \"\"\"\r\n    return unsafe_div(_weight, WEIGHT_SCALE) | shift(unsafe_div(_target, WEIGHT_SCALE), -TARGET_WEIGHT_SHIFT) | shift(unsafe_div(_lower, WEIGHT_SCALE), -LOWER_BAND_SHIFT) | shift(unsafe_div(_upper, WEIGHT_SCALE), -UPPER_BAND_SHIFT)\r\n\r\n@internal\r\n@pure\r\ndef _unpack_weight(_packed: uint256) -> (uint256, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack weight to its components\r\n    @param _packed Packed weight\r\n    @return Tuple with weight, target weight, lower band and upper band (all in 18 decimals)\r\n    \"\"\"\r\n    return unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul(shift(_packed, TARGET_WEIGHT_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul(shift(_packed, LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul(shift(_packed, UPPER_BAND_SHIFT), WEIGHT_SCALE)\r\n\r\n@internal\r\n@pure\r\ndef _unpack_wn(_packed: uint256, _num_assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Unpack weight and multiply by number of assets\r\n    @param _packed Packed weight\r\n    @param _num_assets Number of assets\r\n    @return Weight multiplied by number of assets (18 decimals)\r\n    \"\"\"\r\n    return unsafe_mul(unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), _num_assets)\r\n\r\n@internal\r\n@pure\r\ndef _pack_pool_vb(_prod: uint256, _sum: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Pack pool product and sum term\r\n    @param _prod Product term (pi)\r\n    @param _sum Sum term (sigma)\r\n    @return Packed terms\r\n    \"\"\"\r\n    assert _prod <= POOL_VB_MASK and _sum <= POOL_VB_MASK\r\n    return _prod | shift(_sum, -POOL_VB_SHIFT)\r\n\r\n@internal\r\n@pure\r\ndef _unpack_pool_vb(_packed: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack pool product and sum term\r\n    @param _packed Packed terms\r\n    @return Tuple with pool product term (pi) and sum term (sigma)\r\n    \"\"\"\r\n    return _packed & POOL_VB_MASK, shift(_packed, POOL_VB_SHIFT)\r\n\r\n@internal\r\n@pure\r\ndef _pow_up(_x: uint256, _y: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate `x` to power of `y`, rounded up\r\n    @param _x Base (18 decimals)\r\n    @param _y Exponent (18 decimals)\r\n    @return `x^y` in 18 decimals, rounded up\r\n    @dev Guaranteed to be at least as big as the actual value\r\n    \"\"\"\r\n    p: uint256 = self._pow(_x, _y)\r\n    if p == 0:\r\n        return 0\r\n    # p + (p * MAX_POW_REL_ERR - 1) / PRECISION + 1\r\n    return unsafe_add(unsafe_add(p, unsafe_div(unsafe_sub(unsafe_mul(p, MAX_POW_REL_ERR), 1), PRECISION)), 1)\r\n\r\n@internal\r\n@pure\r\ndef _pow_down(_x: uint256, _y: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate `x` to power of `y`, rounded down\r\n    @param _x Base (18 decimals)\r\n    @param _y Exponent (18 decimals)\r\n    @return `x^y` in 18 decimals, rounded down\r\n    @dev Guaranteed to be at most as big as the actual value\r\n    \"\"\"\r\n    p: uint256 = self._pow(_x, _y)\r\n    if p == 0:\r\n        return 0\r\n    # (p * MAX_POW_REL_ERR - 1) / PRECISION + 1\r\n    e: uint256 = unsafe_add(unsafe_div(unsafe_sub(unsafe_mul(p, MAX_POW_REL_ERR), 1), PRECISION), 1)\r\n    if p < e:\r\n        return 0\r\n    return unsafe_sub(p, e)\r\n\r\n@internal\r\n@pure\r\ndef _pow(_x: uint256, _y: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate `x` to power of `y`\r\n    @param _x Base (18 decimals)\r\n    @param _y Exponent (18 decimals)\r\n    @return `x^y` in 18 decimals\r\n    @dev Only accurate until 10^-16, use rounded variants for consistent results\r\n    \"\"\"\r\n    # adapted from Balancer at https://github.com/balancer-labs/balancer-v2-monorepo/blob/599b0cd8f744e1eabef3600d79a2c2b0aea3ddcb/pkg/solidity-utils/contracts/math/LogExpMath.sol\r\n    if _y == 0:\r\n        return convert(E18, uint256) # x^0 == 1\r\n\r\n    if _x == 0:\r\n        return 0 # 0^y == 0\r\n    \r\n    assert shift(_x, -255) == 0 # dev: x out of bounds\r\n    assert _y < MILD_EXP_BOUND # dev: y out of bounds\r\n\r\n    # x^y = e^log(x^y)) = e^(y log x)\r\n    x: int256 = convert(_x, int256)\r\n    y: int256= convert(_y, int256)\r\n    l: int256 = 0\r\n    if x > LOG36_LOWER and x < LOG36_UPPER:\r\n        l = self._log36(x)\r\n        # l / E18 * y + (l % E18) * y / E18\r\n        l = unsafe_add(unsafe_mul(unsafe_div(l, E18), y), unsafe_div(unsafe_mul(l % E18, y), E18))\r\n    else:\r\n        l = unsafe_mul(self._log(x), y)\r\n    l = unsafe_div(l, E18)\r\n    return convert(self._exp(l), uint256)\r\n\r\n@internal\r\n@pure\r\ndef _log36(_x: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural logarithm in double precision\r\n    @param _x Argument of logarithm (18 decimals)\r\n    @return Natural logarithm in 36 decimals\r\n    @dev Caller should perform bounds checks before calling this function\r\n    \"\"\"\r\n    x: int256 = unsafe_mul(_x, E18)\r\n    \r\n    # Taylor series\r\n    # z = (x - 1) / (x + 1)\r\n    # c = log x = 2 * sum(z^(2n + 1) / (2n + 1))\r\n\r\n    z: int256 = unsafe_div(unsafe_mul(unsafe_sub(x, E36), E36), unsafe_add(x, E36)) # (x - E36) * E36 / (x + E36)\r\n    zsq: int256 = unsafe_div(unsafe_mul(z, z), E36)\r\n    n: int256 = z\r\n    c: int256 = z\r\n\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36) # n * zsq / E36\r\n    c = unsafe_add(c, n / 3)\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36)\r\n    c = unsafe_add(c, n / 5)\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36)\r\n    c = unsafe_add(c, n / 7)\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36)\r\n    c = unsafe_add(c, n / 9)\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36)\r\n    c = unsafe_add(c, n / 11)\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36)\r\n    c = unsafe_add(c, n / 13)\r\n    n = unsafe_div(unsafe_mul(n, zsq), E36)\r\n    c = unsafe_add(c, n / 15)\r\n\r\n    return unsafe_mul(c, 2)\r\n\r\n@internal\r\n@pure\r\ndef _log(_a: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural logarithm\r\n    @param _a Argument of logarithm (18 decimals)\r\n    @return Natural logarithm in 18 decimals\r\n    \"\"\"\r\n    if _a < E18:\r\n        # 1/a > 1, log(a) = -log(1/a)\r\n        return -self.__log(unsafe_div(unsafe_mul(E18, E18), _a))\r\n    return self.__log(_a)\r\n\r\n@internal\r\n@pure\r\ndef __log(_a: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural logarithm, assuming the argument is larger than one\r\n    @param _a Argument of logarithm (18 decimals)\r\n    @return Natural logarithm in 18 decimals\r\n    @dev Caller should perform bounds checks before calling this function\r\n    \"\"\"\r\n    \r\n    # log a = sum(k_n x_n) + log(rem)\r\n    #       = log(product(a_n^k_n) * rem)\r\n    # k_n = {0,1}, x_n = 2^(7-n), log(a_n) = x_n\r\n    a: int256 = _a\r\n    s: int256 = 0\r\n\r\n    # divide out a_ns\r\n    if a >= unsafe_mul(A0, E18):\r\n        a = unsafe_div(a, A0)\r\n        s = unsafe_add(s, X0)\r\n    if a >= unsafe_mul(A1, E18):\r\n        a = unsafe_div(a, A1)\r\n        s = unsafe_add(s, X1)\r\n    \r\n    # other terms are in 20 decimals\r\n    a = unsafe_mul(a, 100)\r\n    s = unsafe_mul(s, 100)\r\n\r\n    if a >= A2:\r\n        a = unsafe_div(unsafe_mul(a, E20), A2) # a * E20 / A2\r\n        s = unsafe_add(s, X2)\r\n    if a >= A3:\r\n        a = unsafe_div(unsafe_mul(a, E20), A3)\r\n        s = unsafe_add(s, X3)\r\n    if a >= A4:\r\n        a = unsafe_div(unsafe_mul(a, E20), A4)\r\n        s = unsafe_add(s, X4)\r\n    if a >= A5:\r\n        a = unsafe_div(unsafe_mul(a, E20), A5)\r\n        s = unsafe_add(s, X5)\r\n    if a >= A6:\r\n        a = unsafe_div(unsafe_mul(a, E20), A6)\r\n        s = unsafe_add(s, X6)\r\n    if a >= A7:\r\n        a = unsafe_div(unsafe_mul(a, E20), A7)\r\n        s = unsafe_add(s, X7)\r\n    if a >= A8:\r\n        a = unsafe_div(unsafe_mul(a, E20), A8)\r\n        s = unsafe_add(s, X8)\r\n    if a >= A9:\r\n        a = unsafe_div(unsafe_mul(a, E20), A9)\r\n        s = unsafe_add(s, X9)\r\n    if a >= A10:\r\n        a = unsafe_div(unsafe_mul(a, E20), A10)\r\n        s = unsafe_add(s, X10)\r\n    if a >= A11:\r\n        a = unsafe_div(unsafe_mul(a, E20), A11)\r\n        s = unsafe_add(s, X11)\r\n\r\n    # a < A11 (1.06), taylor series for remainder\r\n    # z = (a - 1) / (a + 1)\r\n    # c = log a = 2 * sum(z^(2n + 1) / (2n + 1))\r\n    z: int256 = unsafe_div(unsafe_mul(unsafe_sub(a, E20),  E20), unsafe_add(a, E20)) # (a - E20) * E20 / (a + E20)\r\n    zsq: int256 = unsafe_div(unsafe_mul(z, z), E20) # z * z / E20\r\n    n: int256 = z\r\n    c: int256 = z\r\n\r\n    n = unsafe_div(unsafe_mul(n, zsq), E20) # n * zsq / E20\r\n    c = unsafe_add(c, unsafe_div(n, 3)) # c + n / 3\r\n    n = unsafe_div(unsafe_mul(n, zsq), E20)\r\n    c = unsafe_add(c, unsafe_div(n, 5))\r\n    n = unsafe_div(unsafe_mul(n, zsq), E20)\r\n    c = unsafe_add(c, unsafe_div(n, 7))\r\n    n = unsafe_div(unsafe_mul(n, zsq), E20)\r\n    c = unsafe_add(c, unsafe_div(n, 9))\r\n    n = unsafe_div(unsafe_mul(n, zsq), E20)\r\n    c = unsafe_add(c, unsafe_div(n, 11))\r\n\r\n    c = unsafe_mul(c, 2)\r\n    return unsafe_div(unsafe_add(s, c), 100) # (s + c) / 100\r\n\r\n@internal\r\n@pure\r\ndef _exp(_x: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural exponent `e^x`\r\n    @param _x Exponent (18 decimals)\r\n    @return Natural exponent in 18 decimals\r\n    \"\"\"\r\n    assert _x >= MIN_NAT_EXP and _x <= MAX_NAT_EXP\r\n    if _x < 0:\r\n        # exp(-x) = 1/exp(x)\r\n        return unsafe_mul(E18, E18) / self.__exp(-_x)\r\n    return self.__exp(_x)\r\n\r\n@internal\r\n@pure\r\ndef __exp(_x: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural exponent `e^x`, assuming exponent is positive\r\n    @param _x Exponent (18 decimals)\r\n    @return Natural exponent in 18 decimals\r\n    @dev Caller should perform bounds checks before calling this function\r\n    \"\"\"\r\n    \r\n    # e^x = e^(sum(k_n x_n) + rem)\r\n    #     = product(e^(k_n x_n)) * e^(rem)\r\n    #     = product(a_n^k_n) * e^(rem)\r\n    # k_n = {0,1}, x_n = 2^(7-n), a_n = exp(x_n)\r\n    x: int256 = _x\r\n\r\n    # subtract out x_ns\r\n    f: int256 = 1\r\n    if x >= X0:\r\n        x = unsafe_sub(x, X0)\r\n        f = A0\r\n    elif x >= X1:\r\n        x = unsafe_sub(x, X1)\r\n        f = A1\r\n\r\n    # other terms are in 20 decimals\r\n    x = unsafe_mul(x, 100)\r\n\r\n    p: int256 = E20\r\n    if x >= X2:\r\n        x = unsafe_sub(x, X2)\r\n        p = unsafe_div(unsafe_mul(p, A2), E20) # p * A2 / E20\r\n    if x >= X3:\r\n        x = unsafe_sub(x, X3)\r\n        p = unsafe_div(unsafe_mul(p, A3), E20)\r\n    if x >= X4:\r\n        x = unsafe_sub(x, X4)\r\n        p = unsafe_div(unsafe_mul(p, A4), E20)\r\n    if x >= X5:\r\n        x = unsafe_sub(x, X5)\r\n        p = unsafe_div(unsafe_mul(p, A5), E20)\r\n    if x >= X6:\r\n        x = unsafe_sub(x, X6)\r\n        p = unsafe_div(unsafe_mul(p, A6), E20)\r\n    if x >= X7:\r\n        x = unsafe_sub(x, X7)\r\n        p = unsafe_div(unsafe_mul(p, A7), E20)\r\n    if x >= X8:\r\n        x = unsafe_sub(x, X8)\r\n        p = unsafe_div(unsafe_mul(p, A8), E20)\r\n    if x >= X9:\r\n        x = unsafe_sub(x, X9)\r\n        p = unsafe_div(unsafe_mul(p, A9), E20)\r\n    \r\n    # x < X9 (0.25), taylor series for remainder\r\n    # c = e^x = sum(x^n / n!)\r\n    n: int256 = x\r\n    c: int256 = unsafe_add(E20, x)\r\n\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 2) # n * x / E20 / 2\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 3)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 4)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 5)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 6)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 7)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 8)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 9)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 10)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 11)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 12)\r\n    c = unsafe_add(c, n)\r\n\r\n    # p * c / E20 * f / 100\r\n    return unsafe_div(unsafe_mul(unsafe_div(unsafe_mul(p, c), E20), f), 100)", "ABI": "[{\"name\":\"Swap\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":false},{\"name\":\"asset_in\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"asset_out\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"amount_in\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount_out\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amounts_in\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"lp_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"lp_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquiditySingle\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"asset\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"amount_out\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lp_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RateUpdate\",\"inputs\":[{\"name\":\"asset\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Pause\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Unpause\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Kill\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddAsset\",\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"asset\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rate_provider\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"weight\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetSwapFeeRate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWeightBand\",\"inputs\":[{\"name\":\"asset\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"lower\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"upper\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRateProvider\",\"inputs\":[{\"name\":\"asset\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rate_provider\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRamp\",\"inputs\":[{\"name\":\"amplification\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"weights\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"start\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRampStep\",\"inputs\":[{\"name\":\"ramp_step\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRamp\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetStaking\",\"inputs\":[{\"name\":\"staking\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetGuardian\",\"inputs\":[{\"name\":\"acount\",\"type\":\"address\",\"indexed\":true},{\"name\":\"guardian\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amplification\",\"type\":\"uint256\"},{\"name\":\"_assets\",\"type\":\"address[]\"},{\"name\":\"_rate_providers\",\"type\":\"address[]\"},{\"name\":\"_weights\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"swap\",\"inputs\":[{\"name\":\"_i\",\"type\":\"uint256\"},{\"name\":\"_j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"swap\",\"inputs\":[{\"name\":\"_i\",\"type\":\"uint256\"},{\"name\":\"_j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"swap_exact_out\",\"inputs\":[{\"name\":\"_i\",\"type\":\"uint256\"},{\"name\":\"_j\",\"type\":\"uint256\"},{\"name\":\"_dy\",\"type\":\"uint256\"},{\"name\":\"_max_dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"swap_exact_out\",\"inputs\":[{\"name\":\"_i\",\"type\":\"uint256\"},{\"name\":\"_j\",\"type\":\"uint256\"},{\"name\":\"_dy\",\"type\":\"uint256\"},{\"name\":\"_max_dx\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_min_lp_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_min_lp_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_lp_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_lp_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_single\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"},{\"name\":\"_lp_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_single\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"},{\"name\":\"_lp_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_rates\",\"inputs\":[{\"name\":\"_assets\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_weights\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vb_prod_sum\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"virtual_balance\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"weight\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_weight\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"pause\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unpause\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kill\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_asset\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_rate_provider\",\"type\":\"address\"},{\"name\":\"_weight\",\"type\":\"uint256\"},{\"name\":\"_lower\",\"type\":\"uint256\"},{\"name\":\"_upper\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_amplification\",\"type\":\"uint256\"},{\"name\":\"_min_lp_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_asset\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_rate_provider\",\"type\":\"address\"},{\"name\":\"_weight\",\"type\":\"uint256\"},{\"name\":\"_lower\",\"type\":\"uint256\"},{\"name\":\"_upper\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_amplification\",\"type\":\"uint256\"},{\"name\":\"_min_lp_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rescue\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"skim\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_swap_fee_rate\",\"inputs\":[{\"name\":\"_fee_rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_weight_bands\",\"inputs\":[{\"name\":\"_assets\",\"type\":\"uint256[]\"},{\"name\":\"_lower\",\"type\":\"uint256[]\"},{\"name\":\"_upper\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rate_provider\",\"inputs\":[{\"name\":\"_asset\",\"type\":\"uint256\"},{\"name\":\"_rate_provider\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_ramp\",\"inputs\":[{\"name\":\"_amplification\",\"type\":\"uint256\"},{\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_ramp\",\"inputs\":[{\"name\":\"_amplification\",\"type\":\"uint256\"},{\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_ramp_step\",\"inputs\":[{\"name\":\"_ramp_step\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_staking\",\"inputs\":[{\"name\":\"_staking\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_guardian\",\"inputs\":[{\"name\":\"_guardian\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"amplification\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"staking\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"num_assets\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"assets\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate_providers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"guardian\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"swap_fee_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ramp_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ramp_last_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ramp_stop_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"target_amplification\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "yETH weighted stableswap pool", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000001bed97cbc3c24a4fb5c069c6e311a967386131f7000000000000000000000000000000000000000000000018650127cc3dc8000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000005000000000000000000000000ac3e018457b222d93114458476f3e3416abbe38f000000000000000000000000f951e335afb289353dc249e82926178eac7ded780000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000a35b1b31ce002fbf2058d22f30f95d405200a15b000000000000000000000000be9895146f7af43049ca1c1ae358b0541ea4970400000000000000000000000000000000000000000000000000000000000000050000000000000000000000004e322aeaf355dff8fb9fd5d18f3d87667e8f83160000000000000000000000004e322aeaf355dff8fb9fd5d18f3d87667e8f83160000000000000000000000004e322aeaf355dff8fb9fd5d18f3d87667e8f83160000000000000000000000004e322aeaf355dff8fb9fd5d18f3d87667e8f83160000000000000000000000004e322aeaf355dff8fb9fd5d18f3d87667e8f8316000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000003b6b4c83de50000000000000000000000000000000000000000000000000000039c6a857a8e800000000000000000000000000000000000000000000000000003699cbf4644c00000000000000000000000000000000000000000000000000001a99d771c178000000000000000000000000000000000000000000000000000017a5d2f8c944000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}