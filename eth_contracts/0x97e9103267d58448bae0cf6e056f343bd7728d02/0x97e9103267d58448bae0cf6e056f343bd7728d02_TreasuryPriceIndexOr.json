{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/common/CommonEventsAndErrors.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (common/CommonEventsAndErrors.sol)\\n\\n/// @notice A collection of common errors thrown within the Temple contracts\\nlibrary CommonEventsAndErrors {\\n    error InsufficientBalance(address token, uint256 required, uint256 balance);\\n    error InvalidParam();\\n    error InvalidAddress();\\n    error InvalidAccess();\\n    error InvalidAmount(address token, uint256 amount);\\n    error ExpectedNonZero();\\n    error Unimplemented();\\n    event TokenRecovered(address indexed to, address indexed token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/v2/access/ITempleElevatedAccess.sol)\\n\\n/**\\n * @notice Inherit to add Executor and Rescuer roles for DAO elevated access.\\n */ \\ninterface ITempleElevatedAccess {\\n    event ExplicitAccessSet(address indexed account, bytes4 indexed fnSelector, bool indexed value);\\n    event RescueModeSet(bool indexed value);\\n\\n    event NewRescuerProposed(address indexed oldRescuer, address indexed oldProposedRescuer, address indexed newProposedRescuer);\\n    event NewRescuerAccepted(address indexed oldRescuer, address indexed newRescuer);\\n\\n    event NewExecutorProposed(address indexed oldExecutor, address indexed oldProposedExecutor, address indexed newProposedExecutor);\\n    event NewExecutorAccepted(address indexed oldExecutor, address indexed newExecutor);\\n\\n    struct ExplicitAccess {\\n        bytes4 fnSelector;\\n        bool allowed;\\n    }\\n\\n    /**\\n     * @notice A set of addresses which are approved to execute emergency operations.\\n     */ \\n    function rescuer() external returns (address);\\n\\n    /**\\n     * @notice A set of addresses which are approved to execute normal operations on behalf of the DAO.\\n     */ \\n    function executor() external returns (address);\\n\\n    /**\\n     * @notice Explicit approval for an address to execute a function.\\n     * allowedCaller => function selector => true/false\\n     */\\n    function explicitFunctionAccess(address contractAddr, bytes4 functionSelector) external returns (bool);\\n\\n    /**\\n     * @notice Under normal circumstances, rescuers don't have access to admin/operational functions.\\n     * However when rescue mode is enabled (by rescuers or executors), they claim the access rights.\\n     */\\n    function inRescueMode() external returns (bool);\\n    \\n    /**\\n     * @notice Set the contract into or out of rescue mode.\\n     * Only the rescuers or executors are allowed to set.\\n     */\\n    function setRescueMode(bool value) external;\\n\\n    /**\\n     * @notice Proposes a new Rescuer.\\n     * Can only be called by the current rescuer.\\n     */\\n    function proposeNewRescuer(address account) external;\\n\\n    /**\\n     * @notice Caller accepts the role as new Rescuer.\\n     * Can only be called by the proposed rescuer\\n     */\\n    function acceptRescuer() external;\\n\\n    /**\\n     * @notice Proposes a new Executor.\\n     * Can only be called by the current executor or resucer (if in resuce mode)\\n     */\\n    function proposeNewExecutor(address account) external;\\n\\n    /**\\n     * @notice Caller accepts the role as new Executor.\\n     * Can only be called by the proposed executor\\n     */\\n    function acceptExecutor() external;\\n\\n    /**\\n     * @notice Grant `allowedCaller` the rights to call the function selectors in the access list.\\n     * @dev fnSelector == bytes4(keccak256(\\\"fn(argType1,argType2,...)\\\"))\\n     */\\n    function setExplicitAccess(address allowedCaller, ExplicitAccess[] calldata access) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v2/ITreasuryPriceIndexOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/v2/ITreasuryPriceIndexOracle.sol)\\n\\nimport { ITempleElevatedAccess } from \\\"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\\\";\\n\\n/**\\n * @title Treasury Price Index Oracle\\n * @notice The custom oracle (not dependant on external markets/AMMs/dependencies) to give the\\n * Treasury Price Index, representing the target Treasury Value per token.\\n * This rate is updated manually with elevated permissions. The new TPI doesn't take effect until after a cooldown.\\n */\\ninterface ITreasuryPriceIndexOracle is ITempleElevatedAccess {\\n    event TreasuryPriceIndexSet(uint96 oldTpi, uint96 newTpi);\\n    event TpiCooldownSet(uint32 cooldownSecs);\\n    event MaxTreasuryPriceIndexDeltaSet(uint256 maxDelta);\\n\\n    error BreachedMaxTpiDelta(uint96 oldTpi, uint96 newTpi, uint256 maxDelta);\\n\\n    /**\\n     * @notice The current Treasury Price Index (TPI) value\\n     * @dev If the TPI has just been updated, the old TPI will be used until `cooldownSecs` has elapsed\\n     */\\n    function treasuryPriceIndex() external view returns (uint96);\\n\\n    /**\\n     * @notice The maximum allowed TPI change on any single `setTreasuryPriceIndex()`, in absolute terms.\\n     * @dev Used as a bound to avoid unintended/fat fingering when updating TPI\\n     */\\n    function maxTreasuryPriceIndexDelta() external view returns (uint256);\\n\\n    /**\\n     * @notice The current internal TPI data along with when it was last reset, and the prior value\\n     */\\n    function tpiData() external view returns (\\n        uint96 currentTpi,\\n        uint96 previousTpi,\\n        uint32 lastUpdatedAt,\\n        uint32 cooldownSecs\\n    );\\n\\n    /**\\n     * @notice Set the Treasury Price Index (TPI)\\n     */\\n    function setTreasuryPriceIndex(uint96 value) external;\\n\\n    /**\\n     * @notice Set the number of seconds to elapse before a new TPI will take effect.\\n     */\\n    function setTpiCooldown(uint32 cooldownSecs) external;\\n\\n    /**\\n     * @notice Set the maximum allowed TPI change on any single `setTreasuryPriceIndex()`, in absolute terms.\\n     * @dev 18 decimal places, 0.20e18 == $0.20\\n     */\\n    function setMaxTreasuryPriceIndexDelta(uint256 maxDelta) external;\\n\\n    /**\\n     * @notice The decimal precision of Temple Price Index (TPI)\\n     * @dev 18 decimals, so 1.02e18 == $1.02\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function TPI_DECIMALS() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/v2/access/TempleElevatedAccess.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (v2/access/TempleElevatedAccess.sol)\\n\\nimport { ITempleElevatedAccess } from \\\"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\\\";\\nimport { CommonEventsAndErrors } from \\\"contracts/common/CommonEventsAndErrors.sol\\\";\\n\\n/**\\n * @notice Inherit to add Executor and Rescuer roles for DAO elevated access.\\n */ \\nabstract contract TempleElevatedAccess is ITempleElevatedAccess {\\n    /**\\n     * @notice The address which is approved to execute emergency operations.\\n     */ \\n    address public override rescuer;\\n\\n    /**\\n     * @notice The address which is approved to execute normal operations on behalf of the DAO.\\n     */ \\n    address public override executor;\\n\\n    /**\\n     * @notice Explicit approval for an address to execute a function.\\n     * allowedCaller => function selector => true/false\\n     */\\n    mapping(address => mapping(bytes4 => bool)) public override explicitFunctionAccess;\\n\\n    /**\\n     * @notice Under normal circumstances, rescuers don't have access to admin/operational functions.\\n     * However when rescue mode is enabled (by rescuers or executors), they claim the access rights.\\n     */\\n    bool public override inRescueMode;\\n\\n    /// @dev Track proposed rescuer/executor\\n    address private _proposedNewRescuer;\\n    address private _proposedNewExecutor;\\n\\n    constructor(address initialRescuer, address initialExecutor) {\\n        if (initialRescuer == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        if (initialExecutor == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        if (initialExecutor == initialRescuer) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        rescuer = initialRescuer;\\n        executor = initialExecutor;\\n    }\\n\\n    /**\\n     * @notice Set the contract into or out of rescue mode.\\n     * Only the rescuers are allowed to set.\\n     */\\n    function setRescueMode(bool value) external override {\\n        if (msg.sender != rescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        emit RescueModeSet(value);\\n        inRescueMode = value;\\n    }\\n\\n    /**\\n     * @notice Proposes a new Rescuer.\\n     * Can only be called by the current rescuer.\\n     */\\n    function proposeNewRescuer(address account) external override {\\n        if (msg.sender != rescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        if (account == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        emit NewRescuerProposed(msg.sender, _proposedNewRescuer, account);\\n        _proposedNewRescuer = account;\\n    }\\n\\n    /**\\n     * @notice Caller accepts the role as new Rescuer.\\n     * Can only be called by the proposed rescuer\\n     */\\n    function acceptRescuer() external override {\\n        if (msg.sender != _proposedNewRescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        if (msg.sender == executor) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        emit NewRescuerAccepted(rescuer, msg.sender);\\n        rescuer = msg.sender;\\n        delete _proposedNewRescuer;\\n    }\\n\\n    /**\\n     * @notice Proposes a new Executor.\\n     * Can only be called by the current executor or rescuer (if in resuce mode)\\n     */\\n    function proposeNewExecutor(address account) external override onlyElevatedAccess {\\n        if (account == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        emit NewExecutorProposed(executor, _proposedNewExecutor, account);\\n        _proposedNewExecutor = account;\\n    }\\n\\n    /**\\n     * @notice Caller accepts the role as new Executor.\\n     * Can only be called by the proposed executor\\n     */\\n    function acceptExecutor() external override {\\n        if (msg.sender != _proposedNewExecutor) revert CommonEventsAndErrors.InvalidAccess();\\n        if (msg.sender == rescuer) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        emit NewExecutorAccepted(executor, msg.sender);\\n        executor = msg.sender;\\n        delete _proposedNewExecutor;\\n    }\\n\\n    /**\\n     * @notice Grant `allowedCaller` the rights to call the function selectors in the access list.\\n     * @dev fnSelector == bytes4(keccak256(\\\"fn(argType1,argType2,...)\\\"))\\n     */\\n    function setExplicitAccess(address allowedCaller, ExplicitAccess[] calldata access) external override onlyElevatedAccess {\\n        if (allowedCaller == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        uint256 _length = access.length;\\n        ExplicitAccess memory _access;\\n        for (uint256 i; i < _length; ++i) {\\n            _access = access[i];\\n            emit ExplicitAccessSet(allowedCaller, _access.fnSelector, _access.allowed);\\n            explicitFunctionAccess[allowedCaller][_access.fnSelector] = _access.allowed;\\n        }\\n    }\\n\\n    function isElevatedAccess(address caller, bytes4 fnSelector) internal view returns (bool) {\\n        if (inRescueMode) {\\n            // If we're in rescue mode, then only the rescuers can call\\n            return caller == rescuer;\\n        } else if (caller == executor || explicitFunctionAccess[caller][fnSelector]) {\\n            // If we're not in rescue mode, the executor can call all functions\\n            // or the caller has been given explicit access on this function\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Under normal operations, only the executors are allowed to call.\\n     * If 'rescue mode' has been enabled, then only the rescuers are allowed to call.\\n     * @dev Important: Only for use when called from an *external* contract. \\n     * If a function with this modifier is called internally then the `msg.sig` \\n     * will still refer to the top level externally called function.\\n     */\\n    modifier onlyElevatedAccess() {\\n        if (!isElevatedAccess(msg.sender, msg.sig)) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only the executors or rescuers can call.\\n     */\\n    modifier onlyInRescueMode() {\\n        if (!(inRescueMode && msg.sender == rescuer)) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n\\n    modifier notInRescueMode() {\\n        if (inRescueMode) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/TreasuryPriceIndexOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (v2/TreasuryPriceIndexOracle.sol)\\n\\nimport { ITreasuryPriceIndexOracle } from \\\"contracts/interfaces/v2/ITreasuryPriceIndexOracle.sol\\\";\\nimport { TempleElevatedAccess } from \\\"contracts/v2/access/TempleElevatedAccess.sol\\\";\\n\\n/* solhint-disable not-rely-on-time */\\n\\n/**\\n * @title Treasury Price Index Oracle\\n * @notice The custom oracle (not dependant on external markets/AMMs/dependencies) to give the\\n * Treasury Price Index, representing the target Treasury Value per token.\\n * This rate is updated manually with elevated permissions. The new TPI doesn't take effect until after a cooldown.\\n */\\ncontract TreasuryPriceIndexOracle is ITreasuryPriceIndexOracle, TempleElevatedAccess {\\n    /**\\n     * @notice The decimal precision of Temple Price Index (TPI)\\n     * @dev 18 decimals, so 1.02e18 == $1.02\\n     */\\n    uint256 public constant override TPI_DECIMALS = 18;\\n\\n    struct TpiData {\\n        /// @notice The Treasury Price Index - the target price of the Treasury, in `stableToken` terms.\\n        uint96 currentTpi;\\n\\n        /// @notice The previous TPI - used if there hasn't been enough elapsed time since the last update\\n        uint96 previousTpi;\\n\\n        /// @notice The time at which TPI was last updated\\n        uint32 lastUpdatedAt;\\n\\n        /// @notice When TPI is updated, it doesn't immediately take effect.\\n        /// The new TPI takes effect after this cooldown has elapsed.\\n        uint32 cooldownSecs;\\n    }\\n    \\n    /**\\n     * @notice The current TPI data along with when it was last reset, and the prior value\\n     */\\n    TpiData public override tpiData;\\n\\n    /**\\n     * @notice The maximum allowed TPI change on any single `setTreasuryPriceIndex()`, in absolute terms.\\n     * @dev Used as a bound to avoid unintended/fat fingering when updating TPI\\n     */\\n    uint256 public override maxTreasuryPriceIndexDelta;\\n\\n    constructor(\\n        address _initialRescuer,\\n        address _initialExecutor,\\n        uint96 _initialTreasuryPriceIndex,\\n        uint256 _maxTreasuryPriceIndexDelta,\\n        uint32 _cooldownSecs\\n    ) TempleElevatedAccess(_initialRescuer, _initialExecutor)\\n    {\\n        tpiData = TpiData({\\n            currentTpi: _initialTreasuryPriceIndex,\\n            previousTpi: _initialTreasuryPriceIndex,\\n            lastUpdatedAt: uint32(block.timestamp),\\n            cooldownSecs: _cooldownSecs\\n        });\\n        maxTreasuryPriceIndexDelta = _maxTreasuryPriceIndexDelta;\\n    }\\n\\n    /**\\n     * @notice The current Treasury Price Index (TPI) value\\n     * @dev If the TPI has just been updated, the old TPI will be used until `cooldownSecs` has elapsed\\n     */\\n    function treasuryPriceIndex() public override view returns (uint96) {\\n        return (block.timestamp < (tpiData.lastUpdatedAt + tpiData.cooldownSecs))\\n            ? tpiData.previousTpi  // use the previous TPI if we haven't passed the cooldown yet.\\n            : tpiData.currentTpi;  // use the new TPI\\n    }\\n\\n    /**\\n     * @notice Set the number of seconds to elapse before a new TPI will take effect.\\n     */\\n    function setTpiCooldown(uint32 cooldownSecs) external override onlyElevatedAccess {\\n        emit TpiCooldownSet(cooldownSecs);\\n        tpiData.cooldownSecs = cooldownSecs;\\n    }\\n\\n    /**\\n     * @notice Set the maximum allowed TPI change on any single `setTreasuryPriceIndex()`, in absolute terms.\\n     * @dev 18 decimal places, 0.20e18 == $0.20\\n     */\\n    function setMaxTreasuryPriceIndexDelta(uint256 maxDelta) external override onlyElevatedAccess {\\n        emit MaxTreasuryPriceIndexDeltaSet(maxDelta);\\n        maxTreasuryPriceIndexDelta = maxDelta;\\n    }\\n\\n    /**\\n     * @notice Set the Treasury Price Index (TPI)\\n     * @dev 18 decimal places, 1.05e18 == $1.05\\n     */\\n    function setTreasuryPriceIndex(uint96 value) external override onlyElevatedAccess {\\n        // If the cooldownSecs hasn't yet passed since the last update, then this will still\\n        // refer to the `previousTpi` value\\n        uint96 _oldTpi = treasuryPriceIndex();\\n        uint96 _newTpi = value;\\n\\n        unchecked {\\n            uint256 _delta = (_newTpi > _oldTpi) ? _newTpi - _oldTpi : _oldTpi - _newTpi;\\n            if (_delta > maxTreasuryPriceIndexDelta) revert BreachedMaxTpiDelta(_oldTpi, _newTpi, maxTreasuryPriceIndexDelta);\\n        }\\n\\n        emit TreasuryPriceIndexSet(_oldTpi, _newTpi);\\n\\n        tpiData = TpiData({\\n            currentTpi: _newTpi,\\n            previousTpi: _oldTpi,\\n            lastUpdatedAt: uint32(block.timestamp),\\n            cooldownSecs: tpiData.cooldownSecs\\n        });\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialRescuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initialExecutor\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_initialTreasuryPriceIndex\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_maxTreasuryPriceIndexDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_cooldownSecs\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"oldTpi\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"newTpi\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"maxDelta\",\"type\":\"uint256\"}],\"name\":\"BreachedMaxTpiDelta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAccess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"ExplicitAccessSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxDelta\",\"type\":\"uint256\"}],\"name\":\"MaxTreasuryPriceIndexDeltaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"NewExecutorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProposedExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposedExecutor\",\"type\":\"address\"}],\"name\":\"NewExecutorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"NewRescuerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProposedRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposedRescuer\",\"type\":\"address\"}],\"name\":\"NewRescuerProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"RescueModeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"cooldownSecs\",\"type\":\"uint32\"}],\"name\":\"TpiCooldownSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"oldTpi\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"newTpi\",\"type\":\"uint96\"}],\"name\":\"TreasuryPriceIndexSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TPI_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"explicitFunctionAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inRescueMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTreasuryPriceIndexDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeNewExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeNewRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescuer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allowedCaller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"internalType\":\"struct ITempleElevatedAccess.ExplicitAccess[]\",\"name\":\"access\",\"type\":\"tuple[]\"}],\"name\":\"setExplicitAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxDelta\",\"type\":\"uint256\"}],\"name\":\"setMaxTreasuryPriceIndexDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setRescueMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"cooldownSecs\",\"type\":\"uint32\"}],\"name\":\"setTpiCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"name\":\"setTreasuryPriceIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tpiData\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"currentTpi\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"previousTpi\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cooldownSecs\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryPriceIndex\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TreasuryPriceIndexOracle", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000009f90430179d9b67341bfa50559bc7b8e35629f1b000000000000000000000000b1e8ab0a81aadf632a653e46caeda1593d71d1430000000000000000000000000000000000000000000000000eb5e06245ea000000000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000000000000000000000000000000000000000000708", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}