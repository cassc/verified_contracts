{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControlEnumerable} from \\\"./IAccessControlEnumerable.sol\\\";\\nimport {AccessControl} from \\\"../AccessControl.sol\\\";\\nimport {EnumerableSet} from \\\"../../utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    mapping(bytes32 role => EnumerableSet.AddressSet) private _roleMembers;\\n\\n    /**w\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\\n        bool granted = super._grantRole(role, account);\\n        if (granted) {\\n            _roleMembers[role].add(account);\\n        }\\n        return granted;\\n    }\\n\\n    /**\\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\\n        bool revoked = super._revokeRole(role, account);\\n        if (revoked) {\\n            _roleMembers[role].remove(account);\\n        }\\n        return revoked;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"../IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\nimport {Context} from \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys a `value` amount of tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 value) public virtual {\\n        _burn(_msgSender(), value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n     * the caller's allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `value`.\\n     */\\n    function burnFrom(address account, uint256 value) public virtual {\\n        _spendAllowance(account, _msgSender(), value);\\n        _burn(account, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Capped.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\\n */\\nabstract contract ERC20Capped is ERC20 {\\n    uint256 private immutable _cap;\\n\\n    /**\\n     * @dev Total supply cap has been exceeded.\\n     */\\n    error ERC20ExceededCap(uint256 increasedSupply, uint256 cap);\\n\\n    /**\\n     * @dev The supplied cap is not a valid cap.\\n     */\\n    error ERC20InvalidCap(uint256 cap);\\n\\n    /**\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n    constructor(uint256 cap_) {\\n        if (cap_ == 0) {\\n            revert ERC20InvalidCap(0);\\n        }\\n        _cap = cap_;\\n    }\\n\\n    /**\\n     * @dev Returns the cap on the token's total supply.\\n     */\\n    function cap() public view virtual returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_update}.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual override {\\n        super._update(from, to, value);\\n\\n        if (from == address(0)) {\\n            uint256 maxSupply = cap();\\n            uint256 supply = totalSupply();\\n            if (supply > maxSupply) {\\n                revert ERC20ExceededCap(supply, maxSupply);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\nimport {Pausable} from \\\"../../../utils/Pausable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n *\\n * IMPORTANT: This contract does not include public pause and unpause functions. In\\n * addition to inheriting this contract, you must define both functions, invoking the\\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\\n */\\nabstract contract ERC20Pausable is ERC20, Pausable {\\n    /**\\n     * @dev See {ERC20-_update}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\\n        super._update(from, to, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Quoter Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BankVaultL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Const.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n// Access control: owner sets default admin, admin manages roles; \\n// owner and admin should be different otherwise this contract will be at risk when owner is unreachable\\ncontract BankVaultL is Ownable, AccessControlEnumerable, Pausable {\\n    using SafeERC20 for IERC20;\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n\\n    // a contract where BankVaultL sends money to\\n    address public predefinedContract;\\n\\n    uint private maxAmountPerTrans = 200000 * Const.MULTIPLIER_18;\\n    uint[] private transactionTimeArr;\\n    uint private allowedAmountCap = 1000000 * Const.MULTIPLIER_18;\\n    uint private transferredAmount;\\n    address public A_leverage;\\n\\n    event TransferDYDX2Leverage(uint amount);\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        address contractAddr,\\n        address a_leverage\\n    ) Ownable(initialOwner) {\\n        // Grant the default admin role: it will be able to grant and revoke any roles\\n        // default admin role can have multiple accounts, but we will try to make it have only one account\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        require(contractAddr != address(0), \\\"Invalid address provided\\\");\\n        predefinedContract = contractAddr;\\n        a_leverage = A_leverage;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    function transferDYDX2Leverage(address tokenAddress, uint amount) external {\\n        // only allow leverage contract to call\\n        require(msg.sender == A_leverage, \\\"Unauthorized\\\");\\n        IERC20 token = IERC20(tokenAddress);\\n        token.safeTransfer(A_leverage, amount);\\n        emit TransferDYDX2Leverage(amount);\\n    }\\n\\n    function transfer2Contract(uint amount) public whenNotPaused onlyRole(OPERATOR) {\\n        require(predefinedContract != address(0), \\\"Invalid predefinedContract\\\");\\n        require(amount <= maxAmountPerTrans, \\\"amount must be less than max amount per transaction\\\");\\n\\n        IERC20 dydx = IERC20(Const.A_DYDX);\\n        require(amount <= dydx.balanceOf(address(this)), \\\"Not enough DYDX fund\\\");\\n        require(_checkExceedLimitRate(), \\\"Exeed daily transaction limit\\\");\\n        transferredAmount += amount;\\n        require(_checkExeedTransferredAmt(), \\\"Exeed transferred amount cap\\\");\\n        dydx.safeTransfer(predefinedContract, amount);\\n    }\\n\\n    function transfer(address addr, uint amount) public whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address\\\");\\n        require(amount <= maxAmountPerTrans, \\\"amount must be less than max amount per transaction\\\");\\n\\n        IERC20 dydx = IERC20(Const.A_DYDX);\\n        require(amount <= dydx.balanceOf(address(this)), \\\"Not enough DYDX fund\\\");\\n        require(_checkExceedLimitRate(), \\\"Exeed daily transaction limit\\\");\\n        transferredAmount += amount;\\n        require(_checkExeedTransferredAmt(), \\\"Exeed transferred amount cap\\\");\\n        dydx.safeTransfer(addr, amount);\\n    }\\n\\n    function _checkExceedLimitRate() private returns (bool){\\n        uint len = transactionTimeArr.length;\\n        if(len > 5 && block.timestamp - transactionTimeArr[len - 5] <= 86400){\\n            return false;\\n        }\\n        transactionTimeArr.push(block.timestamp);\\n        return true;\\n    }\\n\\n    function _checkExeedTransferredAmt() private view returns (bool){\\n        return transferredAmount <= allowedAmountCap;\\n    }\\n\\n    function setMaxAmountPerTrans(uint val) external onlyRole(OPERATOR) {\\n        maxAmountPerTrans = val;\\n    }\\n\\n    function setAllowedAmountCap(uint val) external onlyRole(OPERATOR) {\\n        allowedAmountCap = val;\\n    }\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BankVaultX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Const.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n// Access control: owner sets default admin, admin manages roles; \\n// owner and admin should be different otherwise this contract will be at risk when owner is unreachable\\ncontract BankVaultX is Ownable, AccessControlEnumerable, Pausable {\\n    using SafeERC20 for IERC20;\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n\\n    // a contract where BankVaultX sends money to\\n    address public predefinedContract;\\n\\n    uint private maxAmountPerTrans = 200000 * Const.MULTIPLIER_18;\\n    uint[] private transactionTimeArr;\\n    uint private allowedAmountCap = 1000000 * Const.MULTIPLIER_18;\\n    uint private transferredAmount;\\n\\n    event Price(uint indexed price);\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        address contractAddr\\n    ) Ownable(initialOwner) {\\n        // Grant the default admin role: it will be able to grant and revoke any roles\\n        // default admin role can have multiple accounts!\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        require(contractAddr != address(0), \\\"Invalid address provided\\\");\\n        predefinedContract = contractAddr;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    function transfer2Contract(uint amount) public whenNotPaused onlyRole(OPERATOR) {\\n        require(predefinedContract != address(0), \\\"Invalid predefinedContract\\\");\\n        require(amount <= maxAmountPerTrans, \\\"Amount must be less than max amount per transaction\\\");\\n\\n        IERC20 dydx = IERC20(Const.A_DYDX);\\n        require(amount <= dydx.balanceOf(address(this)), \\\"Not enough DYDX fund\\\");\\n        require(_checkExceedLimitRate(), \\\"Exeed daily transaction limit\\\");\\n        transferredAmount += amount;\\n        require(_checkExeedTransferredAmt(), \\\"Exeed transferred amount cap\\\");\\n        dydx.safeTransfer(predefinedContract, amount);\\n    }\\n\\n    function transfer(address addr, uint amount) public whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address\\\");\\n        require(amount <= maxAmountPerTrans, \\\"Amount must be less than max amount per transaction\\\");\\n\\n        IERC20 dydx = IERC20(Const.A_DYDX);\\n        require(amount <= dydx.balanceOf(address(this)), \\\"Not enough DYDX fund\\\");\\n        require(_checkExceedLimitRate(), \\\"Exeed daily transaction limit\\\");\\n        transferredAmount += amount;\\n        require(_checkExeedTransferredAmt(), \\\"Exeed transferred amount cap\\\");\\n        dydx.safeTransfer(addr, amount);\\n    }\\n\\n    function _checkExceedLimitRate() private returns (bool){\\n        uint len = transactionTimeArr.length;\\n        if(len > 5 && block.timestamp - transactionTimeArr[len - 5] <= 86400){\\n            return false;\\n        }\\n        transactionTimeArr.push(block.timestamp);\\n        return true;\\n    }\\n\\n    function _checkExeedTransferredAmt() private view returns (bool){\\n        return transferredAmount <= allowedAmountCap;\\n    }\\n\\n    function setMaxAmountPerTrans(uint val) external onlyRole(OPERATOR) {\\n        maxAmountPerTrans = val;\\n    }\\n\\n    function setAllowedAmountCap(uint val) external onlyRole(OPERATOR) {\\n        allowedAmountCap = val;\\n    }\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Const.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nlibrary Const {\\n    uint public constant MULTIPLIER_18 = 10 ** 18;\\n    uint public constant MULTIPLIER_6 = 10 ** 6;\\n\\n    address public constant A_USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    // address public constant A_DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public constant A_DYDX = 0x92D6C1e31e14520e676a687F0a93788B716BEff5;\\n\\n    address public constant A_DYDX_USDT_POOL = 0x6C4AB1907805AdCB0B7ae911A5d1B0B99d608B3C;\\n    address public constant A_UNI_QUOTER = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\n}\"\r\n    },\r\n    \"contracts/Invitation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\n\\ncontract Invitation is Ownable, AccessControlEnumerable {\\n\\n  // Key: account A; Value: whether A is registered\\n  mapping(address => bool) public registeredMap;\\n\\n  // Track who invited whom(me). Key: account A; Value: A's inviter\\n  mapping(address => address) public inviterOf;\\n\\n  // Key: account A; Value: A's root inviter\\n  mapping(address => address) public rootInviterOf;\\n  \\n  // Key: account A; Value: acccounts that A has invited\\n  mapping(address => address[]) public inviteesOf;\\n\\n  error SameAdminAddress();\\n  error SameInviterAddress();\\n  error InvalidAddress();\\n  error AlreadyRegistered();\\n  error InviterUnregistered();\\n  error AccountUnregistered();\\n  error SelfInvitationNotAllowed();\\n\\n  event Invite(address indexed inviter, address indexed invitee);\\n  event AdminInvite(address indexed inviter, address indexed invitee);\\n\\n  constructor(\\n    address initialOwner,\\n    address initialAdmin\\n  ) Ownable(initialOwner) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n  }\\n\\n  // if this does not work, then use grantDefaultAdmin\\n  function setDefaultAdmin(address addr) external onlyOwner {\\n    if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n      address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n      if(currentAdmin == addr) revert SameAdminAddress();\\n      _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n    }\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  // only use when setDefaultAdmin does not work\\n  function grantDefaultAdmin(address addr) external onlyOwner {\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  function register(address inviter) public {\\n    if(registeredMap[msg.sender]) revert AlreadyRegistered();\\n\\n    // there is an inviter\\n    if(inviter != address(0)){\\n      if(!registeredMap[inviter]) revert InviterUnregistered();\\n      inviterOf[msg.sender] = inviter;\\n      if(!_elementExists(inviteesOf[inviter], msg.sender)){\\n        inviteesOf[inviter].push(msg.sender);\\n      }\\n      rootInviterOf[msg.sender] = _getRootInviter(inviter);\\n    }\\n    registeredMap[msg.sender] = true;\\n    emit Invite(inviter, msg.sender);\\n  }\\n\\n  function adminSetInviter(address addr, address inviter) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if(addr == address(0)) revert InvalidAddress();\\n    if(!registeredMap[addr]) revert AccountUnregistered();\\n    if(inviter != address(0) && !registeredMap[inviter]) revert InviterUnregistered();\\n    if(addr == inviter) revert SelfInvitationNotAllowed();\\n    address currentInviter = inviterOf[addr];\\n    if(inviter == currentInviter) revert SameInviterAddress();\\n\\n    inviterOf[addr] = inviter;\\n    _removeElement(inviteesOf[currentInviter], addr);\\n\\n    if(inviter != address(0) && !_elementExists(inviteesOf[inviter], addr)){\\n      inviteesOf[inviter].push(addr);\\n    } \\n    rootInviterOf[addr] = _getRootInviter(inviter);\\n\\n    _setRootInviter4Invitees(inviteesOf[addr], addr, inviter);\\n\\n    emit AdminInvite(inviter, addr);\\n  }\\n\\n  function _setRootInviter4Invitees(address[] memory inviteesArr, address addr, address inviter) private {\\n    uint len = inviteesArr.length;\\n    for(uint i; i < len; i++){\\n      rootInviterOf[inviteesArr[i]] = inviter==address(0) ? addr : _getRootInviter(inviter);\\n      _setRootInviter4Invitees(inviteesOf[inviteesArr[i]], inviteesArr[i], inviterOf[inviteesArr[i]]);\\n    }\\n  }\\n\\n  function _getRootInviter(address inviter) view private returns(address){\\n    // the account is root, so its inviter and root inviter is address(0)\\n    if(inviter == address(0)) return address(0);\\n    return (rootInviterOf[inviter] == address(0)) ? inviter : rootInviterOf[inviter];\\n  }\\n\\n  function _removeElement(address[] storage array, address e) private {\\n    uint len = array.length;\\n    for (uint i = 0; i < len; i++) {\\n      if (array[i] == e) {\\n        array[i] = array[len - 1];\\n        array.pop();\\n      }\\n    }\\n  }\\n\\n  function _elementExists(address[] memory array, address target) private pure returns (bool) {\\n    for (uint i = 0; i < array.length; i++) {\\n      if (array[i] == target) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function getInvitees(address addr) public view returns (address[] memory) {\\n      return inviteesOf[addr];\\n  }\\n}\"\r\n    },\r\n    \"contracts/InviteReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ninterface IInvitation {\\n    function inviterOf(address _account) external view returns (address);\\n    function rootInviterOf(address _account) external view returns (address);\\n    function inviteesOf(address _account) external view returns (address[] memory);\\n}\\n\\ninterface ISavings {\\n    function listAllSStakingContracts() external view returns (address[] memory);\\n}\\n\\ncontract InviteReward is Ownable, Pausable, AccessControlEnumerable {\\n  using SafeERC20 for IERC20;\\n  bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n  uint inviteRewardRate = 5; //5%\\n  uint indirectInviteRewardRate = 3; //3%\\n  bool claimIndirectInvitationRewards = true;\\n\\n  address A_t100x;\\n  address A_staking100xt;\\n  address A_savings;\\n  address A_Invitation;\\n\\n  // Key: account A; Value: A's last claimed block number\\n  mapping(address => uint) lastClaimedBlockNO;\\n\\n  // Key: account A; Value: A's total claimed 100xt from invitations\\n  mapping(address => uint) public claimed;\\n\\n  constructor(\\n    address initialOwner,\\n    address initialAdmin,\\n    address a_t100x,\\n    address a_invitation\\n  ) Ownable(initialOwner) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n    _grantRole(OPERATOR, initialOwner);\\n    _grantRole(OPERATOR, initialAdmin);\\n    A_t100x = a_t100x;\\n    A_Invitation = a_invitation;\\n  }\\n\\n  // if this does not work, then use grantDefaultAdmin\\n  function setDefaultAdmin(address addr) external onlyOwner {\\n    if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n      address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n      require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n      _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n    }\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  // only use when setDefaultAdmin does not work\\n  function grantDefaultAdmin(address addr) external onlyOwner {\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  function getInvitationRewards(address addr) public view returns (uint){\\n    IInvitation inviteContract = IInvitation(A_Invitation);\\n    address[] memory invitees = inviteContract.inviteesOf(addr);\\n\\n    uint inviteesRewards;\\n    uint indirectInviteesRewards;\\n\\n    for (uint i = 0; i < invitees.length; i++) {\\n      inviteesRewards += getContractsRewards(invitees[i]);\\n      if(claimIndirectInvitationRewards){\\n        address[] memory indirectInvitees = inviteContract.inviteesOf(invitees[i]);\\n        for (uint j = 0; j < indirectInvitees.length; j++) {\\n          indirectInviteesRewards += getContractsRewards(indirectInvitees[j]);\\n        }\\n      }\\n    }\\n    return (inviteesRewards * inviteRewardRate + indirectInviteesRewards * indirectInviteRewardRate) / 100;\\n  }\\n\\n  function getContractsRewards(address addr) public view returns (uint){\\n    ISavings savingsContract = ISavings(A_savings);\\n    address[] memory addresses = savingsContract.listAllSStakingContracts();\\n    uint length = addresses.length;\\n    uint rewards;\\n    for (uint i = 0; i < length; ++i) {\\n      IStaking sStakingContract = IStaking(addresses[i]);\\n      rewards += sStakingContract.rewards(addr, lastClaimedBlockNO[addr]);\\n      // rewards += sStakingContract.rewards(addr, lastClaimedBlockNO[msg.sender]);\\n    }\\n    if(A_staking100xt != address(0)){\\n      IStaking staking100xtContract = IStaking(A_staking100xt);\\n      rewards += staking100xtContract.rewards(addr, lastClaimedBlockNO[addr]);\\n      // rewards += staking100xtContract.rewards(addr, lastClaimedBlockNO[msg.sender]);\\n    }\\n    return rewards;\\n  }\\n\\n  /**\\n   * Manual Operation: mint 100xt to this contract for rewarding. \\n   * A child withdraw all the money, I may lose rewards from him,so claiming regularly is a good practice.\\n   */\\n  function claimInvitationRewards() public whenNotPaused returns (uint){\\n    uint totalAmount = getInvitationRewards(msg.sender);\\n    claimed[msg.sender] += totalAmount;\\n    lastClaimedBlockNO[msg.sender] = block.number;\\n\\n    // transfer the rewards\\n    IERC20 token = IERC20(A_t100x);\\n    token.safeTransfer(msg.sender, totalAmount);\\n\\n    return totalAmount;\\n  }\\n\\n/**\\n * For calculating leverage ratio\\n */\\n  function getLeverageDepositAmt(address addr) public view returns (uint){\\n    ISavings savingsContract = ISavings(A_savings);\\n    address[] memory addresses = savingsContract.listAllSStakingContracts();\\n    uint length = addresses.length;\\n    uint amount;\\n    for (uint i = 0; i < length; ++i) {\\n      IStaking sStakingContract = IStaking(addresses[i]);\\n      amount += sStakingContract.balanceOf(addr);\\n    }\\n    return amount;\\n  }\\n\\n  // 100XT amount\\n  function getLeverageAmt(address addr) public view returns (uint){\\n    uint invitateRewardAmt = claimed[addr];\\n    uint myReward;\\n    ISavings savingsContract = ISavings(A_savings);\\n    address[] memory addresses = savingsContract.listAllSStakingContracts();\\n    uint length = addresses.length;\\n    for (uint i = 0; i < length; ++i) {\\n      IStaking sStakingContract = IStaking(addresses[i]);\\n      myReward += sStakingContract.getMyClaimed(addr);\\n    }\\n    if(A_staking100xt != address(0)){\\n      IStaking staking100xtContract = IStaking(A_staking100xt);\\n      myReward += staking100xtContract.getMyClaimed(addr);\\n    }\\n    return invitateRewardAmt + myReward * 20 / 100;\\n  }\\n\\n  function setClaimIndirectInvitationRewards(bool flag) external onlyRole(OPERATOR) {\\n    claimIndirectInvitationRewards = flag;\\n  }\\n\\n  function setInviteRewardRate(uint rate) external onlyRole(OPERATOR) {\\n    require(rate >= 0, \\\"value needs to be greater than 0\\\");\\n    require(rate < 20, \\\"value needs to be less than 20\\\");\\n    inviteRewardRate = rate;\\n  }\\n\\n  function setIndirectInviteRewardRate(uint rate) external onlyRole(OPERATOR) {\\n    require(rate >= 0, \\\"value needs to be greater than 0\\\");\\n    require(rate < 10, \\\"value needs to be less than 10\\\");\\n    indirectInviteRewardRate = rate;\\n  }\\n\\n  function set100XTAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n      require(addr != address(0), \\\"Invalid address provided\\\");\\n      A_t100x = addr;\\n  }\\n\\n  function setStaking100XTAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n      require(addr != address(0), \\\"Invalid address provided\\\");\\n      A_staking100xt = addr;\\n  }\\n\\n  function setSavingsAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n      require(addr != address(0), \\\"Invalid address provided\\\");\\n      A_savings = addr;\\n  }\\n\\n  function setInvitationAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n      require(addr != address(0), \\\"Invalid address provided\\\");\\n      A_Invitation = addr;\\n  }\\n\\n  function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n      _pause();\\n  }\\n\\n  function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n      _unpause();\\n  }\\n}\"\r\n    },\r\n    \"contracts/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\ninterface IOracle {\\n    /**\\n     * @param oracleType 1: system's preset value 2: uniswap 3: other oracle source like chainlink etc\\n     * \\n     * e.g. tokenIn=DYDX tokenOut=100XT and (1 DYDX)=(2.05 100XT)\\n     * return value will be 2.05*(10**18): 18 is 100XT's decimal\\n     * Note: if want to get a token's USD price, tokenOut can be set to \\\"USDT\\\"\\n     * Note:for future oracle implementation: if the token/baseToken pair does not exist in mapping, use 3rd-party oracle!\\n     */\\n    function getPrice(string calldata tokenInSymbol, string calldata tokenOutSymbol, uint oracleType) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\n// For refering staking contracts in Invitation.sol, so we only define this method for now\\ninterface IStaking {\\n    function rewards(address addr, uint startBlockNO) external view returns (uint);\\n    function getMyClaimed(address addr) external view returns (uint);\\n    function balanceOf(address _account) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Leverage-o.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./Const.sol\\\";\\n\\n// todo: admin to set ratio and leverage amount for particular account!\\ninterface ISavings {\\n    function transfer2Leverage(address tokenAddress, uint amount) external;\\n}\\n\\ninterface IBankVaultL {\\n    function transferDYDX2Leverage(address tokenAddress, uint amount) external;\\n}\\n\\ninterface IInviteReward {\\n    function getLeverageDepositAmt(address addr) external view returns (uint);\\n    function claimed(address addr) external view returns (uint);\\n    function getLeverageAmt(address addr) external view returns (uint);\\n}\\n\\ninterface IInvitation {\\n    function inviterOf(address _account) external view returns (address);\\n    function rootInviterOf(address _account) external view returns (address);\\n    function inviteesOf(address _account) external view returns (address[] memory);\\n}\\n\\n// need to set system address during/after deployment\\ncontract Leverage is Ownable, Pausable, AccessControlEnumerable {\\n    using SafeERC20 for IERC20;\\n    bytes32 private constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n    ISwapRouter private immutable swapRouter;\\n    address private A_USDX;\\n    address private A_100XT;\\n    address private A_Savings;\\n    address private A_Invitation;\\n    address private A_InvitReward;\\n    address private A_BankVault;\\n    address private A_OracleProxy;\\n\\n    // system address to receive earnings if there are no inviters\\n    address public A_System;\\n\\n    // if leverage ratio=2, user pay 2*10=20 100xt\\n    uint public leverage100xtFeeRate = 10 * Const.MULTIPLIER_18;\\n\\n    uint public leverageFeeRate = 1000; // leverage fee = 0.1%.\\n    uint16 public poolFee = 3000; // 0.3%\\n\\n    // ratio increment 1, per 20,000 USD\\n    uint public ratioPerAmount = 20000 * Const.MULTIPLIER_18;\\n    uint16 public systemRatioLimit = 100;\\n    uint public sysLeverageShortAmtLimit = 10000;\\n\\n    uint private swapAmtOutMinRate = 80; //80%\\n\\n    uint public USDTLimitPerSwap = 50000 * Const.MULTIPLIER_6;\\n\\n    // balances' key will be USDT or USDX to distinguish different type of trade\\n    struct User {\\n        mapping(string => uint) dydxbalances;\\n        mapping(string => uint) borrowedbalances;\\n        mapping(string => uint) principalAmt;//new\\n        // mapping(string => uint) withdrawalAmt;//new\\n        uint usedLeverageShortAmt; // 10,000 for USDX + USDT\\n    }\\n    mapping(address => User) public user;\\n\\n    uint public sysProfitRate = 5;\\n    uint public inviterProfitRate = 5;\\n    uint public rootInviterProfitRate =10;\\n\\n    uint private t100xUsdtPriceType = 1;\\n    uint private dydxUsdxPriceType = 1;\\n    uint private dydxUsdtPriceType = 1;\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        ISwapRouter _swapRouter,\\n        address _a_usdx,\\n        address _a_t100xt,\\n        address _a_savings,\\n        address _a_invitation,\\n        address _a_invite_reward,\\n        address _a_oracle_proxy\\n    ) Ownable(initialOwner) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        swapRouter = _swapRouter;\\n        require(_a_usdx != address(0), \\\"Invalid address provided\\\");\\n        require(_a_t100xt != address(0), \\\"Invalid address provided\\\");\\n        require(_a_savings != address(0), \\\"Invalid address provided\\\");\\n        require(_a_invitation != address(0), \\\"Invalid address provided\\\");\\n        require(_a_invite_reward != address(0), \\\"Invalid address provided\\\");\\n        require(_a_oracle_proxy != address(0), \\\"Invalid address provided\\\");\\n        A_USDX = _a_usdx;\\n        A_100XT = _a_t100xt;\\n        A_Savings = _a_savings;\\n        A_Invitation = _a_invitation;\\n        A_InvitReward = _a_invite_reward;\\n        A_OracleProxy = _a_oracle_proxy;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    //usdx or usdt\\n    function useLeverage(address tokenAddr, uint amountIn, uint16 ratio) external whenNotPaused returns (uint amountOut) {\\n        require(tokenAddr == Const.A_USDT || tokenAddr == A_USDX, \\\"Token must be USDX or USDT\\\");\\n\\n        // check max ratio\\n        uint allowedMaxRatio = getAllowedMaxRatio();\\n        require(ratio <= allowedMaxRatio, string(abi.encodePacked(\\\"Exeed max ratio: \\\", Strings.toString(allowedMaxRatio))));\\n\\n        // check max leverage amount, make sure the amount does not exceed limit even if the user has multiple leverages\\n        uint shortAmtIn = _getShortAmt(tokenAddr, amountIn);\\n        uint allowedShortAmt = getAllowedLeverageShortAmt(msg.sender);\\n        uint usedShortAmt = user[msg.sender].usedLeverageShortAmt;\\n        require(allowedShortAmt > usedShortAmt, string(abi.encodePacked(\\\"Leverage short amount used: \\\", Strings.toString(usedShortAmt))));\\n        uint currentAllowedShortAmt = allowedShortAmt - usedShortAmt;\\n        require(shortAmtIn <= currentAllowedShortAmt, string(abi.encodePacked(\\\"Exceed current allowed leverage short amount: \\\", Strings.toString(currentAllowedShortAmt))));\\n\\n        // msg.sender must approve this contract!!! R: Should be done on the web3 side!\\n        // pay principal: Transfer the specified amount of token(usdx/usdt) to this contract.\\n        TransferHelper.safeTransferFrom(tokenAddr, msg.sender, address(this), amountIn);\\n\\n        // pay 100x\\n        IERC20 t100x = IERC20(A_100XT);\\n        // frontend to call approve\\n        t100x.safeTransferFrom(msg.sender, address(this), ratio * leverage100xtFeeRate);\\n\\n        user[msg.sender].usedLeverageShortAmt += amountIn / _decimals(tokenAddr);\\n        user[msg.sender].principalAmt[_symbol(tokenAddr)] += amountIn;\\n        user[msg.sender].borrowedbalances[_symbol(tokenAddr)] += amountIn * ratio;\\n\\n        // borrow money from savings\\n        // TODO consider UX when not enough money to borrow\\n        ISavings savingsContract = ISavings(A_Savings);\\n        savingsContract.transfer2Leverage(tokenAddr, amountIn * ratio);\\n\\n        // calculate fees\\n        uint totalAmount = amountIn * (ratio + 1);\\n        uint swapAmount = _distributeFees(tokenAddr, totalAmount);\\n\\n        // swap\\n        // TODO: consider big swap strategy! multiple leverages for one user! to store how much a user has used leverage!\\n        amountOut = _swap(tokenAddr, Const.A_DYDX, swapAmount, A_BankVault);\\n        user[msg.sender].dydxbalances[_symbol(tokenAddr)] += amountOut;\\n    }\\n\\n    /**\\n     * @param tokenAddr indicate selling for USDX OR USDT\\n     */\\n    function sell(uint dydxAmountIn, address tokenAddr) external whenNotPaused returns (uint amountOut) {\\n        require(user[msg.sender].dydxbalances[_symbol(tokenAddr)] >= dydxAmountIn, \\\"Not enough dydx amount in user's account\\\");\\n\\n        require(ifAllowSelling(tokenAddr, msg.sender), \\\"Selling is blocked due to shrinked asset\\\");\\n\\n        IERC20 token = IERC20(tokenAddr);\\n        // transfer dydx from VaultL to this contract\\n        IBankVaultL bankVault = IBankVaultL(A_BankVault);\\n        bankVault.transferDYDX2Leverage(Const.A_DYDX, dydxAmountIn);\\n        amountOut = _swap(Const.A_DYDX, tokenAddr, dydxAmountIn, address(this));\\n        user[msg.sender].dydxbalances[_symbol(tokenAddr)] -= dydxAmountIn;\\n\\n        // calculate fees\\n        amountOut = _distributeFees(tokenAddr, amountOut);\\n\\n        // return borrowed money\\n        uint borrowedAmt = user[msg.sender].borrowedbalances[_symbol(tokenAddr)];\\n        if(borrowedAmt > 0){\\n            uint returnAmt = (borrowedAmt > amountOut) ? amountOut : borrowedAmt;\\n            user[msg.sender].borrowedbalances[_symbol(tokenAddr)] -= returnAmt;\\n            amountOut -= returnAmt;\\n            token.safeTransfer(A_Savings, returnAmt);\\n        }\\n\\n        // calculate profit\\n        if(amountOut > 0){\\n            // return principal\\n            uint principalAmt = user[msg.sender].principalAmt[_symbol(tokenAddr)];\\n\\n            // pay back principal first\\n            if(principalAmt > 0 && principalAmt >= amountOut){\\n                user[msg.sender].principalAmt[_symbol(tokenAddr)] -= amountOut;\\n                token.safeTransfer(msg.sender, amountOut);\\n\\n            // pay back all the principal\\n            }else if(principalAmt > 0 && principalAmt < amountOut){\\n                amountOut -= principalAmt;\\n                user[msg.sender].principalAmt[_symbol(tokenAddr)] = 0;\\n                amountOut = _distributeProfit(token, amountOut);\\n                token.safeTransfer(msg.sender, principalAmt + amountOut);\\n            }else{\\n                // the account has earned back all the principal amount already\\n                amountOut = _distributeProfit(token, amountOut);\\n                token.safeTransfer(msg.sender, amountOut);\\n            }\\n        }\\n\\n        // return 100xt\\n\\n    }\\n\\n    /**\\n     * @param tokenAddr USDX address or USDT address\\n     * @param addr caller's address\\n     * return true if user's dydx'value is greater than the borrowed coins\\n     */\\n    function ifAllowSelling(address tokenAddr, address addr) public returns (bool) {\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        string memory symbol = _symbol(tokenAddr);\\n        uint priceType = (keccak256(abi.encodePacked(symbol)) == keccak256(abi.encodePacked(\\\"USDX\\\"))) ? dydxUsdxPriceType : dydxUsdtPriceType;\\n        uint dydxPrice = oracle.getPrice(\\\"DYDX\\\", symbol, priceType);\\n        return user[addr].dydxbalances[symbol] * dydxPrice > user[addr].borrowedbalances[_symbol(tokenAddr)];\\n    }\\n\\n    function _distributeProfit(IERC20 token, uint amount) private returns (uint pay2user) {\\n        uint pay2sysAmt = amount * sysProfitRate / 100;\\n        uint pay2inviterAmt = amount * inviterProfitRate / 100;\\n        uint pay2rootInviterAmt = amount * rootInviterProfitRate / 100;\\n\\n        IInvitation inviteContract = IInvitation(A_Invitation);\\n        token.safeTransfer(inviteContract.inviterOf(msg.sender), pay2inviterAmt);\\n        address rootInviterAddr = inviteContract.rootInviterOf(msg.sender);\\n\\n        if(rootInviterAddr != address(0)){\\n            token.safeTransfer(rootInviterAddr, pay2rootInviterAmt);\\n            token.safeTransfer(A_System, pay2sysAmt);\\n        }else{\\n            // if root address does not exist, use system address instead!\\n            token.safeTransfer(A_System, pay2rootInviterAmt + pay2sysAmt);\\n        }\\n        pay2user = amount - pay2sysAmt - pay2inviterAmt - pay2rootInviterAmt;\\n    }\\n\\n    function _distributeFees(address tokenAddr, uint amount) private returns (uint) {\\n        uint leverageFee = amount * leverageFeeRate / 1000000;\\n        uint pay2inviterAmt = leverageFee / 2;\\n        uint pay2rootInviterAmt = leverageFee - pay2inviterAmt;\\n\\n        IERC20 token = IERC20(tokenAddr); \\n        IInvitation inviteContract = IInvitation(A_Invitation);\\n        token.safeTransfer(inviteContract.inviterOf(msg.sender), pay2inviterAmt);\\n        address rootInviterAddr = inviteContract.rootInviterOf(msg.sender);\\n\\n        // check: if root address does not exist, use system address instead!\\n        token.safeTransfer((rootInviterAddr==address(0)) ? A_System : rootInviterAddr, pay2rootInviterAmt);\\n        return amount - leverageFee;\\n    }\\n\\n    // The calling address must approve this contract to spend at least `amountIn` worth of its USDT for this function to succeed.\\n    function _swap(address tokenIn, address tokenOut, uint amountIn, address outAddr) private returns (uint amountOut) {\\n\\n        // Approve the router to spend USDT\\n        TransferHelper.safeApprove(tokenIn, address(swapRouter), amountIn);\\n\\n        // only swap max 50K USDT a time. Leftover will be swapped next time along with others' funds\\n        uint swapAmount = amountIn;\\n        // uint swapAmount = getSwapAmount(amountIn, address(this).balance);\\n\\n        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.\\n        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\n            .ExactInputSingleParams({\\n                tokenIn: tokenIn,\\n                tokenOut: tokenOut,\\n                fee: poolFee,\\n                recipient: outAddr,\\n                deadline: block.timestamp,\\n                amountIn: swapAmount,\\n                amountOutMinimum: _getAmountOutMinimum(swapAmount),\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n        return swapRouter.exactInputSingle(params);\\n    }\\n\\n    function getSwapAmount(uint amountIn, uint contractBalance) private view returns (uint swapAmount) {\\n        if (amountIn > USDTLimitPerSwap) {\\n            swapAmount = USDTLimitPerSwap;\\n        } else if (amountIn + contractBalance > USDTLimitPerSwap) {\\n            swapAmount = USDTLimitPerSwap;\\n        } else {\\n            swapAmount = amountIn + contractBalance;\\n        }\\n        return swapAmount;\\n    }\\n\\n\\n    function _getAmountOutMinimum(uint amountIn) private returns (uint amountOutMin) {\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        uint dydxPrice = oracle.getPrice(\\\"DYDX\\\", \\\"USDX\\\", dydxUsdxPriceType);\\n        // dydxAmount * dydxPrice = usdxAmount * usdxPrice -> dydxAmount = usdxAmount/dydxPrice\\n        amountOutMin = amountIn * swapAmtOutMinRate / 100 / dydxPrice;\\n    }\\n\\n\\n    function getAllowedMaxRatio() public view returns (uint ratio) {\\n        IInvitation inviteContract = IInvitation(A_Invitation);\\n        IInviteReward inviteRewardContract = IInviteReward(A_InvitReward);\\n        address[] memory children = inviteContract.inviteesOf(msg.sender);\\n        uint childrenTotalAmount;\\n        for (uint i = 0; i < children.length; i++) {\\n            childrenTotalAmount += inviteRewardContract.getLeverageDepositAmt(children[i]);\\n        }\\n        return _calculateMaxLeverageRatio(childrenTotalAmount, ratioPerAmount, systemRatioLimit);\\n    }\\n\\n    function _calculateMaxLeverageRatio(\\n        uint _childrenTotalAmount,\\n        uint _ratioPerAmount,\\n        uint16 _systemRatioLimit\\n    ) private pure returns (uint) {\\n        uint maxRatio = _childrenTotalAmount / _ratioPerAmount;\\n        maxRatio = (maxRatio == 0) ? 1 : maxRatio;\\n        return (maxRatio > _systemRatioLimit) ? _systemRatioLimit : maxRatio;\\n    }\\n\\n    function _getShortAmt(address token, uint amount) private pure returns (uint) {\\n        return amount / ((token == Const.A_USDT) ? Const.MULTIPLIER_6 : Const.MULTIPLIER_18);\\n    }\\n\\n    /**\\n     * @param token USDT or USDX\\n     */\\n    function _symbol(address token) private pure returns(string memory){\\n        return (token == Const.A_USDT) ? \\\"USDT\\\" : \\\"USDX\\\";\\n    }\\n\\n    /**\\n     * @param token USDT or USDX\\n     */\\n    function _decimals(address token) private pure returns(uint){\\n        return (token == Const.A_USDT) ? Const.MULTIPLIER_6 : Const.MULTIPLIER_18;\\n    }\\n\\n    /**\\n     * 'ShortAmt' in the function name refers to the amount without decimals\\n     * Considered rewards amount and system amount limit\\n     */\\n    function getAllowedLeverageShortAmt(address addr) public returns (uint) {\\n        // the user has used all the leverage amount\\n        // if(user[msg.sender].usedLeverageAmt >= sysLeverageShortAmtLimit) return 0;\\n\\n        IInviteReward inviteRewardContract = IInviteReward(A_InvitReward);\\n        uint leverageAmt = inviteRewardContract.getLeverageAmt(addr);\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        uint t100xPrice = oracle.getPrice(\\\"T100X\\\", \\\"USDT\\\", t100xUsdtPriceType);\\n        uint rewardAllowedUSDTShortAmt = leverageAmt * t100xPrice / Const.MULTIPLIER_6;\\n        uint allowedAmt = (rewardAllowedUSDTShortAmt > sysLeverageShortAmtLimit) ? sysLeverageShortAmtLimit : rewardAllowedUSDTShortAmt;\\n        return allowedAmt;\\n    }\\n\\n    function setLeverage100xtFeeRate(uint rate) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        leverage100xtFeeRate = rate;\\n    }\\n\\n    function setSystemAddress(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_System = addr;\\n    }\\n\\n    function setBankVaultAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_BankVault = addr;\\n    }\\n\\n    function setInvitationAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_Invitation = addr;\\n    }\\n\\n    function setSwapAmtOutMinRate(uint _val) external onlyRole(OPERATOR) {\\n        require(_val <= 100, \\\"Value must be less than 100\\\");\\n        require(_val >= 50, \\\"Value must be greater than 50\\\");\\n        swapAmtOutMinRate = _val;\\n    }\\n\\n    //TODO set functions for other variables\\n\\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Leverage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\npragma abicoder v2;\\n\\nimport \\\"./LeverageBase.sol\\\";\\nimport \\\"./Const.sol\\\";\\n\\n// todo: admin to set ratio and leverage amount for particular account!\\n// need to set system address during/after deployment\\ncontract Leverage is LeverageBase {\\nconstructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        ISwapRouter swapRouter,\\n        address a_usdx,\\n        address a_t100xt,\\n        address a_savings,\\n        address a_invitation,\\n        address a_invite_reward,\\n        address a_oracle_proxy\\n    ) LeverageBase(initialOwner, initialAdmin, swapRouter, a_usdx, a_t100xt, a_savings, a_invitation, a_invite_reward, a_oracle_proxy) {}\\n}\\n\\n\"\r\n    },\r\n    \"contracts/LeverageBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./Const.sol\\\";\\n\\n// todo: admin to set ratio and leverage amount for particular account!\\ninterface ISavings {\\n    function transfer2Leverage(address tokenAddress, uint amount) external;\\n}\\n\\ninterface IBankVaultL {\\n    function transferDYDX2Leverage(address tokenAddress, uint amount) external;\\n}\\n\\ninterface IInviteReward {\\n    function getLeverageDepositAmt(address addr) external view returns (uint);\\n    function claimed(address addr) external view returns (uint);\\n    function getLeverageAmt(address addr) external view returns (uint);\\n}\\n\\ninterface IInvitation {\\n    function inviterOf(address _account) external view returns (address);\\n    function rootInviterOf(address _account) external view returns (address);\\n    function inviteesOf(address _account) external view returns (address[] memory);\\n}\\n\\n// need to set system address during/after deployment\\nabstract contract LeverageBase is Ownable, Pausable, AccessControlEnumerable {\\n    using SafeERC20 for IERC20;\\n    bytes32 private constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n    ISwapRouter private immutable swapRouter;\\n    address private A_USDX;\\n    address private A_100XT;\\n    address private A_Savings;\\n    address private A_Invitation;\\n    address private A_InvitReward;\\n    address private A_BankVault;\\n    address private A_OracleProxy;\\n\\n    // system address to receive earnings if there are no inviters\\n    address public A_System;\\n\\n    // if leverage ratio=2, user pay 2*10=20 100xt\\n    uint public leverage100xtFeeRate = 10 * Const.MULTIPLIER_18;\\n\\n    uint public leverageFeeRate = 1000; // leverage fee = 0.1%.\\n    uint16 public poolFee = 3000; // 0.3%\\n\\n    // ratio increment 1, per 20,000 USD\\n    uint public ratioPerAmount = 20000 * Const.MULTIPLIER_18;\\n    uint16 public systemRatioLimit = 100;\\n    uint public sysLeverageShortAmtLimit = 10000;\\n\\n    uint private swapAmtOutMinRate = 80; //80%\\n\\n    uint public USDTLimitPerSwap = 50000 * Const.MULTIPLIER_6;\\n\\n    // balances' key will be USDT or USDX to distinguish different type of trade\\n    struct User {\\n        mapping(string => uint) dydxbalances;\\n        mapping(string => uint) borrowedbalances;\\n        mapping(string => uint) principalAmt;//new\\n        // mapping(string => uint) withdrawalAmt;//new\\n        uint usedLeverageShortAmt; // 10,000 for USDX + USDT\\n    }\\n    mapping(address => User) public user;\\n\\n    uint public sysProfitRate = 5;\\n    uint public inviterProfitRate = 5;\\n    uint public rootInviterProfitRate =10;\\n\\n    uint private t100xUsdtPriceType = 1;\\n    uint private dydxUsdxPriceType = 1;\\n    uint private dydxUsdtPriceType = 1;\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        ISwapRouter _swapRouter,\\n        address _a_usdx,\\n        address _a_t100xt,\\n        address _a_savings,\\n        address _a_invitation,\\n        address _a_invite_reward,\\n        address _a_oracle_proxy\\n    ) Ownable(initialOwner) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        swapRouter = _swapRouter;\\n        require(_a_usdx != address(0), \\\"Invalid address provided\\\");\\n        require(_a_t100xt != address(0), \\\"Invalid address provided\\\");\\n        require(_a_savings != address(0), \\\"Invalid address provided\\\");\\n        require(_a_invitation != address(0), \\\"Invalid address provided\\\");\\n        require(_a_invite_reward != address(0), \\\"Invalid address provided\\\");\\n        require(_a_oracle_proxy != address(0), \\\"Invalid address provided\\\");\\n        A_USDX = _a_usdx;\\n        A_100XT = _a_t100xt;\\n        A_Savings = _a_savings;\\n        A_Invitation = _a_invitation;\\n        A_InvitReward = _a_invite_reward;\\n        A_OracleProxy = _a_oracle_proxy;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    //usdx or usdt\\n    function useLeverage(address tokenAddr, uint amountIn, uint16 ratio) external whenNotPaused returns (uint amountOut) {\\n        require(tokenAddr == Const.A_USDT || tokenAddr == A_USDX, \\\"Token must be USDX or USDT\\\");\\n\\n        // check max ratio\\n        uint allowedMaxRatio = getAllowedMaxRatio();\\n        require(ratio <= allowedMaxRatio, string(abi.encodePacked(\\\"Exeed max ratio: \\\", Strings.toString(allowedMaxRatio))));\\n\\n        // check max leverage amount, make sure the amount does not exceed limit even if the user has multiple leverages\\n        uint shortAmtIn = _getShortAmt(tokenAddr, amountIn);\\n        uint allowedShortAmt = getAllowedLeverageShortAmt(msg.sender);\\n        uint usedShortAmt = user[msg.sender].usedLeverageShortAmt;\\n        require(allowedShortAmt > usedShortAmt, string(abi.encodePacked(\\\"Leverage short amount used: \\\", Strings.toString(usedShortAmt))));\\n        uint currentAllowedShortAmt = allowedShortAmt - usedShortAmt;\\n        require(shortAmtIn <= currentAllowedShortAmt, string(abi.encodePacked(\\\"Exceed current allowed leverage short amount: \\\", Strings.toString(currentAllowedShortAmt))));\\n\\n        // msg.sender must approve this contract!!! R: Should be done on the web3 side!\\n        // pay principal: Transfer the specified amount of token(usdx/usdt) to this contract.\\n        TransferHelper.safeTransferFrom(tokenAddr, msg.sender, address(this), amountIn);\\n\\n        // pay 100x\\n        IERC20 t100x = IERC20(A_100XT);\\n        // frontend to call approve\\n        t100x.safeTransferFrom(msg.sender, address(this), ratio * leverage100xtFeeRate);\\n\\n        user[msg.sender].usedLeverageShortAmt += amountIn / _decimals(tokenAddr);\\n        user[msg.sender].principalAmt[_symbol(tokenAddr)] += amountIn;\\n        user[msg.sender].borrowedbalances[_symbol(tokenAddr)] += amountIn * ratio;\\n\\n        // borrow money from savings\\n        // TODO consider UX when not enough money to borrow\\n        ISavings savingsContract = ISavings(A_Savings);\\n        savingsContract.transfer2Leverage(tokenAddr, amountIn * ratio);\\n\\n        // calculate fees\\n        uint totalAmount = amountIn * (ratio + 1);\\n        uint swapAmount = _distributeFees(tokenAddr, totalAmount);\\n\\n        // swap\\n        // TODO: consider big swap strategy! \\n        amountOut = _swap(tokenAddr, Const.A_DYDX, swapAmount, A_BankVault);\\n        user[msg.sender].dydxbalances[_symbol(tokenAddr)] += amountOut;\\n    }\\n\\n    /**\\n     * @param tokenAddr indicate selling for USDX OR USDT\\n     */\\n    function sell(uint dydxAmountIn, address tokenAddr) external whenNotPaused returns (uint amountOut) {\\n        require(user[msg.sender].dydxbalances[_symbol(tokenAddr)] >= dydxAmountIn, \\\"Not enough dydx amount in user's account\\\");\\n\\n        require(ifAllowSelling(tokenAddr, msg.sender), \\\"Selling is blocked due to shrinked asset\\\");\\n\\n        IERC20 token = IERC20(tokenAddr);\\n        // transfer dydx from VaultL to this contract\\n        IBankVaultL bankVault = IBankVaultL(A_BankVault);\\n        bankVault.transferDYDX2Leverage(Const.A_DYDX, dydxAmountIn);\\n        amountOut = _swap(Const.A_DYDX, tokenAddr, dydxAmountIn, address(this));\\n        user[msg.sender].dydxbalances[_symbol(tokenAddr)] -= dydxAmountIn;\\n\\n        // calculate fees\\n        amountOut = _distributeFees(tokenAddr, amountOut);\\n\\n        // return borrowed money\\n        uint borrowedAmt = user[msg.sender].borrowedbalances[_symbol(tokenAddr)];\\n        if(borrowedAmt > 0){\\n            uint returnAmt = (borrowedAmt > amountOut) ? amountOut : borrowedAmt;\\n            user[msg.sender].borrowedbalances[_symbol(tokenAddr)] -= returnAmt;\\n            amountOut -= returnAmt;\\n            token.safeTransfer(A_Savings, returnAmt);\\n        }\\n\\n        // calculate profit\\n        if(amountOut > 0){\\n            // return principal\\n            uint principalAmt = user[msg.sender].principalAmt[_symbol(tokenAddr)];\\n\\n            // pay back principal first\\n            if(principalAmt > 0 && principalAmt >= amountOut){\\n                user[msg.sender].principalAmt[_symbol(tokenAddr)] -= amountOut;\\n                token.safeTransfer(msg.sender, amountOut);\\n\\n            // pay back all the principal\\n            }else if(principalAmt > 0 && principalAmt < amountOut){\\n                amountOut -= principalAmt;\\n                user[msg.sender].principalAmt[_symbol(tokenAddr)] = 0;\\n                amountOut = _distributeProfit(token, amountOut);\\n                token.safeTransfer(msg.sender, principalAmt + amountOut);\\n            }else{\\n                // the account has earned back all the principal amount already\\n                amountOut = _distributeProfit(token, amountOut);\\n                token.safeTransfer(msg.sender, amountOut);\\n            }\\n        }\\n\\n        // return 100xt\\n\\n    }\\n\\n    /**\\n     * @param tokenAddr USDX address or USDT address\\n     * @param addr caller's address\\n     * return true if user's dydx'value is greater than the borrowed coins\\n     */\\n    function ifAllowSelling(address tokenAddr, address addr) public returns (bool) {\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        string memory symbol = _symbol(tokenAddr);\\n        uint priceType = (keccak256(abi.encodePacked(symbol)) == keccak256(abi.encodePacked(\\\"USDX\\\"))) ? dydxUsdxPriceType : dydxUsdtPriceType;\\n        uint dydxPrice = oracle.getPrice(\\\"DYDX\\\", symbol, priceType);\\n        return user[addr].dydxbalances[symbol] * dydxPrice > user[addr].borrowedbalances[_symbol(tokenAddr)];\\n    }\\n\\n    function _distributeProfit(IERC20 token, uint amount) private returns (uint pay2user) {\\n        uint pay2sysAmt = amount * sysProfitRate / 100;\\n        uint pay2inviterAmt = amount * inviterProfitRate / 100;\\n        uint pay2rootInviterAmt = amount * rootInviterProfitRate / 100;\\n\\n        IInvitation inviteContract = IInvitation(A_Invitation);\\n        token.safeTransfer(inviteContract.inviterOf(msg.sender), pay2inviterAmt);\\n        address rootInviterAddr = inviteContract.rootInviterOf(msg.sender);\\n\\n        if(rootInviterAddr != address(0)){\\n            token.safeTransfer(rootInviterAddr, pay2rootInviterAmt);\\n            token.safeTransfer(A_System, pay2sysAmt);\\n        }else{\\n            // if root address does not exist, use system address instead!\\n            token.safeTransfer(A_System, pay2rootInviterAmt + pay2sysAmt);\\n        }\\n        pay2user = amount - pay2sysAmt - pay2inviterAmt - pay2rootInviterAmt;\\n    }\\n\\n    function _distributeFees(address tokenAddr, uint amount) private returns (uint) {\\n        uint leverageFee = amount * leverageFeeRate / 1000000;\\n        uint pay2inviterAmt = leverageFee / 2;\\n        uint pay2rootInviterAmt = leverageFee - pay2inviterAmt;\\n\\n        IERC20 token = IERC20(tokenAddr); \\n        IInvitation inviteContract = IInvitation(A_Invitation);\\n        token.safeTransfer(inviteContract.inviterOf(msg.sender), pay2inviterAmt);\\n        address rootInviterAddr = inviteContract.rootInviterOf(msg.sender);\\n\\n        // check: if root address does not exist, use system address instead!\\n        token.safeTransfer((rootInviterAddr==address(0)) ? A_System : rootInviterAddr, pay2rootInviterAmt);\\n        return amount - leverageFee;\\n    }\\n\\n    // The calling address must approve this contract to spend at least `amountIn` worth of its USDT for this function to succeed.\\n    function _swap(address tokenIn, address tokenOut, uint amountIn, address outAddr) private returns (uint amountOut) {\\n\\n        // Approve the router to spend USDT\\n        TransferHelper.safeApprove(tokenIn, address(swapRouter), amountIn);\\n\\n        // only swap max 50K USDT a time. Leftover will be swapped next time along with others' funds\\n        uint swapAmount = amountIn;\\n        // uint swapAmount = getSwapAmount(amountIn, address(this).balance);\\n\\n        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.\\n        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\n            .ExactInputSingleParams({\\n                tokenIn: tokenIn,\\n                tokenOut: tokenOut,\\n                fee: poolFee,\\n                recipient: outAddr,\\n                deadline: block.timestamp,\\n                amountIn: swapAmount,\\n                amountOutMinimum: _getAmountOutMinimum(swapAmount),\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n        return swapRouter.exactInputSingle(params);\\n    }\\n\\n    function getSwapAmount(uint amountIn, uint contractBalance) private view returns (uint swapAmount) {\\n        if (amountIn > USDTLimitPerSwap) {\\n            swapAmount = USDTLimitPerSwap;\\n        } else if (amountIn + contractBalance > USDTLimitPerSwap) {\\n            swapAmount = USDTLimitPerSwap;\\n        } else {\\n            swapAmount = amountIn + contractBalance;\\n        }\\n        return swapAmount;\\n    }\\n\\n    function _getAmountOutMinimum(uint amountIn) private returns (uint amountOutMin) {\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        uint dydxPrice = oracle.getPrice(\\\"DYDX\\\", \\\"USDX\\\", dydxUsdxPriceType);\\n        // dydxAmount * dydxPrice = usdxAmount * usdxPrice -> dydxAmount = usdxAmount/dydxPrice\\n        amountOutMin = amountIn * swapAmtOutMinRate / 100 / dydxPrice;\\n    }\\n\\n    function getAllowedMaxRatio() public view returns (uint ratio) {\\n        IInvitation inviteContract = IInvitation(A_Invitation);\\n        IInviteReward inviteRewardContract = IInviteReward(A_InvitReward);\\n        address[] memory children = inviteContract.inviteesOf(msg.sender);\\n        uint childrenTotalAmount;\\n        for (uint i = 0; i < children.length; i++) {\\n            childrenTotalAmount += inviteRewardContract.getLeverageDepositAmt(children[i]);\\n        }\\n        return _calculateMaxLeverageRatio(childrenTotalAmount, ratioPerAmount, systemRatioLimit);\\n    }\\n\\n    function _calculateMaxLeverageRatio(\\n        uint _childrenTotalAmount,\\n        uint _ratioPerAmount,\\n        uint16 _systemRatioLimit\\n    ) private pure returns (uint) {\\n        uint maxRatio = _childrenTotalAmount / _ratioPerAmount;\\n        maxRatio = (maxRatio == 0) ? 1 : maxRatio;\\n        return (maxRatio > _systemRatioLimit) ? _systemRatioLimit : maxRatio;\\n    }\\n\\n    function _getShortAmt(address token, uint amount) private pure returns (uint) {\\n        return amount / ((token == Const.A_USDT) ? Const.MULTIPLIER_6 : Const.MULTIPLIER_18);\\n    }\\n\\n    /**\\n     * @param token USDT or USDX\\n     */\\n    function _symbol(address token) private pure returns(string memory){\\n        return (token == Const.A_USDT) ? \\\"USDT\\\" : \\\"USDX\\\";\\n    }\\n\\n    /**\\n     * @param token USDT or USDX\\n     */\\n    function _decimals(address token) private pure returns(uint){\\n        return (token == Const.A_USDT) ? Const.MULTIPLIER_6 : Const.MULTIPLIER_18;\\n    }\\n\\n    /**\\n     * 'ShortAmt' in the function name refers to the amount without decimals\\n     * Considered rewards amount and system amount limit\\n     */\\n    function getAllowedLeverageShortAmt(address addr) public returns (uint) {\\n        // the user has used all the leverage amount\\n        // if(user[msg.sender].usedLeverageAmt >= sysLeverageShortAmtLimit) return 0;\\n\\n        IInviteReward inviteRewardContract = IInviteReward(A_InvitReward);\\n        uint leverageAmt = inviteRewardContract.getLeverageAmt(addr);\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        uint t100xPrice = oracle.getPrice(\\\"T100X\\\", \\\"USDT\\\", t100xUsdtPriceType);\\n        uint rewardAllowedUSDTShortAmt = leverageAmt * t100xPrice / Const.MULTIPLIER_6;\\n        uint allowedAmt = (rewardAllowedUSDTShortAmt > sysLeverageShortAmtLimit) ? sysLeverageShortAmtLimit : rewardAllowedUSDTShortAmt;\\n        return allowedAmt;\\n    }\\n\\n    function setLeverage100xtFeeRate(uint rate) external onlyRole(OPERATOR) {\\n        leverage100xtFeeRate = rate;\\n    }\\n\\n    function setSystemAddress(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_System = addr;\\n    }\\n\\n    function setBankVaultAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_BankVault = addr;\\n    }\\n\\n    function setInvitationAddr(address addr) external onlyRole(OPERATOR) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_Invitation = addr;\\n    }\\n\\n    function setSwapAmtOutMinRate(uint _val) external onlyRole(OPERATOR) {\\n        require(_val <= 100, \\\"Value must be less than 100\\\");\\n        require(_val >= 50, \\\"Value must be greater than 50\\\");\\n        swapAmtOutMinRate = _val;\\n    }\\n\\n    //TODO set functions for other variables\\n\\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OracleProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\\\";\\nimport \\\"./Const.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ncontract OracleProxy is Ownable, AccessControlEnumerable, IOracle {\\n  bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n\\n  mapping(string => address) public tokenAddressMap;\\n  mapping(string => uint) public tokenDecimalMap;\\n\\n  address[] private oracleContracts;\\n\\n  event SetPrice(string key, uint price);\\n\\n  constructor(\\n    address initialOwner,\\n    address initialAdmin\\n  ) Ownable(initialOwner) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n    _grantRole(OPERATOR, initialOwner);\\n    _grantRole(OPERATOR, initialAdmin);\\n  }\\n\\n  // if this does not work, then use grantDefaultAdmin\\n  function setDefaultAdmin(address addr) external onlyOwner {\\n    if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n      address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n      require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n      _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n    }\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  // only use when setDefaultAdmin does not work\\n  function grantDefaultAdmin(address addr) external onlyOwner {\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  function getPrice(string calldata tokenInSymbol, string calldata tokenOutSymbol, uint oracleType) public override returns (uint){\\n    IOracle oracle = IOracle(oracleContracts[oracleType - 1]);\\n    return oracle.getPrice(tokenInSymbol, tokenOutSymbol, oracleType);\\n  }\\n\\n  /**\\n   * Manual operation: set oracle contracts' addresses after deploying an oracle contract\\n   * address array sequence is important: V1, V2 ...\\n   */\\n  function setOracleContracts(address[] calldata addr) external onlyRole(OPERATOR) {\\n    oracleContracts = addr;\\n  }\\n  /**\\n   * Manual operation: key: \\\"USDT\\\", value: 0x......\\n   */\\n  function setTokenAddressMap(string calldata symbol, address addr) external onlyRole(OPERATOR){\\n    tokenAddressMap[symbol] = addr;\\n  }\\n  /**\\n   * Manual operation: key: \\\"USDT\\\", value: 6\\n   */\\n  function setTokenDecimalMap(string calldata symbol, uint decimals) external onlyRole(OPERATOR){\\n    tokenDecimalMap[symbol] = decimals;\\n  }\\n\\n}\"\r\n    },\r\n    \"contracts/OracleV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ncontract OracleV1 is Ownable, AccessControlEnumerable, IOracle {\\n  bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n  mapping(string => uint) public priceMap;\\n  address A_oracleProxy;\\n\\n  event SetPrice(string key, uint price);\\n\\n  constructor(\\n    address initialOwner,\\n    address initialAdmin,\\n    address a_oracleProxy\\n  ) Ownable(initialOwner) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n    _grantRole(OPERATOR, initialOwner);\\n    _grantRole(OPERATOR, initialAdmin);\\n    A_oracleProxy = a_oracleProxy;\\n  }\\n\\n  // if this does not work, then use grantDefaultAdmin\\n  function setDefaultAdmin(address addr) external onlyOwner {\\n    if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n      address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n      require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n      _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n    }\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  // only use when setDefaultAdmin does not work\\n  function grantDefaultAdmin(address addr) external onlyOwner {\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  function getPrice(string calldata tokenInSymbol, string calldata tokenOutSymbol, uint oracleType) public view override returns (uint){\\n    require(oracleType == 1, \\\"oracle type is invalid\\\");\\n    string memory key = string.concat(tokenInSymbol, \\\"-\\\", tokenOutSymbol);\\n    return priceMap[key];\\n  }\\n\\n  // augment tokenInSymbol=DYDX, tokenOutSymbol=100XT, price=2,05*(10**100XT.decimals()) means (1 DYDX)=(2.05 100XT)\\n  function setPrice(string calldata tokenInSymbol, string calldata tokenOutSymbol, uint price) external onlyRole(OPERATOR){\\n    require(price > 0, \\\"price must be greater than 0\\\");\\n    string memory key = string.concat(tokenInSymbol, \\\"-\\\", tokenOutSymbol);\\n    priceMap[key] = price;\\n    emit SetPrice(key, price);\\n  }\\n\\n  function deletePrice(string calldata tokenInSymbol, string calldata tokenOutSymbol) external onlyRole(OPERATOR){\\n    string memory key = string.concat(tokenInSymbol, \\\"-\\\", tokenOutSymbol);\\n    priceMap[key] = 0;\\n    emit SetPrice(key, 0);\\n  }\\n}\"\r\n    },\r\n    \"contracts/OracleV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\\\";\\nimport \\\"./Const.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\ninterface IOracleProxy {\\n    function tokenAddressMap(string calldata symbol) external view returns (address);\\n    function tokenDecimalMap(string calldata symbol) external view returns (uint);\\n}\\n\\ncontract OracleV2 is Ownable, AccessControlEnumerable, IOracle {\\n  bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n  address A_oracleProxy;\\n\\n  constructor(\\n    address initialOwner,\\n    address initialAdmin,\\n    address a_oracleProxy\\n  ) Ownable(initialOwner) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n    _grantRole(OPERATOR, initialOwner);\\n    _grantRole(OPERATOR, initialAdmin);\\n    A_oracleProxy = a_oracleProxy;\\n  }\\n\\n  // if this does not work, then use grantDefaultAdmin\\n  function setDefaultAdmin(address addr) external onlyOwner {\\n    if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n      address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n      require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n      _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n    }\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  // only use when setDefaultAdmin does not work\\n  function grantDefaultAdmin(address addr) external onlyOwner {\\n    _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n  }\\n\\n  function getPrice(string calldata tokenInSymbol, string calldata tokenOutSymbol, uint oracleType) public override returns (uint){\\n    require(oracleType == 2, \\\"oracle type is invalid\\\");\\n    IOracleProxy oP = IOracleProxy(A_oracleProxy);\\n    \\n    uint ou = getPriceForTokenIn(oP.tokenAddressMap(tokenInSymbol), oP.tokenAddressMap(tokenOutSymbol), 10**oP.tokenDecimalMap(tokenInSymbol));\\n    return ou;\\n  }\\n\\n  function getPriceForTokenIn(\\n      address tokenIn,\\n      address tokenOut,\\n      uint amountIn\\n  ) private returns (uint256) {\\n      uint24 fee = 3000;\\n      IQuoter uniQuoter = IQuoter(Const.A_UNI_QUOTER);\\n      uint amountOut = uniQuoter.quoteExactInputSingle(\\n          tokenIn,\\n          tokenOut,\\n          fee,\\n          amountIn,\\n          0\\n      );\\n      return amountOut;\\n  }\\n}\"\r\n    },\r\n    \"contracts/Savings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n// stake usdx, reward 100xt\\ncontract Savings is Ownable, Pausable, AccessControlEnumerable {\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n    using SafeERC20 for IERC20;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    uint public totalStaked = 0;\\n    address public A_leverage;\\n\\n    // contracts which return 100xt as rewards\\n    EnumerableSet.AddressSet private sStakingContractsSet;\\n\\n    event Lend(address addr, uint amount);\\n    event Withdraw(IERC20 token, address addr, uint amount);\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin\\n        ) Ownable(initialOwner) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // usdx or usdt\\n    function transfer2Leverage(address tokenAddress, uint amount) external {\\n        // only allow leverage contract to call\\n        require(msg.sender == A_leverage, \\\"Unauthorized\\\");\\n        IERC20 token = IERC20(tokenAddress);\\n        token.safeTransfer(A_leverage, amount);\\n        emit Lend(tokenAddress, amount);\\n    }\\n\\n    // usdx, for staking contracts to withdraw/unstake\\n    function withdraw(IERC20 token, address to, uint amount) external {\\n        //only allow several contracts to call!\\n        require(sStakingContains(msg.sender), \\\"Unauthorized\\\");\\n        token.safeTransfer(to, amount);\\n        emit Withdraw(token, to, amount);\\n    }\\n\\n    function addSStakingContract(address addr) public returns (bool) {\\n        return EnumerableSet.add(sStakingContractsSet, addr);\\n    }\\n\\n    function removeSStakingContract(address addr) public returns (bool) {\\n        return EnumerableSet.remove(sStakingContractsSet, addr);\\n    }\\n\\n    function sStakingContains(address addr) private view returns (bool) {\\n        return EnumerableSet.contains(sStakingContractsSet, addr);\\n    }\\n\\n    function listAllSStakingContracts() external view returns (address[] memory) {\\n        uint256 length = sStakingContractsSet.length();\\n        address[] memory addresses = new address[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            addresses[i] = sStakingContractsSet.at(i);\\n        }\\n        return addresses;\\n    }\\n\\n    function setLeverageAddress(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_leverage = addr;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SStakingBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface ISavings {\\n    function withdraw(IERC20 _token, address _to, uint _amount) external;\\n}\\n\\n/**\\n * SStakingBase is short for SavingsStakingBase\\n */\\nabstract contract SStakingBase is IStaking, Ownable, Pausable, AccessControlEnumerable {\\n    bytes32 constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n    // allows you to call the safe methods provided by SafeERC20 on any token that is an instance of IERC20\\n    using SafeERC20 for IERC20;\\n    IERC20 immutable token;\\n    IERC20 immutable rewardToken;\\n\\n    address A_Savings;\\n\\n    uint public totalStaked = 0;\\n    mapping(address => uint) public balanceOf;\\n    // track the block number when an account interacts with the contract\\n    mapping(address => uint) internal lastUpdatedBlockNO;\\n    mapping(address => uint) public claimed;\\n\\n    event Stake(address address_, uint amount);\\n    event Claim(address address_, uint amount);\\n    event Unstake(address address_, uint amount);\\n\\n    constructor(address initialOwner, address initialAdmin, IERC20 token_, IERC20 rewardToken_) \\n        Ownable(initialOwner) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        token = token_;\\n        rewardToken = rewardToken_;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    function stake(uint amount) public virtual whenNotPaused {\\n        require(A_Savings != address(0), \\\"Invalid savings address provided\\\");\\n        claim();\\n        balanceOf[msg.sender] += amount;\\n        lastUpdatedBlockNO[msg.sender] = block.number;\\n        totalStaked += amount;\\n        token.safeTransferFrom(msg.sender, A_Savings, amount);\\n        emit Stake(msg.sender, amount);\\n    }\\n\\n    function rewards(address addr, uint startBlockNO) public view virtual returns (uint);\\n\\n    function claim() internal virtual whenNotPaused {\\n        uint amount = rewards(msg.sender, 0);\\n        rewardToken.safeTransfer(msg.sender, amount);\\n        claimed[msg.sender] += amount;\\n        lastUpdatedBlockNO[msg.sender] = block.number;\\n        emit Claim(msg.sender, amount);\\n    }\\n\\n    function unstake(uint amount) external whenNotPaused {\\n        require(amount > 0, \\\"The amount to withdraw must be greater than zero\\\");\\n        require(balanceOf[msg.sender] >= amount, \\\"Insufficient funds for the account\\\");\\n        require(token.balanceOf(A_Savings) >= amount, \\\"Insufficient funds of Savings contract\\\");\\n        balanceOf[msg.sender] -= amount;\\n        totalStaked -= amount;\\n        claim();\\n        ISavings savingsContract = ISavings(A_Savings);\\n        savingsContract.withdraw(token, msg.sender, amount);\\n        // token.safeTransfer(msg.sender, amount);\\n        emit Unstake(msg.sender, amount);\\n    }\\n\\n    function setSavingsAddress(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_Savings = addr;\\n    }\\n\\n    function getMyClaimed(address addr) public view returns (uint){\\n        return claimed[addr];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SStakingStepAPR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./SStakingBase.sol\\\";\\nimport \\\"./Const.sol\\\";\\n\\n// stake usdx, reward 100xt\\ncontract SStakingStepAPR is SStakingBase {\\n    // allows you to call the safe methods provided by SafeERC20 on any token that is an instance of IERC20\\n    using SafeERC20 for IERC20;\\n\\n    // amount of rewardToken per block per 10*decimals() token\\n    uint public rewardsRate1 = 1;\\n    uint public rewardsRate2 = 1;\\n    uint public rewardsRate3 = 1;\\n    uint public rewardsRate4 = 1;\\n    uint public rewardsRate5 = 1;\\n    uint public rewardsRate6 = 1;\\n    uint public rewardsRate7 = 1;\\n    uint public rewardsRate8 = 1;\\n    uint public rewardsRate9 = 1;\\n    uint public rewardsRate10 = 1;\\n    uint public rewardsRate11 = 1;\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        IERC20 token, \\n        IERC20 rewardToken\\n    ) SStakingBase(initialOwner, initialAdmin, token, rewardToken) {}\\n\\n    function rewards(address addr, uint _startBlockNO) public view override returns (uint) {\\n        uint rewardCalculationStartBlockNO = (_startBlockNO==0) ? lastUpdatedBlockNO[addr] : _startBlockNO;\\n        uint balance = balanceOf[addr];\\n        return balance * getRewardRate(balance) * (block.number - rewardCalculationStartBlockNO);\\n    }\\n\\n    function getRewardRate(uint amount) private view returns (uint) {\\n        uint rate;\\n        uint coins = amount / Const.MULTIPLIER_18;\\n        if(coins > 0 && coins < 1000){\\n            rate = rewardsRate1;\\n        } else if(coins >= 1000 && coins < 3000){\\n            rate = rewardsRate2;\\n        } else if(coins >= 3000 && coins < 5000){\\n            rate = rewardsRate3;\\n        } else if(coins >= 5000 && coins < 7000){\\n            rate = rewardsRate4;\\n        } else if(coins >= 7000 && coins < 9000){\\n            rate = rewardsRate5;\\n        } else if(coins >= 9000 && coins < 11000){\\n            rate = rewardsRate6;\\n        } else if(coins >= 11000 && coins < 13000){\\n            rate = rewardsRate7;\\n        } else if(coins >= 13000 && coins < 15000){\\n            rate = rewardsRate8;\\n        } else if(coins >= 15000 && coins < 17000){\\n            rate = rewardsRate9;\\n        } else if(coins >= 17000 && coins < 20000){\\n            rate = rewardsRate10;\\n        } else if(coins >= 20000 ){\\n            rate = rewardsRate11;\\n        }\\n        return rate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Staking100XT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\n// TODO what if no enough tokens for users to withdraw\\n// TODO admin to set some parameters\\ncontract Staking100XT is IStaking, Ownable, Pausable, AccessControlEnumerable {\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n    // todo: get rid of struct and get rid of getMyClaimed function\\n    struct User{\\n        uint balance;\\n        // keep track of when an account interacts with the contract\\n        uint lastUpdated;\\n        uint claimed;\\n        uint lastWithdrawed;\\n    }\\n    mapping(address => uint) public balanceOf;\\n    // using SafeERC20 for IERC20;\\n    IERC20 public immutable token;\\n    uint public baseRewardRate = 3000; // 30% annual return\\n    // auto increment 100(1%) per month. So annual return would be 30+12=42% after a year\\n    uint public extraRewardRateInterval = 100;\\n    uint public extraRewardRateLimit = 3000; // max extra reward is up to 30% annual return\\n    uint public constant secondsInAYear = 365 days;\\n    uint public constant secondsInAMonth = 30 days;\\n    uint public totalStaked = 0;\\n    mapping(address => User) public user;\\n\\n    event Deposit(address addr_, uint amount_);\\n    event Claim(address addr_, uint amount_);\\n    event Compound(address addr_, uint amount_);\\n    event Withdraw(address addr_, uint amount_);\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        IERC20 token_\\n    ) Ownable(initialOwner) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        token = token_;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // In order to make sure we return the same value whether the total rewards are needed\\n    // internally or externally in the contract, we put the calculation into an internal function.\\n    // The external function then simply calls the internal one, removing the opportunity for a discrepancy.\\n    function totalRewards() external view returns (uint) {\\n        return _totalRewards();\\n    }\\n\\n    // track the number of reward tokens available = total tokens in the contract, minus the total tokens staked.\\n    function _totalRewards() internal view returns (uint) {\\n        return token.balanceOf(address(this)) - totalStaked;\\n    }\\n\\n    function deposit(uint amount_) external whenNotPaused {\\n        _compound();\\n        // need approval in advance\\n        require(token.transferFrom(msg.sender, address(this), amount_), \\\"Transfer failed\\\");\\n        user[msg.sender].balance += amount_;\\n        user[msg.sender].lastUpdated = block.timestamp;\\n        if(user[msg.sender].lastWithdrawed == 0 ){\\n            // set as the first deposit time\\n            user[msg.sender].lastWithdrawed = block.timestamp;\\n        }\\n        totalStaked += amount_;\\n        emit Deposit(msg.sender, amount_);\\n    }\\n\\n    function rewards(address addr_, uint _startTime) external view returns (uint) {\\n        return _rewards(addr_, _startTime);\\n    }\\n\\n    function _rewards(address addr_, uint _startTime) internal view returns (uint) {\\n        uint rewardCalculationStartTime = (_startTime==0) ? user[addr_].lastUpdated : _startTime;\\n        uint rewardRate = baseRewardRate + _getExtraRewardRate(user[addr_].lastWithdrawed);\\n        return\\n            user[addr_].balance * rewardRate * (block.timestamp - rewardCalculationStartTime) / 10000 / secondsInAYear;\\n    }\\n\\n    function claim() external whenNotPaused {\\n        uint amount = _rewards(msg.sender, 0);\\n        require(token.transfer(msg.sender, amount), \\\"Transfer failed\\\");\\n        user[msg.sender].claimed += amount;\\n        user[msg.sender].lastUpdated = block.timestamp;\\n        // TODO do this or not?\\n        // user[msg.sender].lastWithdrawed = block.timestamp;\\n        emit Claim(msg.sender, amount);\\n    }\\n\\n    function compound() external {\\n        _compound();\\n    }\\n\\n    function _compound() internal {\\n        uint amount = _rewards(msg.sender, 0);\\n        // No transfer function called\\n        user[msg.sender].claimed += amount;\\n        user[msg.sender].balance += amount;\\n        totalStaked += amount;\\n        user[msg.sender].lastUpdated = block.timestamp;\\n        emit Compound(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint amount_) external whenNotPaused {\\n        require(amount_ > 0, \\\"The amount to withdraw must be greater than zero\\\");\\n        require(user[msg.sender].balance >= amount_, \\\"Insufficient funds\\\");\\n        _compound();\\n        require(token.transfer(msg.sender, amount_), \\\"Transfer failed\\\");\\n        user[msg.sender].balance -= amount_;\\n        user[msg.sender].lastWithdrawed = block.timestamp;\\n        totalStaked -= amount_;\\n        emit Withdraw(msg.sender, amount_);\\n    }\\n\\n    function _getExtraRewardRate(uint lastWithdrawed_) private view returns (uint) {\\n        uint extraRate = (block.timestamp - lastWithdrawed_) * extraRewardRateInterval / secondsInAMonth;\\n        return (extraRate > extraRewardRateLimit) ? extraRewardRateLimit : extraRate;\\n    }\\n\\n    function getMyClaimed(address addr) public view returns (uint) {\\n        return user[addr].claimed;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/T100X.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\n\\ncontract T100X is ERC20Capped, ERC20Burnable, ERC20Pausable, Ownable, AccessControlEnumerable {\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        uint256 initialCap\\n        )Ownable(initialOwner) ERC20(\\\"100XToken\\\", \\\"100XT\\\") ERC20Capped(initialCap * (10 ** decimals())) {\\n            _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n            _grantRole(OPERATOR, initialOwner);\\n            _grantRole(OPERATOR, initialAdmin);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal override (ERC20Capped, ERC20, ERC20Pausable){\\n        super._update(from, to, value);\\n        if(from == address(0)){\\n            uint256 maxSupply = cap();\\n            uint256 supply = totalSupply();\\n            if(supply > maxSupply){\\n                revert ERC20ExceededCap(supply, maxSupply);\\n            }\\n        }\\n    }\\n\\n    function mint(address to, uint256 amount) public onlyRole(OPERATOR) {\\n        _mint(to, amount);\\n    }\\n\\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/USDXToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\n\\ncontract USDXToken is ERC20Burnable, Ownable, Pausable, AccessControlEnumerable{\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin)\\n        ERC20(\\\"USDXToken\\\", \\\"USDX\\\")\\n        Ownable(initialOwner)\\n    {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if(getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0){\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(currentAdmin != addr, \\\"New admin address is the same as the current one\\\");\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\\n        super._update(from, to, value);\\n    }\\n\\n    function mint(address to, uint256 amount) public onlyRole(OPERATOR) {\\n        _mint(to, amount);\\n    }\\n\\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/X.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\\\";\\nimport \\\"./Const.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract X is Ownable, Pausable, AccessControlEnumerable {\\n    using SafeERC20 for IERC20;\\n    bytes32 public constant OPERATOR = keccak256(\\\"OPERATOR\\\");\\n    ISwapRouter public immutable swapRouter;\\n\\n    address private A_USDX;\\n    address private A_100XT;\\n    address private A_BankVault;\\n    address private A_OracleProxy;\\n\\n    // set the pool fee to 0.3%.\\n    uint16 private poolFee = 3000;\\n\\n    uint depositMinAmt = 10 * Const.MULTIPLIER_6;\\n\\n    // the portion of deposited usdt to swap dydx\\n    uint private swapRate = 100; //100%\\n\\n    uint private usdtSwapLimit = 50000 * Const.MULTIPLIER_6;\\n\\n    // remaining USDT amount waiting for swaping\\n    uint private swapRemainingAmt;\\n\\n    uint private swapAmtOutMinRate = 80; //80%\\n\\n    uint private payDuration100xt = 365 * 2; // 2 years, hard coded\\n\\n    // the system issues max 3000 100xt per day\\n    uint private sysAmt100xtPerDay = 3000 * Const.MULTIPLIER_18;\\n\\n    uint public issuedUSDXAmt;\\n\\n    uint[] private recalculateArr;\\n\\n    uint private dydxUsdtPriceType = 1;\\n    uint private t100xUsdtPriceType = 1;\\n\\n    // for paying 100xt\\n    // TODO unit test init value=0 for these attributes\\n    struct User {\\n        uint t100xAmt;\\n        uint claimingAmtPerHour;\\n        uint startTime;\\n        uint lastUpdated;\\n        uint claimed;\\n        uint recalculateNO;\\n    }\\n    mapping(address => User) public user;\\n\\n    uint userInQueueFor100xt;\\n\\n    error MinDeposit(uint depositAmt, uint minAmt);\\n\\n    event Price(uint indexed price);\\n\\n    constructor(\\n        address initialOwner,\\n        address initialAdmin,\\n        ISwapRouter _swapRouter,\\n        address _a_usdx,\\n        address _a_100xt,\\n        address _a_oracle\\n    ) Ownable(initialOwner) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n        _grantRole(OPERATOR, initialOwner);\\n        _grantRole(OPERATOR, initialAdmin);\\n        swapRouter = _swapRouter;\\n        require(_a_usdx != address(0), \\\"Invalid USDX address\\\");\\n        require(_a_100xt != address(0), \\\"Invalid 100XT address\\\");\\n        A_USDX = _a_usdx;\\n        A_100XT = _a_100xt;\\n        A_OracleProxy = _a_oracle;\\n    }\\n\\n    // if this does not work, then use grantDefaultAdmin\\n    function setDefaultAdmin(address addr) external onlyOwner {\\n        if (getRoleMemberCount(DEFAULT_ADMIN_ROLE) > 0) {\\n            address currentAdmin = getRoleMember(DEFAULT_ADMIN_ROLE, 0);\\n            require(\\n                currentAdmin != addr,\\n                \\\"New admin address is the same as the current one\\\"\\n            );\\n            _revokeRole(DEFAULT_ADMIN_ROLE, currentAdmin);\\n        }\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    // only use when setDefaultAdmin does not work\\n    function grantDefaultAdmin(address addr) external onlyOwner {\\n        _grantRole(DEFAULT_ADMIN_ROLE, addr);\\n    }\\n\\n    /**\\n     * swap a fixed amount of USDT for a maximum possible amount of DYDX; using the USDT/DYDX 0.3% pool\\n     * The calling address must approve this contract to spend at least `amountIn` worth of its USDT for this function to succeed\\n     */\\n    function depositUSDT(uint amountIn) external whenNotPaused returns (uint amountOut) {\\n        if(amountIn < depositMinAmt) revert MinDeposit(amountIn, depositMinAmt);\\n\\n        // Transfer the specified amount of USDT to this contract\\n        TransferHelper.safeTransferFrom(Const.A_USDT, msg.sender, address(this), amountIn);\\n        // Transfer USDX to the user\\n        IERC20 usdx = IERC20(A_USDX);\\n        uint usdxAmount = (amountIn / Const.MULTIPLIER_6) * Const.MULTIPLIER_18;\\n        usdx.safeTransfer(msg.sender, usdxAmount);\\n        issuedUSDXAmt += usdxAmount;\\n\\n        if (swapRate == 0) return 0;\\n\\n        uint newAmountIn = amountIn * swapRate / 100;\\n\\n        //only swap max 50K USDT a time. Remaining will be swapped next time along with others' funds\\n        uint swapAmount = _getSwapAmount(newAmountIn, swapRemainingAmt);\\n\\n        // this is to prevent from swapRemainingAmt being negative\\n        if (swapRemainingAmt < swapAmount - newAmountIn) {\\n            swapRemainingAmt = 0;\\n        } else {\\n            swapRemainingAmt += newAmountIn - swapAmount;\\n        }\\n\\n        // Approve the router to spend USDT.\\n        TransferHelper.safeApprove(Const.A_USDT, address(swapRouter), swapAmount);\\n\\n        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.\\n        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\n            .ExactInputSingleParams({\\n                tokenIn: Const.A_USDT,\\n                tokenOut: Const.A_DYDX,\\n                fee: poolFee,\\n                recipient: A_BankVault,\\n                deadline: block.timestamp,\\n                amountIn: swapAmount,\\n                amountOutMinimum: _getAmountOutMinimum(swapAmount),\\n                sqrtPriceLimitX96: 0\\n            });\\n        return swapRouter.exactInputSingle(params);\\n    }\\n\\n    /**\\n     * @param amount the amount for swaping, after swapRate\\n     * @param remainingAmount the amount remained in the contract, waiting for swaping\\n     */\\n    function _getSwapAmount(uint amount, uint remainingAmount) public view returns (uint swapAmount) {\\n        if (amount > usdtSwapLimit) {\\n            swapAmount = usdtSwapLimit;\\n        } else if (amount + remainingAmount > usdtSwapLimit) {\\n            swapAmount = usdtSwapLimit;\\n        } else {\\n            swapAmount = amount + remainingAmount;\\n        }\\n    }\\n\\n    function _getAmountOutMinimum(uint amountIn) private returns (uint amountOutMin) {\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        uint dydxPrice = oracle.getPrice(\\\"DYDX\\\", \\\"USDT\\\", dydxUsdtPriceType);\\n        // dydxAmount * dydxPrice = usdtAmount * usdtPrice -> dydxAmount = usdtAmount/dydxPrice\\n        amountOutMin = amountIn * swapAmtOutMinRate / 100 / dydxPrice;\\n    }\\n\\n    // assume 1usdx=1usdt\\n    function withdraw(uint usdxAmt) external whenNotPaused {\\n        require(usdxAmt <= issuedUSDXAmt, \\\"Withdrawal amount must be less than issued usdx\\\");\\n        IERC20 usdt = IERC20(Const.A_USDT);\\n        IERC20 dydx = IERC20(Const.A_DYDX);\\n        IERC20 usdx = IERC20(A_USDX);\\n        usdx.safeTransfer(address(this), usdxAmt);\\n        issuedUSDXAmt -= usdxAmt;\\n\\n        // if this contract has usdt, return usdt first\\n        uint usdxWithoutDecimal = usdxAmt / Const.MULTIPLIER_18;\\n        uint contractUSDTAmount = usdt.balanceOf(address(this));\\n        uint usdtWithoutDecimal = contractUSDTAmount / Const.MULTIPLIER_6;\\n        if (contractUSDTAmount > 0) {\\n            // if usdt is enough, only pay usdt back\\n            if (usdtWithoutDecimal >= usdxWithoutDecimal) {\\n                usdt.safeTransfer(msg.sender, usdxWithoutDecimal * Const.MULTIPLIER_6);\\n                return;\\n            }\\n            // contract's usdt is not enough, pay contract's usdt first\\n            usdt.safeTransfer(msg.sender, usdtWithoutDecimal * Const.MULTIPLIER_6);\\n            // remaining usdx amount after paying some usdt\\n            usdxAmt = (usdxWithoutDecimal - usdtWithoutDecimal) * Const.MULTIPLIER_18;\\n        }\\n\\n        // get dydx value\\n        uint currrentContractUSDTAmt = usdt.balanceOf(address(this));\\n        uint sysDYDXAmt = dydx.balanceOf(address(this)) + dydx.balanceOf(A_BankVault);\\n\\n        // Manual Operation: transfer DYDX to this contract from BankVaultX\\n        IOracle oracle = IOracle(A_OracleProxy);\\n        uint dydxPrice = oracle.getPrice(\\\"DYDX\\\", \\\"USDT\\\", dydxUsdtPriceType);\\n        if ((dydxPrice * sysDYDXAmt + currrentContractUSDTAmt) / Const.MULTIPLIER_6 > issuedUSDXAmt / Const.MULTIPLIER_18) {\\n            // calculate the amount of dydx to pay\\n            uint dydx2pay = ((usdxAmt * Const.MULTIPLIER_6) / Const.MULTIPLIER_18) / dydxPrice;\\n            dydx.safeTransfer(msg.sender, dydx2pay);\\n        } else {\\n            // pay dydx\\n            uint dydx2pay = (usdxAmt * sysDYDXAmt) / issuedUSDXAmt;\\n            uint dydx2payDiscount = (dydx2pay * 95) / 100;\\n            dydx.safeTransfer(msg.sender, dydx2payDiscount);\\n\\n            // pay 100xt\\n            // assume we have USDT/100xt pool\\n            uint remainUSDTAmt = (usdxAmt * Const.MULTIPLIER_6) / Const.MULTIPLIER_18 - dydx2payDiscount * dydxPrice;\\n            // uint t100xPrice = getPriceForTokenIn(A_100XT, Const.A_USDT, 1 * Const.MULTIPLIER_18);\\n            uint t100xPrice = oracle.getPrice(\\\"T100X\\\", \\\"USDT\\\", t100xUsdtPriceType);\\n\\n            // merge if there is an existing withdrawal for the same user\\n            if (user[msg.sender].t100xAmt == 0) {\\n                userInQueueFor100xt += 1;\\n            }\\n            user[msg.sender].t100xAmt = remainUSDTAmt / t100xPrice + user[msg.sender].t100xAmt;\\n            user[msg.sender].claimingAmtPerHour = user[msg.sender].t100xAmt / payDuration100xt / 24;\\n            user[msg.sender].startTime = block.timestamp;\\n            user[msg.sender].lastUpdated = block.timestamp;\\n        }\\n    }\\n\\n    function viewClaiming100xt() public view returns (uint) {\\n        uint amount = user[msg.sender].t100xAmt;\\n        if(amount == 0 || userInQueueFor100xt ==0) return 0;\\n\\n        uint amountPerHour = user[msg.sender].claimingAmtPerHour;\\n        amount = _getReCalculateAmount(amount, user[msg.sender].recalculateNO);\\n        amountPerHour = _getReCalculateAmount(amountPerHour, user[msg.sender].recalculateNO);\\n\\n        uint sysAmountPerHour = sysAmt100xtPerDay / userInQueueFor100xt / 24;\\n        uint claimingAmountPerHour = (amountPerHour < sysAmountPerHour)\\n            ? amountPerHour\\n            : sysAmountPerHour;\\n        uint claimingAmount = (claimingAmountPerHour * (block.timestamp - user[msg.sender].lastUpdated)) / 3600;\\n        return (claimingAmount > amount) ? amount : claimingAmount;\\n    }\\n\\n    /**\\n     * Manual Operation: mint 100XT to this contract\\n     */\\n    function claim100xt() external whenNotPaused {\\n        // recalculate\\n        uint recalculateArrLen = recalculateArr.length;\\n        if(user[msg.sender].recalculateNO < recalculateArrLen){\\n            user[msg.sender].t100xAmt = _getReCalculateAmount(user[msg.sender].t100xAmt, user[msg.sender].recalculateNO);\\n            user[msg.sender].claimingAmtPerHour = _getReCalculateAmount(user[msg.sender].claimingAmtPerHour, user[msg.sender].recalculateNO);\\n            user[msg.sender].recalculateNO = recalculateArrLen;\\n        }\\n\\n        IERC20 t100x = IERC20(A_100XT);\\n        uint amount = viewClaiming100xt();\\n        if(user[msg.sender].t100xAmt <= amount){\\n            userInQueueFor100xt = (userInQueueFor100xt >= 1) ? userInQueueFor100xt - 1 : 0;\\n            amount = user[msg.sender].t100xAmt;\\n        }\\n        user[msg.sender].claimed += amount;\\n        user[msg.sender].t100xAmt -= amount;\\n        user[msg.sender].lastUpdated = block.timestamp;\\n        t100x.safeTransfer(msg.sender, amount);\\n    }\\n\\n    function _getReCalculateAmount(uint amount, uint index) private view returns(uint){\\n        uint len = recalculateArr.length;\\n        for(uint i = index; i < len; i++){\\n            amount = amount * recalculateArr[i] / 100;\\n        }\\n        return amount;\\n    }\\n    /**\\n     * When the price of 100xt changes a lot. Admin triggers this to adjust the amount of 100xt that should pay to users\\n     * @param percent 50 means the new 100xt amout to pay to a user is 50% of the original amount\\n     */\\n    function reCalculate100xtClaiming(uint percent) external onlyRole(OPERATOR) {\\n        require(percent < 100, \\\"percent must be less than 100\\\");\\n        recalculateArr.push(percent);\\n    }\\n\\n    /**\\n     * Only used by Admin when recalculateArr is wrong.\\n     */\\n    function setReCalculateArr(uint[] calldata arr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        recalculateArr = arr;\\n    }\\n\\n    function setBankVaultAddr(address addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(addr != address(0), \\\"Invalid address provided\\\");\\n        A_BankVault = addr;\\n    }\\n\\n    function setSwapRate(uint _rate) external onlyRole(OPERATOR) {\\n        require(_rate <= 100, \\\"Value can not exceed 100\\\");\\n        swapRate = _rate;\\n    }\\n\\n    function setPoolFee(uint16 _fee) external onlyRole(OPERATOR) {\\n        require(_fee >= 1000, \\\"Value must be greater than 1000\\\");\\n        require(_fee <= 50000, \\\"Value must be less than 50000\\\");\\n        poolFee = _fee;\\n    }\\n\\n    function setUsdtSwapLimit(uint _val) external onlyRole(OPERATOR) {\\n        require(_val <= 200000 * Const.MULTIPLIER_6, \\\"Value must be less than 200000\\\");\\n        require(_val >= 1000 * Const.MULTIPLIER_6, \\\"Value must be greater than 1000\\\");\\n        usdtSwapLimit = _val;\\n    }\\n\\n    function setSwapAmtOutMinRate(uint _val) external onlyRole(OPERATOR) {\\n        require(_val <= 100, \\\"Value must be less than 100\\\");\\n        require(_val >= 50, \\\"Value must be greater than 50\\\");\\n        swapAmtOutMinRate = _val;\\n    }\\n\\n    function setsysAmt100xtPerDay(uint _val) external onlyRole(OPERATOR) {\\n        require(_val <= 100000 * Const.MULTIPLIER_18, \\\"Value must be less than 100000\\\");\\n        require(_val >= 1000 * Const.MULTIPLIER_18, \\\"Value must be greater than 1000\\\");\\n        sysAmt100xtPerDay = _val;\\n    }\\n\\n    function setDydxUsdtPriceType(uint _val) external onlyRole(OPERATOR) {\\n        dydxUsdtPriceType = _val;\\n    }\\n\\n    function setDepositMinAmt(uint _val) external onlyRole(OPERATOR) {\\n        depositMinAmt = _val;\\n    }\\n\\n    function setT100xUsdtPriceType(uint _val) external onlyRole(OPERATOR) {\\n        t100xUsdtPriceType = _val;\\n    }\\n\\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialAdmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AccountUnregistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InviterUnregistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameAdminAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameInviterAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SelfInvitationNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"invitee\",\"type\":\"address\"}],\"name\":\"AdminInvite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"invitee\",\"type\":\"address\"}],\"name\":\"Invite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"adminSetInviter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvitees\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"grantDefaultAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inviteesOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviterOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rootInviterOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDefaultAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Invitation", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a51304555ebc9c8d498723166ccc669734203a8f000000000000000000000000db8a701f2eee438ed8f790ddc4d640dee5a93511", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}