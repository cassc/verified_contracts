{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC20721T.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IERC20721T.sol\\\";\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ncontract ERC20721T is IERC20721T {\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    struct UserApprovalRef {\\n        mapping(address => uint256) allowance;\\n        mapping(address => bool) approved;\\n    }\\n\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n    uint256 private constant _BITPOS_AUX = 192;\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n    bytes32 private constant _ERC721_TRANSFER_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n    bytes32 private constant _ERC20_TRANSFER_SIGNATURE =\\n        keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"));\\n    bytes32 private constant _ERC20_APPROVAL_SIGNATURE =\\n        keccak256(bytes(\\\"Approval(address,address,uint256)\\\"));\\n\\n    address private _wrapper;\\n    uint256 private _currentIndex;\\n    uint256 private _burnCounter;\\n    uint256 public decimals;\\n    string private _name;\\n    string private _symbol;\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n    mapping(address => uint256) private _packedAddressData;\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n    mapping(address => UserApprovalRef) private _userApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    function _maxSupply() internal view virtual returns (uint256) {\\n        return 1000;\\n    }\\n\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return _maxSupply() + 1;\\n    }\\n\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    function wrapper() public view virtual returns (address) {\\n        return _wrapper;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256) {\\n        return _userApprovals[owner].allowance[spender];\\n    }\\n\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return\\n            (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) &\\n            _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return\\n            (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) &\\n            _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed =\\n            (packed & _BITMASK_AUX_COMPLEMENT) |\\n            (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    function _setWrapper(address w) internal virtual {\\n        _wrapper = w;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view virtual returns (string memory) {\\n        if (!_exists(tokenId)) _revert(URIQueryForNonexistentToken.selector);\\n\\n        string memory baseURI = _baseURI();\\n        return\\n            bytes(baseURI).length != 0\\n                ? string(abi.encodePacked(baseURI, _toString(tokenId)))\\n                : \\\"\\\";\\n    }\\n\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    function _ownershipOf(\\n        uint256 tokenId\\n    ) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    function _ownershipAt(\\n        uint256 index\\n    ) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    function _ownershipIsInitialized(\\n        uint256 index\\n    ) internal view virtual returns (bool) {\\n        return _packedOwnerships[index] != 0;\\n    }\\n\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    function _packedOwnershipOf(\\n        uint256 tokenId\\n    ) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        _revert(OwnerQueryForNonexistentToken.selector);\\n    }\\n\\n    function _unpackedOwnership(\\n        uint256 packed\\n    ) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    function _packOwnershipData(\\n        address owner,\\n        uint256 flags\\n    ) private view returns (uint256 result) {\\n        assembly {\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            result := or(\\n                owner,\\n                or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags)\\n            )\\n        }\\n    }\\n\\n    function _nextInitializedFlag(\\n        uint256 quantity\\n    ) private pure returns (uint256 result) {\\n        assembly {\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    function approve(\\n        address _spender,\\n        uint256 quantityOrTokenId\\n    ) external returns (bool) {\\n        uint256 max = _maxSupply() + 1;\\n        if (quantityOrTokenId > max && quantityOrTokenId <= max * 2) {\\n            _approveERC721(_spender, quantityOrTokenId);\\n        } else {\\n            _approveERC20(msg.sender, _spender, quantityOrTokenId);\\n        }\\n        return true;\\n    }\\n\\n    function _approveERC721(address to, uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSender() != owner)\\n            if (!isApprovedForAll(owner, _msgSender())) {\\n                _revert(ApprovalCallerNotOwnerNorApproved.selector);\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    function _approveERC20(\\n        address _owner,\\n        address _spender,\\n        uint256 _tokens\\n    ) internal {\\n        _userApprovals[_owner].allowance[_spender] = _tokens;\\n        emit ERC20Approval(\\n            _ERC20_APPROVAL_SIGNATURE,\\n            _owner,\\n            _spender,\\n            _tokens\\n        );\\n    }\\n\\n    function getApproved(\\n        uint256 tokenId\\n    ) public view virtual returns (address) {\\n        if (!_exists(tokenId))\\n            _revert(ApprovalQueryForNonexistentToken.selector);\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _userApprovals[_msgSender()].approved[operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) public view virtual returns (bool) {\\n        return _userApprovals[owner].approved[operator] || _wrapper == operator;\\n    }\\n\\n    function tokensOfOwner(\\n        address owner\\n    ) public view returns (uint256[] memory) {\\n        uint256 start = _startTokenId();\\n        uint256 stop = _nextTokenId();\\n        uint256[] memory tokenIds;\\n        if (start != stop) tokenIds = _tokensOfOwnerIn(owner, start, stop);\\n        return tokenIds;\\n    }\\n\\n    function _tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) private view returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) _revert(InvalidQueryRange.selector);\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            uint256 stopLimit = _nextTokenId();\\n            if (stop >= stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256[] memory tokenIds;\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            bool startLtStop = start < stop;\\n            assembly {\\n                tokenIdsMaxLength := mul(tokenIdsMaxLength, startLtStop)\\n            }\\n            if (tokenIdsMaxLength != 0) {\\n                if (stop - start <= tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = stop - start;\\n                }\\n                assembly {\\n                    tokenIds := mload(0x40)\\n                    mstore(\\n                        0x40,\\n                        add(tokenIds, shl(5, add(tokenIdsMaxLength, 1)))\\n                    )\\n                }\\n\\n                TokenOwnership memory ownership = _explicitOwnershipOf(start);\\n                address currOwnershipAddr;\\n\\n                if (!ownership.burned) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                uint256 tokenIdsIdx;\\n                do {\\n                    ownership = _ownershipAt(start);\\n                    assembly {\\n                        switch mload(add(ownership, 0x40))\\n                        case 0 {\\n                            if mload(ownership) {\\n                                currOwnershipAddr := mload(ownership)\\n                            }\\n                            if iszero(shl(96, xor(currOwnershipAddr, owner))) {\\n                                tokenIdsIdx := add(tokenIdsIdx, 1)\\n                                mstore(\\n                                    add(tokenIds, shl(5, tokenIdsIdx)),\\n                                    start\\n                                )\\n                            }\\n                        }\\n                        default {\\n                            currOwnershipAddr := 0\\n                        }\\n                        start := add(start, 1)\\n                    }\\n                } while (!(start == stop || tokenIdsIdx == tokenIdsMaxLength));\\n                assembly {\\n                    mstore(tokenIds, tokenIdsIdx)\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    function _explicitOwnershipOf(\\n        uint256 tokenId\\n    ) internal view virtual returns (TokenOwnership memory ownership) {\\n        unchecked {\\n            if (tokenId >= _startTokenId()) {\\n                if (tokenId < _nextTokenId()) {\\n                    // If the `tokenId` is within bounds,\\n                    // scan backwards for the initialized ownership slot.\\n                    while (!_ownershipIsInitialized(tokenId)) --tokenId;\\n                    return _ownershipAt(tokenId);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex &&\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0;\\n    }\\n\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) internal view virtual returns (bool result) {\\n        assembly {\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    function _getApprovedSlotAndAddress(\\n        uint256 tokenId\\n    )\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint256 quantity\\n    ) public payable virtual returns (bool) {\\n        _transfer(msg.sender, to, quantity);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 quantity) internal {\\n        uint256[] memory tokens = tokensOfOwner(from);\\n\\n        if (tokens.length < quantity) _revert(InsufficientBalance.selector);\\n\\n        batchTransfer(\\n            from,\\n            to,\\n            tokens.length > quantity\\n                ? _getLimitedArray(tokens, quantity)\\n                : tokens\\n        );\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 quantityOrTokenId\\n    ) public payable virtual returns (bool) {\\n        uint256 max = _maxSupply();\\n        if (quantityOrTokenId <= max) {\\n            _transfer(from, to, quantityOrTokenId);\\n        } else if (quantityOrTokenId <= max * 2) {\\n            _transferFrom(from, to, quantityOrTokenId);\\n            emit ERC20Transfer(_ERC20_TRANSFER_SIGNATURE, from, to, 1);\\n        } else {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from)\\n            _revert(TransferFromIncorrectOwner.selector);\\n\\n        (\\n            uint256 approvedAddressSlot,\\n            address approvedAddress\\n        ) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSender()))\\n            if (!isApprovedForAll(from, _msgSender()))\\n                if (_userApprovals[from].allowance[msg.sender] < 1)\\n                    _revert(TransferCallerNotOwnerNorApproved.selector);\\n\\n        if (to == address(0)) _revert(TransferToZeroAddress.selector);\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        assembly {\\n            if approvedAddress {\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        unchecked {\\n            --_packedAddressData[from];\\n            ++_packedAddressData[to];\\n\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED |\\n                    _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    if (nextTokenId != _currentIndex) {\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (_userApprovals[from].allowance[msg.sender] > 0) {\\n            _userApprovals[from].allowance[msg.sender]--;\\n        }\\n\\n        if (from == _wrapper) {\\n            emit Locked(tokenId);\\n            emit MetadataUpdate(tokenId);\\n        } else if (to == _wrapper) {\\n            emit Unlocked(tokenId);\\n            emit MetadataUpdate(tokenId);\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    function batchTransfer(\\n        address from,\\n        address to,\\n        uint256[] memory tokenIds\\n    ) public {\\n        emit ERC20Transfer(\\n            _ERC20_TRANSFER_SIGNATURE,\\n            from,\\n            to,\\n            tokenIds.length\\n        );\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            _transferFrom(from, to, tokenIds[i]);\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual {\\n        emit ERC20Transfer(_ERC20_TRANSFER_SIGNATURE, from, to, 1);\\n        _transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\\n            }\\n    }\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try\\n            IERC721Receiver(to).onERC721Received(\\n                _msgSender(),\\n                from,\\n                tokenId,\\n                _data\\n            )\\n        returns (bytes4 retval) {\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        unchecked {\\n            _packedAddressData[to] +=\\n                quantity *\\n                ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) |\\n                    _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            assembly {\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                log4(\\n                    0,\\n                    0,\\n                    _ERC721_TRANSFER_SIGNATURE,\\n                    0,\\n                    toMasked,\\n                    startTokenId\\n                )\\n\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    log4(0, 0, _ERC721_TRANSFER_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n\\n            emit ERC20Transfer(\\n                _ERC20_TRANSFER_SIGNATURE,\\n                address(0),\\n                to,\\n                quantity\\n            );\\n\\n            if (toMasked == 0) _revert(MintToZeroAddress.selector);\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) _revert(MintToZeroAddress.selector);\\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT)\\n            _revert(MintERC2309QuantityExceedsLimit.selector);\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        unchecked {\\n            _packedAddressData[to] +=\\n                quantity *\\n                ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) |\\n                    _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(\\n                startTokenId,\\n                startTokenId + quantity - 1,\\n                address(0),\\n                to\\n            );\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (\\n                        !_checkContractOnERC721Received(\\n                            address(0),\\n                            to,\\n                            index++,\\n                            _data\\n                        )\\n                    ) {\\n                        _revert(\\n                            TransferToNonERC721ReceiverImplementer.selector\\n                        );\\n                    }\\n                } while (index < end);\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, \\\"\\\");\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (\\n            uint256 approvedAddressSlot,\\n            address approvedAddress\\n        ) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSender()))\\n                if (!isApprovedForAll(from, _msgSender()))\\n                    _revert(TransferCallerNotOwnerNorApproved.selector);\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        assembly {\\n            if approvedAddress {\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        unchecked {\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) |\\n                    _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    if (nextTokenId != _currentIndex) {\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit ERC20Transfer(_ERC20_TRANSFER_SIGNATURE, from, address(0), 1);\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    function _getLimitedArray(\\n        uint256[] memory originalArray,\\n        uint256 length\\n    ) internal pure returns (uint256[] memory) {\\n        if (length > originalArray.length)\\n            _revert(InvalidArrayOperation.selector);\\n        uint256[] memory limitedArray = new uint256[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            limitedArray[i] = originalArray[i];\\n        }\\n        return limitedArray;\\n    }\\n\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);\\n        uint256 extraDataCasted;\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed =\\n            (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) |\\n            (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _toString(\\n        uint256 value\\n    ) internal pure virtual returns (string memory str) {\\n        assembly {\\n            let m := add(mload(0x40), 0xa0)\\n            mstore(0x40, m)\\n            str := sub(m, 0x20)\\n            mstore(str, 0)\\n\\n            let end := str\\n\\n            for {\\n                let temp := value\\n            } 1 {\\n\\n            } {\\n                str := sub(str, 1)\\n                mstore8(str, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) {\\n                    break\\n                }\\n            }\\n\\n            let length := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, length)\\n        }\\n    }\\n\\n    function _revert(bytes4 errorSelector) internal pure {\\n        assembly {\\n            mstore(0x00, errorSelector)\\n            revert(0x00, 0x04)\\n        }\\n    }\\n}\\n\\ncontract ERC20721TWrapper is IERC20721TWrapper {\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    IERC20721T public immutable base;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _baseContract\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        base = IERC20721T(_baseContract);\\n    }\\n\\n    function wrappedTokenPool() public view returns (uint256[] memory) {\\n        return base.tokensOfOwner(address(this));\\n    }\\n\\n    function wrap(uint256 quantity) public payable virtual {\\n        uint256[] memory tokens = base.tokensOfOwner(msg.sender);\\n        if (tokens.length < quantity) _revert(InsufficientNFTBalance.selector);\\n        base.batchTransfer(\\n            msg.sender,\\n            address(this),\\n            _getLimitedArray(tokens, quantity)\\n        );\\n        _mint(msg.sender, quantity * 10 ** decimals());\\n        emit Wrap(msg.sender, quantity);\\n    }\\n\\n    function wrap(uint256[] calldata tokenIds) public payable virtual {\\n        base.batchTransfer(msg.sender, address(this), tokenIds);\\n        _mint(msg.sender, tokenIds.length * 10 ** decimals());\\n        emit Wrap(msg.sender, tokenIds.length);\\n    }\\n\\n    function unwrap(uint256 quantity) public payable virtual {\\n        base.transfer(msg.sender, quantity);\\n        _burn(msg.sender, quantity * 10 ** decimals());\\n        emit Unwrap(msg.sender, quantity);\\n    }\\n\\n    function unwrap(uint256[] calldata tokenIds) public payable virtual {\\n        base.batchTransfer(address(this), msg.sender, tokenIds);\\n        _burn(msg.sender, tokenIds.length * 10 ** decimals());\\n        emit Unwrap(msg.sender, tokenIds.length);\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        bool emitEvent\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _getLimitedArray(\\n        uint256[] memory originalArray,\\n        uint256 length\\n    ) internal pure returns (uint256[] memory) {\\n        if (length > originalArray.length)\\n            _revert(InvalidArrayOperation.selector);\\n        uint256[] memory limitedArray = new uint256[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            limitedArray[i] = originalArray[i];\\n        }\\n        return limitedArray;\\n    }\\n\\n    function _revert(bytes4 errorSelector) internal pure {\\n        assembly {\\n            mstore(0x00, errorSelector)\\n            revert(0x00, 0x04)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20721T.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IERC20721T {\\n    struct TokenOwnership {\\n        address addr;\\n        uint64 startTimestamp;\\n        bool burned;\\n        uint24 extraData;\\n    }\\n\\n    error ApprovalCallerNotOwnerNorApproved();\\n    error ApprovalQueryForNonexistentToken();\\n    error BalanceQueryForZeroAddress();\\n    error MintToZeroAddress();\\n    error MintZeroQuantity();\\n    error OwnerQueryForNonexistentToken();\\n    error TransferCallerNotOwnerNorApproved();\\n    error TransferFromIncorrectOwner();\\n    error TransferToNonERC721ReceiverImplementer();\\n    error TransferToZeroAddress();\\n    error URIQueryForNonexistentToken();\\n    error MintERC2309QuantityExceedsLimit();\\n    error OwnershipNotInitializedForExtraData();\\n    error InvalidQueryRange();\\n    error InsufficientBalance();\\n    error InvalidArrayOperation();\\n\\n    event ERC20Transfer(\\n        bytes32 indexed topic0,\\n        address indexed from,\\n        address indexed to,\\n        uint256 tokens\\n    ) anonymous;\\n    event ERC20Approval(\\n        bytes32 indexed topic0,\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 tokens\\n    ) anonymous;\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n    event ConsecutiveTransfer(\\n        uint256 indexed fromTokenId,\\n        uint256 toTokenId,\\n        address indexed from,\\n        address indexed to\\n    );\\n    event Locked(uint256 tokenId);\\n    event Unlocked(uint256 tokenId);\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    function decimals() external view returns (uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function approve(\\n        address _spender,\\n        uint256 quantityOrTokenId\\n    ) external returns (bool);\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    function tokensOfOwner(\\n        address owner\\n    ) external view returns (uint256[] memory);\\n\\n    function transfer(\\n        address to,\\n        uint256 quantity\\n    ) external payable returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 quantityOrTokenId\\n    ) external payable returns (bool);\\n\\n    function batchTransfer(\\n        address from,\\n        address to,\\n        uint256[] memory tokenIds\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) external payable;\\n\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC20721TWrapper {\\n    error ERC20InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed\\n    );\\n    error ERC20InvalidSender(address sender);\\n    error ERC20InvalidReceiver(address receiver);\\n    error ERC20InsufficientAllowance(\\n        address spender,\\n        uint256 allowance,\\n        uint256 needed\\n    );\\n    error ERC20InvalidApprover(address approver);\\n    error ERC20InvalidSpender(address spender);\\n    error InvalidArrayOperation();\\n    error InsufficientNFTBalance();\\n\\n    event Wrap(address account, uint256 quantity);\\n    event Unwrap(address account, uint256 quantity);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function base() external view returns (IERC20721T);\\n\\n    function wrappedTokenPool() external view returns (uint256[] memory);\\n\\n    function wrap(uint256 quantity) external payable;\\n\\n    function wrap(uint256[] calldata tokenIds) external payable;\\n\\n    function unwrap(uint256 quantity) external payable;\\n\\n    function unwrap(uint256[] calldata tokenIds) external payable;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/TekomonWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {ERC20721TWrapper} from \\\"./ERC20721T.sol\\\";\\n\\ncontract TekomonWrapper is ERC20721TWrapper {\\n    constructor(\\n        address base\\n    ) ERC20721TWrapper(\\\"Wrapped Tekomon\\\", \\\"wTEKOMON\\\", base) {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNFTBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"Unwrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"Wrap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"contract IERC20721T\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedTokenPool\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TekomonWrapper", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006e9149150171deba46b1e777f573cebea8c56cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}