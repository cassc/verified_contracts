{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Autolend/Manager/LendManagerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title MetaLend's manager error interface\\n * @author MetaLend\\n * @notice defines the errors for reporting during reverts\\n * @dev use this with proxy and implementation to report errors\\n */\\ninterface LendManagerErrorInterface {\\n    /**\\n     * @notice Thrown when guarded function is called by non admin address\\n     * @param caller address of the invalid caller\\n     */\\n    error ErrCallerNotAdmin(address caller);\\n\\n    /**\\n     * @notice Thrown when trying to set implementation of mediator to address which is not mediator\\n     * @param implementation the address of the invalid implementation\\n     */\\n    error ErrImplementationNotLendMediator(address implementation);\\n\\n    /**\\n     * @notice Thrown when input param is an invalid number (e.g. does not fit constraints)\\n     * @param num the invalid number\\n     */\\n    error ErrInvalidNumber(uint256 num);\\n\\n    /**\\n     * @notice Thrown when input param is an invalid address (such as address(0))\\n     * @param addr the invalid address\\n     */\\n    error ErrInvalidAddress(address addr);\\n\\n    /**\\n     * @notice Thrown when user tries to create a mediator and it already exists\\n     * @param user the user with existing mediator\\n     * @param mediator the existing mediator address\\n     */\\n    error ErrMediatorExists(address user, address mediator);\\n}\\n\\n/**\\n * @title MetaLend's manager event interface\\n * @author MetaLend\\n * @notice defines the events emitted during interaction\\n * @dev use this with proxy and implementation to emit events\\n */\\ninterface LendManagerEventInterface {\\n    /**\\n     * @notice emitted when a new mediator is created\\n     * @param user address of the account which creates the new mediator contract\\n     * @param mediator address of the mediator contract\\n     */\\n    event NewLendMediator(address indexed user, address indexed mediator);\\n    /**\\n     * @notice emitted when a global mediator implementation changes\\n     * @param previous the previous implementation address\\n     * @param next the new implementation address\\n     */\\n    event NewLendMediatorImplementation(address indexed previous, address indexed next);\\n\\n    /**\\n     * @notice emitted when a royalties percentage changes\\n     * @param previous the previous percentage value\\n     * @param next the new percentage value\\n     */\\n    event NewRoyaltiesPercentage(uint256 indexed previous, uint256 indexed next);\\n\\n    /**\\n     * @notice emitted when a new royalties receiver is set\\n     * @param previous the previous receiver\\n     * @param next the new receiver\\n     */\\n    event NewRoyaltiesReceiver(address indexed previous, address indexed next);\\n\\n    /**\\n     * @notice emitted when a new offer signer is set\\n     * @param previous the previous offer signer\\n     * @param next the new offer signer\\n     */\\n    event NewOfferSigner(address indexed previous, address indexed next);\\n}\\n\\n/**\\n * @title MetaLend's manager function interface\\n * @author MetaLend\\n * @notice defines the functions usable in manager contracts\\n * @dev use this with implementation contract to override functions\\n */\\ninterface LendManagerFunctionInterface {\\n    /**\\n     * @notice denominator to calculate percentage\\n     * @dev use this to calculate percentages\\n     * @return uint256 10000\\n     */\\n    function feeDenominator() external pure returns (uint256);\\n\\n    /**\\n     * @notice creates a new mediator for user\\n     * @dev reverts if mediator already exists for given address\\n     */\\n    function createLendMediator() external;\\n\\n    /**\\n     * @notice sets the new value for royalties percentage\\n     * @dev called only by MetaLend admin\\n     *  100 = 1%, based on {feeDenominator}\\n     * @param newPercentage the new percentage for royalties\\n     */\\n    function setRoyaltiesPercentage(uint256 newPercentage) external;\\n\\n    /**\\n     * @notice sets the new royalties receiver\\n     * @dev called only by MetaLend admin\\n     * @param newReceiver address of the new receiver\\n     */\\n    function setRoyaltiesReceiver(address payable newReceiver) external;\\n\\n    /**\\n     * @notice sets the new implementation for all mediator contracts\\n     * @dev called only by MetaLend admin\\n     * @param newImplementation address of the new implementation contract\\n     */\\n    function setLendMediatorImplementation(address newImplementation) external;\\n\\n    /**\\n     * @notice sets the new address of the signer of offers\\n     * @dev called only by MetaLend admin\\n     * @param newSigner address of the new signer of offers\\n     */\\n    function setOfferSigner(address newSigner) external;\\n\\n    /**\\n     * @notice returns a value modified by royalties precentage\\n     * @param value the uint256 value to modify\\n     * @return uint256 the result\\n     */\\n    function getValueByRoyaltiesPercentage(uint256 value) external view returns (uint256);\\n}\\n\\n/**\\n * @title MetaLend's manager proxy interface\\n * @author MetaLend\\n * @notice defines setImplementation proxy function and event and error\\n * @dev use this interface with manager proxy\\n */\\ninterface LendManagerProxyInterface {\\n    /**\\n     * @notice Thrown when guarded function is called by non admin address\\n     * @param caller address of the invalid caller\\n     */\\n    error ErrCallerNotAdmin(address caller);\\n\\n    /**\\n     * @notice Thrown when input param is an invalid address (such as address(0))\\n     * @param addr the invalid address\\n     */\\n    error ErrInvalidAddress(address addr);\\n\\n    /**\\n     * @notice Thrown when trying to set implementation of manager to address which is not manager\\n     * @param implementation the address of the invalid implementation\\n     */\\n    error ErrImplementationNotLendManager(address implementation);\\n\\n    /**\\n     * @notice Emitted when implementation is changed\\n     * @param previous address of the old implementation contract\\n     * @param next address of the new implementation contract\\n     */\\n    event NewImplementation(address indexed previous, address indexed next);\\n\\n    /**\\n     * @notice emitted when an admin is changed\\n     * @param previous the previous admin\\n     * @param next the new admin\\n     */\\n    event NewAdmin(address indexed previous, address indexed next);\\n\\n    /**\\n     * @notice sets the new implementation for the proxy contract\\n     * @dev should be available to be called only under specific cirmustances (such as an admin account)\\n     * @param newImplementation the address of the new implementation contract\\n     */\\n    function setImplementation(address newImplementation) external;\\n\\n    /**\\n     * @notice sets the new admin\\n     * @dev called only by MetaLend admin\\n     * @param newAdmin the new admin of the protocol\\n     */\\n    function setAdmin(address newAdmin) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Autolend/Manager/LendManagerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Proxy} from \\\"../../lib/Proxy/Proxy.sol\\\";\\nimport {LendManagerProxyInterface} from \\\"./LendManagerInterface.sol\\\";\\nimport {LendManagerProxyStorage} from \\\"./LendManagerStorage.sol\\\";\\nimport {DetectContract} from \\\"../../lib/utils/DetectContract.sol\\\";\\n\\n/**\\n * @title MetaLend's LendManagerProxy Contract\\n * @author MetaLend\\n * @notice The main manager contract\\n * @dev Proxies to implementation contract\\n */\\ncontract LendManagerProxy is Proxy, LendManagerProxyInterface, LendManagerProxyStorage {\\n    /**\\n     * @notice Construct a new staking manager\\n     * @param newImplementation The address of the implementation the contract delegates to\\n     */\\n    constructor(address newImplementation) {\\n        if (!DetectContract.isExistingContract(newImplementation)) {\\n            revert ErrImplementationNotLendManager(newImplementation);\\n        }\\n        try LendManagerProxyStorage(newImplementation).IS_LEND_MANAGER() returns (bool isLendManager) {\\n            if (!isLendManager) {\\n                revert ErrImplementationNotLendManager(newImplementation);\\n            }\\n        } catch {\\n            revert ErrImplementationNotLendManager(newImplementation);\\n        }\\n        implementation = newImplementation;\\n        admin = msg.sender;\\n        emit NewImplementation(address(0), newImplementation);\\n        emit NewAdmin(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc LendManagerProxyInterface\\n     */\\n    function setImplementation(address newImplementation) external override {\\n        if (msg.sender != admin) revert ErrCallerNotAdmin(msg.sender);\\n        if (!DetectContract.isExistingContract(newImplementation)) {\\n            revert ErrImplementationNotLendManager(newImplementation);\\n        }\\n        try LendManagerProxyStorage(newImplementation).IS_LEND_MANAGER() returns (bool isLendManager) {\\n            if (!isLendManager) {\\n                revert ErrImplementationNotLendManager(newImplementation);\\n            }\\n        } catch {\\n            revert ErrImplementationNotLendManager(newImplementation);\\n        }\\n        emit NewImplementation(implementation, newImplementation);\\n        implementation = newImplementation;\\n    }\\n\\n    /**\\n     * @inheritdoc LendManagerProxyInterface\\n     */\\n    function setAdmin(address newAdmin) external override {\\n        if (msg.sender != admin) revert ErrCallerNotAdmin(msg.sender);\\n        if (newAdmin == address(0)) revert ErrInvalidAddress(newAdmin);\\n        emit NewAdmin(admin, newAdmin);\\n        admin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev This function returns the current implementation contract\\n     * @return address of the implementation contract\\n     */\\n    function _implementation() internal view override returns (address) {\\n        return implementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Autolend/Manager/LendManagerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title MetaLend's Lend Manager proxy storage contract\\n * @author MetaLend\\n * @notice defines storage layout for proxy contract\\n * @dev this should be inherited by `LendManager` so that implementation and proxy have same layouts\\n */\\nabstract contract LendManagerProxyStorage {\\n    /// @notice Indicator that this is a LendManager contract (for inspection)\\n    /// @return bool true this is lend manager\\n    bool public constant IS_LEND_MANAGER = true;\\n\\n    /// @notice implementaiton for proxy\\n    /// @return address of the implementation manager contract\\n    address public implementation;\\n\\n    /// @notice MetaLend admin\\n    /// @return address of the MetaLend admin for this manager\\n    address public admin;\\n}\\n\\n/**\\n * @title MetaLend's Lend Manager storage contract\\n * @author MetaLend\\n * @notice defines storage layout for manager contracts\\n * @dev use for both proxy and implementation contracts\\n */\\nabstract contract LendManagerStorage {\\n    /// @notice global implementation for all mediator contracts\\n    /// @return address of the mediator implementation contract\\n    address public lendMediatorImplementation;\\n\\n    /// @notice signer of offers\\n    /// @return address of the offer signer\\n    address public offerSigner;\\n\\n    /// @notice if royalties are implemented, this is the receiver\\n    /// @return address of the royalties receiver\\n    address payable public royaltiesReceiver;\\n\\n    /// @notice scale 0 <=> 10000, 1% = 100\\n    /// @return uint256 the percentage\\n    uint256 public royaltiesPercentage;\\n\\n    /// @notice mapping from user address to own userLendMediator\\n    /// @return address of the mediator contract for given address of the user\\n    mapping(address => address) public userLendMediator;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/utils/DetectContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title MetaLend's DetectContract utility\\n * @author MetaLend\\n * @notice Contains function to detect if address is a contract\\n * @dev Only works for already deployed contracts\\n */\\nlibrary DetectContract {\\n    /**\\n     * @notice function to detect if address is existing contract (already created)\\n     * @dev used for checking if caller is contract\\n     * @param addr the address of the account to check\\n     * @return bool if address is contract\\n     */\\n    function isExistingContract(address addr) internal view returns (bool) {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(addr)\\n        }\\n        if (contractSize == 0) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ErrCallerNotAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ErrImplementationNotLendManager\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ErrInvalidAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"IS_LEND_MANAGER\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LendManagerProxy", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000c402cfef0b9aaf913e574cc557d144f98a1d3ea4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xc402cfef0b9aaf913e574cc557d144f98a1d3ea4", "SwarmSource": "none"}