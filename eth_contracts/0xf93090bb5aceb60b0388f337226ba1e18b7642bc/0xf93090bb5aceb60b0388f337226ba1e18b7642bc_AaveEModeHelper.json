{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/providers/AaveEModeHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\n/**\\n * @title AaveEModeHelper\\n *\\n * @author Fujidao Labs\\n *\\n * @notice Helper contract that aids to determine config Ids if a collateral\\n * debt pair is eligible for Aave-v3 efficiency mode (e-mode).\\n *\\n * @dev This helper contract needs to be set-up.\\n * To find the existing emode configuration Ids use\\n * query schema:\\n * {\\n *  emodeCategories{\\n *    id\\n *      label\\n *   }\\n * }\\n *\\n * Refer to each chain subgraphs site at:\\n * https://github.com/aave/protocol-subgraphs#production-networks\\n */\\n\\nimport {IV3Pool} from \\\"../interfaces/aaveV3/IV3Pool.sol\\\";\\nimport {SystemAccessControl, IChief} from \\\"../access/SystemAccessControl.sol\\\";\\n\\ncontract AaveEModeHelper is SystemAccessControl {\\n  // Events\\n  event EmodeConfigSet(address indexed asset, address indexed debt, uint8 configId);\\n\\n  // Custom errors\\n  error AaveEModeHelper_constructor_addressZero();\\n  error AaveEModeHelper_setEModeConfig_arrayDiscrepancy();\\n\\n  // collateral asset => debt asset => configId\\n  mapping(address => mapping(address => uint8)) internal _eModeConfigIds;\\n\\n  constructor(address chief_) {\\n    if (chief_ == address(0)) revert AaveEModeHelper_constructor_addressZero();\\n    __SystemAccessControl_init(chief_);\\n  }\\n\\n  /**\\n   * @notice Returns de config Id if any for asset-debt pair in AaveV3 pool.\\n   * It none, returns zero.\\n   *\\n   * @param asset erc-20 address of collateral\\n   * @param debt erc-20 address of debt asset\\n   */\\n  function getEModeConfigIds(address asset, address debt) external view returns (uint8 id) {\\n    return _eModeConfigIds[asset][debt];\\n  }\\n\\n  /**\\n   * @notice Sets the configIds for an array of `assets` and `debts`\\n   *\\n   * @param assets erc-20 address array to set e-mode config\\n   * @param debts erc-20 address array corresponding asset in mapping\\n   * @param configIds from aaveV3 (refer to this contract title block)\\n   */\\n  function setEModeConfig(\\n    address[] calldata assets,\\n    address[] calldata debts,\\n    uint8[] calldata configIds\\n  )\\n    external\\n    onlyTimelock\\n  {\\n    uint256 len = assets.length;\\n    if (len != debts.length || len != configIds.length) {\\n      revert AaveEModeHelper_setEModeConfig_arrayDiscrepancy();\\n    }\\n\\n    for (uint256 i = 0; i < len;) {\\n      if (configIds[i] != 0 && assets[i] != address(0) && debts[i] != address(0)) {\\n        _eModeConfigIds[assets[i]][debts[i]] = configIds[i];\\n\\n        emit EmodeConfigSet(assets[i], debts[i], configIds[i]);\\n      }\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/aaveV3/IV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IV3Pool\\n *\\n * @author Aave\\n *\\n * @notice Defines the interface for AaveV3 main\\n * pool contract.\\n */\\ninterface IV3Pool {\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60: asset is paused\\n    //bit 61: borrowing in isolation mode is enabled\\n    //bit 62-63: reserved\\n    //bit 64-79: reserve factor\\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n    //bit 152-167 liquidation protocol fee\\n    //bit 168-175 eMode category\\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n    //bit 252-255 unused\\n    uint256 data;\\n  }\\n\\n  struct ReserveData {\\n    // Stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    // The liquidity index. Expressed in ray.\\n    uint128 liquidityIndex;\\n    // The current supply rate. Expressed in ray.\\n    uint128 currentLiquidityRate;\\n    // Variable borrow index. Expressed in ray.\\n    uint128 variableBorrowIndex;\\n    // The current variable borrow rate. Expressed in ray.\\n    uint128 currentVariableBorrowRate;\\n    // The current stable borrow rate. Expressed in ray.\\n    uint128 currentStableBorrowRate;\\n    // Timestamp of last update.\\n    uint40 lastUpdateTimestamp;\\n    // The id of the reserve. Represents the position in the list of the active reserves.\\n    uint16 id;\\n    // aToken address.\\n    address aTokenAddress;\\n    // StableDebtToken address.\\n    address stableDebtTokenAddress;\\n    // VariableDebtToken address.\\n    address variableDebtTokenAddress;\\n    // Address of the interest rate strategy.\\n    address interestRateStrategyAddress;\\n    // The current treasury balance, scaled.\\n    uint128 accruedToTreasury;\\n    // The outstanding unbacked aTokens minted through the bridging feature.\\n    uint128 unbacked;\\n    // The outstanding debt borrowed against this asset in isolation mode.\\n    uint128 isolationModeTotalDebt;\\n  }\\n\\n  /**\\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n\\n  /**\\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to The address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   */\\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\\n\\n  /**\\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   */\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referralCode,\\n    address onBehalfOf\\n  )\\n    external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @return The final amount repaid\\n   */\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    address onBehalfOf\\n  )\\n    external\\n    returns (uint256);\\n\\n  /**\\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\\n   * @param asset The address of the underlying asset supplied\\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\\n   */\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n   * into consideration. For further details please visit https://docs.aave.com/developers/\\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\n   * @param asset The address of the asset being flash-borrowed\\n   * @param amount The amount of the asset being flash-borrowed\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function flashLoanSimple(\\n    address receiverAddress,\\n    address asset,\\n    uint256 amount,\\n    bytes calldata params,\\n    uint16 referralCode\\n  )\\n    external;\\n\\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state and configuration data of the reserve\\n   */\\n  function getReserveData(address asset) external view returns (ReserveData memory);\\n\\n  /**\\n   * @notice Allows a user to use the protocol in eMode\\n   * @param categoryId The id of the category\\n   */\\n  function setUserEMode(uint8 categoryId) external;\\n\\n  /**\\n   * @notice Returns the eMode the user is using\\n   * @param user The address of the user\\n   * @return The eMode id\\n   */\\n  function getUserEMode(address user) external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/access/SystemAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\n/**\\n * @title SystemAccessControl\\n *\\n * @author Fujidao Labs\\n *\\n * @notice Abstract contract that should be inherited by contract implementations that\\n * call the {Chief} contract for access control checks.\\n */\\n\\nimport {IChief} from \\\"../interfaces/IChief.sol\\\";\\nimport {CoreRoles} from \\\"./CoreRoles.sol\\\";\\n\\ncontract SystemAccessControl is CoreRoles {\\n  /// @dev Custom Errors\\n  error SystemAccessControl__hasRole_missingRole(address caller, bytes32 role);\\n  error SystemAccessControl__onlyTimelock_callerIsNotTimelock();\\n  error SystemAccessControl__onlyHouseKeeper_notHouseKeeper();\\n\\n  IChief public chief;\\n\\n  /**\\n   * @dev Modifier that checks `caller` has `role`.\\n   */\\n  modifier hasRole(address caller, bytes32 role) {\\n    if (!chief.hasRole(role, caller)) {\\n      revert SystemAccessControl__hasRole_missingRole(caller, role);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier that checks `msg.sender` has HOUSE_KEEPER_ROLE.\\n   */\\n  modifier onlyHouseKeeper() {\\n    if (!chief.hasRole(HOUSE_KEEPER_ROLE, msg.sender)) {\\n      revert SystemAccessControl__onlyHouseKeeper_notHouseKeeper();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier that checks `msg.sender` is the defined `timelock` in {Chief}\\n   * contract.\\n   */\\n  modifier onlyTimelock() {\\n    if (msg.sender != chief.timelock()) {\\n      revert SystemAccessControl__onlyTimelock_callerIsNotTimelock();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Init of a new {SystemAccessControl}.\\n   *\\n   * @param chief_ address\\n   *\\n   * @dev Requirements:\\n   * - Must pass non-zero {Chief} address, that could be checked at child contract.\\n   */\\n  function __SystemAccessControl_init(address chief_) internal {\\n    chief = IChief(chief_);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IChief.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IChief\\n *\\n * @author Fujidao Labs\\n *\\n * @notice Defines interface for {Chief} access control operations.\\n */\\n\\nimport {IAccessControl} from \\\"openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IChief is IAccessControl {\\n  /// @notice Returns the timelock address of the FujiV2 system.\\n  function timelock() external view returns (address);\\n\\n  /// @notice Returns the address mapper contract address of the FujiV2 system.\\n  function addrMapper() external view returns (address);\\n\\n  /**\\n   * @notice Returns true if `vault` is active.\\n   *\\n   * @param vault to check status\\n   */\\n  function isVaultActive(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Returns true if `flasher` is an allowed {IFlasher}.\\n   *\\n   * @param flasher address to check\\n   */\\n  function allowedFlasher(address flasher) external view returns (bool);\\n\\n  /**\\n   * @notice Returns true if `swapper` is an allowed {ISwapper}.\\n   *\\n   * @param swapper address to check\\n   */\\n  function allowedSwapper(address swapper) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/access/CoreRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\n/**\\n * @title CoreRoles\\n *\\n * @author Fujidao Labs\\n *\\n * @notice System definition of roles used across FujiV2 contracts.\\n */\\n\\ncontract CoreRoles {\\n  bytes32 public constant HOUSE_KEEPER_ROLE = keccak256(\\\"HOUSE_KEEPER_ROLE\\\");\\n\\n  bytes32 public constant REBALANCER_ROLE = keccak256(\\\"REBALANCER_ROLE\\\");\\n  bytes32 public constant HARVESTER_ROLE = keccak256(\\\"HARVESTER_ROLE\\\");\\n  bytes32 public constant LIQUIDATOR_ROLE = keccak256(\\\"LIQUIDATOR_ROLE\\\");\\n\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n  bytes32 public constant UNPAUSER_ROLE = keccak256(\\\"UNPAUSER_ROLE\\\");\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"nxtp/=lib/nxtp/packages/deployments/contracts/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"lib/openzeppelin-contracts-upgradeable:openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chief_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AaveEModeHelper_constructor_addressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AaveEModeHelper_setEModeConfig_arrayDiscrepancy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"SystemAccessControl__hasRole_missingRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SystemAccessControl__onlyHouseKeeper_notHouseKeeper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SystemAccessControl__onlyTimelock_callerIsNotTimelock\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"configId\",\"type\":\"uint8\"}],\"name\":\"EmodeConfigSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HARVESTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOUSE_KEEPER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REBALANCER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNPAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chief\",\"outputs\":[{\"internalType\":\"contract IChief\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debt\",\"type\":\"address\"}],\"name\":\"getEModeConfigIds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"debts\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"configIds\",\"type\":\"uint8[]\"}],\"name\":\"setEModeConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AaveEModeHelper", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000088ed3b8d03e5a70bf23286872b24cffd76e91922", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}