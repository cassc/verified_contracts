{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IVaultInterface {\r\n    function execute(\r\n        address,\r\n        bytes memory\r\n    ) external payable returns (bytes memory);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(\r\n        uint80 _roundId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            uint256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\ninterface IsparkSavingsInterface {\r\n    function wstETH() external view returns (address);\r\n\r\n    function savingsAsset() external view returns (address);\r\n\r\n    function getDai() external view returns (address);\r\n\r\n    function getGem() external view returns (address);\r\n\r\n    function getGemJoin() external view returns (address);\r\n}\r\n\r\ncontract MakerDaoPSMSparkStakeMonitor {\r\n    using SafeMath for uint256;\r\n    address public owner;\r\n    address public daiStakePool;\r\n    address public makerDaoSparkSavingsStrategy;\r\n    address public chainlinkDaiBaseUSD;\r\n    address public chainlinkUsdcBaseUSD;\r\n    address public DAI;\r\n    address public PSMUSDC;\r\n    address public USDC;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        chainlinkDaiBaseUSD = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;\r\n        chainlinkUsdcBaseUSD = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\r\n        makerDaoSparkSavingsStrategy = 0x6Dae9515DEb20F9875B4A383D353a97E0A6815E4; //0x71122Cd26c5f1E18826652708C3e00D1cf837DA4\r\n        PSMUSDC = IsparkSavingsInterface(makerDaoSparkSavingsStrategy)\r\n            .getGemJoin(); //0x0A59649758aa4d66E25f08Dd01271e891fe52199;\r\n        USDC = IsparkSavingsInterface(makerDaoSparkSavingsStrategy).getGem(); //0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n        daiStakePool = IsparkSavingsInterface(makerDaoSparkSavingsStrategy)\r\n            .savingsAsset(); //0x83F20F44975D03b1b09e64809B757c47f942BEeA; // sdai\r\n        DAI = IsparkSavingsInterface(makerDaoSparkSavingsStrategy).getDai(); // 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    }\r\n\r\n    function setMakerDaoSparkSavingsStrategy(\r\n        address _makerDaoSparkSavingsStrategy\r\n    ) external {\r\n        require(\r\n            msg.sender == owner,\r\n            \" only owner set lido spark staked Strategy\"\r\n        );\r\n        makerDaoSparkSavingsStrategy = _makerDaoSparkSavingsStrategy;\r\n    }\r\n\r\n    function getPSMUSDCLiquidity() public view returns (uint256) {\r\n        uint256 _usdcCash;\r\n        _usdcCash = getTokenBalance(USDC, PSMUSDC);\r\n        return _usdcCash;\r\n    }\r\n\r\n    function isPSMUSDCLiquidityInsufficient(\r\n        uint256 _USDCAmountThreshold\r\n    ) public view returns (bool) {\r\n        uint256 _USDCCash;\r\n        _USDCCash = getPSMUSDCLiquidity();\r\n        if (_USDCAmountThreshold >= _USDCCash) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function hasSparkStaked(address _vault) public view returns (bool) {\r\n        uint256 _balance;\r\n\r\n        _balance = IERC20(daiStakePool).balanceOf(_vault);\r\n\r\n        if (_balance > 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getTokenBalance(\r\n        address underlying,\r\n        address vault\r\n    ) public view returns (uint256) {\r\n        return IERC20(underlying).balanceOf(vault);\r\n    }\r\n\r\n    function getPriceChainLink(\r\n        address _chainlinkAggregator\r\n    ) public view returns (uint256) {\r\n        /*\r\n        (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n        )\r\n        */\r\n        (, uint256 _price, , , ) = AggregatorV3Interface(_chainlinkAggregator)\r\n            .latestRoundData();\r\n        return _price;\r\n    }\r\n\r\n    function getDaiPriceFromChainLink() public view returns (uint256) {\r\n        uint256 _price;\r\n        _price = getPriceChainLink(chainlinkDaiBaseUSD);\r\n        return _price;\r\n    }\r\n\r\n    function getUsdcPriceFromChainLink() public view returns (uint256) {\r\n        uint256 _price;\r\n        _price = getPriceChainLink(chainlinkUsdcBaseUSD);\r\n        return _price;\r\n    }\r\n\r\n    function isDaiPriceUnanchoredFromChainLink(\r\n        uint256 _anchorPrice\r\n    ) public view returns (bool) {\r\n        /*\r\n        (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n        )\r\n        */\r\n        uint256 _price;\r\n        _price = getDaiPriceFromChainLink();\r\n        if (_price <= _anchorPrice) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isUsdcPriceUnanchoredFromChainLink(\r\n        uint256 _anchorPrice\r\n    ) public view returns (bool) {\r\n        /*\r\n        (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n        )\r\n        */\r\n        uint256 _price;\r\n        _price = getUsdcPriceFromChainLink();\r\n        if (_price <= _anchorPrice) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function encodeExitAllInput()\r\n        internal\r\n        pure\r\n        returns (bytes memory encodedInput)\r\n    {\r\n        return abi.encodeWithSignature(\"exitAll()\");\r\n    }\r\n\r\n    function executeExitAll(\r\n        address _vault\r\n    ) public view returns (bool canExec, bytes memory execPayload) {\r\n        bytes memory args = encodeExitAllInput();\r\n        execPayload = abi.encodeWithSelector(\r\n            IVaultInterface(_vault).execute.selector,\r\n            makerDaoSparkSavingsStrategy,\r\n            args\r\n        );\r\n        return (true, execPayload);\r\n    }\r\n\r\n    function checker(\r\n        address _vault,\r\n        uint256 _anchorDaiPriceThreshold,\r\n        uint256 _anchorUsdcPriceThreshold,\r\n        uint256 _psmusdcCashThreshold\r\n    ) external view returns (bool canExec, bytes memory execPayload) {\r\n        if (hasSparkStaked(_vault)) {\r\n            if (isDaiPriceUnanchoredFromChainLink(_anchorDaiPriceThreshold)) {\r\n                return executeExitAll(_vault);\r\n            }\r\n            if (isUsdcPriceUnanchoredFromChainLink(_anchorUsdcPriceThreshold)) {\r\n                return executeExitAll(_vault);\r\n            }\r\n            if (isPSMUSDCLiquidityInsufficient(_psmusdcCashThreshold)) {\r\n                return executeExitAll(_vault);\r\n            }\r\n        }\r\n        return (false, bytes(\"monitor is ok\"));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PSMUSDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkDaiBaseUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkUsdcBaseUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_anchorDaiPriceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_anchorUsdcPriceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_psmusdcCashThreshold\",\"type\":\"uint256\"}],\"name\":\"checker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiStakePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"executeExitAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaiPriceFromChainLink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPSMUSDCLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chainlinkAggregator\",\"type\":\"address\"}],\"name\":\"getPriceChainLink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdcPriceFromChainLink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"hasSparkStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_anchorPrice\",\"type\":\"uint256\"}],\"name\":\"isDaiPriceUnanchoredFromChainLink\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_USDCAmountThreshold\",\"type\":\"uint256\"}],\"name\":\"isPSMUSDCLiquidityInsufficient\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_anchorPrice\",\"type\":\"uint256\"}],\"name\":\"isUsdcPriceUnanchoredFromChainLink\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makerDaoSparkSavingsStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerDaoSparkSavingsStrategy\",\"type\":\"address\"}],\"name\":\"setMakerDaoSparkSavingsStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MakerDaoPSMSparkStakeMonitor", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000040ff7499951546dfa412e9dc05c816a453953616", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://69d81926e1eea60b3dd43b99c04265d3e4e960c1edfbd184d4710bc9cc14681a"}