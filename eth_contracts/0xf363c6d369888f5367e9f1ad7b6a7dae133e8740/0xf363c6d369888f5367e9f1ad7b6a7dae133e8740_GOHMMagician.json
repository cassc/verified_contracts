{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/liquidation/magicians/GOHMMagician.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/IMagician.sol\\\";\\nimport \\\"./interfaces/IOlympusStakingV3Like.sol\\\";\\nimport \\\"./interfaces/IGOHMLikeV2.sol\\\";\\nimport \\\"./interfaces/IBalancerVaultLike.sol\\\";\\n\\n/// @dev gOHM Magician\\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\\ncontract GOHMMagician is IMagician {\\n    /// @dev Value for gOHM -> OHMv2 balances calculation\\n    uint256 public constant TWO_EXTRA_WEIS = (1 wei) + (1 wei);\\n\\n    /// @dev Argument for Olympus Staking `stake()`. Mint gOHM tokens instantly on stake.\\n    bool public constant OLYMPUS_STAKING_CLAIM = true;\\n\\n    /// @dev Argument for Olympus Staking `stake()` or `unstake()`. Receive gOHM tokens instead of rebasing sOHM.\\n    bool public constant OLYMPUS_STAKING_REBASING = false;\\n\\n    /// @dev Argument for Olympus Staking `unstake()`. Do not trigger rebase() of OHM tokens, save gas.\\n    bool public constant OLYMPUS_STAKING_TRIGGER = false;\\n\\n    /// @dev Limit for OHMv2 swap.\\n    uint256 public constant SWAP_AMOUNT_OUT_LIMIT = type(uint256).max;\\n\\n    /// @dev Limit for OHMv2 swap.\\n    uint256 public constant SWAP_AMOUNT_IN_LIMIT = 1;\\n\\n    /// @dev Required for OHMv2 swap.\\n    // solhint-disable-next-line var-name-mixedcase\\n    IBalancerVaultLike public immutable BALANCER_VAULT;\\n\\n    /// @dev OHMv2 pool that is used for swap.\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public immutable BALANCER_OHM_POOL;\\n\\n    /// @dev The address of quote token.\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable QUOTE;\\n\\n    /// @dev 10 ** (gOHM decimals), constant and equal to 10**18.\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint256 public immutable TEN_POW_GOHM_DECIMALS;\\n\\n    /// @dev Original token, OHMv2.\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable OHM;\\n\\n    /// @dev Wrapper for rebasing sOHM token.\\n    // solhint-disable-next-line var-name-mixedcase\\n    IGOHMLikeV2 public immutable GOHM;\\n\\n    /// @dev Olympus staking contract for OHMv2 <-> gOHM wrapping and unwrapping.\\n    // solhint-disable-next-line var-name-mixedcase\\n    IOlympusStakingV3Like public immutable OLYMPUS_STAKING_V3;\\n\\n    error InvalidAsset();\\n    error InvalidBalancerPool();\\n\\n    constructor(\\n        address _quote,\\n        IOlympusStakingV3Like _olympusStakingV3,\\n        IBalancerVaultLike _balancerVault,\\n        bytes32 _balancerOhmPool\\n    ) {\\n        QUOTE = _quote;\\n\\n        GOHM = IGOHMLikeV2(_olympusStakingV3.gOHM());\\n        TEN_POW_GOHM_DECIMALS = 10 ** GOHM.decimals();\\n        OHM = _olympusStakingV3.OHM();\\n\\n        OLYMPUS_STAKING_V3 = _olympusStakingV3;\\n        BALANCER_VAULT = _balancerVault;\\n        BALANCER_OHM_POOL = _balancerOhmPool;\\n\\n        if (!verifyPoolAndVault(_balancerVault, _balancerOhmPool)) revert InvalidBalancerPool();\\n    }\\n\\n    /// @inheritdoc IMagician\\n    function towardsNative(address _asset, uint256 _amount) external returns (address, uint256) {\\n        if (_asset != address(GOHM)) revert InvalidAsset();\\n\\n        GOHM.approve(address(OLYMPUS_STAKING_V3), _amount);\\n\\n        uint256 ohmAmount = OLYMPUS_STAKING_V3.unstake(\\n            address(this),\\n                _amount,\\n                OLYMPUS_STAKING_TRIGGER,\\n                OLYMPUS_STAKING_REBASING\\n        );\\n\\n        return (QUOTE, _swapOHMForQuote(ohmAmount));\\n    }\\n\\n    /// @inheritdoc IMagician\\n    function towardsAsset(address _asset, uint256 _amount) external returns (address, uint256) {\\n        if (_asset != address(GOHM)) revert InvalidAsset();\\n\\n        uint256 ohmAmount = ohmBalanceFrom(_amount);\\n        uint256 quoteSpent = _swapQuoteForOHM(ohmAmount);\\n\\n        IERC20(OHM).approve(address(OLYMPUS_STAKING_V3), ohmAmount);\\n        OLYMPUS_STAKING_V3.stake(address(this), ohmAmount, OLYMPUS_STAKING_REBASING, OLYMPUS_STAKING_CLAIM);\\n\\n        return (address(GOHM), quoteSpent);\\n    }\\n\\n    /// @dev calculate gOHM -> OHMv2 amounts.\\n    ///     Our goal is to calculate right amount of OHM that will give us `_gOhmAmount` when we stake it.\\n    ///     2 extra weis added to make sure that we will not receive less than `_gOhmAmount`.\\n    ///     First `1 wei` explanation:\\n    ///     We can lose up to one wei on step of OHM -> gOHM inside OlympusStaking.stake():\\n    ///     OHM -> gOHM formula: `ohmAmount * (10**18) / (index);`.\\n    ///     The operation of `/(index)` can cause the lost of [0..index-1] from `ohmAmount * (10**18)`.\\n    ///     If we add 1 wei to `ohmAmount`, `(ohmAmount + 1 wei) * (10**18) > ohmAmount * (10**18) - (index - 1)`.\\n    ///     Index has 9 basis points, it will work until it will not increase 10**18.\\n    ///     Second `1 wei` explanation:\\n    ///     We can lose up to one wei on step of gOHM -> OHM calculation below.\\n    ///     gOHM -> OHM formula: `(gOhmAmount * index) / (10**18)`.\\n    ///     The operation of `/ (10**18)` can cause the lost of [0..10**18 - 1] from `(gOhmAmount * index)`.\\n    ///     Let's add extra wei to gOHM -> OHM formula.\\n    ///     Then on gOHM -> OHM calculations, worst case scenario:\\n    ///     ((gOhmAmount * index) / (10**18) + 1) * (10**18) / (index) >=\\n    ///     = (gOhmAmount * index - (10**18 - 1) + 10**18) / index =\\n    ///     = (gOhmAmount * index + 1) / index >= gOhmAmount\\n    /// @param _gOhmAmount input amount of gOHM\\n    /// @return ohmAmount equal amount in OHMv2\\n    function ohmBalanceFrom(uint256 _gOhmAmount) public view returns (uint256 ohmAmount) {\\n        ohmAmount = _gOhmAmount * GOHM.index();\\n\\n        // we can safely divide by 10 ** 18 and add 2\\n        unchecked {\\n            ohmAmount = ohmAmount / TEN_POW_GOHM_DECIMALS + TWO_EXTRA_WEIS;\\n        }\\n    }\\n\\n    /// @dev verify the Balancer pool and the vault. Sanity check for vault address is a call of getPoolTokens(_poolId).\\n    ///     Pool is valid if it has OHMv2 and quote tokens.\\n    /// @param _balancerVault address of the Balancer vault\\n    /// @param _poolId pool id\\n    /// @return true if the pool is valid for the swap\\n    function verifyPoolAndVault(IBalancerVaultLike _balancerVault, bytes32 _poolId) public view returns (bool) {\\n        (address[] memory tokens,,) = IBalancerVaultLike(_balancerVault).getPoolTokens(_poolId);\\n        bool isQuote;\\n        bool isOhm;\\n\\n        for (uint256 i; i < tokens.length && !(isOhm && isQuote);) {\\n            if (!isOhm && tokens[i] == OHM) {\\n                isOhm = true;\\n            } else if (!isQuote && tokens[i] == QUOTE) {\\n                isQuote = true;\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return isQuote && isOhm;\\n    }\\n\\n    /// @dev it swaps OHMv2 for quote token\\n    /// @param _ohmAmount exact amountIn of OHMv2 token\\n    /// @return quoteReceived amount of quote token received\\n    function _swapOHMForQuote(uint256 _ohmAmount) internal returns (uint256 quoteReceived) {\\n        IERC20(OHM).approve(address(BALANCER_VAULT), _ohmAmount);\\n        quoteReceived = _swapAmountIn(OHM, QUOTE, _ohmAmount, BALANCER_OHM_POOL);\\n    }\\n\\n    /// @dev it swaps quote token for OHMv2\\n    /// @param _ohmAmount exact amountOut of OHMv2\\n    /// @return quoteSpent amount of quote token spent\\n    function _swapQuoteForOHM(uint256 _ohmAmount) internal returns (uint256 quoteSpent) {\\n        IERC20(QUOTE).approve(address(BALANCER_VAULT), SWAP_AMOUNT_OUT_LIMIT);\\n        quoteSpent = _swapAmountOut(QUOTE, OHM, _ohmAmount, BALANCER_OHM_POOL);\\n    }\\n\\n    /// @dev it swaps _tokenIn for _tokenOut\\n    /// @param _tokenIn address of the tokenIn\\n    /// @param _tokenOut address of the tokenOut\\n    /// @param _amountOut amount of the tokenOut to receive\\n    /// @param _poolId balancer pool id\\n    /// @return amount of _tokenIn spent\\n    function _swapAmountOut(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _amountOut,\\n        bytes32 _poolId\\n    ) internal returns (uint256) {\\n        IBalancerVaultLike.SingleSwap memory singleSwap = IBalancerVaultLike.SingleSwap(\\n            _poolId, IBalancerVaultLike.SwapKind.GIVEN_OUT, address(_tokenIn), address(_tokenOut), _amountOut, \\\"\\\"\\n        );\\n\\n        IBalancerVaultLike.FundManagement memory funds = IBalancerVaultLike.FundManagement(\\n            address(this), false, payable(address(this)), false\\n        );\\n\\n        return BALANCER_VAULT.swap(singleSwap, funds, SWAP_AMOUNT_OUT_LIMIT, block.timestamp);\\n    }\\n\\n    /// @dev it swaps _tokenIn for _tokenOut\\n    /// @param _tokenIn address of the tokenIn\\n    /// @param _tokenOut address of the tokenOut\\n    /// @param _amountIn amount of the tokenIn to spend\\n    /// @param _poolId balancer pool id\\n    /// @return amount of _tokenOut received\\n    function _swapAmountIn(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _amountIn,\\n        bytes32 _poolId\\n    ) internal returns (uint256) {\\n        IBalancerVaultLike.SingleSwap memory singleSwap = IBalancerVaultLike.SingleSwap(\\n            _poolId, IBalancerVaultLike.SwapKind.GIVEN_IN, address(_tokenIn), address(_tokenOut), _amountIn, \\\"\\\"\\n        );\\n\\n        IBalancerVaultLike.FundManagement memory funds = IBalancerVaultLike.FundManagement(\\n            address(this), false, payable(address(this)), false\\n        );\\n\\n        return BALANCER_VAULT.swap(singleSwap, funds, SWAP_AMOUNT_IN_LIMIT, block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/magicians/interfaces/IMagician.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @notice Extension for the Liquidation helper to support such operations as unwrapping\\ninterface IMagician {\\n    /// @notice Operates to unwrap an `_asset`\\n    /// @param _asset Asset to be unwrapped\\n    /// @param _amount Amount of the `_asset`\\n    /// @return tokenOut A token that the `_asset` has been converted to\\n    /// @return amountOut Amount of the `tokenOut` that we received\\n    function towardsNative(address _asset, uint256 _amount) external returns (address tokenOut, uint256 amountOut);\\n\\n    /// @notice Performs operation opposit to `towardsNative`\\n    /// @param _asset Asset to be wrapped\\n    /// @param _amount Amount of the `_asset`\\n    /// @return tokenOut A token that the `_asset` has been converted to\\n    /// @return amountOut Amount of the quote token that we spent to get `_amoun` of the `_asset`\\n    function towardsAsset(address _asset, uint256 _amount) external returns (address tokenOut, uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/magicians/interfaces/IOlympusStakingV3Like.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\n/// @dev A simplified version of the Olympus staking V3 interface with methods\\n/// that are required for the gOHM magician contract.\\ninterface IOlympusStakingV3Like {\\n    function unstake(\\n        address _to,\\n        uint256 _amount,\\n        bool _trigger,\\n        bool _rebasing\\n    ) external returns (uint256 amount_);\\n\\n    function stake(\\n        address _to,\\n        uint256 _amount,\\n        bool _rebasing,\\n        bool _claim\\n    ) external returns (uint256);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function OHM() external view returns (address);\\n    function gOHM() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/magicians/interfaces/IGOHMLikeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGOHMLikeV2 is IERC20 {\\n    function index() external view returns (uint256);\\n    function decimals() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/magicians/interfaces/IBalancerVaultLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\ninterface IBalancerVaultLike {\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            address[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_quote\",\"type\":\"address\"},{\"internalType\":\"contract IOlympusStakingV3Like\",\"name\":\"_olympusStakingV3\",\"type\":\"address\"},{\"internalType\":\"contract IBalancerVaultLike\",\"name\":\"_balancerVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_balancerOhmPool\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBalancerPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BALANCER_OHM_POOL\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BALANCER_VAULT\",\"outputs\":[{\"internalType\":\"contract IBalancerVaultLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOHM\",\"outputs\":[{\"internalType\":\"contract IGOHMLikeV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OHM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OLYMPUS_STAKING_CLAIM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OLYMPUS_STAKING_REBASING\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OLYMPUS_STAKING_TRIGGER\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OLYMPUS_STAKING_V3\",\"outputs\":[{\"internalType\":\"contract IOlympusStakingV3Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_AMOUNT_IN_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_AMOUNT_OUT_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEN_POW_GOHM_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWO_EXTRA_WEIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gOhmAmount\",\"type\":\"uint256\"}],\"name\":\"ohmBalanceFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ohmAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"towardsAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"towardsNative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBalancerVaultLike\",\"name\":\"_balancerVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"name\":\"verifyPoolAndVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GOHMMagician", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000b63cac384247597756545b500253ff8e607a8020000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c8c45d42f801105e861e86658648e3678ad7aa70f900010000000000000000011e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}