{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.21;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n}\"},\"MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\r\\n\\r\\npragma solidity 0.8.21;\\r\\n\\r\\n/**\\r\\n * @dev These functions deal with verification of Merkle Tree proofs.\\r\\n *\\r\\n * The tree and the proofs can be generated using our\\r\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\r\\n * You will find a quickstart guide in the readme.\\r\\n *\\r\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\r\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\r\\n * This is because the concatenation of a sorted pair of internal nodes in\\r\\n * the merkle tree could be reinterpreted as a leaf value.\\r\\n * OpenZeppelin\\u0027s JavaScript library generates merkle trees that are safe\\r\\n * against this attack out of the box.\\r\\n */\\r\\nlibrary MerkleProof {\\r\\n    /**\\r\\n     *@dev The multiproof provided is not valid.\\r\\n     */\\r\\n    error MerkleProofInvalidMultiproof();\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\r\\n     * defined by `root`. For this, a `proof` must be provided, containing\\r\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\r\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProof(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {verify}\\r\\n     */\\r\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProofCalldata(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\r\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\r\\n     * hash matches the root of the tree. When processing the proof, the pairs\\r\\n     * of leafs \\u0026 pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processProof}\\r\\n     */\\r\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\r\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function multiProofVerify(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {multiProofVerify}\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function multiProofVerifyCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\r\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\r\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\r\\n     * respectively.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\r\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\r\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\r\\n     */\\r\\n    function processMultiProof(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        if (leavesLen + proofLen - 1 != totalHashes) {\\r\\n            revert MerkleProofInvalidMultiproof();\\r\\n        }\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\\u0027s \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i \\u003c totalHashes; i++) {\\r\\n            bytes32 a = leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes \\u003e 0) {\\r\\n            if (proofPos != proofLen) {\\r\\n                revert MerkleProofInvalidMultiproof();\\r\\n            }\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen \\u003e 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function processMultiProofCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        if (leavesLen + proofLen - 1 != totalHashes) {\\r\\n            revert MerkleProofInvalidMultiproof();\\r\\n        }\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\\u0027s \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i \\u003c totalHashes; i++) {\\r\\n            bytes32 a = leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos \\u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes \\u003e 0) {\\r\\n            if (proofPos != proofLen) {\\r\\n                revert MerkleProofInvalidMultiproof();\\r\\n            }\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen \\u003e 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\r\\n        return a \\u003c b ? _efficientHash(a, b) : _efficientHash(b, a);\\r\\n    }\\r\\n\\r\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, a)\\r\\n            mstore(0x20, b)\\r\\n            value := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"XccelerateStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.21;\\r\\n\\r\\nimport \\\"./MerkleProof.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract XccelerateStaking {\\r\\n    IERC20 public XLRT = IERC20(0x8a3C710E41cD95799C535f22DBaE371D7C858651);\\r\\n\\r\\n    // merkle related vars\\r\\n    address public owner;\\r\\n    address public rootFeeder;\\r\\n    bytes32 public merkleRoot;\\r\\n    mapping(bytes32 =\\u003e bool) private _leafClaimed;\\r\\n\\r\\n    // staking vars\\r\\n    uint256 public totalStaked;\\r\\n    mapping(address =\\u003e uint256) public staked;\\r\\n\\r\\n    // all events emmited for the merkle tree\\r\\n    event MerkleUpdated();\\r\\n    event Staked(address staker, uint256 amount, uint256 timestamp);\\r\\n    event Unstaked(address staker, uint256 amount, uint256 timestamp);\\r\\n    event Claimed(address staker, uint256 amount, uint256 timestamp);\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Only the owner can call this function.\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev owner can set the rootFeeder address\\r\\n    */\\r\\n    function setRootFeeder(address feeder) external onlyOwner {\\r\\n        rootFeeder = feeder;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev rootFeeder can update the root (automatic process done once every day)\\r\\n    */\\r\\n    function setMerkleRoot(bytes32 _merkleRoot) external payable {\\r\\n        require(msg.sender == rootFeeder, \\\"Only the rootFeeder can call this function.\\\");\\r\\n        merkleRoot = _merkleRoot;\\r\\n\\r\\n        emit MerkleUpdated();\\r\\n    }\\r\\n\\r\\n    function getLeaf(uint256 cumulativeReward) external view returns(bytes32) {\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, cumulativeReward));\\r\\n        return leaf;\\r\\n    }\\r\\n\\r\\n    function verifyMerkleProof(bytes32[] calldata proof, address elementToProve, uint256 cumulativeReward) public view returns (bool) {\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(elementToProve, cumulativeReward));\\r\\n        bool verified = MerkleProof.verify(proof, merkleRoot, leaf);\\r\\n        \\r\\n        return verified;\\r\\n    }\\r\\n\\r\\n    function _claim(uint256 cumulativeReward, bytes32[] memory proof) private {\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, cumulativeReward));\\r\\n        require(!_leafClaimed[leaf], \\\"You have already claimed your rewards, wait until the next merkleRoot set.\\\");\\r\\n        require(MerkleProof.verify(proof, merkleRoot, leaf), \\\"Invalid proof\\\");\\r\\n\\r\\n        _leafClaimed[leaf] = true;\\r\\n        payable(msg.sender).transfer(cumulativeReward);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Adds positing to staking pool\\r\\n    */\\r\\n    function stake(uint256 amount) external {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n\\r\\n        XLRT.transferFrom(msg.sender, address(this), amount);\\r\\n        staked[msg.sender] += amount;\\r\\n        totalStaked += amount;\\r\\n\\r\\n        emit Staked(msg.sender, amount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Unstakes the amount wished to be unstaked along with claiming cumulative reward\\r\\n    */\\r\\n    function unstake(uint256 amount, uint256 cumulativeReward, bytes32[] memory proof) external {\\r\\n        require(amount \\u003e 0, \\\"Cannot unstake 0\\\");\\r\\n        require(staked[msg.sender] \\u003e= amount, \\\"unstake amount exceeds staked balance\\\");\\r\\n\\r\\n        staked[msg.sender] -= amount;\\r\\n        totalStaked -= amount;\\r\\n        XLRT.transfer(msg.sender, amount);\\r\\n\\r\\n        if (cumulativeReward \\u003e 0)\\r\\n            _claim(cumulativeReward, proof);\\r\\n\\r\\n        emit Unstaked(msg.sender, amount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Claiming can be done once every 24h after Merkle Root has been called\\r\\n    */\\r\\n    function claim(uint256 cumulativeReward, bytes32[] memory proof) external {\\r\\n        _claim(cumulativeReward, proof);\\r\\n        emit Claimed(msg.sender, cumulativeReward, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Emergency withdraw eth in contract in case something is wrong with the contract\\r\\n    */\\r\\n    function emergencyWithdraw() external onlyOwner{\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MerkleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"XLRT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeReward\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeReward\",\"type\":\"uint256\"}],\"name\":\"getLeaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootFeeder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeder\",\"type\":\"address\"}],\"name\":\"setRootFeeder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeReward\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"elementToProve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeReward\",\"type\":\"uint256\"}],\"name\":\"verifyMerkleProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XccelerateStaking", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://55845dfc8cf079c5d513b6dfcdaab6a86378e9b20f2bdb82b392f334fa20bfd6"}