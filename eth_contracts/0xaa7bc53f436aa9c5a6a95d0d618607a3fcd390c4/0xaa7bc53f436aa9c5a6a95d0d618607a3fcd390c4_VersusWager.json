{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Versus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract VersusWager {\\r\\n    struct Game {\\r\\n        address payable playerA;\\r\\n        address payable playerB;\\r\\n        uint256 stake;\\r\\n        bool isFlipped;\\r\\n        address winner;\\r\\n    }\\r\\n\\r\\n    mapping(string => Game) public games; // Maps gameID to Game.\\r\\n    mapping(uint256 => string) public gameNumbers; // Maps gameNumber to gameID.\\r\\n    uint256 public currentGameNumber = 0;\\r\\n    string[] public openGames;\\r\\n    \\r\\n    function createGame(string memory gameID) public payable {\\r\\n        require(bytes(gameID).length <= 10, \\\"GameID too long\\\");\\r\\n        require(games[gameID].playerA == address(0), \\\"GameID already exists\\\");\\r\\n        \\r\\n    games[gameID] = Game({\\r\\n        playerA: payable(msg.sender),\\r\\n        playerB: payable(address(0)),\\r\\n        stake: msg.value,\\r\\n        isFlipped: false,\\r\\n        winner: address(0)\\r\\n    });\\r\\n\\r\\n\\r\\n        currentGameNumber++;\\r\\n        gameNumbers[currentGameNumber] = gameID;\\r\\n        openGames.push(gameID);\\r\\n    }\\r\\n\\r\\n    function joinGame(string memory gameID) public payable {\\r\\n        require(games[gameID].playerA != address(0), \\\"Game does not exist\\\");\\r\\n        require(games[gameID].playerB == address(0), \\\"Game already has a second player\\\");\\r\\n        require(msg.value == games[gameID].stake, \\\"Must send the correct stake amount\\\");\\r\\n\\r\\n        games[gameID].playerB = payable(msg.sender);\\r\\n\\r\\n        // Removing game from the openGames list\\r\\n        for(uint i = 0; i < openGames.length; i++) {\\r\\n            if(keccak256(abi.encodePacked(openGames[i])) == keccak256(abi.encodePacked(gameID))) {\\r\\n                openGames[i] = openGames[openGames.length - 1];\\r\\n                openGames.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function flip(string memory gameID) public {\\r\\n        require(games[gameID].playerB != address(0), \\\"Game does not have a second player yet\\\");\\r\\n        require(!games[gameID].isFlipped, \\\"Game has already been flipped\\\");\\r\\n        require(msg.sender == games[gameID].playerA || msg.sender == games[gameID].playerB, \\\"Only participants can initiate the flip\\\");\\r\\n        \\r\\n        uint256 randomness = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender))) % 2;\\r\\n        if(randomness == 0) {\\r\\n            games[gameID].winner = games[gameID].playerA;\\r\\n            games[gameID].playerA.transfer(games[gameID].stake * 2);\\r\\n        } else {\\r\\n            games[gameID].winner = games[gameID].playerB;\\r\\n            games[gameID].playerB.transfer(games[gameID].stake * 2);\\r\\n        }\\r\\n        games[gameID].isFlipped = true;\\r\\n    }\\r\\n    \\r\\n    function getGame(string memory gameID) public view returns(Game memory) {\\r\\n        return games[gameID];\\r\\n    }\\r\\n\\r\\n    function getOpenGames() public view returns(string[] memory) {\\r\\n        return openGames;\\r\\n    }\\r\\n\\r\\n    function getAllGames() public view returns(string[] memory) {\\r\\n        string[] memory allGames = new string[](currentGameNumber);\\r\\n        for(uint i = 0; i < currentGameNumber; i++) {\\r\\n            allGames[i] = gameNumbers[i+1];\\r\\n        }\\r\\n        return allGames;\\r\\n    }\\r\\n\\r\\n    function getUnflippedGames(address player) public view returns(string[] memory) {\\r\\n        uint count = 0;\\r\\n        for(uint i = 0; i < openGames.length; i++) {\\r\\n            if(games[openGames[i]].playerA == player || games[openGames[i]].playerB == player) {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        string[] memory unflipped = new string[](count);\\r\\n        uint j = 0;\\r\\n        for(uint i = 0; i < openGames.length; i++) {\\r\\n            if(games[openGames[i]].playerA == player || games[openGames[i]].playerB == player) {\\r\\n                unflipped[j] = openGames[i];\\r\\n                j++;\\r\\n            }\\r\\n        }\\r\\n        return unflipped;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"gameID\",\"type\":\"string\"}],\"name\":\"createGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentGameNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"gameID\",\"type\":\"string\"}],\"name\":\"flip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameNumbers\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFlipped\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllGames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"gameID\",\"type\":\"string\"}],\"name\":\"getGame\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"playerA\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"playerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFlipped\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"internalType\":\"struct VersusWager.Game\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenGames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getUnflippedGames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"gameID\",\"type\":\"string\"}],\"name\":\"joinGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"openGames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VersusWager", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}