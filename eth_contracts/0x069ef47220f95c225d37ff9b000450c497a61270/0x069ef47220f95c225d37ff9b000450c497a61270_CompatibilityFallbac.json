{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/NXV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {Executor} from \\\"./base/Executor.sol\\\";\\nimport {OwnerManager} from \\\"./base/OwnerManager.sol\\\";\\nimport {FallbackManager} from \\\"./base/FallbackManager.sol\\\";\\nimport {NativeCurrencyPaymentFallback} from \\\"./common/NativeCurrencyPaymentFallback.sol\\\";\\nimport {Singleton} from \\\"./common/Singleton.sol\\\";\\nimport {SignatureDecoder} from \\\"./common/SignatureDecoder.sol\\\";\\nimport {SecuredTokenTransfer} from \\\"./common/SecuredTokenTransfer.sol\\\";\\nimport {StorageAccessible} from \\\"./common/StorageAccessible.sol\\\";\\nimport {Enum} from \\\"./common/Enum.sol\\\";\\nimport {ISignatureValidator, ISignatureValidatorConstants} from \\\"./interfaces/ISignatureValidator.sol\\\";\\nimport {SafeMath} from \\\"./external/SafeMath.sol\\\";\\n\\n/**\\n * @title NXV - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\\n * @dev Most important concepts:\\n *      - Threshold: Number of required confirmations for a NXV transaction.\\n *      - Owners: List of addresses that control the NXV. They are the only ones that can add/remove owners, change the threshold and\\n *        approve transactions. Managed in `OwnerManager`.\\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\\n *      - Signature: A valid signature of an owner of the NXV for a transaction hash.\\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for NXV. Managed in `FallbackManager`.\\n * @author Stefan George - @Georgi87\\n * @author Richard Meissner - @rmeissner\\n */\\ncontract NXV is\\n    Singleton,\\n    NativeCurrencyPaymentFallback,\\n    Executor,\\n    OwnerManager,\\n    SignatureDecoder,\\n    ISignatureValidatorConstants,\\n    FallbackManager,\\n    StorageAccessible\\n{\\n    using SafeMath for uint256;\\n\\n    string public constant VERSION = \\\"1.0.0\\\";\\n\\n    /*\\n     *  Constants\\n     */\\n    // bytes32 public DOMAIN_SEPARATOR;\\n    bytes32 private constant EIP712DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 private constant TRANSACTION_TYPEHASH = keccak256(\\\"Transaction(address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\\\");\\n\\n    /*\\n     *  Events\\n     */\\n    event NXVSetup(address indexed initiator, address[] owners, uint256 threshold, address fallbackHandler);\\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 indexed nonce);\\n    event ExecutionFailure(bytes32 indexed txHash, uint256 indexed nonce);\\n\\n    /*\\n     *  Storage\\n     */\\n    mapping(uint256 => bool) public txNonces;\\n\\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\\n    mapping(bytes32 => uint256) public signedMessages;\\n\\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\\n    constructor() {\\n        /**\\n         * By setting the threshold it is not possible to call setup anymore,\\n         * so we create a NXV with 0 owners and threshold 1.\\n         * This is an unusable NXV, perfect for the singleton\\n         */\\n        threshold = 1;\\n    }\\n\\n    /**\\n     * @notice Sets an initial storage of the NXV contract.\\n     * @dev This method can only be called once.\\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\\n     * @param _owners List of NXV owners.\\n     * @param _threshold Number of required confirmations for a NXV transaction.\\n     * @param fallbackHandler Handler for fallback calls to this contract\\n     */\\n    function setup(\\n        address[] calldata _owners,\\n        uint256 _threshold,\\n        address fallbackHandler\\n    ) external {\\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\\n        setupOwners(_owners, _threshold);\\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\\n        emit NXVSetup(msg.sender, _owners, _threshold, fallbackHandler);\\n    }\\n\\n    /**\\n     * @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\\n     * @param to to address of NXV transaction.\\n     * @param value Ether value of NXV transaction.\\n     * @param data Data payload of NXV transaction.\\n     * @param operation Operation type of NXV transaction.\\n     * @param nonce Transaction nonce\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     * @return success Boolean indicating transaction's success.\\n     */\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 nonce,\\n        bytes memory signatures\\n    ) public payable virtual returns (bool success) {\\n        // require(signatures.length >= threshold, \\\"invalid signature data length\\\");\\n\\n        // \\\"txHash\\\" is the unique hash of transaction data\\n        bytes32 txHash = getTransactionHash(to, value, data, operation, nonce);\\n\\n        // two identical nonce only allow one to be executed\\n        // uint256 nonce = nonce;\\n        require(!txNonces[nonce], \\\"tx-nonce-exist\\\");\\n\\n        checkSignatures(txHash, \\\"\\\", signatures);\\n\\n        txNonces[nonce] = true;\\n\\n        success = execute(to, value, data, operation, (gasleft() - 2500));\\n        if (success) {\\n            emit ExecutionSuccess(txHash, nonce);\\n        } else {\\n            emit ExecutionFailure(txHash, nonce);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\\n     * @param txHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param data That should be signed (this is passed to an external validator contract)\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     */\\n    function checkSignatures(bytes32 txHash, bytes memory data, bytes memory signatures) public view {\\n        // Load threshold to avoid multiple storage loads\\n        uint256 _threshold = threshold;\\n        // Check that a threshold is set\\n        require(_threshold > 0, \\\"Threshold needs defined\\\");\\n        checkNSignatures(txHash, data, signatures, _threshold);\\n    }\\n\\n    /**\\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\\n     * @param txHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     * @param requiredSignatures Amount of required valid signatures.\\n     */\\n    function checkNSignatures(bytes32 txHash, bytes memory /* data */, bytes memory signatures, uint256 requiredSignatures) public view {\\n        // Check that the provided signature data is not too short\\n        require(signatures.length >= requiredSignatures * 65, \\\"invalid sig length\\\");\\n        // There cannot be an owner with address 0.\\n        address lastOwner = address(0);\\n        address currentOwner;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 i;\\n        for(i = 0; i < requiredSignatures; i++) {\\n            (v, r, s) = signatureSplit(signatures, i);\\n            currentOwner = ecrecover(txHash, v, r, s);\\n            // to save gas, need signature sorted\\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \\\"error-sig\\\");\\n            lastOwner = currentOwner;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the ID of the chain the contract is currently deployed on.\\n     * @return The ID of the current chain as a uint256.\\n     */\\n    function getChainId() public view returns (uint256) {\\n        uint256 id;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\\n     * @return bytes32 The domain separator hash.\\n     */\\n    function domainSeparator() public view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                EIP712DOMAIN_TYPEHASH,\\n                keccak256(\\\"NXVWallet\\\"), // name\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\\n     * @param to to address.\\n     * @param value Ether value.\\n     * @param data Data payload.\\n     * @param operation Operation type.\\n     * @param _nonce Transaction nonce.\\n     * @return Transaction hash bytes.\\n     */\\n    function encodeTransactionData(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 _nonce\\n    ) private view returns (bytes memory) {\\n        bytes32 txHash = keccak256(\\n            abi.encode(\\n                TRANSACTION_TYPEHASH,\\n                to,\\n                value,\\n                keccak256(data),\\n                operation,\\n                _nonce\\n            )\\n        );\\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), txHash);\\n    }\\n\\n    /**\\n     * @notice Returns transaction hash to be signed by owners.\\n     * @param to to address.\\n     * @param value Ether value.\\n     * @param data Data payload.\\n     * @param operation Operation type.\\n     * @param _nonce Transaction nonce.\\n     * @return Transaction hash.\\n     */\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 _nonce\\n    ) public view returns (bytes32) {\\n        return keccak256(encodeTransactionData(to, value, data, operation, _nonce));\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/base/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\nimport {Enum} from \\\"../common/Enum.sol\\\";\\n\\n/**\\n * @title Executor - A contract that can execute transactions\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract Executor {\\n    /**\\n     * @notice Executes either a delegatecall or a call with provided parameters.\\n     * @dev This method doesn't perform any sanity check of the transaction, such as:\\n     *      - if the contract at `to` address has code or not\\n     *      It is the responsibility of the caller to perform such checks.\\n     * @param to Destination address.\\n     * @param value Ether value.\\n     * @param data Data payload.\\n     * @param operation Operation type.\\n     * @return success boolean flag indicating if the call succeeded.\\n     */\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        if (operation == Enum.Operation.DelegateCall) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\\n            }\\n        } else {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\\n            }\\n        }\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/base/FallbackManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {SelfAuthorized} from \\\"../common/SelfAuthorized.sol\\\";\\n\\n/**\\n * @title Fallback Manager - A contract managing fallback calls made to this contract\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract FallbackManager is SelfAuthorized {\\n    event ChangedFallbackHandler(address indexed handler);\\n\\n    // keccak256(\\\"fallback_manager.handler.address\\\")\\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\\n\\n    /**\\n     *  @notice Internal function to set the fallback handler.\\n     *  @param handler contract to handle fallback calls.\\n     */\\n    function internalSetFallbackHandler(address handler) internal {\\n        /*\\n            If a fallback handler is set to self, then the following attack vector is opened:\\n            Imagine we have a function like this:\\n            function withdraw() internal authorized {\\n                withdrawalAddress.call.value(address(this).balance)(\\\"\\\");\\n            }\\n\\n            If the fallback method is triggered, the fallback handler appends the msg.sender address to the calldata and calls the fallback handler.\\n            A potential attacker could call a Safe with the 3 bytes signature of a withdraw function. Since 3 bytes do not create a valid signature,\\n            the call would end in a fallback handler. Since it appends the msg.sender address to the calldata, the attacker could craft an address \\n            where the first 3 bytes of the previous calldata + the first byte of the address make up a valid function signature. The subsequent call would result in unsanctioned access to Safe's internal protected methods.\\n            For some reason, solidity matches the first 4 bytes of the calldata to a function signature, regardless if more data follow these 4 bytes.\\n        */\\n        require(handler != address(this), \\\"Fallback handler cannot be self\\\");\\n\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, handler)\\n        }\\n    }\\n\\n    /**\\n     * @notice Set Fallback Handler to `handler` for the Safe.\\n     * @dev Only fallback calls without value and with data will be forwarded.\\n     *      This can only be done via a Safe transaction.\\n     *      Cannot be set to the Safe itself.\\n     * @param handler contract to handle fallback calls.\\n     */\\n    function setFallbackHandler(address handler) public authorized {\\n        internalSetFallbackHandler(handler);\\n        emit ChangedFallbackHandler(handler);\\n    }\\n\\n    // @notice Forwards all calls to the fallback handler if set. Returns 0 if no handler is set.\\n    // @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\\n    //      The handler can make us of `HandlerContext.sol` to extract the address.\\n    //      This is done because in the next call frame the `msg.sender` will be FallbackManager's address\\n    //      and having the original caller address may enable additional verification scenarios.\\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\\n    fallback() external {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let handler := sload(slot)\\n            if iszero(handler) {\\n                return(0, 0)\\n            }\\n            calldatacopy(0, 0, calldatasize())\\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n            // Then the address without padding is stored right after the calldata\\n            mstore(calldatasize(), shl(96, caller()))\\n            // Add 20 bytes for the address appended add the end\\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if iszero(success) {\\n                revert(0, returndatasize())\\n            }\\n            return(0, returndatasize())\\n        }\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/base/OwnerManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\nimport {SelfAuthorized} from \\\"../common/SelfAuthorized.sol\\\";\\n\\n/**\\n * @title OwnerManager - Manages Safe owners and a threshold to authorize transactions.\\n * @dev Uses a linked list to store the owners because the code generate by the solidity compiler\\n *      is more efficient than using a dynamic array.\\n * @author Stefan George - @Georgi87\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract OwnerManager is SelfAuthorized {\\n    event AddedOwner(address indexed owner);\\n    event RemovedOwner(address indexed owner);\\n    event ChangedThreshold(uint256 threshold);\\n\\n    address internal constant SENTINEL_OWNERS = address(0x1);\\n\\n    mapping(address => address) internal owners;\\n    uint256 internal ownerCount;\\n    uint256 internal threshold;\\n\\n    /**\\n     * @notice Sets the initial storage of the contract.\\n     * @param _owners List of Safe owners.\\n     * @param _threshold Number of required confirmations for a Safe transaction.\\n     */\\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\\n        // Threshold can only be 0 at initialization.\\n        // Check ensures that setup function can only be called once.\\n        require(threshold == 0, \\\"Owners set up\\\");\\n        // Validate that threshold is smaller than number of added owners.\\n        require(_threshold <= _owners.length, \\\"Threshold exceed owner count\\\");\\n        // There has to be at least one Safe owner.\\n        require(_threshold >= 1, \\\"Threshold needs greater than 0\\\");\\n        // Initializing Safe owners.\\n        address currentOwner = SENTINEL_OWNERS;\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            // Owner address cannot be null.\\n            address owner = _owners[i];\\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \\\"Invalid owner\\\");\\n            // No duplicate owners allowed.\\n            require(owners[owner] == address(0), \\\"Address is already owner\\\");\\n            owners[currentOwner] = owner;\\n            currentOwner = owner;\\n        }\\n        owners[currentOwner] = SENTINEL_OWNERS;\\n        ownerCount = _owners.length;\\n        threshold = _threshold;\\n    }\\n\\n    /**\\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param owner New owner address.\\n     * @param _threshold New threshold.\\n     */\\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\\n        // Owner address cannot be null, the sentinel or the Safe itself.\\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \\\"Invalid owner\\\");\\n        // No duplicate owners allowed.\\n        require(owners[owner] == address(0), \\\"Address is already owner\\\");\\n        owners[owner] = owners[SENTINEL_OWNERS];\\n        owners[SENTINEL_OWNERS] = owner;\\n        ownerCount++;\\n        emit AddedOwner(owner);\\n        // Change threshold if threshold was changed.\\n        if (threshold != _threshold) changeThreshold(_threshold);\\n    }\\n\\n    /**\\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\\n     * @param owner Owner address to be removed.\\n     * @param _threshold New threshold.\\n     */\\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) public authorized {\\n        // Only allow to remove an owner, if threshold can still be reached.\\n        require(ownerCount - 1 >= _threshold, \\\"Threshold exceed owner count\\\");\\n        // Validate owner address and check that it corresponds to owner index.\\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \\\"Invalid owner\\\");\\n        require(owners[prevOwner] == owner, \\\"Invalid prevOwner, owner\\\");\\n        owners[prevOwner] = owners[owner];\\n        owners[owner] = address(0);\\n        ownerCount--;\\n        emit RemovedOwner(owner);\\n        // Change threshold if threshold was changed.\\n        if (threshold != _threshold) changeThreshold(_threshold);\\n    }\\n\\n    /**\\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\\n     * @param oldOwner Owner address to be replaced.\\n     * @param newOwner New owner address.\\n     */\\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) public authorized {\\n        // Owner address cannot be null, the sentinel or the Safe itself.\\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \\\"Invalid owner\\\");\\n        // No duplicate owners allowed.\\n        require(owners[newOwner] == address(0), \\\"Address is already owner\\\");\\n        // Validate oldOwner address and check that it corresponds to owner index.\\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \\\"Invalid owner\\\");\\n        require(owners[prevOwner] == oldOwner, \\\"Invalid prevOwner, owner\\\");\\n        owners[newOwner] = owners[oldOwner];\\n        owners[prevOwner] = newOwner;\\n        owners[oldOwner] = address(0);\\n        emit RemovedOwner(oldOwner);\\n        emit AddedOwner(newOwner);\\n    }\\n\\n    /**\\n     * @notice Changes the threshold of the Safe to `_threshold`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param _threshold New threshold.\\n     */\\n    function changeThreshold(uint256 _threshold) public authorized {\\n        // Validate that threshold is smaller than number of owners.\\n        require(_threshold <= ownerCount, \\\"Threshold exceed owner count\\\");\\n        // There has to be at least one Safe owner.\\n        require(_threshold >= 1, \\\"Threshold needs greater than 0\\\");\\n        threshold = _threshold;\\n        emit ChangedThreshold(threshold);\\n    }\\n\\n    /**\\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\\n     * @return Threshold number.\\n     */\\n    function getThreshold() public view returns (uint256) {\\n        return threshold;\\n    }\\n\\n    /**\\n     * @notice Returns if `owner` is an owner of the Safe.\\n     * @return Boolean if owner is an owner of the Safe.\\n     */\\n    function isOwner(address owner) public view returns (bool) {\\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\\n    }\\n\\n    /**\\n     * @notice Returns a list of Safe owners.\\n     * @return Array of Safe owners.\\n     */\\n    function getOwners() public view returns (address[] memory) {\\n        address[] memory array = new address[](ownerCount);\\n\\n        // populate return array\\n        uint256 index = 0;\\n        address currentOwner = owners[SENTINEL_OWNERS];\\n        while (currentOwner != SENTINEL_OWNERS) {\\n            array[index] = currentOwner;\\n            currentOwner = owners[currentOwner];\\n            index++;\\n        }\\n        return array;\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/Enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Enum - Collection of enums used in Safe contracts.\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/NativeCurrencyPaymentFallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title NativeCurrencyPaymentFallback - A contract that has a fallback to accept native currency payments.\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract NativeCurrencyPaymentFallback {\\n    event NXVReceived(address indexed sender, uint256 value);\\n\\n    /**\\n     * @notice Receive function accepts native currency transactions.\\n     * @dev Emits an event with sender and received value.\\n     */\\n    receive() external payable {\\n        emit NXVReceived(msg.sender, msg.value);\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/SecuredTokenTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title SecuredTokenTransfer - Secure token transfer.\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract SecuredTokenTransfer {\\n    /**\\n     * @notice Transfers a token and returns a boolean if it was a success\\n     * @dev It checks the return data of the transfer call and returns true if the transfer was successful.\\n     *      It doesn't check if the `token` address is a contract or not.\\n     * @param token Token that should be transferred\\n     * @param receiver Receiver to whom the token should be transferred\\n     * @param amount The amount of tokens that should be transferred\\n     * @return transferred Returns true if the transfer was successful\\n     */\\n    function transferToken(address token, address receiver, uint256 amount) internal returns (bool transferred) {\\n        // 0xa9059cbb - keccack(\\\"transfer(address,uint256)\\\")\\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // We write the return value to scratch space.\\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            switch returndatasize()\\n            case 0 {\\n                transferred := success\\n            }\\n            case 0x20 {\\n                transferred := iszero(or(iszero(success), iszero(mload(0))))\\n            }\\n            default {\\n                transferred := 0\\n            }\\n        }\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/SelfAuthorized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title SelfAuthorized - Authorizes current contract to perform actions to itself.\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract SelfAuthorized {\\n    function requireSelfCall() private view {\\n        require(msg.sender == address(this), \\\"Only be called from this contract\\\");\\n    }\\n\\n    modifier authorized() {\\n        // Modifiers are copied around during compilation. This is a function call as it minimized the bytecode size\\n        requireSelfCall();\\n        _;\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/SignatureDecoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title SignatureDecoder - Decodes signatures encoded as bytes\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract SignatureDecoder {\\n    /**\\n     * @notice Splits signature bytes into `uint8 v, bytes32 r, bytes32 s`.\\n     * @dev Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\\n     *      The signature format is a compact form of {bytes32 r}{bytes32 s}{uint8 v}\\n     *      Compact means uint8 is not padded to 32 bytes.\\n     * @param pos Which signature to read.\\n     *            A prior bounds check of this parameter should be performed, to avoid out of bounds access.\\n     * @param signatures Concatenated {r, s, v} signatures.\\n     * @return v Recovery ID or Safe signature type.\\n     * @return r Output value r of the signature.\\n     * @return s Output value s of the signature.\\n     */\\n    function signatureSplit(bytes memory signatures, uint256 pos) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        /* solhint-disable no-inline-assembly */\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let signaturePos := mul(0x41, pos)\\n            r := mload(add(signatures, add(signaturePos, 0x20)))\\n            s := mload(add(signatures, add(signaturePos, 0x40)))\\n            v := byte(0, mload(add(signatures, add(signaturePos, 0x60))))\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/Singleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Singleton - Base for singleton contracts (should always be the first super contract)\\n *        This contract is tightly coupled to our proxy contract (see `proxies/SafeProxy.sol`)\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract Singleton {\\n    // singleton always has to be the first declared variable to ensure the same location as in the Proxy contract.\\n    // It should also always be ensured the address is stored alone (uses a full word)\\n    address private singleton;\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/common/StorageAccessible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title StorageAccessible - A generic base contract that allows callers to access all internal storage.\\n * @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\\n *         It removes a method from the original contract not needed for the Safe contracts.\\n * @author Gnosis Developers\\n */\\nabstract contract StorageAccessible {\\n    /**\\n     * @notice Reads `length` bytes of storage in the currents contract\\n     * @param offset - the offset in the current contract's storage in words to start reading from\\n     * @param length - the number of words (32 bytes) of data to read\\n     * @return the bytes that were read.\\n     */\\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\\n        bytes memory result = new bytes(length * 32);\\n        for (uint256 index = 0; index < length; index++) {\\n            /* solhint-disable no-inline-assembly */\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let word := sload(add(offset, index))\\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\\n            }\\n            /* solhint-enable no-inline-assembly */\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs a delegatecall on a targetContract in the context of self.\\n     * Internally reverts execution to avoid side effects (making it static).\\n     *\\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\\n     * Specifically, the `returndata` after a call to this method will be:\\n     * `success:bool || response.length:uint256 || response:bytes`.\\n     *\\n     * @param targetContract Address of the contract containing the code to execute.\\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\\n     */\\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\\n        /* solhint-disable no-inline-assembly */\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\\n            // Load free memory location\\n            let ptr := mload(0x40)\\n            mstore(ptr, success)\\n            mstore(add(ptr, 0x20), returndatasize())\\n            returndatacopy(add(ptr, 0x40), 0, returndatasize())\\n            revert(ptr, add(returndatasize(), 0x40))\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/external/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title SafeMath\\n * @notice Math operations with safety checks that revert on error (overflow/underflow)\\n */\\nlibrary SafeMath {\\n    /**\\n     * @notice Multiplies two numbers, reverts on overflow.\\n     * @param a First number\\n     * @param b Second number\\n     * @return Product of a and b\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     * @param a First number\\n     * @param b Second number\\n     * @return Difference of a and b\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Adds two numbers, reverts on overflow.\\n     * @param a First number\\n     * @param b Second number\\n     * @return Sum of a and b\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Returns the largest of two numbers.\\n     * @param a First number\\n     * @param b Second number\\n     * @return Largest of a and b\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/handler/CompatibilityFallbackHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {TokenCallbackHandler} from \\\"./TokenCallbackHandler.sol\\\";\\nimport {ISignatureValidator} from \\\"../interfaces/ISignatureValidator.sol\\\";\\nimport {NXV} from \\\"../NXV.sol\\\";\\nimport {HandlerContext} from \\\"./HandlerContext.sol\\\";\\n\\n/**\\n * @title Compatibility Fallback Handler - Provides compatibility between pre 1.3.0 and 1.3.0+ Safe contracts.\\n * @author Richard Meissner - @rmeissner\\n */\\ncontract CompatibilityFallbackHandler is TokenCallbackHandler, ISignatureValidator, HandlerContext {\\n\\n    // keccak256(\\\"NXVMessage(bytes message)\\\");\\n    bytes32 private constant NXV_MSG_TYPEHASH = 0xdf49db468cf6e89852cc8e0f454403496dae2705e7f81fce587279884ba3c833;\\n\\n    bytes4 internal constant SIMULATE_SELECTOR = bytes4(keccak256(\\\"simulate(address,bytes)\\\"));\\n\\n    // address internal constant SENTINEL_MODULES = address(0x1);\\n\\n    /**\\n     * @dev Returns the hash of a message to be signed by owners.\\n     * @param message Raw message bytes.\\n     * @return Message hash.\\n     */\\n    function getMessageHash(bytes memory message) public view returns (bytes32) {\\n        return getMessageHashForNXV(NXV(payable(msg.sender)), message);\\n    }\\n\\n    /**\\n     * @dev Returns the pre-image of the message hash (see getMessageHashForSafe).\\n     * @param nxv Safe to which the message is targeted.\\n     * @param message Message that should be encoded.\\n     * @return Encoded message.\\n     */\\n    function encodeMessageDataForNXV(NXV nxv, bytes memory message) public view returns (bytes memory) {\\n        bytes32 nxvMessageHash = keccak256(abi.encode(NXV_MSG_TYPEHASH, keccak256(message)));\\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), nxv.domainSeparator(), nxvMessageHash);\\n    }\\n\\n    /**\\n     * @dev Returns hash of a message that can be signed by owners.\\n     * @param nxv Safe to which the message is targeted.\\n     * @param message Message that should be hashed.\\n     * @return Message hash.\\n     */\\n    function getMessageHashForNXV(NXV nxv, bytes memory message) public view returns (bytes32) {\\n        return keccak256(encodeMessageDataForNXV(nxv, message));\\n    }\\n\\n    /**\\n     * @notice Implementation of updated EIP-1271 signature validation method.\\n     * @param _dataHash Hash of the data signed on the behalf of address(msg.sender)\\n     * @param _signature Signature byte array associated with _dataHash\\n     * @return Updated EIP1271 magic value if signature is valid, otherwise 0x0\\n     */\\n    function isValidSignature(bytes32 _dataHash, bytes calldata _signature) public view override returns (bytes4) {\\n        // Caller should be a Safe\\n        NXV nxv = NXV(payable(msg.sender));\\n        bytes memory messageData = encodeMessageDataForNXV(nxv, abi.encode(_dataHash));\\n        bytes32 messageHash = keccak256(messageData);\\n        if (_signature.length == 0) {\\n            require(nxv.signedMessages(messageHash) != 0, \\\"Hash not approved\\\");\\n        } else {\\n            nxv.checkSignatures(messageHash, messageData, _signature);\\n        }\\n        return EIP1271_MAGIC_VALUE;\\n    }\\n\\n    /**\\n     * @dev Performs a delegatecall on a targetContract in the context of self.\\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\\n     * @dev Inspired by https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\\n     * @param targetContract Address of the contract containing the code to execute.\\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\\n     */\\n    function simulate(address targetContract, bytes calldata calldataPayload) external returns (bytes memory response) {\\n        /**\\n         * Suppress compiler warnings about not using parameters, while allowing\\n         * parameters to keep names for documentation purposes. This does not\\n         * generate code.\\n         */\\n        targetContract;\\n        calldataPayload;\\n\\n        /* solhint-disable no-inline-assembly */\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let internalCalldata := mload(0x40)\\n            /**\\n             * Store `simulateAndRevert.selector`.\\n             * String representation is used to force right padding\\n             */\\n            mstore(internalCalldata, \\\"\\\\xb4\\\\xfa\\\\xba\\\\x09\\\")\\n            /**\\n             * Abuse the fact that both this and the internal methods have the\\n             * same signature, and differ only in symbol name (and therefore,\\n             * selector) and copy calldata directly. This saves us approximately\\n             * 250 bytes of code and 300 gas at runtime over the\\n             * `abi.encodeWithSelector` builtin.\\n             */\\n            calldatacopy(add(internalCalldata, 0x04), 0x04, sub(calldatasize(), 0x04))\\n\\n            /**\\n             * `pop` is required here by the compiler, as top level expressions\\n             * can't have return values in inline assembly. `call` typically\\n             * returns a 0 or 1 value indicated whether or not it reverted, but\\n             * since we know it will always revert, we can safely ignore it.\\n             */\\n            pop(\\n                call(\\n                    gas(),\\n                    // address() has been changed to caller() to use the implementation of the Safe\\n                    caller(),\\n                    0,\\n                    internalCalldata,\\n                    calldatasize(),\\n                    /**\\n                     * The `simulateAndRevert` call always reverts, and\\n                     * instead encodes whether or not it was successful in the return\\n                     * data. The first 32-byte word of the return data contains the\\n                     * `success` value, so write it to memory address 0x00 (which is\\n                     * reserved Solidity scratch space and OK to use).\\n                     */\\n                    0x00,\\n                    0x20\\n                )\\n            )\\n\\n            /**\\n             * Allocate and copy the response bytes, making sure to increment\\n             * the free memory pointer accordingly (in case this method is\\n             * called as an internal function). The remaining `returndata[0x20:]`\\n             * contains the ABI encoded response bytes, so we can just write it\\n             * as is to memory.\\n             */\\n            let responseSize := sub(returndatasize(), 0x20)\\n            response := mload(0x40)\\n            mstore(0x40, add(response, responseSize))\\n            returndatacopy(response, 0x20, responseSize)\\n\\n            if iszero(mload(0x00)) {\\n                revert(add(response, 0x20), mload(response))\\n            }\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n\\n    /**\\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\\n     *      The function was moved to the fallback handler as a part of\\n     *      1.5.0 contract upgrade. It used to be a part of the Safe core contract, but\\n     *      was replaced by the same function that accepts the executor as a parameter.\\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     * @param requiredSignatures Amount of required valid signatures.\\n     */\\n    function checkNSignatures(bytes32 dataHash, bytes memory, bytes memory signatures, uint256 requiredSignatures) public view {\\n        NXV(payable(_manager())).checkNSignatures(dataHash, \\\"\\\", signatures, requiredSignatures);\\n        // _manager() is the NXV address\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/handler/HandlerContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Handler Context - Allows the fallback handler to extract addition context from the calldata\\n * @dev The fallback manager appends the following context to the calldata:\\n *      1. Fallback manager caller address (non-padded)\\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract HandlerContext {\\n    /**\\n     * @notice Allows fetching the original caller address.\\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\\n     *      check information against the calling manager.\\n     * @return sender Original caller address.\\n     */\\n    function _msgSender() internal pure returns (address sender) {\\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\\n        /* solhint-disable no-inline-assembly */\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n\\n    /**\\n     * @notice Returns the FallbackManager address\\n     * @return Fallback manager address\\n     */\\n    function _manager() internal view returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/handler/TokenCallbackHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {ERC1155TokenReceiver} from \\\"../interfaces/ERC1155TokenReceiver.sol\\\";\\nimport {ERC721TokenReceiver} from \\\"../interfaces/ERC721TokenReceiver.sol\\\";\\nimport {ERC777TokensRecipient} from \\\"../interfaces/ERC777TokensRecipient.sol\\\";\\nimport {IERC165} from \\\"../interfaces/IERC165.sol\\\";\\n\\n/**\\n * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\\n * @author Richard Meissner - @rmeissner\\n */\\ncontract TokenCallbackHandler is ERC1155TokenReceiver, ERC777TokensRecipient, ERC721TokenReceiver, IERC165 {\\n    /**\\n     * @notice Handles ERC1155 Token callback.\\n     * @return Standardized onERC1155Received return value.\\n     */\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\\n        return 0xf23a6e61;\\n    }\\n\\n    /**\\n     * @notice Handles ERC1155 Token batch callback.\\n     * @return Standardized onERC1155BatchReceived return value.\\n     */\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return 0xbc197c81;\\n    }\\n\\n    /**\\n     * @notice Handles ERC721 Token callback.\\n     * @return Standardized onERC721Received return value.\\n     */\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\\n        return 0x150b7a02;\\n    }\\n\\n    /**\\n     * @notice Handles ERC777 Token callback.\\n     *         return nothing (not standardized)\\n     */\\n    function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure override {\\n        // We implement this for completeness, doesn't really have any value\\n    }\\n\\n    /**\\n     * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\\n     * @param interfaceId Id of the interface.\\n     * @return if the interface is supported.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return\\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\\n            interfaceId == type(ERC721TokenReceiver).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/interfaces/ERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n// Note: The ERC-165 identifier for this interface is 0x4e2312e0.\\ninterface ERC1155TokenReceiver {\\n    /**\\n     * @notice Handle the receipt of a single ERC1155 token type.\\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\\n     *      This function MUST return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\\n     *      This function MUST revert if it rejects the transfer.\\n     *      Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n     * @param _operator  The address which initiated the transfer (i.e. msg.sender).\\n     * @param _from      The address which previously owned the token.\\n     * @param _id        The ID of the token being transferred.\\n     * @param _value     The amount of tokens being transferred.\\n     * @param _data      Additional data with no specified format.\\n     * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`.\\n     */\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @notice Handle the receipt of multiple ERC1155 token types.\\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\\n     *      This function MUST return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\\n     *      This function MUST revert if it rejects the transfer(s).\\n     *      Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n     * @param _operator  The address which initiated the batch transfer (i.e. msg.sender).\\n     * @param _from      The address which previously owned the token.\\n     * @param _ids       An array containing ids of each token being transferred (order and length must match _values array).\\n     * @param _values    An array containing amounts of each token being transferred (order and length must match _ids array).\\n     * @param _data      Additional data with no specified format.\\n     * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`.\\n     */\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address _from,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/interfaces/ERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface ERC721TokenReceiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     *  after a `transfer`. This function MAY throw to revert and reject the\\n     *  transfer. Return of other than the magic value MUST result in the\\n     *  transaction being reverted.\\n     *  Note: the contract address is always the message sender.\\n     * @param _operator The address which called `safeTransferFrom` function.\\n     * @param _from The address which previously owned the token.\\n     * @param _tokenId The NFT identifier which is being transferred.\\n     * @param _data Additional data with no specified format.\\n     * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n     *  unless throwing\\n     */\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/interfaces/ERC777TokensRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title ERC777TokensRecipient\\n * @dev Interface for contracts that will be called with the ERC777 token's `tokensReceived` method.\\n * The contract receiving the tokens must implement this interface in order to receive the tokens.\\n */\\ninterface ERC777TokensRecipient {\\n    /**\\n     * @dev Called by the ERC777 token contract after a successful transfer or a minting operation.\\n     * @param operator The address of the operator performing the transfer or minting operation.\\n     * @param from The address of the sender.\\n     * @param to The address of the recipient.\\n     * @param amount The amount of tokens that were transferred or minted.\\n     * @param data Additional data that was passed during the transfer or minting operation.\\n     * @param operatorData Additional data that was passed by the operator during the transfer or minting operation.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n     * See the corresponding EIP section\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n// .\"\r\n    },\r\n    \"contracts/interfaces/ISignatureValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n/* solhint-disable one-contract-per-file */\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract ISignatureValidatorConstants {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\\n}\\n\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\n    /**\\n     * @notice EIP1271 method to validate a signature.\\n     * @param _hash Hash of the data signed on the behalf of address(this).\\n     * @param _signature Signature byte array associated with _data.\\n     *\\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view virtual returns (bytes4);\\n}\\n\\n// .\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"requiredSignatures\",\"type\":\"uint256\"}],\"name\":\"checkNSignatures\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract NXV\",\"name\":\"nxv\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"encodeMessageDataForNXV\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract NXV\",\"name\":\"nxv\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getMessageHashForNXV\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldataPayload\",\"type\":\"bytes\"}],\"name\":\"simulate\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "CompatibilityFallbackHandler", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}