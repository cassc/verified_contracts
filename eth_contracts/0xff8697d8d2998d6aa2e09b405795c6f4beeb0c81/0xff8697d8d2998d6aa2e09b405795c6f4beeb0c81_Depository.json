{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Depository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IErrorsTokenomics} from \\\"./interfaces/IErrorsTokenomics.sol\\\";\\nimport {IGenericBondCalculator} from \\\"./interfaces/IGenericBondCalculator.sol\\\";\\nimport {IToken} from \\\"./interfaces/IToken.sol\\\";\\nimport {ITokenomics} from \\\"./interfaces/ITokenomics.sol\\\";\\nimport {ITreasury} from \\\"./interfaces/ITreasury.sol\\\";\\n\\n/*\\n* In this contract we consider OLAS tokens. The initial numbers will be as follows:\\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\\n*  - After 10 years, the inflation rate is capped at 2% per year.\\n* Starting from a year 11, the maximum number of tokens that can be reached per the year x is 1e27 * (1.02)^x.\\n* To make sure that a unit(n) does not overflow the total supply during the year x, we have to check that\\n* 2^n - 1 >= 1e27 * (1.02)^x. We limit n by 96, thus it would take 220+ years to reach that total supply.\\n*\\n* We then limit each time variable to last until the value of 2^32 - 1 in seconds.\\n* 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970.\\n* Thus, this counter is safe until the year 2106.\\n*\\n* The number of blocks cannot be practically bigger than the number of seconds, since there is more than one second\\n* in a block. Thus, it is safe to assume that uint32 for the number of blocks is also sufficient.\\n*\\n* In conclusion, this contract is only safe to use until 2106.\\n*/\\n\\n// The size of the struct is 160 + 96 + 32 * 2 = 256 + 64 (2 slots)\\nstruct Bond {\\n    // Account address\\n    address account;\\n    // OLAS remaining to be paid out\\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\\n    uint96 payout;\\n    // Bond maturity time\\n    // 2^32 - 1 is enough to count 136 years starting from the year of 1970. This counter is safe until the year of 2106\\n    uint32 maturity;\\n    // Product Id of a bond\\n    // We assume that the number of products will not be bigger than the number of seconds\\n    uint32 productId;\\n}\\n\\n// The size of the struct is 160 + 32 + 160 + 96 = 256 + 192 (2 slots)\\nstruct Product {\\n    // priceLP (reserve0 / totalSupply or reserve1 / totalSupply) with 18 additional decimals\\n    // priceLP = 2 * r0/L * 10^18 = 2*r0*10^18/sqrt(r0*r1) ~= 61 + 96 - sqrt(96 * 112) ~= 53 bits (if LP is balanced)\\n    // or 2* r0/sqrt(r0) * 10^18 => 87 bits + 60 bits = 147 bits (if LP is unbalanced)\\n    uint160 priceLP;\\n    // Bond vesting time\\n    // 2^32 - 1 is enough to count 136 years starting from the year of 1970. This counter is safe until the year of 2106\\n    uint32 vesting;\\n    // Token to accept as a payment\\n    address token;\\n    // Supply of remaining OLAS tokens\\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\\n    uint96 supply;\\n}\\n\\n/// @title Bond Depository - Smart contract for OLAS Bond Depository\\n/// @author AL\\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\\ncontract Depository is IErrorsTokenomics {\\n    event OwnerUpdated(address indexed owner);\\n    event TokenomicsUpdated(address indexed tokenomics);\\n    event TreasuryUpdated(address indexed treasury);\\n    event BondCalculatorUpdated(address indexed bondCalculator);\\n    event CreateBond(address indexed token, uint256 indexed productId, address indexed owner, uint256 bondId,\\n        uint256 amountOLAS, uint256 tokenAmount, uint256 maturity);\\n    event RedeemBond(uint256 indexed productId, address indexed owner, uint256 bondId);\\n    event CreateProduct(address indexed token, uint256 indexed productId, uint256 supply, uint256 priceLP,\\n        uint256 vesting);\\n    event CloseProduct(address indexed token, uint256 indexed productId, uint256 supply);\\n\\n    // Minimum bond vesting value\\n    uint256 public constant MIN_VESTING = 1 days;\\n    // Depository version number\\n    string public constant VERSION = \\\"1.0.1\\\";\\n    \\n    // Owner address\\n    address public owner;\\n    // Individual bond counter\\n    // We assume that the number of bonds will not be bigger than the number of seconds\\n    uint32 public bondCounter;\\n    // Bond product counter\\n    // We assume that the number of products will not be bigger than the number of seconds\\n    uint32 public productCounter;\\n\\n    // OLAS token address\\n    address public immutable olas;\\n    // Tkenomics contract address\\n    address public tokenomics;\\n    // Treasury contract address\\n    address public treasury;\\n    // Bond Calculator contract address\\n    address public bondCalculator;\\n\\n    // Mapping of bond Id => account bond instance\\n    mapping(uint256 => Bond) public mapUserBonds;\\n    // Mapping of product Id => bond product instance\\n    mapping(uint256 => Product) public mapBondProducts;\\n\\n    /// @dev Depository constructor.\\n    /// @param _olas OLAS token address.\\n    /// @param _treasury Treasury address.\\n    /// @param _tokenomics Tokenomics address.\\n    constructor(address _olas, address _tokenomics, address _treasury, address _bondCalculator)\\n    {\\n        owner = msg.sender;\\n\\n        // Check for at least one zero contract address\\n        if (_olas == address(0) || _tokenomics == address(0) || _treasury == address(0) || _bondCalculator == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        olas = _olas;\\n        tokenomics = _tokenomics;\\n        treasury = _treasury;\\n        bondCalculator = _bondCalculator;\\n    }\\n\\n    /// @dev Changes the owner address.\\n    /// @param newOwner Address of a new owner.\\n    /// #if_succeeds {:msg \\\"Changing owner\\\"} old(owner) == msg.sender ==> owner == newOwner;\\n    function changeOwner(address newOwner) external {\\n        // Check for the contract ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Check for the zero address\\n        if (newOwner == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        owner = newOwner;\\n        emit OwnerUpdated(newOwner);\\n    }\\n\\n    /// @dev Changes various managing contract addresses.\\n    /// @param _tokenomics Tokenomics address.\\n    /// @param _treasury Treasury address.\\n    /// #if_succeeds {:msg \\\"tokenomics changed\\\"} _tokenomics != address(0) ==> tokenomics == _tokenomics;\\n    /// #if_succeeds {:msg \\\"treasury changed\\\"} _treasury != address(0) ==> treasury == _treasury;\\n    function changeManagers(address _tokenomics, address _treasury) external {\\n        // Check for the contract ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Change Tokenomics contract address\\n        if (_tokenomics != address(0)) {\\n            tokenomics = _tokenomics;\\n            emit TokenomicsUpdated(_tokenomics);\\n        }\\n        // Change Treasury contract address\\n        if (_treasury != address(0)) {\\n            treasury = _treasury;\\n            emit TreasuryUpdated(_treasury);\\n        }\\n    }\\n\\n    /// @dev Changes Bond Calculator contract address\\n    /// #if_succeeds {:msg \\\"bondCalculator changed\\\"} _bondCalculator != address(0) ==> bondCalculator == _bondCalculator;\\n    function changeBondCalculator(address _bondCalculator) external {\\n        // Check for the contract ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        if (_bondCalculator != address(0)) {\\n            bondCalculator = _bondCalculator;\\n            emit BondCalculatorUpdated(_bondCalculator);\\n        }\\n    }\\n\\n    /// @dev Creates a new bond product.\\n    /// @param token LP token to be deposited for pairs like OLAS-DAI, OLAS-ETH, etc.\\n    /// @param priceLP LP token price with 18 additional decimals.\\n    /// @param supply Supply in OLAS tokens.\\n    /// @param vesting Vesting period (in seconds).\\n    /// @return productId New bond product Id.\\n    /// #if_succeeds {:msg \\\"productCounter increases\\\"} productCounter == old(productCounter) + 1;\\n    /// #if_succeeds {:msg \\\"isActive\\\"} mapBondProducts[productId].supply > 0 && mapBondProducts[productId].vesting == vesting;\\n    function create(address token, uint256 priceLP, uint256 supply, uint256 vesting) external returns (uint256 productId) {\\n        // Check for the contract ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Check for the pool liquidity as the LP price being greater than zero\\n        if (priceLP == 0) {\\n            revert ZeroValue();\\n        }\\n\\n        // Check the priceLP limit value\\n        if (priceLP > type(uint160).max) {\\n            revert Overflow(priceLP, type(uint160).max);\\n        }\\n\\n        // Check that the supply is greater than zero\\n        if (supply == 0) {\\n            revert ZeroValue();\\n        }\\n\\n        // Check the supply limit value\\n        if (supply > type(uint96).max) {\\n            revert Overflow(supply, type(uint96).max);\\n        }\\n\\n        // Check the vesting minimum limit value\\n        if (vesting < MIN_VESTING) {\\n            revert LowerThan(vesting, MIN_VESTING);\\n        }\\n\\n        // Check for the maturity time overflow for the current timestamp\\n        uint256 maturity = block.timestamp + vesting;\\n        if (maturity > type(uint32).max) {\\n            revert Overflow(maturity, type(uint32).max);\\n        }\\n\\n        // Check if the LP token is enabled\\n        if (!ITreasury(treasury).isEnabled(token)) {\\n            revert UnauthorizedToken(token);\\n        }\\n\\n        // Check if the bond amount is beyond the limits\\n        if (!ITokenomics(tokenomics).reserveAmountForBondProgram(supply)) {\\n            revert LowerThan(ITokenomics(tokenomics).effectiveBond(), supply);\\n        }\\n\\n        // Push newly created bond product into the list of products\\n        productId = productCounter;\\n        mapBondProducts[productId] = Product(uint160(priceLP), uint32(vesting), token, uint96(supply));\\n        // Even if we create a bond product every second, 2^32 - 1 is enough for the next 136 years\\n        productCounter = uint32(productId + 1);\\n        emit CreateProduct(token, productId, supply, priceLP, vesting);\\n    }\\n\\n    /// @dev Closes bonding products.\\n    /// @notice This will terminate programs regardless of their vesting time.\\n    /// @param productIds Set of product Ids.\\n    /// @return closedProductIds Set of closed product Ids.\\n    /// #if_succeeds {:msg \\\"productCounter not touched\\\"} productCounter == old(productCounter);\\n    /// #if_succeeds {:msg \\\"success closed\\\"} forall (uint k in productIds) mapBondProducts[productIds[k]].vesting == 0 && mapBondProducts[productIds[k]].supply == 0;\\n    function close(uint256[] memory productIds) external returns (uint256[] memory closedProductIds) {\\n        // Check for the contract ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Calculate the number of closed products\\n        uint256 numProducts = productIds.length;\\n        uint256[] memory ids = new uint256[](numProducts);\\n        uint256 numClosedProducts;\\n        // Traverse to close all possible products\\n        for (uint256 i = 0; i < numProducts; ++i) {\\n            uint256 productId = productIds[i];\\n            // Check if the product is still open by getting its supply amount\\n            uint256 supply = mapBondProducts[productId].supply;\\n            // The supply is greater than zero only if the product is active, otherwise it is already closed\\n            if (supply > 0) {\\n                // Refund unused OLAS supply from the product if it was not used by the product completely\\n                ITokenomics(tokenomics).refundFromBondProgram(supply);\\n                address token = mapBondProducts[productId].token;\\n                delete mapBondProducts[productId];\\n\\n                ids[numClosedProducts] = productIds[i];\\n                ++numClosedProducts;\\n                emit CloseProduct(token, productId, supply);\\n            }\\n        }\\n\\n        // Get the correct array size of closed product Ids\\n        closedProductIds = new uint256[](numClosedProducts);\\n        for (uint256 i = 0; i < numClosedProducts; ++i) {\\n            closedProductIds[i] = ids[i];\\n        }\\n    }\\n\\n    /// @dev Deposits tokens in exchange for a bond from a specified product.\\n    /// @param productId Product Id.\\n    /// @param tokenAmount Token amount to deposit for the bond.\\n    /// @return payout The amount of OLAS tokens due.\\n    /// @return maturity Timestamp for payout redemption.\\n    /// @return bondId Id of a newly created bond.\\n    /// #if_succeeds {:msg \\\"token is valid\\\"} mapBondProducts[productId].token != address(0);\\n    /// #if_succeeds {:msg \\\"input supply is non-zero\\\"} old(mapBondProducts[productId].supply) > 0 && mapBondProducts[productId].supply <= type(uint96).max;\\n    /// #if_succeeds {:msg \\\"vesting is non-zero\\\"} mapBondProducts[productId].vesting > 0 && mapBondProducts[productId].vesting + block.timestamp <= type(uint32).max;\\n    /// #if_succeeds {:msg \\\"bond Id\\\"} bondCounter == old(bondCounter) + 1 && bondCounter <= type(uint32).max;\\n    /// #if_succeeds {:msg \\\"payout\\\"} old(mapBondProducts[productId].supply) == mapBondProducts[productId].supply + payout;\\n    /// #if_succeeds {:msg \\\"OLAS balances\\\"} IToken(mapBondProducts[productId].token).balanceOf(treasury) == old(IToken(mapBondProducts[productId].token).balanceOf(treasury)) + tokenAmount;\\n    function deposit(uint256 productId, uint256 tokenAmount) external\\n        returns (uint256 payout, uint256 maturity, uint256 bondId)\\n    {\\n        // Check the token amount\\n        if (tokenAmount == 0) {\\n            revert ZeroValue();\\n        }\\n\\n        // Get the bonding product\\n        Product storage product = mapBondProducts[productId];\\n\\n        // Check for the product supply, which is zero if the product was closed or never existed\\n        uint256 supply = product.supply;\\n        if (supply == 0) {\\n            revert ProductClosed(productId);\\n        }\\n\\n        // Calculate the bond maturity based on its vesting time\\n        maturity = block.timestamp + product.vesting;\\n        // Check for the time limits\\n        if (maturity > type(uint32).max) {\\n            revert Overflow(maturity, type(uint32).max);\\n        }\\n\\n        // Get the LP token address\\n        address token = product.token;\\n\\n        // Calculate the payout in OLAS tokens based on the LP pair with the discount factor (DF) calculation\\n        // Note that payout cannot be zero since the price LP is non-zero, otherwise the product would not be created\\n        payout = IGenericBondCalculator(bondCalculator).calculatePayoutOLAS(tokenAmount, product.priceLP);\\n\\n        // Check for the sufficient supply\\n        if (payout > supply) {\\n            revert ProductSupplyLow(token, productId, payout, supply);\\n        }\\n\\n        // Decrease the supply for the amount of payout\\n        supply -= payout;\\n        product.supply = uint96(supply);\\n\\n        // Create and add a new bond, update the bond counter\\n        bondId = bondCounter;\\n        mapUserBonds[bondId] = Bond(msg.sender, uint96(payout), uint32(maturity), uint32(productId));\\n        bondCounter = uint32(bondId + 1);\\n\\n        // Deposit that token amount to mint OLAS tokens in exchange\\n        ITreasury(treasury).depositTokenForOLAS(msg.sender, tokenAmount, token, payout);\\n\\n        // Close the product if the supply becomes zero\\n        if (supply == 0) {\\n            delete mapBondProducts[productId];\\n            emit CloseProduct(token, productId, supply);\\n        }\\n\\n        emit CreateBond(token, productId, msg.sender, bondId, payout, tokenAmount, maturity);\\n    }\\n\\n    /// @dev Redeems account bonds.\\n    /// @param bondIds Bond Ids to redeem.\\n    /// @return payout Total payout sent in OLAS tokens.\\n    /// #if_succeeds {:msg \\\"payout > 0\\\"} payout > 0;\\n    /// #if_succeeds {:msg \\\"msg.sender is the only owner\\\"} old(forall (uint k in bondIds) mapUserBonds[bondIds[k]].account == msg.sender);\\n    /// #if_succeeds {:msg \\\"accounts deleted\\\"} forall (uint k in bondIds) mapUserBonds[bondIds[k]].account == address(0);\\n    /// #if_succeeds {:msg \\\"payouts are zeroed\\\"} forall (uint k in bondIds) mapUserBonds[bondIds[k]].payout == 0;\\n    /// #if_succeeds {:msg \\\"maturities are zeroed\\\"} forall (uint k in bondIds) mapUserBonds[bondIds[k]].maturity == 0;\\n    function redeem(uint256[] memory bondIds) external returns (uint256 payout) {\\n        for (uint256 i = 0; i < bondIds.length; ++i) {\\n            // Get the amount to pay and the maturity status\\n            uint256 pay = mapUserBonds[bondIds[i]].payout;\\n            bool matured = block.timestamp >= mapUserBonds[bondIds[i]].maturity;\\n\\n            // Revert if the bond does not exist or is not matured yet\\n            if (pay == 0 || !matured) {\\n                revert BondNotRedeemable(bondIds[i]);\\n            }\\n\\n            // Check that the msg.sender is the owner of the bond\\n            if (mapUserBonds[bondIds[i]].account != msg.sender) {\\n                revert OwnerOnly(msg.sender, mapUserBonds[bondIds[i]].account);\\n            }\\n\\n            // Increase the payout\\n            payout += pay;\\n\\n            // Get the productId\\n            uint256 productId = mapUserBonds[bondIds[i]].productId;\\n\\n            // Delete the Bond struct and release the gas\\n            delete mapUserBonds[bondIds[i]];\\n            emit RedeemBond(productId, msg.sender, bondIds[i]);\\n        }\\n\\n        // Check for the non-zero payout\\n        if (payout == 0) {\\n            revert ZeroValue();\\n        }\\n\\n        // No reentrancy risk here since it's the last operation, and originated from the OLAS token\\n        // No need to check for the return value, since it either reverts or returns true, see the ERC20 implementation\\n        IToken(olas).transfer(msg.sender, payout);\\n    }\\n\\n    /// @dev Gets an array of active or inactive product Ids.\\n    /// @param active Flag to select active or inactive products.\\n    /// @return productIds Product Ids.\\n    function getProducts(bool active) external view returns (uint256[] memory productIds) {\\n        // Calculate the number of existing products\\n        uint256 numProducts = productCounter;\\n        bool[] memory positions = new bool[](numProducts);\\n        uint256 numSelectedProducts;\\n        // Traverse to find requested products\\n        for (uint256 i = 0; i < numProducts; ++i) {\\n            // Product is always active if its supply is not zero, and inactive otherwise\\n            if ((active && mapBondProducts[i].supply > 0) || (!active && mapBondProducts[i].supply == 0)) {\\n                positions[i] = true;\\n                ++numSelectedProducts;\\n            }\\n        }\\n\\n        // Form active or inactive products index array\\n        productIds = new uint256[](numSelectedProducts);\\n        uint256 numPos;\\n        for (uint256 i = 0; i < numProducts; ++i) {\\n            if (positions[i]) {\\n                productIds[numPos] = i;\\n                ++numPos;\\n            }\\n        }\\n    }\\n\\n    /// @dev Gets activity information about a given product.\\n    /// @param productId Product Id.\\n    /// @return status True if the product is active.\\n    function isActiveProduct(uint256 productId) external view returns (bool status) {\\n        status = (mapBondProducts[productId].supply > 0);\\n    }\\n\\n    /// @dev Gets bond Ids for the account address.\\n    /// @param account Account address to query bonds for.\\n    /// @param matured Flag to get matured bonds only or all of them.\\n    /// @return bondIds Bond Ids.\\n    /// @return payout Cumulative expected OLAS payout.\\n    /// #if_succeeds {:msg \\\"matured bonds\\\"} matured == true ==> forall (uint k in bondIds)\\n    /// mapUserBonds[bondIds[k]].account == account && block.timestamp >= mapUserBonds[bondIds[k]].maturity;\\n    function getBonds(address account, bool matured) external view\\n        returns (uint256[] memory bondIds, uint256 payout)\\n    {\\n        // Check the address\\n        if (account == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        uint256 numAccountBonds;\\n        // Calculate the number of pending bonds\\n        uint256 numBonds = bondCounter;\\n        bool[] memory positions = new bool[](numBonds);\\n        // Record the bond number if it belongs to the account address and was not yet redeemed\\n        for (uint256 i = 0; i < numBonds; ++i) {\\n            // Check if the bond belongs to the account\\n            // If not and the address is zero, the bond was redeemed or never existed\\n            if (mapUserBonds[i].account == account) {\\n                // Check if requested bond is not matured but owned by the account address\\n                if (!matured ||\\n                    // Or if the requested bond is matured, i.e., the bond maturity timestamp passed\\n                    block.timestamp >= mapUserBonds[i].maturity)\\n                {\\n                    positions[i] = true;\\n                    ++numAccountBonds;\\n                    // The payout is always bigger than zero if the bond exists\\n                    payout += mapUserBonds[i].payout;\\n                }\\n            }\\n        }\\n\\n        // Form pending bonds index array\\n        bondIds = new uint256[](numAccountBonds);\\n        uint256 numPos;\\n        for (uint256 i = 0; i < numBonds; ++i) {\\n            if (positions[i]) {\\n                bondIds[numPos] = i;\\n                ++numPos;\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates the maturity and payout to claim for a single bond.\\n    /// @param bondId The account bond Id.\\n    /// @return payout The payout amount in OLAS.\\n    /// @return matured True if the payout can be redeemed.\\n    function getBondStatus(uint256 bondId) external view returns (uint256 payout, bool matured) {\\n        payout = mapUserBonds[bondId].payout;\\n        // If payout is zero, the bond has been redeemed or never existed\\n        if (payout > 0) {\\n            matured = block.timestamp >= mapUserBonds[bondId].maturity;\\n        }\\n    }\\n\\n    /// @dev Gets current reserves of OLAS / totalSupply of LP tokens.\\n    /// @param token Token address.\\n    /// @return priceLP Resulting reserveX / totalSupply ratio with 18 decimals.\\n    function getCurrentPriceLP(address token) external view returns (uint256 priceLP) {\\n        return IGenericBondCalculator(bondCalculator).getCurrentPriceLP(token);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IErrorsTokenomics.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @dev Errors.\\ninterface IErrorsTokenomics {\\n    /// @dev Only `manager` has a privilege, but the `sender` was provided.\\n    /// @param sender Sender address.\\n    /// @param manager Required sender address as a manager.\\n    error ManagerOnly(address sender, address manager);\\n\\n    /// @dev Only `owner` has a privilege, but the `sender` was provided.\\n    /// @param sender Sender address.\\n    /// @param owner Required sender address as an owner.\\n    error OwnerOnly(address sender, address owner);\\n\\n    /// @dev Provided zero address.\\n    error ZeroAddress();\\n\\n    /// @dev Wrong length of two arrays.\\n    /// @param numValues1 Number of values in a first array.\\n    /// @param numValues2 Number of values in a second array.\\n    error WrongArrayLength(uint256 numValues1, uint256 numValues2);\\n\\n    /// @dev Service Id does not exist in registry records.\\n    /// @param serviceId Service Id.\\n    error ServiceDoesNotExist(uint256 serviceId);\\n\\n    /// @dev Zero value when it has to be different from zero.\\n    error ZeroValue();\\n\\n    /// @dev Non-zero value when it has to be zero.\\n    error NonZeroValue();\\n\\n    /// @dev Value overflow.\\n    /// @param provided Overflow value.\\n    /// @param max Maximum possible value.\\n    error Overflow(uint256 provided, uint256 max);\\n\\n    /// @dev Service was never deployed.\\n    /// @param serviceId Service Id.\\n    error ServiceNeverDeployed(uint256 serviceId);\\n\\n    /// @dev Token is disabled or not whitelisted.\\n    /// @param tokenAddress Address of a token.\\n    error UnauthorizedToken(address tokenAddress);\\n\\n    /// @dev Provided token address is incorrect.\\n    /// @param provided Provided token address.\\n    /// @param expected Expected token address.\\n    error WrongTokenAddress(address provided, address expected);\\n\\n    /// @dev Bond is not redeemable (does not exist or not matured).\\n    /// @param bondId Bond Id.\\n    error BondNotRedeemable(uint256 bondId);\\n\\n    /// @dev The product is expired.\\n    /// @param tokenAddress Address of a token.\\n    /// @param productId Product Id.\\n    /// @param deadline The program expiry time.\\n    /// @param curTime Current timestamp.\\n    error ProductExpired(address tokenAddress, uint256 productId, uint256 deadline, uint256 curTime);\\n\\n    /// @dev The product is already closed.\\n    /// @param productId Product Id.\\n    error ProductClosed(uint256 productId);\\n\\n    /// @dev The product supply is low for the requested payout.\\n    /// @param tokenAddress Address of a token.\\n    /// @param productId Product Id.\\n    /// @param requested Requested payout.\\n    /// @param actual Actual supply left.\\n    error ProductSupplyLow(address tokenAddress, uint256 productId, uint256 requested, uint256 actual);\\n\\n    /// @dev Received lower value than the expected one.\\n    /// @param provided Provided value is lower.\\n    /// @param expected Expected value.\\n    error LowerThan(uint256 provided, uint256 expected);\\n\\n    /// @dev Wrong amount received / provided.\\n    /// @param provided Provided amount.\\n    /// @param expected Expected amount.\\n    error WrongAmount(uint256 provided, uint256 expected);\\n\\n    /// @dev Insufficient token allowance.\\n    /// @param provided Provided amount.\\n    /// @param expected Minimum expected amount.\\n    error InsufficientAllowance(uint256 provided, uint256 expected);\\n\\n    /// @dev Failure of a transfer.\\n    /// @param token Address of a token.\\n    /// @param from Address `from`.\\n    /// @param to Address `to`.\\n    /// @param amount Token amount.\\n    error TransferFailed(address token, address from, address to, uint256 amount);\\n\\n    /// @dev Incentives claim has failed.\\n    /// @param account Account address.\\n    /// @param reward Reward amount.\\n    /// @param topUp Top-up amount.\\n    error ClaimIncentivesFailed(address account, uint256 reward, uint256 topUp);\\n\\n    /// @dev Caught reentrancy violation.\\n    error ReentrancyGuard();\\n\\n    /// @dev Failure of treasury re-balance during the reward allocation.\\n    /// @param epochNumber Epoch number.\\n    error TreasuryRebalanceFailed(uint256 epochNumber);\\n\\n    /// @dev Operation with a wrong component / agent Id.\\n    /// @param unitId Component / agent Id.\\n    /// @param unitType Type of the unit (component / agent).\\n    error WrongUnitId(uint256 unitId, uint256 unitType);\\n\\n    /// @dev The donator address is blacklisted.\\n    /// @param account Donator account address.\\n    error DonatorBlacklisted(address account);\\n\\n    /// @dev The contract is already initialized.\\n    error AlreadyInitialized();\\n\\n    /// @dev The contract has to be delegate-called via proxy.\\n    error DelegatecallOnly();\\n\\n    /// @dev The contract is paused.\\n    error Paused();\\n\\n    /// @dev Caught an operation that is not supposed to happen in the same block.\\n    error SameBlockNumberViolation();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGenericBondCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @dev Interface for generic bond calculator.\\ninterface IGenericBondCalculator {\\n    /// @dev Calculates the amount of OLAS tokens based on the bonding calculator mechanism.\\n    /// @param tokenAmount LP token amount.\\n    /// @param priceLP LP token price.\\n    /// @return amountOLAS Resulting amount of OLAS tokens.\\n    function calculatePayoutOLAS(uint256 tokenAmount, uint256 priceLP) external view\\n        returns (uint256 amountOLAS);\\n\\n    /// @dev Get reserveX/reserveY at the time of product creation.\\n    /// @param token Token address.\\n    /// @return priceLP Resulting reserve ratio.\\n    function getCurrentPriceLP(address token) external view returns (uint256 priceLP);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @dev Generic token interface for IERC20 and IERC721 tokens.\\ninterface IToken {\\n    /// @dev Gets the amount of tokens owned by a specified account.\\n    /// @param account Account address.\\n    /// @return Amount of tokens owned.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @dev Gets the owner of the token Id.\\n    /// @param tokenId Token Id.\\n    /// @return Token Id owner address.\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Gets the total amount of tokens stored by the contract.\\n    /// @return Amount of tokens.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @dev Transfers the token amount.\\n    /// @param to Address to transfer to.\\n    /// @param amount The amount to transfer.\\n    /// @return True if the function execution is successful.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @dev Gets remaining number of tokens that the `spender` can transfer on behalf of `owner`.\\n    /// @param owner Token owner.\\n    /// @param spender Account address that is able to transfer tokens on behalf of the owner.\\n    /// @return Token amount allowed to be transferred.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    /// @param spender Account address that will be able to transfer tokens on behalf of the caller.\\n    /// @param amount Token amount.\\n    /// @return True if the function execution is successful.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @dev Transfers the token amount that was previously approved up until the maximum allowance.\\n    /// @param from Account address to transfer from.\\n    /// @param to Account address to transfer to.\\n    /// @param amount Amount to transfer to.\\n    /// @return True if the function execution is successful.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenomics.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @dev Interface for tokenomics management.\\ninterface ITokenomics {\\n    /// @dev Gets effective bond (bond left).\\n    /// @return Effective bond.\\n    function effectiveBond() external pure returns (uint256);\\n\\n    /// @dev Record global data to the checkpoint\\n    function checkpoint() external returns (bool);\\n\\n    /// @dev Tracks the deposited ETH service donations during the current epoch.\\n    /// @notice This function is only called by the treasury where the validity of arrays and values has been performed.\\n    /// @param donator Donator account address.\\n    /// @param serviceIds Set of service Ids.\\n    /// @param amounts Correspondent set of ETH amounts provided by services.\\n    /// @param donationETH Overall service donation amount in ETH.\\n    function trackServiceDonations(\\n        address donator,\\n        uint256[] memory serviceIds,\\n        uint256[] memory amounts,\\n        uint256 donationETH\\n    ) external;\\n\\n    /// @dev Reserves OLAS amount from the effective bond to be minted during a bond program.\\n    /// @notice Programs exceeding the limit in the epoch are not allowed.\\n    /// @param amount Requested amount for the bond program.\\n    /// @return True if effective bond threshold is not reached.\\n    function reserveAmountForBondProgram(uint256 amount) external returns(bool);\\n\\n    /// @dev Refunds unused bond program amount.\\n    /// @param amount Amount to be refunded from the bond program.\\n    function refundFromBondProgram(uint256 amount) external;\\n\\n    /// @dev Gets component / agent owner incentives and clears the balances.\\n    /// @param account Account address.\\n    /// @param unitTypes Set of unit types (component / agent).\\n    /// @param unitIds Set of corresponding unit Ids where account is the owner.\\n    /// @return reward Reward amount.\\n    /// @return topUp Top-up amount.\\n    function accountOwnerIncentives(address account, uint256[] memory unitTypes, uint256[] memory unitIds) external\\n        returns (uint256 reward, uint256 topUp);\\n\\n    /// @dev Gets inverse discount factor with the multiple of 1e18 of the last epoch.\\n    /// @return idf Discount factor with the multiple of 1e18.\\n    function getLastIDF() external view returns (uint256 idf);\\n\\n    /// @dev Gets the service registry contract address\\n    /// @return Service registry contract address;\\n    function serviceRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @dev Interface for treasury management.\\ninterface ITreasury {\\n    /// @dev Allows approved address to deposit an asset for OLAS.\\n    /// @param account Account address making a deposit of LP tokens for OLAS.\\n    /// @param tokenAmount Token amount to get OLAS for.\\n    /// @param token Token address.\\n    /// @param olaMintAmount Amount of OLAS token issued.\\n    function depositTokenForOLAS(address account, uint256 tokenAmount, address token, uint256 olaMintAmount) external;\\n\\n    /// @dev Deposits service donations in ETH.\\n    /// @param serviceIds Set of service Ids.\\n    /// @param amounts Set of corresponding amounts deposited on behalf of each service Id.\\n    function depositServiceDonationsETH(uint256[] memory serviceIds, uint256[] memory amounts) external payable;\\n\\n    /// @dev Gets information about token being enabled.\\n    /// @param token Token address.\\n    /// @return enabled True is token is enabled.\\n    function isEnabled(address token) external view returns (bool enabled);\\n\\n    /// @dev Withdraws ETH and / or OLAS amounts to the requested account address.\\n    /// @notice Only dispenser contract can call this function.\\n    /// @notice Reentrancy guard is on a dispenser side.\\n    /// @notice Zero account address is not possible, since the dispenser contract interacts with msg.sender.\\n    /// @param account Account address.\\n    /// @param accountRewards Amount of account rewards.\\n    /// @param accountTopUps Amount of account top-ups.\\n    /// @return success True if the function execution is successful.\\n    function withdrawToAccount(address account, uint256 accountRewards, uint256 accountTopUps) external returns (bool success);\\n\\n    /// @dev Re-balances treasury funds to account for the treasury reward for a specific epoch.\\n    /// @param treasuryRewards Treasury rewards.\\n    /// @return success True, if the function execution is successful.\\n    function rebalanceTreasury(uint256 treasuryRewards) external returns (bool success);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_olas\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenomics\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bondCalculator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"}],\"name\":\"BondNotRedeemable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"topUp\",\"type\":\"uint256\"}],\"name\":\"ClaimIncentivesFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelegatecallOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"DonatorBlacklisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"LowerThan\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonZeroValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Paused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"}],\"name\":\"ProductClosed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curTime\",\"type\":\"uint256\"}],\"name\":\"ProductExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"ProductSupplyLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameBlockNumberViolation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"ServiceDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"ServiceNeverDeployed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"name\":\"TreasuryRebalanceFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"UnauthorizedToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"WrongAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numValues1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numValues2\",\"type\":\"uint256\"}],\"name\":\"WrongArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"}],\"name\":\"WrongTokenAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitType\",\"type\":\"uint256\"}],\"name\":\"WrongUnitId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bondCalculator\",\"type\":\"address\"}],\"name\":\"BondCalculatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"CloseProduct\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOLAS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"}],\"name\":\"CreateBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceLP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"}],\"name\":\"CreateProduct\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"}],\"name\":\"RedeemBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenomics\",\"type\":\"address\"}],\"name\":\"TokenomicsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"TreasuryUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_VESTING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondCalculator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondCounter\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bondCalculator\",\"type\":\"address\"}],\"name\":\"changeBondCalculator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenomics\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"changeManagers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"productIds\",\"type\":\"uint256[]\"}],\"name\":\"close\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"closedProductIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"}],\"name\":\"getBondStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"matured\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"matured\",\"type\":\"bool\"}],\"name\":\"getBonds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bondIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getCurrentPriceLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceLP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"getProducts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"productIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"}],\"name\":\"isActiveProduct\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapBondProducts\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"priceLP\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"vesting\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"supply\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapUserBonds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"payout\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"maturity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"productId\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"olas\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"productCounter\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bondIds\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenomics\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Depository", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "4000", "ConstructorArguments": "0000000000000000000000000001a500a6b18995b03f44bb040a5ffc28e45cb0000000000000000000000000c096362fa6f4a4b1a9ea68b1043416f3381ce300000000000000000000000000a0da53447c0f6c4987964d8463da7e6628b30f820000000000000000000000001521918961bdbc9ed4c67a7103d5999e4130e6cb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}