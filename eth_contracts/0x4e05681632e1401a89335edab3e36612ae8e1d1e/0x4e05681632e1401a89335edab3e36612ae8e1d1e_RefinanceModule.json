{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/infiniteProxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_)\\n        external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_)\\n        external\\n        view\\n        returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface TokenInterface {\\n    function approve(address, uint256) external;\\n\\n    function transfer(address, uint) external;\\n\\n    function transferFrom(address, address, uint) external;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function decimals() external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n}\\n\\ninterface IInstaIndex {\\n    function build(\\n        address owner_,\\n        uint256 accountVersion_,\\n        address origin_\\n    ) external returns (address account_);\\n}\\n\\ninterface IDSA {\\n    function cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32);\\n}\\n\\ninterface IWstETH {\\n    function tokensPerStEth() external view returns (uint256);\\n\\n    function getStETHByWstETH(\\n        uint256 _wstETHAmount\\n    ) external view returns (uint256);\\n\\n    function getWstETHByStETH(\\n        uint256 _stETHAmount\\n    ) external view returns (uint256);\\n\\n    function stEthPerToken() external view returns (uint256);\\n}\\n\\ninterface ICompoundMarket {\\n    struct UserCollateral {\\n        uint128 balance;\\n        uint128 _reserved;\\n    }\\n\\n    function borrowBalanceOf(address account) external view returns (uint256);\\n\\n    function userCollateral(\\n        address,\\n        address\\n    ) external view returns (UserCollateral memory);\\n}\\n\\ninterface IEulerTokens {\\n    function balanceOfUnderlying(\\n        address account\\n    ) external view returns (uint256); //To be used for E-Tokens\\n\\n    function balanceOf(address) external view returns (uint256); //To be used for D-Tokens\\n}\\n\\ninterface ILiteVaultV1 {\\n    function deleverageAndWithdraw(\\n        uint256 deleverageAmt_,\\n        uint256 withdrawAmount_,\\n        address to_\\n    ) external;\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (uint256 exchangePrice_, uint256 newRevenue_);\\n}\\n\\ninterface IAavePoolProviderInterface {\\n    function getLendingPool() external view returns (address);\\n}\\n\\ninterface IAavePool {\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256); // Returns underlying amount withdrawn.\\n}\\n\\ninterface IMorphoAaveV2 {\\n    struct PoolIndexes {\\n        uint32 lastUpdateTimestamp; // The last time the local pool and peer-to-peer indexes were updated.\\n        uint112 poolSupplyIndex; // Last pool supply index. Note that for the stEth market, the pool supply index is tweaked to take into account the staking rewards.\\n        uint112 poolBorrowIndex; // Last pool borrow index. Note that for the stEth market, the pool borrow index is tweaked to take into account the staking rewards.\\n    }\\n\\n    function poolIndexes(address) external view returns (PoolIndexes memory);\\n\\n    // Current index from supply peer-to-peer unit to underlying (in ray).\\n    function p2pSupplyIndex(address) external view returns (uint256);\\n\\n    // Current index from borrow peer-to-peer unit to underlying (in ray).\\n    function p2pBorrowIndex(address) external view returns (uint256);\\n\\n    struct SupplyBalance {\\n        uint256 inP2P; // In peer-to-peer supply scaled unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\\n        uint256 onPool; // In pool supply scaled unit. Multiply by the pool supply index to get the underlying amount.\\n    }\\n\\n    struct BorrowBalance {\\n        uint256 inP2P; // In peer-to-peer borrow scaled unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\\n        uint256 onPool; // In pool borrow scaled unit, a unit that grows in value, to keep track of the debt increase when borrowers are on Aave. Multiply by the pool borrow index to get the underlying amount.\\n    }\\n\\n    // For a given market, the supply balance of a user. aToken -> user -> balances.\\n    function supplyBalanceInOf(\\n        address,\\n        address\\n    ) external view returns (SupplyBalance memory);\\n\\n    // For a given market, the borrow balance of a user. aToken -> user -> balances.\\n    function borrowBalanceInOf(\\n        address,\\n        address\\n    ) external view returns (BorrowBalance memory);\\n\\n    /// @notice Updates the peer-to-peer indexes and pool indexes (only stored locally).\\n    function updateIndexes(address _poolToken) external;\\n}\\n\\ninterface ILidoWithdrawalQueue {\\n    // code below from Lido WithdrawalQueueBase.sol\\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0-beta.3/contracts/0.8.9/WithdrawalQueueBase.sol\\n\\n    /// @notice output format struct for `_getWithdrawalStatus()` method\\n    struct WithdrawalRequestStatus {\\n        /// @notice stETH token amount that was locked on withdrawal queue for this request\\n        uint256 amountOfStETH;\\n        /// @notice amount of stETH shares locked on withdrawal queue for this request\\n        uint256 amountOfShares;\\n        /// @notice address that can claim or transfer this request\\n        address owner;\\n        /// @notice timestamp of when the request was created, in seconds\\n        uint256 timestamp;\\n        /// @notice true, if request is finalized\\n        bool isFinalized;\\n        /// @notice true, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\\n        bool isClaimed;\\n    }\\n\\n    /// @notice length of the checkpoints. Last possible value for the claim hint\\n    function getLastCheckpointIndex() external view returns (uint256);\\n\\n    // code below from Lido WithdrawalQueue.sol\\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0-beta.3/contracts/0.8.9/WithdrawalQueue.sol\\n\\n    /// @notice Request the sequence of stETH withdrawals according to passed `withdrawalRequestInputs` data\\n    /// @param amounts an array of stETH amount values. The standalone withdrawal request will\\n    ///  be created for each item in the passed list.\\n    /// @param _owner address that will be able to transfer or claim the request.\\n    ///  If `owner` is set to `address(0)`, `msg.sender` will be used as owner.\\n    /// @return requestIds an array of the created withdrawal requests\\n    function requestWithdrawals(\\n        uint256[] calldata amounts,\\n        address _owner\\n    ) external returns (uint256[] memory requestIds);\\n\\n    /// @notice Claim one`_requestId` request once finalized sending locked ether to the owner\\n    /// @param _requestId request id to claim\\n    /// @dev use unbounded loop to find a hint, which can lead to OOG\\n    /// @dev\\n    ///  Reverts if requestId or hint are not valid\\n    ///  Reverts if request is not finalized or already claimed\\n    ///  Reverts if msg sender is not an owner of request\\n    function claimWithdrawal(uint256 _requestId) external;\\n\\n    /// @notice Claim a batch of withdrawal requests once finalized (claimable) sending locked ether to the owner\\n    /// @param _requestIds array of request ids to claim\\n    /// @param _hints checkpoint hint for each id.\\n    ///   Can be retrieved with `findCheckpointHints()`\\n    /// @dev\\n    ///  Reverts if any requestId or hint in arguments are not valid\\n    ///  Reverts if any request is not finalized or already claimed\\n    ///  Reverts if msg sender is not an owner of the requests\\n    function claimWithdrawals(\\n        uint256[] calldata _requestIds,\\n        uint256[] calldata _hints\\n    ) external;\\n\\n    /// @notice Returns all withdrawal requests that belongs to the `_owner` address\\n    ///\\n    /// WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n    /// to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n    /// this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n    /// uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n    function getWithdrawalRequests(\\n        address _owner\\n    ) external view returns (uint256[] memory requestsIds);\\n\\n    /// @notice Finds the list of hints for the given `_requestIds` searching among the checkpoints with indices\\n    ///  in the range  `[_firstIndex, _lastIndex]`. NB! Array of request ids should be sorted\\n    /// @param _requestIds ids of the requests sorted in the ascending order to get hints for\\n    /// @param _firstIndex left boundary of the search range\\n    /// @param _lastIndex right boundary of the search range\\n    /// @return hintIds the hints for `claimWithdrawal` to find the checkpoint for the passed request ids\\n    function findCheckpointHints(\\n        uint256[] calldata _requestIds,\\n        uint256 _firstIndex,\\n        uint256 _lastIndex\\n    ) external view returns (uint256[] memory hintIds);\\n\\n    /// @notice Returns statuses for the array of request ids\\n    /// @param _requestIds array of withdrawal request ids\\n    function getWithdrawalStatus(\\n        uint256[] calldata _requestIds\\n    ) external view returns (WithdrawalRequestStatus[] memory statuses);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n}\\n\\ninterface IWeth {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n}\\n\\ninterface IMorphoAaveV3 {\\n    function marketsCreated() external view returns (address[] memory);\\n\\n    /// @notice Contains the market side indexes as uint256 instead of uint128.\\n    struct MarketSideIndexes256 {\\n        uint256 poolIndex; // The pool index (in ray).\\n        uint256 p2pIndex; // The peer-to-peer index (in ray).\\n    }\\n\\n    /// @notice Contains the indexes as uint256 instead of uint128.\\n    struct Indexes256 {\\n        MarketSideIndexes256 supply; // The `MarketSideIndexes` related to the supply as uint256.\\n        MarketSideIndexes256 borrow; // The `MarketSideIndexes` related to the borrow as uint256.\\n    }\\n\\n    /// @notice Returns the updated indexes (peer-to-peer and pool).\\n    function updatedIndexes(\\n        address underlying\\n    ) external view returns (Indexes256 memory);\\n\\n    /// @notice Returns the total borrow balance of `user` on the `underlying` market (in underlying).\\n    function borrowBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the supply collateral balance of `user` on the `underlying` market (in underlying).\\n    function collateralBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, supplied on pool & used as collateral (with `underlying` decimals).\\n    function scaledCollateralBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, borrowed peer-to-peer (with `underlying` decimals).\\n    function scaledP2PBorrowBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, borrowed from pool (with `underlying` decimals).\\n    function scaledPoolBorrowBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n}\\n\\ninterface IFluidVaultT1 {\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(\\n        bytes32 slot_\\n    ) external view returns (uint256 result_);\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/variables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces.sol\\\";\\nimport \\\"../../infiniteProxy/IProxy.sol\\\";\\n\\n/// @title      Variables\\n/// @notice     Contains common storage variables of all modules of Infinite proxy.\\ncontract ConstantVariables {\\n    uint256 internal constant RAY = 10 ** 27;\\n    uint256 internal constant MAX_UINT256 = type(uint256).max;\\n    uint256 internal constant RAY_MINUS_ONE = RAY - 1;\\n    uint256 internal constant MAX_UINT256_MINUS_RAY_MINUS_ONE =\\n        MAX_UINT256 - RAY_MINUS_ONE;\\n\\n    uint256 internal constant MORPHO_V3_MAX_ITERATIONS = 10;\\n\\n    IInstaIndex internal constant INSTA_INDEX_CONTRACT =\\n        IInstaIndex(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\\n    address internal constant IETH_TOKEN_V1 =\\n        0xc383a3833A87009fD9597F8184979AF5eDFad019;\\n\\n    /***********************************|\\n    |           STETH ADDRESSES         |\\n    |__________________________________*/\\n    address internal constant STETH_ADDRESS =\\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n    // IERC20 internal constant STETH_CONTRACT = IERC20(STETH_ADDRESS);\\n    address internal constant A_STETH_ADDRESS =\\n        0x1982b2F5814301d4e9a8b0201555376e62F82428;\\n\\n    /***********************************|\\n    |           WSTETH ADDRESSES        |\\n    |__________________________________*/\\n    address internal constant WSTETH_ADDRESS =\\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\n    IWstETH internal constant WSTETH_CONTRACT = IWstETH(WSTETH_ADDRESS);\\n    address internal constant A_WSTETH_ADDRESS_AAVEV3 =\\n        0x0B925eD163218f6662a35e0f0371Ac234f9E9371;\\n    address internal constant E_WSTETH_ADDRESS =\\n        0xbd1bd5C956684f7EB79DA40f582cbE1373A1D593;\\n    address internal constant SP_WSTETH_ADDRESS_SPARK =\\n        0x12B54025C112Aa61fAce2CDB7118740875A566E9;\\n\\n    /***********************************|\\n    |           ETH ADDRESSES           |\\n    |__________________________________*/\\n    address internal constant ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address internal constant WETH_ADDRESS =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant A_WETH_ADDRESS =\\n        0x030bA81f1c18d280636F32af80b9AAd02Cf0854e;\\n    address internal constant D_WETH_ADDRESS =\\n        0xF63B34710400CAd3e044cFfDcAb00a0f32E33eCf;\\n    address internal constant D_WETH_ADDRESS_AAVEV3 =\\n        0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;\\n    address internal constant D_WETH_ADDRESS_EULER =\\n        0x62e28f054efc24b26A794F5C1249B6349454352C;\\n    address internal constant D_WETH_ADDRESS_SPARK =\\n        0x2e7576042566f8D6990e07A1B61Ad1efd86Ae70d;\\n\\n    address internal constant COMP_ETH_MARKET_ADDRESS =\\n        0xA17581A9E3356d9A858b789D68B4d866e593aE94;\\n\\n    ILiteVaultV1 internal constant LITE_VAULT_V1 = ILiteVaultV1(IETH_TOKEN_V1);\\n\\n    ICompoundMarket internal constant COMP_ETH_MARKET_CONTRACT =\\n        ICompoundMarket(COMP_ETH_MARKET_ADDRESS);\\n\\n    IMorphoAaveV2 internal constant MORPHO_CONTRACT =\\n        IMorphoAaveV2(0x777777c9898D384F785Ee44Acfe945efDFf5f3E0);\\n\\n    IAavePoolProviderInterface internal constant AAVE_POOL_PROVIDER =\\n        IAavePoolProviderInterface(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\\n\\n    ILidoWithdrawalQueue internal constant LIDO_WITHDRAWAL_QUEUE =\\n        ILidoWithdrawalQueue(0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1);\\n\\n    IMorphoAaveV3 internal constant MORPHO_AAVE_V3 =\\n        IMorphoAaveV3(0x33333aea097c193e66081E930c33020272b33333);\\n\\n    IFluidVaultT1 internal constant FLUID_VAULT =\\n        IFluidVaultT1(FLUID_VAULT_ADDRESS);\\n\\n    address internal constant FLUID_VAULT_ADDRESS =\\n        0xA0F83Fc5885cEBc0420ce7C7b139Adc80c4F4D91;\\n\\n    uint256 internal constant FLUID_NFT_ID = 3;\\n\\n    uint256 internal constant X8 = 0xff;\\n\\n    uint256 internal constant X19 = 0x7ffff;\\n\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n}\\n\\ncontract Variables is ConstantVariables {\\n    /****************************************************************************|\\n    |   @notice Ids associated with protocols at the time of deployment.         |\\n    |   New protocols might have been added or removed at the time of viewing.   |\\n    |                          AAVE_V2 => 1                                      |\\n    |                          AAVE_V3 => 2                                      |\\n    |                          COMPOUND_V3 => 3                                  |\\n    |                          EULER => 4 // Disabled                            |\\n    |                          MORPHO_AAVE_V2 => 5                               |\\n    |                          MORPHO_AAVE_V3 => 6                               |\\n    |                          SPARK => 7                                        |\\n    |                          FLUID => 8                                        |\\n    |___________________________________________________________________________*/\\n\\n    /***********************************|\\n    |           STATE VARIABLES         |\\n    |__________________________________*/\\n\\n    // 1: open; 2: closed\\n    uint8 internal _status;\\n\\n    IDSA public vaultDSA;\\n\\n    /// @notice Max limit (in wei) allowed for wsteth per eth unit amount.\\n    uint256 public leverageMaxUnitAmountLimit;\\n\\n    /// @notice Secondary auth that only has the power to reduce max risk ratio.\\n    address public secondaryAuth;\\n\\n    // Current exchange price.\\n    uint256 public exchangePrice;\\n\\n    // Revenue exchange price (helps in calculating revenue).\\n    // Exchange price when revenue got updated last. It'll only increase overtime.\\n    uint256 public revenueExchangePrice;\\n\\n    /// @notice mapping to store allowed rebalancers\\n    ///         modifiable by auth\\n    mapping(address => bool) public isRebalancer;\\n\\n    // Mapping of protocol id => max risk ratio, scaled to factor 4.\\n    // i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    // 1 = Aave v2\\n    // 2 = Aave v3\\n    // 3 = Compound v3 (ETH market)\\n    // 4 = Euler // Disabled\\n    // 5 = Morpho Aave v2\\n    // 6 = Morpho Aave v3\\n    // 7 = Spark\\n    // 8 = Fluid\\n    mapping(uint8 => uint256) public maxRiskRatio;\\n\\n    // Max aggregated risk ratio of the vault that can be reached, scaled to factor 4.\\n    // i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    uint256 public aggrMaxVaultRatio;\\n\\n    /// @notice withdraw fee is either amount in percentage or absolute minimum. This var defines the percentage in 1e6\\n    /// this number is given in 1e4, i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    /// modifiable by owner\\n    uint256 public withdrawalFeePercentage;\\n\\n    /// @notice withdraw fee is either amount in percentage or absolute minimum. This var defines the absolute minimum\\n    /// this number is given in decimals for the respective asset of the vault.\\n    /// modifiable by owner\\n    uint256 public withdrawFeeAbsoluteMin; // in underlying base asset, i.e. stEth\\n\\n    // charge from the profits, scaled to factor 4.\\n    // 100,000 would be 10% cut from profit\\n    uint256 public revenueFeePercentage;\\n\\n    /// @notice Stores profit revenue and withdrawal fees collected.\\n    uint256 public revenue;\\n\\n    /// @notice Revenue will be transffered to this address upon collection.\\n    address public treasury;\\n\\n    /// @notice Tracker for amount of stETH queued for withdrawal.\\n    uint256 public queuedWithdrawStEth;\\n}\\n\\n/// @title      PrimaryHelpers\\n/// @notice     Contains common modifiers of all modules of Infinite proxy.\\ncontract PrimaryHelpers is Variables {\\n    /***********************************|\\n    |              ERRORS               |\\n    |__________________________________*/\\n    error Helpers__UnsupportedProtocolId();\\n    error Helpers__NotRebalancer();\\n    error Helpers__Reentrant();\\n    error Helpers__EulerDisabled();\\n\\n    /***********************************|\\n    |              MODIFIERS            |\\n    |__________________________________*/\\n    modifier onlyRebalancer() {\\n        if (\\n            !(isRebalancer[msg.sender] ||\\n                IProxy(address(this)).getAdmin() == msg.sender)\\n        ) {\\n            revert Helpers__NotRebalancer();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev reentrancy gaurd.\\n     */\\n    modifier nonReentrant() {\\n        if (_status == 2) revert Helpers__Reentrant();\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n\\n    /// @notice Implements a method to read uint256 data from storage at a bytes32 storage slot key.\\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\\n        assembly {\\n            result_ := sload(slot_) // read value from the storage slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/variablesBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title      VariablesBuffer\\n/// @notice     Allocates space of 151 slots to maintain storage \\n///             consistency with imported variables in VariablesPrimaryHelper.\\n\\ncontract VariablesBuffer {\\n    uint[151] internal __buffergap;\\n}\"\r\n    },\r\n    \"contracts/vault/common/variablesBufferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title      VariablesBufferHelper\\n/// @notice     Buffer Helper for variables that imports all the primary \\n///             helpers from the storage slot 152.\\n\\nimport {VariablesBuffer} from \\\"./variablesBuffer.sol\\\";\\nimport {PrimaryHelpers} from \\\"./variables.sol\\\";\\n\\n// Buffer & variables\\ncontract VariablesBufferHelper is VariablesBuffer, PrimaryHelpers {\\n}\"\r\n    },\r\n    \"contracts/vault/modules/common/interface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.17;\\n\\ninterface IVault {\\n    struct ProtocolAssetsInStETH {\\n        uint256 stETH; // supply\\n        uint256 wETH; // borrow\\n    }\\n\\n    struct ProtocolAssetsInWstETH {\\n        uint256 wstETH; // supply\\n        uint256 wETH; // borrow\\n    }\\n\\n    struct IdealBalances {\\n        uint256 stETH;\\n        uint256 wstETH;\\n        uint256 wETH;\\n    }\\n\\n    struct NetAssetsHelper {\\n        ProtocolAssetsInStETH aaveV2;\\n        ProtocolAssetsInWstETH aaveV3;\\n        ProtocolAssetsInWstETH compoundV3;\\n        ProtocolAssetsInWstETH euler;\\n        ProtocolAssetsInStETH morphoAaveV2;\\n        ProtocolAssetsInWstETH morphoAaveV3;\\n        ProtocolAssetsInWstETH spark;\\n        ProtocolAssetsInWstETH fluid;\\n        IdealBalances vaultBalances;\\n        IdealBalances dsaBalances;\\n    }\\n\\n    function getProtocolRatio(uint8 protocolId_) external view returns (uint256 ratio_);\\n    function getNetAssets()\\n        external\\n        view\\n        returns (\\n            uint256 totalAssets_, // Total assets(collaterals + ideal balances) inlcuding reveune\\n            uint256 totalDebt_, // Total debt\\n            uint256 netAssets_, // Total assets - Total debt - Reveune\\n            uint256 aggregatedRatio_, // Aggregated ratio of vault (Total debt/ (Total assets - revenue))\\n            NetAssetsHelper memory assets_\\n        );\\n\\n    function getWithdrawFee(uint256 stETHAmount_) external view returns (uint256);\\n\\n    function getRatioAaveV3(uint256 stEthPerWsteth_)\\n        external\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        );\\n\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\"\r\n    },\r\n    \"contracts/vault/modules/refinanceModule/events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract Events {\\n    /// @notice Emitted whenever rebalancer refinances between 2 protocols.\\n    event LogRefinance(\\n        uint8 indexed protocolFrom,\\n        uint8 indexed protocolTo,\\n        uint256 indexed route,\\n        uint256 wstETHflashAmount,\\n        uint256 wETHBorrowAmount,\\n        uint256 withdrawAmount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/vault/modules/refinanceModule/main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../../common/variablesBufferHelper.sol\\\";\\nimport \\\"./events.sol\\\";\\nimport {IVault} from \\\"../common/interface.sol\\\";\\n\\ncontract RefinanceModule is VariablesBufferHelper, Events {\\n\\n    /***********************************|\\n    |              ERRORS               |\\n    |__________________________________*/\\n    error RefinanceModule__Unsafe();\\n\\n    /***********************************|\\n    |           REFINANCE CORE          |\\n    |__________________________________*/\\n    struct RefinanceVariables {\\n        bool isFromStETHBasedProtocol;\\n        bool isToStETHBasedProtocol;\\n        uint256 spellIndex;\\n        uint256 spellsLength;\\n        string[] targets;\\n        bytes[] calldatas;\\n        uint256 withdrawIdToPaybackFlashloan;\\n    }\\n\\n    /// @notice Core function to perform refinance.\\n    /// @dev Note Flashloan will always be taken in `WSTETH`.\\n    /// @param fromProtocolId_ Id of the protocol to refinance from.\\n    /// @param toProtocolId_ Id of the protocol to refinance to.\\n    /// @param route_ Route for flashloan.\\n    /// @param wstETHflashAmount_ Amount of flashloan.\\n    /// @param wETHBorrowAmount_ Amount of wETH to be borrowed.\\n    /// @param withdrawAmount_ Amount to be withdrawn. Will always be in stETH.\\n    function refinance(\\n        uint8 fromProtocolId_,\\n        uint8 toProtocolId_,\\n        uint256 route_,\\n        uint256 wstETHflashAmount_,\\n        uint256 wETHBorrowAmount_,\\n        uint256 withdrawAmount_\\n    )\\n        external\\n        nonReentrant\\n        onlyRebalancer\\n        returns (uint256 ratioFromProtocol_, uint256 ratioToProtocol_)\\n    {\\n        if (fromProtocolId_ == 4 || toProtocolId_ == 4) {\\n            revert Helpers__EulerDisabled();\\n        }\\n\\n        RefinanceVariables memory ref_;\\n\\n        ref_.isFromStETHBasedProtocol =\\n            fromProtocolId_ == 1 ||\\n            fromProtocolId_ == 5;\\n        ref_.isToStETHBasedProtocol = toProtocolId_ == 1 || toProtocolId_ == 5;\\n\\n        /// @dev `wstETHflashAmount_` does not include withdraw and deposit spells.\\n        /// They are considered in `withdrawAmount_` count.\\n        if (ref_.isFromStETHBasedProtocol && !(ref_.isToStETHBasedProtocol)) {\\n            // From: stETH based protocol\\n            // To: wstETH based protocol\\n\\n            // to: deposit wstETH protocol -> 1\\n            // to: withdraw wstETH protocol, flashpayback -> 2\\n            if (wstETHflashAmount_ > 0) ref_.spellsLength += 3;\\n\\n            // to: borrow wETH, from: payback wETH -> 2\\n            if (wETHBorrowAmount_ > 0) ref_.spellsLength += 2;\\n\\n            // from: withdraw stETH protocol, steth => wsteth, to: deposit wstETH protocol -> 3\\n            if (withdrawAmount_ > 0) ref_.spellsLength += 3;\\n        } else if (\\n            !(ref_.isFromStETHBasedProtocol) && ref_.isToStETHBasedProtocol\\n        ) {\\n            // From: wstETH based protocol\\n            // To: stETH based protocol\\n\\n            // wstETH flashloan to stETH, to: stETH deposit in protocol -> 2\\n            // stETH withdraw from protocol, stETH to wstETH, flash payback -> 3\\n            if (wstETHflashAmount_ > 0) ref_.spellsLength += 5;\\n\\n            // to: borrow WETH, from: payback WETH -> 2\\n            if (wETHBorrowAmount_ > 0) ref_.spellsLength += 2;\\n\\n            // from: withdraw wstETH based protocol, unwrap wsteth to steth, to: deposit stETH based protocol -> 3\\n            if (withdrawAmount_ > 0) ref_.spellsLength += 3;\\n        } else if (\\n            ref_.isFromStETHBasedProtocol && ref_.isToStETHBasedProtocol\\n        ) {\\n            // From: stETH based protocol\\n            // To: stETH based protocol\\n\\n            // wstETH flashloan to stETH, to: stETH deposit protocol -> 2\\n            // to: withdraw stETH from protocol, stETH to wstETH, flashpayback wstETH -> 3\\n            if (wstETHflashAmount_ > 0) ref_.spellsLength += 5;\\n\\n            // to: borrow WETH, from: payback WETH -> 2\\n            if (wETHBorrowAmount_ > 0) ref_.spellsLength += 2;\\n\\n            // from: withdraw stETH protocol, to: deposit stETH based protocol -> 2\\n            if (withdrawAmount_ > 0) ref_.spellsLength += 2;\\n        } else if (\\n            !(ref_.isFromStETHBasedProtocol) && !(ref_.isToStETHBasedProtocol)\\n        ) {\\n            // From: wstETH based protocol\\n            // To: wstETH based protocol\\n\\n            // to: deposit wstETH protocol -> 1\\n            // to: withdraw wstETH protocol, flashPayback wstETH -> 2\\n            if (wstETHflashAmount_ > 0) ref_.spellsLength += 3;\\n\\n            // to: borrow wETH, from: payback wETH -> 2\\n            if (wETHBorrowAmount_ > 0) ref_.spellsLength += 2;\\n\\n            // from: withdraw wstETH protocol, to: deposit wstETH protocol -> 2\\n            if (withdrawAmount_ > 0) ref_.spellsLength += 2;\\n        }\\n\\n        if (fromProtocolId_ == 8 || toProtocolId_ == 8) {\\n            // If fluid is toProtocolId_; spell to convert borrowed ETH to WETH\\n            // If fluid is toProtocolId_; spell to convert payback WETH to ETH\\n            ref_.spellsLength += 1;\\n        }\\n\\n        // withdrawAmount_ will always be in stETH.\\n        // Getting wstETH values for protocols supporting wstETH.\\n        uint256 fromWithdrawAmount_ = ref_.isFromStETHBasedProtocol\\n            ? withdrawAmount_\\n            : WSTETH_CONTRACT.getWstETHByStETH(withdrawAmount_);\\n\\n        // To get the amount of stETH deposited from wstETH flashloan.\\n        uint256 flashDepositAmount_ = ref_.isToStETHBasedProtocol\\n            ? WSTETH_CONTRACT.getStETHByWstETH(wstETHflashAmount_)\\n            : wstETHflashAmount_;\\n\\n        ref_.targets = new string[](ref_.spellsLength);\\n        ref_.calldatas = new bytes[](ref_.spellsLength);\\n\\n        // stETH => wstETH after withdraw for flashloan payback\\n        ref_.withdrawIdToPaybackFlashloan = 5236237;\\n\\n        /**************************************|\\n        |   TAKE WSTETH FLASHLOAN AND DEPOSIT  |\\n        |_____________________________________*/\\n\\n        if (wstETHflashAmount_ > 0) {\\n            if (ref_.isToStETHBasedProtocol) {\\n                // to: stETH based protocols\\n                ref_.targets[ref_.spellIndex] = \\\"WSTETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(uint256,uint256,uint256)\\\",\\n                    type(uint256).max, // Converting all wsteth to steth\\n                    0,\\n                    0\\n                );\\n\\n                ref_.spellIndex++;\\n            }\\n\\n            if (toProtocolId_ == 1) {\\n                // to: stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    type(uint256).max, // stETH amount will come from below getId\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 2) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 3) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"COMPOUND-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,address,uint256,uint256,uint256)\\\",\\n                    COMP_ETH_MARKET_ADDRESS,\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 4) {\\n                // // to: wstETH based protocol\\n                // ref_.targets[ref_.spellIndex] = \\\"EULER-A\\\";\\n                // ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                //     \\\"deposit(uint256,address,uint256,bool,uint256,uint256)\\\",\\n                //     0,\\n                //     WSTETH_ADDRESS,\\n                //     type(uint256).max,\\n                //     true,\\n                //     0,\\n                //     0\\n                // );\\n            } else if (toProtocolId_ == 5) {\\n                // to: stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    A_STETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 6) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"depositCollateral(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 7) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"SPARK-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 8) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"FLUID-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"operate(address,uint256,int256,int256,uint256)\\\",\\n                    FLUID_VAULT_ADDRESS,\\n                    FLUID_NFT_ID,\\n                    type(int256).max,\\n                    0,\\n                    0\\n                );\\n            }\\n\\n            ref_.spellIndex++;\\n        }\\n\\n        /***********************************|\\n        |      BORROW WETH AND PAYBACK       |\\n        |__________________________________*/\\n\\n        if (wETHBorrowAmount_ > 0) {\\n            if (toProtocolId_ == 1) {\\n                // to: stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"borrow(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    2,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 2) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"borrow(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    2,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 3) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"COMPOUND-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"borrow(address,address,uint256,uint256,uint256)\\\",\\n                    COMP_ETH_MARKET_ADDRESS,\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 4) {\\n                // // to: wstETH based protocol\\n                // ref_.targets[ref_.spellIndex] = \\\"EULER-A\\\";\\n                // ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                //     \\\"borrow(uint256,address,uint256,uint256,uint256)\\\",\\n                //     0,\\n                //     WETH_ADDRESS,\\n                //     wETHBorrowAmount_,\\n                //     0,\\n                //     0\\n                // );\\n            } else if (toProtocolId_ == 5) {\\n                // to: stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"borrow(address,address,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    A_WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 6) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"borrowWithMaxIterations(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    MORPHO_V3_MAX_ITERATIONS,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 7) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"SPARK-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"borrow(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    2,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 8) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"FLUID-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"operate(address,uint256,int256,int256,uint256)\\\",\\n                    FLUID_VAULT_ADDRESS,\\n                    FLUID_NFT_ID,\\n                    0,\\n                    int256(wETHBorrowAmount_),\\n                    0\\n                );\\n\\n                ref_.spellIndex++;\\n\\n                ref_.targets[ref_.spellIndex] = \\\"WETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(uint256,uint256,uint256)\\\",\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n            }\\n\\n            ref_.spellIndex++;\\n\\n            if (fromProtocolId_ == 1) {\\n                // from: stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"payback(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    2,\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 2) {\\n                // from: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"payback(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    2,\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 3) {\\n                // from: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"COMPOUND-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"payback(address,address,uint256,uint256,uint256)\\\",\\n                    COMP_ETH_MARKET_ADDRESS,\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 4) {\\n                // // from: wstETH based protocol\\n                // ref_.targets[ref_.spellIndex] = \\\"EULER-A\\\";\\n                // ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                //     \\\"repay(uint256,address,uint256,uint256,uint256)\\\",\\n                //     0,\\n                //     WETH_ADDRESS,\\n                //     wETHBorrowAmount_,\\n                //     0,\\n                //     0\\n                // );\\n            } else if (fromProtocolId_ == 5) {\\n                // from: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"payback(address,address,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    A_WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 6) {\\n                // from: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"payback(address,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 7) {\\n                // from: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"SPARK-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"payback(address,uint256,uint256,uint256,uint256)\\\",\\n                    WETH_ADDRESS,\\n                    wETHBorrowAmount_,\\n                    2,\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 8) {\\n                // Convert borrowed WETH to ETH\\n                ref_.targets[ref_.spellIndex] = \\\"WETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(uint256,uint256,uint256)\\\",\\n                    wETHBorrowAmount_,\\n                    0,\\n                    0\\n                );\\n\\n                ref_.spellIndex++;\\n\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"FLUID-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"operate(address,uint256,int256,int256,uint256)\\\",\\n                    FLUID_VAULT_ADDRESS,\\n                    FLUID_NFT_ID,\\n                    0,\\n                    -int256(wETHBorrowAmount_),\\n                    wETHBorrowAmount_\\n                );\\n            }\\n\\n            ref_.spellIndex++;\\n        }\\n\\n        /*************************************|\\n        |     WITHDRAW wstETH AND DEPOSIT     |\\n        |____________________________________*/\\n\\n        if (withdrawAmount_ > 0) {\\n            // even in case of flashloan, this amount will be withdrawn\\n\\n            if (fromProtocolId_ == 1) {\\n                // from: stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    fromWithdrawAmount_, // withdrawAmount_ is stETH based\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 2) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    fromWithdrawAmount_, // stETH amount converted to wstETH.\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 3) {\\n                // wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"COMPOUND-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,address,uint256,uint256,uint256)\\\",\\n                    COMP_ETH_MARKET_ADDRESS,\\n                    WSTETH_ADDRESS,\\n                    fromWithdrawAmount_, // stETH amount converted to wstETH.\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 4) {\\n                // // wstETH based protocol\\n                // ref_.targets[ref_.spellIndex] = \\\"EULER-A\\\";\\n                // ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                //     \\\"withdraw(uint256,address,uint256,uint256,uint256)\\\",\\n                //     0,\\n                //     WSTETH_ADDRESS,\\n                //     fromWithdrawAmount_, // stETH amount converted to wstETH.\\n                //     0,\\n                //     0\\n                // );\\n            } else if (fromProtocolId_ == 5) {\\n                // stETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    A_STETH_ADDRESS,\\n                    fromWithdrawAmount_, // stETH amount\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 6) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdrawCollateral(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    fromWithdrawAmount_, // stETH amount converted to wstETH.\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 7) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"SPARK-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    fromWithdrawAmount_, // stETH amount converted to wstETH.\\n                    0,\\n                    0\\n                );\\n            } else if (fromProtocolId_ == 8) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"FLUID-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"operate(address,uint256,int256,int256,uint256)\\\",\\n                    FLUID_VAULT_ADDRESS,\\n                    FLUID_NFT_ID,\\n                    (-int256(fromWithdrawAmount_)),\\n                    0,\\n                    0\\n                );\\n            }\\n\\n            ref_.spellIndex++;\\n\\n            if (ref_.isFromStETHBasedProtocol && !ref_.isToStETHBasedProtocol) {\\n                // from: stETH based protocols\\n                // to: wstETH based protocols\\n\\n                ref_.targets[ref_.spellIndex] = \\\"WSTETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(uint256,uint256,uint256)\\\",\\n                    type(uint256).max, // Converting all the withdrawn amount\\n                    0,\\n                    0\\n                );\\n\\n                ref_.spellIndex++;\\n            } else if (\\n                !ref_.isFromStETHBasedProtocol && ref_.isToStETHBasedProtocol\\n            ) {\\n                // from: wstETH based protocols\\n                // to: stETH based protocols\\n\\n                ref_.targets[ref_.spellIndex] = \\\"WSTETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(uint256,uint256,uint256)\\\",\\n                    type(uint256).max, // Converting all the withdrawn amount\\n                    0,\\n                    0\\n                );\\n\\n                ref_.spellIndex++;\\n            }\\n\\n            if (toProtocolId_ == 1) {\\n                // to: stETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    type(uint256).max, // Depositing all stETH\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 2) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max, // Depositing all wstETH\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 3) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"COMPOUND-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,address,uint256,uint256,uint256)\\\",\\n                    COMP_ETH_MARKET_ADDRESS,\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max, // Depositing all wstETH\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 4) {\\n                // // to: wstETH based protocol\\n                // ref_.targets[ref_.spellIndex] = \\\"EULER-A\\\";\\n                // ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                //     \\\"deposit(uint256,address,uint256,bool,uint256,uint256)\\\",\\n                //     0,\\n                //     WSTETH_ADDRESS,\\n                //     type(uint256).max, // Depositing all wstETH\\n                //     true,\\n                //     0,\\n                //     0\\n                // );\\n            } else if (toProtocolId_ == 5) {\\n                // to: stETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    A_STETH_ADDRESS,\\n                    type(uint256).max, // Depositing all stETH\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 6) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"depositCollateral(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 7) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"SPARK-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    type(uint256).max,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 8) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"FLUID-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"operate(address,uint256,int256,int256,uint256)\\\",\\n                    FLUID_VAULT_ADDRESS,\\n                    FLUID_NFT_ID,\\n                    type(int256).max, // Depositing all wstETH\\n                    0,\\n                    0\\n                );\\n            }\\n\\n            ref_.spellIndex++;\\n        }\\n\\n        /***************************************|\\n        |   WITHDRAW WSTETH AND FLASH PAYBACK   |\\n        |______________________________________*/\\n\\n        if (wstETHflashAmount_ > 0) {\\n            if (toProtocolId_ == 1) {\\n                // stETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    (flashDepositAmount_ + 10), // flash amount in stETH + 10 wei buffer for proper payback.\\n                    0,\\n                    ref_.withdrawIdToPaybackFlashloan\\n                );\\n                ref_.spellIndex++;\\n\\n                ref_.targets[ref_.spellIndex] = \\\"WSTETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(uint256,uint256,uint256)\\\",\\n                    0,\\n                    ref_.withdrawIdToPaybackFlashloan, // stETH flashloan deposited + 10 wei\\n                    0\\n                );\\n            } else if (toProtocolId_ == 2) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    flashDepositAmount_, // flash amount in wstETH\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 3) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"COMPOUND-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,address,uint256,uint256,uint256)\\\",\\n                    COMP_ETH_MARKET_ADDRESS,\\n                    WSTETH_ADDRESS,\\n                    flashDepositAmount_, // flash amount in wstETH\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 4) {\\n                // // wstETH based protocol\\n\\n                // ref_.targets[ref_.spellIndex] = \\\"EULER-A\\\";\\n                // ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                //     \\\"withdraw(uint256,address,uint256,uint256,uint256)\\\",\\n                //     0,\\n                //     WSTETH_ADDRESS,\\n                //     flashDepositAmount_, // flash amount in wstETH\\n                //     0,\\n                //     0\\n                // );\\n            } else if (toProtocolId_ == 5) {\\n                // stETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V2-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,address,uint256,uint256,uint256)\\\",\\n                    STETH_ADDRESS,\\n                    A_STETH_ADDRESS,\\n                    (flashDepositAmount_ + 10), // flash amount in stETH + 10 wei buffer for proper payback.\\n                    0,\\n                    ref_.withdrawIdToPaybackFlashloan\\n                );\\n\\n                ref_.spellIndex++;\\n\\n                ref_.targets[ref_.spellIndex] = \\\"WSTETH-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"deposit(uint256,uint256,uint256)\\\",\\n                    0,\\n                    ref_.withdrawIdToPaybackFlashloan, // stETH flashloan deposited + 10 wei\\n                    0\\n                );\\n            } else if (toProtocolId_ == 6) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"MORPHO-AAVE-V3-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdrawCollateral(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    flashDepositAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 7) {\\n                // wstETH based protocol\\n\\n                ref_.targets[ref_.spellIndex] = \\\"SPARK-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                    WSTETH_ADDRESS,\\n                    flashDepositAmount_,\\n                    0,\\n                    0\\n                );\\n            } else if (toProtocolId_ == 8) {\\n                // to: wstETH based protocol\\n                ref_.targets[ref_.spellIndex] = \\\"FLUID-A\\\";\\n                ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                    \\\"operate(address,uint256,int256,int256,uint256)\\\",\\n                    FLUID_VAULT_ADDRESS,\\n                    FLUID_NFT_ID,\\n                    -int256(flashDepositAmount_),\\n                    0,\\n                    0\\n                );\\n            }\\n\\n            ref_.spellIndex++;\\n\\n            ref_.targets[ref_.spellIndex] = \\\"INSTAPOOL-C\\\";\\n            ref_.calldatas[ref_.spellIndex] = abi.encodeWithSignature(\\n                \\\"flashPayback(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                wstETHflashAmount_,\\n                0,\\n                0\\n            );\\n\\n            /*********************************|\\n            |    CAST SPELLS WITH FLASHLOAN   |\\n            |________________________________*/\\n            bytes memory encodedFlashData_ = abi.encode(\\n                ref_.targets,\\n                ref_.calldatas\\n            );\\n\\n            string[] memory flashTarget = new string[](1);\\n            bytes[] memory flashCalldata = new bytes[](1);\\n            flashTarget[0] = \\\"INSTAPOOL-C\\\";\\n            flashCalldata[0] = abi.encodeWithSignature(\\n                \\\"flashBorrowAndCast(address,uint256,uint256,bytes,bytes)\\\",\\n                WSTETH_ADDRESS,\\n                wstETHflashAmount_,\\n                route_,\\n                encodedFlashData_,\\n                \\\"0x\\\"\\n            );\\n\\n            vaultDSA.cast(flashTarget, flashCalldata, address(this));\\n        } else {\\n            /******************|\\n            |    CAST SPELLS   |\\n            |_________________*/\\n\\n            vaultDSA.cast(ref_.targets, ref_.calldatas, address(this));\\n        }\\n\\n        uint256 fromRatio_ = IVault(address(this)).getProtocolRatio(fromProtocolId_);\\n        uint256 toRatio_ = IVault(address(this)).getProtocolRatio(toProtocolId_);\\n\\n        if (\\n            fromRatio_ < maxRiskRatio[fromProtocolId_] &&\\n            toRatio_ < maxRiskRatio[toProtocolId_]\\n        ) {\\n            emit LogRefinance(\\n                fromProtocolId_,\\n                toProtocolId_,\\n                route_,\\n                wstETHflashAmount_,\\n                wETHBorrowAmount_,\\n                withdrawAmount_\\n            );\\n\\n            return (fromRatio_, toRatio_);\\n        } else {\\n            revert RefinanceModule__Unsafe();\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"Helpers__EulerDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__NotRebalancer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__UnsupportedProtocolId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefinanceModule__Unsafe\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocolFrom\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocolTo\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"route\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wstETHflashAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wETHBorrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"LogRefinance\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aggrMaxVaultRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRebalancer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leverageMaxUnitAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"maxRiskRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queuedWithdrawStEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot_\",\"type\":\"bytes32\"}],\"name\":\"readFromStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fromProtocolId_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"toProtocolId_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"route_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wstETHflashAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETHBorrowAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount_\",\"type\":\"uint256\"}],\"name\":\"refinance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratioFromProtocol_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratioToProtocol_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueExchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryAuth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultDSA\",\"outputs\":[{\"internalType\":\"contract IDSA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeAbsoluteMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RefinanceModule", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}