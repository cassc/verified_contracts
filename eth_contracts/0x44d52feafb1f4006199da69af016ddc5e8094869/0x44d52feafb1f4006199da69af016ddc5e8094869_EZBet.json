{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2024-04-17\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n\r\ninterface ITellor {\r\n\r\n\r\n    function getNewValueCountbyQueryId(bytes32 _queryId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory);\r\n\r\n\r\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory _value, uint256 _timestampRetrieved);\r\n\r\n\r\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bool _found, uint256 _index);\r\n\r\n\r\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function tellor() external view returns (address);\r\n}\r\n\r\n/**\r\n @author Tellor Inc\r\n @title UsingTellor\r\n @dev This contract helps smart contracts read data from Tellor\r\n */\r\ncontract UsingTellor {\r\n    ITellor public tellor;\r\n    /*Constructor*/\r\n    /**\r\n     * @dev the constructor sets the oracle address in storage\r\n     * @param _tellor is the Tellor Oracle address\r\n     */\r\n    constructor(address payable _tellor) {\r\n        tellor = ITellor(_tellor);\r\n    }\r\n\r\n    /*Getters*/\r\n    /**\r\n     * @dev Retrieves the next value for the queryId after the specified timestamp\r\n     * @param _queryId is the queryId to look up the value for\r\n     * @param _timestamp after which to search for next value\r\n     * @return _value the value retrieved\r\n     * @return _timestampRetrieved the value's timestamp\r\n     */\r\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (bytes memory _value, uint256 _timestampRetrieved)\r\n    {\r\n        (bool _found, uint256 _index) = getIndexForDataAfter(\r\n            _queryId,\r\n            _timestamp\r\n        );\r\n        if (!_found) {\r\n            return (\"\", 0);\r\n        }\r\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\r\n        _value = retrieveData(_queryId, _timestampRetrieved);\r\n        return (_value, _timestampRetrieved);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\r\n     * @param _queryId is the queryId to look up the index for\r\n     * @param _timestamp is the timestamp before which to search for the latest index\r\n     * @return _found whether the index was found\r\n     * @return _index the latest index found before the specified timestamp\r\n     */\r\n    // slither-disable-next-line calls-loop\r\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (bool _found, uint256 _index)\r\n    {\r\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\r\n        if (_count == 0) return (false, 0);\r\n        _count--;\r\n        bool _search = true; // perform binary search\r\n        uint256 _middle = 0;\r\n        uint256 _start = 0;\r\n        uint256 _end = _count;\r\n        uint256 _timestampRetrieved;\r\n        // checking boundaries to short-circuit the algorithm\r\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _end);\r\n        if (_timestampRetrieved <= _timestamp) return (false, 0);\r\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _start);\r\n        if (_timestampRetrieved > _timestamp) {\r\n            // candidate found, check for disputes\r\n            _search = false;\r\n        }\r\n        // since the value is within our boundaries, do a binary search\r\n        while (_search) {\r\n            _middle = (_end + _start) / 2;\r\n            _timestampRetrieved = getTimestampbyQueryIdandIndex(\r\n                _queryId,\r\n                _middle\r\n            );\r\n            if (_timestampRetrieved > _timestamp) {\r\n                // get immediate previous value\r\n                uint256 _prevTime = getTimestampbyQueryIdandIndex(\r\n                    _queryId,\r\n                    _middle - 1\r\n                );\r\n                if (_prevTime <= _timestamp) {\r\n                    // candidate found, check for disputes\r\n                    _search = false;\r\n                } else {\r\n                    // look from start to middle -1(prev value)\r\n                    _end = _middle - 1;\r\n                }\r\n            } else {\r\n                // get immediate next value\r\n                uint256 _nextTime = getTimestampbyQueryIdandIndex(\r\n                    _queryId,\r\n                    _middle + 1\r\n                );\r\n                if (_nextTime > _timestamp) {\r\n                    // candidate found, check for disputes\r\n                    _search = false;\r\n                    _middle++;\r\n                    _timestampRetrieved = _nextTime;\r\n                } else {\r\n                    // look from middle + 1(next value) to end\r\n                    _start = _middle + 1;\r\n                }\r\n            }\r\n        }\r\n        // candidate found, check for disputed values\r\n        if (!isInDispute(_queryId, _timestampRetrieved)) {\r\n            // _timestampRetrieved is correct\r\n            return (true, _middle);\r\n        } else {\r\n            // iterate forward until we find a non-disputed value\r\n            while (\r\n                isInDispute(_queryId, _timestampRetrieved) && _middle < _count\r\n            ) {\r\n                _middle++;\r\n                _timestampRetrieved = getTimestampbyQueryIdandIndex(\r\n                    _queryId,\r\n                    _middle\r\n                );\r\n            }\r\n            if (\r\n                _middle == _count && isInDispute(_queryId, _timestampRetrieved)\r\n            ) {\r\n                return (false, 0);\r\n            }\r\n            // _timestampRetrieved is correct\r\n            return (true, _middle);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Counts the number of values that have been submitted for the queryId\r\n     * @param _queryId the id to look up\r\n     * @return uint256 count of the number of values received for the queryId\r\n     */\r\n    function getNewValueCountbyQueryId(bytes32 _queryId)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tellor.getNewValueCountbyQueryId(_queryId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the timestamp for the value based on their index\r\n     * @param _queryId is the id to look up\r\n     * @param _index is the value index to look up\r\n     * @return uint256 timestamp\r\n     */\r\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\r\n     * @param _queryId is the value id to look up\r\n     * @param _timestamp is the timestamp of the value to look up\r\n     * @return bool true if queryId/timestamp is under dispute\r\n     */\r\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return tellor.isInDispute(_queryId, _timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve value from oracle based on queryId/timestamp\r\n     * @param _queryId being requested\r\n     * @param _timestamp to retrieve data/value from\r\n     * @return bytes value for query/timestamp submitted\r\n     */\r\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return tellor.retrieveData(_queryId, _timestamp);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n @author themandalore\r\n @title EZBet\r\n @dev This is a contract for making a simple bet.  Vote yes or vote no.  Yes deposits split the no pot if yes, and vice-versa\r\n endDate is when betting stop, 12 hours (the delay variable) for the event, then 24 hours after tellor report to wait for disputes\r\n*/\r\ncontract EZBet is UsingTellor {\r\n    // Question must resolve with \"Yes\" or \"No\".  Anything else is invalid and you just get your money back.  Even \"YES\" or \"NO\" or \"yes\" or \"no\".\r\n    // Be retarded, but that not retarded. You can check if it properly settles and dispute if need be*/\r\n    // Also note, tellor is decentralized.  Reporting a bad value can get you disputed.  Also be sure to check for disputes\r\n    // if you got cash on the line.  We don't do it for you and you shouldn't assume others do. \r\n    // also run your own node (just throwing that in there)\r\n\r\n    string public question;\r\n    bytes public queryData;\r\n    bytes32 public queryId;\r\n    bool public settled;\r\n    bool public yesWins;\r\n    bool public unresolved;\r\n    uint256 public yesBets;\r\n    uint256 public noBets;\r\n    uint256 public endDate;\r\n    uint256 public delay = 12 hours;//time for match (so bets happen, then delay, then 24 hours for tellor report)\r\n    mapping(address => uint256) public addyToYes;\r\n    mapping(address => uint256) public addyToNo;\r\n\r\n\r\n    event BetSettled(bool _yesWins);\r\n    event NoBet(address _addy, uint256 _amt);\r\n    event YesBet(address _addy, uint256 _amt);\r\n    event WinningsClaimed(address _addy, uint256 _amt);\r\n    //0x8cFc184c877154a8F9ffE0fe75649dbe5e2DBEbf,\"Did Levan win EvW12 vs Devon?\",1,1,1713628800\r\n    /**\r\n     * @dev constructor to kick things off\r\n     * @param _tellorAddress the tellor oracle (TellorFlex.sol) address\r\n     * @param _question the question you want to ask, be sure to have it resolve Yes or No\r\n     * @param _amountYes initial yes bet\r\n     * @param _amountNo initial no bet\r\n     * @param _endDate time that the betting ends.  event ends 12 hours later. Tellor has 24 hours to report\r\n     */\r\n    constructor(address payable _tellorAddress, string memory _question, uint _amountYes, uint _amountNo, uint256 _endDate)\r\n        UsingTellor(_tellorAddress) payable{\r\n        question = _question;\r\n        queryData = abi.encode(\"StringQuery\", abi.encode(question));\r\n        queryId = keccak256(queryData);\r\n        require(_amountNo > 0 && _amountYes > 0, \"amounts must be > 0\");\r\n        require(msg.value == _amountNo + _amountYes, \"must send funds\");\r\n        require(_endDate > block.timestamp, \"end date must be in the future\");\r\n        addyToYes[msg.sender] = _amountYes;\r\n        addyToNo[msg.sender] = _amountNo;\r\n        yesBets = _amountYes;\r\n        noBets = _amountNo;\r\n        endDate = _endDate;\r\n    }\r\n\r\n    /**\r\n     * @dev allows user to bet on the question resolving yes\r\n     * @param _amt a uint for the amount of eth you want to send\r\n     */\r\n    function betOnYes(uint256 _amt) external payable{\r\n        require(block.timestamp < endDate, \"end date passed\");\r\n        require(_amt > 0, \"amount too low\");\r\n        require(_amt == msg.value, \"amount != msg.value\");\r\n        addyToYes[msg.sender] = addyToYes[msg.sender] + msg.value;\r\n        yesBets += msg.value;\r\n        emit YesBet(msg.sender,msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev allows user to bet on the question resolving no\r\n     * @param _amt a uint for the amount of eth you want to send\r\n     */\r\n    function betOnNo(uint256 _amt) external payable{\r\n        require(block.timestamp < endDate, \"end date passed\");\r\n        require(_amt > 0, \"amount too low\");\r\n        require(_amt == msg.value, \"amount != msg.value\");\r\n        addyToNo[msg.sender] = addyToNo[msg.sender] + msg.value;\r\n        noBets += msg.value;\r\n        emit NoBet(msg.sender,msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev allows parties who bet to claim their winnings\r\n     */\r\n    function claimWinnings() external{\r\n        if(settled){\r\n            uint256 _amt;\r\n            uint256 _myAmt;\r\n            if(unresolved){\r\n                _amt = addyToYes[msg.sender] + addyToNo[msg.sender];\r\n                addyToYes[msg.sender] = 0; \r\n                addyToNo[msg.sender] = 0; \r\n            }\r\n            else if(yesWins ){\r\n                _myAmt = addyToYes[msg.sender];\r\n                _amt = (noBets * _myAmt/yesBets) + _myAmt;\r\n                addyToYes[msg.sender] = 0;\r\n            }\r\n            else{\r\n                _myAmt = addyToNo[msg.sender];\r\n                _amt = (yesBets * _myAmt/noBets) + _myAmt;\r\n                addyToNo[msg.sender] = 0;\r\n            }\r\n            require(_amt > 0, \"amount must be greater than 0\");\r\n            payable(msg.sender).transfer(_amt);\r\n            emit WinningsClaimed(msg.sender, _amt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev allows anyone to settle the bet, 36 hours after the endDate (and a valid tellor report 24 hours old)\r\n     */\r\n     //can be run 24 hours after the match is reported to Tellor\r\n    function settleBet() external{\r\n        require(!settled, \"settled\");\r\n        (bytes memory _value, uint256 _timestampRetrieved) =\r\n            getDataAfter(queryId, endDate + delay);\r\n        require(_timestampRetrieved !=0, \"no tellor value\");\r\n        if(block.timestamp - _timestampRetrieved >= 24 hours) {\r\n                settled = true;\r\n                if(keccak256(_value) == keccak256(abi.encode(\"Yes\"))){\r\n                            yesWins = true;\r\n                        }\r\n                else if(keccak256(_value) != keccak256(abi.encode(\"No\"))){\r\n                            unresolved = true;\r\n                }\r\n                emit BetSettled(yesWins);\r\n        }\r\n    }\r\n\r\n    //view functions\r\n    /**\r\n     * @dev shows you the current odds of yes, rounded down to nearest pct\r\n     */\r\n    function getCurrentOddsOfYes() external view returns(uint256){\r\n        return (yesBets * 100)/(yesBets + noBets);\r\n    }\r\n\r\n    /**\r\n     * @dev allows you to check how the market will settle and how long until settlement\r\n     */\r\n    function getSettlementStatus() external view\r\n        returns(bool,bool _yesWins, bool _unresolved,string memory,uint256 _timeUntilSettlement){\r\n        (bytes memory _value, uint256 _timestampRetrieved) = getDataAfter(queryId, endDate + delay);\r\n        if(_timestampRetrieved > 0){\r\n                    if( block.timestamp > _timestampRetrieved + 24 hours){\r\n            _timeUntilSettlement = 0;\r\n            }\r\n            else if (block.timestamp - _timestampRetrieved < 24 hours){\r\n                _timeUntilSettlement = 24 hours - (block.timestamp - _timestampRetrieved);\r\n            }\r\n            if(keccak256(_value) == keccak256(abi.encode(\"Yes\"))){\r\n                        _yesWins = true;\r\n                    }\r\n            else if(keccak256(_value) != keccak256(abi.encode(\"No\"))){\r\n                        _unresolved = true;\r\n            }\r\n        }\r\n        else{\r\n            _timeUntilSettlement = (endDate + delay + 24 hours) - block.timestamp;\r\n        }\r\n        return (settled, _yesWins, _unresolved, string(_value),_timeUntilSettlement);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_tellorAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_question\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amountYes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_yesWins\",\"type\":\"bool\"}],\"name\":\"BetSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"NoBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"WinningsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"YesBet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addyToNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addyToYes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"betOnNo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"betOnYes\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentOddsOfYes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSettlementStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_yesWins\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_unresolved\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_timeUntilSettlement\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"question\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellor\",\"outputs\":[{\"internalType\":\"contract ITellor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unresolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yesBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yesWins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EZBet", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000008cfc184c877154a8f9ffe0fe75649dbe5e2dbebf00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000006623e680000000000000000000000000000000000000000000000000000000000000001d446964204c6576616e2077696e204576573132207673204465766f6e3f000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://30bfe97fa8df0776354fbf79eba4421a9689c70fe5a58b5bb806bd4fc3850df2"}