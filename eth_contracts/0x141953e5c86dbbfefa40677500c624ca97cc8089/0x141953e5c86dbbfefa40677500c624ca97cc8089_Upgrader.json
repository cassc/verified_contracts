{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n// optimize 200\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\ninterface StakeV2{\r\n    function getPending1(address staker) external view returns(uint256 _pendingReward);\r\n    function getPending2(address staker) external view returns(uint256 _pendingReward);\r\n    function getPending3(address staker) external view returns(uint256 _pendingReward);\r\n    function isStakeholder(address _address) external view returns(bool);\r\n    function userStakedFEG(address user) external view returns(uint256 StakedFEG);\r\n}\r\n\r\ninterface dr {\r\n    function setMainBreaker(bool boolean) external;\r\n    function isAdmin(address addy) external view returns(bool);\r\n    function superAdmin(address addy) external view returns(bool);\r\n    function wETH() external view returns(address);\r\n    function stake(address user, uint256 amt) external returns(uint256);\r\n    function FEGstake() external view returns(address);\r\n}\r\n\r\ninterface backing {\r\n    function liquifyForBacking(uint256 amt) external;\r\n    function BackingLogicAddress() external view returns(address);\r\n    function backingLogicAddress() external view returns(address);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ncontract ReEntrancyGuard {\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ninterface br {    \r\n    function costBridge(uint16 toChain) external view returns(uint256,uint256);\r\n    function bridge(uint16 toChain, uint256 amount, address user) external payable;\r\n    function bridgeSD(address addy) external view returns(address);\r\n}      \r\n\r\ncontract Upgrader is ReEntrancyGuard {\r\n    address public constant V_2 = 0x4a9D6b95459eb9532B7E4d82Ca214a3b20fa2358;\r\n    address public constant FEGv1 = 0x389999216860AB8E0175387A0c90E5c52522C945;\r\n    address public constant FEGv2 = 0xbededDf2eF49E87037c4fb2cA34d1FF3D3992A11;\r\n    address public constant FEGv3 = 0xF3c7CECF8cBC3066F9a87b310cEBE198d00479aC; \r\n    address public constant ROX = 0x378c77C5379cA07BBB5B3506c08a1C769dEC91c2 ; \r\n    address public dev = 0x249Df570e549E93788F0682dc522741701Ef75E1; \r\n    address public dataread = 0xdAE383661587232FBd254b05a395CB8e35E6e7B6;\r\n    mapping(address => bool) public expired;\r\n    mapping(address => uint256) public convertedROX;\r\n    mapping(address => uint256) public FEGfromROX;\r\n    mapping(address => uint256) public FEGperDist;\r\n    mapping(address => uint256) public totalFEGFromROXAvailable;\r\n    mapping(address => uint256) public lastClaimed;\r\n    mapping(address => bool) public convertEnabledROX;\r\n    uint256 public timer;\r\n    uint256 public coolDown = 1 days;\r\n    uint256 public timerFee;\r\n    uint256 public burnThreshold = 100000000e18;\r\n    uint256 public FEGforROXTotal;\r\n    uint256 public FEGforROXClaimed;\r\n    uint256 public ROXReleasePeriods = 25;\r\n    uint256 public timerROX = 30 days;\r\n    uint256 public ROXPerRelease;\r\n    uint256 public FEGperROX;\r\n    uint256 public FEGSinceLastUpgrade;\r\n    uint256 public FEGUpgraded;\r\n    uint256 public convertCheckRate = 1000000000e18;\r\n    uint256 public _fee = 10;\r\n    bool public live = true;\r\n    event Upgrade(address, uint256, uint256, uint16);\r\n    event SaveLostTokens(address, uint256);\r\n    event FEGClaimedForROX(address, uint256, uint16);\r\n    event StakeFEGClaimedForROX(address, uint256);\r\n    event DepositROX(address, uint256);\r\n    mapping(address=>uint256) public amtClaimed;\r\n    mapping(address=>bool) public claimed;\r\n    constructor() {\r\n        timer = 1717200000; //june 1st 0:00 utc\r\n    }\r\n    receive() external payable {}\r\n\r\n    modifier Live() {\r\n        require(live, \"not live\");\r\n        _;\r\n    }\r\n\r\n    function FEGStake() public view returns(address) {\r\n        return dr(dataread).FEGstake();\r\n    }\r\n    \r\n    function fee() public view returns(uint256 fee_) {\r\n        uint256 time = timerFee;\r\n        if(time > 0) {\r\n        for(uint256 i = 0; i < 25; i++) {\r\n            if(block.timestamp > time) {\r\n                time += 30 days;\r\n                fee_ += _fee;\r\n                if(fee_ >= 100) {\r\n                fee_ = 100;\r\n                break;\r\n                }\r\n            }\r\n            if(block.timestamp <= time) {\r\n                break;\r\n            }\r\n        }\r\n        }\r\n        if(time == 0) {\r\n            fee_ = 0;\r\n        }\r\n    }\r\n\r\n    function setfee(uint256 fee_) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        _fee = fee_;\r\n    }\r\n\r\n    function setDev(address addy) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        dev = addy;\r\n    }\r\n\r\n    function resetFEGChecker() external {\r\n        require(dr(dataread).superAdmin(msg.sender) || dr(dataread).isAdmin(msg.sender));\r\n        FEGSinceLastUpgrade = 0;\r\n    }\r\n\r\n    function setTimerFee(uint256 amt) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        timerFee = amt;\r\n    }\r\n\r\n    function setConvertCheckRate(uint256 amt) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        require(amt > 10000000e18, \"10m min\");\r\n        convertCheckRate = amt;\r\n    }\r\n\r\n    function loadFEGForROX(uint256 amt) external noReentrant {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        TransferHelper.safeTransferFrom(FEGv3, msg.sender, address(this), amt * 1e18);  \r\n        FEGforROXTotal += amt;\r\n        ROXPerRelease = FEGforROXTotal / ROXReleasePeriods;\r\n        FEGperROX = FEGforROXTotal * 1e9 / 1000;\r\n    }\r\n\r\n    function roundROX() public view returns(uint256 round) {\r\n        round = 1;\r\n        if(block.timestamp < timer) {\r\n        round = 0;\r\n        }\r\n        if(round > 0) {\r\n        for(uint256 i = 0; i < 26; i++) {\r\n        if(block.timestamp > timer + (timerROX * round)) {\r\n            round += 1;\r\n            if(round == 25) {\r\n            break; //failsafe\r\n            }\r\n        }\r\n        }\r\n    }\r\n    }\r\n\r\n    function costBridge(uint16 toChain) external view returns(uint256 cost) {\r\n        address brd = br(dataread).bridgeSD(FEGv3);\r\n        (cost,) = br(brd).costBridge(toChain);\r\n    }\r\n\r\n    function setLive(bool _bool) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        live = _bool;\r\n    }\r\n\r\n    function setCoolDown(uint256 amt) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        coolDown = amt;\r\n    }\r\n\r\n    function setBurnThreshold(uint256 amt) external {\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        burnThreshold = amt;\r\n    }\r\n    \r\n    function setExp(address user, bool _bool) external {\r\n        require(dr(dataread).isAdmin(msg.sender));\r\n        expired[user] = _bool;\r\n    }\r\n\r\n    function WETH() public view returns(address) {\r\n        return dr(dataread).wETH();\r\n    }\r\n\r\n    function depositROX() external noReentrant {\r\n        require(block.timestamp > timer, \"<June1\");\r\n        require(!expired[msg.sender], \"expired wallet\");\r\n        uint256 amt = IERC20(ROX).balanceOf(msg.sender);\r\n        require(!convertEnabledROX[msg.sender], \"already\");\r\n        uint256 tot = totalEligibleROXForFEG(msg.sender);\r\n        TransferHelper.safeTransferFrom(ROX, msg.sender, address(this), amt);  \r\n        convertedROX[msg.sender] = amt;\r\n        convertEnabledROX[msg.sender] = true;\r\n        FEGperDist[msg.sender] = tot / ROXReleasePeriods;\r\n        totalFEGFromROXAvailable[msg.sender] = tot;\r\n        emit DepositROX(msg.sender, amt);\r\n    }\r\n\r\n    function claimFEGRelease(uint256 amt, uint16 toChain, address to) external noReentrant payable {\r\n        require(!expired[msg.sender], \"expired wallet\");\r\n        require(convertEnabledROX[msg.sender], \"not ready\");\r\n        require(block.timestamp > lastClaimed[msg.sender] + coolDown, \"1 day cooldown\");\r\n        require(amt > 0, \"cannot claim 0\");\r\n        require(totalFEGFromROXAvailable[msg.sender] >= amt, \"over\");\r\n        uint256 tot = roundROX() * FEGperDist[msg.sender];\r\n        uint256 amtOpen = tot - FEGfromROX[msg.sender];\r\n        require(amt <= amtOpen, \"not enough open\");\r\n        lastClaimed[msg.sender] = block.timestamp;\r\n        FEGfromROX[msg.sender] += amt;\r\n        totalFEGFromROXAvailable[msg.sender] -= amt;\r\n        FEGforROXClaimed += amt;\r\n        if(toChain == 0) {\r\n        TransferHelper.safeTransfer(FEGv3,to,amt);\r\n        }\r\n        if(toChain > 0) {\r\n        address brd = br(dataread).bridgeSD(FEGv3);\r\n        (uint256 cost,) = br(brd).costBridge(toChain);\r\n        require(msg.value >= cost, \"insufficient fee\");\r\n        TransferHelper.safeApprove(FEGv3, brd, amt);\r\n        br(brd).bridge{value: cost}(toChain,amt,to);\r\n        }\r\n        emit FEGClaimedForROX(msg.sender, amt, toChain);\r\n    }\r\n\r\n    function stakeFEGRelease(uint256 amt) external noReentrant {\r\n        require(!expired[msg.sender], \"expired wallet\");\r\n        require(convertEnabledROX[msg.sender], \"not ready\");\r\n        require(block.timestamp > lastClaimed[msg.sender] + coolDown, \"1 day cooldown\");\r\n        require(amt > 0, \"cannot claim 0\");\r\n        require(totalFEGFromROXAvailable[msg.sender] >= amt, \"over\");\r\n        uint256 tot = roundROX() * FEGperDist[msg.sender];\r\n        uint256 amtOpen = tot - FEGfromROX[msg.sender];\r\n        require(amt <= amtOpen, \"not enough open\");\r\n        FEGfromROX[msg.sender] += amt;\r\n        FEGforROXClaimed += amt;\r\n        totalFEGFromROXAvailable[msg.sender] -= amt;\r\n        lastClaimed[msg.sender] = block.timestamp;\r\n        address stake = FEGStake();\r\n        TransferHelper.safeApprove(FEGv3, stake, amt);\r\n        dr(stake).stake(msg.sender, amt);\r\n        emit StakeFEGClaimedForROX(msg.sender, amt);\r\n    }\r\n\r\n    function totalEligibleROXForFEG(address holder) public view returns(uint256) {\r\n        return (IERC20(ROX).balanceOf(holder) * FEGperROX);\r\n    }\r\n\r\n    function totalOpenROXForFEG(address holder) public view returns(uint256) {\r\n        uint256 tot = roundROX() * FEGperDist[holder];\r\n        uint256 amtOpen = tot - FEGfromROX[holder];\r\n        return amtOpen;\r\n    }        \r\n\r\n    function balanceEligible(address holder) public view returns(uint256,uint256,uint256) {\r\n        uint256 fv = IERC20(FEGv1).balanceOf(holder);\r\n        uint256 totOld = fv > 1000000 ? (fv / 1000000) * 1e9: 0;\r\n        uint256 totFee;\r\n        if(fee() > 0 && totOld > 0) {\r\n        totFee = totOld * fee() / 100;\r\n        totOld -= totFee;\r\n        }\r\n        uint256 totF = IERC20(FEGv2).balanceOf(holder);\r\n        return (totOld, totFee, totF);\r\n    }\r\n\r\n    function allBalances(address holder) external view returns(uint256 fegv1, uint256 fegv2, uint256 stakev2, uint256 rox) {\r\n        fegv1 = IERC20(FEGv1).balanceOf(holder);\r\n        fegv2 = IERC20(FEGv2).balanceOf(holder);\r\n        stakev2 = StakeV2(V_2).userStakedFEG(holder);\r\n        rox = IERC20(ROX).balanceOf(holder);\r\n    }\r\n\r\n    function stakingV2Eligible(address holder) public view returns(uint256,uint256) {\r\n        uint256 sv = StakeV2(V_2).userStakedFEG(holder);\r\n        uint256 tot = sv > 1000000 ? (sv / 1000000) * 1e9: 0;\r\n        uint256 totFee;\r\n        if(fee() > 0) {\r\n        totFee += tot * fee() / 100;\r\n        tot -= totFee;\r\n        }\r\n        return (tot , totFee);\r\n    }\r\n\r\n    function upgradeFEG(uint16 toChain, address to) external noReentrant Live payable {\r\n        require(!expired[msg.sender], \"expired wallet\");\r\n        require(IERC20(FEGv1).balanceOf(msg.sender) == 0 && IERC20(V_2).balanceOf(msg.sender) == 0, \"must be 0\");\r\n        uint256 bal = IERC20(FEGv2).balanceOf(msg.sender);\r\n        FEGSinceLastUpgrade += bal;\r\n        require(FEGSinceLastUpgrade < convertCheckRate, \"reset checker\");\r\n        if(bal > 0) {\r\n        require(!claimed[msg.sender], \"done\");\r\n        require(IERC20(FEGv3).balanceOf(address(this)) >= bal + ((FEGforROXTotal * 1e18) - FEGforROXClaimed), \"fill upgrader\");\r\n        TransferHelper.safeTransferFrom(FEGv2, msg.sender, address(this), bal);  \r\n        if(toChain == 0) {\r\n        TransferHelper.safeTransfer(FEGv3,to,bal);\r\n        }\r\n        if(toChain > 0) {\r\n        address brd = br(dataread).bridgeSD(FEGv3);\r\n        (uint256 cost,) = br(brd).costBridge(toChain);\r\n        require(msg.value >= cost, \"insufficient fee\");\r\n        TransferHelper.safeApprove(FEGv3, brd, bal);\r\n        br(brd).bridge{value: cost}(toChain,bal,to);\r\n        }\r\n        claimed[msg.sender] = true;\r\n        amtClaimed[msg.sender] += bal;\r\n        }\r\n        if(IERC20(FEGv2).balanceOf(address(this)) > burnThreshold) {\r\n        addBacking();\r\n        }\r\n        emit Upgrade(msg.sender, 0 , bal, toChain);\r\n    }\r\n\r\n    function stakeUpgradeFEG() external noReentrant Live {\r\n        require(!expired[msg.sender], \"expired wallet\");\r\n        require(IERC20(FEGv1).balanceOf(msg.sender) == 0 && IERC20(V_2).balanceOf(msg.sender) == 0, \"must be 0\");\r\n        uint256 bal = IERC20(FEGv2).balanceOf(msg.sender);\r\n        if(bal > 0) {\r\n        require(!claimed[msg.sender], \"done\");\r\n        require(IERC20(FEGv3).balanceOf(address(this)) >= bal + ((FEGforROXTotal * 1e18) - FEGforROXClaimed), \"fill upgrader\");\r\n        TransferHelper.safeTransferFrom(FEGv2, msg.sender, address(this), bal);  \r\n        amtClaimed[msg.sender] += bal;\r\n        claimed[msg.sender] = true;\r\n        address stake = FEGStake();\r\n        TransferHelper.safeApprove(FEGv3, stake, bal);\r\n        dr(stake).stake(msg.sender, bal);\r\n        }\r\n        if(IERC20(FEGv2).balanceOf(address(this)) > burnThreshold) {\r\n        addBacking();\r\n        }\r\n        emit Upgrade(msg.sender, 0 , bal, 0);\r\n    }\r\n\r\n    function totalEligible(address holder) public view returns(uint256){\r\n        (uint256 a,,uint256 c) = balanceEligible(holder);\r\n        (uint256 b,) = stakingV2Eligible(holder);        \r\n        return a + b + c;\r\n    }\r\n\r\n    function saveLostTokens(address toSave) external { //added function to save any lost tokens\r\n        require(FEGv1 != toSave,\"Can't extract FEG\");\r\n        require(FEGv2 != toSave,\"Can't extract FEG\"); // only burn for backing\r\n        require(V_2 != toSave,\"Can't extract V-2\");\r\n        require(ROX != toSave,\"Can't extract V-2\");\r\n        require(WETH() != toSave,\"Can't extract WETH\");\r\n        require(dr(dataread).superAdmin(msg.sender));\r\n        uint256 toSend = IERC20(toSave).balanceOf(address(this));\r\n        TransferHelper.safeTransfer(toSave,dev,toSend);\r\n        emit SaveLostTokens(toSave, toSend);\r\n    }\r\n\r\n    function addBacking() public {\r\n        address back = backing(FEGv2).BackingLogicAddress();\r\n        uint256 bh = IERC20(FEGv2).balanceOf(address(this));\r\n        TransferHelper.safeApprove(FEGv2, back, bh);\r\n        backing(back).liquifyForBacking(bh);\r\n        address newback = backing(FEGv3).backingLogicAddress();\r\n        address weth = WETH();\r\n        TransferHelper.safeTransfer(weth, newback, IERC20(weth).balanceOf(address(this))); \r\n    }\r\n\r\n    function upgradeAllOLD(uint16 toChain, address to) external noReentrant Live payable {\r\n        require(!claimed[msg.sender]);\r\n        require(!expired[msg.sender], \"expired wallet\");\r\n        address user = msg.sender;\r\n        uint256 toSend = 0;\r\n        (uint256 old, uint256 fbe, uint256 old2) = balanceEligible(user);\r\n        if(old > 0){\r\n        TransferHelper.safeTransferFrom(FEGv1, user, address(this), IERC20(FEGv1).balanceOf(user));\r\n        }\r\n        if(old2 > 0){\r\n        TransferHelper.safeTransferFrom(FEGv2, user, address(this), IERC20(FEGv2).balanceOf(user));  \r\n        if(IERC20(FEGv2).balanceOf(address(this)) > burnThreshold) {\r\n        addBacking();\r\n        } \r\n        }\r\n        toSend += (old + old2);\r\n        //Staking V_2\r\n        (uint256 v2Bal, uint256 v2v) = stakingV2Eligible(user);\r\n        uint256 v2tot = IERC20(V_2).balanceOf(user);\r\n        if(v2Bal > 0){\r\n        //V_2 logic\r\n        toSend += v2Bal;\r\n        TransferHelper.safeTransferFrom(V_2, user, address(this), v2tot);\r\n        //Guarantee transfer of FSS\r\n        require(IERC20(V_2).balanceOf(user) == 0, \"Must be left with 0 FSS balance\");\r\n        }\r\n        FEGSinceLastUpgrade += toSend;\r\n        require(FEGSinceLastUpgrade < convertCheckRate, \"reset checker\");\r\n        //checks if the person get's anything\r\n        require(toSend > 0, \"Nothing to upgrade\");\r\n        require(IERC20(FEGv3).balanceOf(address(this)) >= toSend + ((FEGforROXTotal * 1e18) - FEGforROXClaimed), \"fill upgrader\");\r\n        amtClaimed[user] += toSend + fbe + v2v;\r\n        claimed[user] = true; \r\n        if(toChain == 0) {\r\n        TransferHelper.safeTransfer(FEGv3,to,toSend);\r\n        }\r\n        if(toChain > 0) {\r\n        address brd = br(dataread).bridgeSD(FEGv3);\r\n        (uint256 cost,) = br(brd).costBridge(toChain);\r\n        require(msg.value >= cost, \"insufficient fee\");\r\n        TransferHelper.safeApprove(FEGv3, brd, toSend);\r\n        br(brd).bridge{value: cost}(toChain,toSend,to);\r\n        }\r\n        emit Upgrade(user, v2Bal, toSend, toChain);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DepositROX\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"FEGClaimedForROX\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SaveLostTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"StakeFEGClaimedForROX\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEGSinceLastUpgrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGUpgraded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGforROXClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGforROXTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"FEGfromROX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"FEGperDist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGperROX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGv1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGv2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGv3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROXPerRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROXReleasePeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"V_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addBacking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"allBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fegv1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fegv2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakev2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rox\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amtClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"balanceEligible\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimFEGRelease\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convertCheckRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"convertEnabledROX\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"convertedROX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coolDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"}],\"name\":\"costBridge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataread\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositROX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"expired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"loadFEGForROX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetFEGChecker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundROX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toSave\",\"type\":\"address\"}],\"name\":\"saveLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setBurnThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setConvertCheckRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setCoolDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setExp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setTimerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"setfee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"stakeFEGRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeUpgradeFEG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"stakingV2Eligible\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerROX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"totalEligible\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"totalEligibleROXForFEG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalFEGFromROXAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"totalOpenROXForFEG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"upgradeAllOLD\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"upgradeFEG\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Upgrader", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8e15d6a33001e6c121a7f579ea98bb5f562573b7647a49bc819028b24d682e9d"}