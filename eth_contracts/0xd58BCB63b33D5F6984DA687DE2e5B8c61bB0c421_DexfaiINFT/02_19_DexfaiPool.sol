// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.19;

import "IDexfaiPool.sol";
import "IERC20.sol";
import "IDexfaiFactory.sol";

/**
 * @title Xfai's Dexfai Pools
 * @author Xfai
 * @notice DexfaiPool are contracts that get generated by the DexfaiFactory. Every hosted token has one unique pool that holds the state (i.e. pool reserve, balance, weights) for the given token.
 */
contract DexfaiPool is IDexfaiPool {
  /**
   * @notice The ERC20 token name for the LP token
   */
  string public override name;

  /**
   * @notice The ERC20 token symbol for the LP token
   */
  string public override symbol;

  /**
   * @notice The ERC20 token decimals for the LP token
   */
  uint8 public constant override decimals = 18;

  /**
   * @notice Structure to capture time period obervations every 15 minutes, used for local oracles
   */
  struct Observation {
    uint rCumulative;
    uint wCumulative;
    uint timestamp;
  }

  /**
   * @notice The amount of time within a period.
   * @dev Used to capture oracle reading every 15 minutes
   */
  uint private constant PERIOD_SIZE = 900;

  /**
   * @notice The total size of the ring buffer
   * @dev Stores every PERIOD_SIZE a new record. The buffer can store up to 1 week of data
   */
  uint private constant RING_SIZE = 672;

  /**
   * @notice The ring buffer counter
   * @dev Used to determine the latest index within the ring buffer
   */
  uint public ringBufferNonce = 0;

  /**
   * @notice The ring buffer array
   */
  Observation[RING_SIZE] public override observations;

  /**
   * @notice The pool reserve
   */
  uint private r;

  /**
   * @notice Pool weight
   * @dev w is used to compute the exchange value of a token
   */
  uint private w;

  /**
   * @notice The last block timestamp
   */
  uint private blockTimestampLast;

  /**
   * @notice The cumulative reserve value
   * @dev used to compute TWAPs
   */
  uint private rCumulativeLast;

  /**
   * @notice The cumulative w value
   * @dev used to compute TWAPs
   */
  uint private wCumulativeLast;

  /**
   * @notice The total supply of LP tokens
   */
  uint public override totalSupply = 0;

  uint private seeded = 1;
  IDexfaiFactory private dexfaiFactory;

  /**
   * @notice The ERC20 token address for which the pool was created. Not the same with the LP token address
   */
  address public override poolToken;

  /**
   * @notice the domain seperator. Used for permits
   */
  bytes32 public override DOMAIN_SEPARATOR;

  /**
   * @notice the permit typehash. Used for permits
   * @dev keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
   */
  bytes32 public constant override PERMIT_TYPEHASH =
    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

  /**
   * @notice mapping used to determine the nonce of an address. Used for permits
   */
  mapping(address => uint) public override nonces;

  /**
   * @notice mapping used to determine the allowance of an address for another address
   */
  mapping(address => mapping(address => uint)) public override allowance;

  /**
   * @notice mapping used to determine the LP token balance of an address
   */
  mapping(address => uint) public override balanceOf;

  modifier linked() {
    address core = getDexfaiCore();
    require(msg.sender == core, 'DexfaiPool: NOT_CORE');
    _;
  }

  /**
   * @notice Construct the DexfaiPool
   * @dev The parameters of the pool are omitted in the construct and are instead specified via the initialize function
   */
  constructor() {
    write(0, 0, block.timestamp);

    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(
          'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'
        ),
        keccak256(bytes(name)),
        keccak256('1'),
        block.chainid,
        address(this)
      )
    );
  }

  // **** Oracle Functions ****

  /**
   * @notice Computes the latest index within the ring buffer
   * @dev The returned index will point at the latest 'empty' position within the ring buffer, i.e. the index for which the time period has not yet been reached
   * @return index The current index within the price oracle ring bufffer
   */
  function getCurrentIndex() public view override returns (uint16 index) {
    index = uint16(ringBufferNonce % RING_SIZE);
  }

  function write(uint _r, uint _w, uint _blockTimestamp) private returns (uint16 index) {
    index = getCurrentIndex();
    observations[index] = Observation(_r, _w, _blockTimestamp);
    ringBufferNonce += 1;
    emit Write(_r, _w, _blockTimestamp);
  }

  /**
   * @notice Fetches the N-th latest stored observation from the ring buffer
   * @dev E.g. If _n = 1, getNthObservation returns the lastest observation. If _n = 2, getNthObservation returns the previous (2nd lastest) observation
   * @param _n The N-th observation that one wants to fetch
   * @return rCumulative The rCumulative of the N-th observation
   * @return wCumulative The wCumulative of the N-th observation
   * @return timestamp The timestamp of the N-th observation
   */
  function getNthObservation(
    uint _n
  ) public view override returns (uint rCumulative, uint wCumulative, uint timestamp) {
    require(ringBufferNonce >= _n, 'DexfaiPool: INEXISTENT_HISTORY');
    require(_n < RING_SIZE, 'DexfaiPool: OVERRIDDEN_HISTORY');
    uint16 index = uint16((ringBufferNonce - _n) % RING_SIZE);
    Observation memory point = observations[index];
    rCumulative = point.rCumulative;
    wCumulative = point.wCumulative;
    timestamp = point.timestamp;
  }

  /**
   * @notice Fetches the latest cummulativeLast values of the pool
   * @return rCumulativeLast The cummulative r of the pool
   * @return wCumulativeLast The cummulative w of the pool
   * @return blockTimestampLast The cummulative timestamp of the pool
   */
  function getCumulativeLast() public view override returns (uint, uint, uint) {
    return (rCumulativeLast, wCumulativeLast, blockTimestampLast);
  }

  // **** Pool Functions ****

  /**
   * @notice Called once by the factory at time of deployment
   * @param _token The ERC20 token address of the pool
   * @param _dexfaiFactory The Dexfai Factory of the pool
   */
  function initialize(address _token, address _dexfaiFactory) external override {
    require(seeded == 1, 'DexfaiPool: DEX_SEEDED');
    poolToken = _token;
    dexfaiFactory = IDexfaiFactory(_dexfaiFactory);
    name = string(abi.encodePacked(IERC20(_token).name(), '-Xfai'));
    symbol = string(abi.encodePacked(IERC20(_token).symbol(), '-Xfai'));
    seeded = 2;
  }

  /**
   * @notice Get the current Dexfai Core that is allowed to modify the pool state
   */
  function getDexfaiCore() public view override returns (address) {
    return dexfaiFactory.getDexfaiCore();
  }

  /**
   * @notice Get the current reserve, weight, and last block timestamp of the pool
   */
  function getStates() external view override returns (uint, uint, uint) {
    return (r, w, blockTimestampLast);
  }

  /**
   * @notice Updates the reserve and weight. On the first call per block updates cumulative states.
   * @dev This function is linked. Only the latest Dexfai core can call it
   * @param _balance The latest balance of the pool
   * @param _r The latest reserve of the pool
   * @param _w The latest w weight of the pool
   */
  function update(uint _balance, uint _r, uint _w) external override linked {
    uint blockTimestamp = block.timestamp;
    uint timeElapsed = blockTimestamp - blockTimestampLast;
    if (timeElapsed > 0 && _r != 0) {
      unchecked {
        rCumulativeLast += _r * timeElapsed;
        wCumulativeLast += _w * timeElapsed;
      }
    }
    (, , uint timestamp) = getNthObservation(1);
    timeElapsed = blockTimestamp - timestamp; // compare the last observation with current timestamp, if greater than 15 minutes, record a new event
    if (timeElapsed > PERIOD_SIZE && _r != 0) {
      write(rCumulativeLast, wCumulativeLast, blockTimestamp);
    }
    r = _balance;
    w = _w;
    blockTimestampLast = blockTimestamp;
    emit Sync(_balance, _w);
  }

  /**
   * @notice transfer the pool's ERC20 token (not LP token)
   * @dev This function is linked. Only the latest Dexfai core can call it
   * @param _token The pool's ERC20 token address
   * @param _to The recipient of the tokens
   * @param _value The amount of tokens
   */
  function safeTransfer(address _token, address _to, uint256 _value) external override linked {
    require(_token.code.length > 0, 'DexfaiPool: TRANSFER_FAILED');
    (bool success, bytes memory data) = _token.call(
      abi.encodeWithSelector(IERC20.transfer.selector, _to, _value)
    );
    require(
      success && (data.length == 0 || abi.decode(data, (bool))),
      'DexfaiPool: TRANSFER_FAILED'
    );
  }

  // **** ERC20 Functions ****

  /**
   * @notice This function mints new ERC20 LP tokens
   * @dev This function is linked. Only the latest Dexfai core can call it
   * @param _to The recipient of the tokens
   * @param _amount The amount of tokens
   */
  function mint(address _to, uint _amount) public override linked {
    _mint(_to, _amount);
  }

  /**
   * @notice This function burns existing ERC20 LP tokens
   * @dev This function is linked. Only the latest Dexfai core can call it
   * @param _to The recipient whose tokens get burned
   * @param _amount The amount of tokens burned
   */
  function burn(address _to, uint _amount) public override linked {
    _burn(_to, _amount);
  }

  function _mint(address _dst, uint _amount) internal {
    totalSupply += _amount;
    balanceOf[_dst] += _amount;
    emit Transfer(address(0), _dst, _amount);
  }

  function _burn(address _dst, uint _amount) internal {
    totalSupply -= _amount;
    balanceOf[_dst] -= _amount;
    emit Transfer(_dst, address(0), _amount);
  }

  /**
   * @notice The ERC20 standard approve function
   */
  function approve(address _spender, uint _amount) external override returns (bool) {
    allowance[msg.sender][_spender] = _amount;

    emit Approval(msg.sender, _spender, _amount);
    return true;
  }

  /**
   * @notice The ERC20 standard permit function
   */
  function permit(
    address _owner,
    address _spender,
    uint _value,
    uint _deadline,
    uint8 _v,
    bytes32 _r,
    bytes32 _s
  ) external override {
    require(_deadline >= block.timestamp, 'DexfaiPool: EXPIRED');
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR,
        keccak256(
          abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _deadline)
        )
      )
    );
    address recoveredAddress = ecrecover(digest, _v, _r, _s);
    require(recoveredAddress != address(0), 'DexfaiPool: INVALID_SIGNATURE');
    require(recoveredAddress == _owner, 'DexfaiPool: INVALID_SIGNATURE');
    allowance[_owner][_spender] = _value;

    emit Approval(_owner, _spender, _value);
  }

  /**
   * @notice The ERC20 standard transfer function
   */
  function transfer(address _dst, uint _amount) external override returns (bool) {
    _transferTokens(msg.sender, _dst, _amount);
    return true;
  }

  /**
   * @notice The ERC20 standard transferFrom function
   */
  function transferFrom(address _src, address _dst, uint _amount) external override returns (bool) {
    address spender = msg.sender;
    uint spenderAllowance = allowance[_src][spender];

    if (spender != _src && spenderAllowance != type(uint).max) {
      uint newAllowance = spenderAllowance - _amount;
      allowance[_src][spender] = newAllowance;

      emit Approval(_src, spender, newAllowance);
    }

    _transferTokens(_src, _dst, _amount);
    return true;
  }

  function _transferTokens(address _src, address _dst, uint _amount) internal {
    balanceOf[_src] -= _amount;
    balanceOf[_dst] += _amount;

    emit Transfer(_src, _dst, _amount);
  }
}