{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/marginAccount/AccountFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    IAccountFactory\\n} from \\\"contracts/interfaces/accountAbstraction/marginAccount/IAccountFactory.sol\\\";\\nimport {IInitializable} from \\\"contracts/interfaces/common/IInitializable.sol\\\";\\n\\nimport {AccessControlDS} from \\\"contracts/base/auth/AccessControlDS.sol\\\";\\nimport {BeaconDS} from \\\"contracts/base/proxy/BeaconDS.sol\\\";\\nimport {ImmutableBeaconProxy} from \\\"contracts/base/proxy/ImmutableBeaconProxy.sol\\\";\\n\\nimport {AccountFactoryRepository as Repository} from \\\"./libraries/AccountFactoryRepository.sol\\\";\\n\\ncontract AccountFactory is IAccountFactory, AccessControlDS, BeaconDS {\\n    bytes32 public constant MARGIN_ENGINE = keccak256(\\\"Margin Engine\\\");\\n\\n    function borrowAccount() external override onlyRole(MARGIN_ENGINE) returns (address account) {\\n        account = Repository.isMarginAccountsPoolEmpty()\\n            ? deployMarginAccount()\\n            : Repository.popMarginAccount();\\n\\n        emit AccountBorrowed(account);\\n    }\\n\\n    function returnAccount(address account) external override onlyRole(MARGIN_ENGINE) {\\n        Repository.pushMarginAccount(account);\\n        emit AccountReturned(address(account));\\n    }\\n\\n    function deployMarginAccounts(uint256 _count) external override onlyOwner {\\n        for (uint256 i; i < _count; i++) {\\n            Repository.pushMarginAccount(deployMarginAccount());\\n        }\\n    }\\n\\n    function deployMarginAccount() internal returns (address) {\\n        bytes memory initData = abi.encodeCall(IInitializable.initialize, ());\\n        address acc = address(new ImmutableBeaconProxy(initData));\\n        emit AccountDeployed(acc);\\n        return acc;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/marginAccount/libraries/AccountFactoryRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary AccountFactoryRepository {\\n    struct State {\\n        uint256 nonce;\\n        address[] pool;\\n    }\\n\\n    bytes32 private constant STORAGE_POSITION = keccak256(\\\"Margin Account Factory State V1\\\");\\n\\n    error MarginAccountsPoolIsEmpty();\\n    error MarginAccountImplementationNotFound();\\n\\n    function pushMarginAccount(address _account) internal {\\n        state().pool.push(_account);\\n    }\\n\\n    function popMarginAccount() internal returns (address account_) {\\n        if (isMarginAccountsPoolEmpty()) revert MarginAccountsPoolIsEmpty();\\n        uint256 last = state().pool.length - 1;\\n        account_ = state().pool[last];\\n        state().pool.pop();\\n    }\\n\\n    function getAndIncrementNonce() internal returns (bytes32) {\\n        return bytes32(state().nonce++);\\n    }\\n\\n    function getNonce() internal view returns (bytes32) {\\n        return bytes32(state().nonce);\\n    }\\n\\n    function isMarginAccountsPoolEmpty() internal view returns (bool) {\\n        return state().pool.length == 0;\\n    }\\n\\n    function state() private pure returns (State storage s_) {\\n        bytes32 storageSlot = STORAGE_POSITION;\\n        assembly {\\n            s_.slot := storageSlot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/auth/AccessControlDS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {OwnableReadonlyDS} from \\\"./OwnableReadonlyDS.sol\\\";\\n\\nabstract contract AccessControlDS is AccessControl, OwnableReadonlyDS {\\n    function hasRole(bytes32 _role, address _account) public view virtual override returns (bool) {\\n        return (isOwnerRole(_role) && _owner() == _account) || super.hasRole(_role, _account);\\n    }\\n\\n    function isOwnerRole(bytes32 _role) private pure returns (bool) {\\n        return _role == DEFAULT_ADMIN_ROLE;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/auth/OwnableReadonly.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {UnauthorizedAccount} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\nimport {Address} from \\\"contracts/libraries/Address.sol\\\";\\n\\n/**\\n * @dev We intentionally do not expose \\\"owner()\\\" publicly\\n * due to possible conflicts with \\\"OwnershipFacet\\\"\\n * https://github.com/mudgen/diamond-3-hardhat/blob/main/contracts/facets/OwnershipFacet.sol\\n */\\nabstract contract OwnableReadonly {\\n    using Address for bytes32;\\n\\n    modifier onlyOwner() {\\n        enforceIsContractOwner();\\n        _;\\n    }\\n\\n    function _owner() internal view returns (address) {\\n        return _ownerSlot().get();\\n    }\\n\\n    function _ownerSlot() internal pure virtual returns (bytes32);\\n\\n    function enforceIsContractOwner() private view {\\n        if (msg.sender != _owner()) revert UnauthorizedAccount(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/auth/OwnableReadonlyDS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {DiamondLibrary} from \\\"contracts/libraries/DiamondLibrary.sol\\\";\\nimport {OwnableReadonly} from \\\"./OwnableReadonly.sol\\\";\\n\\n/**\\n * @notice Use DiamondStorage's owner slot for OwnableReadonly\\n */\\nabstract contract OwnableReadonlyDS is OwnableReadonly {\\n    function _ownerSlot() internal pure override returns (bytes32 slot_) {\\n        DiamondLibrary.DiamondStorage storage ds = DiamondLibrary.diamondStorage();\\n        assembly {\\n            // DiamondLib will not change so it's safe to hardcode owner offset here\\n            let ownerOffsetInDiamondStorage := 4\\n            slot_ := add(ds.slot, ownerOffsetInDiamondStorage)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/proxy/BeaconDS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {AlreadyUpToDate} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\nimport {IBeacon} from \\\"contracts/interfaces/base/proxy/IBeacon.sol\\\";\\nimport {OwnableReadonlyDS} from \\\"contracts/base/auth/OwnableReadonlyDS.sol\\\";\\n\\ncontract BeaconDS is IBeacon, OwnableReadonlyDS {\\n    bytes32 private constant IMPLEMENTATION_SLOT = keccak256(\\\"Implementation slot inside BeaconDS\\\");\\n\\n    function upgradeTo(address newImplementation) external override onlyOwner {\\n        if (newImplementation == address(0)) revert ImplementationAddressIsZero();\\n        if (_implementation() == newImplementation) revert AlreadyUpToDate();\\n\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n\\n    function implementation() external view override returns (address impl) {\\n        if ((impl = _implementation()) == address(0)) revert ImplementationAddressIsZero();\\n    }\\n\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/proxy/ImmutableBeaconProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\nimport {Proxy} from \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport {IBeacon} from \\\"contracts/interfaces/base/proxy/IBeacon.sol\\\";\\nimport {SafeCall} from \\\"contracts/libraries/SafeCall.sol\\\";\\n\\ncontract ImmutableBeaconProxy is Proxy {\\n    using {SafeCall.safeDelegateCall} for address;\\n\\n    address private immutable beacon;\\n\\n    error BeaconCallFailed();\\n    error BeaconReturnedUnexpectedNumberOfBytes(uint256);\\n    error BeaconReturnedAddressZero();\\n\\n    constructor(bytes memory initDataWithSelector) {\\n        beacon = msg.sender;\\n\\n        if (initDataWithSelector.length > 0) {\\n            _implementation().safeDelegateCall(initDataWithSelector);\\n        } else {\\n            // Make sure msg.sender implements IBeacon interface\\n            _implementation();\\n        }\\n    }\\n\\n    function _implementation() internal view override returns (address impl) {\\n        (bool success, bytes memory result) = beacon.staticcall(\\n            abi.encodeCall(IBeacon.implementation, ())\\n        );\\n\\n        if (!success) revert BeaconCallFailed();\\n        if (result.length != 32) revert BeaconReturnedUnexpectedNumberOfBytes(result.length);\\n\\n        impl = abi.decode(result, (address));\\n        if (impl == address(0)) revert BeaconReturnedAddressZero();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/Command.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {CommandLibrary} from \\\"contracts/libraries/CommandLibrary.sol\\\";\\n\\n/**\\n * @title Command\\n * @notice Contains arguments for a low-level call.\\n * @dev This struct allows deferring the call's execution, suspending it by passing it to another function or contract.\\n * @dev `target` The address to be called.\\n * @dev `value` Value to send in the call.\\n * @dev `payload` Encoded call with function selector and arguments.\\n */\\nstruct Command {\\n    address target;\\n    uint256 value;\\n    bytes payload;\\n}\\n\\nusing CommandLibrary for Command global;\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/marginAccount/IAccountFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IAccountFactory {\\n    /// @notice Logged when new margin account is deployed\\n    event AccountDeployed(address indexed account);\\n    /// @notice Logged every time a margin account being assigned to a new owner\\n    event AccountBorrowed(address indexed account);\\n    /// @notice Logged every time a margin account being unassigned from the previous owner\\n    event AccountReturned(address indexed account);\\n\\n    /**\\n     * @notice Allows *Margin Engine* to borrow an account for registration.\\n     * @return Address of the borrowed account.\\n     */\\n    function borrowAccount() external returns (address);\\n\\n    /**\\n     * @notice After account was closed or liquidated *Margin Engine* returns it to the factory for later reuse.\\n     * @param account Address of the account to return.\\n     */\\n    function returnAccount(address account) external;\\n\\n    /**\\n     * @notice Utility to deploy multiple margin accounts for future use\\n     * @param count Number of margin accounts to deploy\\n     */\\n    function deployMarginAccounts(uint256 count) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/base/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @notice An error indicating that the amount for the specified token is zero.\\n * @param token The address of the token with a zero amount.\\n */\\nerror AmountMustNotBeZero(address token);\\n\\n/**\\n * @notice An error indicating that an address must not be zero.\\n */\\nerror AddressMustNotBeZero();\\n\\n/**\\n * @notice An error indicating that an array must not be empty.\\n */\\nerror ArrayMustNotBeEmpty();\\n\\n/**\\n * @notice An error indicating storage is already up to date and doesn't need further processing.\\n * @dev This error is thrown when attempting to update an entity(s) that is(are) already up to date.\\n */\\nerror AlreadyUpToDate();\\n\\n/**\\n * @notice An error indicating that an action is unauthorized for the specified account.\\n * @param account The address of the unauthorized account.\\n */\\nerror UnauthorizedAccount(address account);\\n\"\r\n    },\r\n    \"contracts/interfaces/base/proxy/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IBeacon {\\n    error ImplementationAddressIsZero();\\n\\n    /**\\n     * This upgrade will affect all Beacon Proxies that use this Beacon\\n     * @param newImplementation New implementation to delegate calls from Beacon Proxies\\n     */\\n    function upgradeTo(address newImplementation) external;\\n\\n    /**\\n     * Returns address of the current used by Beacon Proxies\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/common/IInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IInitializable {\\n    function initialize() external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary Address {\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    function set(bytes32 _slot, address _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    function get(bytes32 _slot) internal view returns (address result_) {\\n        assembly {\\n            result_ := sload(_slot)\\n        }\\n    }\\n\\n    function isEth(address _token) internal pure returns (bool) {\\n        return _token == ETH || _token == address(0);\\n    }\\n\\n    function sort(address _a, address _b) internal pure returns (address, address) {\\n        return _a < _b ? (_a, _b) : (_b, _a);\\n    }\\n\\n    function sort(address[4] memory _array) internal pure returns (address[4] memory _sorted) {\\n        // Sorting network for the array of length 4\\n        (_sorted[0], _sorted[1]) = sort(_array[0], _array[1]);\\n        (_sorted[2], _sorted[3]) = sort(_array[2], _array[3]);\\n\\n        (_sorted[0], _sorted[2]) = sort(_sorted[0], _sorted[2]);\\n        (_sorted[1], _sorted[3]) = sort(_sorted[1], _sorted[3]);\\n        (_sorted[1], _sorted[2]) = sort(_sorted[1], _sorted[2]);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/CommandLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Command} from \\\"contracts/interfaces/accountAbstraction/interpreter/Command.sol\\\";\\nimport {SafeCall} from \\\"contracts/libraries/SafeCall.sol\\\";\\n\\n/**\\n * @notice Utility to convert often-used methods into a Command object\\n */\\nlibrary CommandPresets {\\n    function approve(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal pure returns (Command memory cmd_) {\\n        cmd_.target = _token;\\n        cmd_.payload = abi.encodeCall(IERC20.approve, (_to, _amount));\\n    }\\n\\n    function transfer(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal pure returns (Command memory cmd_) {\\n        cmd_.target = _token;\\n        cmd_.payload = abi.encodeCall(IERC20.transfer, (_to, _amount));\\n    }\\n}\\n\\nlibrary CommandExecutor {\\n    using SafeCall for Command[];\\n\\n    function execute(Command[] calldata _cmds) external {\\n        _cmds.safeCallAll();\\n    }\\n}\\n\\nlibrary CommandLibrary {\\n    using CommandLibrary for Command[];\\n\\n    function last(Command[] memory _self) internal pure returns (Command memory) {\\n        return _self[_self.length - 1];\\n    }\\n\\n    function asArray(Command memory _self) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](1);\\n        result_[0] = _self;\\n    }\\n\\n    function concat(\\n        Command memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](2);\\n        result_[0] = _self;\\n        result_[1] = _cmd;\\n    }\\n\\n    function concat(\\n        Command memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_cmds.length + 1);\\n        result_[0] = _self;\\n        for (uint256 i = 1; i < result_.length; i++) {\\n            result_[i] = _cmds[i - 1];\\n        }\\n    }\\n\\n    function append(\\n        Command[] memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_self.length + _cmds.length);\\n        uint256 i;\\n        for (; i < _self.length; i++) {\\n            result_[i] = _self[i];\\n        }\\n        for (; i < result_.length; i++) {\\n            result_[i] = _cmds[i - _self.length];\\n        }\\n    }\\n\\n    function push(\\n        Command[] memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_self.length + 1);\\n        for (uint256 i; i < _self.length; i++) {\\n            result_[i] = _self[i];\\n        }\\n        result_[_self.length] = _cmd;\\n    }\\n\\n    function unshift(\\n        Command[] memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](1 + _self.length);\\n        result_[0] = _cmd;\\n        for (uint256 i = 1; i < result_.length; i++) {\\n            result_[i] = _self[i - 1];\\n        }\\n    }\\n\\n    function unshift(\\n        Command[] memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_cmds.length + _self.length);\\n        uint256 i;\\n        for (; i < _cmds.length; i++) {\\n            result_[i] = _cmds[i];\\n        }\\n        for (; i < result_.length; i++) {\\n            result_[i] = _self[i - _cmds.length];\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amount != 0) {\\n            result_ = CommandPresets.approve(_token, _self.target, _amount).concat(_self);\\n        } else {\\n            result_ = _self.asArray();\\n        }\\n    }\\n\\n    function populateWithRevokeAndApprove(\\n        Command memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        return\\n            CommandPresets.approve(_token, _self.target, 0).concat(\\n                _self.populateWithApprove(_token, _amount)\\n            );\\n    }\\n\\n    function populateWithApprove(\\n        Command[] memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amount != 0) {\\n            result_ = _self.unshift(\\n                CommandPresets.approve(_token, _self[_self.length - 1].target, _amount)\\n            );\\n        } else {\\n            result_ = _self;\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[2] memory _tokens,\\n        uint256[2] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] != 0) {\\n                result_ = populateWithApprove(_self, _tokens[0], _amounts[0]);\\n            } else {\\n                result_ = populateWithApprove(_self, _tokens[1], _amounts[1]);\\n            }\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[3] memory _tokens,\\n        uint256[3] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0 && _amounts[2] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(CommandPresets.approve(_tokens[2], _self.target, _amounts[2]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[1], _tokens[2]],\\n                    [_amounts[1], _amounts[2]]\\n                );\\n            } else if (_amounts[1] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[2]],\\n                    [_amounts[0], _amounts[2]]\\n                );\\n            } else {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1]],\\n                    [_amounts[0], _amounts[1]]\\n                );\\n            }\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[4] memory _tokens,\\n        uint256[4] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0 && _amounts[2] != 0 && _amounts[3] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(CommandPresets.approve(_tokens[2], _self.target, _amounts[2]))\\n                .push(CommandPresets.approve(_tokens[3], _self.target, _amounts[3]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[1], _tokens[2], _tokens[3]],\\n                    [_amounts[1], _amounts[2], _amounts[3]]\\n                );\\n            } else if (_amounts[1] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[2], _tokens[3]],\\n                    [_amounts[0], _amounts[2], _amounts[3]]\\n                );\\n            } else if (_amounts[2] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1], _tokens[3]],\\n                    [_amounts[0], _amounts[1], _amounts[3]]\\n                );\\n            } else {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1], _tokens[2]],\\n                    [_amounts[0], _amounts[1], _amounts[2]]\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DiamondLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary DiamondLibrary {\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    bytes32 private constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds_) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds_.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Command} from \\\"contracts/interfaces/accountAbstraction/interpreter/Command.sol\\\";\\n\\n/**\\n * @notice Safe methods performing a low-level calls that revert\\n * if the call was not successful\\n */\\nlibrary SafeCall {\\n    using Address for address;\\n\\n    function safeCallAll(Command[] memory _cmds) internal {\\n        for (uint256 i; i < _cmds.length; i++) {\\n            safeCall(_cmds[i]);\\n        }\\n    }\\n\\n    function safeCall(Command memory _cmd) internal returns (bytes memory result_) {\\n        result_ = safeCall(_cmd.target, _cmd.value, _cmd.payload);\\n    }\\n\\n    function safeCall(address _target, bytes memory _data) internal returns (bytes memory result_) {\\n        result_ = safeCall(_target, 0, _data);\\n    }\\n\\n    function safeCall(\\n        address _target,\\n        uint256 _value,\\n        bytes memory _data\\n    ) internal returns (bytes memory result_) {\\n        result_ = _target.functionCallWithValue(_data, _value);\\n    }\\n\\n    function safeDelegateCall(\\n        address _target,\\n        bytes memory _data\\n    ) internal returns (bytes memory result_) {\\n        result_ = _target.functionDelegateCall(_data);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyUpToDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ImplementationAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarginAccountsPoolIsEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountBorrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARGIN_ENGINE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"deployMarginAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"returnAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AccountFactory", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}