/********************** @2022 Wizarre, All rights reserved *********************
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMmMMMMMMMMMMMMMNNMMMMNddNMMMMmmmmmNMMMMNddNMMMMNMMMMMMMMMMMMMMmMMMMMMMMM
MMMMMMMMdysNhoossydNMmosyyMM+ddd-NhssdNMMNdsshN-ddd+MMsysomMNdyssoohNysdMMMMMMMM
MMMMMMMMmss::NMMh/+o+/-ohhMMhhdm`:hNNmMMMMmMNy:.mdhhMNhho-/+o+/dMMN-:ssmMMMMMMMM
MMMMMMMMNoMhyhdNNNmsoyNh/:mMMMs.oNMhoNMMMMmodMNo.yMMMd:/hNyoymNNNdhyhNoNMMMMMMMM
MMMMMMMNy/:shhhhy/-syyhhy`.hho :hho-yhhhhhhy-shh: ohh.`yhhyyo./yhhhhs:/hNMMMMMMM
MMMMMMMd `+://sso:`.`---/:osoo.syhh+yyyssyyyohhyo-osso:/---`.`/oss//:o  mMMMMMMM
MMMMMMMd `s+s+:..``.-+yhmyddhhsmyoyosddyyddsoyoymsyhdhymhy+-.``..:+s+y  mMMMMMMM
MMMMMMMd  sm`  -shhy. sMNys+ho+ssymyoodmmhooydyos+oh+yyMMo -yhhs-  `ms  mMMMMMMM
MMMMMMMd `yds` `/ss+:/hddddhhodNNhdssyNMMNyssdhNNhshhddddh/:+ss/` `ydy  mMMMMMMM
MMMMMMMd  ooNh/-..`````     :sdhdssddshmmhsddsydhdo-     `````..-/dNoo  mMMMMMMM
MMMMMMMd `md+ymddysohs.   `odmmdoyNoNmohhoNNoNssdmmho`   .yhosyddmy+dm  mMMMMMMM
MMMMMMMd `Nmh+/oyo-+o` `  syMMsM/dy/NhdyhhhN:yd+MsMNyo  ` `o+-oyo:+hmm  mMMMMMMM
MMMMMMMd  -NNy+/+yy.  :../odyhohssohyhsooshshossh+hyd+/`-:  -yy+/+yNm.  mMMMMMMM
MMMMMMMd -/-::yNN/   +/`so/shhssyhyy+yy++hy+hshysyhho:oo`++   +Nms::-/. mMMMMMMM
MMMMMMMd oMy/MMh.   ss hMNNhs+:/++++/yhyyhy/++++::oshNhNy ys   .hMM:hM+ mMMMMMMM
MMMMMMMd hMooMo    ym`oMdhymhyo/    `ooo+oo`    .shhdmyhM+`ms    oM+oMy mMMMMMMM
MMMMMMMd mMsy-    yM:`Nmsdyhysys:  ` `:ys/` ` `hmMMdsshsom /My    :ysMm mMMMMMMM
MMMMMMMd.MMd.    yMh :yssMNhshymNy: /``Nm .: .yNdMN/hmMddM- dMs    .mMM`mMMMMMMM
MMMMMMMdoMh`    oMM- :omdoMMMMdhddm/ s.--.s /mhshMhydhhdoN/ :MM+    `dM+mMMMMMMM
MMMMMMMdmh`    :MMd  /yhhh+s:ysyy+hN+`d..d`+ddhyyssNNyddss+  mMM-    `ddmMMMMMMM
MMMMMMMMh`     dMMy  :hodoNoy+hysdmym-+dd/-mymhdhdyd+NNmyN-  hMMd     `hMMMMMMMM
MMMMMMMM.      .sNMh- /yddyms+NMm:mmhs`Nm yMmhdssyhs+dy+o: -dMNs`      .MMMMMMMM
MMMMMMMNd:       .sNNs.`sNNyhhoNMm+dh-`dd`:Moymhhdyhsdho`.sNNs.       /mMMMMMMMM
MMMMMMMdhmo:`      .odm+`:sddmmsmmo/o +--+ /dymddhhmms-`+md+`      `:sNymMMMMMMM
MMMMMMMd/sy:do-      `:hh/`:sdmdydm- ./  /``odmyhydo-./dy:`      -sh:yy:mMMMMMMM
MMMMMMMd`m/.+shh+-      .os/`:ohdds  - // - `hMNhs-./s+.     `-+hhs/./m mMMMMMMM
MMMMMMMd -.mho/-hNds:.    `-/-`.oo`    --    `oo-`-/-`   `./sdNy-/sdm`- mMMMMMMM
MMMMMMMd  oMoo/.mNyooss+/-`  ``       `/:`       ``  .-/+ssoohMm.+osMo  mMMMMMMM
MMMMMMMd  myssh+hN.`o++/oNmo+/-.`  `.+hddh/.`  `.-++smm+/++o`.Nhohssyd  mMMMMMMM
MMMMMMMd  ++++osys-..--:/++:/yso+/:/o+-``-+o/:/+oss::++/:--..:syso++++  mMMMMMMM
MMMMMMMMh/.`-+hdmoohdmmmmddhmmmy+ooh/ .ys` +hoo+ymmmhddmmmmdhoomdh+-`.+hMMMMMMMM
MMMMMMMMMNmhs.`::`yhymdyoshNdsddyy. .+mNNm+` -yydhsmNhsoymdyhs /:`.sdmNMMMMMMMMM
MMMMMMMMMsohh.ymhy+//+./NMNssh+::.`+dmymmymd/`.::+hosNMm/.+//+yhmy.dh+yMMMMMMMMM
MMMMMMMMMNhysmMMMMMMMMh+MNhNMMMNNMdysyNMMNssydMNNMMMNhNN+dMMMMMMMMmsydNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/

// SPDX-License-Identifier: None
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

abstract contract StakingMapV2Contract {
    struct StakeOutput {
        uint32 createdAt;
        uint32 endAt;
        uint32 age;
        uint32 stakesAmount;
        uint32 startPos;
        uint32 currentPos;
        uint32[] bonusPeriods;
        uint32[] bonusPercents;
        uint8 mapVersion;
    }

    function getStakes(address _userAddress) external virtual view returns (StakeOutput[] memory _stakes, uint256[] memory _indexes);
}

interface iERC1155 {
    function mint(address account, uint256 id, uint256 amount, bytes memory data) external;

    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;
}

contract StakingMapV2MilestoneForERC1155 is Ownable, Pausable {
    using SafeERC20 for IERC20;

    StakingMapV2Contract public STAKING_CONTRACT;
    uint32 public REWARD_MIN_TIME_PERIOD;
    iERC1155 public REWARDS_CONTRACT;
    Reward[] public REWARDS;
    mapping(address => uint256) public USER_USED_REWARD_POINTS;

    // Contains rewardIds from ERC1155 contract
    struct Reward {
        uint32 rewardId;
        uint32 pointsCostWithFraction;
    }

    event RewardReceived(address userAddress, uint256[] _rewardIds, uint256[] _rewardAmounts);
    event RewardReceivedSingle(address userAddress, uint256 _rewardIds, uint256 _rewardAmounts);

    constructor(
        StakingMapV2Contract _staking_contract,
        uint32 _reward_min_time_period,
        iERC1155 _rewards_contract,
        uint32[] memory _availableRewardIds,
        uint32[] memory _availableRewardPointsCostWithFraction
    ) {
        STAKING_CONTRACT = _staking_contract;
        REWARD_MIN_TIME_PERIOD = _reward_min_time_period;
        REWARDS_CONTRACT = _rewards_contract;
        setAvailableRewards(_availableRewardIds, _availableRewardPointsCostWithFraction);
    }

    function setRewardsContract(iERC1155 _newContract) external onlyOwner {
        REWARDS_CONTRACT = _newContract;
    }

    function setStakingContract(StakingMapV2Contract _newContract) external onlyOwner {
        STAKING_CONTRACT = _newContract;
    }

    function setAvailableRewards(uint32[] memory _ids, uint32[] memory _pointsCostWithFraction) public onlyOwner {
        uint256 _inputLen = _ids.length;
        require(_inputLen == _pointsCostWithFraction.length, "DATA_SIZE_MISMATCH");

        delete REWARDS;
        for (uint256 i = 0; i < _inputLen; i++) {
            REWARDS.push(
                Reward({
                    rewardId: _ids[i],
                    pointsCostWithFraction: _pointsCostWithFraction[i]
                })
            );
        }
    }

    function availableRewardTypesLength() external view returns (uint256){
        return REWARDS.length;
    }

    function rewardPointsAmount(address _userAddress) public view returns (uint256 _points) {
        (StakingMapV2Contract.StakeOutput[] memory _stakes,) = STAKING_CONTRACT.getStakes(_userAddress);

        // Sum points from all stakes(pawns)
        for (uint256 _i = 0; _i < _stakes.length; _i++) {
            // User may have multiple stakes
            if (_stakes[_i].startPos < REWARD_MIN_TIME_PERIOD && REWARD_MIN_TIME_PERIOD < _stakes[_i].currentPos) {
                _points += uint256(_stakes[_i].stakesAmount * 100);
                

                for (uint256 _j = 0; _j < _stakes[_i].bonusPeriods.length; _j++) {
                    if (
                        _stakes[_i].bonusPeriods[_j] < REWARD_MIN_TIME_PERIOD
                        && _stakes[_i].startPos - _stakes[_i].age < _stakes[_i].bonusPeriods[_j]
                    ) {
                        _points += uint256(_stakes[_i].stakesAmount * _stakes[_i].bonusPercents[_j]);
                    }
                }
            }
        }
        _points -= USER_USED_REWARD_POINTS[_userAddress];
    }

    // Array of local reward IDs, not ID in RewardContract
    function receiveRewards(uint256 _rewardId, uint256 _rewardAmount) external whenNotPaused {
        uint256 _totalCost = uint256(REWARDS[_rewardId].pointsCostWithFraction) * _rewardAmount;
        require(_totalCost <= rewardPointsAmount(_msgSender()), "CHOSEN_REWARD_COST_EXCEED_AVAILABLE_POINTS");

        // Reduce available points amount for user
        USER_USED_REWARD_POINTS[_msgSender()] += _totalCost;

        // Mint rewards for user
        REWARDS_CONTRACT.mint(_msgSender(), uint256(REWARDS[_rewardId].rewardId), _rewardAmount, bytes(''));

        emit RewardReceivedSingle(_msgSender(), _rewardId, _rewardAmount);
    }

    function receiveMultipleRewards(uint256[] calldata _rewardIds, uint256[] calldata _rewardAmounts) external whenNotPaused {
        uint256 _totalCost = 0;
        uint256 _len = _rewardIds.length;
        require(_len == _rewardAmounts.length, "DATA_SIZE_MISMATCH");

        uint256[] memory _ids = new uint256[](_len);
        for (uint256 i = 0; i < _len; i++) {
            _totalCost += uint256(REWARDS[_rewardIds[i]].pointsCostWithFraction) * _rewardAmounts[i];
            _ids[i] = uint256(REWARDS[_rewardIds[i]].rewardId);
        }
        require(_totalCost <= rewardPointsAmount(_msgSender()), "CHOSEN_REWARD_COST_EXCEED_AVAILABLE_POINTS");

        // Reduce available points amount for user
        USER_USED_REWARD_POINTS[_msgSender()] += _totalCost;

        // Mint rewards for user
        REWARDS_CONTRACT.mintBatch(_msgSender(), _ids, _rewardAmounts, bytes(''));

        emit RewardReceived(_msgSender(), _rewardIds, _rewardAmounts);
    }

    function returnAccidentallySent(IERC20 _tokenToSent) external onlyOwner {
        uint256 _amount = _tokenToSent.balanceOf(address(this));
        _tokenToSent.safeTransfer(_msgSender(), _amount);
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}