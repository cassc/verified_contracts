{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/others/MontageV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Attention all users! \\n\\n// Montage Token takes a strong stance against any form of malicious trading behaviour. We prioritize the safety & security of our community and our enabling ecosystem. \\n// Any user (BOT or human) engaging in activities that threaten the integrity of our services, such as interfering with transactions, will be swiftly identified and blacklisted. \\n// This means permanently restricted from accessing our services. We urge all users to adhere to ethical practices when trading our token and respect these  terms of service. \\n// Let us work together to maintain a trusted and secure environment for all Montage investors worldwide.\\n \\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n}\\n\\ninterface IRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nlibrary Address {\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\tuint256 size;\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(account)\\n\\t\\t}\\n\\t\\treturn size > 0;\\n\\t}\\n\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\n\\t\\trequire(\\n\\t\\t\\taddress(this).balance >= amount,\\n\\t\\t\\t\\\"Address: insufficient balance\\\"\\n\\t\\t);\\n\\n\\t\\t(bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n\\t\\trequire(\\n\\t\\t\\tsuccess,\\n\\t\\t\\t\\\"Address: unable to send value, recipient may have reverted\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data)\\n\\tinternal\\n\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n\\t}\\n\\n\\tfunction functionCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn\\n\\t\\tfunctionCallWithValue(\\n\\t\\t\\ttarget,\\n\\t\\t\\tdata,\\n\\t\\t\\tvalue,\\n\\t\\t\\t\\\"Address: low-level call with value failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\trequire(\\n\\t\\t\\taddress(this).balance >= value,\\n\\t\\t\\t\\\"Address: insufficient balance for call\\\"\\n\\t\\t);\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n\\t\\t(bool success, bytes memory returndata) = target.call{value: value}(\\n\\t\\tdata\\n\\t\\t);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction functionStaticCall(address target, bytes memory data)\\n\\tinternal\\n\\tview\\n\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn\\n\\t\\tfunctionStaticCall(\\n\\t\\t\\ttarget,\\n\\t\\t\\tdata,\\n\\t\\t\\t\\\"Address: low-level static call failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction functionStaticCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal view returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n\\t\\t(bool success, bytes memory returndata) = target.staticcall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction functionDelegateCall(address target, bytes memory data)\\n\\tinternal\\n\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn\\n\\t\\tfunctionDelegateCall(\\n\\t\\t\\ttarget,\\n\\t\\t\\tdata,\\n\\t\\t\\t\\\"Address: low-level delegate call failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction functionDelegateCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n\\t\\t(bool success, bytes memory returndata) = target.delegatecall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction _verifyCallResult(\\n\\t\\tbool success,\\n\\t\\tbytes memory returndata,\\n\\t\\tstring memory errorMessage\\n\\t) private pure returns (bytes memory) {\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\tif (returndata.length > 0) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n   function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\\ncontract MontageToken is Ownable, ERC20 {\\n    using Address for address;\\n\\n    IRouter public uniswapV2Router;\\n    address public uniswapV2Pair;\\n\\n    string private constant _name = \\\"Montage Token\\\";\\n    string private constant _symbol = \\\"MTGX\\\";\\n\\n    bool public isTradingEnabled;\\n\\n    uint256 public initialSupply = 10000000000 * (10**18);\\n    uint256 public maxWalletAmount = initialSupply * 200 / 10000;\\n\\n    bool private _swapping;\\n    uint256 public minimumTokensBeforeSwap = initialSupply - (initialSupply - 1);\\n\\tuint256 public acceptableSlippagePercent= 0;\\n\\n    address public targetAWallet;\\n    address public targetBWallet;\\n\\taddress public targetCWallet;\\n\\n    struct CustomTaxPeriod {\\n        uint32 targetAFeeOnBuy; //liquidity\\n        uint32 targetAFeeOnSell;\\n        uint32 targetBFeeOnBuy; //marketing\\n        uint32 targetBFeeOnSell;\\n\\t\\tuint32 targetCFeeOnBuy; //charity\\n\\t\\tuint32 targetCFeeOnSell;\\n        uint32 burnFeeOnBuy;\\n        uint32 burnFeeOnSell;\\n    }\\n\\n    // Base taxes\\n    CustomTaxPeriod private _base = CustomTaxPeriod(0, 618, 1000, 1000, 0, 1000, 0, 382);\\n\\n    bool private _pairCreated;\\n    bool private _launchTokensClaimed;\\n    uint256 private _launchBlockNumber;\\n\\n    mapping (address => bool) private _isBlocked;\\n    mapping(address => bool) private _isAllowedToTradeWhenDisabled;\\n    mapping(address => bool) private _isExcludedFromFee;\\n    mapping(address => bool) private _isExcludedFromMaxWalletLimit;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    uint32 private _targetAFee;\\n    uint32 private _targetBFee;\\n\\tuint32 private _targetCFee;\\n    uint32 private _burnFee;\\n    uint32 private _totalFee;\\n\\n    event AutomatedMarketMakerPairChange(address indexed pair, bool indexed value);\\n    event BlockedAccountChange(address indexed holder, bool indexed status);\\n    event UniswapV2RouterChange(address indexed newAddress, address indexed oldAddress);\\n    event WalletChange(string indexed indentifier,address indexed newWallet,address indexed oldWallet);\\n    event FeeChange(string indexed identifier,uint32 targetAFee, uint32 targetBFee, uint32 targetCFee, uint32 burnFee);\\n    event CustomTaxPeriodChange(uint256 indexed newValue,uint256 indexed oldValue,string indexed taxType);\\n    event MaxWalletAmountChange(uint256 indexed newValue, uint256 indexed oldValue);\\n    event ExcludeFromFeesChange(address indexed account, bool isExcluded);\\n    event ExcludeFromMaxWalletChange(address indexed account, bool isExcluded);\\n    event AllowedWhenTradingDisabledChange(address indexed account, bool isExcluded);\\n    event MinTokenAmountBeforeSwapChange(uint256 indexed newValue, uint256 indexed oldValue);\\n    event ClaimOverflow(address token, uint256 amount);\\n    event TradingStatusChange(bool indexed newValue, bool indexed oldValue);\\n    event Liquify(uint256 ethReceived, uint256 tokensIntoLiqudity);\\n    event FeesApplied(uint32 targetAFee, uint32 targetBFee, uint32 targetCFee, uint32 burnFee, uint32 totalFee);\\n    event TokenBurn(uint32 burnFee, uint256 amountToBurn);\\n\\n    constructor() ERC20(_name, _symbol) {\\n        targetAWallet = owner();\\n        targetBWallet = owner();\\n\\t\\ttargetCWallet = owner();\\n\\n        IRouter _uniswapV2Router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\t\\taddress _uniswapV2Pair = IFactory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n\\t\\tuniswapV2Router = _uniswapV2Router;\\n\\t\\tuniswapV2Pair = _uniswapV2Pair;\\n\\t\\t_setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\n\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n        _isAllowedToTradeWhenDisabled[owner()] = true;\\n        _isAllowedToTradeWhenDisabled[address(this)] = true;\\n\\n        _isExcludedFromMaxWalletLimit[_uniswapV2Pair] = true;\\n        _isExcludedFromMaxWalletLimit[address(uniswapV2Router)] = true;\\n        _isExcludedFromMaxWalletLimit[address(this)] = true;\\n        _isExcludedFromMaxWalletLimit[owner()] = true;\\n\\n        _mint(owner(), initialSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    function activateTrading() external onlyOwner {\\n        isTradingEnabled = true;\\n        if(_launchBlockNumber == 0) {\\n            _launchBlockNumber = block.number;\\n        }\\n        emit TradingStatusChange(true, false);\\n    }\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n\\t\\trequire(automatedMarketMakerPairs[pair] != value, \\\"Montage: Automated market maker pair is already set to that value\\\");\\n\\t\\tautomatedMarketMakerPairs[pair] = value;\\n\\t\\temit AutomatedMarketMakerPairChange(pair, value);\\n\\t}\\n    function allowTradingWhenDisabled(address account, bool allowed) external onlyOwner {\\n        _isAllowedToTradeWhenDisabled[account] = allowed;\\n        emit AllowedWhenTradingDisabledChange(account, allowed);\\n    }\\n    function blockAccount(address account) external onlyOwner {\\n        require(!_isBlocked[account], \\\"Montage: Account is already blocked\\\");\\n        _isBlocked[account] = true;\\n        emit BlockedAccountChange(account, true);\\n    }\\n    function unblockAccount(address account) external onlyOwner {\\n        require(_isBlocked[account], \\\"Montage: Account is not blcoked\\\");\\n        _isBlocked[account] = false;\\n        emit BlockedAccountChange(account, false);\\n    }\\n    function excludeFromFees(address account, bool excluded) external onlyOwner {\\n        require(_isExcludedFromFee[account] != excluded,\\\"Montage: Account is already the value of 'excluded'\\\");\\n        _isExcludedFromFee[account] = excluded;\\n        emit ExcludeFromFeesChange(account, excluded);\\n    }\\n    function excludeFromMaxWalletLimit(address account, bool excluded) external onlyOwner {\\n        require(_isExcludedFromMaxWalletLimit[account] != excluded,\\\"Montage: Account is already the value of 'excluded'\\\");\\n        _isExcludedFromMaxWalletLimit[account] = excluded;\\n        emit ExcludeFromMaxWalletChange(account, excluded);\\n    }\\n    function setWallets(address newTargetAWallet, address newTargetBWallet, address newTargetCWallet) external onlyOwner {\\n        if (targetAWallet != newTargetAWallet) {\\n            require(newTargetAWallet != address(0), \\\"Montage: The targetAWallet cannot be 0\\\");\\n            emit WalletChange(\\\"targetAWallet\\\", newTargetAWallet, targetAWallet);\\n            targetAWallet = newTargetAWallet;\\n        }\\n        if (targetBWallet != newTargetBWallet) {\\n            require(newTargetBWallet != address(0), \\\"Montage: The targetBWallet cannot be 0\\\");\\n            emit WalletChange(\\\"targetBWallet\\\", newTargetBWallet, targetBWallet);\\n            targetBWallet = newTargetBWallet;\\n        }\\n\\t\\tif (targetCWallet != newTargetCWallet) {\\n\\t\\t\\trequire(newTargetCWallet != address(0), \\\"Montage: The targetCWallet cannot be 0\\\");\\n\\t\\t\\temit WalletChange(\\\"targetCWallet\\\", newTargetCWallet, targetCWallet);\\n\\t\\t\\ttargetCWallet = newTargetCWallet;\\n\\t\\t}\\n    }\\n    function setFeesOnBuy(uint32 _targetAFeeOnBuy, uint32 _targetBFeeOnBuy, uint32 _targetCFeeOnBuy, uint32 _burnFeeOnBuy) external onlyOwner {\\n        require(_targetAFeeOnBuy + _targetBFeeOnBuy + _targetCFeeOnBuy + _burnFeeOnBuy <= 5000, \\\"Montage: Fees must be less or equal to 5.00%\\\");\\n        _setCustomBuyTaxPeriod(_base,_targetAFeeOnBuy,_targetBFeeOnBuy, _targetCFeeOnBuy, _burnFeeOnBuy);\\n        emit FeeChange(\\\"baseFees-Buy\\\",_targetAFeeOnBuy,_targetBFeeOnBuy, _targetCFeeOnBuy, _burnFeeOnBuy);\\n    }\\n    function setFeesOnSell(uint32 _targetAFeeOnSell, uint32 _targetBFeeOnSell, uint32 _targetCFeeOnSell, uint32 _burnFeeOnSell) external onlyOwner {\\n        require(_targetAFeeOnSell + _targetBFeeOnSell + _targetCFeeOnSell + _burnFeeOnSell <= 5000, \\\"Montage: Fees must be less or equal to 5.00%\\\");\\n        _setCustomSellTaxPeriod(_base,_targetAFeeOnSell, _targetBFeeOnSell, _targetCFeeOnSell, _burnFeeOnSell);\\n        emit FeeChange(\\\"baseFees-Sell\\\",_targetAFeeOnSell, _targetBFeeOnSell, _targetCFeeOnSell, _burnFeeOnSell);\\n    }\\n    function setUniswapRouter(address newAddress) external onlyOwner {\\n        require(newAddress != address(uniswapV2Router),\\\"Montage: The router already has that address\\\");\\n        emit UniswapV2RouterChange(newAddress, address(uniswapV2Router));\\n        uniswapV2Router = IRouter(newAddress);\\n    }\\n    function setMaxWalletAmount(uint256 newValue) external onlyOwner {\\n        require(newValue >= totalSupply() * 10 / 1000, \\\"Montage: Max wallet value must be greater than or equal to 1% of supply\\\");\\n        require(newValue != maxWalletAmount,\\\"Montage: Cannot update maxWalletAmount to same value\\\");\\n        emit MaxWalletAmountChange(newValue, maxWalletAmount);\\n        maxWalletAmount = newValue;\\n    }\\n    function setMinimumTokensBeforeSwap(uint256 newValue) external onlyOwner {\\n        require(newValue != minimumTokensBeforeSwap,\\\"Montage: Cannot update minimumTokensBeforeSwap to same value\\\");\\n        emit MinTokenAmountBeforeSwapChange(newValue, minimumTokensBeforeSwap);\\n        minimumTokensBeforeSwap = newValue;\\n    }\\n    function claimLaunchTokens() external onlyOwner {\\n\\t\\trequire(block.number - _launchBlockNumber > 5, \\\"Montage: Only claim launch tokens after first 5 blocks\\\");\\n        require(!_launchTokensClaimed, \\\"Montage: Launch tokens have been claimed\\\");\\n        _launchTokensClaimed = true;\\n\\t\\tuint256 tokenBalance = balanceOf(address(this));\\n        (bool success) = IERC20(address(this)).transfer(owner(), tokenBalance);\\n        if (success){\\n            emit ClaimOverflow(address(this), tokenBalance);\\n        }\\n    }\\n    function claimETHOverflow(uint256 amount) external onlyOwner {\\n        require(amount <= address(this).balance, \\\"Montage: Cannot send more than contract balance\\\");\\n        (bool success, ) = address(owner()).call{ value: amount }(\\\"\\\");\\n        if (success) {\\n            emit ClaimOverflow(uniswapV2Router.WETH(), amount);\\n        }\\n    }\\n\\tfunction setAcceptableSlippage(uint256 value) external onlyOwner {\\n\\t\\trequire (value <= 1000, \\\"Montage: Acceptable slippage cannot be more than 100%!\\\") ;\\n\\t\\tacceptableSlippagePercent = value;\\n\\t}\\n\\n    // Getters\\n    function getBuyFees() external view returns (uint32, uint32, uint32, uint32) {\\n        return (_base.targetAFeeOnBuy, _base.targetBFeeOnBuy, _base.targetCFeeOnBuy, _base.burnFeeOnBuy);\\n    }\\n    function getSellFees() external view returns (uint32, uint32, uint32, uint32) {\\n        return (_base.targetAFeeOnSell, _base.targetBFeeOnSell, _base.targetCFeeOnSell, _base.burnFeeOnSell);\\n    }\\n    // Main\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\t\\trequire(!_isBlocked[to], \\\"Montage: Account is blocked\\\");\\n\\t\\trequire(!_isBlocked[from], \\\"Montage: Account is blocked\\\");\\n\\n\\t\\tif (amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        if (!_isAllowedToTradeWhenDisabled[from] && !_isAllowedToTradeWhenDisabled[to]) {\\n            require(isTradingEnabled, \\\"Montage: Trading is currently disabled.\\\");\\n        }\\n\\n        _adjustTaxes(automatedMarketMakerPairs[from], automatedMarketMakerPairs[to]);\\n        bool canSwap = balanceOf(address(this)) >= minimumTokensBeforeSwap;\\n\\n        if (\\n            isTradingEnabled &&\\n            canSwap &&\\n            !_swapping &&\\n            _totalFee > 0 &&\\n            automatedMarketMakerPairs[to]\\n        ) {\\n            _swapping = true;\\n            _swapAndTransfer();\\n            _swapping = false;\\n        }\\n\\n        bool takeFee = !_swapping && isTradingEnabled;\\n\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\\n            takeFee = false;\\n        }\\n        if (takeFee && _totalFee > 0) {\\n            uint256 fee = (amount * _totalFee) / 100000;\\n            amount = amount - fee;\\n            super._transfer(from, address(this), fee);\\n        }\\n\\n\\t\\tif (!_isExcludedFromMaxWalletLimit[to]) {\\n\\t\\t\\trequire((balanceOf(to) + amount) <= maxWalletAmount, \\\"Montage: Expected wallet amount exceeds the maxWalletAmount.\\\");\\n\\t\\t}\\n\\n        super._transfer(from, to, amount);\\n    }\\n    function _adjustTaxes(bool isBuy,bool isSell) private {\\n        _targetAFee = 0;\\n        _targetBFee = 0;\\n\\t\\t_targetCFee = 0;\\n        _burnFee = 0;\\n\\n        if (isBuy) {\\n            if (block.number - _launchBlockNumber <= 5) {\\n                _targetAFee = 100000;\\n            } else {\\n                _targetAFee = _base.targetAFeeOnBuy;\\n                _targetBFee = _base.targetBFeeOnBuy;\\n\\t\\t\\t\\t_targetCFee = _base.targetCFeeOnBuy;\\n                _burnFee = _base.burnFeeOnBuy;\\n            }\\n        }\\n        if (isSell) {\\n            _targetAFee = _base.targetAFeeOnSell;\\n            _targetBFee = _base.targetBFeeOnSell;\\n\\t\\t\\t_targetCFee = _base.targetCFeeOnSell;\\n            _burnFee = _base.burnFeeOnSell;\\n        }\\n        _totalFee = _targetAFee + _targetBFee + _targetCFee + _burnFee;\\n        emit FeesApplied(_targetAFee, _targetBFee, _targetCFee, _burnFee, _totalFee);\\n    }\\n    function _setCustomSellTaxPeriod(CustomTaxPeriod storage map, uint32 _targetAFeeOnSell, uint32 _targetBFeeOnSell, uint32 _targetCFeeOnSell, uint32 _burnFeeOnSell ) private {\\n        if (map.targetAFeeOnSell != _targetAFeeOnSell) {\\n            emit CustomTaxPeriodChange(_targetAFeeOnSell,map.targetAFeeOnSell,\\\"targetAFeeOnSell\\\");\\n            map.targetAFeeOnSell = _targetAFeeOnSell;\\n        }\\n        if (map.targetBFeeOnSell != _targetBFeeOnSell) {\\n            emit CustomTaxPeriodChange(_targetBFeeOnSell,map.targetBFeeOnSell,\\\"targetBFeeOnSell\\\");\\n            map.targetBFeeOnSell = _targetBFeeOnSell;\\n        }\\n\\t\\tif (map.targetCFeeOnSell != _targetCFeeOnSell) {\\n\\t\\t\\temit CustomTaxPeriodChange(_targetCFeeOnSell,map.targetCFeeOnSell,\\\"targetCFeeOnSell\\\");\\n\\t\\t\\tmap.targetCFeeOnSell = _targetCFeeOnSell;\\n\\t\\t}\\n        if (map.burnFeeOnSell != _burnFeeOnSell) {\\n            emit CustomTaxPeriodChange(_burnFeeOnSell,map.burnFeeOnSell,\\\"burnFeeOnSell\\\");\\n            map.burnFeeOnSell = _burnFeeOnSell;\\n        }\\n    }\\n    function _setCustomBuyTaxPeriod(CustomTaxPeriod storage map, uint32 _targetAFeeOnBuy, uint32 _targetBFeeOnBuy, uint32 _targetCFeeOnBuy, uint32 _burnFeeOnBuy) private {\\n        if (map.targetAFeeOnBuy != _targetAFeeOnBuy) {\\n            emit CustomTaxPeriodChange(_targetAFeeOnBuy,map.targetAFeeOnBuy,\\\"targetAFeeOnBuy\\\");\\n            map.targetAFeeOnBuy = _targetAFeeOnBuy;\\n        }\\n        if (map.targetBFeeOnBuy != _targetBFeeOnBuy) {\\n            emit CustomTaxPeriodChange(_targetBFeeOnBuy,map.targetBFeeOnBuy,\\\"targetBFeeOnBuy\\\");\\n            map.targetBFeeOnBuy = _targetBFeeOnBuy;\\n        }\\n\\t\\tif (map.targetCFeeOnBuy != _targetCFeeOnBuy) {\\n\\t\\t\\temit CustomTaxPeriodChange(_targetCFeeOnBuy,map.targetCFeeOnBuy,\\\"targetCFeeOnBuy\\\");\\n\\t\\t\\tmap.targetCFeeOnBuy = _targetCFeeOnBuy;\\n\\t\\t}\\n        if (map.burnFeeOnBuy != _burnFeeOnBuy) {\\n            emit CustomTaxPeriodChange(_burnFeeOnBuy,map.burnFeeOnBuy,\\\"burnFeeOnBuy\\\");\\n            map.burnFeeOnBuy = _burnFeeOnBuy;\\n        }\\n    }\\n    function _swapAndTransfer() private {\\n        uint256 contractBalance = balanceOf(address(this));\\n        uint256 initialETHBalance = address(this).balance;\\n        uint32 _totalFeePrior = _totalFee;\\n\\n        uint256 amountToLiquify = contractBalance * _targetAFee / _totalFeePrior / 2;\\n        uint256 amountToBurn = contractBalance * _burnFee / _totalFeePrior;\\n        uint256 amountToSwap = contractBalance - amountToLiquify - amountToBurn;\\n\\n        if (amountToBurn > 0) {\\n            super._burn(address(this), amountToBurn);\\n            emit TokenBurn(_burnFee, amountToBurn);\\n        }\\n\\n        _swapTokensForETH(amountToSwap);\\n\\n        uint256 ETHBalanceAfterSwap = address(this).balance - initialETHBalance;\\n        uint256 totalETHFee = _totalFeePrior - (_targetAFee / 2) - _burnFee;\\n        uint256 amountETHTargetA = ETHBalanceAfterSwap * _targetAFee / totalETHFee / 2;\\n\\t\\tuint256 amountETHTargetB = ETHBalanceAfterSwap * _targetBFee / totalETHFee;\\n        uint256 amountETHTargetC = ETHBalanceAfterSwap - amountETHTargetA - amountETHTargetB;\\n\\n        Address.sendValue(payable(targetBWallet),amountETHTargetB);\\n\\t\\tAddress.sendValue(payable(targetCWallet),amountETHTargetC);\\n\\n        if (amountToLiquify > 0) {\\n            _addLiquidity(amountToLiquify, amountETHTargetA);\\n            emit Liquify(amountETHTargetA, amountToLiquify);\\n        }\\n        _totalFee = _totalFeePrior;\\n    }\\n    function _swapTokensForETH(uint256 tokenAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n\\t\\tuint256 minAmountOut;\\n\\t\\tif (acceptableSlippagePercent == 0) {\\n\\t\\t\\t// Disable slippage protection if zero is set to acceptableSlippagePercent (it would always revert otherwise)\\n\\t\\t\\tminAmountOut = 0;\\n\\t\\t} else {\\n\\t\\t\\t// Determine the minimum out token percentage ie. if tokenAmount was 100 and 20% was the acceptable slippage,\\n\\t\\t\\t// the result will be 20 tokens.\\n\\t\\t\\tuint256 minAmountOutPercentage = (tokenAmount * acceptableSlippagePercent) / 1000;\\n\\t\\t\\t//1 Determine the min amount out by subtracting total token amount the min out percentage so\\n\\t\\t\\t// the final result would be at least 80 tokens out.\\n\\t\\t\\tminAmountOut = tokenAmount - minAmountOutPercentage;\\n\\t\\t}\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n\\t\\t\\tminAmountOut,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        uniswapV2Router.addLiquidityETH{ value: ethAmount }(\\n            address(this),\\n            tokenAmount,\\n            1, // slippage is unavoidable\\n            1, // slippage is unavoidable\\n            targetAWallet,\\n            block.timestamp\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"AllowedWhenTradingDisabledChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"AutomatedMarketMakerPairChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"BlockedAccountChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimOverflow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taxType\",\"type\":\"string\"}],\"name\":\"CustomTaxPeriodChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFeesChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromMaxWalletChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"targetAFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"targetBFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"targetCFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"burnFee\",\"type\":\"uint32\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"targetAFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"targetBFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"targetCFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"burnFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalFee\",\"type\":\"uint32\"}],\"name\":\"FeesApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"Liquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MaxWalletAmountChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MinTokenAmountBeforeSwapChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"burnFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"TokenBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"oldValue\",\"type\":\"bool\"}],\"name\":\"TradingStatusChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UniswapV2RouterChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indentifier\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"WalletChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptableSlippagePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"allowTradingWhenDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blockAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimETHOverflow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLaunchTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyFees\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellFees\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setAcceptableSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_targetAFeeOnBuy\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_targetBFeeOnBuy\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_targetCFeeOnBuy\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_burnFeeOnBuy\",\"type\":\"uint32\"}],\"name\":\"setFeesOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_targetAFeeOnSell\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_targetBFeeOnSell\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_targetCFeeOnSell\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_burnFeeOnSell\",\"type\":\"uint32\"}],\"name\":\"setFeesOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinimumTokensBeforeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setUniswapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTargetAWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newTargetBWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newTargetCWallet\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetAWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetBWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetCWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unblockAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MontageToken", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}