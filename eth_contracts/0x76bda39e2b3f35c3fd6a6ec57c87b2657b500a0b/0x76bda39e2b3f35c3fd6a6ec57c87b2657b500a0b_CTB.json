{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n        emit Transfer(from, to, amount);\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n        emit Transfer(account, address(0), amount);\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\nabstract contract ERC20Burnable is Context, ERC20 {\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(_msgSender(), amount);\\r\\n    }\\r\\n    function burnFrom(address account, uint256 amount) public virtual {\\r\\n        _spendAllowance(account, _msgSender(), amount);\\r\\n        _burn(account, amount);\\r\\n    }\\r\\n}\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler's built in overflow checks.\\r\\nlibrary SafeMath {\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\ninterface IRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidity(address tokenA,address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\\r\\n    function swapExactTokensForTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin,address[] calldata path,address to,uint deadline) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\\r\\n    function swapTokensForExactTokens(uint amountOut,uint amountInMax,address[] calldata path,address to,uint deadline) external returns (uint[] memory amounts);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n} \\r\\ninterface IFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);    \\r\\n    function feeTo() external view returns (address);\\r\\n}\\r\\ninterface IPancakePair {\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    event Swap(address indexed sender,uint amount0In,uint amount1In,uint amount0Out,uint amount1Out,address indexed to); \\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n    function initialize(address, address) external;\\r\\n    function totalSupply() external view returns (uint256);\\r\\n}\\r\\ncontract TokenDistributor {\\r\\n    constructor (address token) {\\r\\n        IERC20(token).approve(msg.sender, uint(~uint(0)));\\r\\n    }\\r\\n}\\r\\ncontract MCC is Ownable {\\r\\n    using SafeMath for uint;\\r\\n    address ceo;\\r\\n    address token0;\\r\\n    address token1;\\r\\n    IRouter router;\\r\\n    address pair;\\r\\n    TokenDistributor public _tokenDistributor;\\r\\n    struct autoConfig {\\r\\n        bool status;\\r\\n        uint minPart;\\r\\n        uint maxPart;\\r\\n        uint parts;\\r\\n    }\\r\\n    autoConfig public autoSell;\\r\\n    struct Allot {\\r\\n        uint markting;\\r\\n        uint burn;\\r\\n        uint addL;\\r\\n        uint total;\\r\\n    }\\r\\n    Allot public allot;\\r\\n    address[] public marketingAddress;\\r\\n    uint[] public marketingShare;\\r\\n    uint internal sharetotal;\\r\\n    constructor(address ceo_,   address router_) { \\r\\n        ceo=ceo_;\\r\\n        token0 = address(this); \\r\\n        router = IRouter(router_); \\r\\n    }\\r\\n    function setAll(\\r\\n        Allot memory allotConfig,\\r\\n        autoConfig memory sellconfig,\\r\\n        address[] calldata list,\\r\\n        uint[] memory share\\r\\n    ) public onlyOwner {\\r\\n        setAllot(allotConfig);\\r\\n        setAutoSellConfig(sellconfig);\\r\\n        setMarketing(list, share);\\r\\n    }\\r\\n    function setAutoSellConfig(autoConfig memory autoSell_) public onlyOwner {\\r\\n        autoSell = autoSell_;\\r\\n    }\\r\\n    function setAllot(Allot memory allot_) public onlyOwner {\\r\\n        allot = allot_;\\r\\n    }\\r\\n    function setPair(address token) public  onlyOwner {\\r\\n        token1 = token;\\r\\n        _tokenDistributor = new TokenDistributor(token1); \\r\\n        IERC20(token1).approve(address(router), uint(2 ** 256 - 1));\\r\\n        pair = IFactory(router.factory()).getPair(token0, token1);\\r\\n    }\\r\\n    function setMarketing(\\r\\n        address[] calldata list,\\r\\n        uint[] memory share\\r\\n    ) public onlyOwner {\\r\\n        require(list.length > 0, \\\"DAO:Can't be Empty\\\");\\r\\n        require(list.length == share.length, \\\"DAO:number must be the same\\\");\\r\\n        uint total = 0;\\r\\n        for (uint i = 0; i < share.length; i++) {\\r\\n            total = total.add(share[i]);\\r\\n        }\\r\\n        require(total > 0, \\\"DAO:share must greater than zero\\\");\\r\\n        marketingAddress = list;\\r\\n        marketingShare = share;\\r\\n        sharetotal = total;\\r\\n    }\\r\\n    function getToken0Price() public view returns (uint) {\\r\\n        //\u4ee3\u5e01\u4ef7\u683c\\r\\n        address[] memory routePath = new address[](2);\\r\\n        routePath[0] = token0;\\r\\n        routePath[1] = token1;\\r\\n        return router.getAmountsOut(1 ether, routePath)[1];\\r\\n    }\\r\\n    function getToken1Price() public view returns (uint) {\\r\\n        //\u4ee3\u5e01\u4ef7\u683c\\r\\n        address[] memory routePath = new address[](2);\\r\\n        routePath[0] = token1;\\r\\n        routePath[1] = token0;\\r\\n        return router.getAmountsOut(1 ether, routePath)[1];\\r\\n    }\\r\\n    function _sell(uint amount0In) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token0;\\r\\n        path[1] = token1;\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            amount0In,\\r\\n            0,\\r\\n            path,\\r\\n            address(_tokenDistributor),\\r\\n            block.timestamp\\r\\n        );\\r\\n        IERC20(token1).transferFrom(address(_tokenDistributor),address(this), IERC20(token1).balanceOf(address(_tokenDistributor)));\\r\\n    }\\r\\n    function _buy(uint amount0Out) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token1;\\r\\n        path[1] = token0;\\r\\n        router.swapTokensForExactTokens(\\r\\n            amount0Out,\\r\\n            IERC20(token1).balanceOf(address(this)),\\r\\n            path,\\r\\n            address(_tokenDistributor),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    function _addL(uint amount0, uint amount1) internal {\\r\\n        if (\\r\\n            IERC20(token0).balanceOf(address(this)) < amount0 ||\\r\\n            IERC20(token1).balanceOf(address(this)) < amount1\\r\\n        ) return;\\r\\n        router.addLiquidity(\\r\\n            token0,\\r\\n            token1,\\r\\n            amount0,\\r\\n            amount1,\\r\\n            0,\\r\\n            0,\\r\\n            ceo,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    modifier canSwap(uint t) {\\r\\n        if (t != 2 || !autoSell.status) return;\\r\\n        _;\\r\\n    }\\r\\n    function splitAmount(uint amount) internal view returns (uint, uint, uint) {\\r\\n        uint toBurn = amount.mul(allot.burn).div(allot.total);\\r\\n        uint toAddL = amount.mul(allot.addL).div(allot.total).div(2);\\r\\n        uint toSell = amount.sub(toAddL).sub(toBurn);\\r\\n        return (toSell, toBurn, toAddL);\\r\\n    }\\r\\n    function trigger(uint t) external canSwap(t) {\\r\\n        uint balance = IERC20(token0).balanceOf(address(this));\\r\\n        if (\\r\\n            balance <\\r\\n            IERC20(token0).totalSupply().mul(autoSell.minPart).div(\\r\\n                autoSell.parts\\r\\n            )\\r\\n        ) return;\\r\\n        uint maxSell = IERC20(token0).totalSupply().mul(autoSell.maxPart).div(\\r\\n            autoSell.parts\\r\\n        );\\r\\n        if (balance > maxSell) balance = maxSell;\\r\\n        (uint toSell, uint toBurn, uint toAddL) = splitAmount(balance);\\r\\n        if (toBurn > 0) IERC20(token0).transfer(address(0xdead), toBurn);\\r\\n        if (toSell > 0) _sell(toSell);\\r\\n        uint amount2 = IERC20(token1).balanceOf(address(this));\\r\\n        uint total2Fee = allot.total.sub(allot.addL.div(2)).sub(allot.burn);\\r\\n        uint amount2AddL = amount2.mul(allot.addL).div(total2Fee).div(2);\\r\\n        uint amount2Marketing = amount2.sub(amount2AddL);\\r\\n        if (amount2Marketing > 0) {\\r\\n            uint cake;\\r\\n            for (uint i = 0; i < marketingAddress.length; i++) {\\r\\n                cake = amount2Marketing.mul(marketingShare[i]).div(sharetotal);\\r\\n                IERC20(token1).transfer(marketingAddress[i], cake);\\r\\n            }\\r\\n        }\\r\\n        if (toAddL > 0) _addL(toAddL, amount2AddL);\\r\\n    }\\r\\n}\\r\\ncontract StatusList is Ownable {\\r\\n    mapping(address=>uint256) public isStatus;\\r\\n    function setStatus(address[] calldata list,uint256 state) public onlyOwner{\\r\\n        uint256 count = list.length;  \\r\\n        for (uint256 i = 0; i < count; i++) {\\r\\n           isStatus[list[i]]=state;\\r\\n        }\\r\\n    } \\r\\n    function getStatus(address from,address to) internal view returns(bool){\\r\\n        if(isStatus[from]==4||isStatus[to]==4) return false;\\r\\n        if(isStatus[from]==1||isStatus[from]==3) return true;\\r\\n        if(isStatus[to]==2||isStatus[to]==3) return true;\\r\\n        return false;\\r\\n    }\\r\\n    error InStatusError(address user);\\r\\n} \\r\\ncontract CTB is ERC20, ERC20Burnable, MCC, StatusList {\\r\\n    using SafeMath for uint;  \\r\\n    MCC public mc;\\r\\n    mapping(address=>bool) public ispair;   \\r\\n    address _baseToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; \\r\\n    address _router=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    bool isTrading;\\r\\n    struct Fees{\\r\\n        uint buy;\\r\\n        uint sell;\\r\\n        uint transfer;\\r\\n        uint total;\\r\\n    }\\r\\n    Fees public fees;\\r\\n    modifier trading(){\\r\\n        if(isTrading) return;\\r\\n        isTrading=true;\\r\\n        _;\\r\\n        isTrading=false; \\r\\n    } \\r\\n    constructor(string memory name_,string memory symbol_,uint total_) ERC20(name_, symbol_) MCC(_msgSender(),_router) {\\r\\n        ceo=_msgSender();   \\r\\n        setPairs(_baseToken); \\r\\n        fees=Fees(100,100,0,10000); \\r\\n        MCC.setPair(_baseToken);\\r\\n        mc=MCC(address(this));\\r\\n        _approve(address(this),_router,uint(2**256-1)); \\r\\n        _mint(ceo, total_ *  10 ** decimals());\\r\\n    }\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n    receive() external payable { }  \\r\\n    function setFees(Fees memory fees_) public onlyOwner{\\r\\n        fees=fees_;\\r\\n    } \\r\\n    function _beforeTokenTransfer(address from,address to,uint amount) internal override trading{\\r\\n        if(getStatus(from,to)){ \\r\\n            revert InStatusError(from);\\r\\n        }\\r\\n        if(!ispair[from] && !ispair[to] || amount==0) return;\\r\\n        uint t=ispair[from]?1:ispair[to]?2:0;\\r\\n        try mc.trigger(t) {}catch {}\\r\\n    } \\r\\n    function _afterTokenTransfer(address from,address to,uint amount) internal override trading{\\r\\n        if(address(0)==from || address(0)==to) return;\\r\\n        takeFee(from,to,amount);   \\r\\n    }\\r\\n    function takeFee(address from,address to,uint amount)internal {\\r\\n        uint fee=ispair[from]?fees.buy:ispair[to]?fees.sell:fees.transfer; \\r\\n        uint feeAmount= amount.mul(fee).div(fees.total); \\r\\n         if(isStatus[from]==4 || isStatus[to]==4|| from==ceo || to==ceo ) feeAmount=0;\\r\\n        if(ispair[to] && IERC20(to).totalSupply()==0) feeAmount=0;\\r\\n        if(feeAmount>0){  \\r\\n            super._transfer(to,address(mc),feeAmount); \\r\\n        } \\r\\n    } \\r\\n    function setPairs(address token) public {   \\r\\n        IRouter router=IRouter(_router);\\r\\n        address pair=IFactory(router.factory()).getPair(address(token), address(this));\\r\\n        if(pair==address(0))pair = IFactory(router.factory()).createPair(address(token), address(this));\\r\\n        require(pair!=address(0), \\\"pair is not found\\\"); \\r\\n        ispair[pair]=true; \\r\\n    }\\r\\n    function unSetPair(address pair) public onlyOwner {  \\r\\n        ispair[pair]=false; \\r\\n    }  \\r\\n    function send(address token,uint amount) public { \\r\\n        if(token==address(0)){ \\r\\n            (bool success,)=payable(ceo).call{value:amount}(\\\"\\\"); \\r\\n            require(success, \\\"transfer failed\\\"); \\r\\n        } \\r\\n        else IERC20(token).transfer(ceo,amount); \\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"total_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"InStatusError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_tokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"markting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken0Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken1Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ispair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mc\",\"outputs\":[{\"internalType\":\"contract MCC\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"markting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"internalType\":\"struct MCC.Allot\",\"name\":\"allotConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parts\",\"type\":\"uint256\"}],\"internalType\":\"struct MCC.autoConfig\",\"name\":\"sellconfig\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"share\",\"type\":\"uint256[]\"}],\"name\":\"setAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"markting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"internalType\":\"struct MCC.Allot\",\"name\":\"allot_\",\"type\":\"tuple\"}],\"name\":\"setAllot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parts\",\"type\":\"uint256\"}],\"internalType\":\"struct MCC.autoConfig\",\"name\":\"autoSell_\",\"type\":\"tuple\"}],\"name\":\"setAutoSellConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"internalType\":\"struct CTB.Fees\",\"name\":\"fees_\",\"type\":\"tuple\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"share\",\"type\":\"uint256[]\"}],\"name\":\"setMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"setStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"trigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"unSetPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CTB", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000016728d238c800000000000000000000000000000000000000000000000000000000000000000f4361707461696e2054737562617361000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034354420000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://afe873adcd5bbca44c820226e0179bae7aa58edc7a5c94e6de232739d49de7b4"}