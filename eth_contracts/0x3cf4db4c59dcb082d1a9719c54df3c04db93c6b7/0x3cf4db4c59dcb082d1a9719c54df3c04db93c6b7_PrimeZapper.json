{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/utils/PrimeZapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ILRTDepositPool } from \\\"../interfaces/ILRTDepositPool.sol\\\";\\nimport { IWETH } from \\\"../interfaces/IWETH.sol\\\";\\n\\ncontract PrimeZapper {\\n    IERC20 public immutable primeEth;\\n    ILRTDepositPool public immutable lrtDepositPool;\\n    // TODO: add a fork test weth is correctly configured\\n    IWETH public immutable weth;\\n\\n    /* leaving ETH marker and \\\"asset\\\" in the Zap event just in case in \\n     * future we decide to allow for zapping with any other asset.\\n     */\\n    address private constant ETH_MARKER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\\n\\n    constructor(address _primeEth, address _lrtDepositPool, address _weth) {\\n        primeEth = IERC20(_primeEth);\\n        lrtDepositPool = ILRTDepositPool(_lrtDepositPool);\\n        weth = IWETH(_weth);\\n        weth.approve(address(_lrtDepositPool), type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Deposit ETH and receive primeETH in return.\\n     * Will not verify minimum amount of primeETH received\\n     */\\n    receive() external payable {\\n        deposit(0, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Deposit ETH and receive primeETH in return\\n     * @param minPrimeEth Minimum amount of primeETH for user to receive\\n     * @return primeEthAmount the amount of primeETH tokens sent to user\\n     */\\n    function deposit(uint256 minPrimeEth, string memory referralId) public payable returns (uint256 primeEthAmount) {\\n        uint256 balance = address(this).balance;\\n        weth.deposit{ value: balance }();\\n        emit Zap(msg.sender, ETH_MARKER, balance);\\n        primeEthAmount = _deposit(minPrimeEth, referralId);\\n    }\\n\\n    /**\\n     * @dev Internal function to deposit PrimeETH from WETH\\n     * @param minPrimeEth Minimum amount of PrimeETH for user to receive\\n     * @return primeEthAmount the amount of primeETH tokens sent to user\\n     */\\n    function _deposit(uint256 minPrimeEth, string memory referralId) internal returns (uint256 primeEthAmount) {\\n        uint256 toDeposit = weth.balanceOf(address(this));\\n        lrtDepositPool.depositAsset(address(weth), toDeposit, minPrimeEth, referralId);\\n        primeEthAmount = primeEth.balanceOf(address(this));\\n        require(primeEthAmount >= minPrimeEth, \\\"Zapper: not enough minted\\\");\\n        require(primeEth.transfer(msg.sender, primeEthAmount));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILRTDepositPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.21;\\n\\ninterface ILRTDepositPool {\\n    //errors\\n    error TokenTransferFailed();\\n    error InvalidAmountToDeposit();\\n    error NotEnoughAssetToTransfer();\\n    error MaximumDepositLimitReached();\\n    error MaximumNodeDelegatorLimitReached();\\n    error InvalidMaximumNodeDelegatorLimit();\\n    error MinimumAmountToReceiveNotMet();\\n    error NodeDelegatorNotFound();\\n    error NodeDelegatorHasAssetBalance(address assetAddress, uint256 assetBalance);\\n\\n    //events\\n    event MaxNodeDelegatorLimitUpdated(uint256 maxNodeDelegatorLimit);\\n    event NodeDelegatorAddedInQueue(address[] nodeDelegatorContracts);\\n    event NodeDelegatorRemovedFromQueue(address nodeDelegatorContracts);\\n    event AssetDeposit(\\n        address indexed depositor,\\n        address indexed asset,\\n        uint256 depositAmount,\\n        uint256 primeEthMintAmount,\\n        string referralId\\n    );\\n    event ETHDeposit(address indexed depositor, uint256 depositAmount, uint256 primeEthMintAmount, string referralId);\\n    event MinAmountToDepositUpdated(uint256 minAmountToDeposit);\\n    event AssetSwapped(\\n        address indexed fromAsset, address indexed toAsset, uint256 fromAssetAmount, uint256 toAssetAmount\\n    );\\n\\n    function depositAsset(\\n        address asset,\\n        uint256 depositAmount,\\n        uint256 minPrimeETHAmount,\\n        string calldata referralId\\n    )\\n        external;\\n\\n    function getTotalAssetDeposits(address asset) external view returns (uint256);\\n\\n    function getAssetCurrentLimit(address asset) external view returns (uint256);\\n\\n    function getMintAmount(address asset, uint256 depositAmount) external view returns (uint256);\\n\\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContract) external;\\n\\n    function transferAssetToNodeDelegator(uint256 ndcIndex, address asset, uint256 amount) external;\\n    function transferAssetsToNodeDelegator(uint256 ndcIndex, address[] calldata assets) external;\\n\\n    function updateMaxNodeDelegatorLimit(uint256 maxNodeDelegatorLimit) external;\\n\\n    function getNodeDelegatorQueue() external view returns (address[] memory);\\n\\n    function getAssetDistributionData(address asset)\\n        external\\n        view\\n        returns (uint256 depositPoolAssets, uint256 ndcAssets, uint256 eigenAssets);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function deposit() external payable;\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"solidity-code-metrics/=node_modules/solidity-code-metrics/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_primeEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lrtDepositPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Zap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPrimeEth\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"referralId\",\"type\":\"string\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"primeEthAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lrtDepositPool\",\"outputs\":[{\"internalType\":\"contract ILRTDepositPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primeEth\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PrimeZapper", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000006ef3d766dfe02dc4bf04aae9122eb9a0ded25615000000000000000000000000a479582c8b64533102f6f528774c536e354b8d32000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}