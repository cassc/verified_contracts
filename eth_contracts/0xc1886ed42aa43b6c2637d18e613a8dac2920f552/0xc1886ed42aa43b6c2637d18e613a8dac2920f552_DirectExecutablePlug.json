{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDaiLikePermit\\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\\n */\\ninterface IDaiLikePermit {\\n    /**\\n     * @notice Approves spending of tokens via off-chain signatures.\\n     * @param holder Token holder's address.\\n     * @param spender Spender's address.\\n     * @param nonce Current nonce of the holder.\\n     * @param expiry Time when the permit expires.\\n     * @param allowed True to allow, false to disallow spending.\\n     * @param v, r, s Signature components.\\n     */\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC7597Permit\\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\\n */\\ninterface IERC7597Permit {\\n    /**\\n     * @notice Update allowance with a signed permit.\\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\\n     * @param owner Token owner's address (Authorizer).\\n     * @param spender Spender's address.\\n     * @param value Amount of allowance.\\n     * @param deadline The time at which the signature expires (unixtime).\\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPermit2\\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\\n */\\ninterface IPermit2 {\\n    /**\\n     * @dev Struct for holding permit details.\\n     * @param token ERC20 token address for which the permit is issued.\\n     * @param amount The maximum amount allowed to spend.\\n     * @param expiration Timestamp until which the permit is valid.\\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\\n     */\\n    struct PermitDetails {\\n        address token;\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @dev Struct for a single token allowance permit.\\n     * @param details Permit details including token, amount, expiration, and nonce.\\n     * @param spender Address authorized to spend the tokens.\\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\\n     */\\n    struct PermitSingle {\\n        PermitDetails details;\\n        address spender;\\n        uint256 sigDeadline;\\n    }\\n\\n    /**\\n     * @dev Struct for packed allowance data to optimize storage.\\n     * @param amount Amount allowed.\\n     * @param expiration Permission expiry timestamp.\\n     * @param nonce Unique incrementing value for tracking allowances.\\n     */\\n    struct PackedAllowance {\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @notice Executes a token transfer from one address to another.\\n     * @param user The token owner's address.\\n     * @param spender The address authorized to spend the tokens.\\n     * @param amount The amount of tokens to transfer.\\n     * @param token The address of the token being transferred.\\n     */\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    /**\\n     * @notice Issues a permit for spending tokens via a signed authorization.\\n     * @param owner The token owner's address.\\n     * @param permitSingle Struct containing the permit details.\\n     * @param signature The signature proving the owner authorized the permit.\\n     */\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /**\\n     * @notice Retrieves the allowance details between a token owner and spender.\\n     * @param user The token owner's address.\\n     * @param token The token address.\\n     * @param spender The spender's address.\\n     * @return The packed allowance details.\\n     */\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n\\n    /**\\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\\n     * @param token The token to approve\\n     * @param spender The spender address to approve\\n     * @param amount The approved amount of the token\\n     * @param expiration The timestamp at which the approval is no longer valid\\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\\n     */\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\\n}\\n\"\r\n    },\r\n    \"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IWETH\\n * @dev Interface for wrapper as WETH-like token.\\n */\\ninterface IWETH is IERC20 {\\n    /**\\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\\n     */\\n    event Deposit(address indexed dst, uint256 wad);\\n\\n    /**\\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\\n     */\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    /**\\n     * @notice Deposit Ether to get wrapper tokens.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Withdraw wrapped tokens as Ether.\\n     * @param amount Amount of wrapped tokens to withdraw.\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RevertReasonForwarder\\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\\n */\\nlibrary RevertReasonForwarder {\\n    /**\\n     * @dev Forwards the revert reason from the latest external call.\\n     * This method allows propagating the revert reason of a failed external call to the caller.\\n     */\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the revert reason from the latest external call.\\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\\n     * @return reason The latest external call revert reason.\\n     */\\n    function reReason() internal pure returns (bytes memory reason) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            reason := mload(0x40)\\n            let length := returndatasize()\\n            mstore(reason, length)\\n            returndatacopy(add(reason, 0x20), 0, length)\\n            mstore(0x40, add(reason, add(0x20, length)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IERC7597Permit.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/**\\n * @title Implements efficient safe methods for ERC20 interface.\\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\\n * 1. more gas-efficient, providing significant savings in transaction costs.\\n * 2. support for different permit implementations\\n * 3. forceApprove functionality\\n * 4. support for WETH deposit and withdraw\\n */\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    // Uniswap Permit2 address\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\\n\\n    /**\\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\\n     * Consumes less gas then regular `ERC20.balanceOf`.\\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\\n     * @param token The IERC20 token contract for which the balance will be fetched.\\n     * @param account The address of the account whose token balance will be fetched.\\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\\n     */\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another.\\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\\n     */\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(_PERMIT2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens to another address.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely increases the allowance of a spender.\\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to increase the allowance by.\\n     */\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /**\\n     * @notice Safely decreases the allowance of a spender.\\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to decrease the allowance by.\\n     */\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param owner The owner of the tokens for which the permit is made.\\n     * @param spender The spender allowed to spend the tokens by the permit.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\\n     */\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    /**\\n     * @notice The function attempts to call the permit function on a given ERC20 token.\\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\\n     * It accommodates both Compact and Full formats of these permit types.\\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\\n     * before invocation for optimized performance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The address of the ERC20 token on which to call the permit function.\\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\\n     * @param spender The address which will be approved for transfer of tokens.\\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\\n     * @return success A boolean indicating whether the permit call was successful.\\n     */\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        // load function selectors for different permit standards\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // Switch case for different permit lengths, indicating different permit standards\\n            switch permit.length\\n            // Compact IERC20Permit\\n            case 100 {\\n                mstore(ptr, permitSelector)     // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // Compact IDaiLikePermit\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)  // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // IERC20Permit\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // IDaiLikePermit\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // Compact IPermit2\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)  // store selector\\n                mstore(add(ptr, 0x04), owner) // store owner\\n                mstore(add(ptr, 0x24), token) // store token\\n\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\\n                mstore(add(ptr, 0xa4), spender)                               // store spender\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // IPermit2\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // Dynamic length\\n            default {\\n                mstore(ptr, erc7597PermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param selector The function signature that is to be called on the token contract.\\n     * @param to The address to which the token amount will be transferred.\\n     * @param amount The token amount to be transferred.\\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\\n     * In case of success but no returned data, validates that the contract code exists.\\n     * In case of returned data, ensures that it's a boolean `true`.\\n     */\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of Ether to deposit into the IWETH contract.\\n     */\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        if (amount > 0) {\\n            bytes4 selector = IWETH.deposit.selector;\\n            assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                mstore(0, selector)\\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\\n     * @dev Uses inline assembly to interact with the IWETH contract.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     */\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\\n     * Consumes less gas then regular `IWETH.withdraw`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     * @param to The recipient of the withdrawn Ether.\\n     */\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IConfigurable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Configurable Interface\\n/// @notice This interface defines the functions for manage market configurations\\ninterface IConfigurable {\\n    struct MarketConfig {\\n        /// @notice The liquidation fee rate for per trader position,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 liquidationFeeRatePerPosition;\\n        /// @notice The maximum size rate for per position, denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 maxSizeRatePerPosition;\\n        /// @notice If the balance rate after increasing a long position is greater than this parameter,\\n        /// then the trading fee rate will be changed to the floating fee rate,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 openPositionThreshold;\\n        /// @notice The trading fee rate for taker increase or decrease positions,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 tradingFeeRate;\\n        /// @notice The maximum leverage for per trader position, for example, 100 means the maximum leverage\\n        /// is 100 times\\n        uint8 maxLeveragePerPosition;\\n        /// @notice The market token decimals\\n        uint8 decimals;\\n        /// @notice A system variable to calculate the `spread`\\n        uint120 liquidityScale;\\n        /// @notice The protocol fee rate as a percentage of trading fee,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 protocolFeeRate;\\n        /// @notice The maximum floating fee rate for increasing long position,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 maxFeeRate;\\n        /// @notice A system variable to calculate the `spreadFactor`, in seconds\\n        uint24 riskFreeTime;\\n        /// @notice The minimum entry margin required for per trader position\\n        uint64 minMarginPerPosition;\\n        /// @notice If balance rate is less than minMintingRate, the minting is disabled,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 minMintingRate;\\n        /// @notice If balance rate is greater than maxBurningRate, the burning is disabled,\\n        /// denominated in thousandths of a bip (i.e. 1e-7)\\n        uint24 maxBurningRate;\\n        /// @notice The liquidation execution fee for LP and trader positions\\n        uint64 liquidationExecutionFee;\\n        /// @notice Whether the liquidity buffer module is enabled when decreasing position\\n        bool liquidityBufferModuleEnabled;\\n        /// @notice If the total supply of the stable coin reach stableCoinSupplyCap, the minting is disabled.\\n        uint64 stableCoinSupplyCap;\\n        /// @notice The capacity of the liquidity\\n        uint120 liquidityCap;\\n    }\\n\\n    /// @notice Emitted when the market is enabled\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param cfg The new market configuration\\n    event MarketConfigEnabled(IERC20 indexed market, MarketConfig cfg);\\n\\n    /// @notice Emitted when a market configuration is changed\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param cfg The new market configuration\\n    event MarketConfigChanged(IERC20 indexed market, MarketConfig cfg);\\n\\n    /// @notice Market is already enabled\\n    error MarketAlreadyEnabled(IERC20 market);\\n    /// @notice Market is not enabled\\n    error MarketNotEnabled(IERC20 market);\\n    /// @notice Invalid maximum leverage for trader positions\\n    error InvalidMaxLeveragePerPosition(uint8 maxLeveragePerPosition);\\n    /// @notice Invalid liquidation fee rate for trader positions\\n    error InvalidLiquidationFeeRatePerPosition(uint24 liquidationFeeRatePerPosition);\\n    /// @notice Invalid max size per rate for per position\\n    error InvalidMaxSizeRatePerPosition(uint24 maxSizeRatePerPosition);\\n    /// @notice Invalid liquidity capacity\\n    error InvalidLiquidityCap(uint120 liquidityCap);\\n    /// @notice Invalid trading fee rate\\n    error InvalidTradingFeeRate(uint24 tradingFeeRate);\\n    /// @notice Invalid protocol fee rate\\n    error InvalidProtocolFeeRate(uint24 protocolFeeRate);\\n    /// @notice Invalid min minting rate\\n    error InvalidMinMintingRate(uint24 minMintingRate);\\n    /// @notice Invalid max burning rate\\n    error InvalidMaxBurningRate(uint24 maxBurnningRate);\\n    /// @notice Invalid open position threshold\\n    error InvalidOpenPositionThreshold(uint24 openPositionThreshold);\\n    /// @notice Invalid max fee rate\\n    error InvalidMaxFeeRate(uint24 maxFeeRate);\\n    /// @notice The risk free time is zero, which is not allowed\\n    error ZeroRiskFreeTime();\\n    /// @notice The liquidity scale is zero, which is not allowed\\n    error ZeroLiquidityScale();\\n    /// @notice Invalid stable coin supply capacity\\n    error InvalidStableCoinSupplyCap(uint256 stablecoinSupplyCap);\\n    /// @notice Invalid decimals\\n    error InvalidDecimals(uint8 decimals);\\n\\n    /// @notice Checks if a market is enabled\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @return True if the market is enabled, false otherwise\\n    function isEnabledMarket(IERC20 market) external view returns (bool);\\n\\n    /// @notice Get the information of market configuration\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function marketConfigs(IERC20 market) external view returns (MarketConfig memory);\\n\\n    /// @notice Enable the market\\n    /// @dev The call will fail if caller is not the governor or the market is already enabled\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param tokenSymbol The symbol of the LP token\\n    /// @param cfg The market configuration\\n    function enableMarket(IERC20 market, string calldata tokenSymbol, MarketConfig calldata cfg) external;\\n\\n    /// @notice Update a market configuration\\n    /// @dev The call will fail if caller is not the governor or the market is not enabled\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param newCfg The new market configuration\\n    function updateMarketConfig(IERC20 market, MarketConfig calldata newCfg) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/ILPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ILPToken is IERC20 {\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IMarketErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IMarketErrors {\\n    /// @notice Failed to transfer ETH\\n    error FailedTransferETH();\\n    /// @notice Invalid caller\\n    error InvalidCaller(address requiredCaller);\\n    /// @notice Insufficient size to decrease\\n    error InsufficientSizeToDecrease(uint128 requiredSize, uint128 size);\\n    /// @notice Insufficient margin\\n    error InsufficientMargin();\\n    /// @notice Position not found\\n    error PositionNotFound(address requiredAccount);\\n    /// @notice Size exceeds max size per position\\n    error SizeExceedsMaxSizePerPosition(uint256 requiredSize, uint256 maxSizePerPosition);\\n    /// @notice Size exceeds max size\\n    error SizeExceedsMaxSize(uint256 requiredSize, uint256 maxSize);\\n    /// @notice Insufficient liquidity to decrease\\n    error InsufficientLiquidityToDecrease(uint256 liquidity, uint128 requiredLiquidity);\\n    /// @notice Liquidity Cap exceeded\\n    error LiquidityCapExceeded(uint128 liquidityBefore, uint96 liquidityDelta, uint120 liquidityCap);\\n    /// @notice Balance Rate Cap exceeded\\n    error BalanceRateCapExceeded();\\n    /// @notice Error thrown when min minting size cap is not met\\n    error MinMintingSizeCapNotMet(uint128 netSize, uint128 sizeDelta, uint128 minMintingSizeCap);\\n    /// @notice Error thrown when max burning size cap is exceeded\\n    error MaxBurningSizeCapExceeded(uint128 netSize, uint128 sizeDelta, uint256 maxBurningSizeCap);\\n    /// @notice Insufficient balance\\n    error InsufficientBalance(uint256 balance, uint256 requiredAmount);\\n    /// @notice Leverage is too high\\n    error LeverageTooHigh(uint256 margin, uint128 size, uint8 maxLeverage);\\n    /// @notice Position margin rate is too low\\n    error MarginRateTooLow(int256 margin, uint256 maintenanceMargin);\\n    /// @notice Position margin rate is too high\\n    error MarginRateTooHigh(int256 margin, uint256 maintenanceMargin);\\n    error InvalidAmount(uint128 requiredAmount, uint128 pusdBalance);\\n    error InvalidSize();\\n    /// @notice Stable Coin Supply Cap exceeded\\n    error StableCoinSupplyCapExceeded(uint256 supplyCap, uint256 totalSupply, uint256 amountDelta);\\n    /// @notice Error thrown when the pay amount is less than the required amount\\n    error TooLittlePayAmount(uint128 requiredAmount, uint128 payAmount);\\n    /// @notice Error thrown when the pay amount is not equal to the required amount\\n    error UnexpectedPayAmount(uint128 requiredAmount, uint128 payAmount);\\n    error NegativeReceiveAmount(int256 receiveAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IMarketLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILPToken.sol\\\";\\n\\n/// @notice Interface for managing liquidity of the protocol\\ninterface IMarketLiquidity {\\n    /// @notice Emitted when the global liquidity is increased by trading fee\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param liquidityFee The increased liquidity fee\\n    event GlobalLiquidityIncreasedByTradingFee(IERC20 indexed market, uint96 liquidityFee);\\n\\n    /// @notice Emitted when the global liquidity is settled\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param sizeDelta The change in the global liquidity\\n    /// @param realizedPnL The realized PnL of the global liquidity\\n    /// @param entryPriceAfter The entry price after the settlement\\n    event GlobalLiquiditySettled(IERC20 indexed market, int256 sizeDelta, int256 realizedPnL, uint64 entryPriceAfter);\\n\\n    /// @notice Emitted when a new LP Token is deployed\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param token The LP Token contract address\\n    event LPTokenDeployed(IERC20 indexed market, ILPToken indexed token);\\n\\n    /// @notice Emitted when the LP Token is minted\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the LP Token\\n    /// @param receiver The address to receive the minted LP Token\\n    /// @param liquidity The liquidity provided by the LP\\n    /// @param tokenValue The LP Token to be minted\\n    event LPTMinted(\\n        IERC20 indexed market,\\n        address indexed account,\\n        address indexed receiver,\\n        uint96 liquidity,\\n        uint64 tokenValue\\n    );\\n\\n    /// @notice Emitted when the LP Token is burned\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the LP Token\\n    /// @param receiver The address to receive the margin\\n    /// @param liquidity The liquidity to be returned to the LP\\n    /// @param tokenValue The LP Token to be burned\\n    event LPTBurned(\\n        IERC20 indexed market,\\n        address indexed account,\\n        address indexed receiver,\\n        uint96 liquidity,\\n        uint64 tokenValue\\n    );\\n\\n    /// @notice Mint the LP Token\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The address to mint the liquidity. The parameter is only used for emitting event\\n    /// @param receiver The address to receive the minted LP Token\\n    /// @return tokenValue The LP Token to be minted\\n    function mintLPT(IERC20 market, address account, address receiver) external returns (uint64 tokenValue);\\n\\n    /// @notice Burn the LP Token\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The address to burn the liquidity. The parameter is only used for emitting event\\n    /// @param receiver The address to receive the returned liquidity\\n    /// @return liquidity The liquidity to be returned to the LP\\n    function burnLPT(IERC20 market, address account, address receiver) external returns (uint96 liquidity);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IMarketManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPSM.sol\\\";\\nimport \\\"./IConfigurable.sol\\\";\\nimport \\\"./IMarketErrors.sol\\\";\\nimport \\\"./IPUSDManager.sol\\\";\\nimport \\\"./IMarketPosition.sol\\\";\\nimport \\\"./IMarketLiquidity.sol\\\";\\nimport \\\"../../oracle/interfaces/IPriceFeed.sol\\\";\\nimport \\\"../../plugins/interfaces/IPluginManager.sol\\\";\\nimport \\\"../../oracle/interfaces/IPriceFeed.sol\\\";\\n\\ninterface IMarketManager is\\n    IMarketErrors,\\n    IMarketPosition,\\n    IMarketLiquidity,\\n    IPUSDManager,\\n    IConfigurable,\\n    IPluginManager,\\n    IPriceFeed,\\n    IPSM\\n{\\n    struct LiquidityBufferModule {\\n        /// @notice The debt of the liquidity buffer module\\n        uint128 pusdDebt;\\n        /// @notice The token payback of the liquidity buffer module\\n        uint128 tokenPayback;\\n    }\\n\\n    struct PackedState {\\n        /// @notice The spread factor used to calculate spread\\n        int256 spreadFactorX96;\\n        /// @notice Last trading timestamp in seconds since Unix epoch\\n        uint64 lastTradingTimestamp;\\n        /// @notice The sum of long position sizes\\n        uint128 longSize;\\n        /// @notice The entry price of the net position\\n        uint64 lpEntryPrice;\\n        /// @notice The total liquidity of all LPs\\n        uint128 lpLiquidity;\\n        /// @notice The size of the net position held by all LPs\\n        uint128 lpNetSize;\\n    }\\n\\n    struct State {\\n        /// @notice The packed state of the market\\n        PackedState packedState;\\n        /// @notice The value is used to track the global PUSD position\\n        GlobalPUSDPosition globalPUSDPosition;\\n        /// @notice Mapping of account to long position\\n        mapping(address account => Position) longPositions;\\n        /// @notice The value is used to track the liquidity buffer module status\\n        LiquidityBufferModule liquidityBufferModule;\\n        /// @notice The value is used to track the remaining protocol fee of the market\\n        uint128 protocolFee;\\n        /// @notice The value is used to track the token balance of the market\\n        uint128 tokenBalance;\\n        /// @notice The margin of the global stability fund\\n        uint256 globalStabilityFund;\\n    }\\n\\n    /// @notice Emitted when the protocol fee is increased\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param amount The increased protocol fee\\n    event ProtocolFeeIncreased(IERC20 indexed market, uint96 amount);\\n\\n    /// @notice Emitted when the protocol fee is collected\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param amount The collected protocol fee\\n    event ProtocolFeeCollected(IERC20 indexed market, uint128 amount);\\n\\n    /// @notice Emitted when the stability fund is used by `Gov`\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param receiver The address that receives the stability fund\\n    /// @param stabilityFundDelta The amount of stability fund used\\n    event GlobalStabilityFundGovUsed(IERC20 indexed market, address indexed receiver, uint128 stabilityFundDelta);\\n\\n    /// @notice Emitted when the liquidity of the stability fund is increased by liquidation\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param liquidationFee The amount of the liquidation fee that is added to the stability fund.\\n    event GlobalStabilityFundIncreasedByLiquidation(IERC20 indexed market, uint96 liquidationFee);\\n\\n    /// @notice Emitted when the liquidity of the stability fund is increased by spread\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param spread The spread incurred by the position\\n    event GlobalStabilityFundIncreasedBySpread(IERC20 indexed market, uint96 spread);\\n\\n    /// @notice Emitted when the liquidity buffer module debt is increased\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The address for debt repayment\\n    /// @param pusdDebtDelta The increase in the debt of the LBM module\\n    /// @param tokenPaybackDelta The increase in the token payback of the LBM module\\n    event LiquidityBufferModuleDebtIncreased(\\n        IERC20 market,\\n        address account,\\n        uint128 pusdDebtDelta,\\n        uint128 tokenPaybackDelta\\n    );\\n\\n    /// @notice Emitted when the liquidity buffer module debt is repaid\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The address for debt repayment\\n    /// @param pusdDebtDelta The decrease in the debt of the LBM module\\n    /// @param tokenPaybackDelta The decrease in the token payback of the LBM module\\n    event LiquidityBufferModuleDebtRepaid(\\n        IERC20 market,\\n        address account,\\n        uint128 pusdDebtDelta,\\n        uint128 tokenPaybackDelta\\n    );\\n\\n    /// @notice Emitted when the spread factor is changed\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param spreadFactorAfterX96 The spread factor after the trade, as a Q160.96\\n    event SpreadFactorChanged(IERC20 market, int256 spreadFactorAfterX96);\\n\\n    /// @notice Get the packed state of the given market\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function packedStates(IERC20 market) external view returns (PackedState memory);\\n\\n    /// @notice Get the remaining protocol fee of the given market\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function protocolFees(IERC20 market) external view returns (uint128);\\n\\n    /// @notice Get the token balance of the given market\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function tokenBalances(IERC20 market) external view returns (uint128);\\n\\n    /// @notice Collect the protocol fee of the given market\\n    /// @dev This function can be called without authorization\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function collectProtocolFee(IERC20 market) external;\\n\\n    /// @notice Get the information of global stability fund\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function globalStabilityFunds(IERC20 market) external view returns (uint256);\\n\\n    /// @notice `Gov` uses the stability fund\\n    /// @dev The call will fail if the caller is not the `Gov` or the stability fund is insufficient\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param receiver The address to receive the stability fund\\n    /// @param stabilityFundDelta The amount of stability fund to be used\\n    function govUseStabilityFund(IERC20 market, address receiver, uint128 stabilityFundDelta) external;\\n\\n    /// @notice Repay the liquidity buffer debt of the given market\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The address for debt repayment\\n    /// @param receiver The address to receive the payback token\\n    /// @return receiveAmount The amount of payback token received\\n    function repayLiquidityBufferDebt(\\n        IERC20 market,\\n        address account,\\n        address receiver\\n    ) external returns (uint128 receiveAmount);\\n\\n    /// @notice Get the liquidity buffer module of the given market\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @return liquidityBufferModule The liquidity buffer module data\\n    function liquidityBufferModules(\\n        IERC20 market\\n    ) external view returns (LiquidityBufferModule memory liquidityBufferModule);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IMarketPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {Side} from \\\"../../types/Side.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Interface for managing market positions.\\n/// @dev The market position is the core component of the protocol, which stores the information of\\n/// all trader's positions.\\ninterface IMarketPosition {\\n    struct Position {\\n        /// @notice The margin of the position\\n        uint96 margin;\\n        /// @notice The size of the position\\n        uint96 size;\\n        /// @notice The entry price of the position\\n        uint64 entryPrice;\\n    }\\n\\n    /// @notice Emitted when the position is increased\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the position\\n    /// @param marginDelta The increased margin\\n    /// @param marginAfter The adjusted margin\\n    /// @param sizeDelta The increased size\\n    /// @param indexPrice The index price at which the position is increased.\\n    /// If only adding margin, it will be 0\\n    /// @param entryPriceAfter The adjusted entry price of the position\\n    /// @param tradingFee The trading fee paid by the position\\n    /// @param spread The spread incurred by the position\\n    event PositionIncreased(\\n        IERC20 indexed market,\\n        address indexed account,\\n        uint96 marginDelta,\\n        uint96 marginAfter,\\n        uint96 sizeDelta,\\n        uint64 indexPrice,\\n        uint64 entryPriceAfter,\\n        uint96 tradingFee,\\n        uint96 spread\\n    );\\n\\n    /// @notice Emitted when the position is decreased\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the position\\n    /// @param marginDelta The decreased margin\\n    /// @param marginAfter The adjusted margin\\n    /// @param sizeDelta The decreased size\\n    /// @param indexPrice The index price at which the position is decreased\\n    /// @param realizedPnL The realized PnL\\n    /// @param tradingFee The trading fee paid by the position\\n    /// @param spread The spread incurred by the position\\n    /// @param receiver The address that receives the margin\\n    event PositionDecreased(\\n        IERC20 indexed market,\\n        address indexed account,\\n        uint96 marginDelta,\\n        uint96 marginAfter,\\n        uint96 sizeDelta,\\n        uint64 indexPrice,\\n        int256 realizedPnL,\\n        uint96 tradingFee,\\n        uint96 spread,\\n        address receiver\\n    );\\n\\n    /// @notice Emitted when a position is liquidated\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param liquidator The address that executes the liquidation of the position\\n    /// @param account The owner of the position\\n    /// @param sizeDelta The liquidated size\\n    /// @param indexPrice The index price at which the position is liquidated\\n    /// @param liquidationPrice The liquidation price of the position\\n    /// @param tradingFee The trading fee paid by the position\\n    /// @param liquidationFee The liquidation fee paid by the position\\n    /// @param liquidationExecutionFee The liquidation execution fee paid by the position\\n    /// @param feeReceiver The address that receives the liquidation execution fee\\n    event PositionLiquidated(\\n        IERC20 indexed market,\\n        address indexed liquidator,\\n        address indexed account,\\n        uint96 sizeDelta,\\n        uint64 indexPrice,\\n        uint64 liquidationPrice,\\n        uint96 tradingFee,\\n        uint96 liquidationFee,\\n        uint64 liquidationExecutionFee,\\n        address feeReceiver\\n    );\\n\\n    /// @notice Get the information of a long position\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the position\\n    function longPositions(IERC20 market, address account) external view returns (Position memory);\\n\\n    /// @notice Increase the margin or size of a position\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the position\\n    /// @param sizeDelta The increase in size, which can be 0\\n    /// @return spread The spread incurred by the position\\n    function increasePosition(IERC20 market, address account, uint96 sizeDelta) external returns (uint96 spread);\\n\\n    /// @notice Decrease the margin or size of a position\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the position\\n    /// @param marginDelta The decrease in margin, which can be 0. If the position size becomes zero after\\n    /// the decrease, the marginDelta will be ignored, and all remaining margin will be returned\\n    /// @param sizeDelta The decrease in size, which can be 0\\n    /// @param receiver The address to receive the margin\\n    /// @return spread The spread incurred by the position\\n    /// @return actualMarginDelta The actual decrease in margin\\n    function decreasePosition(\\n        IERC20 market,\\n        address account,\\n        uint96 marginDelta,\\n        uint96 sizeDelta,\\n        address receiver\\n    ) external returns (uint96 spread, uint96 actualMarginDelta);\\n\\n    /// @notice Liquidate a position\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param account The owner of the position\\n    /// @param feeReceiver The address that receives the liquidation execution fee\\n    function liquidatePosition(IERC20 market, address account, address feeReceiver) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IPSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Peg Stability Module interface\\ninterface IPSM {\\n    struct CollateralState {\\n        uint120 cap;\\n        uint8 decimals;\\n        uint128 balance;\\n    }\\n\\n    /// @notice Emitted when the collateral cap is updated\\n    event PSMCollateralUpdated(IERC20 collateral, uint120 cap);\\n\\n    /// @notice Emit when PUSD is minted through the PSM module\\n    /// @param collateral The collateral token\\n    /// @param receiver Address to receive PUSD\\n    /// @param payAmount The amount of collateral paid\\n    /// @param receiveAmount The amount of PUSD minted\\n    event PSMMinted(IERC20 indexed collateral, address indexed receiver, uint96 payAmount, uint64 receiveAmount);\\n\\n    /// @notice Emitted when PUSD is burned through the PSM module\\n    /// @param collateral The collateral token\\n    /// @param receiver Address to receive collateral\\n    /// @param payAmount The amount of PUSD burned\\n    /// @param receiveAmount The amount of collateral received\\n    event PSMBurned(IERC20 indexed collateral, address indexed receiver, uint64 payAmount, uint96 receiveAmount);\\n\\n    /// @notice Invalid collateral token\\n    error InvalidCollateral();\\n\\n    /// @notice Invalid collateral decimals\\n    error InvalidCollateralDecimals(uint8 decimals);\\n\\n    /// @notice The PSM balance is insufficient\\n    error InsufficientPSMBalance(uint96 receiveAmount, uint128 balance);\\n\\n    /// @notice Get the collateral state\\n    function psmCollateralStates(IERC20 collateral) external view returns (CollateralState memory);\\n\\n    /// @notice Update the collateral cap\\n    /// @param collateral The collateral token\\n    /// @param cap The new cap\\n    function updatePSMCollateralCap(IERC20 collateral, uint120 cap) external;\\n\\n    /// @notice Mint PUSD\\n    /// @param collateral The collateral token\\n    /// @param receiver Address to receive PUSD\\n    /// @return receiveAmount The amount of PUSD minted\\n    function psmMintPUSD(IERC20 collateral, address receiver) external returns (uint64 receiveAmount);\\n\\n    /// @notice Burn PUSD\\n    /// @param collateral The collateral token\\n    /// @param receiver Address to receive collateral\\n    /// @return receiveAmount The amount of collateral received\\n    function psmBurnPUSD(IERC20 collateral, address receiver) external returns (uint96 receiveAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IPUSD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPUSD is IERC20 {\\n    /// @notice Emitted when minter is updated\\n    event MinterUpdate(address minter, bool enabled);\\n\\n    error InvalidMinter();\\n\\n    /// @notice Set minter\\n    /// @param minter Minter address\\n    /// @param enabled Whether minter is enabled\\n    function setMinter(address minter, bool enabled) external;\\n\\n    function mint(address to, uint256 value) external;\\n\\n    function burn(uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IPUSDManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPUSDManagerCallback.sol\\\";\\n\\n/// @notice Interface for managing the minting and burning of PUSD.\\ninterface IPUSDManager {\\n    struct GlobalPUSDPosition {\\n        /// @notice The total PUSD supply of the current market\\n        uint64 totalSupply;\\n        /// @notice The size of the position\\n        uint128 size;\\n        /// @notice The entry price of the position\\n        uint64 entryPrice;\\n    }\\n\\n    /// @notice Emitted when the PUSD position is increased\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param receiver Address to receive PUSD\\n    /// @param sizeDelta The size of the position to increase\\n    /// @param indexPrice The index price at which the position is increased\\n    /// @param entryPriceAfter The adjusted entry price of the position\\n    /// @param payAmount The amount of token to pay\\n    /// @param receiveAmount The amount of PUSD to mint\\n    /// @param tradingFee The amount of trading fee to pay\\n    /// @param spread The spread incurred by the position\\n    event PUSDPositionIncreased(\\n        IERC20 indexed market,\\n        address indexed receiver,\\n        uint96 sizeDelta,\\n        uint64 indexPrice,\\n        uint64 entryPriceAfter,\\n        uint96 payAmount,\\n        uint64 receiveAmount,\\n        uint96 tradingFee,\\n        uint96 spread\\n    );\\n\\n    /// @notice Emitted when the PUSD position is decreased\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param receiver Address to receive token\\n    /// @param sizeDelta The size of the position to decrease\\n    /// @param indexPrice The index price at which the position is decreased\\n    /// @param payAmount The amount of PUSD to burn\\n    /// @param receiveAmount The amount of token to receive\\n    /// @param realizedPnL The realized profit and loss of the position\\n    /// @param tradingFee The amount of trading fee to pay\\n    /// @param spread The spread incurred by the position\\n    event PUSDPositionDecreased(\\n        IERC20 indexed market,\\n        address indexed receiver,\\n        uint96 sizeDelta,\\n        uint64 indexPrice,\\n        uint64 payAmount,\\n        uint96 receiveAmount,\\n        int256 realizedPnL,\\n        uint96 tradingFee,\\n        uint96 spread\\n    );\\n\\n    /// @notice Get the global PUSD position of the given market\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    function globalPUSDPositions(IERC20 market) external view returns (GlobalPUSDPosition memory);\\n\\n    /// @notice Mint PUSD\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param amount When `exactIn` is true, it is the amount of token to pay,\\n    /// otherwise, it is the amount of PUSD to mint\\n    /// @param callback Address to callback after minting\\n    /// @param data Any data to be passed to the callback\\n    /// @param receiver Address to receive PUSD\\n    /// @return payAmount The amount of token to pay\\n    /// @return receiveAmount The amount of PUSD to receive\\n    function mintPUSD(\\n        IERC20 market,\\n        bool exactIn,\\n        uint96 amount,\\n        IPUSDManagerCallback callback,\\n        bytes calldata data,\\n        address receiver\\n    ) external returns (uint96 payAmount, uint64 receiveAmount);\\n\\n    /// @notice Burn PUSD\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param amount When `exactIn` is true, it is the amount of PUSD to burn,\\n    /// otherwise, it is the amount of token to receive\\n    /// @param callback Address to callback after burning\\n    /// @param data Any data to be passed to the callback\\n    /// @param receiver Address to receive token\\n    /// @return payAmount The amount of PUSD to pay\\n    /// @return receiveAmount The amount of token to receive\\n    function burnPUSD(\\n        IERC20 market,\\n        bool exactIn,\\n        uint96 amount,\\n        IPUSDManagerCallback callback,\\n        bytes calldata data,\\n        address receiver\\n    ) external returns (uint64 payAmount, uint96 receiveAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IPUSDManagerCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Callback for IPUSDManager.mint and IPUSDManager.burn\\ninterface IPUSDManagerCallback {\\n    /// @notice Called after executing a mint or burn operation\\n    /// @dev In this implementation, you are required to pay the amount of `payAmount` to the caller.\\n    /// @dev In this implementation, you MUST check that the caller is IPUSDManager.\\n    /// @param payToken The token to pay\\n    /// @param payAmount The amount of token to pay\\n    /// @param receiveAmount The amount of token to receive\\n    /// @param data The data passed to the original `mint` or `burn` function\\n    function PUSDManagerCallback(IERC20 payToken, uint96 payAmount, uint96 receiveAmount, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity =0.8.26;\\n\\ncontract Governable {\\n    address private _gov;\\n    address private _pendingGov;\\n\\n    event ChangeGovStarted(address indexed previousGov, address indexed newGov);\\n    event GovChanged(address indexed previousGov, address indexed newGov);\\n\\n    error Forbidden();\\n\\n    modifier onlyGov() {\\n        _onlyGov();\\n        _;\\n    }\\n\\n    constructor(address _initialGov) {\\n        _changeGov(_initialGov);\\n    }\\n\\n    function gov() public view virtual returns (address) {\\n        return _gov;\\n    }\\n\\n    function pendingGov() public view virtual returns (address) {\\n        return _pendingGov;\\n    }\\n\\n    function changeGov(address _newGov) public virtual onlyGov {\\n        _pendingGov = _newGov;\\n        emit ChangeGovStarted(_gov, _newGov);\\n    }\\n\\n    function acceptGov() public virtual {\\n        if (msg.sender != _pendingGov) revert Forbidden();\\n\\n        delete _pendingGov;\\n        _changeGov(msg.sender);\\n    }\\n\\n    function _changeGov(address _newGov) internal virtual {\\n        address previousGov = _gov;\\n        _gov = _newGov;\\n        emit GovChanged(previousGov, _newGov);\\n    }\\n\\n    function _onlyGov() internal view {\\n        if (msg.sender != _gov) revert Forbidden();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Governable.sol\\\";\\n\\nabstract contract GovernableProxy {\\n    Governable private _impl;\\n\\n    error Forbidden();\\n\\n    modifier onlyGov() {\\n        _onlyGov();\\n        _;\\n    }\\n\\n    constructor(Governable _newImpl) {\\n        _impl = _newImpl;\\n    }\\n\\n    function _changeImpl(Governable _newGov) public virtual onlyGov {\\n        _impl = _newGov;\\n    }\\n\\n    function gov() public view virtual returns (address) {\\n        return _impl.gov();\\n    }\\n\\n    function _onlyGov() internal view {\\n        if (msg.sender != _impl.gov()) revert Forbidden();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IWETHMinimum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IWETHMinimum {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function balanceOf(address dst) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary Constants {\\n    uint24 internal constant BASIS_POINTS_DIVISOR = 10_000_000;\\n\\n    uint8 internal constant DECIMALS_6 = 6;\\n    uint8 internal constant PRICE_DECIMALS = 10;\\n    uint64 internal constant PRICE_1 = uint64(10 ** PRICE_DECIMALS);\\n\\n    uint256 internal constant Q64 = 1 << 64;\\n    uint256 internal constant Q96 = 1 << 96;\\n    uint256 internal constant Q72 = 1 << 72;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MarketUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"../core/interfaces/IMarketManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SafeERC20 as OneInchSafeERC20} from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\n\\n/// @notice Utility library for market manager\\nlibrary MarketUtil {\\n    using SafeCast for *;\\n\\n    /// @notice Transfer ETH from the contract to the receiver\\n    /// @param _receiver The address of the receiver\\n    /// @param _amount The amount of ETH to transfer\\n    /// @param _executionGasLimit The gas limit for the transfer\\n    function transferOutETH(address payable _receiver, uint256 _amount, uint256 _executionGasLimit) internal {\\n        if (_amount == 0) return;\\n\\n        if (address(this).balance < _amount) revert IMarketErrors.InsufficientBalance(address(this).balance, _amount);\\n\\n        (bool success, ) = _receiver.call{value: _amount, gas: _executionGasLimit}(\\\"\\\");\\n        if (!success) revert IMarketErrors.FailedTransferETH();\\n    }\\n\\n    /// @notice Check if the account is a deployed contract\\n    /// @param _account The address of the account\\n    /// @return true if the account is a deployed contract, false otherwise\\n    function isDeployedContract(address _account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        // prettier-ignore\\n        assembly { size := extcodesize(_account) }\\n        return size > 0;\\n    }\\n\\n    /// @notice `Gov` uses the stability fund\\n    /// @param _state The state of the market\\n    /// @param _market The target market contract address, such as the contract address of WETH\\n    /// @param _stabilityFundDelta The amount of stability fund to be used\\n    /// @param _receiver The address to receive the stability fund\\n    function govUseStabilityFund(\\n        IMarketManager.State storage _state,\\n        IERC20 _market,\\n        uint128 _stabilityFundDelta,\\n        address _receiver\\n    ) public {\\n        _state.globalStabilityFund -= _stabilityFundDelta;\\n        emit IMarketManager.GlobalStabilityFundGovUsed(_market, _receiver, _stabilityFundDelta);\\n    }\\n\\n    /// @notice Validate the leverage of a position\\n    /// @param _margin The margin of the position\\n    /// @param _size The size of the position\\n    /// @param _maxLeverage The maximum acceptable leverage of the position\\n    function validateLeverage(uint128 _margin, uint128 _size, uint8 _maxLeverage) internal pure {\\n        unchecked {\\n            if (uint256(_margin) * _maxLeverage < _size)\\n                revert IMarketErrors.LeverageTooHigh(_margin, _size, _maxLeverage);\\n        }\\n    }\\n\\n    function safePermit(IERC20 _token, address _spender, bytes calldata _data) internal {\\n        if (_data.length == 0) return;\\n        OneInchSafeERC20.safePermit(_token, msg.sender, _spender, _data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/IChainLinkAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IChainLinkAggregator {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(\\n        uint80 _roundId\\n    )\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IChainLinkAggregator.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../types/PackedValue.sol\\\";\\n\\ninterface IPriceFeed {\\n    struct PriceFeedConfig {\\n        /// @notice ChainLink contract address for corresponding market\\n        IChainLinkAggregator refPriceFeed;\\n        /// @notice Expected update interval of chain link price feed\\n        uint32 refHeartbeatDuration;\\n        /// @notice Maximum cumulative change ratio difference between prices and ChainLink price\\n        /// within a period of time.\\n        uint48 maxCumulativeDeltaDiff;\\n        /// @notice Decimals of ChainLink price\\n        uint8 refPriceDecimals;\\n    }\\n\\n    struct PriceDataItem {\\n        /// @notice previous round id\\n        uint32 prevRound;\\n        /// @notice previous ChainLink price\\n        uint64 prevRefPrice;\\n        /// @notice cumulative value of the ChainLink price change ratio in a round\\n        uint64 cumulativeRefPriceDelta;\\n        /// @notice previous market price\\n        uint64 prevPrice;\\n        /// @notice cumulative value of the market price change ratio in a round\\n        uint64 cumulativePriceDelta;\\n    }\\n\\n    struct PricePack {\\n        /// @notice The timestamp when updater uploads the price\\n        uint32 updateTimestamp;\\n        /// @notice Calculated maximum price\\n        uint64 maxPrice;\\n        /// @notice Calculated minimum price\\n        uint64 minPrice;\\n        /// @notice previous round id\\n        uint32 prevRound;\\n        /// @notice previous ChainLink price\\n        uint64 prevRefPrice;\\n        /// @notice cumulative value of the ChainLink price change ratio in a round\\n        uint64 cumulativeRefPriceDelta;\\n        /// @notice previous market price\\n        uint64 prevPrice;\\n        /// @notice cumulative value of the market price change ratio in a round\\n        uint64 cumulativePriceDelta;\\n    }\\n\\n    /// @notice Emitted when market price updated\\n    /// @param market Market address\\n    /// @param price The price passed in by updater\\n    /// @param maxPrice Calculated maximum price\\n    /// @param minPrice Calculated minimum price\\n    event PriceUpdated(IERC20 indexed market, uint64 price, uint64 minPrice, uint64 maxPrice);\\n\\n    /// @notice Emitted when maxCumulativeDeltaDiff exceeded\\n    /// @param market Market address\\n    /// @param price The price passed in by updater\\n    /// @param refPrice The price provided by ChainLink\\n    /// @param cumulativeDelta The cumulative value of the price change ratio\\n    /// @param cumulativeRefDelta The cumulative value of the ChainLink price change ratio\\n    event MaxCumulativeDeltaDiffExceeded(\\n        IERC20 indexed market,\\n        uint64 price,\\n        uint64 refPrice,\\n        uint64 cumulativeDelta,\\n        uint64 cumulativeRefDelta\\n    );\\n\\n    /// @notice Price not be initialized\\n    error NotInitialized();\\n\\n    /// @notice Reference price feed not set\\n    error ReferencePriceFeedNotSet();\\n\\n    /// @notice Invalid reference price\\n    /// @param referencePrice Reference price\\n    error InvalidReferencePrice(int256 referencePrice);\\n\\n    /// @notice Reference price timeout\\n    /// @param elapsed The time elapsed since the last price update.\\n    error ReferencePriceTimeout(uint256 elapsed);\\n\\n    /// @notice Invalid update timestamp\\n    /// @param timestamp Update timestamp\\n    error InvalidUpdateTimestamp(uint32 timestamp);\\n\\n    /// @notice Update market price feed config\\n    /// @param market Market address\\n    /// @param priceFeed ChainLink price feed\\n    /// @param refHeartBeatDuration Expected update interval of chain link price feed\\n    /// @param maxCumulativeDeltaDiff Maximum cumulative change ratio difference between prices and ChainLink price\\n    function updateMarketPriceFeedConfig(\\n        IERC20 market,\\n        IChainLinkAggregator priceFeed,\\n        uint32 refHeartBeatDuration,\\n        uint48 maxCumulativeDeltaDiff\\n    ) external;\\n\\n    /// @notice Get market price feed config\\n    /// @param market Market address\\n    /// @return config The price feed config\\n    function marketPriceFeedConfigs(IERC20 market) external view returns (PriceFeedConfig memory config);\\n\\n    /// @notice update global price feed config\\n    /// @param maxDeviationRatio Maximum deviation ratio between ChainLink price and market price\\n    /// @param cumulativeRoundDuration The duration of the round for the cumulative value of the price change ratio\\n    /// @param updateTxTimeout The maximum time allowed for the transaction to update the price\\n    /// @param ignoreReferencePriceFeedError Whether to ignore the error of the reference price feed not settled\\n    function updateGlobalPriceFeedConfig(\\n        uint24 maxDeviationRatio,\\n        uint32 cumulativeRoundDuration,\\n        uint32 updateTxTimeout,\\n        bool ignoreReferencePriceFeedError\\n    ) external;\\n\\n    /// @notice Get global price feed config\\n    /// @return maxDeviationRatio Maximum deviation ratio between ChainLink price and market price\\n    /// @return cumulativeRoundDuration The duration of the round for the cumulative value of the price change ratio\\n    /// @return updateTxTimeout The maximum time allowed for the transaction to update the price\\n    /// @return ignoreReferencePriceFeedError Whether to ignore the error of the reference price feed not settled\\n    function globalPriceFeedConfig()\\n        external\\n        view\\n        returns (\\n            uint24 maxDeviationRatio,\\n            uint32 cumulativeRoundDuration,\\n            uint32 updateTxTimeout,\\n            bool ignoreReferencePriceFeedError\\n        );\\n\\n    /// @notice Update updater\\n    /// @param account The account to set\\n    function updateUpdater(address account) external;\\n\\n    /// @notice Get market price\\n    /// @param market Market address\\n    /// @return minPrice Minimum price\\n    /// @return maxPrice Maximum price\\n    function getPrice(IERC20 market) external view returns (uint64 minPrice, uint64 maxPrice);\\n\\n    /// @notice Check if the account is updater\\n    /// @param account The account to check\\n    /// @return active True if the account is updater\\n    function isUpdater(address account) external view returns (bool active);\\n\\n    /// @notice Update market price\\n    /// @param packedValue The packed values of the order index and require success flag: bit 0-159 represent\\n    /// market address, bit 160-223 represent the price and bit 223-255 represent the update timestamp\\n    function updatePrice(PackedValue packedValue) external;\\n\\n    /// @notice Get market price data packed data\\n    /// @param market Market address\\n    /// @return pack The price packed data\\n    function marketPricePacks(IERC20 market) external view returns (PricePack memory pack);\\n}\\n\"\r\n    },\r\n    \"contracts/plugins/DirectExecutablePlugin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity =0.8.26;\\n\\nimport \\\"../IWETHMinimum.sol\\\";\\nimport \\\"../libraries/MarketUtil.sol\\\";\\nimport \\\"../core/interfaces/IPUSD.sol\\\";\\nimport \\\"../governance/GovernableProxy.sol\\\";\\nimport \\\"./interfaces/IDirectExecutablePlugin.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\ncontract DirectExecutablePlugin is IDirectExecutablePlugin, GovernableProxy {\\n    using MarketUtil for *;\\n\\n    IPUSD public immutable usd;\\n    IMarketManager public immutable marketManager;\\n    IWETHMinimum public immutable weth;\\n\\n    mapping(address => bool) public override psmMinters;\\n    mapping(address => bool) public override liquidityBufferDebtPayers;\\n    bool public override allowAnyoneRepayLiquidityBufferDebt;\\n    bool public override allowAnyoneUsePSM;\\n\\n    /// @notice Used to receive ETH withdrawal from the WETH contract\\n    receive() external payable {\\n        if (msg.sender != address(weth)) revert IMarketErrors.InvalidCaller(address(weth));\\n    }\\n\\n    constructor(\\n        Governable _govImpl,\\n        IPUSD _usd,\\n        IMarketManager _marketManager,\\n        IWETHMinimum _weth\\n    ) GovernableProxy(_govImpl) {\\n        (usd, marketManager, weth) = (_usd, _marketManager, _weth);\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function updateLiquidityBufferDebtPayer(address _account, bool _active) external override onlyGov {\\n        liquidityBufferDebtPayers[_account] = _active;\\n        emit LiquidityBufferDebtPayerUpdated(_account, _active);\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function updateAllowAnyoneRepayLiquidityBufferDebt(bool _allowed) external override onlyGov {\\n        allowAnyoneRepayLiquidityBufferDebt = _allowed;\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function updatePSMMinters(address _account, bool _active) external override onlyGov {\\n        psmMinters[_account] = _active;\\n        emit PSMMinterUpdated(_account, _active);\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function updateAllowAnyoneUsePSM(bool _allowed) external override onlyGov {\\n        allowAnyoneUsePSM = _allowed;\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function repayLiquidityBufferDebt(\\n        IERC20 _market,\\n        uint128 _amount,\\n        address _receiver,\\n        bytes calldata _permitData\\n    ) external override {\\n        require(liquidityBufferDebtPayers[msg.sender] || allowAnyoneRepayLiquidityBufferDebt, Forbidden());\\n\\n        IWETHMinimum weth_ = weth;\\n        IPUSD usd_ = usd;\\n        IMarketManager marketManager_ = marketManager;\\n        IMarketManager.LiquidityBufferModule memory lbm = marketManager_.liquidityBufferModules(_market);\\n\\n        uint256 balance = usd_.balanceOf(address(marketManager_));\\n        if (_amount > 0 && balance + _amount > lbm.pusdDebt) revert TooMuchRepaid(balance, _amount, lbm.pusdDebt);\\n        usd_.safePermit(address(marketManager_), _permitData);\\n        marketManager_.pluginTransfer(usd_, msg.sender, address(marketManager_), _amount);\\n\\n        if (address(weth_) == address(_market) && !MarketUtil.isDeployedContract(_receiver)) {\\n            uint128 receiveAmount = marketManager_.repayLiquidityBufferDebt(_market, msg.sender, address(this));\\n\\n            weth_.withdraw(receiveAmount);\\n            Address.sendValue(payable(_receiver), receiveAmount);\\n        } else {\\n            marketManager_.repayLiquidityBufferDebt(_market, msg.sender, _receiver);\\n        }\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function psmMintPUSD(\\n        IERC20 _collateral,\\n        uint120 _amount,\\n        address _receiver,\\n        bytes calldata _permitData\\n    ) external override returns (uint64 receiveAmount) {\\n        require(psmMinters[msg.sender] || allowAnyoneUsePSM, Forbidden());\\n\\n        IMarketManager marketManager_ = marketManager;\\n        IPSM.CollateralState memory state = marketManager_.psmCollateralStates(_collateral);\\n\\n        uint256 balance = _collateral.balanceOf(address(marketManager_));\\n        if (_amount > 0 && balance + _amount > state.cap) revert PSMCapExceeded(balance, _amount, state.cap);\\n\\n        _collateral.safePermit(address(marketManager_), _permitData);\\n        marketManager_.pluginTransfer(_collateral, msg.sender, address(marketManager_), _amount);\\n        receiveAmount = marketManager_.psmMintPUSD(_collateral, _receiver);\\n    }\\n\\n    /// @inheritdoc IDirectExecutablePlugin\\n    function psmBurnPUSD(\\n        IERC20 _collateral,\\n        uint64 _amount,\\n        address _receiver,\\n        bytes calldata _permitData\\n    ) external override returns (uint96 receiveAmount) {\\n        IMarketManager marketManager_ = marketManager;\\n        usd.safePermit(address(marketManager_), _permitData);\\n        marketManager_.pluginTransfer(usd, msg.sender, address(marketManager_), _amount);\\n        receiveAmount = marketManager_.psmBurnPUSD(_collateral, _receiver);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/plugins/interfaces/IDirectExecutablePlugin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDirectExecutablePlugin {\\n    /// @notice Emitted when liquidity buffer debt payer updated\\n    /// @param account Account to update\\n    /// @param active Whether active after the update\\n    event LiquidityBufferDebtPayerUpdated(address indexed account, bool active);\\n\\n    /// @notice Emitted when PSM minter updated\\n    /// @param account Account to update\\n    /// @param active Whether active after the update\\n    event PSMMinterUpdated(address indexed account, bool active);\\n\\n    /// @notice Error thrown when the cap is exceeded\\n    error PSMCapExceeded(uint256 balance, uint120 amount, uint120 cap);\\n\\n    /// @notice Error thrown when the excess debt is repaid\\n    error TooMuchRepaid(uint256 balance, uint128 amount, uint128 cap);\\n\\n    function liquidityBufferDebtPayers(address account) external view returns (bool);\\n\\n    function allowAnyoneRepayLiquidityBufferDebt() external view returns (bool);\\n\\n    function psmMinters(address account) external view returns (bool);\\n\\n    function allowAnyoneUsePSM() external view returns (bool);\\n\\n    /// @notice Update liquidity buffer debt payer\\n    /// @param account Account to update\\n    /// @param active Updated status\\n    function updateLiquidityBufferDebtPayer(address account, bool active) external;\\n\\n    /// @notice Update allow anyone repay liquidity buffer debt status\\n    /// @param allowed Updated status\\n    function updateAllowAnyoneRepayLiquidityBufferDebt(bool allowed) external;\\n\\n    /// @notice Update PSM minters\\n    /// @param account Account to update\\n    /// @param active Updated status\\n    function updatePSMMinters(address account, bool active) external;\\n\\n    /// @notice Update allow anyone use PSM\\n    /// @param allowed Updated status\\n    function updateAllowAnyoneUsePSM(bool allowed) external;\\n\\n    /// @notice Repay liquidity buffer debt\\n    /// @param market The target market contract address, such as the contract address of WETH\\n    /// @param amount The amount of PUSD to repay\\n    /// @param receiver Address to receive repaid token\\n    /// @param permitData The permit data for the PUSD token, optional\\n    function repayLiquidityBufferDebt(\\n        IERC20 market,\\n        uint128 amount,\\n        address receiver,\\n        bytes calldata permitData\\n    ) external;\\n\\n    /// @notice Mint PUSD through the PSM module\\n    /// @param collateral The collateral token\\n    /// @param amount The amount of collateral to mint\\n    /// @param receiver Address to receive PUSD\\n    /// @param permitData The permit data for the collateral token, optional\\n    /// @return receiveAmount The amount of PUSD minted\\n    function psmMintPUSD(\\n        IERC20 collateral,\\n        uint120 amount,\\n        address receiver,\\n        bytes memory permitData\\n    ) external returns (uint64 receiveAmount);\\n\\n    /// @notice Burn PUSD through the PSM module\\n    /// @param collateral The collateral token\\n    /// @param amount The amount of PUSD to burn\\n    /// @param receiver Address to receive collateral\\n    /// @param permitData The permit data for the PUSD token, optional\\n    /// @return receiveAmount The amount of collateral received\\n    function psmBurnPUSD(\\n        IERC20 collateral,\\n        uint64 amount,\\n        address receiver,\\n        bytes calldata permitData\\n    ) external returns (uint96 receiveAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/plugins/interfaces/IPluginManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Plugin Manager Interface\\n/// @notice The interface defines the functions to manage plugins\\ninterface IPluginManager {\\n    /// @notice Emitted when a plugin is updated\\n    /// @param plugin The plugin to update\\n    /// @param active Whether active after the update\\n    event PluginUpdated(address indexed plugin, bool active);\\n\\n    /// @notice Error thrown when the plugin is inactive\\n    error PluginInactive(address plugin);\\n\\n    /// @notice Update plugin\\n    /// @param plugin The plugin to update\\n    /// @param active Whether active after the update\\n    function updatePlugin(address plugin, bool active) external;\\n\\n    /// @notice Checks if a plugin is registered\\n    /// @param plugin The plugin to check\\n    /// @return True if the plugin is registered, false otherwise\\n    function activePlugins(address plugin) external view returns (bool);\\n\\n    /// @notice Transfers `amount` of `token` from `from` to `to`\\n    /// @param token The address of the ERC20 token\\n    /// @param from The address to transfer the tokens from\\n    /// @param to The address to transfer the tokens to\\n    /// @param amount The amount of tokens to transfer\\n    function pluginTransfer(IERC20 token, address from, address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/types/PackedValue.sol\": {\r\n      \"content\": \"// This file was procedurally generated from scripts/generate/PackedValue.template.js, DO NOT MODIFY MANUALLY\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ntype PackedValue is uint256;\\n\\nusing {\\n    packAddress,\\n    unpackAddress,\\n    packBool,\\n    unpackBool,\\n    packUint8,\\n    unpackUint8,\\n    packUint16,\\n    unpackUint16,\\n    packUint24,\\n    unpackUint24,\\n    packUint32,\\n    unpackUint32,\\n    packUint40,\\n    unpackUint40,\\n    packUint48,\\n    unpackUint48,\\n    packUint56,\\n    unpackUint56,\\n    packUint64,\\n    unpackUint64,\\n    packUint72,\\n    unpackUint72,\\n    packUint80,\\n    unpackUint80,\\n    packUint88,\\n    unpackUint88,\\n    packUint96,\\n    unpackUint96,\\n    packUint104,\\n    unpackUint104,\\n    packUint112,\\n    unpackUint112,\\n    packUint120,\\n    unpackUint120,\\n    packUint128,\\n    unpackUint128,\\n    packUint136,\\n    unpackUint136,\\n    packUint144,\\n    unpackUint144,\\n    packUint152,\\n    unpackUint152,\\n    packUint160,\\n    unpackUint160,\\n    packUint168,\\n    unpackUint168,\\n    packUint176,\\n    unpackUint176,\\n    packUint184,\\n    unpackUint184,\\n    packUint192,\\n    unpackUint192,\\n    packUint200,\\n    unpackUint200,\\n    packUint208,\\n    unpackUint208,\\n    packUint216,\\n    unpackUint216,\\n    packUint224,\\n    unpackUint224,\\n    packUint232,\\n    unpackUint232,\\n    packUint240,\\n    unpackUint240,\\n    packUint248,\\n    unpackUint248\\n} for PackedValue global;\\n\\nfunction packUint8(PackedValue self, uint8 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint8(PackedValue self, uint8 position) pure returns (uint8) {\\n    return uint8((PackedValue.unwrap(self) >> position) & 0xff);\\n}\\n\\nfunction packUint16(PackedValue self, uint16 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint16(PackedValue self, uint8 position) pure returns (uint16) {\\n    return uint16((PackedValue.unwrap(self) >> position) & 0xffff);\\n}\\n\\nfunction packUint24(PackedValue self, uint24 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint24(PackedValue self, uint8 position) pure returns (uint24) {\\n    return uint24((PackedValue.unwrap(self) >> position) & 0xffffff);\\n}\\n\\nfunction packUint32(PackedValue self, uint32 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint32(PackedValue self, uint8 position) pure returns (uint32) {\\n    return uint32((PackedValue.unwrap(self) >> position) & 0xffffffff);\\n}\\n\\nfunction packUint40(PackedValue self, uint40 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint40(PackedValue self, uint8 position) pure returns (uint40) {\\n    return uint40((PackedValue.unwrap(self) >> position) & 0xffffffffff);\\n}\\n\\nfunction packUint48(PackedValue self, uint48 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint48(PackedValue self, uint8 position) pure returns (uint48) {\\n    return uint48((PackedValue.unwrap(self) >> position) & 0xffffffffffff);\\n}\\n\\nfunction packUint56(PackedValue self, uint56 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint56(PackedValue self, uint8 position) pure returns (uint56) {\\n    return uint56((PackedValue.unwrap(self) >> position) & 0xffffffffffffff);\\n}\\n\\nfunction packUint64(PackedValue self, uint64 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint64(PackedValue self, uint8 position) pure returns (uint64) {\\n    return uint64((PackedValue.unwrap(self) >> position) & 0xffffffffffffffff);\\n}\\n\\nfunction packUint72(PackedValue self, uint72 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint72(PackedValue self, uint8 position) pure returns (uint72) {\\n    return uint72((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffff);\\n}\\n\\nfunction packUint80(PackedValue self, uint80 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint80(PackedValue self, uint8 position) pure returns (uint80) {\\n    return uint80((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffff);\\n}\\n\\nfunction packUint88(PackedValue self, uint88 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint88(PackedValue self, uint8 position) pure returns (uint88) {\\n    return uint88((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffff);\\n}\\n\\nfunction packUint96(PackedValue self, uint96 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint96(PackedValue self, uint8 position) pure returns (uint96) {\\n    return uint96((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffff);\\n}\\n\\nfunction packUint104(PackedValue self, uint104 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint104(PackedValue self, uint8 position) pure returns (uint104) {\\n    return uint104((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint112(PackedValue self, uint112 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint112(PackedValue self, uint8 position) pure returns (uint112) {\\n    return uint112((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint120(PackedValue self, uint120 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint120(PackedValue self, uint8 position) pure returns (uint120) {\\n    return uint120((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint128(PackedValue self, uint128 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint128(PackedValue self, uint8 position) pure returns (uint128) {\\n    return uint128((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint136(PackedValue self, uint136 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint136(PackedValue self, uint8 position) pure returns (uint136) {\\n    return uint136((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint144(PackedValue self, uint144 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint144(PackedValue self, uint8 position) pure returns (uint144) {\\n    return uint144((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint152(PackedValue self, uint152 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint152(PackedValue self, uint8 position) pure returns (uint152) {\\n    return uint152((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint160(PackedValue self, uint160 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint160(PackedValue self, uint8 position) pure returns (uint160) {\\n    return uint160((PackedValue.unwrap(self) >> position) & 0x00ffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint168(PackedValue self, uint168 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint168(PackedValue self, uint8 position) pure returns (uint168) {\\n    return uint168((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint176(PackedValue self, uint176 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint176(PackedValue self, uint8 position) pure returns (uint176) {\\n    return uint176((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint184(PackedValue self, uint184 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint184(PackedValue self, uint8 position) pure returns (uint184) {\\n    return uint184((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint192(PackedValue self, uint192 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint192(PackedValue self, uint8 position) pure returns (uint192) {\\n    return uint192((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint200(PackedValue self, uint200 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint200(PackedValue self, uint8 position) pure returns (uint200) {\\n    return uint200((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint208(PackedValue self, uint208 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint208(PackedValue self, uint8 position) pure returns (uint208) {\\n    return uint208((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint216(PackedValue self, uint216 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint216(PackedValue self, uint8 position) pure returns (uint216) {\\n    return uint216((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint224(PackedValue self, uint224 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint224(PackedValue self, uint8 position) pure returns (uint224) {\\n    return uint224((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint232(PackedValue self, uint232 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint232(PackedValue self, uint8 position) pure returns (uint232) {\\n    return\\n        uint232((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n}\\n\\nfunction packUint240(PackedValue self, uint240 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint240(PackedValue self, uint8 position) pure returns (uint240) {\\n    return\\n        uint240(\\n            (PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n        );\\n}\\n\\nfunction packUint248(PackedValue self, uint248 value, uint8 position) pure returns (PackedValue) {\\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\\n}\\n\\nfunction unpackUint248(PackedValue self, uint8 position) pure returns (uint248) {\\n    return\\n        uint248(\\n            (PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n        );\\n}\\n\\nfunction packBool(PackedValue self, bool value, uint8 position) pure returns (PackedValue) {\\n    return packUint8(self, value ? 1 : 0, position);\\n}\\n\\nfunction unpackBool(PackedValue self, uint8 position) pure returns (bool) {\\n    return ((PackedValue.unwrap(self) >> position) & 0x1) == 1;\\n}\\n\\nfunction packAddress(PackedValue self, address value, uint8 position) pure returns (PackedValue) {\\n    return packUint160(self, uint160(value), position);\\n}\\n\\nfunction unpackAddress(PackedValue self, uint8 position) pure returns (address) {\\n    return address(unpackUint160(self, position));\\n}\\n\"\r\n    },\r\n    \"contracts/types/Side.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nSide constant LONG = Side.wrap(1);\\nSide constant SHORT = Side.wrap(2);\\n\\ntype Side is uint8;\\n\\nerror InvalidSide(Side side);\\n\\nusing {requireValid, isLong, isShort, flip, eq as ==} for Side global;\\n\\nfunction requireValid(Side self) pure {\\n    if (!isLong(self) && !isShort(self)) revert InvalidSide(self);\\n}\\n\\nfunction isLong(Side self) pure returns (bool) {\\n    return Side.unwrap(self) == Side.unwrap(LONG);\\n}\\n\\nfunction isShort(Side self) pure returns (bool) {\\n    return Side.unwrap(self) == Side.unwrap(SHORT);\\n}\\n\\nfunction eq(Side self, Side other) pure returns (bool) {\\n    return Side.unwrap(self) == Side.unwrap(other);\\n}\\n\\nfunction flip(Side self) pure returns (Side) {\\n    return isLong(self) ? SHORT : LONG;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract Governable\",\"name\":\"_govImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPUSD\",\"name\":\"_usd\",\"type\":\"address\"},{\"internalType\":\"contract IMarketManager\",\"name\":\"_marketManager\",\"type\":\"address\"},{\"internalType\":\"contract IWETHMinimum\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Forbidden\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requiredCaller\",\"type\":\"address\"}],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint120\",\"name\":\"amount\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"cap\",\"type\":\"uint120\"}],\"name\":\"PSMCapExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"cap\",\"type\":\"uint128\"}],\"name\":\"TooMuchRepaid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"LiquidityBufferDebtPayerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"PSMMinterUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract Governable\",\"name\":\"_newGov\",\"type\":\"address\"}],\"name\":\"_changeImpl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowAnyoneRepayLiquidityBufferDebt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowAnyoneUsePSM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityBufferDebtPayers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketManager\",\"outputs\":[{\"internalType\":\"contract IMarketManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_amount\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_permitData\",\"type\":\"bytes\"}],\"name\":\"psmBurnPUSD\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"receiveAmount\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"uint120\",\"name\":\"_amount\",\"type\":\"uint120\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_permitData\",\"type\":\"bytes\"}],\"name\":\"psmMintPUSD\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"receiveAmount\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"psmMinters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_permitData\",\"type\":\"bytes\"}],\"name\":\"repayLiquidityBufferDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"updateAllowAnyoneRepayLiquidityBufferDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"updateAllowAnyoneUsePSM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"updateLiquidityBufferDebtPayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"updatePSMMinters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usd\",\"outputs\":[{\"internalType\":\"contract IPUSD\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETHMinimum\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DirectExecutablePlugin", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "100000000", "ConstructorArguments": "000000000000000000000000e80b9b1ff9416bccbf8c04761ff706482861b1ef0000000000000000000000007db40da34c2db863b0a76e110f99e037c7e36ef1000000000000000000000000bfeeedd4711d4b56f7a0fd26d8d9c39063f84ce6000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}