{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ERC721A/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/interfaces/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\"\r\n    },\r\n    \"lib/ERC721H/src/interfaces/IERC721ACH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\ninterface IERC721ACH {\\n    /**\\n     * @dev Enumerated list of all available hook types for the ERC721ACH contract.\\n     */\\n    enum HookType {\\n        /// @notice Hook for custom logic before a token transfer occurs.\\n        BeforeTokenTransfers,\\n        /// @notice Hook for custom logic after a token transfer occurs.\\n        AfterTokenTransfers,\\n        /// @notice Hook for custom logic for ownerOf() function.\\n        OwnerOf\\n    }\\n\\n    /**\\n     * @notice An event that gets emitted when a hook is updated.\\n     * @param setter The address that set the hook.\\n     * @param hookType The type of the hook that was set.\\n     * @param hookAddress The address of the contract that implements the hook.\\n     */\\n    event UpdatedHook(\\n        address indexed setter,\\n        HookType hookType,\\n        address indexed hookAddress\\n    );\\n\\n    /**\\n     * @notice Sets the contract address for a specified hook type.\\n     * @param hookType The type of hook to set, as defined in the HookType enum.\\n     * @param hookAddress The address of the contract implementing the hook interface.\\n     */\\n    function setHook(HookType hookType, address hookAddress) external;\\n\\n    /**\\n     * @notice Returns the contract address for a specified hook type.\\n     * @param hookType The type of hook to set, as defined in the HookType enum.\\n     * @return The address of the contract implementing the hook interface.\\n     */\\n    function getHook(HookType hookType) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICollectionHolderMint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n * @title ICollectionHolderMint\\n * @dev This interface represents the functions related to minting a collection of tokens.\\n */\\ninterface ICollectionHolderMint {\\n    // Events\\n    error AlreadyClaimedFreeMint(); // Fired when a free mint has already been claimed\\n    error NoTokensProvided(); // Fired when a mint function is called with no tokens provided\\n    error DuplicatesFound(); // Fired when a mint function is called with duplicate tokens\\n\\n    /**\\n     * @dev Returns whether a specific mint has been claimed\\n     * @param tokenId The ID of the token in question\\n     * @return A boolean indicating whether the mint has been claimed\\n     */\\n    function freeMintClaimed(uint256 tokenId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the address of the collection contract\\n     * @return The address of the collection contract\\n     */\\n    function cre8orsNFTContractAddress() external view returns (address);\\n\\n    /**\\n     * @dev Returns the address of the minter utility contract\\n     * @return The address of the minter utility contract\\n     */\\n    function minterUtilityContractAddress() external view returns (address);\\n\\n    /**\\n     * @dev Returns the maximum number of free mints claimed by an address\\n     * @return The maximum number of free mints claimed\\n     */\\n    function totalClaimed(address) external view returns (uint256);\\n\\n    /**\\n     * @dev Mints a batch of tokens and sends them to a recipient\\n     * @param tokenIds An array of token IDs to mint\\n     * @param recipient The address to send the minted tokens to\\n     * @return The last token ID minted in this batch\\n     */\\n    function mint(\\n        uint256[] calldata tokenIds,\\n        address recipient\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Changes the address of the minter utility contract\\n     * @param _newMinterUtilityContractAddress The new minter utility contract address\\n     */\\n    function setNewMinterUtilityContractAddress(\\n        address _newMinterUtilityContractAddress\\n    ) external;\\n\\n    /**\\n     * @dev Toggles the claim status of a free mint\\n     * @param tokenId The ID of the token whose claim status is being toggled\\n     */\\n    function toggleHasClaimedFreeMint(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICre8ing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {ILockup} from \\\"./ILockup.sol\\\";\\n\\ninterface ICre8ing {\\n    /// @notice Getter for Lockup interface\\n    function lockUp(address) external view returns (ILockup);\\n\\n    /// @dev Emitted when a CRE8OR begins cre8ing.\\n    event Cre8ed(address, uint256 indexed tokenId);\\n\\n    /// @dev Emitted when a CRE8OR stops cre8ing; either through standard means or\\n    ///     by expulsion.\\n    event Uncre8ed(address, uint256 indexed tokenId);\\n\\n    /// @dev Emitted when a CRE8OR is expelled from the Warehouse.\\n    event Expelled(address, uint256 indexed tokenId);\\n\\n    /// @notice Missing cre8ing status\\n    error CRE8ING_NotCre8ing(address, uint256 tokenId);\\n\\n    /// @notice Cre8ing Closed\\n    error Cre8ing_Cre8ingClosed();\\n\\n    /// @notice Cre8ing\\n    error Cre8ing_Cre8ing();\\n\\n    /// @notice Missing Lockup\\n    error Cre8ing_MissingLockup();\\n\\n    /// @notice Cre8ing period\\n    function cre8ingPeriod(\\n        address,\\n        uint256\\n    ) external view returns (bool cre8ing, uint256 current, uint256 total);\\n\\n    /// @notice open / close staking\\n    function setCre8ingOpen(address, bool) external;\\n\\n    /// @notice force removal from staking\\n    function expelFromWarehouse(address, uint256) external;\\n\\n    /// @notice function getCre8ingStarted(\\n    function getCre8ingStarted(\\n        address _target,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    /// @notice array of staked tokenIDs\\n    /// @dev used in cre8ors ui to quickly get list of staked NFTs.\\n    function cre8ingTokens(\\n        address _target\\n    ) external view returns (uint256[] memory stakedTokens);\\n\\n    /// @notice initialize both staking and lockups\\n    function inializeStakingAndLockup(\\n        address _target,\\n        uint256[] memory,\\n        bytes memory\\n    ) external;\\n\\n    /// @notice Set a new lockup for the target.\\n    /// @param _target The target address.\\n    /// @param newLockup The new lockup contract address.\\n    function setLockup(address _target, ILockup newLockup) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICre8ors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Drop} from \\\"./IERC721Drop.sol\\\";\\nimport {ILockup} from \\\"./ILockup.sol\\\";\\nimport {IERC721A} from \\\"erc721a/contracts/IERC721A.sol\\\";\\nimport {ICre8ing} from \\\"./ICre8ing.sol\\\";\\nimport {ISubscription} from \\\"../subscription/interfaces/ISubscription.sol\\\";\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                       \\n*/\\n/// @notice Interface for Cre8ors Drops contract\\ninterface ICre8ors is IERC721Drop, IERC721A {\\n    function cre8ing() external view returns (ICre8ing);\\n\\n    /// @notice Getter for last minted token ID (gets next token id and subtracts 1)\\n    function _lastMintedTokenId() external view returns (uint256);\\n\\n    /// @dev Returns `true` if `account` has been granted `role`.\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    function subscription() external view returns (address);\\n\\n    function setSubscription(address newSubscription) external;\\n\\n    function setCre8ing(ICre8ing _cre8ing) external;\\n\\n    function MINTER_ROLE() external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721Drop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IMetadataRenderer} from \\\"../interfaces/IMetadataRenderer.sol\\\";\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                       \\n*/\\n/// @notice Interface for Cre8ors Drop contract\\ninterface IERC721Drop {\\n    // Access errors\\n\\n    /// @notice Only admin can access this function\\n    error Access_OnlyAdmin();\\n    /// @notice Missing the given role or admin access\\n    error Access_MissingRoleOrAdmin(bytes32 role);\\n    /// @notice Withdraw is not allowed by this user\\n    error Access_WithdrawNotAllowed();\\n    /// @notice Cannot withdraw funds due to ETH send failure.\\n    error Withdraw_FundsSendFailure();\\n    /// @notice Missing the owner role.\\n    error Access_OnlyOwner();\\n    /// @notice Missing the owner role or approved nft access.\\n    error Access_MissingOwnerOrApproved();\\n\\n    // Sale/Purchase errors\\n    /// @notice Sale is inactive\\n    error Sale_Inactive();\\n    /// @notice Presale is inactive\\n    error Presale_Inactive();\\n    /// @notice Presale merkle root is invalid\\n    error Presale_MerkleNotApproved();\\n    /// @notice Wrong price for purchase\\n    error Purchase_WrongPrice(uint256 correctPrice);\\n    /// @notice NFT sold out\\n    error Mint_SoldOut();\\n    /// @notice Too many purchase for address\\n    error Purchase_TooManyForAddress();\\n    /// @notice Too many presale for address\\n    error Presale_TooManyForAddress();\\n\\n    // Admin errors\\n    /// @notice Royalty percentage too high\\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\\n    /// @notice Invalid admin upgrade address\\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\\n    error Admin_UnableToFinalizeNotOpenEdition();\\n\\n    /// @notice Event emitted for each sale\\n    /// @param to address sale was made to\\n    /// @param quantity quantity of the minted nfts\\n    /// @param pricePerToken price for each token\\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\\n    event Sale(\\n        address indexed to,\\n        uint256 indexed quantity,\\n        uint256 indexed pricePerToken,\\n        uint256 firstPurchasedTokenId\\n    );\\n\\n    /// @notice Sales configuration has been changed\\n    /// @dev To access new sales configuration, use getter function.\\n    /// @param changedBy Changed by user\\n    event SalesConfigChanged(address indexed changedBy);\\n\\n    /// @notice Event emitted when the funds recipient is changed\\n    /// @param newAddress new address for the funds recipient\\n    /// @param changedBy address that the recipient is changed by\\n    event FundsRecipientChanged(\\n        address indexed newAddress,\\n        address indexed changedBy\\n    );\\n\\n    /// @notice Event emitted when the funds are withdrawn from the minting contract\\n    /// @param withdrawnBy address that issued the withdraw\\n    /// @param withdrawnTo address that the funds were withdrawn to\\n    /// @param amount amount that was withdrawn\\n    event FundsWithdrawn(\\n        address indexed withdrawnBy,\\n        address indexed withdrawnTo,\\n        uint256 amount\\n    );\\n\\n    /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\\n    /// @param sender address sending close mint\\n    /// @param numberOfMints number of mints the contract is finalized at\\n    event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\\n\\n    /// @notice Event emitted when metadata renderer is updated.\\n    /// @param sender address of the updater\\n    /// @param renderer new metadata renderer address\\n    event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\\n\\n    /// @notice General configuration for NFT Minting and bookkeeping\\n    struct Configuration {\\n        /// @dev Metadata renderer (uint160)\\n        IMetadataRenderer metadataRenderer;\\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\\n        uint64 editionSize;\\n        /// @dev Royalty amount in bps (uint224+16 = 240)\\n        uint16 royaltyBPS;\\n        /// @dev Funds recipient for sale (new slot, uint160)\\n        address payable fundsRecipient;\\n    }\\n\\n    /// @notice Sales states and configuration\\n    /// @dev Uses 3 storage slots\\n    struct SalesConfiguration {\\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\\n        uint104 publicSalePrice;\\n        /// @dev ERC20 Token\\n        address erc20PaymentToken;\\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\\n        /// @dev Max purchase number per txn (90+32 = 122)\\n        uint32 maxSalePurchasePerAddress;\\n        /// @dev uint64 type allows for dates into 292 billion years\\n        /// @notice Public sale start timestamp (136+64 = 186)\\n        uint64 publicSaleStart;\\n        /// @notice Public sale end timestamp (186+64 = 250)\\n        uint64 publicSaleEnd;\\n        /// @notice Presale start timestamp\\n        /// @dev new storage slot\\n        uint64 presaleStart;\\n        /// @notice Presale end timestamp\\n        uint64 presaleEnd;\\n        /// @notice Presale merkle root\\n        bytes32 presaleMerkleRoot;\\n    }\\n\\n    /// @notice CRE8ORS - General configuration for Builder Rewards burn requirements\\n    struct BurnConfiguration {\\n        /// @dev Token to burn\\n        address burnToken;\\n        /// @dev Required number of tokens to burn\\n        uint256 burnQuantity;\\n    }\\n\\n    /// @notice Sales states and configuration\\n    /// @dev Uses 3 storage slots\\n    struct ERC20SalesConfiguration {\\n        /// @notice Public sale price\\n        /// @dev max ether value > 1000 ether with this value\\n        uint104 publicSalePrice;\\n        /// @dev ERC20 Token\\n        address erc20PaymentToken;\\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\\n        /// @dev Max purchase number per txn (90+32 = 122)\\n        uint32 maxSalePurchasePerAddress;\\n        /// @dev uint64 type allows for dates into 292 billion years\\n        /// @notice Public sale start timestamp (136+64 = 186)\\n        uint64 publicSaleStart;\\n        /// @notice Public sale end timestamp (186+64 = 250)\\n        uint64 publicSaleEnd;\\n        /// @notice Presale start timestamp\\n        /// @dev new storage slot\\n        uint64 presaleStart;\\n        /// @notice Presale end timestamp\\n        uint64 presaleEnd;\\n        /// @notice Presale merkle root\\n        bytes32 presaleMerkleRoot;\\n    }\\n\\n    /// @notice Return value for sales details to use with front-ends\\n    struct SaleDetails {\\n        // Synthesized status variables for sale and presale\\n        bool publicSaleActive;\\n        bool presaleActive;\\n        // Price for public sale\\n        uint256 publicSalePrice;\\n        // Timed sale actions for public sale\\n        uint64 publicSaleStart;\\n        uint64 publicSaleEnd;\\n        // Timed sale actions for presale\\n        uint64 presaleStart;\\n        uint64 presaleEnd;\\n        // Merkle root (includes address, quantity, and price data for each entry)\\n        bytes32 presaleMerkleRoot;\\n        // Limit public sale to a specific number of mints per wallet\\n        uint256 maxSalePurchasePerAddress;\\n        // Information about the rest of the supply\\n        // Total that have been minted\\n        uint256 totalMinted;\\n        // The total supply available\\n        uint256 maxSupply;\\n    }\\n\\n    /// @notice Return value for sales details to use with front-ends\\n    struct ERC20SaleDetails {\\n        /// @notice Synthesized status variables for sale\\n        bool publicSaleActive;\\n        /// @notice Synthesized status variables for presale\\n        bool presaleActive;\\n        /// @notice Price for public sale\\n        uint256 publicSalePrice;\\n        /// @notice ERC20 contract address for payment. address(0) for ETH.\\n        address erc20PaymentToken;\\n        /// @notice public sale start\\n        uint64 publicSaleStart;\\n        /// @notice public sale end\\n        uint64 publicSaleEnd;\\n        /// @notice Timed sale actions for presale start\\n        uint64 presaleStart;\\n        /// @notice Timed sale actions for presale end\\n        uint64 presaleEnd;\\n        /// @notice Merkle root (includes address, quantity, and price data for each entry)\\n        bytes32 presaleMerkleRoot;\\n        /// @notice Limit public sale to a specific number of mints per wallet\\n        uint256 maxSalePurchasePerAddress;\\n        /// @notice Total that have been minted\\n        uint256 totalMinted;\\n        /// @notice The total supply available\\n        uint256 maxSupply;\\n    }\\n\\n    /// @notice Return type of specific mint counts and details per address\\n    struct AddressMintDetails {\\n        /// Number of total mints from the given address\\n        uint256 totalMints;\\n        /// Number of presale mints from the given address\\n        uint256 presaleMints;\\n        /// Number of public mints from the given address\\n        uint256 publicMints;\\n    }\\n\\n    /// @notice External purchase function (payable in eth)\\n    /// @param quantity to purchase\\n    /// @return first minted token ID\\n    function purchase(uint256 quantity) external payable returns (uint256);\\n\\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\\n    /// @param quantity to purchase\\n    /// @param maxQuantity can purchase (verified by merkle root)\\n    /// @param pricePerToken price per token allowed (verified by merkle root)\\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\\n    /// @return first minted token ID\\n    function purchasePresale(\\n        uint256 quantity,\\n        uint256 maxQuantity,\\n        uint256 pricePerToken,\\n        bytes32[] memory merkleProof\\n    ) external payable returns (uint256);\\n\\n    /// @notice Function to return the global sales details for the given drop\\n    function saleDetails() external view returns (ERC20SaleDetails memory);\\n\\n    /// @notice Function to return the specific sales details for a given address\\n    /// @param minter address for minter to return mint information for\\n    function mintedPerAddress(\\n        address minter\\n    ) external view returns (AddressMintDetails memory);\\n\\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\\n    function owner() external view returns (address);\\n\\n    /// @notice Update the metadata renderer\\n    /// @param newRenderer new address for renderer\\n    /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\\n    function setMetadataRenderer(\\n        IMetadataRenderer newRenderer,\\n        bytes memory setupRenderer\\n    ) external;\\n\\n    /// @notice This is an admin mint function to mint a quantity to a specific address\\n    /// @param to address to mint to\\n    /// @param quantity quantity to mint\\n    /// @return the id of the first minted NFT\\n    function adminMint(address to, uint256 quantity) external returns (uint256);\\n\\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\\n    /// @param to list of addresses to mint an NFT each to\\n    /// @return the id of the first minted NFT\\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\\n\\n    /// @dev Getter for admin role associated with the contract to handle metadata\\n    /// @return boolean if address is admin\\n    function isAdmin(address user) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFriendsAndFamilyMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title FriendsAndFamilyMinter Interface\\n/// @notice This interface defines the functions and events for the FriendsAndFamilyMinter contract.\\ninterface IFriendsAndFamilyMinter {\\n    // Events\\n    error MissingDiscount();\\n    error ExistingDiscount();\\n\\n    // Functions\\n\\n    /// @dev Checks if the specified recipient has a discount.\\n    /// @param recipient The address of the recipient to check for the discount.\\n    /// @return A boolean indicating whether the recipient has a discount or not.\\n    function hasDiscount(address recipient) external view returns (bool);\\n\\n    /// @dev Retrieves the address of the Cre8orsNFT contract used by the FriendsAndFamilyMinter.\\n    /// @return The address of the Cre8orsNFT contract.\\n    function cre8orsNFT() external view returns (address);\\n\\n    /// @dev Retrieves the address of the MinterUtilities contract used by the FriendsAndFamilyMinter.\\n    /// @return The address of the MinterUtilities contract.\\n    function minterUtilityContractAddress() external view returns (address);\\n\\n    /// @dev Retrieves the maximum number of tokens claimed for free by the specified recipient.\\n    /// @param recipient The address of the recipient to query for the maximum claimed free tokens.\\n    /// @return The maximum number of tokens claimed for free by the recipient.\\n    function totalClaimed(address recipient) external view returns (uint256);\\n\\n    /// @dev Mints a new token for the specified recipient and returns the token ID.\\n    /// @param recipient The address of the recipient who will receive the minted token.\\n    /// @return The token ID of the minted token.\\n    function mint(address recipient) external returns (uint256);\\n\\n    /// @dev Grants a discount to the specified recipient, allowing them to mint tokens without paying the regular price.\\n    /// @param recipient The address of the recipient who will receive the discount.\\n    function addDiscount(address recipient) external;\\n\\n    /// @dev Grants a discount to the specified recipient, allowing them to mint tokens without paying the regular price.\\n    /// @param recipient The address of the recipients who will receive the discount.\\n    function addDiscount(address[] memory recipient) external;\\n\\n    /// @dev Removes the discount from the specified recipient, preventing them from minting tokens with a discount.\\n    /// @param recipient The address of the recipient whose discount will be removed.\\n    function removeDiscount(address recipient) external;\\n\\n    /// @dev Sets a new address for the MinterUtilities contract.\\n    /// @param _newMinterUtilityContractAddress The address of the new MinterUtilities contract.\\n    function setNewMinterUtilityContractAddress(\\n        address _newMinterUtilityContractAddress\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILockup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                     \\n */\\ninterface ILockup {\\n    /// @notice Storage for token edition information\\n    struct TokenLockupInfo {\\n        uint64 unlockDate;\\n        uint256 priceToUnlock;\\n    }\\n\\n    /// @notice Locked\\n    error Lockup_Locked();\\n\\n    /// @notice Wrong price for unlock\\n    error Unlock_WrongPrice(uint256 correctPrice);\\n\\n    /// @notice Event for updated Lockup\\n    event TokenLockupUpdated(\\n        address indexed target,\\n        uint256 tokenId,\\n        uint64 unlockDate,\\n        uint256 priceToUnlock\\n    );\\n\\n    /// @notice retrieves locked state for token\\n    function isLocked(address, uint256) external view returns (bool);\\n\\n    /// @notice retieves unlock date for token\\n    function unlockInfo(\\n        address,\\n        uint256\\n    ) external view returns (TokenLockupInfo memory);\\n\\n    /// @notice sets unlock tier for token\\n    function setUnlockInfo(address, uint256, bytes memory) external;\\n\\n    /// @notice pay to unlock a locked token\\n    function payToUnlock(address payable, uint256) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                     \\n */\\n\\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\\ninterface IMetadataRenderer {\\n    function tokenURI(uint256) external view returns (string memory);\\n\\n    function contractURI() external view returns (string memory);\\n\\n    function initializeWithData(bytes memory initData) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinterUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n * @title Minter Utilities Interface\\n * @notice Interface for the MinterUtilities contract, which provides utility functions for the minter.\\n */\\ninterface IMinterUtilities {\\n    /**\\n     * @dev Emitted when the price of a tier is updated.\\n     * @param tier The tier whose price is updated.\\n     * @param price The new price for the tier.\\n     */\\n    event TierPriceUpdated(uint256 tier, uint256 price);\\n\\n    /**\\n     * @dev Emitted when the lockup period of a tier is updated.\\n     * @param tier The tier whose lockup period is updated.\\n     * @param lockup The new lockup period for the tier.\\n     */\\n    event TierLockupUpdated(uint256 tier, uint256 lockup);\\n\\n    /**\\n     * @dev Represents pricing and lockup information for a specific tier.\\n     */\\n    struct TierInfo {\\n        uint256 price;\\n        uint256 lockup;\\n    }\\n\\n    /**\\n     * @dev Represents a tier and quantity of NFTs.\\n     */\\n    struct Cart {\\n        uint8 tier;\\n        uint256 quantity;\\n    }\\n\\n    /**\\n     * @notice Calculates the total price for a given quantity of NFTs in a specific tier.\\n     * @param tier The tier to calculate the price for.\\n     * @param quantity The quantity of NFTs to calculate the price for.\\n     * @return The total price in wei for the given quantity in the specified tier.\\n     */\\n    function calculatePrice(\\n        uint8 tier,\\n        uint256 quantity\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the quantity of NFTs left that can be minted by the given recipient.\\n     * @param passportHolderMinter The address of the PassportHolderMinter contract.\\n     * @param friendsAndFamilyMinter The address of the FriendsAndFamilyMinter contract.\\n     * @param target The address of the target contract (ICre8ors contract).\\n     * @param recipient The recipient's address.\\n     * @return The quantity of NFTs that can still be minted by the recipient.\\n     */\\n    function quantityLeft(\\n        address passportHolderMinter,\\n        address friendsAndFamilyMinter,\\n        address target,\\n        address recipient\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Calculates the total cost for a given list of NFTs in different tiers.\\n     * @param carts An array of Cart struct representing the tiers and quantities.\\n     * @return The total cost in wei for the given list of NFTs.\\n     */\\n    function calculateTotalCost(\\n        uint256[] memory carts\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Calculates the unlock price for a given tier and minting option.\\n     * @param tier The tier for which to calculate the unlock price.\\n     * @param freeMint A boolean flag indicating whether the minting option is free or not.\\n     * @return The calculated unlock price in wei.\\n     */\\n    function calculateUnlockPrice(\\n        uint8 tier,\\n        bool freeMint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Calculates the lockup period for a specific tier.\\n     * @param tier The tier to calculate the lockup period for.\\n     * @return The lockup period in seconds for the specified tier.\\n     */\\n    function calculateLockupDate(uint8 tier) external view returns (uint256);\\n\\n    /**\\n     * @notice Calculates the total quantity of NFTs in a given list of Cart structs.\\n     * @param carts An array of Cart struct representing the tiers and quantities.\\n     * @return Total quantity of NFTs in the given list of carts.\\n     */\\n\\n    function calculateTotalQuantity(\\n        uint256[] memory carts\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Updates the prices for all tiers in the MinterUtilities contract.\\n     * @param tierPrices A bytes array representing the new prices for all tiers (in wei).\\n     */\\n    function updateAllTierPrices(bytes calldata tierPrices) external;\\n\\n    /**\\n     * @notice Sets new default lockup periods for all tiers.\\n     * @param lockupInfo A bytes array representing the new lockup periods for all tiers (in seconds).\\n     */\\n    function setNewDefaultLockups(bytes calldata lockupInfo) external;\\n\\n    /**\\n     * @notice Retrieves tier information for a specific tier ID.\\n     * @param tierId The ID of the tier to get information for.\\n     * @return TierInfo tier information struct containing lockup duration and unlock price in wei.\\n     */\\n    function getTierInfo(uint8 tierId) external view returns (TierInfo memory);\\n\\n    /**\\n     * @notice Retrieves all tier information.\\n     * @return bytes data of tier information struct containing lockup duration and unlock price in wei.\\n     */\\n    function getTierInfo() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISharedPaidMinterFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\nimport {IMinterUtilities} from \\\"../interfaces/IMinterUtilities.sol\\\";\\n\\ninterface ISharedPaidMinterFunctions {\\n    error InvalidTier();\\n\\n    error InvalidArrayLength();\\n}\\n\"\r\n    },\r\n    \"src/minter/FriendsAndFamilyMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IERC721A} from \\\"lib/ERC721A/contracts/interfaces/IERC721A.sol\\\";\\nimport {ICre8ors} from \\\"../interfaces/ICre8ors.sol\\\";\\nimport {IERC721Drop} from \\\"../interfaces/IERC721Drop.sol\\\";\\nimport {ILockup} from \\\"../interfaces/ILockup.sol\\\";\\nimport {IMinterUtilities} from \\\"../interfaces/IMinterUtilities.sol\\\";\\nimport {IFriendsAndFamilyMinter} from \\\"../interfaces/IFriendsAndFamilyMinter.sol\\\";\\nimport {IERC721ACH} from \\\"ERC721H/interfaces/IERC721ACH.sol\\\";\\n\\ncontract FriendsAndFamilyMinter is IFriendsAndFamilyMinter {\\n    ///@notice Mapping to track whether an address has discount for free mint.\\n    mapping(address => bool) public hasDiscount;\\n\\n    ///@notice The address of the collection contract that mints and manages the tokens.\\n    address public cre8orsNFT;\\n    ///@notice The address of the minter utility contract that contains shared utility info.\\n    address public minterUtilityContractAddress;\\n\\n    ///@notice mapping of address to quantity of free mints claimed.\\n    mapping(address => uint256) public totalClaimed;\\n\\n    constructor(address _cre8orsNFT, address _minterUtilityContractAddress) {\\n        cre8orsNFT = _cre8orsNFT;\\n        minterUtilityContractAddress = _minterUtilityContractAddress;\\n    }\\n\\n    /// @dev Mints a new token for the specified recipient and performs additional actions, such as setting the lockup (if applicable).\\n    /// @param recipient The address of the recipient who will receive the minted token.\\n    /// @return The token ID of the minted token.\\n    function mint(\\n        address recipient\\n    ) external onlyExistingDiscount(recipient) returns (uint256) {\\n        // Mint the token\\n        uint256 pfpTokenId = ICre8ors(cre8orsNFT).adminMint(recipient, 1);\\n        totalClaimed[recipient] += 1;\\n\\n        // Reset discount for the recipient\\n        hasDiscount[recipient] = false;\\n\\n        // Set lockup information (optional)\\n        IMinterUtilities minterUtility = IMinterUtilities(\\n            minterUtilityContractAddress\\n        );\\n        uint256 lockupDate = block.timestamp + 8 weeks;\\n        uint256 unlockPrice = minterUtility.getTierInfo(3).price;\\n        bytes memory data = abi.encode(lockupDate, unlockPrice);\\n        uint256[] memory tokenIDs = new uint256[](1);\\n        tokenIDs[0] = pfpTokenId;\\n        ICre8ors(\\n            IERC721ACH(cre8orsNFT).getHook(\\n                IERC721ACH.HookType.BeforeTokenTransfers\\n            )\\n        ).cre8ing().inializeStakingAndLockup(cre8orsNFT, tokenIDs, data);\\n\\n        // Return the token ID of the minted token\\n        return pfpTokenId;\\n    }\\n\\n    /// @dev Grants a discount to the specified recipient, allowing them to mint tokens without paying the regular price.\\n    /// @param recipient The address of the recipient who will receive the discount.\\n    function addDiscount(address recipient) external onlyAdmin {\\n        if (hasDiscount[recipient]) {\\n            revert ExistingDiscount();\\n        }\\n        hasDiscount[recipient] = true;\\n    }\\n\\n    /// @dev Grants a discount to the specified array of recipients, allowing them to mint tokens without paying the regular price.\\n    /// @param recipient The address of the recipients who will receive the discount.\\n    function addDiscount(address[] memory recipient) external onlyAdmin {\\n        for (uint256 i = 0; i < recipient.length; ) {\\n            if (!hasDiscount[recipient[i]]) {\\n                hasDiscount[recipient[i]] = true;\\n            }\\n            unchecked {\\n                i += 1;\\n            }\\n        }\\n    }\\n\\n    /// @dev Removes the discount from the specified recipient, preventing them from minting tokens with a discount.\\n    /// @param recipient The address of the recipient whose discount will be removed.\\n    function removeDiscount(\\n        address recipient\\n    ) external onlyAdmin onlyExistingDiscount(recipient) {\\n        hasDiscount[recipient] = false;\\n    }\\n\\n    /// @dev Sets a new address for the MinterUtilities contract.\\n    /// @param _newMinterUtilityContractAddress The address of the new MinterUtilities contract.\\n    function setNewMinterUtilityContractAddress(\\n        address _newMinterUtilityContractAddress\\n    ) external onlyAdmin {\\n        minterUtilityContractAddress = _newMinterUtilityContractAddress;\\n    }\\n\\n    /// @dev Modifier that restricts access to only the contract's admin.\\n    modifier onlyAdmin() {\\n        if (!ICre8ors(cre8orsNFT).isAdmin(msg.sender)) {\\n            revert IERC721Drop.Access_OnlyAdmin();\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks if the specified recipient has a discount.\\n    /// @param recipient The address of the recipient to check for the discount.\\n    modifier onlyExistingDiscount(address recipient) {\\n        if (!hasDiscount[recipient]) {\\n            revert MissingDiscount();\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/minter/PublicMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {MinterUtilities} from \\\"../utils/MinterUtilities.sol\\\";\\nimport {ICre8ors} from \\\"../interfaces/ICre8ors.sol\\\";\\nimport {ILockup} from \\\"../interfaces/ILockup.sol\\\";\\nimport {IERC721A} from \\\"lib/ERC721A/contracts/interfaces/IERC721A.sol\\\";\\nimport {IERC721Drop} from \\\"../interfaces/IERC721Drop.sol\\\";\\nimport {IMinterUtilities} from \\\"../interfaces/IMinterUtilities.sol\\\";\\nimport {SharedPaidMinterFunctions} from \\\"../utils/SharedPaidMinterFunctions.sol\\\";\\nimport {ICollectionHolderMint} from \\\"../interfaces/ICollectionHolderMint.sol\\\";\\nimport {IFriendsAndFamilyMinter} from \\\"../interfaces/IFriendsAndFamilyMinter.sol\\\";\\n\\ncontract PublicMinter is SharedPaidMinterFunctions {\\n    constructor(\\n        address _cre8orsNFT,\\n        address _minterUtility,\\n        address _collectionHolderMint,\\n        address _friendsAndFamilyMinter\\n    ) {\\n        cre8orsNFT = _cre8orsNFT;\\n        minterUtility = _minterUtility;\\n        collectionHolderMint = _collectionHolderMint;\\n        friendsAndFamilyMinter = _friendsAndFamilyMinter;\\n    }\\n\\n    function mintPfp(\\n        address recipient,\\n        uint256[] memory carts\\n    )\\n        external\\n        payable\\n        verifyCost(carts)\\n        onlyPublicSaleOrAlreadyMinted(recipient)\\n        returns (uint256)\\n    {\\n        uint256 quantity = calculateTotalQuantity(carts);\\n\\n        if (\\n            quantity >\\n            IMinterUtilities(minterUtility).quantityLeft(\\n                collectionHolderMint,\\n                friendsAndFamilyMinter,\\n                cre8orsNFT,\\n                recipient\\n            )\\n        ) {\\n            revert IERC721Drop.Purchase_TooManyForAddress();\\n        }\\n\\n        uint256 pfpTokenId = ICre8ors(cre8orsNFT).adminMint(\\n            recipient,\\n            quantity\\n        );\\n        payable(address(cre8orsNFT)).call{value: msg.value}(\\\"\\\");\\n        _lockUp(carts, pfpTokenId - quantity + 1);\\n        return pfpTokenId;\\n    }\\n\\n    /// @dev Sets a new address for the MinterUtilities contract.\\n    /// @param _newMinterUtilityContractAddress The address of the new MinterUtilities contract.\\n    function setNewMinterUtilityContractAddress(\\n        address _newMinterUtilityContractAddress\\n    ) external onlyAdmin {\\n        minterUtility = _newMinterUtilityContractAddress;\\n    }\\n\\n    modifier onlyPublicSaleOrAlreadyMinted(address recipient) {\\n        /**  @dev This is the only change from AllowlistMinter\\n         * This is so that anyone with a\\n         *                 pfp can mint from the public sale\\n         *                 which before public sale being active\\n         *                 should be only discount/passport holders\\n         */\\n        if (\\n            !ICre8ors(cre8orsNFT).saleDetails().publicSaleActive &&\\n            ICre8ors(cre8orsNFT).mintedPerAddress(recipient).totalMints == 0\\n        ) {\\n            revert IERC721Drop.Sale_Inactive();\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/subscription/interfaces/ISubscription.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title ISubscription\\n/// @dev Interface for managing subscriptions to NFTs.\\ninterface ISubscription {\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The subscription associated with the provided token ID is invalid or has expired.\\n    error InvalidSubscription();\\n\\n    /// @notice Attempting to set a subscription contract address with a zero address value.\\n    error SubscriptionCannotBeZeroAddress();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Emitted when the renewability status of subscriptions is updated.\\n    event RenewableUpdate(bool renewable);\\n\\n    /// @dev Emitted when the minimum duration for subscription renewal is updated.\\n    event MinRenewalDurationUpdate(uint64 duration);\\n\\n    /// @dev Emitted when the maximum duration for subscription renewal is updated.\\n    event MaxRenewalDurationUpdate(uint64 duration);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Checks the subscription for the given `tokenId`.\\n    /// Throws if `tokenId` subscription has expired.\\n    /// @param tokenId The unique identifier of the NFT token.\\n    function checkSubscription(uint256 tokenId) external view;\\n\\n    /// @notice Returns whether the subscription for the given `tokenId` is valid.\\n    /// @param tokenId The unique identifier of the NFT token.\\n    /// @return A boolean indicating if the subscription is valid.\\n    function isSubscriptionValid(uint256 tokenId) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /*//////////   updateSubscriptionForFree variants   //////////*/\\n\\n    /// @notice Extends the subscription for the given `tokenId` with a specified `duration` for free.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenId The unique identifier of the NFT token to be subscribed.\\n    function updateSubscriptionForFree(address target, uint64 duration, uint256 tokenId) external;\\n\\n    /// @notice Extends the subscription for the given `tokenIds` with a specified `duration` for free.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenIds An array of unique identifiers of the NFT tokens to update the subscriptions for.\\n    function updateSubscriptionForFree(address target, uint64 duration, uint256[] calldata tokenIds) external;\\n\\n    /*//////////////   updateSubscription variants   /////////////*/\\n\\n    /// @notice Extends the subscription for the given `tokenId` with a specified `duration`, using native currency as\\n    /// payment.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenId The unique identifier of the NFT token to be subscribed.\\n    function updateSubscription(address target, uint64 duration, uint256 tokenId) external payable;\\n\\n    /// @notice Extends the subscription for the given `tokenIds` with a specified `duration`, using native currency as\\n    /// payment.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenIds An array of unique identifiers of the NFT tokens to update the subscriptions for.\\n    function updateSubscription(address target, uint64 duration, uint256[] calldata tokenIds) external payable;\\n}\\n\"\r\n    },\r\n    \"src/utils/MinterUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\nimport {IERC721A} from \\\"lib/ERC721A/contracts/interfaces/IERC721A.sol\\\";\\nimport {ICre8ors} from \\\"../interfaces/ICre8ors.sol\\\";\\nimport {IERC721Drop} from \\\"../interfaces/IERC721Drop.sol\\\";\\nimport {ICollectionHolderMint} from \\\"../interfaces/ICollectionHolderMint.sol\\\";\\nimport {FriendsAndFamilyMinter} from \\\"../minter/FriendsAndFamilyMinter.sol\\\";\\nimport {IMinterUtilities} from \\\"../interfaces/IMinterUtilities.sol\\\";\\n\\ncontract MinterUtilities is IMinterUtilities {\\n    /// @dev The maximum quantity allowed for each address in the whitelist.\\n    uint256 public maxAllowlistQuantity = 8;\\n\\n    /// @dev The maximum quantity allowed for public minting.\\n    uint256 public maxPublicMintQuantity = 18;\\n\\n    /// @dev The address of the collection contract.\\n    address public cre8orsNFT;\\n\\n    /// @dev Mapping to store tier information for each tier represented by an integer key.\\n    /// @notice Tier information includes price and lockup details.\\n    mapping(uint8 => TierInfo) public tierInfo;\\n\\n    constructor(\\n        address _cre8orsNFT,\\n        uint256 _tier1Price,\\n        uint256 _tier2Price,\\n        uint256 _tier3Price\\n    ) {\\n        cre8orsNFT = _cre8orsNFT;\\n        tierInfo[1] = TierInfo(_tier1Price, 32 weeks);\\n        tierInfo[2] = TierInfo(_tier2Price, 8 weeks);\\n        tierInfo[3] = TierInfo(_tier3Price, 0 weeks);\\n    }\\n\\n    /// @dev Calculates the total price based on the tier and quantity of items to be purchased.\\n    /// @param tier The tier of the item.\\n    /// @param quantity The quantity of the items to be purchased.\\n    /// @return The total price for the specified tier and quantity.\\n    function calculatePrice(\\n        uint8 tier,\\n        uint256 quantity\\n    ) public view returns (uint256) {\\n        uint256 tierPrice = tier > 0 && tier < 4\\n            ? tierInfo[tier].price\\n            : tierInfo[3].price;\\n        uint256 price = tierPrice * quantity;\\n        return price;\\n    }\\n\\n    /// @dev Retrieves the quantity of items remaining that can be minted by the specified recipient.\\n    /// @param passportHolderMinter The address of the passport holder minter contract.\\n    /// @param friendsAndFamilyMinter The address of the friends and family minter contract.\\n    /// @param target The address of the ICre8ors contract.\\n    /// @param recipient The recipient address for which the quantity is to be calculated.\\n    /// @return The quantity of items that can be minted by the specified recipient.\\n    function quantityLeft(\\n        address passportHolderMinter,\\n        address friendsAndFamilyMinter,\\n        address target,\\n        address recipient\\n    ) external view returns (uint256) {\\n        ICre8ors cre8ors = ICre8ors(target);\\n        ICollectionHolderMint passportMinter = ICollectionHolderMint(\\n            passportHolderMinter\\n        );\\n        FriendsAndFamilyMinter friendsAndFamily = FriendsAndFamilyMinter(\\n            friendsAndFamilyMinter\\n        );\\n\\n        uint256 totalMints = cre8ors.mintedPerAddress(recipient).totalMints;\\n        uint256 totalClaimed = passportMinter.totalClaimed(recipient) +\\n            friendsAndFamily.totalClaimed(recipient);\\n        uint256 maxQuantity = maxAllowedQuantity(totalClaimed);\\n\\n        if (maxQuantity < totalMints) {\\n            return 0;\\n        }\\n        return maxQuantity - totalMints;\\n    }\\n\\n    /// @dev Calculates the total cost of all items in the given carts array.\\n    /// @param carts An array of Cart structs containing information about each item in the cart.\\n    /// @return The total cost of all items in the carts array.\\n    function calculateTotalCost(\\n        uint256[] memory carts\\n    ) external view returns (uint256) {\\n        uint256 totalCost = 0;\\n        for (uint256 i = 0; i < carts.length; i++) {\\n            totalCost += calculatePrice(uint8(i + 1), carts[i]);\\n        }\\n        return totalCost;\\n    }\\n\\n    /// @dev Calculates the lockup date for a given tier.\\n    /// @param tier The tier for which the lockup date is being calculated.\\n    /// @return The lockup date for the specified tier, expressed as a Unix timestamp.\\n    function calculateLockupDate(uint8 tier) external view returns (uint256) {\\n        return block.timestamp + tierInfo[tier].lockup;\\n    }\\n\\n    /// @dev Calculates the total quantity of items across all carts.\\n    /// @param carts An array of Cart structs containing information about each item in the cart.\\n    /// @return uint256 total quantity of items across all carts.\\n    function calculateTotalQuantity(\\n        uint256[] memory carts\\n    ) public pure returns (uint256) {\\n        uint256 totalQuantity = 0;\\n        for (uint256 i = 0; i < carts.length; i++) {\\n            totalQuantity += carts[i];\\n        }\\n        return totalQuantity;\\n    }\\n\\n    /**\\n     * @dev Calculates the unlock price for a given tier and minting option.\\n     * @param tier The tier for which to calculate the unlock price.\\n     * @param freeMint A boolean flag indicating whether the minting option is free or not.\\n     * @return The calculated unlock price in wei.\\n     */\\n    function calculateUnlockPrice(\\n        uint8 tier,\\n        bool freeMint\\n    ) external view returns (uint256) {\\n        if (freeMint) {\\n            return tierInfo[3].price - tierInfo[1].price;\\n        } else {\\n            return tierInfo[3].price - tierInfo[tier].price;\\n        }\\n    }\\n\\n    /// @dev Updates the prices for all tiers.\\n    /// @param tierPrices A bytes array containing the new prices for tier 1, tier 2, and tier 3.\\n    ///                  The bytes array should be encoded using the `abi.encode` function with three uint256 values\\n    ///                  corresponding to the prices of tier 1, tier 2, and tier 3, respectively.\\n    /// @notice This function can only be called by the contract's admin.\\n    function updateAllTierPrices(bytes calldata tierPrices) external onlyAdmin {\\n        (uint256 tier1, uint256 tier2, uint256 tier3) = abi.decode(\\n            tierPrices,\\n            (uint256, uint256, uint256)\\n        );\\n        tierInfo[1].price = tier1;\\n        tierInfo[2].price = tier2;\\n        tierInfo[3].price = tier3;\\n    }\\n\\n    /// @dev Sets new default lockup periods for all tiers.\\n    /// @param lockupInfo A bytes array containing the new lockup periods for tier 1, tier 2, and tier 3.\\n    ///                   The bytes array should be encoded using the `abi.encode` function with three uint256 values\\n    ///                   corresponding to the lockup periods of tier 1, tier 2, and tier 3, respectively.\\n    /// @notice This function can only be called by the contract's admin.\\n    function setNewDefaultLockups(\\n        bytes calldata lockupInfo\\n    ) external onlyAdmin {\\n        (uint256 tier1, uint256 tier2, uint256 tier3) = abi.decode(\\n            lockupInfo,\\n            (uint256, uint256, uint256)\\n        );\\n        tierInfo[1].lockup = tier1;\\n        tierInfo[2].lockup = tier2;\\n        tierInfo[3].lockup = tier3;\\n    }\\n\\n    /// @dev Retrieves tier information for a given tier.\\n    /// @param tier The tier for which the information is being retrieved.\\n    /// @return TierInfo struct containing price and lockup information for the specified tier.\\n    function getTierInfo(uint8 tier) external view returns (TierInfo memory) {\\n        return tierInfo[tier];\\n    }\\n\\n    /// @dev Retrieves tier information for all tiers.\\n    /// @return A bytes array containing the tier information for all tiers.\\n    function getTierInfo() external view returns (bytes memory) {\\n        TierInfo[] memory tierInfoArray = new TierInfo[](3);\\n        tierInfoArray[0] = tierInfo[1];\\n        tierInfoArray[1] = tierInfo[2];\\n        tierInfoArray[2] = tierInfo[3];\\n        return abi.encode(tierInfoArray);\\n    }\\n\\n    /// @dev allows user to convert tier prices or tier unlock periods to bytes for using in update functions.\\n    /// @param tierOne The price(in wei) or lockup period (in seconds) for tier 1.\\n    /// @param tierTwo The price(in wei) or lockup period (in seconds) for tier 2.\\n    /// @param tierThree The price(in wei) or lockup period (in seconds) for tier 3.\\n    function convertTierInfoToBytes(\\n        uint256 tierOne,\\n        uint256 tierTwo,\\n        uint256 tierThree\\n    ) external pure returns (bytes memory) {\\n        return abi.encode(tierOne, tierTwo, tierThree);\\n    }\\n\\n    /// @dev Updates the maximum allowed quantity for the whitelist.\\n    /// @param _maxAllowlistQuantity The new maximum allowed quantity for the whitelist.\\n    /// @notice This function can only be called by the contract's admin.\\n    function updateMaxAllowlistQuantity(\\n        uint256 _maxAllowlistQuantity\\n    ) external onlyAdmin {\\n        maxAllowlistQuantity = _maxAllowlistQuantity;\\n    }\\n\\n    /// @dev Updates the maximum allowed quantity for the public mint.\\n    /// @param _maxPublicMintQuantity The new maximum allowed quantity for the public mint.\\n    /// @notice This function can only be called by the contract's admin.\\n    function updateMaxPublicMintQuantity(\\n        uint256 _maxPublicMintQuantity\\n    ) external onlyAdmin {\\n        maxPublicMintQuantity = _maxPublicMintQuantity;\\n    }\\n\\n    //////////////////////////\\n    // MODIFIERS //\\n    //////////////////////////\\n    /// @dev Modifier that restricts access to only the contract's admin.\\n    modifier onlyAdmin() {\\n        require(\\n            ICre8ors(cre8orsNFT).isAdmin(msg.sender),\\n            \\\"IERC721Drop: Access restricted to admin\\\"\\n        );\\n        _;\\n    }\\n\\n    //////////////////////////\\n    // INTERNAL FUNCTIONS ////\\n    //////////////////////////\\n\\n    /// @dev Calculates the maximum allowed quantity based on the current timestamp and the public sale start time.\\n    /// @param totalClaimedFree The base starting point for calculating the maximum allowed quantity.\\n    /// @return The maximum allowed quantity based on the current timestamp and the public sale start time.\\n    function maxAllowedQuantity(\\n        uint256 totalClaimedFree\\n    ) internal view returns (uint256) {\\n        uint256 currentTimestamp = block.timestamp;\\n        uint256 publicSaleStart = ICre8ors(cre8orsNFT)\\n            .saleDetails()\\n            .publicSaleStart;\\n        if (currentTimestamp < publicSaleStart) {\\n            return maxAllowlistQuantity + totalClaimedFree;\\n        }\\n        if (totalClaimedFree > 0) {\\n            return\\n                maxAllowlistQuantity + maxPublicMintQuantity + totalClaimedFree;\\n        }\\n        return maxPublicMintQuantity + totalClaimedFree;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/SharedPaidMinterFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\nimport {IMinterUtilities} from \\\"../interfaces/IMinterUtilities.sol\\\";\\nimport {ILockup} from \\\"../interfaces/ILockup.sol\\\";\\nimport {ICre8ors} from \\\"../interfaces/ICre8ors.sol\\\";\\nimport {IERC721Drop} from \\\"../interfaces/IERC721Drop.sol\\\";\\nimport {ICre8ing} from \\\"../interfaces/ICre8ing.sol\\\";\\nimport {ISharedPaidMinterFunctions} from \\\"../interfaces/ISharedPaidMinterFunctions.sol\\\";\\nimport {IERC721ACH} from \\\"ERC721H/interfaces/IERC721ACH.sol\\\";\\n\\ncontract SharedPaidMinterFunctions is ISharedPaidMinterFunctions {\\n    address public cre8orsNFT;\\n    address public minterUtility;\\n    address public collectionHolderMint;\\n    address public friendsAndFamilyMinter;\\n\\n    modifier arrayLengthMustBe3(uint256[] memory array) {\\n        if (array.length != 3) {\\n            revert ISharedPaidMinterFunctions.InvalidArrayLength();\\n        }\\n        _;\\n    }\\n    modifier verifyCost(uint256[] memory carts) {\\n        uint256 totalCost = IMinterUtilities(minterUtility).calculateTotalCost(\\n            carts\\n        );\\n        if (msg.value < totalCost) {\\n            revert IERC721Drop.Purchase_WrongPrice(totalCost);\\n        }\\n        _;\\n    }\\n    modifier onlyValidTier(uint256 tier) {\\n        if (tier < 1 || tier > 3) {\\n            revert InvalidTier();\\n        }\\n        _;\\n    }\\n    /// @dev Modifier that restricts access to only the contract's admin.\\n    modifier onlyAdmin() {\\n        if (!ICre8ors(cre8orsNFT).isAdmin(msg.sender)) {\\n            revert IERC721Drop.Access_OnlyAdmin();\\n        }\\n        _;\\n    }\\n\\n    function calculateTotalQuantity(\\n        uint256[] memory carts\\n    ) internal pure returns (uint256) {\\n        uint256 totalQuantity;\\n        for (uint256 i = 0; i < carts.length; i++) {\\n            totalQuantity += carts[i];\\n        }\\n        return totalQuantity;\\n    }\\n\\n    function _lockUp(uint256[] memory carts, uint256 startingTokenId) internal {\\n        uint256 tokenId = startingTokenId;\\n        IMinterUtilities.TierInfo[] memory tiers = abi.decode(\\n            IMinterUtilities(minterUtility).getTierInfo(),\\n            (IMinterUtilities.TierInfo[])\\n        );\\n        for (uint256 i = 0; i < carts.length; i++) {\\n            if (i == 3 || carts[i] == 0) {\\n                continue;\\n            }\\n            uint256[] memory tokenIds = new uint256[](carts[i]);\\n            for (uint256 j = 0; j < carts[i]; j++) {\\n                tokenIds[j] = tokenId;\\n                tokenId++;\\n            }\\n            ICre8ors(\\n                IERC721ACH(cre8orsNFT).getHook(\\n                    IERC721ACH.HookType.BeforeTokenTransfers\\n                )\\n            ).cre8ing().inializeStakingAndLockup(\\n                    cre8orsNFT,\\n                    tokenIds,\\n                    _getLockUpDateAndPrice(tiers, i + 1)\\n                );\\n        }\\n    }\\n\\n    function _getLockUpDateAndPrice(\\n        IMinterUtilities.TierInfo[] memory tiers,\\n        uint256 tier\\n    ) internal view onlyValidTier(tier) returns (bytes memory) {\\n        IMinterUtilities.TierInfo memory selectedTier = tiers[tier - 1];\\n        uint256 lockupDate = block.timestamp + selectedTier.lockup;\\n        uint256 tierPrice = selectedTier.price;\\n\\n        return abi.encode(lockupDate, tierPrice);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC6551/=lib/ERC6551/src/\",\r\n      \"ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ERC721C/=lib/creator-token-contracts/contracts/\",\r\n      \"ERC721H/=lib/ERC721H/src/\",\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"creator-token-contracts/=lib/creator-token-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc6551/=lib/tokenbound/lib/reference/src/\",\r\n      \"erc721a/=lib/ERC721A/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=lib/creator-token-contracts/node_modules/hardhat/\",\r\n      \"murky/=lib/creator-token-contracts/lib/murky/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"reference/=lib/tokenbound/lib/reference/src/\",\r\n      \"sstore2/=lib/ERC6551/lib/sstore2/contracts/\",\r\n      \"tokenbound/=lib/tokenbound/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cre8orsNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minterUtility\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collectionHolderMint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_friendsAndFamilyMinter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Access_OnlyAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTier\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Purchase_TooManyForAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"correctPrice\",\"type\":\"uint256\"}],\"name\":\"Purchase_WrongPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Sale_Inactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"collectionHolderMint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cre8orsNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"friendsAndFamilyMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"carts\",\"type\":\"uint256[]\"}],\"name\":\"mintPfp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterUtility\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMinterUtilityContractAddress\",\"type\":\"address\"}],\"name\":\"setNewMinterUtilityContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PublicMinter", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ddef0396d4b61fcbb0e4a821dfac52c011f79da00000000000000000000000014b9df14151a8417106df244faf20b6cec2ad7b6000000000000000000000000f253a36fb30d0ddb654953508f9c59aad877a3f700000000000000000000000086558b0cd2310382344e4ee52b1922dddbb52d31", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}