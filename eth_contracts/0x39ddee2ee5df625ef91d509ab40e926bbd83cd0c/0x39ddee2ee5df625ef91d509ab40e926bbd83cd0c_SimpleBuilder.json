{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@ironblocks/firewall-consumer/contracts/FirewallConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2024\\npragma solidity ^0.8;\\n\\nimport {FirewallConsumerBase} from \\\"./FirewallConsumerBase.sol\\\";\\n\\n/**\\n * @title Firewall Consumer\\n * @author David Benchimol @ Ironblocks\\n * @dev This contract is a parent contract that can be used to add firewall protection to any contract.\\n *\\n * The contract must initializes with the firewall contract disabled, and the deployer\\n * as the firewall admin.\\n *\\n */\\ncontract FirewallConsumer is FirewallConsumerBase(address(0), msg.sender) {\\n}\"\r\n    },\r\n    \"@ironblocks/firewall-consumer/contracts/FirewallConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2024\\npragma solidity ^0.8;\\n\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IFirewall} from \\\"./interfaces/IFirewall.sol\\\";\\nimport {IFirewallConsumer} from \\\"./interfaces/IFirewallConsumer.sol\\\";\\n\\n/**\\n * @title Firewall Consumer Base Contract\\n * @author David Benchimol @ Ironblocks\\n * @dev This contract is a parent contract that can be used to add firewall protection to any contract.\\n *\\n * The contract must define a firewall contract which will manage the policies that are applied to the contract.\\n * It also must define a firewall admin which will be able to add and remove policies.\\n *\\n */\\ncontract FirewallConsumerBase is IFirewallConsumer, Context {\\n\\n    // This slot is used to store the firewall address\\n    bytes32 private constant FIREWALL_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.firewall\\\")) - 1);\\n\\n    // This slot is used to store the firewall admin address\\n    bytes32 private constant FIREWALL_ADMIN_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.firewall.admin\\\")) - 1);\\n\\n    // This slot is used to store the new firewall admin address (when changing admin)\\n    bytes32 private constant NEW_FIREWALL_ADMIN_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.new.firewall.admin\\\")) - 1);\\n    bytes4 private constant SUPPORTS_APPROVE_VIA_SIGNATURE_INTERFACE_ID = bytes4(0x0c908cff); // sighash of approveCallsViaSignature\\n\\n    // This slot is special since it's used for mappings and not a single value\\n    bytes32 private constant APPROVED_TARGETS_MAPPING_SLOT = bytes32(uint256(keccak256(\\\"eip1967.approved.targets\\\")) - 1);\\n\\n    event FirewallAdminUpdated(address newAdmin);\\n    event FirewallUpdated(address newFirewall);\\n\\n    /**\\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall, applying each of\\n     * the subscribed policies.\\n     *\\n     * NOTE: Applying this modifier on functions that exit execution flow by an inline assmebly \\\"return\\\" call will\\n     * prevent the postExecution hook from running - breaking the protection provided by the firewall.\\n     * If you have any questions, please refer to the Firewall's documentation and/or contact our support.\\n     */\\n    modifier firewallProtected() {\\n        address firewall = _getAddressBySlot(FIREWALL_STORAGE_SLOT);\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint256 value = _msgValue();\\n        IFirewall(firewall).preExecution(_msgSender(), _msgData(), value);\\n        _;\\n        IFirewall(firewall).postExecution(_msgSender(), _msgData(), value);\\n    }\\n\\n    /**\\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall, applying each of\\n     * the subscribed policies. Allows passing custom data to the firewall, not necessarily msg.data.\\n     * Useful for checking internal function calls\\n     *\\n     * @param data custom data to be passed to the firewall\\n     * NOTE: Using this modifier affects the data that is passed to the firewall, and as such it is mainly meant\\n     * to be used by internal functions, and only in conjuction with policies that whose protection strategy\\n     * requires this data.\\n     *\\n     * Using this modifier incorrectly may result in unexpected behavior.\\n     *\\n     * If you have any questions on how or when to use this modifier, please refer to the Firewall's documentation\\n     * and/or contact our support.\\n     *\\n     * NOTE: Applying this modifier on functions that exit execution flow by an inline assmebly \\\"return\\\" call will\\n     * prevent the postExecution hook from running - breaking the protection provided by the firewall.\\n     * If you have any questions, please refer to the Firewall's documentation and/or contact our support.\\n     */\\n    modifier firewallProtectedCustom(bytes memory data) {\\n        address firewall = _getAddressBySlot(FIREWALL_STORAGE_SLOT);\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint256 value = _msgValue();\\n        IFirewall(firewall).preExecution(_msgSender(), data, value);\\n        _;\\n        IFirewall(firewall).postExecution(_msgSender(), data, value);\\n    }\\n\\n    /**\\n     * @dev identical to the rest of the modifiers in terms of logic, but makes it more\\n     * aesthetic when all you want to pass are signatures/unique identifiers.\\n     *\\n     * @param selector unique identifier for the function\\n     *\\n     * NOTE: Using this modifier affects the data that is passed to the firewall, and as such it is mainly to\\n     * be used by policies that whose protection strategy relies on the function's signature hahs.\\n     *\\n     * Using this modifier incorrectly may result in unexpected behavior.\\n     *\\n     * If you have any questions on how or when to use this modifier, please refer to the Firewall's documentation\\n     * and/or contact our support.\\n     *\\n     * NOTE: Applying this modifier on functions that exit execution flow by an inline assmebly \\\"return\\\" call will\\n     * prevent the postExecution hook from running - breaking the protection provided by the firewall.\\n     * If you have any questions, please refer to the Firewall's documentation and/or contact our support.\\n     */\\n    modifier firewallProtectedSig(bytes4 selector) {\\n        address firewall = _getAddressBySlot(FIREWALL_STORAGE_SLOT);\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint256 value = _msgValue();\\n        IFirewall(firewall).preExecution(_msgSender(), abi.encodePacked(selector), value);\\n        _;\\n        IFirewall(firewall).postExecution(_msgSender(), abi.encodePacked(selector), value);\\n    }\\n\\n    /**\\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall invariant policy,\\n     * applying the subscribed invariant policy\\n     *\\n     * NOTE: Applying this modifier on functions that exit execution flow by an inline assmebly \\\"return\\\" call will\\n     * prevent the postExecution hook from running - breaking the protection provided by the firewall.\\n     * If you have any questions, please refer to the Firewall's documentation and/or contact our support.\\n     */\\n    modifier invariantProtected() {\\n        address firewall = _getAddressBySlot(FIREWALL_STORAGE_SLOT);\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint256 value = _msgValue();\\n        bytes32[] memory storageSlots = IFirewall(firewall).preExecutionPrivateInvariants(_msgSender(), _msgData(), value);\\n        bytes32[] memory preValues = _readStorage(storageSlots);\\n        _;\\n        bytes32[] memory postValues = _readStorage(storageSlots);\\n        IFirewall(firewall).postExecutionPrivateInvariants(_msgSender(), _msgData(), value, preValues, postValues);\\n    }\\n\\n\\n    /**\\n     * @dev modifier asserting that the target is approved\\n     * @param target address of the target\\n     */\\n    modifier onlyApprovedTarget(address target) {\\n        // We use the same logic that solidity uses for mapping locations, but we add a pseudorandom\\n        // constant \\\"salt\\\" instead of a constant placeholder so that there are no storage collisions\\n        // if adding this to an upgradeable contract implementation\\n        bytes32 _slot = keccak256(abi.encode(APPROVED_TARGETS_MAPPING_SLOT, target));\\n        bool isApprovedTarget = _getValueBySlot(_slot) != bytes32(0);\\n        require(isApprovedTarget, \\\"FirewallConsumer: Not approved target\\\");\\n        require(ERC165Checker.supportsERC165InterfaceUnchecked(target, SUPPORTS_APPROVE_VIA_SIGNATURE_INTERFACE_ID));\\n        _;\\n    }\\n\\n    /**\\n     * @dev modifier similar to onlyOwner, but for the firewall admin.\\n     */\\n    modifier onlyFirewallAdmin() {\\n        require(msg.sender == _getAddressBySlot(FIREWALL_ADMIN_STORAGE_SLOT), \\\"FirewallConsumer: not firewall admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes a contract protected by a firewall, with a firewall address and a firewall admin.\\n     */\\n    constructor(\\n        address _firewall,\\n        address _firewallAdmin\\n    ) {\\n        _setAddressBySlot(FIREWALL_STORAGE_SLOT, _firewall);\\n        _setAddressBySlot(FIREWALL_ADMIN_STORAGE_SLOT, _firewallAdmin);\\n    }\\n\\n    /**\\n     * @dev Allows calling an approved external target before executing a method.\\n     *\\n     * This can be used for multiple purposes, but the initial one is to call `approveCallsViaSignature` before\\n     * executing a function, allowing synchronous transaction approvals.\\n     *\\n     * @param target address of the target\\n     * @param targetPayload payload to be sent to the target\\n     * @param data data to be executed after the target call\\n     */\\n    function safeFunctionCall(\\n        address target,\\n        bytes calldata targetPayload,\\n        bytes calldata data\\n    ) external payable onlyApprovedTarget(target) {\\n        (bool success, ) = target.call(targetPayload);\\n        require(success);\\n        require(msg.sender == _msgSender(), \\\"FirewallConsumer: No meta transactions\\\");\\n        Address.functionDelegateCall(address(this), data);\\n    }\\n\\n    /**\\n     * @dev Allows firewall admin to set approved targets.\\n     * IMPORTANT: Only set approved target if you know what you're doing. Anyone can cause this contract\\n     * to send any data to an approved target.\\n     *\\n     * @param target address of the target\\n     * @param status status of the target\\n     */\\n    function setApprovedTarget(address target, bool status) external onlyFirewallAdmin {\\n        bytes32 _slot = keccak256(abi.encode(APPROVED_TARGETS_MAPPING_SLOT, target));\\n        assembly {\\n            sstore(_slot, status)\\n        }\\n    }\\n\\n    /**\\n     * @dev View function for the firewall admin\\n     */\\n    function firewallAdmin() external override view returns (address) {\\n        return _getAddressBySlot(FIREWALL_ADMIN_STORAGE_SLOT);\\n    }\\n\\n    /**\\n     * @dev Admin only function allowing the consumers admin to set the firewall address.\\n     * @param _firewall address of the firewall\\n     */\\n    function setFirewall(address _firewall) external onlyFirewallAdmin {\\n        _setAddressBySlot(FIREWALL_STORAGE_SLOT, _firewall);\\n        emit FirewallUpdated(_firewall);\\n    }\\n\\n    /**\\n     * @dev Admin only function, sets new firewall admin. New admin must accept.\\n     * @param _firewallAdmin address of the new firewall admin\\n     */\\n    function setFirewallAdmin(address _firewallAdmin) external onlyFirewallAdmin {\\n        require(_firewallAdmin != address(0), \\\"FirewallConsumer: zero address\\\");\\n        _setAddressBySlot(NEW_FIREWALL_ADMIN_STORAGE_SLOT, _firewallAdmin);\\n    }\\n\\n    /**\\n     * @dev Accept the role as firewall admin.\\n     */\\n    function acceptFirewallAdmin() external {\\n        require(msg.sender == _getAddressBySlot(NEW_FIREWALL_ADMIN_STORAGE_SLOT), \\\"FirewallConsumer: not new admin\\\");\\n        _setAddressBySlot(FIREWALL_ADMIN_STORAGE_SLOT, msg.sender);\\n        emit FirewallAdminUpdated(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Internal helper funtion to get the msg.value\\n     * @return value of the msg.value\\n     */\\n    function _msgValue() internal view returns (uint256 value) {\\n        // We do this because msg.value can only be accessed in payable functions.\\n        assembly {\\n            value := callvalue()\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function to read storage slots\\n     * @param storageSlots array of storage slots\\n     */\\n    function _readStorage(bytes32[] memory storageSlots) internal view returns (bytes32[] memory) {\\n        uint256 slotsLength = storageSlots.length;\\n        bytes32[] memory values = new bytes32[](slotsLength);\\n\\n        for (uint256 i = 0; i < slotsLength; i++) {\\n            bytes32 slotValue = _getValueBySlot(storageSlots[i]);\\n            values[i] = slotValue;\\n        }\\n        return values;\\n    }\\n\\n    /**\\n     * @dev Internal helper function to set an address in a storage slot\\n     * @param _slot storage slot\\n     * @param _address address to be set\\n     */\\n    function _setAddressBySlot(bytes32 _slot, address _address) internal {\\n        assembly {\\n            sstore(_slot, _address)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function to get an address from a storage slot\\n     * @param _slot storage slot\\n     * @return _address from the storage slot\\n     */\\n    function _getAddressBySlot(bytes32 _slot) internal view returns (address _address) {\\n        assembly {\\n            _address := sload(_slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function to get a value from a storage slot\\n     * @param _slot storage slot\\n     * @return _value from the storage slot\\n     */\\n    function _getValueBySlot(bytes32 _slot) internal view returns (bytes32 _value) {\\n        assembly {\\n            _value := sload(_slot)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@ironblocks/firewall-consumer/contracts/interfaces/IFirewall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2024\\npragma solidity ^0.8;\\n\\ninterface IFirewall {\\n    function preExecution(address sender, bytes memory data, uint256 value) external;\\n    function postExecution(address sender, bytes memory data, uint256 value) external;\\n    function preExecutionPrivateInvariants(address sender, bytes memory data, uint256 value) external returns (bytes32[] calldata);\\n    function postExecutionPrivateInvariants(\\n        address sender,\\n        bytes memory data,\\n        uint256 value,\\n        bytes32[] calldata preValues,\\n        bytes32[] calldata postValues\\n    ) external;\\n}\"\r\n    },\r\n    \"@ironblocks/firewall-consumer/contracts/interfaces/IFirewallConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2024\\npragma solidity ^0.8;\\n\\ninterface IFirewallConsumer {\\n    function firewallAdmin() external returns (address);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Receiver} from \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\\n * {IERC721-setApprovalForAll}.\\n */\\nabstract contract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@poolzfinance/poolz-helper-v2/contracts/interfaces/ILockDealNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"./IProvider.sol\\\";\\nimport \\\"./IVaultManager.sol\\\";\\n\\ninterface ILockDealNFT is IERC721Enumerable {\\n    function approvedContracts(address contractAddress) external view returns (bool);\\n\\n    function mintAndTransfer(\\n        address owner,\\n        address token,\\n        uint256 amount,\\n        IProvider provider\\n    ) external returns (uint256 poolId);\\n\\n    function safeMintAndTransfer(\\n        address owner,\\n        address token,\\n        address from,\\n        uint256 amount,\\n        IProvider provider,\\n        bytes calldata data\\n    ) external returns (uint256 poolId);\\n\\n    function cloneVaultId(uint256 destinationPoolId, uint256 sourcePoolId) external;\\n\\n    function mintForProvider(address owner, IProvider provider) external returns (uint256 poolId);\\n\\n    function getData(uint256 poolId) external view returns (BasePoolInfo memory poolInfo);\\n\\n    function getFullData(uint256 poolId) external view returns (BasePoolInfo[] memory poolInfo);\\n\\n    function tokenOf(uint256 poolId) external view returns (address token);\\n\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function poolIdToProvider(uint256 poolId) external view returns (IProvider provider);\\n\\n    function getWithdrawableAmount(uint256 poolId) external view returns (uint256 withdrawalAmount);\\n\\n    struct BasePoolInfo {\\n        IProvider provider;\\n        string name;\\n        uint256 poolId;\\n        uint256 vaultId;\\n        address owner;\\n        address token;\\n        uint256[] params;\\n    }\\n}\"\r\n    },\r\n    \"@poolzfinance/poolz-helper-v2/contracts/interfaces/IProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n///@dev Interface for the provider contract\\n///@notice This interface is used by the NFT contract to call the provider contract\\ninterface IProvider {\\n    event UpdateParams(uint256 indexed poolId, uint256[] params);\\n\\n    function withdraw(uint256 tokenId) external returns (uint256 withdrawnAmount, bool isFinal);\\n\\n    function split(uint256 oldPoolId, uint256 newPoolId, uint256 ratio) external;\\n\\n    function registerPool(uint256 poolId, uint256[] calldata params) external;\\n\\n    function getParams(uint256 poolId) external view returns (uint256[] memory params);\\n\\n    function getWithdrawableAmount(uint256 poolId) external view returns (uint256 withdrawalAmount);\\n\\n    function currentParamsTargetLength() external view returns (uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function getSubProvidersPoolIds(uint256 poolID) external view returns (uint256[] memory poolIds);\\n}\"\r\n    },\r\n    \"@poolzfinance/poolz-helper-v2/contracts/interfaces/ISimpleProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IProvider.sol\\\";\\n\\n///@dev Interface for the simple providers\\ninterface ISimpleProvider is IProvider {\\n    function withdraw(uint256 poolId, uint256 amount) external returns (uint256 withdrawnAmount, bool isFinal);\\n}\"\r\n    },\r\n    \"@poolzfinance/poolz-helper-v2/contracts/interfaces/IVaultManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\n\\ninterface IVaultManager is IERC2981 {\\n    function depositByToken(address _tokenAddress, uint _amount) external returns (uint vaultId);\\n    function safeDeposit(\\n        address _tokenAddress,\\n        uint _amount,\\n        address _from,\\n        bytes memory _signature\\n    ) external returns (uint vaultId);\\n    function withdrawByVaultId(uint _vaultId, address to, uint _amount) external;\\n    function vaultIdToTokenAddress(uint _vaultId) external view returns (address token);\\n    function vaultIdToTradeStartTime(uint256 _vaultId) external view returns (uint256 startTime);\\n}\\n\"\r\n    },\r\n    \"contracts/Builder/BuilderInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./BuilderModifiers.sol\\\";\\r\\nimport \\\"@poolzfinance/poolz-helper-v2/contracts/interfaces/ISimpleProvider.sol\\\";\\r\\n\\r\\n/// @title BuilderInternal\\r\\n/// @notice This contract contains internal functions for Builders\\r\\nabstract contract BuilderInternal is BuilderModifiers {\\r\\n    /// @dev Concatenates an amount with additional parameters\\r\\n    /// @param amount The initial amount\\r\\n    /// @param params Additional parameters to concatenate\\r\\n    /// @return result Concatenated array containing the amount followed by the additional parameters\\r\\n    function _concatParams(uint amount, uint256[] calldata params) internal pure returns (uint256[] memory result) {\\r\\n        uint256 length = params.length;\\r\\n        result = new uint256[](length + 1);\\r\\n        result[0] = amount;\\r\\n        for (uint256 i; i < length; ) {\\r\\n            result[i + 1] = params[i];\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Creates a new NFT for a user pool\\r\\n    /// @param provider The SimpleProvider (DealProvider, LockProvider or TimedProvider) instance\\r\\n    /// @param tokenPoolId The pool ID of the token\\r\\n    /// @param userData The user pool data\\r\\n    /// @param params The parameters for the SimpleProvider\\r\\n    /// @return amount The amount of tokens in the user pool\\r\\n    function _createNewNFT(\\r\\n        ISimpleProvider provider,\\r\\n        uint256 tokenPoolId,\\r\\n        UserPool memory userData,\\r\\n        uint256[] memory params\\r\\n    ) internal virtual validUserData(userData) returns (uint256 amount) {\\r\\n        amount = userData.amount;\\r\\n        uint256 poolId = lockDealNFT.mintForProvider(userData.user, provider);\\r\\n        params[0] = userData.amount;\\r\\n        provider.registerPool(poolId, params);\\r\\n        lockDealNFT.cloneVaultId(poolId, tokenPoolId);\\r\\n    }\\r\\n\\r\\n    /// @dev Creates the first NFT for a SimpleProvider\\r\\n    /// @param provider The SimpleProvider instance\\r\\n    /// @param token The ERC20 token address\\r\\n    /// @param owner The owner of the NFT\\r\\n    /// @param totalAmount The total amount of tokens\\r\\n    /// @param params The parameters for the SimpleProvider\\r\\n    /// @param signature The cryptographic signature for the transfer\\r\\n    /// @return poolId The pool ID of the created NFT\\r\\n    function _createFirstNFT(\\r\\n        ISimpleProvider provider,\\r\\n        address token,\\r\\n        address owner,\\r\\n        uint256 totalAmount,\\r\\n        uint256[] memory params,\\r\\n        bytes calldata signature\\r\\n    ) internal virtual notZeroAddress(owner) returns (uint256 poolId) {\\r\\n        poolId = lockDealNFT.safeMintAndTransfer(owner, token, msg.sender, totalAmount, provider, signature);\\r\\n        provider.registerPool(poolId, params);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Builder/BuilderModifiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\r\\nimport \\\"./BuilderState.sol\\\";\\r\\n\\r\\n/// @title BuilderModifiers\\r\\n/// @notice This contract contains modifiers and error handling for Builders\\r\\nabstract contract BuilderModifiers is BuilderState {\\r\\n    /// @dev Error thrown when an amount is zero\\r\\n    error NoZeroAmount();\\r\\n    /// @dev Error thrown when the length of parameters is invalid\\r\\n    error InvalidParamsLength(uint256 paramsLength, uint256 minLength);\\r\\n\\r\\n    /// @dev Modifier to ensure an address is not zero\\r\\n    modifier notZeroAddress(address _address) {\\r\\n        _notZeroAddress(_address);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /// @dev Modifier to ensure user data is valid\\r\\n    modifier validUserData(UserPool memory userData) {\\r\\n        _notZeroAddress(userData.user);\\r\\n        _notZeroAmount(userData.amount);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to check that an amount is not zero\\r\\n    function _notZeroAmount(uint256 amount) internal pure {\\r\\n        if (amount == 0) revert NoZeroAmount();\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to check that an address is not zero\\r\\n    function _notZeroAddress(address _address) internal pure {\\r\\n        if (_address == address(0)) revert NoZeroAddress();\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to check the validity of parameter length\\r\\n    function _validParamsLength(uint256 paramsLength, uint256 minLength) internal pure {\\r\\n        if (paramsLength < minLength) revert InvalidParamsLength(paramsLength, minLength);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Builder/BuilderState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@poolzfinance/poolz-helper-v2/contracts/interfaces/ILockDealNFT.sol\\\";\\r\\n\\r\\n/// @title BuilderState\\r\\n/// @notice This contract contains state variables and events for Builders\\r\\ncontract BuilderState {\\r\\n    /// @dev Instance of the LockDealNFT contract\\r\\n    ILockDealNFT public immutable lockDealNFT;\\r\\n\\r\\n    /// @dev Event emitted when mass pools are created\\r\\n    event MassPoolsCreated(address indexed token, IProvider indexed provider, uint256 firstPoolId, uint256 userLength);\\r\\n\\r\\n    /// @dev Error thrown when an address is zero\\r\\n    error NoZeroAddress();\\r\\n    /// @dev Error thrown when an invalid provider type is detected\\r\\n    error InvalidProviderType();\\r\\n\\r\\n    /// @dev Constructor initializes the contract with the provided instance of LockDealNFT\\r\\n    /// @param _lockDealNFT Instance of the LockDealNFT contract\\r\\n    constructor(ILockDealNFT _lockDealNFT) {\\r\\n        if (address(_lockDealNFT) == address(0)) revert NoZeroAddress();\\r\\n        lockDealNFT = _lockDealNFT;\\r\\n    }\\r\\n\\r\\n    /// @dev Struct to store user pool data\\r\\n    struct Builder {\\r\\n        UserPool[] userPools; // Array of user pools\\r\\n        uint256 totalAmount; // Total amount of tokens involved\\r\\n    }\\r\\n\\r\\n    /// @dev Struct to represent a user pool\\r\\n    struct UserPool {\\r\\n        address user; // Address of the user\\r\\n        uint256 amount; // Amount of tokens in the pool\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/SimpleBuilder/SimpleBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\nimport \\\"../Builder/BuilderInternal.sol\\\";\\r\\nimport \\\"@ironblocks/firewall-consumer/contracts/FirewallConsumer.sol\\\";\\r\\n\\r\\n/// @title SimpleBuilder contract\\r\\n/// @notice This contract is used to create mass lock deals(NFTs)\\r\\ncontract SimpleBuilder is ERC721Holder, BuilderInternal, FirewallConsumer {\\r\\n    /// @dev Constructor to initialize the SimpleBuilder contract with the provided instance of LockDealNFT\\r\\n    /// @param _lockDealNFT Instance of the LockDealNFT contract\\r\\n    constructor(ILockDealNFT _lockDealNFT) BuilderState(_lockDealNFT) {}\\r\\n\\r\\n    /// @dev Error thrown when an invalid user length is detected\\r\\n    error InvalidUserLength();\\r\\n\\r\\n    /// @dev Struct to store local variables for building mass pools\\r\\n    struct MassPoolsLocals {\\r\\n        uint256 totalAmount;\\r\\n        address token;\\r\\n        ISimpleProvider provider;\\r\\n        uint256 length;\\r\\n        uint256 poolId;\\r\\n    }\\r\\n\\r\\n    /// @notice Build mass pools\\r\\n    /// @param addressParams[0] - Provider address\\r\\n    /// @param addressParams[1] - Token address\\r\\n    /// @param userData Array of user pools containing user addresses and corresponding token amounts\\r\\n    /// @param params Array of parameters (may be empty if this is a DealProvider)\\r\\n    /// @param signature Cryptographic signature for the transfer\\r\\n    function buildMassPools(\\r\\n        address[] calldata addressParams,\\r\\n        Builder calldata userData,\\r\\n        uint256[] calldata params,\\r\\n        bytes calldata signature\\r\\n    ) external firewallProtected notZeroAddress(addressParams[1]) {\\r\\n        _validParamsLength(addressParams.length, 2);\\r\\n        if (!ERC165Checker.supportsInterface(addressParams[0], type(ISimpleProvider).interfaceId)) {\\r\\n            revert InvalidProviderType();\\r\\n        }\\r\\n        if (userData.userPools.length == 0) revert InvalidUserLength();\\r\\n        MassPoolsLocals memory locals;\\r\\n        locals.totalAmount = userData.totalAmount;\\r\\n        _notZeroAmount(locals.totalAmount);\\r\\n        locals.token = addressParams[1];\\r\\n        locals.provider = ISimpleProvider(addressParams[0]);\\r\\n        UserPool calldata firstUserData = userData.userPools[0];\\r\\n        locals.length = userData.userPools.length;\\r\\n        // one time transfer for decreasing the number of transactions\\r\\n        uint256[] memory simpleParams = _concatParams(firstUserData.amount, params);\\r\\n        locals.poolId = _createFirstNFT(locals.provider, locals.token, firstUserData.user, locals.totalAmount, simpleParams, signature);\\r\\n        locals.totalAmount -= firstUserData.amount;\\r\\n        for (uint256 i = 1; i < locals.length; ) {\\r\\n            UserPool calldata userPool = userData.userPools[i];\\r\\n            locals.totalAmount -= _createNewNFT(locals.provider, locals.poolId, userPool, simpleParams);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n        assert(locals.totalAmount == 0);\\r\\n        emit MassPoolsCreated(locals.token, locals.provider, locals.poolId, userData.userPools.length);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ILockDealNFT\",\"name\":\"_lockDealNFT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paramsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLength\",\"type\":\"uint256\"}],\"name\":\"InvalidParamsLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProviderType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUserLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"FirewallAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFirewall\",\"type\":\"address\"}],\"name\":\"FirewallUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userLength\",\"type\":\"uint256\"}],\"name\":\"MassPoolsCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptFirewallAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addressParams\",\"type\":\"address[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BuilderState.UserPool[]\",\"name\":\"userPools\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BuilderState.Builder\",\"name\":\"userData\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"buildMassPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firewallAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDealNFT\",\"outputs\":[{\"internalType\":\"contract ILockDealNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"targetPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeFunctionCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setApprovedTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_firewall\",\"type\":\"address\"}],\"name\":\"setFirewall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_firewallAdmin\",\"type\":\"address\"}],\"name\":\"setFirewallAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SimpleBuilder", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005e0bb1ff9003ac3586f039d482d2974a6d7ed781", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}