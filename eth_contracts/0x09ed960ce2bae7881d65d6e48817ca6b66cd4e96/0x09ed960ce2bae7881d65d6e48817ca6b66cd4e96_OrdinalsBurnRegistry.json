{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Sorts the pair (a, b) and hashes the result.\\n     */\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\n\\n/**\\n * @dev Core creator interface\\n */\\ninterface ICreatorCore is IERC165 {\\n  event ExtensionRegistered(address indexed extension, address indexed sender);\\n  event ExtensionUnregistered(\\n    address indexed extension,\\n    address indexed sender\\n  );\\n  event ExtensionBlacklisted(address indexed extension, address indexed sender);\\n  event MintPermissionsUpdated(\\n    address indexed extension,\\n    address indexed permissions,\\n    address indexed sender\\n  );\\n  event RoyaltiesUpdated(\\n    uint256 indexed tokenId,\\n    address payable[] receivers,\\n    uint256[] basisPoints\\n  );\\n  event DefaultRoyaltiesUpdated(\\n    address payable[] receivers,\\n    uint256[] basisPoints\\n  );\\n  event ApproveTransferUpdated(address extension);\\n  event ExtensionRoyaltiesUpdated(\\n    address indexed extension,\\n    address payable[] receivers,\\n    uint256[] basisPoints\\n  );\\n  event ExtensionApproveTransferUpdated(\\n    address indexed extension,\\n    bool enabled\\n  );\\n\\n  /**\\n   * @dev gets address of all extensions\\n   */\\n  function getExtensions() external view returns (address[] memory);\\n\\n  /**\\n   * @dev add an extension.  Can only be called by contract owner or admin.\\n   * extension address must point to a contract implementing ICreatorExtension.\\n   * Returns True if newly added, False if already added.\\n   */\\n  function registerExtension(\\n    address extension,\\n    string calldata baseURI\\n  ) external;\\n\\n  /**\\n   * @dev add an extension.  Can only be called by contract owner or admin.\\n   * extension address must point to a contract implementing ICreatorExtension.\\n   * Returns True if newly added, False if already added.\\n   */\\n  function registerExtension(\\n    address extension,\\n    string calldata baseURI,\\n    bool baseURIIdentical\\n  ) external;\\n\\n  /**\\n   * @dev add an extension.  Can only be called by contract owner or admin.\\n   * Returns True if removed, False if already removed.\\n   */\\n  function unregisterExtension(address extension) external;\\n\\n  /**\\n   * @dev blacklist an extension.  Can only be called by contract owner or admin.\\n   * This function will destroy all ability to reference the metadata of any tokens created\\n   * by the specified extension. It will also unregister the extension if needed.\\n   * Returns True if removed, False if already removed.\\n   */\\n  function blacklistExtension(address extension) external;\\n\\n  /**\\n   * @dev set the baseTokenURI of an extension.  Can only be called by extension.\\n   */\\n  function setBaseTokenURIExtension(string calldata uri) external;\\n\\n  /**\\n   * @dev set the baseTokenURI of an extension.  Can only be called by extension.\\n   * For tokens with no uri configured, tokenURI will return \\\"uri+tokenId\\\"\\n   */\\n  function setBaseTokenURIExtension(\\n    string calldata uri,\\n    bool identical\\n  ) external;\\n\\n  /**\\n   * @dev set the common prefix of an extension.  Can only be called by extension.\\n   * If configured, and a token has a uri set, tokenURI will return \\\"prefixURI+tokenURI\\\"\\n   * Useful if you want to use ipfs/arweave\\n   */\\n  function setTokenURIPrefixExtension(string calldata prefix) external;\\n\\n  /**\\n   * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\\n   */\\n  function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\\n\\n  /**\\n   * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\\n   */\\n  function setTokenURIExtension(\\n    uint256[] memory tokenId,\\n    string[] calldata uri\\n  ) external;\\n\\n  /**\\n   * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\\n   * For tokens with no uri configured, tokenURI will return \\\"uri+tokenId\\\"\\n   */\\n  function setBaseTokenURI(string calldata uri) external;\\n\\n  /**\\n   * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\\n   * If configured, and a token has a uri set, tokenURI will return \\\"prefixURI+tokenURI\\\"\\n   * Useful if you want to use ipfs/arweave\\n   */\\n  function setTokenURIPrefix(string calldata prefix) external;\\n\\n  /**\\n   * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\\n   */\\n  function setTokenURI(uint256 tokenId, string calldata uri) external;\\n\\n  /**\\n   * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\\n   */\\n  function setTokenURI(\\n    uint256[] memory tokenIds,\\n    string[] calldata uris\\n  ) external;\\n\\n  /**\\n   * @dev set a permissions contract for an extension.  Used to control minting.\\n   */\\n  function setMintPermissions(address extension, address permissions) external;\\n\\n  /**\\n   * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\\n   * from the extension before transferring\\n   */\\n  function setApproveTransferExtension(bool enabled) external;\\n\\n  /**\\n   * @dev get the extension of a given token\\n   */\\n  function tokenExtension(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Set default royalties\\n   */\\n  function setRoyalties(\\n    address payable[] calldata receivers,\\n    uint256[] calldata basisPoints\\n  ) external;\\n\\n  /**\\n   * @dev Set royalties of a token\\n   */\\n  function setRoyalties(\\n    uint256 tokenId,\\n    address payable[] calldata receivers,\\n    uint256[] calldata basisPoints\\n  ) external;\\n\\n  /**\\n   * @dev Set royalties of an extension\\n   */\\n  function setRoyaltiesExtension(\\n    address extension,\\n    address payable[] calldata receivers,\\n    uint256[] calldata basisPoints\\n  ) external;\\n\\n  /**\\n   * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n   */\\n  function getRoyalties(\\n    uint256 tokenId\\n  ) external view returns (address payable[] memory, uint256[] memory);\\n\\n  // Royalty support for various other standards\\n  function getFeeRecipients(\\n    uint256 tokenId\\n  ) external view returns (address payable[] memory);\\n\\n  function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\\n\\n  function getFees(\\n    uint256 tokenId\\n  ) external view returns (address payable[] memory, uint256[] memory);\\n\\n  function royaltyInfo(\\n    uint256 tokenId,\\n    uint256 value\\n  ) external view returns (address, uint256);\\n\\n  /**\\n   * @dev Set the default approve transfer contract location.\\n   */\\n  function setApproveTransfer(address extension) external;\\n\\n  /**\\n   * @dev Get the default approve transfer contract location.\\n   */\\n  function getApproveTransfer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport './ICreatorCore.sol';\\n\\n/**\\n * @dev Core ERC1155 creator interface\\n */\\ninterface IERC1155CreatorCore is ICreatorCore {\\n  /**\\n   * @dev mint a token with no extension. Can only be called by an admin.\\n   *\\n   * @param to       - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n   * @param amounts  - Can be a single element array (all recipients get the same amount) or a multi-element array\\n   * @param uris     - If no elements, all tokens use the default uri.\\n   *                   If any element is an empty string, the corresponding token uses the default uri.\\n   *\\n   *\\n   * Requirements: If to is a multi-element array, then uris must be empty or single element array\\n   *               If to is a multi-element array, then amounts must be a single element array or a multi-element array of the same size\\n   *               If to is a single element array, uris must be empty or the same length as amounts\\n   *\\n   * Examples:\\n   *    mintBaseNew(['0x....1', '0x....2'], [1], [])\\n   *        Mints a single new token, and gives 1 each to '0x....1' and '0x....2'.  Token uses default uri.\\n   *\\n   *    mintBaseNew(['0x....1', '0x....2'], [1, 2], [])\\n   *        Mints a single new token, and gives 1 to '0x....1' and 2 to '0x....2'.  Token uses default uri.\\n   *\\n   *    mintBaseNew(['0x....1'], [1, 2], [\\\"\\\", \\\"http://token2.com\\\"])\\n   *        Mints two new tokens to '0x....1'. 1 of the first token, 2 of the second.  1st token uses default uri, second uses \\\"http://token2.com\\\".\\n   *\\n   * @return Returns list of tokenIds minted\\n   */\\n  function mintBaseNew(\\n    address[] calldata to,\\n    uint256[] calldata amounts,\\n    string[] calldata uris\\n  ) external returns (uint256[] memory);\\n\\n  /**\\n   * @dev batch mint existing token with no extension. Can only be called by an admin.\\n   *\\n   * @param to        - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n   * @param tokenIds  - Can be a single element array (all recipients get the same token) or a multi-element array\\n   * @param amounts   - Can be a single element array (all recipients get the same amount) or a multi-element array\\n   *\\n   * Requirements: If any of the parameters are multi-element arrays, they need to be the same length as other multi-element arrays\\n   *\\n   * Examples:\\n   *    mintBaseExisting(['0x....1', '0x....2'], [1], [10])\\n   *        Mints 10 of tokenId 1 to each of '0x....1' and '0x....2'.\\n   *\\n   *    mintBaseExisting(['0x....1', '0x....2'], [1, 2], [10, 20])\\n   *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 2 to '0x....2'.\\n   *\\n   *    mintBaseExisting(['0x....1'], [1, 2], [10, 20])\\n   *        Mints 10 of tokenId 1 and 20 of tokenId 2 to '0x....1'.\\n   *\\n   *    mintBaseExisting(['0x....1', '0x....2'], [1], [10, 20])\\n   *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 1 to '0x....2'.\\n   *\\n   */\\n  function mintBaseExisting(\\n    address[] calldata to,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev mint a token from an extension. Can only be called by a registered extension.\\n   *\\n   * @param to       - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n   * @param amounts  - Can be a single element array (all recipients get the same amount) or a multi-element array\\n   * @param uris     - If no elements, all tokens use the default uri.\\n   *                   If any element is an empty string, the corresponding token uses the default uri.\\n   *\\n   *\\n   * Requirements: If to is a multi-element array, then uris must be empty or single element array\\n   *               If to is a multi-element array, then amounts must be a single element array or a multi-element array of the same size\\n   *               If to is a single element array, uris must be empty or the same length as amounts\\n   *\\n   * Examples:\\n   *    mintExtensionNew(['0x....1', '0x....2'], [1], [])\\n   *        Mints a single new token, and gives 1 each to '0x....1' and '0x....2'.  Token uses default uri.\\n   *\\n   *    mintExtensionNew(['0x....1', '0x....2'], [1, 2], [])\\n   *        Mints a single new token, and gives 1 to '0x....1' and 2 to '0x....2'.  Token uses default uri.\\n   *\\n   *    mintExtensionNew(['0x....1'], [1, 2], [\\\"\\\", \\\"http://token2.com\\\"])\\n   *        Mints two new tokens to '0x....1'. 1 of the first token, 2 of the second.  1st token uses default uri, second uses \\\"http://token2.com\\\".\\n   *\\n   * @return Returns list of tokenIds minted\\n   */\\n  function mintExtensionNew(\\n    address[] calldata to,\\n    uint256[] calldata amounts,\\n    string[] calldata uris\\n  ) external returns (uint256[] memory);\\n\\n  /**\\n   * @dev batch mint existing token from extension. Can only be called by a registered extension.\\n   *\\n   * @param to        - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n   * @param tokenIds  - Can be a single element array (all recipients get the same token) or a multi-element array\\n   * @param amounts   - Can be a single element array (all recipients get the same amount) or a multi-element array\\n   *\\n   * Requirements: If any of the parameters are multi-element arrays, they need to be the same length as other multi-element arrays\\n   *\\n   * Examples:\\n   *    mintExtensionExisting(['0x....1', '0x....2'], [1], [10])\\n   *        Mints 10 of tokenId 1 to each of '0x....1' and '0x....2'.\\n   *\\n   *    mintExtensionExisting(['0x....1', '0x....2'], [1, 2], [10, 20])\\n   *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 2 to '0x....2'.\\n   *\\n   *    mintExtensionExisting(['0x....1'], [1, 2], [10, 20])\\n   *        Mints 10 of tokenId 1 and 20 of tokenId 2 to '0x....1'.\\n   *\\n   *    mintExtensionExisting(['0x....1', '0x....2'], [1], [10, 20])\\n   *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 1 to '0x....2'.\\n   *\\n   */\\n  function mintExtensionExisting(\\n    address[] calldata to,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev burn tokens. Can only be called by token owner or approved address.\\n   * On burn, calls back to the registered extension's onBurn method\\n   */\\n  function burn(\\n    address account,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Total amount of tokens in with a given tokenId.\\n   */\\n  function totalSupply(uint256 tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/OrdinalsBurnRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.22;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport 'contracts/interfaces/IERC1155CreatorCore.sol';\\nimport 'contracts/Whitelist.sol';\\n\\n// based on the single necessary interface from 'IERC1155CreatorCore'\\ninterface DefiPassContract {\\n  /**\\n * @dev burn tokens. Can only be called by token owner or approved address.\\n   * On burn, calls back to the registered extension's onBurn method\\n   */\\n  function burn(\\n    address account,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts\\n  ) external;\\n}\\n\\ncontract OrdinalsBurnRegistry is Ownable, Whitelist {\\n  // ------------------ STRUCTS ------------------\\n\\n  /// @notice Burn details\\n  struct BurnRecord {\\n    /// @notice burner's ETH address\\n    address ownerEthereumAddress;\\n    /// @notice amounts of tokens burned\\n    uint8 amountBurned;\\n    /// @notice Target ordinals address of the owner\\n    string ownerOrdinalsAddress;\\n  }\\n\\n  // ------------------ EVENTS ------------------\\n\\n  /// @notice Event emitted when a token is burned\\n  /// @param ownerEthereumAddress ETH address of the owner\\n  /// @param totalRequestedByUser Quantity of tokens burned\\n  /// @param ownerOrdinalsAddress Target ordinals address of the owner\\n  event Burn(\\n    address indexed ownerEthereumAddress,\\n    uint8 totalRequestedByUser,\\n    string indexed ownerOrdinalsAddress\\n  );\\n\\n  // ------------------ STORAGE ------------------\\n  /// @notice Maximum number of burns allowed\\n  uint256 public immutable MAX_NUMBER_OF_BURNS;\\n\\n  /// @notice Token ID to burn\\n  uint256 public immutable TOKEN_ID_TO_BURN;\\n\\n  /// @notice Current number of burns\\n  uint256 public supply;\\n\\n  /// @notice Contract to register ordinals burns for\\n  DefiPassContract public immutable NFT_CONTRACT;\\n\\n  /// @notice Stored burn data\\n  BurnRecord[] public burnRecords;\\n\\n  /// @notice Mapping of owner to ref. burn records (index in burnRecords array)\\n  mapping(address => uint256[]) public burnRecordsByOwner;\\n\\n  /// @notice Whether or not burning is enabled\\n  bool public burnEnabled;\\n\\n  // ------------------ CONSTRUCTOR ------------------\\n\\n  /// @param nftContract Address of the NFT contract to register burns for\\n  /// @param maxNumberOfBurns Maximum number of burns allowed\\n  /// @param tokenIdToBurn Token ID to burn\\n  constructor(\\n    DefiPassContract nftContract,\\n    uint256 maxNumberOfBurns,\\n    uint256 tokenIdToBurn\\n  ) Ownable(msg.sender) {\\n    NFT_CONTRACT = nftContract;\\n    MAX_NUMBER_OF_BURNS = maxNumberOfBurns;\\n    TOKEN_ID_TO_BURN = tokenIdToBurn;\\n  }\\n\\n  // ------------------ BURN FUNCTIONS ------------------\\n\\n  /// @notice Burns the given amounts of token IDs, registers the burn details and emits a Burn event\\n  /// @param totalRequestedByUser Quantity of tokens to be burned\\n  /// @param maxAmount Maximum amount of tokens allowed to be burned by msg.sender\\n  /// @param proof Merkle proof to verify the owner's whitelist status\\n  /// @param ordinalsAddress Target ordinals address to receive the ordinals\\n  function burn(\\n    uint8 totalRequestedByUser,\\n    uint256 maxAmount,\\n    bytes32[] calldata proof,\\n    string calldata ordinalsAddress\\n  ) public {\\n    require(burnEnabled, 'BurnRegistry: Burning is disabled');\\n\\n    // Check if the user is burning at least one token\\n    require(\\n      totalRequestedByUser > 0,\\n      'BurnRegistry: Must burn at least one token'\\n    );\\n\\n    // Check if the user is in the whitelist\\n    require(\\n      _verify(proof, msg.sender, maxAmount),\\n      'BurnRegistry: user is not whitelisted'\\n    );\\n\\n    uint256 totalBurntByUser = getTotalBurntForOwner(msg.sender);\\n\\n    require(\\n      // Check if the total amount of tokens burned by the owner is less than the user's limit\\n      totalBurntByUser + totalRequestedByUser <= maxAmount &&\\n        // Check if the total amount of tokens burned is less than the contract's limit\\n        supply + totalRequestedByUser <= MAX_NUMBER_OF_BURNS,\\n      'BurnRegistry: Burn amount exceeds the limit'\\n    );\\n\\n    uint256[] memory tokenIds = new uint256[](1);\\n    tokenIds[0] = TOKEN_ID_TO_BURN;\\n\\n    uint256[] memory amounts = new uint256[](1);\\n    amounts[0] = totalRequestedByUser;\\n\\n    // Burn the tokens\\n    NFT_CONTRACT.burn(msg.sender, tokenIds, amounts);\\n\\n    // increment the total number of burns\\n    supply += totalRequestedByUser;\\n\\n    // Save the index of the new burn record\\n    uint256 burnIndex = burnRecords.length;\\n\\n    // Record the burn details\\n    burnRecords.push(\\n      BurnRecord({\\n        ownerEthereumAddress: msg.sender,\\n        amountBurned: totalRequestedByUser,\\n        ownerOrdinalsAddress: ordinalsAddress\\n      })\\n    );\\n\\n    // Add the burn record index to the owner's list of burn records\\n    burnRecordsByOwner[msg.sender].push(burnIndex);\\n\\n    // Emit the Burn event\\n    emit Burn(msg.sender, totalRequestedByUser, ordinalsAddress);\\n  }\\n\\n  // ------------------ OWNER FUNCTIONS ------------------\\n\\n  /// @notice Enables or disables burning\\n  /// @param enabled Whether or not burning should be enabled\\n  function setBurnEnabled(bool enabled) external onlyOwner {\\n    burnEnabled = enabled;\\n  }\\n\\n  /// @notice Sets the merkle root for the whitelist\\n  /// @param newMerkleRoot New merkle root\\n  function setWhitelistRoot(bytes32 newMerkleRoot) external onlyOwner {\\n    _setMerkleRoot(newMerkleRoot);\\n  }\\n\\n  // ------------------ VIEW FUNCTIONS ------------------\\n\\n  /// @notice Returns the burn records for the given owner\\n  /// @param owner Owner to get the burn records for\\n  /// @return burnRecordsForOwner Burn records for the given owner\\n  function getBurnRecordsByOwner(\\n    address owner\\n  ) external view returns (BurnRecord[] memory burnRecordsForOwner) {\\n    uint256[] memory burnIndices = burnRecordsByOwner[owner];\\n    burnRecordsForOwner = new BurnRecord[](burnIndices.length);\\n\\n    for (uint256 i = 0; i < burnIndices.length; i++) {\\n      burnRecordsForOwner[i] = burnRecords[burnIndices[i]];\\n    }\\n  }\\n\\n  /// @notice Returns the indices of the burn records for the given owner\\n  /// @param owner Owner to get the burn record indices for\\n  /// @return burnIndices Indices of the burn records for the given owner\\n  function getBurnRecordIndicesForOwner(\\n    address owner\\n  ) external view returns (uint256[] memory burnIndices) {\\n    burnIndices = burnRecordsByOwner[owner];\\n  }\\n\\n  /// @notice Returns the total amount of tokens burned by the given owner\\n  /// @param owner Owner to get the total amount of tokens burned for\\n  function getTotalBurntForOwner(\\n    address owner\\n  ) public view returns (uint256 burnt) {\\n    uint256[] memory burnIndices = burnRecordsByOwner[owner];\\n    for (uint256 i = 0; i < burnIndices.length; i++) {\\n      BurnRecord memory record = burnRecords[burnIndices[i]];\\n\\n      burnt += record.amountBurned;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.22;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\\n\\ncontract Whitelist {\\n  bytes32 public merkleRoot;\\n\\n  function _setMerkleRoot(bytes32 _merkleRoot) internal {\\n    merkleRoot = _merkleRoot;\\n  }\\n\\n  function _verify(\\n    bytes32[] memory proof,\\n    address user,\\n    uint256 amount\\n  ) internal view returns (bool) {\\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(user, amount))));\\n    return MerkleProof.verify(proof, merkleRoot, leaf);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract DefiPassContract\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxNumberOfBurns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdToBurn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerEthereumAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"totalRequestedByUser\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"ownerOrdinalsAddress\",\"type\":\"string\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_NUMBER_OF_BURNS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_CONTRACT\",\"outputs\":[{\"internalType\":\"contract DefiPassContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_ID_TO_BURN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"totalRequestedByUser\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"string\",\"name\":\"ordinalsAddress\",\"type\":\"string\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnRecords\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerEthereumAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"amountBurned\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"ownerOrdinalsAddress\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnRecordsByOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getBurnRecordIndicesForOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"burnIndices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getBurnRecordsByOwner\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ownerEthereumAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"amountBurned\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"ownerOrdinalsAddress\",\"type\":\"string\"}],\"internalType\":\"struct OrdinalsBurnRegistry.BurnRecord[]\",\"name\":\"burnRecordsForOwner\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTotalBurntForOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burnt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setBurnEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setWhitelistRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrdinalsBurnRegistry", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "000000000000000000000000e77ad290adab2989a81ae62ab2467c01b45feeff00000000000000000000000000000000000000000000000000000000000000960000000000000000000000000000000000000000000000000000000000000009", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}