{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(\\n        TransparentUpgradeableProxy proxy,\\n        address implementation,\\n        bytes memory data\\n    ) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/AbsBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {L1MessageType_ethDeposit} from \\\"../libraries/MessageTypes.sol\\\";\\n\\nimport {\\n    NotContract,\\n    NotRollupOrOwner,\\n    NotDelayedInbox,\\n    NotSequencerInbox,\\n    NotOutbox,\\n    InvalidOutboxSet,\\n    BadSequencerMessageNumber\\n} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\nimport {L1MessageType_batchPostingReport} from \\\"../libraries/MessageTypes.sol\\\";\\n\\n/**\\n * @title Staging ground for incoming and outgoing messages\\n * @notice Holds the inbox accumulator for sequenced and delayed messages.\\n * Since the escrow is held here, this contract also contains a list of allowed\\n * outboxes that can make calls from here and withdraw this escrow.\\n */\\nabstract contract AbsBridge is Initializable, DelegateCallAware, IBridge {\\n    using AddressUpgradeable for address;\\n\\n    struct InOutInfo {\\n        uint256 index;\\n        bool allowed;\\n    }\\n\\n    mapping(address => InOutInfo) private allowedDelayedInboxesMap;\\n    mapping(address => InOutInfo) private allowedOutboxesMap;\\n\\n    address[] public allowedDelayedInboxList;\\n    address[] public allowedOutboxList;\\n\\n    address internal _activeOutbox;\\n\\n    /// @inheritdoc IBridge\\n    bytes32[] public delayedInboxAccs;\\n\\n    /// @inheritdoc IBridge\\n    bytes32[] public sequencerInboxAccs;\\n\\n    IOwnable public rollup;\\n    address public sequencerInbox;\\n\\n    uint256 public override sequencerReportedSubMessageCount;\\n\\n    address internal constant EMPTY_ACTIVEOUTBOX = address(type(uint160).max);\\n\\n    modifier onlyRollupOrOwner() {\\n        if (msg.sender != address(rollup)) {\\n            address rollupOwner = rollup.owner();\\n            if (msg.sender != rollupOwner) {\\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @notice Allows the rollup owner to set another rollup address\\n    function updateRollupAddress(IOwnable _rollup) external onlyRollupOrOwner {\\n        rollup = _rollup;\\n        emit RollupUpdated(address(_rollup));\\n    }\\n\\n    /// @dev returns the address of current active Outbox, or zero if no outbox is active\\n    function activeOutbox() public view returns (address) {\\n        address outbox = _activeOutbox;\\n        // address zero is returned if no outbox is set, but the value used in storage\\n        // is non-zero to save users some gas (as storage refunds are usually maxed out)\\n        // EIP-1153 would help here.\\n        // we don't return `EMPTY_ACTIVEOUTBOX` to avoid a breaking change on the current api\\n        if (outbox == EMPTY_ACTIVEOUTBOX) return address(0);\\n        return outbox;\\n    }\\n\\n    function allowedDelayedInboxes(address inbox) public view returns (bool) {\\n        return allowedDelayedInboxesMap[inbox].allowed;\\n    }\\n\\n    function allowedOutboxes(address outbox) public view returns (bool) {\\n        return allowedOutboxesMap[outbox].allowed;\\n    }\\n\\n    modifier onlySequencerInbox() {\\n        if (msg.sender != sequencerInbox) revert NotSequencerInbox(msg.sender);\\n        _;\\n    }\\n\\n    function enqueueSequencerMessage(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    )\\n        external\\n        onlySequencerInbox\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        if (\\n            sequencerReportedSubMessageCount != prevMessageCount &&\\n            prevMessageCount != 0 &&\\n            sequencerReportedSubMessageCount != 0\\n        ) {\\n            revert BadSequencerMessageNumber(sequencerReportedSubMessageCount, prevMessageCount);\\n        }\\n        sequencerReportedSubMessageCount = newMessageCount;\\n        seqMessageIndex = sequencerInboxAccs.length;\\n        if (sequencerInboxAccs.length > 0) {\\n            beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\\n        }\\n        if (afterDelayedMessagesRead > 0) {\\n            delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\\n        }\\n        acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\\n        sequencerInboxAccs.push(acc);\\n    }\\n\\n    /// @inheritdoc IBridge\\n    function submitBatchSpendingReport(address sender, bytes32 messageDataHash)\\n        external\\n        onlySequencerInbox\\n        returns (uint256)\\n    {\\n        return\\n            addMessageToDelayedAccumulator(\\n                L1MessageType_batchPostingReport,\\n                sender,\\n                uint64(block.number),\\n                uint64(block.timestamp), // solhint-disable-line not-rely-on-time,\\n                block.basefee,\\n                messageDataHash\\n            );\\n    }\\n\\n    function _enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (!allowedDelayedInboxes(msg.sender)) revert NotDelayedInbox(msg.sender);\\n\\n        uint256 messageCount = addMessageToDelayedAccumulator(\\n            kind,\\n            sender,\\n            uint64(block.number),\\n            uint64(block.timestamp), // solhint-disable-line not-rely-on-time\\n            _baseFeeToReport(),\\n            messageDataHash\\n        );\\n\\n        _transferFunds(amount);\\n\\n        return messageCount;\\n    }\\n\\n    function addMessageToDelayedAccumulator(\\n        uint8 kind,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 blockTimestamp,\\n        uint256 baseFeeL1,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        uint256 count = delayedInboxAccs.length;\\n        bytes32 messageHash = Messages.messageHash(\\n            kind,\\n            sender,\\n            blockNumber,\\n            blockTimestamp,\\n            count,\\n            baseFeeL1,\\n            messageDataHash\\n        );\\n        bytes32 prevAcc = 0;\\n        if (count > 0) {\\n            prevAcc = delayedInboxAccs[count - 1];\\n        }\\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\\n        emit MessageDelivered(\\n            count,\\n            prevAcc,\\n            msg.sender,\\n            kind,\\n            sender,\\n            messageDataHash,\\n            baseFeeL1,\\n            blockTimestamp\\n        );\\n        if (kind == L1MessageType_ethDeposit) {\\n            emit DepositMessageDelivered(sender);\\n        }\\n        return count;\\n    }\\n\\n    /// @inheritdoc IBridge\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        if (!allowedOutboxes(msg.sender)) revert NotOutbox(msg.sender);\\n        if (data.length > 0 && !to.isContract()) revert NotContract(to);\\n        address prevOutbox = _activeOutbox;\\n        _activeOutbox = msg.sender;\\n        // We set and reset active outbox around external call so activeOutbox remains valid during call\\n\\n        // We use a low level call here since we want to bubble up whether it succeeded or failed to the caller\\n        // rather than reverting on failure as well as allow contract and non-contract calls\\n        (success, returnData) = _executeLowLevelCall(to, value, data);\\n\\n        _activeOutbox = prevOutbox;\\n        emit BridgeCallTriggered(msg.sender, to, value, data);\\n    }\\n\\n    function setSequencerInbox(address _sequencerInbox) external onlyRollupOrOwner {\\n        sequencerInbox = _sequencerInbox;\\n        emit SequencerInboxUpdated(_sequencerInbox);\\n    }\\n\\n    function setDelayedInbox(address inbox, bool enabled) external onlyRollupOrOwner {\\n        InOutInfo storage info = allowedDelayedInboxesMap[inbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit InboxToggle(inbox, enabled);\\n        if (alreadyEnabled == enabled) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedDelayedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\\n            allowedDelayedInboxList.push(inbox);\\n        } else {\\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\\n                allowedDelayedInboxList.length - 1\\n            ];\\n            allowedDelayedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\\n            allowedDelayedInboxList.pop();\\n            delete allowedDelayedInboxesMap[inbox];\\n        }\\n    }\\n\\n    function setOutbox(address outbox, bool enabled) external onlyRollupOrOwner {\\n        if (outbox == EMPTY_ACTIVEOUTBOX) revert InvalidOutboxSet(outbox);\\n\\n        InOutInfo storage info = allowedOutboxesMap[outbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit OutboxToggle(outbox, enabled);\\n        if (alreadyEnabled == enabled) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\\n            allowedOutboxList.push(outbox);\\n        } else {\\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\\n            allowedOutboxList.pop();\\n            delete allowedOutboxesMap[outbox];\\n        }\\n    }\\n\\n    function setSequencerReportedSubMessageCount(uint256 newMsgCount) external onlyRollupOrOwner {\\n        sequencerReportedSubMessageCount = newMsgCount;\\n    }\\n\\n    function delayedMessageCount() external view override returns (uint256) {\\n        return delayedInboxAccs.length;\\n    }\\n\\n    function sequencerMessageCount() external view returns (uint256) {\\n        return sequencerInboxAccs.length;\\n    }\\n\\n    /// @dev For the classic -> nitro migration. TODO: remove post-migration.\\n    function acceptFundsFromOldBridge() external payable {}\\n\\n    /// @dev transfer funds provided to pay for crosschain msg\\n    function _transferFunds(uint256 amount) internal virtual;\\n\\n    function _executeLowLevelCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal virtual returns (bool success, bytes memory returnData);\\n\\n    /// @dev get base fee which is emitted in `MessageDelivered` event and then picked up and\\n    /// used in ArbOs to calculate the submission fee for retryable ticket\\n    function _baseFeeToReport() internal view virtual returns (uint256);\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[40] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/bridge/AbsInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {\\n    DataTooLarge,\\n    GasLimitTooLarge,\\n    InsufficientValue,\\n    InsufficientSubmissionCost,\\n    L1Forked,\\n    NotAllowedOrigin,\\n    NotOrigin,\\n    NotRollupOrOwner,\\n    RetryableData\\n} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IInboxBase.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"../libraries/AddressAliasHelper.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {\\n    L1MessageType_submitRetryableTx,\\n    L2MessageType_unsignedContractTx,\\n    L2MessageType_unsignedEOATx,\\n    L2_MSG\\n} from \\\"../libraries/MessageTypes.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\\\";\\n\\n/**\\n * @title Inbox for user and contract originated messages\\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\\n * to await inclusion in the SequencerInbox\\n */\\nabstract contract AbsInbox is DelegateCallAware, PausableUpgradeable, IInboxBase {\\n    /// @dev Storage slot with the admin of the contract.\\n    /// This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n    bytes32 internal constant _ADMIN_SLOT =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @inheritdoc IInboxBase\\n    IBridge public bridge;\\n    /// @inheritdoc IInboxBase\\n    ISequencerInbox public sequencerInbox;\\n\\n    /// ------------------------------------ allow list start ------------------------------------ ///\\n\\n    /// @inheritdoc IInboxBase\\n    bool public allowListEnabled;\\n\\n    /// @inheritdoc IInboxBase\\n    mapping(address => bool) public isAllowed;\\n\\n    event AllowListAddressSet(address indexed user, bool val);\\n    event AllowListEnabledUpdated(bool isEnabled);\\n\\n    /// @inheritdoc IInboxBase\\n    function setAllowList(address[] memory user, bool[] memory val) external onlyRollupOrOwner {\\n        require(user.length == val.length, \\\"INVALID_INPUT\\\");\\n\\n        for (uint256 i = 0; i < user.length; i++) {\\n            isAllowed[user[i]] = val[i];\\n            emit AllowListAddressSet(user[i], val[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function setAllowListEnabled(bool _allowListEnabled) external onlyRollupOrOwner {\\n        require(_allowListEnabled != allowListEnabled, \\\"ALREADY_SET\\\");\\n        allowListEnabled = _allowListEnabled;\\n        emit AllowListEnabledUpdated(_allowListEnabled);\\n    }\\n\\n    /// @dev this modifier checks the tx.origin instead of msg.sender for convenience (ie it allows\\n    /// allowed users to interact with the token bridge without needing the token bridge to be allowList aware).\\n    /// this modifier is not intended to use to be used for security (since this opens the allowList to\\n    /// a smart contract phishing risk).\\n    modifier onlyAllowed() {\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (allowListEnabled && !isAllowed[tx.origin]) revert NotAllowedOrigin(tx.origin);\\n        _;\\n    }\\n\\n    /// ------------------------------------ allow list end ------------------------------------ ///\\n\\n    modifier onlyRollupOrOwner() {\\n        IOwnable rollup = bridge.rollup();\\n        if (msg.sender != address(rollup)) {\\n            address rollupOwner = rollup.owner();\\n            if (msg.sender != rollupOwner) {\\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\\n            }\\n        }\\n        _;\\n    }\\n\\n    // On L1 this should be set to 117964: 90% of Geth's 128KB tx size limit, leaving ~13KB for proving\\n    uint256 public immutable maxDataSize;\\n    uint256 internal immutable deployTimeChainId = block.chainid;\\n\\n    constructor(uint256 _maxDataSize) {\\n        maxDataSize = _maxDataSize;\\n    }\\n\\n    function _chainIdChanged() internal view returns (bool) {\\n        return deployTimeChainId != block.chainid;\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function pause() external onlyRollupOrOwner {\\n        _pause();\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function unpause() external onlyRollupOrOwner {\\n        _unpause();\\n    }\\n\\n    /* solhint-disable func-name-mixedcase */\\n    function __AbsInbox_init(IBridge _bridge, ISequencerInbox _sequencerInbox)\\n        internal\\n        onlyInitializing\\n    {\\n        bridge = _bridge;\\n        sequencerInbox = _sequencerInbox;\\n        allowListEnabled = false;\\n        __Pausable_init();\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function sendL2MessageFromOrigin(bytes calldata messageData)\\n        external\\n        whenNotPaused\\n        onlyAllowed\\n        returns (uint256)\\n    {\\n        if (_chainIdChanged()) revert L1Forked();\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        if (messageData.length > maxDataSize) revert DataTooLarge(messageData.length, maxDataSize);\\n        uint256 msgNum = _deliverToBridge(L2_MSG, msg.sender, keccak256(messageData), 0);\\n        emit InboxMessageDeliveredFromOrigin(msgNum);\\n        return msgNum;\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function sendL2Message(bytes calldata messageData)\\n        external\\n        whenNotPaused\\n        onlyAllowed\\n        returns (uint256)\\n    {\\n        if (_chainIdChanged()) revert L1Forked();\\n        return _deliverMessage(L2_MSG, msg.sender, messageData, 0);\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external whenNotPaused onlyAllowed returns (uint256) {\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(to)),\\n                    value,\\n                    data\\n                ),\\n                0\\n            );\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external whenNotPaused onlyAllowed returns (uint256) {\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    uint256(uint160(to)),\\n                    value,\\n                    data\\n                ),\\n                0\\n            );\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function getProxyAdmin() external view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    function _createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 amount,\\n        bytes calldata data\\n    ) internal returns (uint256) {\\n        // ensure the user's deposit alone will make submission succeed\\n        if (amount < (maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas)) {\\n            revert InsufficientValue(\\n                maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas,\\n                amount\\n            );\\n        }\\n\\n        // if a refund address is a contract, we apply the alias to it\\n        // so that it can access its funds on the L2\\n        // since the beneficiary and other refund addresses don't get rewritten by arb-os\\n        if (AddressUpgradeable.isContract(excessFeeRefundAddress)) {\\n            excessFeeRefundAddress = AddressAliasHelper.applyL1ToL2Alias(excessFeeRefundAddress);\\n        }\\n        if (AddressUpgradeable.isContract(callValueRefundAddress)) {\\n            // this is the beneficiary. be careful since this is the address that can cancel the retryable in the L2\\n            callValueRefundAddress = AddressAliasHelper.applyL1ToL2Alias(callValueRefundAddress);\\n        }\\n\\n        // gas limit is validated to be within uint64 in unsafeCreateRetryableTicket\\n        return\\n            _unsafeCreateRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                amount,\\n                data\\n            );\\n    }\\n\\n    function _unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 amount,\\n        bytes calldata data\\n    ) internal returns (uint256) {\\n        // gas price and limit of 1 should never be a valid input, so instead they are used as\\n        // magic values to trigger a revert in eth calls that surface data without requiring a tx trace\\n        if (gasLimit == 1 || maxFeePerGas == 1)\\n            revert RetryableData(\\n                msg.sender,\\n                to,\\n                l2CallValue,\\n                amount,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                data\\n            );\\n\\n        // arbos will discard retryable with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n\\n        uint256 submissionFee = calculateRetryableSubmissionFee(data.length, block.basefee);\\n        if (maxSubmissionCost < submissionFee)\\n            revert InsufficientSubmissionCost(submissionFee, maxSubmissionCost);\\n\\n        return\\n            _deliverMessage(\\n                L1MessageType_submitRetryableTx,\\n                msg.sender,\\n                abi.encodePacked(\\n                    uint256(uint160(to)),\\n                    l2CallValue,\\n                    amount,\\n                    maxSubmissionCost,\\n                    uint256(uint160(excessFeeRefundAddress)),\\n                    uint256(uint160(callValueRefundAddress)),\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    data.length,\\n                    data\\n                ),\\n                amount\\n            );\\n    }\\n\\n    function _deliverMessage(\\n        uint8 _kind,\\n        address _sender,\\n        bytes memory _messageData,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (_messageData.length > maxDataSize)\\n            revert DataTooLarge(_messageData.length, maxDataSize);\\n        uint256 msgNum = _deliverToBridge(_kind, _sender, keccak256(_messageData), amount);\\n        emit InboxMessageDelivered(msgNum, _messageData);\\n        return msgNum;\\n    }\\n\\n    function _deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 amount\\n    ) internal virtual returns (uint256);\\n\\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\\n        public\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/bridge/AbsOutbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {\\n    AlreadyInit,\\n    NotRollup,\\n    ProofTooLong,\\n    PathNotMinimal,\\n    UnknownRoot,\\n    AlreadySpent,\\n    BridgeCallFailed,\\n    HadZeroInit,\\n    BadPostUpgradeInit,\\n    RollupNotChanged\\n} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IOutbox.sol\\\";\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\n/// @dev this error is thrown since certain functions are only expected to be used in simulations, not in actual txs\\nerror SimulationOnlyEntrypoint();\\n\\nabstract contract AbsOutbox is DelegateCallAware, IOutbox {\\n    address public rollup; // the rollup contract\\n    IBridge public bridge; // the bridge contract\\n\\n    mapping(uint256 => bytes32) public spent; // packed spent bitmap\\n    mapping(bytes32 => bytes32) public roots; // maps root hashes => L2 block hash\\n\\n    // we're packing this struct into 4 storage slots\\n    // 1st slot: timestamp, l2Block (128 bits each, max ~3.4*10^38)\\n    // 2nd slot: outputId (256 bits)\\n    // 3rd slot: l1Block (96 bits, max ~7.9*10^28), sender (address 160 bits)\\n    // 4th slot: withdrawalAmount (256 bits)\\n    struct L2ToL1Context {\\n        uint128 l2Block;\\n        uint128 timestamp;\\n        bytes32 outputId;\\n        address sender;\\n        uint96 l1Block;\\n        uint256 withdrawalAmount;\\n    }\\n\\n    // Note, these variables are set and then wiped during a single transaction.\\n    // Therefore their values don't need to be maintained, and their slots will\\n    // hold default values (which are interpreted as empty values) outside of transactions\\n    L2ToL1Context internal context;\\n\\n    // default context values to be used in storage instead of zero, to save on storage refunds\\n    // it is assumed that arb-os never assigns these values to a valid leaf to be redeemed\\n    uint128 private constant L2BLOCK_DEFAULT_CONTEXT = type(uint128).max;\\n    uint96 private constant L1BLOCK_DEFAULT_CONTEXT = type(uint96).max;\\n    uint128 private constant TIMESTAMP_DEFAULT_CONTEXT = type(uint128).max;\\n    bytes32 private constant OUTPUTID_DEFAULT_CONTEXT = bytes32(type(uint256).max);\\n    address private constant SENDER_DEFAULT_CONTEXT = address(type(uint160).max);\\n\\n    uint128 public constant OUTBOX_VERSION = 2;\\n\\n    function initialize(IBridge _bridge) external onlyDelegated {\\n        if (address(_bridge) == address(0)) revert HadZeroInit();\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        // address zero is returned if no context is set, but the values used in storage\\n        // are non-zero to save users some gas (as storage refunds are usually maxed out)\\n        // EIP-1153 would help here\\n        context = L2ToL1Context({\\n            l2Block: L2BLOCK_DEFAULT_CONTEXT,\\n            l1Block: L1BLOCK_DEFAULT_CONTEXT,\\n            timestamp: TIMESTAMP_DEFAULT_CONTEXT,\\n            outputId: OUTPUTID_DEFAULT_CONTEXT,\\n            sender: SENDER_DEFAULT_CONTEXT,\\n            withdrawalAmount: _defaultContextAmount()\\n        });\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    function postUpgradeInit() external onlyDelegated onlyProxyOwner {\\n        // prevent postUpgradeInit within a withdrawal\\n        if (context.l2Block != L2BLOCK_DEFAULT_CONTEXT) revert BadPostUpgradeInit();\\n        context = L2ToL1Context({\\n            l2Block: L2BLOCK_DEFAULT_CONTEXT,\\n            l1Block: L1BLOCK_DEFAULT_CONTEXT,\\n            timestamp: TIMESTAMP_DEFAULT_CONTEXT,\\n            outputId: OUTPUTID_DEFAULT_CONTEXT,\\n            sender: SENDER_DEFAULT_CONTEXT,\\n            withdrawalAmount: _defaultContextAmount()\\n        });\\n    }\\n\\n    /// @notice Allows the rollup owner to sync the rollup address\\n    function updateRollupAddress() external {\\n        if (msg.sender != IOwnable(rollup).owner())\\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\\n        address newRollup = address(bridge.rollup());\\n        if (rollup == newRollup) revert RollupNotChanged();\\n        rollup = newRollup;\\n    }\\n\\n    function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external {\\n        if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\\n        roots[root] = l2BlockHash;\\n        emit SendRootUpdated(root, l2BlockHash);\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function l2ToL1Sender() external view returns (address) {\\n        address sender = context.sender;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (sender == SENDER_DEFAULT_CONTEXT) return address(0);\\n        return sender;\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function l2ToL1Block() external view returns (uint256) {\\n        uint128 l2Block = context.l2Block;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (l2Block == L2BLOCK_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(l2Block);\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function l2ToL1EthBlock() external view returns (uint256) {\\n        uint96 l1Block = context.l1Block;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (l1Block == L1BLOCK_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(l1Block);\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function l2ToL1Timestamp() external view returns (uint256) {\\n        uint128 timestamp = context.timestamp;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (timestamp == TIMESTAMP_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(timestamp);\\n    }\\n\\n    /// @notice batch number is deprecated and now always returns 0\\n    function l2ToL1BatchNum() external pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function l2ToL1OutputId() external view returns (bytes32) {\\n        bytes32 outputId = context.outputId;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (outputId == OUTPUTID_DEFAULT_CONTEXT) return bytes32(0);\\n        return outputId;\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function executeTransaction(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external {\\n        bytes32 userTx = calculateItemHash(\\n            l2Sender,\\n            to,\\n            l2Block,\\n            l1Block,\\n            l2Timestamp,\\n            value,\\n            data\\n        );\\n\\n        recordOutputAsSpent(proof, index, userTx);\\n\\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function executeTransactionSimulation(\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external {\\n        if (msg.sender != address(0)) revert SimulationOnlyEntrypoint();\\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\\n    }\\n\\n    function executeTransactionImpl(\\n        uint256 outputId,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal {\\n        emit OutBoxTransactionExecuted(to, l2Sender, 0, outputId);\\n\\n        // we temporarily store the previous values so the outbox can naturally\\n        // unwind itself when there are nested calls to `executeTransaction`\\n        L2ToL1Context memory prevContext = context;\\n\\n        context = L2ToL1Context({\\n            sender: l2Sender,\\n            l2Block: uint128(l2Block),\\n            l1Block: uint96(l1Block),\\n            timestamp: uint128(l2Timestamp),\\n            outputId: bytes32(outputId),\\n            withdrawalAmount: _amountToSetInContext(value)\\n        });\\n\\n        // set and reset vars around execution so they remain valid during call\\n        executeBridgeCall(to, value, data);\\n\\n        context = prevContext;\\n    }\\n\\n    function _calcSpentIndexOffset(uint256 index)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            bytes32\\n        )\\n    {\\n        uint256 spentIndex = index / 255; // Note: Reserves the MSB.\\n        uint256 bitOffset = index % 255;\\n        bytes32 replay = spent[spentIndex];\\n        return (spentIndex, bitOffset, replay);\\n    }\\n\\n    function _isSpent(uint256 bitOffset, bytes32 replay) internal pure returns (bool) {\\n        return ((replay >> bitOffset) & bytes32(uint256(1))) != bytes32(0);\\n    }\\n\\n    /// @inheritdoc IOutbox\\n    function isSpent(uint256 index) external view returns (bool) {\\n        (, uint256 bitOffset, bytes32 replay) = _calcSpentIndexOffset(index);\\n        return _isSpent(bitOffset, replay);\\n    }\\n\\n    function recordOutputAsSpent(\\n        bytes32[] memory proof,\\n        uint256 index,\\n        bytes32 item\\n    ) internal {\\n        if (proof.length >= 256) revert ProofTooLong(proof.length);\\n        if (index >= 2**proof.length) revert PathNotMinimal(index, 2**proof.length);\\n\\n        // Hash the leaf an extra time to prove it's a leaf\\n        bytes32 calcRoot = calculateMerkleRoot(proof, index, item);\\n        if (roots[calcRoot] == bytes32(0)) revert UnknownRoot(calcRoot);\\n\\n        (uint256 spentIndex, uint256 bitOffset, bytes32 replay) = _calcSpentIndexOffset(index);\\n\\n        if (_isSpent(bitOffset, replay)) revert AlreadySpent(index);\\n        spent[spentIndex] = (replay | bytes32(1 << bitOffset));\\n    }\\n\\n    function executeBridgeCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        (bool success, bytes memory returndata) = bridge.executeCall(to, value, data);\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert BridgeCallFailed();\\n            }\\n        }\\n    }\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(l2Sender, to, l2Block, l1Block, l2Timestamp, value, data));\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) public pure returns (bytes32) {\\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\\n    }\\n\\n    /// @notice default value to be used for 'amount' field in L2ToL1Context outside of transaction execution.\\n    /// @return default 'amount' in case of ERC20-based rollup is type(uint256).max, or 0 in case of ETH-based rollup\\n    function _defaultContextAmount() internal pure virtual returns (uint256);\\n\\n    /// @notice value to be set for 'amount' field in L2ToL1Context during L2 to L1 transaction execution.\\n    ///         In case of ERC20-based rollup this is the amount of native token being withdrawn. In case of standard ETH-based\\n    ///         rollup this amount shall always be 0, because amount of ETH being withdrawn can be read from msg.value.\\n    /// @return amount of native token being withdrawn in case of ERC20-based rollup, or 0 in case of ETH-based rollup\\n    function _amountToSetInContext(uint256 value) internal pure virtual returns (uint256);\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[42] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/bridge/Bridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"./AbsBridge.sol\\\";\\nimport \\\"./IEthBridge.sol\\\";\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\nimport {L1MessageType_batchPostingReport} from \\\"../libraries/MessageTypes.sol\\\";\\n\\n/**\\n * @title Staging ground for incoming and outgoing messages\\n * @notice It is also the ETH escrow for value sent with these messages.\\n */\\ncontract Bridge is AbsBridge, IEthBridge {\\n    using AddressUpgradeable for address;\\n\\n    /// @inheritdoc IEthBridge\\n    function initialize(IOwnable rollup_) external initializer onlyDelegated {\\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\\n        rollup = rollup_;\\n    }\\n\\n    /// @inheritdoc IEthBridge\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256) {\\n        return _enqueueDelayedMessage(kind, sender, messageDataHash, msg.value);\\n    }\\n\\n    function _transferFunds(uint256) internal override {\\n        // do nothing as Eth transfer is part of TX execution\\n    }\\n\\n    function _executeLowLevelCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal override returns (bool success, bytes memory returnData) {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, returnData) = to.call{value: value}(data);\\n    }\\n\\n    function _baseFeeToReport() internal view override returns (uint256) {\\n        return block.basefee;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/ERC20Bridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./AbsBridge.sol\\\";\\nimport \\\"./IERC20Bridge.sol\\\";\\nimport \\\"../libraries/AddressAliasHelper.sol\\\";\\nimport {InvalidTokenSet, CallTargetNotAllowed, CallNotAllowed} from \\\"../libraries/Error.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title Staging ground for incoming and outgoing messages\\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\\n * used as native currency on L2.\\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\\n *       - The token can't be rebasing or have a transfer fee\\n *       - The token must only be transferrable via a call to the token address itself\\n *       - The token must only be able to set allowance via a call to the token address itself\\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\\n */\\ncontract ERC20Bridge is AbsBridge, IERC20Bridge {\\n    using SafeERC20 for IERC20;\\n\\n    /// @inheritdoc IERC20Bridge\\n    address public nativeToken;\\n\\n    /// @inheritdoc IERC20Bridge\\n    function initialize(IOwnable rollup_, address nativeToken_) external initializer onlyDelegated {\\n        if (nativeToken_ == address(0)) revert InvalidTokenSet(nativeToken_);\\n        nativeToken = nativeToken_;\\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\\n        rollup = rollup_;\\n    }\\n\\n    /// @inheritdoc IERC20Bridge\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 tokenFeeAmount\\n    ) external returns (uint256) {\\n        return _enqueueDelayedMessage(kind, sender, messageDataHash, tokenFeeAmount);\\n    }\\n\\n    function _transferFunds(uint256 amount) internal override {\\n        // fetch native token from Inbox\\n        IERC20(nativeToken).safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function _executeLowLevelCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal override returns (bool success, bytes memory returnData) {\\n        address _nativeToken = nativeToken;\\n\\n        // we don't allow outgoing calls to native token contract because it could\\n        // result in loss of native tokens which are escrowed by ERC20Bridge\\n        if (to == _nativeToken) {\\n            revert CallTargetNotAllowed(_nativeToken);\\n        }\\n\\n        // first release native token\\n        IERC20(_nativeToken).safeTransfer(to, value);\\n        success = true;\\n\\n        // if there's data do additional contract call. Make sure that call is not used to\\n        // decrease bridge contract's balance of the native token\\n        if (data.length > 0) {\\n            uint256 bridgeBalanceBefore = IERC20(_nativeToken).balanceOf(address(this));\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success, returnData) = to.call(data);\\n\\n            uint256 bridgeBalanceAfter = IERC20(_nativeToken).balanceOf(address(this));\\n            if (bridgeBalanceAfter < bridgeBalanceBefore) {\\n                revert CallNotAllowed();\\n            }\\n        }\\n    }\\n\\n    function _baseFeeToReport() internal pure override returns (uint256) {\\n        // ArbOs uses formula 'l1BaseFee * (1400 + 6 * calldataLengthInBytes)' to calculate retryable ticket's\\n        // submission fee. When custom ERC20 token is used to pay for fees, submission fee shall be 0. That's\\n        // why baseFee is reported as 0 here.\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/ERC20Inbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./AbsInbox.sol\\\";\\nimport \\\"./IERC20Inbox.sol\\\";\\nimport \\\"./IERC20Bridge.sol\\\";\\nimport \\\"../libraries/AddressAliasHelper.sol\\\";\\nimport {L1MessageType_ethDeposit} from \\\"../libraries/MessageTypes.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title Inbox for user and contract originated messages\\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\\n * to await inclusion in the SequencerInbox\\n */\\ncontract ERC20Inbox is AbsInbox, IERC20Inbox {\\n    using SafeERC20 for IERC20;\\n\\n    constructor(uint256 _maxDataSize) AbsInbox(_maxDataSize) {}\\n\\n    /// @inheritdoc IInboxBase\\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox)\\n        external\\n        initializer\\n        onlyDelegated\\n    {\\n        __AbsInbox_init(_bridge, _sequencerInbox);\\n\\n        // inbox holds native token in transit used to pay for retryable tickets, approve bridge to use it\\n        address nativeToken = IERC20Bridge(address(bridge)).nativeToken();\\n        IERC20(nativeToken).approve(address(bridge), type(uint256).max);\\n    }\\n\\n    /// @inheritdoc IERC20Inbox\\n    function depositERC20(uint256 amount) public whenNotPaused onlyAllowed returns (uint256) {\\n        address dest = msg.sender;\\n\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (AddressUpgradeable.isContract(msg.sender) || tx.origin != msg.sender) {\\n            // isContract check fails if this function is called during a contract's constructor.\\n            dest = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        return\\n            _deliverMessage(\\n                L1MessageType_ethDeposit,\\n                msg.sender,\\n                abi.encodePacked(dest, amount),\\n                amount\\n            );\\n    }\\n\\n    /// @inheritdoc IERC20Inbox\\n    function createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 tokenTotalFeeAmount,\\n        bytes calldata data\\n    ) external whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _createRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                tokenTotalFeeAmount,\\n                data\\n            );\\n    }\\n\\n    /// @inheritdoc IERC20Inbox\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 tokenTotalFeeAmount,\\n        bytes calldata data\\n    ) public whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _unsafeCreateRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                tokenTotalFeeAmount,\\n                data\\n            );\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function calculateRetryableSubmissionFee(uint256, uint256)\\n        public\\n        pure\\n        override(AbsInbox, IInboxBase)\\n        returns (uint256)\\n    {\\n        // retryable ticket's submission fee is not charged when ERC20 token is used to pay for fees\\n        return 0;\\n    }\\n\\n    function _deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 tokenAmount\\n    ) internal override returns (uint256) {\\n        // Fetch native token from sender if inbox doesn't already hold enough tokens to pay for fees.\\n        // Inbox might have been pre-funded in prior call, ie. as part of token bridging flow.\\n        address nativeToken = IERC20Bridge(address(bridge)).nativeToken();\\n        uint256 inboxNativeTokenBalance = IERC20(nativeToken).balanceOf(address(this));\\n        if (inboxNativeTokenBalance < tokenAmount) {\\n            uint256 diff = tokenAmount - inboxNativeTokenBalance;\\n            IERC20(nativeToken).safeTransferFrom(msg.sender, address(this), diff);\\n        }\\n\\n        return\\n            IERC20Bridge(address(bridge)).enqueueDelayedMessage(\\n                kind,\\n                AddressAliasHelper.applyL1ToL2Alias(sender),\\n                messageDataHash,\\n                tokenAmount\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/ERC20Outbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./AbsOutbox.sol\\\";\\n\\ncontract ERC20Outbox is AbsOutbox {\\n    // it is assumed that arb-os never assigns this value to a valid leaf to be redeemed\\n    uint256 private constant AMOUNT_DEFAULT_CONTEXT = type(uint256).max;\\n\\n    function l2ToL1WithdrawalAmount() external view returns (uint256) {\\n        uint256 amount = context.withdrawalAmount;\\n        if (amount == AMOUNT_DEFAULT_CONTEXT) return 0;\\n        return amount;\\n    }\\n\\n    /// @inheritdoc AbsOutbox\\n    function _defaultContextAmount() internal pure override returns (uint256) {\\n        // we use type(uint256).max as representation of 0 native token withdrawal amount\\n        return AMOUNT_DEFAULT_CONTEXT;\\n    }\\n\\n    /// @inheritdoc AbsOutbox\\n    function _amountToSetInContext(uint256 value) internal pure override returns (uint256) {\\n        // native token withdrawal amount which can be fetched from context\\n        return value;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IBridge {\\n    /// @dev This is an instruction to offchain readers to inform them where to look\\n    ///      for sequencer inbox batch data. This is not the type of data (eg. das, brotli encoded, or blob versioned hash)\\n    ///      and this enum is not used in the state transition function, rather it informs an offchain\\n    ///      reader where to find the data so that they can supply it to the replay binary\\n    enum BatchDataLocation {\\n        /// @notice The data can be found in the transaction call data\\n        TxInput,\\n        /// @notice The data can be found in an event emitted during the transaction\\n        SeparateBatchEvent,\\n        /// @notice This batch contains no data\\n        NoData,\\n        /// @notice The data can be found in the 4844 data blobs on this transaction\\n        Blob\\n    }\\n\\n    struct TimeBounds {\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        uint64 minBlockNumber;\\n        uint64 maxBlockNumber;\\n    }\\n\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event DepositMessageDelivered(address indexed sender);\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    event RollupUpdated(address rollup);\\n\\n    function allowedDelayedInboxList(uint256) external returns (address);\\n\\n    function allowedOutboxList(uint256) external returns (address);\\n\\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function delayedInboxAccs(uint256) external view returns (bytes32);\\n\\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function sequencerReportedSubMessageCount() external view returns (uint256);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    // ---------- onlySequencerInbox functions ----------\\n\\n    function enqueueSequencerMessage(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    )\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    /**\\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\\n     *      every delayed inbox or every sequencer inbox call.\\n     */\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function updateRollupAddress(IOwnable _rollup) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IERC20Bridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface IERC20Bridge is IBridge {\\n    /**\\n     * @dev token that is escrowed in bridge on L1 side and minted on L2 as native currency.\\n     * Fees are paid in this token. There are certain restrictions on the native token:\\n     *  - The token can't be rebasing or have a transfer fee\\n     *  - The token must only be transferrable via a call to the token address itself\\n     *  - The token must only be able to set allowance via a call to the token address itself\\n     *  - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\\n     */\\n    function nativeToken() external view returns (address);\\n\\n    /**\\n     * @dev Enqueue a message in the delayed inbox accumulator.\\n     *      These messages are later sequenced in the SequencerInbox, either\\n     *      by the sequencer as part of a normal batch, or by force inclusion.\\n     */\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 tokenFeeAmount\\n    ) external returns (uint256);\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IOwnable rollup_, address nativeToken_) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IERC20Inbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IInboxBase.sol\\\";\\n\\ninterface IERC20Inbox is IInboxBase {\\n    /**\\n     * @notice Deposit native token from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\\n     *      Look into retryable tickets if you are interested in this functionality.\\n     * @dev This function should not be called inside contract constructors\\n     */\\n    function depositERC20(uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on L2\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 tokenTotalFeeAmount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\\n     * come from the deposit alone, rather than falling back on the user's L2 balance\\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\\n     * createRetryableTicket method is the recommended standard.\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 tokenTotalFeeAmount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IEthBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface IEthBridge is IBridge {\\n    /**\\n     * @dev Enqueue a message in the delayed inbox accumulator.\\n     *      These messages are later sequenced in the SequencerInbox, either\\n     *      by the sequencer as part of a normal batch, or by force inclusion.\\n     */\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IOwnable rollup_) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IInboxBase.sol\\\";\\n\\ninterface IInbox is IInboxBase {\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev This method can only be called upon L1 fork and will not alias the caller\\n     *      This method will revert if not called from origin\\n     */\\n    function sendL1FundedUnsignedTransactionToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev This method can only be called upon L1 fork and will not alias the caller\\n     *      This method will revert if not called from origin\\n     */\\n    function sendUnsignedTransactionToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Send a message to initiate L2 withdrawal\\n     * @dev This method can only be called upon L1 fork and will not alias the caller\\n     *      This method will revert if not called from origin\\n     */\\n    function sendWithdrawEthToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        uint256 value,\\n        address withdrawTo\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\\n     *      Look into retryable tickets if you are interested in this functionality.\\n     * @dev This function should not be called inside contract constructors\\n     */\\n    function depositEth() external payable returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\\n     * come from the deposit alone, rather than falling back on the user's L2 balance\\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\\n     * createRetryableTicket method is the recommended standard.\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    // ---------- initializer ----------\\n\\n    /**\\n     * @dev function to be called one time during the inbox upgrade process\\n     *      this is used to fix the storage slots\\n     */\\n    function postUpgradeInit(IBridge _bridge) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IInboxBase.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\n\\ninterface IInboxBase is IDelayedMessageProvider {\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    function maxDataSize() external view returns (uint256);\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the L1 fee for submitting a retryable\\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\\n     * @param dataLength The length of the retryable's calldata, in bytes\\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\\n     */\\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    /// @notice pauses all inbox functionality\\n    function pause() external;\\n\\n    /// @notice unpauses all inbox functionality\\n    function unpause() external;\\n\\n    /// @notice add or remove users from allowList\\n    function setAllowList(address[] memory user, bool[] memory val) external;\\n\\n    /// @notice enable or disable allowList\\n    function setAllowListEnabled(bool _allowListEnabled) external;\\n\\n    /// @notice check if user is in allowList\\n    function isAllowed(address user) external view returns (bool);\\n\\n    /// @notice check if allowList is enabled\\n    function allowListEnabled() external view returns (bool);\\n\\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\\n\\n    /// @notice returns the current admin\\n    function getProxyAdmin() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/bridge/Inbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {\\n    NotOrigin,\\n    DataTooLarge,\\n    InsufficientValue,\\n    InsufficientSubmissionCost,\\n    RetryableData,\\n    L1Forked,\\n    NotForked,\\n    GasLimitTooLarge\\n} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./AbsInbox.sol\\\";\\nimport \\\"./IInbox.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IEthBridge.sol\\\";\\nimport \\\"../libraries/AddressAliasHelper.sol\\\";\\nimport {\\n    L2_MSG,\\n    L1MessageType_L2FundedByL1,\\n    L1MessageType_submitRetryableTx,\\n    L1MessageType_ethDeposit,\\n    L2MessageType_unsignedEOATx,\\n    L2MessageType_unsignedContractTx\\n} from \\\"../libraries/MessageTypes.sol\\\";\\nimport \\\"../precompiles/ArbSys.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title Inbox for user and contract originated messages\\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\\n * to await inclusion in the SequencerInbox\\n */\\ncontract Inbox is AbsInbox, IInbox {\\n    constructor(uint256 _maxDataSize) AbsInbox(_maxDataSize) {}\\n\\n    /// @inheritdoc IInboxBase\\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox)\\n        external\\n        initializer\\n        onlyDelegated\\n    {\\n        __AbsInbox_init(_bridge, _sequencerInbox);\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function postUpgradeInit(IBridge) external onlyDelegated onlyProxyOwner {}\\n\\n    /// @inheritdoc IInbox\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(to)),\\n                    msg.value,\\n                    data\\n                ),\\n                msg.value\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function sendL1FundedContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        bytes calldata data\\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    uint256(uint160(to)),\\n                    msg.value,\\n                    data\\n                ),\\n                msg.value\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function sendL1FundedUnsignedTransactionToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\\n        if (!_chainIdChanged()) revert NotForked();\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                // undoing sender alias here to cancel out the aliasing\\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(to)),\\n                    msg.value,\\n                    data\\n                ),\\n                msg.value\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function sendUnsignedTransactionToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external whenNotPaused onlyAllowed returns (uint256) {\\n        if (!_chainIdChanged()) revert NotForked();\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                // undoing sender alias here to cancel out the aliasing\\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(to)),\\n                    value,\\n                    data\\n                ),\\n                0\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function sendWithdrawEthToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        uint256 value,\\n        address withdrawTo\\n    ) external whenNotPaused onlyAllowed returns (uint256) {\\n        if (!_chainIdChanged()) revert NotForked();\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        // arbos will discard unsigned tx with gas limit too large\\n        if (gasLimit > type(uint64).max) {\\n            revert GasLimitTooLarge();\\n        }\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                // undoing sender alias here to cancel out the aliasing\\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(address(100))), // ArbSys address\\n                    value,\\n                    abi.encodeWithSelector(ArbSys.withdrawEth.selector, withdrawTo)\\n                ),\\n                0\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function depositEth() public payable whenNotPaused onlyAllowed returns (uint256) {\\n        address dest = msg.sender;\\n\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (AddressUpgradeable.isContract(msg.sender) || tx.origin != msg.sender) {\\n            // isContract check fails if this function is called during a contract's constructor.\\n            dest = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        return\\n            _deliverMessage(\\n                L1MessageType_ethDeposit,\\n                msg.sender,\\n                abi.encodePacked(dest, msg.value),\\n                msg.value\\n            );\\n    }\\n\\n    /// @notice deprecated in favour of depositEth with no parameters\\n    function depositEth(uint256) external payable whenNotPaused onlyAllowed returns (uint256) {\\n        return depositEth();\\n    }\\n\\n    /**\\n     * @notice deprecated in favour of unsafeCreateRetryableTicket\\n     * @dev deprecated in favour of unsafeCreateRetryableTicket\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function createRetryableTicketNoRefundAliasRewrite(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\\n        // gas limit is validated to be within uint64 in unsafeCreateRetryableTicket\\n        return\\n            unsafeCreateRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                data\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _createRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                msg.value,\\n                data\\n            );\\n    }\\n\\n    /// @inheritdoc IInbox\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) public payable whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _unsafeCreateRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                msg.value,\\n                data\\n            );\\n    }\\n\\n    /// @inheritdoc IInboxBase\\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\\n        public\\n        view\\n        override(AbsInbox, IInboxBase)\\n        returns (uint256)\\n    {\\n        // Use current block basefee if baseFee parameter is 0\\n        return (1400 + 6 * dataLength) * (baseFee == 0 ? block.basefee : baseFee);\\n    }\\n\\n    function _deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 amount\\n    ) internal override returns (uint256) {\\n        return\\n            IEthBridge(address(bridge)).enqueueDelayedMessage{value: amount}(\\n                kind,\\n                AddressAliasHelper.applyL1ToL2Alias(sender),\\n                messageDataHash\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOutbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface IOutbox {\\n    event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash);\\n    event OutBoxTransactionExecuted(\\n        address indexed to,\\n        address indexed l2Sender,\\n        uint256 indexed zero,\\n        uint256 transactionIndex\\n    );\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address); // the rollup contract\\n\\n    function bridge() external view returns (IBridge); // the bridge contract\\n\\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\\n\\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\\n\\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\\n\\n    function updateRollupAddress() external;\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    ///         When the return value is zero, that means this is a system message\\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\\n    function l2ToL1Sender() external view returns (address);\\n\\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\\n    function l2ToL1OutputId() external view returns (bytes32);\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry.\\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\\n     *      is only created once the rollup confirms the respective assertion.\\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\\n     *      to a contract address without any code (as enforced by the Bridge contract).\\n     * @param proof Merkle proof of message inclusion in send root\\n     * @param index Merkle path to message\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param to destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param value wei in L1 message\\n     * @param data abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     *  @dev function used to simulate the result of a particular function call from the outbox\\n     *       it is useful for things such as gas estimates. This function includes all costs except for\\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\\n     *       unless under simulation in an eth_call or eth_estimateGas\\n     */\\n    function executeTransactionSimulation(\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @param index Merkle path to message\\n     * @return true if the message has been spent\\n     */\\n    function isSpent(uint256 index) external view returns (bool);\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external pure returns (bytes32);\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) external pure returns (bytes32);\\n\\n    /**\\n     * @dev function to be called one time during the outbox upgrade process\\n     *      this is used to fix the storage slots\\n     */\\n    function postUpgradeInit() external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.21 <0.9.0;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/bridge/ISequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/IGasRefunder.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface ISequencerInbox is IDelayedMessageProvider {\\n    struct MaxTimeVariation {\\n        uint256 delayBlocks;\\n        uint256 futureBlocks;\\n        uint256 delaySeconds;\\n        uint256 futureSeconds;\\n    }\\n\\n    event SequencerBatchDelivered(\\n        uint256 indexed batchSequenceNumber,\\n        bytes32 indexed beforeAcc,\\n        bytes32 indexed afterAcc,\\n        bytes32 delayedAcc,\\n        uint256 afterDelayedMessagesRead,\\n        IBridge.TimeBounds timeBounds,\\n        IBridge.BatchDataLocation dataLocation\\n    );\\n\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\\n\\n    /// @dev a valid keyset was added\\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\\n\\n    /// @dev a keyset was invalidated\\n    event InvalidateKeyset(bytes32 indexed keysetHash);\\n\\n    function totalDelayedMessagesRead() external view returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    /// @dev The size of the batch header\\n    // solhint-disable-next-line func-name-mixedcase\\n    function HEADER_LENGTH() external view returns (uint256);\\n\\n    /// @dev If the first batch data byte after the header has this bit set,\\n    ///      the sequencer inbox has authenticated the data. Currently only used for 4844 blob support.\\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\\n\\n    /// @dev If the first data byte after the header has this bit set,\\n    ///      then the batch data is to be found in 4844 data blobs\\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DATA_BLOB_HEADER_FLAG() external view returns (bytes1);\\n\\n    /// @dev If the first data byte after the header has this bit set,\\n    ///      then the batch data is a das message\\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\\n\\n    /// @dev If the first data byte after the header has this bit set,\\n    ///      then the batch data is a das message that employs a merklesization strategy\\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\\n    // solhint-disable-next-line func-name-mixedcase\\n    function TREE_DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\\n\\n    /// @dev If the first data byte after the header has this bit set,\\n    ///      then the batch data has been brotli compressed\\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\\n    // solhint-disable-next-line func-name-mixedcase\\n    function BROTLI_MESSAGE_HEADER_FLAG() external view returns (bytes1);\\n\\n    /// @dev If the first data byte after the header has this bit set,\\n    ///      then the batch data uses a zero heavy encoding\\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\\n    // solhint-disable-next-line func-name-mixedcase\\n    function ZERO_HEAVY_MESSAGE_HEADER_FLAG() external view returns (bytes1);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function isBatchPoster(address) external view returns (bool);\\n\\n    function isSequencer(address) external view returns (bool);\\n\\n    function maxDataSize() external view returns (uint256);\\n\\n    /// @notice The batch poster manager has the ability to change the batch poster addresses\\n    ///         This enables the batch poster to do key rotation\\n    function batchPosterManager() external view returns (address);\\n\\n    struct DasKeySetInfo {\\n        bool isValidKeyset;\\n        uint64 creationBlock;\\n    }\\n\\n    /// @dev returns 4 uint256 to be compatible with older version\\n    function maxTimeVariation()\\n        external\\n        view\\n        returns (\\n            uint256 delayBlocks,\\n            uint256 futureBlocks,\\n            uint256 delaySeconds,\\n            uint256 futureSeconds\\n        );\\n\\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\\n\\n    /// @notice Remove force inclusion delay after a L1 chainId fork\\n    function removeDelayAfterFork() external;\\n\\n    /// @notice Force messages from the delayed inbox to be included in the chain\\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\\n    /// @param kind The kind of the last message to be included\\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\\n    /// @param sender The sender of the last message to be included\\n    /// @param messageDataHash The messageDataHash of the last message to be included\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint64[2] calldata l1BlockAndTime,\\n        uint256 baseFeeL1,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external;\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function batchCount() external view returns (uint256);\\n\\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\\n\\n    /// @notice the creation block is intended to still be available after a keyset is deleted\\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\\n\\n    // ---------- BatchPoster functions ----------\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external;\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external;\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external;\\n\\n    function addSequencerL2BatchFromBlobs(\\n        uint256 sequenceNumber,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external;\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    /**\\n     * @notice Set max delay for sequencer inbox\\n     * @param maxTimeVariation_ the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\\n\\n    /**\\n     * @notice Makes Data Availability Service keyset valid\\n     * @param keysetBytes bytes of the serialized keyset\\n     */\\n    function setValidKeyset(bytes calldata keysetBytes) external;\\n\\n    /**\\n     * @notice Invalidates a Data Availability Service keyset\\n     * @param ksHash hash of the keyset\\n     */\\n    function invalidateKeysetHash(bytes32 ksHash) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a sequencer.\\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\\n     * @param addr the address\\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\\n     */\\n    function setIsSequencer(address addr, bool isSequencer_) external;\\n\\n    /**\\n     * @notice Updates the batch poster manager, the address which has the ability to rotate batch poster keys\\n     * @param newBatchPosterManager The new batch poster manager to be set\\n     */\\n    function setBatchPosterManager(address newBatchPosterManager) external;\\n\\n    /// @notice Allows the rollup owner to sync the rollup address\\n    function updateRollupAddress() external;\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/Messages.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Messages {\\n    function messageHash(\\n        uint8 kind,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 baseFeeL1,\\n        bytes32 messageDataHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    kind,\\n                    sender,\\n                    blockNumber,\\n                    timestamp,\\n                    inboxSeqNum,\\n                    baseFeeL1,\\n                    messageDataHash\\n                )\\n            );\\n    }\\n\\n    function accumulateInboxMessage(bytes32 prevAcc, bytes32 message)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(prevAcc, message));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/Outbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./AbsOutbox.sol\\\";\\n\\ncontract Outbox is AbsOutbox {\\n    /// @inheritdoc AbsOutbox\\n    function _defaultContextAmount() internal pure override returns (uint256) {\\n        // In ETH-based chains withdrawal amount can be read from msg.value. For that reason\\n        // amount slot in context will never be accessed and it has 0 default value\\n        return 0;\\n    }\\n\\n    /// @inheritdoc AbsOutbox\\n    function _amountToSetInContext(uint256) internal pure override returns (uint256) {\\n        // In ETH-based chains withdrawal amount can be read from msg.value. For that reason\\n        // amount slot in context will never be accessed, we keep it as 0 all the time\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/SequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {\\n    AlreadyInit,\\n    HadZeroInit,\\n    BadPostUpgradeInit,\\n    NotOrigin,\\n    DataTooLarge,\\n    DelayedBackwards,\\n    DelayedTooFar,\\n    ForceIncludeBlockTooSoon,\\n    ForceIncludeTimeTooSoon,\\n    IncorrectMessagePreimage,\\n    NotBatchPoster,\\n    BadSequencerNumber,\\n    AlreadyValidDASKeyset,\\n    NoSuchKeyset,\\n    NotForked,\\n    NotBatchPosterManager,\\n    RollupNotChanged,\\n    DataBlobsNotSupported,\\n    InitParamZero,\\n    MissingDataHashes,\\n    NotOwner,\\n    InvalidHeaderFlag,\\n    NativeTokenMismatch,\\n    BadMaxTimeVariation,\\n    Deprecated\\n} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IInboxBase.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\nimport \\\"../rollup/IRollupLogic.sol\\\";\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../precompiles/ArbGasInfo.sol\\\";\\nimport \\\"../precompiles/ArbSys.sol\\\";\\nimport \\\"../libraries/IReader4844.sol\\\";\\n\\nimport {L1MessageType_batchPostingReport} from \\\"../libraries/MessageTypes.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {IGasRefunder} from \\\"../libraries/IGasRefunder.sol\\\";\\nimport {GasRefundEnabled} from \\\"../libraries/GasRefundEnabled.sol\\\";\\nimport \\\"../libraries/ArbitrumChecker.sol\\\";\\nimport {IERC20Bridge} from \\\"./IERC20Bridge.sol\\\";\\n\\n/**\\n * @title  Accepts batches from the sequencer and adds them to the rollup inbox.\\n * @notice Contains the inbox accumulator which is the ordering of all data and transactions to be processed by the rollup.\\n *         As part of submitting a batch the sequencer is also expected to include items enqueued\\n *         in the delayed inbox (Bridge.sol). If items in the delayed inbox are not included by a\\n *         sequencer within a time limit they can be force included into the rollup inbox by anyone.\\n */\\ncontract SequencerInbox is DelegateCallAware, GasRefundEnabled, ISequencerInbox {\\n    uint256 public totalDelayedMessagesRead;\\n\\n    IBridge public bridge;\\n\\n    /// @inheritdoc ISequencerInbox\\n    uint256 public constant HEADER_LENGTH = 40;\\n\\n    /// @inheritdoc ISequencerInbox\\n    bytes1 public constant DATA_AUTHENTICATED_FLAG = 0x40;\\n\\n    /// @inheritdoc ISequencerInbox\\n    bytes1 public constant DATA_BLOB_HEADER_FLAG = DATA_AUTHENTICATED_FLAG | 0x10;\\n\\n    /// @inheritdoc ISequencerInbox\\n    bytes1 public constant DAS_MESSAGE_HEADER_FLAG = 0x80;\\n\\n    /// @inheritdoc ISequencerInbox\\n    bytes1 public constant TREE_DAS_MESSAGE_HEADER_FLAG = 0x08;\\n\\n    /// @inheritdoc ISequencerInbox\\n    bytes1 public constant BROTLI_MESSAGE_HEADER_FLAG = 0x00;\\n\\n    /// @inheritdoc ISequencerInbox\\n    bytes1 public constant ZERO_HEAVY_MESSAGE_HEADER_FLAG = 0x20;\\n\\n    // GAS_PER_BLOB from EIP-4844\\n    uint256 internal constant GAS_PER_BLOB = 1 << 17;\\n\\n    IOwnable public rollup;\\n\\n    mapping(address => bool) public isBatchPoster;\\n\\n    // we previously stored the max time variation in a (uint,uint,uint,uint) struct here\\n    // solhint-disable-next-line var-name-mixedcase\\n    ISequencerInbox.MaxTimeVariation private __LEGACY_MAX_TIME_VARIATION;\\n\\n    mapping(bytes32 => DasKeySetInfo) public dasKeySetInfo;\\n\\n    modifier onlyRollupOwner() {\\n        if (msg.sender != rollup.owner()) revert NotOwner(msg.sender, rollup.owner());\\n        _;\\n    }\\n\\n    modifier onlyRollupOwnerOrBatchPosterManager() {\\n        if (msg.sender != rollup.owner() && msg.sender != batchPosterManager) {\\n            revert NotBatchPosterManager(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    mapping(address => bool) public isSequencer;\\n    IReader4844 public immutable reader4844;\\n\\n    // see ISequencerInbox.MaxTimeVariation\\n    uint64 internal delayBlocks;\\n    uint64 internal futureBlocks;\\n    uint64 internal delaySeconds;\\n    uint64 internal futureSeconds;\\n\\n    /// @inheritdoc ISequencerInbox\\n    address public batchPosterManager;\\n\\n    // On L1 this should be set to 117964: 90% of Geth's 128KB tx size limit, leaving ~13KB for proving\\n    uint256 public immutable maxDataSize;\\n    uint256 internal immutable deployTimeChainId = block.chainid;\\n    // If the chain this SequencerInbox is deployed on is an Arbitrum chain.\\n    bool internal immutable hostChainIsArbitrum = ArbitrumChecker.runningOnArbitrum();\\n    // True if the chain this SequencerInbox is deployed on uses custom fee token\\n    bool public immutable isUsingFeeToken;\\n\\n    constructor(\\n        uint256 _maxDataSize,\\n        IReader4844 reader4844_,\\n        bool _isUsingFeeToken\\n    ) {\\n        maxDataSize = _maxDataSize;\\n        if (hostChainIsArbitrum) {\\n            if (reader4844_ != IReader4844(address(0))) revert DataBlobsNotSupported();\\n        } else {\\n            if (reader4844_ == IReader4844(address(0))) revert InitParamZero(\\\"Reader4844\\\");\\n        }\\n        reader4844 = reader4844_;\\n        isUsingFeeToken = _isUsingFeeToken;\\n    }\\n\\n    function _chainIdChanged() internal view returns (bool) {\\n        return deployTimeChainId != block.chainid;\\n    }\\n\\n    function postUpgradeInit() external onlyDelegated onlyProxyOwner {\\n        // Assuming we would not upgrade from a version that have MaxTimeVariation all set to zero\\n        // If that is the case, postUpgradeInit do not need to be called\\n        if (\\n            __LEGACY_MAX_TIME_VARIATION.delayBlocks == 0 &&\\n            __LEGACY_MAX_TIME_VARIATION.futureBlocks == 0 &&\\n            __LEGACY_MAX_TIME_VARIATION.delaySeconds == 0 &&\\n            __LEGACY_MAX_TIME_VARIATION.futureSeconds == 0\\n        ) {\\n            revert AlreadyInit();\\n        }\\n\\n        if (\\n            __LEGACY_MAX_TIME_VARIATION.delayBlocks > type(uint64).max ||\\n            __LEGACY_MAX_TIME_VARIATION.futureBlocks > type(uint64).max ||\\n            __LEGACY_MAX_TIME_VARIATION.delaySeconds > type(uint64).max ||\\n            __LEGACY_MAX_TIME_VARIATION.futureSeconds > type(uint64).max\\n        ) {\\n            revert BadPostUpgradeInit();\\n        }\\n\\n        delayBlocks = uint64(__LEGACY_MAX_TIME_VARIATION.delayBlocks);\\n        futureBlocks = uint64(__LEGACY_MAX_TIME_VARIATION.futureBlocks);\\n        delaySeconds = uint64(__LEGACY_MAX_TIME_VARIATION.delaySeconds);\\n        futureSeconds = uint64(__LEGACY_MAX_TIME_VARIATION.futureSeconds);\\n\\n        __LEGACY_MAX_TIME_VARIATION.delayBlocks = 0;\\n        __LEGACY_MAX_TIME_VARIATION.futureBlocks = 0;\\n        __LEGACY_MAX_TIME_VARIATION.delaySeconds = 0;\\n        __LEGACY_MAX_TIME_VARIATION.futureSeconds = 0;\\n    }\\n\\n    function initialize(\\n        IBridge bridge_,\\n        ISequencerInbox.MaxTimeVariation calldata maxTimeVariation_\\n    ) external onlyDelegated {\\n        if (bridge != IBridge(address(0))) revert AlreadyInit();\\n        if (bridge_ == IBridge(address(0))) revert HadZeroInit();\\n\\n        // Make sure logic contract was created by proper value for 'isUsingFeeToken'.\\n        // Bridge in ETH based chains doesn't implement nativeToken(). In future it might implement it and return address(0)\\n        bool actualIsUsingFeeToken = false;\\n        try IERC20Bridge(address(bridge_)).nativeToken() returns (address feeToken) {\\n            if (feeToken != address(0)) {\\n                actualIsUsingFeeToken = true;\\n            }\\n        } catch {}\\n        if (isUsingFeeToken != actualIsUsingFeeToken) {\\n            revert NativeTokenMismatch();\\n        }\\n\\n        bridge = bridge_;\\n        rollup = bridge_.rollup();\\n\\n        _setMaxTimeVariation(maxTimeVariation_);\\n    }\\n\\n    /// @notice Allows the rollup owner to sync the rollup address\\n    function updateRollupAddress() external {\\n        if (msg.sender != IOwnable(rollup).owner())\\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\\n        IOwnable newRollup = bridge.rollup();\\n        if (rollup == newRollup) revert RollupNotChanged();\\n        rollup = newRollup;\\n    }\\n\\n    function getTimeBounds() internal view virtual returns (IBridge.TimeBounds memory) {\\n        IBridge.TimeBounds memory bounds;\\n        (\\n            uint64 delayBlocks_,\\n            uint64 futureBlocks_,\\n            uint64 delaySeconds_,\\n            uint64 futureSeconds_\\n        ) = maxTimeVariationInternal();\\n        if (block.timestamp > delaySeconds_) {\\n            bounds.minTimestamp = uint64(block.timestamp) - delaySeconds_;\\n        }\\n        bounds.maxTimestamp = uint64(block.timestamp) + futureSeconds_;\\n        if (block.number > delayBlocks_) {\\n            bounds.minBlockNumber = uint64(block.number) - delayBlocks_;\\n        }\\n        bounds.maxBlockNumber = uint64(block.number) + futureBlocks_;\\n        return bounds;\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function removeDelayAfterFork() external {\\n        if (!_chainIdChanged()) revert NotForked();\\n        delayBlocks = 1;\\n        futureBlocks = 1;\\n        delaySeconds = 1;\\n        futureSeconds = 1;\\n    }\\n\\n    function maxTimeVariation()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (\\n            uint64 delayBlocks_,\\n            uint64 futureBlocks_,\\n            uint64 delaySeconds_,\\n            uint64 futureSeconds_\\n        ) = maxTimeVariationInternal();\\n\\n        return (\\n            uint256(delayBlocks_),\\n            uint256(futureBlocks_),\\n            uint256(delaySeconds_),\\n            uint256(futureSeconds_)\\n        );\\n    }\\n\\n    function maxTimeVariationInternal()\\n        internal\\n        view\\n        returns (\\n            uint64,\\n            uint64,\\n            uint64,\\n            uint64\\n        )\\n    {\\n        if (_chainIdChanged()) {\\n            return (1, 1, 1, 1);\\n        } else {\\n            return (delayBlocks, futureBlocks, delaySeconds, futureSeconds);\\n        }\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint64[2] calldata l1BlockAndTime,\\n        uint256 baseFeeL1,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external {\\n        if (_totalDelayedMessagesRead <= totalDelayedMessagesRead) revert DelayedBackwards();\\n        bytes32 messageHash = Messages.messageHash(\\n            kind,\\n            sender,\\n            l1BlockAndTime[0],\\n            l1BlockAndTime[1],\\n            _totalDelayedMessagesRead - 1,\\n            baseFeeL1,\\n            messageDataHash\\n        );\\n        // Can only force-include after the Sequencer-only window has expired.\\n        if (l1BlockAndTime[0] + delayBlocks >= block.number) revert ForceIncludeBlockTooSoon();\\n        if (l1BlockAndTime[1] + delaySeconds >= block.timestamp) revert ForceIncludeTimeTooSoon();\\n\\n        // Verify that message hash represents the last message sequence of delayed message to be included\\n        bytes32 prevDelayedAcc = 0;\\n        if (_totalDelayedMessagesRead > 1) {\\n            prevDelayedAcc = bridge.delayedInboxAccs(_totalDelayedMessagesRead - 2);\\n        }\\n        if (\\n            bridge.delayedInboxAccs(_totalDelayedMessagesRead - 1) !=\\n            Messages.accumulateInboxMessage(prevDelayedAcc, messageHash)\\n        ) revert IncorrectMessagePreimage();\\n\\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formEmptyDataHash(\\n            _totalDelayedMessagesRead\\n        );\\n        uint256 __totalDelayedMessagesRead = _totalDelayedMessagesRead;\\n        uint256 prevSeqMsgCount = bridge.sequencerReportedSubMessageCount();\\n        uint256 newSeqMsgCount = prevSeqMsgCount; // force inclusion should not modify sequencer message count\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(\\n                dataHash,\\n                __totalDelayedMessagesRead,\\n                0,\\n                prevSeqMsgCount,\\n                newSeqMsgCount\\n            );\\n        emit SequencerBatchDelivered(\\n            seqMessageIndex,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            IBridge.BatchDataLocation.NoData\\n        );\\n    }\\n\\n    /// @dev Deprecated, kept for abi generation and will be removed in the future\\n    function addSequencerL2BatchFromOrigin(\\n        uint256,\\n        bytes calldata,\\n        uint256,\\n        IGasRefunder\\n    ) external pure {\\n        revert Deprecated();\\n    }\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external refundsGas(gasRefunder, IReader4844(address(0))) {\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formCallDataHash(\\n            data,\\n            afterDelayedMessagesRead\\n        );\\n        // Reformat the stack to prevent \\\"Stack too deep\\\"\\n        uint256 sequenceNumber_ = sequenceNumber;\\n        IBridge.TimeBounds memory timeBounds_ = timeBounds;\\n        bytes32 dataHash_ = dataHash;\\n        uint256 dataLength = data.length;\\n        uint256 afterDelayedMessagesRead_ = afterDelayedMessagesRead;\\n        uint256 prevMessageCount_ = prevMessageCount;\\n        uint256 newMessageCount_ = newMessageCount;\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(\\n                dataHash_,\\n                afterDelayedMessagesRead_,\\n                dataLength,\\n                prevMessageCount_,\\n                newMessageCount_\\n            );\\n\\n        // ~uint256(0) is type(uint256).max, but ever so slightly cheaper\\n        if (seqMessageIndex != sequenceNumber_ && sequenceNumber_ != ~uint256(0)) {\\n            revert BadSequencerNumber(seqMessageIndex, sequenceNumber_);\\n        }\\n\\n        emit SequencerBatchDelivered(\\n            seqMessageIndex,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds_,\\n            IBridge.BatchDataLocation.TxInput\\n        );\\n    }\\n\\n    function addSequencerL2BatchFromBlobs(\\n        uint256 sequenceNumber,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external refundsGas(gasRefunder, reader4844) {\\n        if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\\n        (\\n            bytes32 dataHash,\\n            IBridge.TimeBounds memory timeBounds,\\n            uint256 blobGas\\n        ) = formBlobDataHash(afterDelayedMessagesRead);\\n\\n        // we use addSequencerL2BatchImpl for submitting the message\\n        // normally this would also submit a batch spending report but that is skipped if we pass\\n        // an empty call data size, then we submit a separate batch spending report later\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(\\n                dataHash,\\n                afterDelayedMessagesRead,\\n                0,\\n                prevMessageCount,\\n                newMessageCount\\n            );\\n\\n        uint256 _sequenceNumber = sequenceNumber; // stack workaround\\n\\n        // ~uint256(0) is type(uint256).max, but ever so slightly cheaper\\n        if (seqMessageIndex != _sequenceNumber && _sequenceNumber != ~uint256(0)) {\\n            revert BadSequencerNumber(seqMessageIndex, _sequenceNumber);\\n        }\\n\\n        emit SequencerBatchDelivered(\\n            _sequenceNumber,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            IBridge.BatchDataLocation.Blob\\n        );\\n\\n        // blobs are currently not supported on host arbitrum chains, when support is added it may\\n        // consume gas in a different way to L1, so explicitly block host arb chains so that if support for blobs\\n        // on arb is added it will need to explicitly turned on in the sequencer inbox\\n        if (hostChainIsArbitrum) revert DataBlobsNotSupported();\\n\\n        // submit a batch spending report to refund the entity that produced the blob batch data\\n        // same as using calldata, we only submit spending report if the caller is the origin of the tx\\n        // such that one cannot \\\"double-claim\\\" batch posting refund in the same tx\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin && !isUsingFeeToken) {\\n            submitBatchSpendingReport(dataHash, seqMessageIndex, block.basefee, blobGas);\\n        }\\n    }\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external override refundsGas(gasRefunder, IReader4844(address(0))) {\\n        if (!isBatchPoster[msg.sender] && msg.sender != address(rollup)) revert NotBatchPoster();\\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formCallDataHash(\\n            data,\\n            afterDelayedMessagesRead\\n        );\\n        uint256 seqMessageIndex;\\n        {\\n            // Reformat the stack to prevent \\\"Stack too deep\\\"\\n            uint256 sequenceNumber_ = sequenceNumber;\\n            IBridge.TimeBounds memory timeBounds_ = timeBounds;\\n            bytes32 dataHash_ = dataHash;\\n            uint256 afterDelayedMessagesRead_ = afterDelayedMessagesRead;\\n            uint256 prevMessageCount_ = prevMessageCount;\\n            uint256 newMessageCount_ = newMessageCount;\\n            // we set the calldata length posted to 0 here since the caller isn't the origin\\n            // of the tx, so they might have not paid tx input cost for the calldata\\n            bytes32 beforeAcc;\\n            bytes32 delayedAcc;\\n            bytes32 afterAcc;\\n            (seqMessageIndex, beforeAcc, delayedAcc, afterAcc) = addSequencerL2BatchImpl(\\n                dataHash_,\\n                afterDelayedMessagesRead_,\\n                0,\\n                prevMessageCount_,\\n                newMessageCount_\\n            );\\n\\n            // ~uint256(0) is type(uint256).max, but ever so slightly cheaper\\n            if (seqMessageIndex != sequenceNumber_ && sequenceNumber_ != ~uint256(0)) {\\n                revert BadSequencerNumber(seqMessageIndex, sequenceNumber_);\\n            }\\n\\n            emit SequencerBatchDelivered(\\n                seqMessageIndex,\\n                beforeAcc,\\n                afterAcc,\\n                delayedAcc,\\n                totalDelayedMessagesRead,\\n                timeBounds_,\\n                IBridge.BatchDataLocation.SeparateBatchEvent\\n            );\\n        }\\n        emit SequencerBatchData(seqMessageIndex, data);\\n    }\\n\\n    function packHeader(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes memory, IBridge.TimeBounds memory)\\n    {\\n        IBridge.TimeBounds memory timeBounds = getTimeBounds();\\n        bytes memory header = abi.encodePacked(\\n            timeBounds.minTimestamp,\\n            timeBounds.maxTimestamp,\\n            timeBounds.minBlockNumber,\\n            timeBounds.maxBlockNumber,\\n            uint64(afterDelayedMessagesRead)\\n        );\\n        // This must always be true from the packed encoding\\n        assert(header.length == HEADER_LENGTH);\\n        return (header, timeBounds);\\n    }\\n\\n    /// @dev    Form a hash for a sequencer message with no batch data\\n    /// @param  afterDelayedMessagesRead The delayed messages count read up to\\n    /// @return The data hash\\n    /// @return The timebounds within which the message should be processed\\n    function formEmptyDataHash(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes32, IBridge.TimeBounds memory)\\n    {\\n        (bytes memory header, IBridge.TimeBounds memory timeBounds) = packHeader(\\n            afterDelayedMessagesRead\\n        );\\n        return (keccak256(header), timeBounds);\\n    }\\n\\n    /// @dev    Since the data is supplied from calldata, the batch poster can choose the data type\\n    ///         We need to ensure that this data cannot cause a collision with data supplied via another method (eg blobs)\\n    ///         therefore we restrict which flags can be provided as a header in this field\\n    ///         This also safe guards unused flags for future use, as we know they would have been disallowed up until this point\\n    /// @param  headerByte The first byte in the calldata\\n    function isValidCallDataFlag(bytes1 headerByte) internal pure returns (bool) {\\n        return\\n            headerByte == BROTLI_MESSAGE_HEADER_FLAG ||\\n            headerByte == DAS_MESSAGE_HEADER_FLAG ||\\n            (headerByte == (DAS_MESSAGE_HEADER_FLAG | TREE_DAS_MESSAGE_HEADER_FLAG)) ||\\n            headerByte == ZERO_HEAVY_MESSAGE_HEADER_FLAG;\\n    }\\n\\n    /// @dev    Form a hash of the data taken from the calldata\\n    /// @param  data The calldata to be hashed\\n    /// @param  afterDelayedMessagesRead The delayed messages count read up to\\n    /// @return The data hash\\n    /// @return The timebounds within which the message should be processed\\n    function formCallDataHash(bytes calldata data, uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes32, IBridge.TimeBounds memory)\\n    {\\n        uint256 fullDataLen = HEADER_LENGTH + data.length;\\n        if (fullDataLen > maxDataSize) revert DataTooLarge(fullDataLen, maxDataSize);\\n\\n        (bytes memory header, IBridge.TimeBounds memory timeBounds) = packHeader(\\n            afterDelayedMessagesRead\\n        );\\n\\n        // the batch poster is allowed to submit an empty batch, they can use this to progress the\\n        // delayed inbox without providing extra batch data\\n        if (data.length > 0) {\\n            // The first data byte cannot be the same as any that have been set via other methods (eg 4844 blob header) as this\\n            // would allow the supplier of the data to spoof an incorrect 4844 data batch\\n            if (!isValidCallDataFlag(data[0])) revert InvalidHeaderFlag(data[0]);\\n\\n            // the first byte is used to identify the type of batch data\\n            // das batches expect to have the type byte set, followed by the keyset (so they should have at least 33 bytes)\\n            // if invalid data is supplied here the state transition function will process it as an empty block\\n            // however we can provide a nice additional check here for the batch poster\\n            if (data[0] & DAS_MESSAGE_HEADER_FLAG != 0 && data.length >= 33) {\\n                // we skip the first byte, then read the next 32 bytes for the keyset\\n                bytes32 dasKeysetHash = bytes32(data[1:33]);\\n                if (!dasKeySetInfo[dasKeysetHash].isValidKeyset) revert NoSuchKeyset(dasKeysetHash);\\n            }\\n        }\\n        return (keccak256(bytes.concat(header, data)), timeBounds);\\n    }\\n\\n    /// @dev    Form a hash of the data being provided in 4844 data blobs\\n    /// @param  afterDelayedMessagesRead The delayed messages count read up to\\n    /// @return The data hash\\n    /// @return The timebounds within which the message should be processed\\n    /// @return The normalized amount of gas used for blob posting\\n    function formBlobDataHash(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (\\n            bytes32,\\n            IBridge.TimeBounds memory,\\n            uint256\\n        )\\n    {\\n        bytes32[] memory dataHashes = reader4844.getDataHashes();\\n        if (dataHashes.length == 0) revert MissingDataHashes();\\n\\n        (bytes memory header, IBridge.TimeBounds memory timeBounds) = packHeader(\\n            afterDelayedMessagesRead\\n        );\\n\\n        uint256 blobCost = reader4844.getBlobBaseFee() * GAS_PER_BLOB * dataHashes.length;\\n        return (\\n            keccak256(bytes.concat(header, DATA_BLOB_HEADER_FLAG, abi.encodePacked(dataHashes))),\\n            timeBounds,\\n            block.basefee > 0 ? blobCost / block.basefee : 0\\n        );\\n    }\\n\\n    /// @dev   Submit a batch spending report message so that the batch poster can be reimbursed on the rollup\\n    ///        This function expect msg.sender is tx.origin, and will always record tx.origin as the spender\\n    /// @param dataHash The hash of the message the spending report is being submitted for\\n    /// @param seqMessageIndex The index of the message to submit the spending report for\\n    /// @param gasPrice The gas price that was paid for the data (standard gas or data gas)\\n    function submitBatchSpendingReport(\\n        bytes32 dataHash,\\n        uint256 seqMessageIndex,\\n        uint256 gasPrice,\\n        uint256 extraGas\\n    ) internal {\\n        // report the account who paid the gas (tx.origin) for the tx as batch poster\\n        // if msg.sender is used and is a contract, it might not be able to spend the refund on l2\\n        // solhint-disable-next-line avoid-tx-origin\\n        address batchPoster = tx.origin;\\n\\n        // this msg isn't included in the current sequencer batch, but instead added to\\n        // the delayed messages queue that is yet to be included\\n        if (hostChainIsArbitrum) {\\n            // Include extra gas for the host chain's L1 gas charging\\n            uint256 l1Fees = ArbGasInfo(address(0x6c)).getCurrentTxL1GasFees();\\n            extraGas += l1Fees / block.basefee;\\n        }\\n        require(extraGas <= type(uint64).max, \\\"EXTRA_GAS_NOT_UINT64\\\");\\n        bytes memory spendingReportMsg = abi.encodePacked(\\n            block.timestamp,\\n            batchPoster,\\n            dataHash,\\n            seqMessageIndex,\\n            gasPrice,\\n            uint64(extraGas)\\n        );\\n\\n        uint256 msgNum = bridge.submitBatchSpendingReport(\\n            batchPoster,\\n            keccak256(spendingReportMsg)\\n        );\\n        // this is the same event used by Inbox.sol after including a message to the delayed message accumulator\\n        emit InboxMessageDelivered(msgNum, spendingReportMsg);\\n    }\\n\\n    function addSequencerL2BatchImpl(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 calldataLengthPosted,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    )\\n        internal\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        if (afterDelayedMessagesRead < totalDelayedMessagesRead) revert DelayedBackwards();\\n        if (afterDelayedMessagesRead > bridge.delayedMessageCount()) revert DelayedTooFar();\\n\\n        (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge.enqueueSequencerMessage(\\n            dataHash,\\n            afterDelayedMessagesRead,\\n            prevMessageCount,\\n            newMessageCount\\n        );\\n\\n        totalDelayedMessagesRead = afterDelayedMessagesRead;\\n\\n        if (calldataLengthPosted > 0 && !isUsingFeeToken) {\\n            // only report batch poster spendings if chain is using ETH as native currency\\n            submitBatchSpendingReport(dataHash, seqMessageIndex, block.basefee, 0);\\n        }\\n    }\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32) {\\n        return bridge.sequencerInboxAccs(index);\\n    }\\n\\n    function batchCount() external view returns (uint256) {\\n        return bridge.sequencerMessageCount();\\n    }\\n\\n    function _setMaxTimeVariation(ISequencerInbox.MaxTimeVariation memory maxTimeVariation_)\\n        internal\\n    {\\n        if (\\n            maxTimeVariation_.delayBlocks > type(uint64).max ||\\n            maxTimeVariation_.futureBlocks > type(uint64).max ||\\n            maxTimeVariation_.delaySeconds > type(uint64).max ||\\n            maxTimeVariation_.futureSeconds > type(uint64).max\\n        ) {\\n            revert BadMaxTimeVariation();\\n        }\\n        delayBlocks = uint64(maxTimeVariation_.delayBlocks);\\n        futureBlocks = uint64(maxTimeVariation_.futureBlocks);\\n        delaySeconds = uint64(maxTimeVariation_.delaySeconds);\\n        futureSeconds = uint64(maxTimeVariation_.futureSeconds);\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function setMaxTimeVariation(ISequencerInbox.MaxTimeVariation memory maxTimeVariation_)\\n        external\\n        onlyRollupOwner\\n    {\\n        _setMaxTimeVariation(maxTimeVariation_);\\n        emit OwnerFunctionCalled(0);\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function setIsBatchPoster(address addr, bool isBatchPoster_)\\n        external\\n        onlyRollupOwnerOrBatchPosterManager\\n    {\\n        isBatchPoster[addr] = isBatchPoster_;\\n        emit OwnerFunctionCalled(1);\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function setValidKeyset(bytes calldata keysetBytes) external onlyRollupOwner {\\n        uint256 ksWord = uint256(keccak256(bytes.concat(hex\\\"fe\\\", keccak256(keysetBytes))));\\n        bytes32 ksHash = bytes32(ksWord ^ (1 << 255));\\n        require(keysetBytes.length < 64 * 1024, \\\"keyset is too large\\\");\\n\\n        if (dasKeySetInfo[ksHash].isValidKeyset) revert AlreadyValidDASKeyset(ksHash);\\n        uint256 creationBlock = block.number;\\n        if (hostChainIsArbitrum) {\\n            creationBlock = ArbSys(address(100)).arbBlockNumber();\\n        }\\n        dasKeySetInfo[ksHash] = DasKeySetInfo({\\n            isValidKeyset: true,\\n            creationBlock: uint64(creationBlock)\\n        });\\n        emit SetValidKeyset(ksHash, keysetBytes);\\n        emit OwnerFunctionCalled(2);\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function invalidateKeysetHash(bytes32 ksHash) external onlyRollupOwner {\\n        if (!dasKeySetInfo[ksHash].isValidKeyset) revert NoSuchKeyset(ksHash);\\n        // we don't delete the block creation value since its used to fetch the SetValidKeyset\\n        // event efficiently. The event provides the hash preimage of the key.\\n        // this is still needed when syncing the chain after a keyset is invalidated.\\n        dasKeySetInfo[ksHash].isValidKeyset = false;\\n        emit InvalidateKeyset(ksHash);\\n        emit OwnerFunctionCalled(3);\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function setIsSequencer(address addr, bool isSequencer_)\\n        external\\n        onlyRollupOwnerOrBatchPosterManager\\n    {\\n        isSequencer[addr] = isSequencer_;\\n        emit OwnerFunctionCalled(4); // Owner in this context can also be batch poster manager\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function setBatchPosterManager(address newBatchPosterManager) external onlyRollupOwner {\\n        batchPosterManager = newBatchPosterManager;\\n        emit OwnerFunctionCalled(5);\\n    }\\n\\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool) {\\n        return dasKeySetInfo[ksHash].isValidKeyset;\\n    }\\n\\n    /// @inheritdoc ISequencerInbox\\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256) {\\n        DasKeySetInfo memory ksInfo = dasKeySetInfo[ksHash];\\n        if (ksInfo.creationBlock == 0) revert NoSuchKeyset(ksHash);\\n        return uint256(ksInfo.creationBlock);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/challenge/ChallengeLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\n\\nlibrary ChallengeLib {\\n    using MachineLib for Machine;\\n    using ChallengeLib for Challenge;\\n\\n    /// @dev It's assumed that that uninitialzed challenges have mode NONE\\n    enum ChallengeMode {\\n        NONE,\\n        BLOCK,\\n        EXECUTION\\n    }\\n\\n    struct Participant {\\n        address addr;\\n        uint256 timeLeft;\\n    }\\n\\n    struct Challenge {\\n        Participant current;\\n        Participant next;\\n        uint256 lastMoveTimestamp;\\n        bytes32 wasmModuleRoot;\\n        bytes32 challengeStateHash;\\n        uint64 maxInboxMessages;\\n        ChallengeMode mode;\\n    }\\n\\n    struct SegmentSelection {\\n        uint256 oldSegmentsStart;\\n        uint256 oldSegmentsLength;\\n        bytes32[] oldSegments;\\n        uint256 challengePosition;\\n    }\\n\\n    function timeUsedSinceLastMove(Challenge storage challenge) internal view returns (uint256) {\\n        return block.timestamp - challenge.lastMoveTimestamp;\\n    }\\n\\n    function isTimedOut(Challenge storage challenge) internal view returns (bool) {\\n        return challenge.timeUsedSinceLastMove() > challenge.current.timeLeft;\\n    }\\n\\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // Start the value stack with the function call ABI for the entrypoint\\n        Value[] memory startingValues = new Value[](3);\\n        startingValues[0] = ValueLib.newRefNull();\\n        startingValues[1] = ValueLib.newI32(0);\\n        startingValues[2] = ValueLib.newI32(0);\\n        ValueArray memory valuesArray = ValueArray({inner: startingValues});\\n        ValueStack memory values = ValueStack({proved: valuesArray, remainingHash: 0});\\n        ValueStack memory internalStack;\\n        StackFrameWindow memory frameStack;\\n\\n        Machine memory mach = Machine({\\n            status: MachineStatus.RUNNING,\\n            valueStack: values,\\n            internalStack: internalStack,\\n            frameStack: frameStack,\\n            globalStateHash: globalStateHash,\\n            moduleIdx: 0,\\n            functionIdx: 0,\\n            functionPc: 0,\\n            modulesRoot: wasmModuleRoot\\n        });\\n        return mach.hash();\\n    }\\n\\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n\\n    function extractChallengeSegment(SegmentSelection calldata selection)\\n        internal\\n        pure\\n        returns (uint256 segmentStart, uint256 segmentLength)\\n    {\\n        uint256 oldChallengeDegree = selection.oldSegments.length - 1;\\n        segmentLength = selection.oldSegmentsLength / oldChallengeDegree;\\n        // Intentionally done before challengeLength is potentially added to for the final segment\\n        segmentStart = selection.oldSegmentsStart + segmentLength * selection.challengePosition;\\n        if (selection.challengePosition == selection.oldSegments.length - 2) {\\n            segmentLength += selection.oldSegmentsLength % oldChallengeDegree;\\n        }\\n    }\\n\\n    function hashChallengeState(\\n        uint256 segmentsStart,\\n        uint256 segmentsLength,\\n        bytes32[] memory segments\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(segmentsStart, segmentsLength, segments));\\n    }\\n\\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Block state:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Block state, errored:\\\", globalStateHash));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Block state, too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeManager.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../osp/IOneStepProofEntry.sol\\\";\\n\\nimport \\\"./IChallengeResultReceiver.sol\\\";\\n\\nimport \\\"./ChallengeLib.sol\\\";\\n\\ninterface IChallengeManager {\\n    enum ChallengeTerminationType {\\n        TIMEOUT,\\n        BLOCK_PROOF,\\n        EXECUTION_PROOF,\\n        CLEARED\\n    }\\n\\n    event InitiatedChallenge(\\n        uint64 indexed challengeIndex,\\n        GlobalState startState,\\n        GlobalState endState\\n    );\\n\\n    event Bisected(\\n        uint64 indexed challengeIndex,\\n        bytes32 indexed challengeRoot,\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength,\\n        bytes32[] chainHashes\\n    );\\n\\n    event ExecutionChallengeBegun(uint64 indexed challengeIndex, uint256 blockSteps);\\n    event OneStepProofCompleted(uint64 indexed challengeIndex);\\n\\n    event ChallengeEnded(uint64 indexed challengeIndex, ChallengeTerminationType kind);\\n\\n    function initialize(\\n        IChallengeResultReceiver resultReceiver_,\\n        ISequencerInbox sequencerInbox_,\\n        IBridge bridge_,\\n        IOneStepProofEntry osp_\\n    ) external;\\n\\n    function createChallenge(\\n        bytes32 wasmModuleRoot_,\\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\\n        GlobalState[2] calldata startAndEndGlobalStates_,\\n        uint64 numBlocks,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) external returns (uint64);\\n\\n    function challengeInfo(uint64 challengeIndex_)\\n        external\\n        view\\n        returns (ChallengeLib.Challenge memory);\\n\\n    function currentResponder(uint64 challengeIndex) external view returns (address);\\n\\n    function isTimedOut(uint64 challengeIndex) external view returns (bool);\\n\\n    function clearChallenge(uint64 challengeIndex_) external;\\n\\n    function timeout(uint64 challengeIndex_) external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeResultReceiver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChallengeResultReceiver {\\n    function completeChallenge(\\n        uint256 challengeIndex,\\n        address winner,\\n        address loser\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/AddressAliasHelper.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + OFFSET);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - OFFSET);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ArbitrumChecker.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../precompiles/ArbSys.sol\\\";\\n\\nlibrary ArbitrumChecker {\\n    function runningOnArbitrum() internal view returns (bool) {\\n        (bool ok, bytes memory data) = address(100).staticcall(\\n            abi.encodeWithSelector(ArbSys.arbOSVersion.selector)\\n        );\\n        return ok && data.length == 32;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/DelegateCallAware.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {NotOwner} from \\\"./Error.sol\\\";\\n\\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\\nabstract contract DelegateCallAware {\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\\n     * callable on the proxy contract but not on the logic contract.\\n     */\\n    modifier onlyDelegated() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"Function must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\\n    modifier onlyProxyOwner() {\\n        // Storage slot with the admin of the proxy contract\\n        // This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n        address admin;\\n        assembly {\\n            admin := sload(slot)\\n        }\\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Init was already called\\nerror AlreadyInit();\\n\\n/// @dev Init was called with param set to zero that must be nonzero\\nerror HadZeroInit();\\n\\n/// @dev Thrown when post upgrade init validation fails\\nerror BadPostUpgradeInit();\\n\\n/// @dev Thrown when non owner tries to access an only-owner function\\n/// @param sender The msg.sender who is not the owner\\n/// @param owner The owner address\\nerror NotOwner(address sender, address owner);\\n\\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\\n/// @param sender The sender who is not the rollup\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\\nerror NotOrigin();\\n\\n/// @dev Provided data was too large\\n/// @param dataLength The length of the data that is too large\\n/// @param maxDataLength The max length the data can be\\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\\n\\n/// @dev The provided is not a contract and was expected to be\\n/// @param addr The adddress in question\\nerror NotContract(address addr);\\n\\n/// @dev The merkle proof provided was too long\\n/// @param actualLength The length of the merkle proof provided\\n/// @param maxProofLength The max length a merkle proof can have\\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\\n\\n/// @dev Thrown when an un-authorized address tries to access an admin function\\n/// @param sender The un-authorized sender\\n/// @param rollup The rollup, which would be authorized\\n/// @param owner The rollup's owner, which would be authorized\\nerror NotRollupOrOwner(address sender, address rollup, address owner);\\n\\n// Bridge Errors\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\\n/// @param sender The un-authorized sender\\nerror NotDelayedInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\\n/// @param sender The un-authorized sender\\nerror NotSequencerInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\\n/// @param sender The un-authorized sender\\nerror NotOutbox(address sender);\\n\\n/// @dev the provided outbox address isn't valid\\n/// @param outbox address of outbox being set\\nerror InvalidOutboxSet(address outbox);\\n\\n/// @dev The provided token address isn't valid\\n/// @param token address of token being set\\nerror InvalidTokenSet(address token);\\n\\n/// @dev Call to this specific address is not allowed\\n/// @param target address of the call receiver\\nerror CallTargetNotAllowed(address target);\\n\\n/// @dev Call that changes the balance of ERC20Bridge is not allowed\\nerror CallNotAllowed();\\n\\n// Inbox Errors\\n\\n/// @dev The contract is paused, so cannot be paused\\nerror AlreadyPaused();\\n\\n/// @dev The contract is unpaused, so cannot be unpaused\\nerror AlreadyUnpaused();\\n\\n/// @dev The contract is paused\\nerror Paused();\\n\\n/// @dev msg.value sent to the inbox isn't high enough\\nerror InsufficientValue(uint256 expected, uint256 actual);\\n\\n/// @dev submission cost provided isn't enough to create retryable ticket\\nerror InsufficientSubmissionCost(uint256 expected, uint256 actual);\\n\\n/// @dev address not allowed to interact with the given contract\\nerror NotAllowedOrigin(address origin);\\n\\n/// @dev used to convey retryable tx data in eth calls without requiring a tx trace\\n/// this follows a pattern similar to EIP-3668 where reverts surface call information\\nerror RetryableData(\\n    address from,\\n    address to,\\n    uint256 l2CallValue,\\n    uint256 deposit,\\n    uint256 maxSubmissionCost,\\n    address excessFeeRefundAddress,\\n    address callValueRefundAddress,\\n    uint256 gasLimit,\\n    uint256 maxFeePerGas,\\n    bytes data\\n);\\n\\n/// @dev Thrown when a L1 chainId fork is detected\\nerror L1Forked();\\n\\n/// @dev Thrown when a L1 chainId fork is not detected\\nerror NotForked();\\n\\n/// @dev The provided gasLimit is larger than uint64\\nerror GasLimitTooLarge();\\n\\n// Outbox Errors\\n\\n/// @dev The provided proof was too long\\n/// @param proofLength The length of the too-long proof\\nerror ProofTooLong(uint256 proofLength);\\n\\n/// @dev The output index was greater than the maximum\\n/// @param index The output index\\n/// @param maxIndex The max the index could be\\nerror PathNotMinimal(uint256 index, uint256 maxIndex);\\n\\n/// @dev The calculated root does not exist\\n/// @param root The calculated root\\nerror UnknownRoot(bytes32 root);\\n\\n/// @dev The record has already been spent\\n/// @param index The index of the spent record\\nerror AlreadySpent(uint256 index);\\n\\n/// @dev A call to the bridge failed with no return data\\nerror BridgeCallFailed();\\n\\n// Sequencer Inbox Errors\\n\\n/// @dev Thrown when someone attempts to read fewer messages than have already been read\\nerror DelayedBackwards();\\n\\n/// @dev Thrown when someone attempts to read more messages than exist\\nerror DelayedTooFar();\\n\\n/// @dev Force include can only read messages more blocks old than the delay period\\nerror ForceIncludeBlockTooSoon();\\n\\n/// @dev Force include can only read messages more seconds old than the delay period\\nerror ForceIncludeTimeTooSoon();\\n\\n/// @dev The message provided did not match the hash in the delayed inbox\\nerror IncorrectMessagePreimage();\\n\\n/// @dev This can only be called by the batch poster\\nerror NotBatchPoster();\\n\\n/// @dev The sequence number provided to this message was inconsistent with the number of batches already included\\nerror BadSequencerNumber(uint256 stored, uint256 received);\\n\\n/// @dev The sequence message number provided to this message was inconsistent with the previous one\\nerror BadSequencerMessageNumber(uint256 stored, uint256 received);\\n\\n/// @dev Tried to create an already valid Data Availability Service keyset\\nerror AlreadyValidDASKeyset(bytes32);\\n\\n/// @dev Tried to use or invalidate an already invalid Data Availability Service keyset\\nerror NoSuchKeyset(bytes32);\\n\\n/// @dev Thrown when the provided address is not the designated batch poster manager\\nerror NotBatchPosterManager(address);\\n\\n/// @dev Thrown when a data blob feature is attempted to be used on a chain that doesnt support it\\nerror DataBlobsNotSupported();\\n\\n/// @dev Thrown when an init param was supplied as empty\\nerror InitParamZero(string name);\\n\\n/// @dev Thrown when data hashes where expected but not where present on the tx\\nerror MissingDataHashes();\\n\\n/// @dev Thrown when rollup is not updated with updateRollupAddress\\nerror RollupNotChanged();\\n\\n/// @dev Unsupported header flag was provided\\nerror InvalidHeaderFlag(bytes1);\\n\\n/// @dev SequencerInbox and Bridge are not in the same feeToken/ETH mode\\nerror NativeTokenMismatch();\\n\\n/// @dev Thrown when a deprecated function is called\\nerror Deprecated();\\n\\n/// @dev Thrown when any component of maxTimeVariation is over uint64\\nerror BadMaxTimeVariation();\\n\"\r\n    },\r\n    \"src/libraries/GasRefundEnabled.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IReader4844.sol\\\";\\nimport \\\"./IGasRefunder.sol\\\";\\n\\nabstract contract GasRefundEnabled {\\n    uint256 internal immutable gasPerBlob = 2**17;\\n\\n    /// @dev this refunds the sender for execution costs of the tx\\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\\n    modifier refundsGas(IGasRefunder gasRefunder, IReader4844 reader4844) {\\n        uint256 startGasLeft = gasleft();\\n        _;\\n        if (address(gasRefunder) != address(0)) {\\n            uint256 calldataSize = msg.data.length;\\n            uint256 calldataWords = (calldataSize + 31) / 32;\\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\\n            // solhint-disable-next-line avoid-tx-origin\\n            if (msg.sender != tx.origin) {\\n                // We can't be sure if this calldata came from the top level tx,\\n                // so to be safe we tell the gas refunder there was no calldata.\\n                calldataSize = 0;\\n            } else {\\n                // for similar reasons to above we only refund blob gas when the tx.origin is the msg.sender\\n                // this avoids the caller being able to send blobs to other contracts and still get refunded here\\n                if (address(reader4844) != address(0)) {\\n                    // add any cost for 4844 data, the data hash reader throws an error prior to 4844 being activated\\n                    // we do this addition here rather in the GasRefunder so that we can check the msg.sender is the tx.origin\\n                    try reader4844.getDataHashes() returns (bytes32[] memory dataHashes) {\\n                        if (dataHashes.length != 0) {\\n                            uint256 blobBasefee = reader4844.getBlobBaseFee();\\n                            startGasLeft +=\\n                                (dataHashes.length * gasPerBlob * blobBasefee) /\\n                                block.basefee;\\n                        }\\n                    } catch {}\\n                }\\n            }\\n\\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/IGasRefunder.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IGasRefunder {\\n    function onGasSpent(\\n        address payable spender,\\n        uint256 gasUsed,\\n        uint256 calldataSize\\n    ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/libraries/IReader4844.sol\": {\r\n      \"content\": \"// Copyright 2023-2024, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IReader4844 {\\n    /// @notice Returns the current BLOBBASEFEE\\n    function getBlobBaseFee() external view returns (uint256);\\n\\n    /// @notice Returns all the data hashes of all the blobs on the current transaction\\n    function getDataHashes() external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"src/libraries/MerkleLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {MerkleProofTooLong} from \\\"./Error.sol\\\";\\n\\nlibrary MerkleLib {\\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\\n        bytes32[] memory prevLayer = _hashes;\\n        while (prevLayer.length > 1) {\\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\\n            for (uint256 i = 0; i < nextLayer.length; i++) {\\n                if (2 * i + 1 < prevLayer.length) {\\n                    nextLayer[i] = keccak256(\\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\\n                    );\\n                } else {\\n                    nextLayer[i] = prevLayer[2 * i];\\n                }\\n            }\\n            prevLayer = nextLayer;\\n        }\\n        return prevLayer[0];\\n    }\\n\\n    function calculateRoot(\\n        bytes32[] memory nodes,\\n        uint256 route,\\n        bytes32 item\\n    ) internal pure returns (bytes32) {\\n        uint256 proofItems = nodes.length;\\n        if (proofItems > 256) revert MerkleProofTooLong(proofItems, 256);\\n        bytes32 h = item;\\n        for (uint256 i = 0; i < proofItems; ) {\\n            bytes32 node = nodes[i];\\n            if ((route & (1 << i)) == 0) {\\n                assembly {\\n                    mstore(0x00, h)\\n                    mstore(0x20, node)\\n                    h := keccak256(0x00, 0x40)\\n                }\\n            } else {\\n                assembly {\\n                    mstore(0x00, node)\\n                    mstore(0x20, h)\\n                    h := keccak256(0x00, 0x40)\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/MessageTypes.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nuint8 constant L2_MSG = 3;\\nuint8 constant L1MessageType_L2FundedByL1 = 7;\\nuint8 constant L1MessageType_submitRetryableTx = 9;\\nuint8 constant L1MessageType_ethDeposit = 12;\\nuint8 constant L1MessageType_batchPostingReport = 13;\\nuint8 constant L2MessageType_unsignedEOATx = 0;\\nuint8 constant L2MessageType_unsignedContractTx = 1;\\n\\nuint8 constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\\nuint8 constant INITIALIZATION_MSG_TYPE = 11;\\n\"\r\n    },\r\n    \"src/osp/IOneStepProofEntry.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOneStepProver.sol\\\";\\n\\nlibrary OneStepProofEntryLib {\\n    uint256 internal constant MAX_STEPS = 1 << 43;\\n}\\n\\ninterface IOneStepProofEntry {\\n    function proveOneStep(\\n        ExecutionContext calldata execCtx,\\n        uint256 machineStep,\\n        bytes32 beforeHash,\\n        bytes calldata proof\\n    ) external view returns (bytes32 afterHash);\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Module.sol\\\";\\nimport \\\"../state/Instructions.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\nstruct ExecutionContext {\\n    uint256 maxInboxMessagesRead;\\n    IBridge bridge;\\n}\\n\\nabstract contract IOneStepProver {\\n    function executeOneStep(\\n        ExecutionContext memory execCtx,\\n        Machine calldata mach,\\n        Module calldata mod,\\n        Instruction calldata instruction,\\n        bytes calldata proof\\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\\n}\\n\"\r\n    },\r\n    \"src/precompiles/ArbGasInfo.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/// @title Provides insight into the cost of using the chain.\\n/// @notice These methods have been adjusted to account for Nitro's heavy use of calldata compression.\\n/// Of note to end-users, we no longer make a distinction between non-zero and zero-valued calldata bytes.\\n/// Precompiled contract that exists in every Arbitrum chain at 0x000000000000000000000000000000000000006c.\\ninterface ArbGasInfo {\\n    /// @notice Get gas prices for a provided aggregator\\n    /// @return return gas prices in wei\\n    ///        (\\n    ///            per L2 tx,\\n    ///            per L1 calldata byte\\n    ///            per storage allocation,\\n    ///            per ArbGas base,\\n    ///            per ArbGas congestion,\\n    ///            per ArbGas total\\n    ///        )\\n    function getPricesInWeiWithAggregator(address aggregator)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get gas prices. Uses the caller's preferred aggregator, or the default if the caller doesn't have a preferred one.\\n    /// @return return gas prices in wei\\n    ///        (\\n    ///            per L2 tx,\\n    ///            per L1 calldata byte\\n    ///            per storage allocation,\\n    ///            per ArbGas base,\\n    ///            per ArbGas congestion,\\n    ///            per ArbGas total\\n    ///        )\\n    function getPricesInWei()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get prices in ArbGas for the supplied aggregator\\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\\n    function getPricesInArbGasWithAggregator(address aggregator)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get prices in ArbGas. Assumes the callers preferred validator, or the default if caller doesn't have a preferred one.\\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\\n    function getPricesInArbGas()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get the gas accounting parameters. `gasPoolMax` is always zero, as the exponential pricing model has no such notion.\\n    /// @return (speedLimitPerSecond, gasPoolMax, maxTxGasLimit)\\n    function getGasAccountingParams()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get the minimum gas price needed for a tx to succeed\\n    function getMinimumGasPrice() external view returns (uint256);\\n\\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\\n    function getL1BaseFeeEstimate() external view returns (uint256);\\n\\n    /// @notice Get how slowly ArbOS updates its estimate of the L1 basefee\\n    function getL1BaseFeeEstimateInertia() external view returns (uint64);\\n\\n    /// @notice Get the L1 pricer reward rate, in wei per unit\\n    /// Available in ArbOS version 11\\n    function getL1RewardRate() external view returns (uint64);\\n\\n    /// @notice Get the L1 pricer reward recipient\\n    /// Available in ArbOS version 11\\n    function getL1RewardRecipient() external view returns (address);\\n\\n    /// @notice Deprecated -- Same as getL1BaseFeeEstimate()\\n    function getL1GasPriceEstimate() external view returns (uint256);\\n\\n    /// @notice Get L1 gas fees paid by the current transaction\\n    function getCurrentTxL1GasFees() external view returns (uint256);\\n\\n    /// @notice Get the backlogged amount of gas burnt in excess of the speed limit\\n    function getGasBacklog() external view returns (uint64);\\n\\n    /// @notice Get how slowly ArbOS updates the L2 basefee in response to backlogged gas\\n    function getPricingInertia() external view returns (uint64);\\n\\n    /// @notice Get the forgivable amount of backlogged gas ArbOS will ignore when raising the basefee\\n    function getGasBacklogTolerance() external view returns (uint64);\\n\\n    /// @notice Returns the surplus of funds for L1 batch posting payments (may be negative).\\n    function getL1PricingSurplus() external view returns (int256);\\n\\n    /// @notice Returns the base charge (in L1 gas) attributed to each data batch in the calldata pricer\\n    function getPerBatchGasCharge() external view returns (int64);\\n\\n    /// @notice Returns the cost amortization cap in basis points\\n    function getAmortizedCostCapBips() external view returns (uint64);\\n\\n    /// @notice Returns the available funds from L1 fees\\n    function getL1FeesAvailable() external view returns (uint256);\\n\\n    /// @notice Returns the equilibration units parameter for L1 price adjustment algorithm\\n    /// Available in ArbOS version 20\\n    function getL1PricingEquilibrationUnits() external view returns (uint256);\\n\\n    /// @notice Returns the last time the L1 calldata pricer was updated.\\n    /// Available in ArbOS version 20\\n    function getLastL1PricingUpdateTime() external view returns (uint64);\\n\\n    /// @notice Returns the amount of L1 calldata payments due for rewards (per the L1 reward rate)\\n    /// Available in ArbOS version 20\\n    function getL1PricingFundsDueForRewards() external view returns (uint256);\\n\\n    /// @notice Returns the amount of L1 calldata posted since the last update.\\n    /// Available in ArbOS version 20\\n    function getL1PricingUnitsSinceUpdate() external view returns (uint64);\\n\\n    /// @notice Returns the L1 pricing surplus as of the last update (may be negative).\\n    /// Available in ArbOS version 20\\n    function getLastL1PricingSurplus() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"src/precompiles/ArbSys.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title System level functionality\\n * @notice For use by contracts to interact with core L2-specific functionality.\\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\\n */\\ninterface ArbSys {\\n    /**\\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n     * @return block number as int\\n     */\\n    function arbBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * @notice Get Arbitrum block hash (reverts unless currentBlockNum-256 <= arbBlockNum < currentBlockNum)\\n     * @return block hash\\n     */\\n    function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);\\n\\n    /**\\n     * @notice Gets the rollup's unique chain identifier\\n     * @return Chain identifier as int\\n     */\\n    function arbChainID() external view returns (uint256);\\n\\n    /**\\n     * @notice Get internal version number identifying an ArbOS build\\n     * @return version number as int\\n     */\\n    function arbOSVersion() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns 0 since Nitro has no concept of storage gas\\n     * @return uint 0\\n     */\\n    function getStorageGasAvailable() external view returns (uint256);\\n\\n    /**\\n     * @notice (deprecated) check if current call is top level (meaning it was triggered by an EoA or a L1 contract)\\n     * @dev this call has been deprecated and may be removed in a future release\\n     * @return true if current execution frame is not a call by another L2 contract\\n     */\\n    function isTopLevelCall() external view returns (bool);\\n\\n    /**\\n     * @notice map L1 sender contract address to its L2 alias\\n     * @param sender sender address\\n     * @param unused argument no longer used\\n     * @return aliased sender address\\n     */\\n    function mapL1SenderContractAddressToL2Alias(address sender, address unused)\\n        external\\n        pure\\n        returns (address);\\n\\n    /**\\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\\n     * @return true iff the caller's address is an alias for an L1 contract address\\n     */\\n    function wasMyCallersAddressAliased() external view returns (bool);\\n\\n    /**\\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\\n     * @return address of the caller's caller, without applying L1 contract address aliasing\\n     */\\n    function myCallersAddressWithoutAliasing() external view returns (address);\\n\\n    /**\\n     * @notice Send given amount of Eth to dest from sender.\\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty data.\\n     * @param destination recipient address on L1\\n     * @return unique identifier for this L2-to-L1 transaction.\\n     */\\n    function withdrawEth(address destination) external payable returns (uint256);\\n\\n    /**\\n     * @notice Send a transaction to L1\\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\\n     * to a contract address without any code (as enforced by the Bridge contract).\\n     * @param destination recipient address on L1\\n     * @param data (optional) calldata for L1 contract call\\n     * @return a unique identifier for this L2-to-L1 transaction.\\n     */\\n    function sendTxToL1(address destination, bytes calldata data)\\n        external\\n        payable\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get send Merkle tree state\\n     * @return size number of sends in the history\\n     * @return root root hash of the send history\\n     * @return partials hashes of partial subtrees in the send history tree\\n     */\\n    function sendMerkleTreeState()\\n        external\\n        view\\n        returns (\\n            uint256 size,\\n            bytes32 root,\\n            bytes32[] memory partials\\n        );\\n\\n    /**\\n     * @notice creates a send txn from L2 to L1\\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\\n     */\\n    event L2ToL1Tx(\\n        address caller,\\n        address indexed destination,\\n        uint256 indexed hash,\\n        uint256 indexed position,\\n        uint256 arbBlockNum,\\n        uint256 ethBlockNum,\\n        uint256 timestamp,\\n        uint256 callvalue,\\n        bytes data\\n    );\\n\\n    /// @dev DEPRECATED in favour of the new L2ToL1Tx event above after the nitro upgrade\\n    event L2ToL1Transaction(\\n        address caller,\\n        address indexed destination,\\n        uint256 indexed uniqueId,\\n        uint256 indexed batchNumber,\\n        uint256 indexInBatch,\\n        uint256 arbBlockNum,\\n        uint256 ethBlockNum,\\n        uint256 timestamp,\\n        uint256 callvalue,\\n        bytes data\\n    );\\n\\n    /**\\n     * @notice logs a merkle branch for proof synthesis\\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\\n     * @param hash the merkle hash\\n     * @param position = (level << 192) + leaf\\n     */\\n    event SendMerkleUpdate(\\n        uint256 indexed reserved,\\n        bytes32 indexed hash,\\n        uint256 indexed position\\n    );\\n\\n    error InvalidBlockNumber(uint256 requested, uint256 current);\\n}\\n\"\r\n    },\r\n    \"src/rollup/AbsRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IEthBridge.sol\\\";\\nimport \\\"../precompiles/ArbGasInfo.sol\\\";\\nimport \\\"../libraries/ArbitrumChecker.sol\\\";\\nimport \\\"../bridge/IDelayedMessageProvider.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {INITIALIZATION_MSG_TYPE} from \\\"../libraries/MessageTypes.sol\\\";\\nimport {AlreadyInit, HadZeroInit, RollupNotChanged} from \\\"../libraries/Error.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\nabstract contract AbsRollupEventInbox is\\n    IRollupEventInbox,\\n    IDelayedMessageProvider,\\n    DelegateCallAware\\n{\\n    IBridge public override bridge;\\n    address public override rollup;\\n\\n    modifier onlyRollup() {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        _;\\n    }\\n\\n    function initialize(IBridge _bridge) external override onlyDelegated {\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        if (address(_bridge) == address(0)) revert HadZeroInit();\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    /// @notice Allows the rollup owner to sync the rollup address\\n    function updateRollupAddress() external {\\n        if (msg.sender != IOwnable(rollup).owner())\\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\\n        address newRollup = address(bridge.rollup());\\n        if (rollup == newRollup) revert RollupNotChanged();\\n        rollup = newRollup;\\n    }\\n\\n    function rollupInitialized(uint256 chainId, string calldata chainConfig)\\n        external\\n        override\\n        onlyRollup\\n    {\\n        require(bytes(chainConfig).length > 0, \\\"EMPTY_CHAIN_CONFIG\\\");\\n        uint8 initMsgVersion = 1;\\n        uint256 currentDataCost = block.basefee;\\n        if (ArbitrumChecker.runningOnArbitrum()) {\\n            currentDataCost += ArbGasInfo(address(0x6c)).getL1BaseFeeEstimate();\\n        }\\n        bytes memory initMsg = abi.encodePacked(\\n            chainId,\\n            initMsgVersion,\\n            currentDataCost,\\n            chainConfig\\n        );\\n        uint256 num = _enqueueInitializationMsg(initMsg);\\n        emit InboxMessageDelivered(num, initMsg);\\n    }\\n\\n    function _enqueueInitializationMsg(bytes memory initMsg) internal virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/rollup/BridgeCreator.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/Bridge.sol\\\";\\nimport \\\"../bridge/SequencerInbox.sol\\\";\\nimport \\\"../bridge/Inbox.sol\\\";\\nimport \\\"../bridge/Outbox.sol\\\";\\nimport \\\"./RollupEventInbox.sol\\\";\\nimport \\\"../bridge/ERC20Bridge.sol\\\";\\nimport \\\"../bridge/ERC20Inbox.sol\\\";\\nimport \\\"../rollup/ERC20RollupEventInbox.sol\\\";\\nimport \\\"../bridge/ERC20Outbox.sol\\\";\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\\\";\\n\\ncontract BridgeCreator is Ownable {\\n    BridgeContracts public ethBasedTemplates;\\n    BridgeContracts public erc20BasedTemplates;\\n\\n    event TemplatesUpdated();\\n    event ERC20TemplatesUpdated();\\n\\n    struct BridgeContracts {\\n        IBridge bridge;\\n        ISequencerInbox sequencerInbox;\\n        IInboxBase inbox;\\n        IRollupEventInbox rollupEventInbox;\\n        IOutbox outbox;\\n    }\\n\\n    constructor(\\n        BridgeContracts memory _ethBasedTemplates,\\n        BridgeContracts memory _erc20BasedTemplates\\n    ) Ownable() {\\n        ethBasedTemplates = _ethBasedTemplates;\\n        erc20BasedTemplates = _erc20BasedTemplates;\\n    }\\n\\n    function updateTemplates(BridgeContracts calldata _newTemplates) external onlyOwner {\\n        ethBasedTemplates = _newTemplates;\\n        emit TemplatesUpdated();\\n    }\\n\\n    function updateERC20Templates(BridgeContracts calldata _newTemplates) external onlyOwner {\\n        erc20BasedTemplates = _newTemplates;\\n        emit ERC20TemplatesUpdated();\\n    }\\n\\n    function _createBridge(address adminProxy, BridgeContracts storage templates)\\n        internal\\n        returns (BridgeContracts memory)\\n    {\\n        BridgeContracts memory frame;\\n        frame.bridge = IBridge(\\n            address(new TransparentUpgradeableProxy(address(templates.bridge), adminProxy, \\\"\\\"))\\n        );\\n        frame.sequencerInbox = ISequencerInbox(\\n            address(\\n                new TransparentUpgradeableProxy(address(templates.sequencerInbox), adminProxy, \\\"\\\")\\n            )\\n        );\\n        frame.inbox = IInboxBase(\\n            address(new TransparentUpgradeableProxy(address(templates.inbox), adminProxy, \\\"\\\"))\\n        );\\n        frame.rollupEventInbox = IRollupEventInbox(\\n            address(\\n                new TransparentUpgradeableProxy(address(templates.rollupEventInbox), adminProxy, \\\"\\\")\\n            )\\n        );\\n        frame.outbox = IOutbox(\\n            address(new TransparentUpgradeableProxy(address(templates.outbox), adminProxy, \\\"\\\"))\\n        );\\n        return frame;\\n    }\\n\\n    function createBridge(\\n        address adminProxy,\\n        address rollup,\\n        address nativeToken,\\n        ISequencerInbox.MaxTimeVariation calldata maxTimeVariation\\n    ) external returns (BridgeContracts memory) {\\n        // create ETH-based bridge if address zero is provided for native token, otherwise create ERC20-based bridge\\n        BridgeContracts memory frame = _createBridge(\\n            adminProxy,\\n            nativeToken == address(0) ? ethBasedTemplates : erc20BasedTemplates\\n        );\\n\\n        // init contracts\\n        if (nativeToken == address(0)) {\\n            IEthBridge(address(frame.bridge)).initialize(IOwnable(rollup));\\n        } else {\\n            IERC20Bridge(address(frame.bridge)).initialize(IOwnable(rollup), nativeToken);\\n        }\\n        frame.sequencerInbox.initialize(IBridge(frame.bridge), maxTimeVariation);\\n        frame.inbox.initialize(frame.bridge, frame.sequencerInbox);\\n        frame.rollupEventInbox.initialize(frame.bridge);\\n        frame.outbox.initialize(frame.bridge);\\n\\n        return frame;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/ERC20RollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AbsRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IERC20Bridge.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\ncontract ERC20RollupEventInbox is AbsRollupEventInbox {\\n    constructor() AbsRollupEventInbox() {}\\n\\n    function _enqueueInitializationMsg(bytes memory initMsg) internal override returns (uint256) {\\n        uint256 tokenAmount = 0;\\n        return\\n            IERC20Bridge(address(bridge)).enqueueDelayedMessage(\\n                INITIALIZATION_MSG_TYPE,\\n                address(0),\\n                keccak256(initMsg),\\n                tokenAmount\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupCore.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Node.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IInboxBase.sol\\\";\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\n\\ninterface IRollupCore {\\n    struct Staker {\\n        uint256 amountStaked;\\n        uint64 index;\\n        uint64 latestStakedNode;\\n        // currentChallenge is 0 if staker is not in a challenge\\n        uint64 currentChallenge;\\n        bool isStaked;\\n    }\\n\\n    event RollupInitialized(bytes32 machineHash, uint256 chainId);\\n\\n    event NodeCreated(\\n        uint64 indexed nodeNum,\\n        bytes32 indexed parentNodeHash,\\n        bytes32 indexed nodeHash,\\n        bytes32 executionHash,\\n        Assertion assertion,\\n        bytes32 afterInboxBatchAcc,\\n        bytes32 wasmModuleRoot,\\n        uint256 inboxMaxCount\\n    );\\n\\n    event NodeConfirmed(uint64 indexed nodeNum, bytes32 blockHash, bytes32 sendRoot);\\n\\n    event NodeRejected(uint64 indexed nodeNum);\\n\\n    event RollupChallengeStarted(\\n        uint64 indexed challengeIndex,\\n        address asserter,\\n        address challenger,\\n        uint64 challengedNode\\n    );\\n\\n    event UserStakeUpdated(address indexed user, uint256 initialBalance, uint256 finalBalance);\\n\\n    event UserWithdrawableFundsUpdated(\\n        address indexed user,\\n        uint256 initialBalance,\\n        uint256 finalBalance\\n    );\\n\\n    function confirmPeriodBlocks() external view returns (uint64);\\n\\n    function extraChallengeTimeBlocks() external view returns (uint64);\\n\\n    function chainId() external view returns (uint256);\\n\\n    function baseStake() external view returns (uint256);\\n\\n    function wasmModuleRoot() external view returns (bytes32);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    function outbox() external view returns (IOutbox);\\n\\n    function rollupEventInbox() external view returns (IRollupEventInbox);\\n\\n    function challengeManager() external view returns (IChallengeManager);\\n\\n    function loserStakeEscrow() external view returns (address);\\n\\n    function stakeToken() external view returns (address);\\n\\n    function minimumAssertionPeriod() external view returns (uint256);\\n\\n    function isValidator(address) external view returns (bool);\\n\\n    function validatorWhitelistDisabled() external view returns (bool);\\n\\n    /**\\n     * @notice Get the Node for the given index.\\n     */\\n    function getNode(uint64 nodeNum) external view returns (Node memory);\\n\\n    /**\\n     * @notice Returns the block in which the given node was created for looking up its creation event.\\n     * Unlike the Node's createdAtBlock field, this will be the ArbSys blockNumber if the host chain is an Arbitrum chain.\\n     * That means that the block number returned for this is usable for event queries.\\n     * This function will revert if the given node number does not exist.\\n     * @dev This function is meant for internal use only and has no stability guarantees.\\n     */\\n    function getNodeCreationBlockForLogLookup(uint64 nodeNum) external view returns (uint256);\\n\\n    /**\\n     * @notice Check if the specified node has been staked on by the provided staker.\\n     * Only accurate at the latest confirmed node and afterwards.\\n     */\\n    function nodeHasStaker(uint64 nodeNum, address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint64 stakerNum) external view returns (address);\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves stored information about a requested staker\\n     * @param staker Staker address to retrieve\\n     * @return A structure with information about the requested staker\\n     */\\n    function getStaker(address staker) external view returns (Staker memory);\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) external view returns (address);\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint64);\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() external view returns (uint256);\\n\\n    function isZombie(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param owner Address to check the funds of\\n     * @return Amount of funds withdrawable by owner\\n     */\\n    function withdrawableFunds(address owner) external view returns (uint256);\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() external view returns (uint64);\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() external view returns (uint64);\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() external view returns (uint64);\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() external view returns (uint64);\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ninterface IRollupEventInbox {\\n    function bridge() external view returns (IBridge);\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address);\\n\\n    function updateRollupAddress() external;\\n\\n    function rollupInitialized(uint256 chainId, string calldata chainConfig) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupLogic.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IOwnable.sol\\\";\\n\\ninterface IRollupUserAbs is IRollupCore, IOwnable {\\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\\n    /// this allows the admin logic to ensure consistency on parameters.\\n    function initialize(address stakeToken) external view;\\n\\n    function removeWhitelistAfterFork() external;\\n\\n    function removeWhitelistAfterValidatorAfk() external;\\n\\n    function isERC20Enabled() external view returns (bool);\\n\\n    function rejectNextNode(address stakerAddress) external;\\n\\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot) external;\\n\\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external;\\n\\n    function stakeOnNewNode(\\n        Assertion memory assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function returnOldDeposit(address stakerAddress) external;\\n\\n    function reduceDeposit(uint256 target) external;\\n\\n    function removeZombie(uint256 zombieNum, uint256 maxNodes) external;\\n\\n    function removeOldZombies(uint256 startIndex) external;\\n\\n    function requiredStake(\\n        uint256 blockNumber,\\n        uint64 firstUnresolvedNodeNum,\\n        uint64 latestCreatedNode\\n    ) external view returns (uint256);\\n\\n    function currentRequiredStake() external view returns (uint256);\\n\\n    function countStakedZombies(uint64 nodeNum) external view returns (uint256);\\n\\n    function countZombiesStakedOnChildren(uint64 nodeNum) external view returns (uint256);\\n\\n    function requireUnresolvedExists() external view;\\n\\n    function requireUnresolved(uint256 nodeNum) external view;\\n\\n    function withdrawStakerFunds() external returns (uint256);\\n\\n    function createChallenge(\\n        address[2] calldata stakers,\\n        uint64[2] calldata nodeNums,\\n        MachineStatus[2] calldata machineStatuses,\\n        GlobalState[2] calldata globalStates,\\n        uint64 numBlocks,\\n        bytes32 secondExecutionHash,\\n        uint256[2] calldata proposedTimes,\\n        bytes32[2] calldata wasmModuleRoots\\n    ) external;\\n}\\n\\ninterface IRollupUser is IRollupUserAbs {\\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable;\\n\\n    function newStakeOnNewNode(\\n        Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external payable;\\n\\n    function addToDeposit(address stakerAddress) external payable;\\n}\\n\\ninterface IRollupUserERC20 is IRollupUserAbs {\\n    function newStakeOnExistingNode(\\n        uint256 tokenAmount,\\n        uint64 nodeNum,\\n        bytes32 nodeHash\\n    ) external;\\n\\n    function newStakeOnNewNode(\\n        uint256 tokenAmount,\\n        Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function addToDeposit(address stakerAddress, uint256 tokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/Node.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\n\\nstruct ExecutionState {\\n    GlobalState globalState;\\n    MachineStatus machineStatus;\\n}\\n\\nstruct Assertion {\\n    ExecutionState beforeState;\\n    ExecutionState afterState;\\n    uint64 numBlocks;\\n}\\n\\nstruct Node {\\n    // Hash of the state of the chain as of this node\\n    bytes32 stateHash;\\n    // Hash of the data that can be challenged\\n    bytes32 challengeHash;\\n    // Hash of the data that will be committed if this node is confirmed\\n    bytes32 confirmData;\\n    // Index of the node previous to this one\\n    uint64 prevNum;\\n    // Deadline at which this node can be confirmed\\n    uint64 deadlineBlock;\\n    // Deadline at which a child of this node can be confirmed\\n    uint64 noChildConfirmedBeforeBlock;\\n    // Number of stakers staked on this node. This includes real stakers and zombies\\n    uint64 stakerCount;\\n    // Number of stakers staked on a child node. This includes real stakers and zombies\\n    uint64 childStakerCount;\\n    // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\\n    uint64 firstChildBlock;\\n    // The number of the latest child of this node to be created\\n    uint64 latestChildNumber;\\n    // The block number when this node was created\\n    uint64 createdAtBlock;\\n    // A hash of all the data needed to determine this node's validity, to protect against reorgs\\n    bytes32 nodeHash;\\n}\\n\\n/**\\n * @notice Utility functions for Node\\n */\\nlibrary NodeLib {\\n    /**\\n     * @notice Initialize a Node\\n     * @param _stateHash Initial value of stateHash\\n     * @param _challengeHash Initial value of challengeHash\\n     * @param _confirmData Initial value of confirmData\\n     * @param _prevNum Initial value of prevNum\\n     * @param _deadlineBlock Initial value of deadlineBlock\\n     * @param _nodeHash Initial value of nodeHash\\n     */\\n    function createNode(\\n        bytes32 _stateHash,\\n        bytes32 _challengeHash,\\n        bytes32 _confirmData,\\n        uint64 _prevNum,\\n        uint64 _deadlineBlock,\\n        bytes32 _nodeHash\\n    ) internal view returns (Node memory) {\\n        Node memory node;\\n        node.stateHash = _stateHash;\\n        node.challengeHash = _challengeHash;\\n        node.confirmData = _confirmData;\\n        node.prevNum = _prevNum;\\n        node.deadlineBlock = _deadlineBlock;\\n        node.noChildConfirmedBeforeBlock = _deadlineBlock;\\n        node.createdAtBlock = uint64(block.number);\\n        node.nodeHash = _nodeHash;\\n        return node;\\n    }\\n\\n    /**\\n     * @notice Update child properties\\n     * @param number The child number to set\\n     */\\n    function childCreated(Node storage self, uint64 number) internal {\\n        if (self.firstChildBlock == 0) {\\n            self.firstChildBlock = uint64(block.number);\\n        }\\n        self.latestChildNumber = number;\\n    }\\n\\n    /**\\n     * @notice Update the child confirmed deadline\\n     * @param deadline The new deadline to set\\n     */\\n    function newChildConfirmDeadline(Node storage self, uint64 deadline) internal {\\n        self.noChildConfirmedBeforeBlock = deadline;\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed the node's deadline\\n     */\\n    function requirePastDeadline(Node memory self) internal view {\\n        require(block.number >= self.deadlineBlock, \\\"BEFORE_DEADLINE\\\");\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed deadline for children of this node to be confirmed\\n     */\\n    function requirePastChildConfirmDeadline(Node memory self) internal view {\\n        require(block.number >= self.noChildConfirmedBeforeBlock, \\\"CHILD_TOO_RECENT\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AbsRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IEthBridge.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\ncontract RollupEventInbox is AbsRollupEventInbox {\\n    constructor() AbsRollupEventInbox() {}\\n\\n    function _enqueueInitializationMsg(bytes memory initMsg) internal override returns (uint256) {\\n        return\\n            IEthBridge(address(bridge)).enqueueDelayedMessage(\\n                INITIALIZATION_MSG_TYPE,\\n                address(0),\\n                keccak256(initMsg)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/GlobalState.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct GlobalState {\\n    bytes32[2] bytes32Vals;\\n    uint64[2] u64Vals;\\n}\\n\\nlibrary GlobalStateLib {\\n    uint16 internal constant BYTES32_VALS_NUM = 2;\\n    uint16 internal constant U64_VALS_NUM = 2;\\n\\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Global state:\\\",\\n                    state.bytes32Vals[0],\\n                    state.bytes32Vals[1],\\n                    state.u64Vals[0],\\n                    state.u64Vals[1]\\n                )\\n            );\\n    }\\n\\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[0];\\n    }\\n\\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[1];\\n    }\\n\\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[0];\\n    }\\n\\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[1];\\n    }\\n\\n    function isEmpty(GlobalState calldata state) internal pure returns (bool) {\\n        return (state.bytes32Vals[0] == bytes32(0) &&\\n            state.bytes32Vals[1] == bytes32(0) &&\\n            state.u64Vals[0] == 0 &&\\n            state.u64Vals[1] == 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Instructions.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct Instruction {\\n    uint16 opcode;\\n    uint256 argumentData;\\n}\\n\\nlibrary Instructions {\\n    uint16 internal constant UNREACHABLE = 0x00;\\n    uint16 internal constant NOP = 0x01;\\n    uint16 internal constant RETURN = 0x0F;\\n    uint16 internal constant CALL = 0x10;\\n    uint16 internal constant CALL_INDIRECT = 0x11;\\n    uint16 internal constant LOCAL_GET = 0x20;\\n    uint16 internal constant LOCAL_SET = 0x21;\\n    uint16 internal constant GLOBAL_GET = 0x23;\\n    uint16 internal constant GLOBAL_SET = 0x24;\\n\\n    uint16 internal constant I32_LOAD = 0x28;\\n    uint16 internal constant I64_LOAD = 0x29;\\n    uint16 internal constant F32_LOAD = 0x2A;\\n    uint16 internal constant F64_LOAD = 0x2B;\\n    uint16 internal constant I32_LOAD8_S = 0x2C;\\n    uint16 internal constant I32_LOAD8_U = 0x2D;\\n    uint16 internal constant I32_LOAD16_S = 0x2E;\\n    uint16 internal constant I32_LOAD16_U = 0x2F;\\n    uint16 internal constant I64_LOAD8_S = 0x30;\\n    uint16 internal constant I64_LOAD8_U = 0x31;\\n    uint16 internal constant I64_LOAD16_S = 0x32;\\n    uint16 internal constant I64_LOAD16_U = 0x33;\\n    uint16 internal constant I64_LOAD32_S = 0x34;\\n    uint16 internal constant I64_LOAD32_U = 0x35;\\n\\n    uint16 internal constant I32_STORE = 0x36;\\n    uint16 internal constant I64_STORE = 0x37;\\n    uint16 internal constant F32_STORE = 0x38;\\n    uint16 internal constant F64_STORE = 0x39;\\n    uint16 internal constant I32_STORE8 = 0x3A;\\n    uint16 internal constant I32_STORE16 = 0x3B;\\n    uint16 internal constant I64_STORE8 = 0x3C;\\n    uint16 internal constant I64_STORE16 = 0x3D;\\n    uint16 internal constant I64_STORE32 = 0x3E;\\n\\n    uint16 internal constant MEMORY_SIZE = 0x3F;\\n    uint16 internal constant MEMORY_GROW = 0x40;\\n\\n    uint16 internal constant DROP = 0x1A;\\n    uint16 internal constant SELECT = 0x1B;\\n    uint16 internal constant I32_CONST = 0x41;\\n    uint16 internal constant I64_CONST = 0x42;\\n    uint16 internal constant F32_CONST = 0x43;\\n    uint16 internal constant F64_CONST = 0x44;\\n    uint16 internal constant I32_EQZ = 0x45;\\n    uint16 internal constant I32_RELOP_BASE = 0x46;\\n    uint16 internal constant IRELOP_EQ = 0;\\n    uint16 internal constant IRELOP_NE = 1;\\n    uint16 internal constant IRELOP_LT_S = 2;\\n    uint16 internal constant IRELOP_LT_U = 3;\\n    uint16 internal constant IRELOP_GT_S = 4;\\n    uint16 internal constant IRELOP_GT_U = 5;\\n    uint16 internal constant IRELOP_LE_S = 6;\\n    uint16 internal constant IRELOP_LE_U = 7;\\n    uint16 internal constant IRELOP_GE_S = 8;\\n    uint16 internal constant IRELOP_GE_U = 9;\\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\\n\\n    uint16 internal constant I64_EQZ = 0x50;\\n    uint16 internal constant I64_RELOP_BASE = 0x51;\\n\\n    uint16 internal constant I32_UNOP_BASE = 0x67;\\n    uint16 internal constant IUNOP_CLZ = 0;\\n    uint16 internal constant IUNOP_CTZ = 1;\\n    uint16 internal constant IUNOP_POPCNT = 2;\\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\\n\\n    uint16 internal constant I32_ADD = 0x6A;\\n    uint16 internal constant I32_SUB = 0x6B;\\n    uint16 internal constant I32_MUL = 0x6C;\\n    uint16 internal constant I32_DIV_S = 0x6D;\\n    uint16 internal constant I32_DIV_U = 0x6E;\\n    uint16 internal constant I32_REM_S = 0x6F;\\n    uint16 internal constant I32_REM_U = 0x70;\\n    uint16 internal constant I32_AND = 0x71;\\n    uint16 internal constant I32_OR = 0x72;\\n    uint16 internal constant I32_XOR = 0x73;\\n    uint16 internal constant I32_SHL = 0x74;\\n    uint16 internal constant I32_SHR_S = 0x75;\\n    uint16 internal constant I32_SHR_U = 0x76;\\n    uint16 internal constant I32_ROTL = 0x77;\\n    uint16 internal constant I32_ROTR = 0x78;\\n\\n    uint16 internal constant I64_UNOP_BASE = 0x79;\\n\\n    uint16 internal constant I64_ADD = 0x7C;\\n    uint16 internal constant I64_SUB = 0x7D;\\n    uint16 internal constant I64_MUL = 0x7E;\\n    uint16 internal constant I64_DIV_S = 0x7F;\\n    uint16 internal constant I64_DIV_U = 0x80;\\n    uint16 internal constant I64_REM_S = 0x81;\\n    uint16 internal constant I64_REM_U = 0x82;\\n    uint16 internal constant I64_AND = 0x83;\\n    uint16 internal constant I64_OR = 0x84;\\n    uint16 internal constant I64_XOR = 0x85;\\n    uint16 internal constant I64_SHL = 0x86;\\n    uint16 internal constant I64_SHR_S = 0x87;\\n    uint16 internal constant I64_SHR_U = 0x88;\\n    uint16 internal constant I64_ROTL = 0x89;\\n    uint16 internal constant I64_ROTR = 0x8A;\\n\\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\\n\\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\\n\\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\\n\\n    uint16 internal constant INIT_FRAME = 0x8002;\\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\\n    uint16 internal constant DUP = 0x8008;\\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\\n\\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\\n\\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\\n\\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\\n\\n    function hash(Instruction memory inst) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Instruction:\\\", inst.opcode, inst.argumentData));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Machine.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ValueStack.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./StackFrame.sol\\\";\\n\\nenum MachineStatus {\\n    RUNNING,\\n    FINISHED,\\n    ERRORED,\\n    TOO_FAR\\n}\\n\\nstruct Machine {\\n    MachineStatus status;\\n    ValueStack valueStack;\\n    ValueStack internalStack;\\n    StackFrameWindow frameStack;\\n    bytes32 globalStateHash;\\n    uint32 moduleIdx;\\n    uint32 functionIdx;\\n    uint32 functionPc;\\n    bytes32 modulesRoot;\\n}\\n\\nlibrary MachineLib {\\n    using StackFrameLib for StackFrameWindow;\\n    using ValueStackLib for ValueStack;\\n\\n    function hash(Machine memory mach) internal pure returns (bytes32) {\\n        // Warning: the non-running hashes are replicated in Challenge\\n        if (mach.status == MachineStatus.RUNNING) {\\n            return\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"Machine running:\\\",\\n                        mach.valueStack.hash(),\\n                        mach.internalStack.hash(),\\n                        mach.frameStack.hash(),\\n                        mach.globalStateHash,\\n                        mach.moduleIdx,\\n                        mach.functionIdx,\\n                        mach.functionPc,\\n                        mach.modulesRoot\\n                    )\\n                );\\n        } else if (mach.status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", mach.globalStateHash));\\n        } else if (mach.status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (mach.status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_MACH_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Module.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ModuleMemoryCompact.sol\\\";\\n\\nstruct Module {\\n    bytes32 globalsMerkleRoot;\\n    ModuleMemory moduleMemory;\\n    bytes32 tablesMerkleRoot;\\n    bytes32 functionsMerkleRoot;\\n    uint32 internalsOffset;\\n}\\n\\nlibrary ModuleLib {\\n    using ModuleMemoryCompactLib for ModuleMemory;\\n\\n    function hash(Module memory mod) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Module:\\\",\\n                    mod.globalsMerkleRoot,\\n                    mod.moduleMemory.hash(),\\n                    mod.tablesMerkleRoot,\\n                    mod.functionsMerkleRoot,\\n                    mod.internalsOffset\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ModuleMemoryCompact.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct ModuleMemory {\\n    uint64 size;\\n    uint64 maxSize;\\n    bytes32 merkleRoot;\\n}\\n\\nlibrary ModuleMemoryCompactLib {\\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Memory:\\\", mem.size, mem.maxSize, mem.merkleRoot));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/StackFrame.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct StackFrame {\\n    Value returnPc;\\n    bytes32 localsMerkleRoot;\\n    uint32 callerModule;\\n    uint32 callerModuleInternals;\\n}\\n\\nstruct StackFrameWindow {\\n    StackFrame[] proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary StackFrameLib {\\n    using ValueLib for Value;\\n\\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Stack frame:\\\",\\n                    frame.returnPc.hash(),\\n                    frame.localsMerkleRoot,\\n                    frame.callerModule,\\n                    frame.callerModuleInternals\\n                )\\n            );\\n    }\\n\\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\\n        h = window.remainingHash;\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Stack frame stack:\\\", hash(window.proved[i]), h));\\n        }\\n    }\\n\\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        return window.proved[0];\\n    }\\n\\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        frame = window.proved[0];\\n        window.proved = new StackFrame[](0);\\n    }\\n\\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            newProved[i] = window.proved[i];\\n        }\\n        newProved[window.proved.length] = frame;\\n        window.proved = newProved;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Value.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nenum ValueType {\\n    I32,\\n    I64,\\n    F32,\\n    F64,\\n    REF_NULL,\\n    FUNC_REF,\\n    INTERNAL_REF\\n}\\n\\nstruct Value {\\n    ValueType valueType;\\n    uint256 contents;\\n}\\n\\nlibrary ValueLib {\\n    function hash(Value memory val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Value:\\\", val.valueType, val.contents));\\n    }\\n\\n    function maxValueType() internal pure returns (ValueType) {\\n        return ValueType.INTERNAL_REF;\\n    }\\n\\n    function assumeI32(Value memory val) internal pure returns (uint32) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I32, \\\"NOT_I32\\\");\\n        require(uintval < (1 << 32), \\\"BAD_I32\\\");\\n        return uint32(uintval);\\n    }\\n\\n    function assumeI64(Value memory val) internal pure returns (uint64) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I64, \\\"NOT_I64\\\");\\n        require(uintval < (1 << 64), \\\"BAD_I64\\\");\\n        return uint64(uintval);\\n    }\\n\\n    function newRefNull() internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\\n    }\\n\\n    function newI32(uint32 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\\n    }\\n\\n    function newI64(uint64 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\\n    }\\n\\n    function newBoolean(bool x) internal pure returns (Value memory) {\\n        if (x) {\\n            return newI32(uint32(1));\\n        } else {\\n            return newI32(uint32(0));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ValueArray.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct ValueArray {\\n    Value[] inner;\\n}\\n\\nlibrary ValueArrayLib {\\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\\n        return arr.inner[index];\\n    }\\n\\n    function set(\\n        ValueArray memory arr,\\n        uint256 index,\\n        Value memory val\\n    ) internal pure {\\n        arr.inner[index] = val;\\n    }\\n\\n    function length(ValueArray memory arr) internal pure returns (uint256) {\\n        return arr.inner.length;\\n    }\\n\\n    function push(ValueArray memory arr, Value memory val) internal pure {\\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\\n        for (uint256 i = 0; i < arr.inner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        newInner[arr.inner.length] = val;\\n        arr.inner = newInner;\\n    }\\n\\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\\n        popped = arr.inner[arr.inner.length - 1];\\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\\n        for (uint256 i = 0; i < newInner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        arr.inner = newInner;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ValueStack.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./ValueArray.sol\\\";\\n\\nstruct ValueStack {\\n    ValueArray proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary ValueStackLib {\\n    using ValueLib for Value;\\n    using ValueArrayLib for ValueArray;\\n\\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\\n        h = stack.remainingHash;\\n        uint256 len = stack.proved.length();\\n        for (uint256 i = 0; i < len; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Value stack:\\\", stack.proved.get(i).hash(), h));\\n        }\\n    }\\n\\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\\n        uint256 len = stack.proved.length();\\n        return stack.proved.get(len - 1);\\n    }\\n\\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\\n        return stack.proved.pop();\\n    }\\n\\n    function push(ValueStack memory stack, Value memory val) internal pure {\\n        return stack.proved.push(val);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"internalType\":\"struct BridgeCreator.BridgeContracts\",\"name\":\"_ethBasedTemplates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"internalType\":\"struct BridgeCreator.BridgeContracts\",\"name\":\"_erc20BasedTemplates\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ERC20TemplatesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TemplatesUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nativeToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation\",\"type\":\"tuple\"}],\"name\":\"createBridge\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"internalType\":\"struct BridgeCreator.BridgeContracts\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20BasedTemplates\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBasedTemplates\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"internalType\":\"struct BridgeCreator.BridgeContracts\",\"name\":\"_newTemplates\",\"type\":\"tuple\"}],\"name\":\"updateERC20Templates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"}],\"internalType\":\"struct BridgeCreator.BridgeContracts\",\"name\":\"_newTemplates\",\"type\":\"tuple\"}],\"name\":\"updateTemplates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BridgeCreator", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "0000000000000000000000001cc6d4dff186509ab8d8067540f7b77694311eb50000000000000000000000007e257db49ab62bc08ea1f8c381e7e252f788106f000000000000000000000000b97d71822464afb2a931a978eb8da8f5d999056d000000000000000000000000cab6572cc8efcb60aade1914e22f82628e681a4f0000000000000000000000006c257cccdbb7bccf52d3e408646947b33ee6943500000000000000000000000055109ac7edfca08ef9dee360140ed686479da91a000000000000000000000000f8b5c7e5bb1a3f62de6fcf0690510351a5e46778000000000000000000000000491705482a602093f42ecddd57e9e4329957f3660000000000000000000000009ad48f1c002509425c8fda71ef64d03116db18090000000000000000000000005c864714456935f05cd74d78cfe05bcc726cddee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}