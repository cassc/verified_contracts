{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Guild\r\n@author Versailles heroes\r\n@license MIT\r\n@notice Used for measuring owner and members rewards\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface VRH20:\r\n    def future_epoch_time_write() -> uint256: nonpayable\r\n    def rate() -> uint256: view\r\n\r\ninterface GuildController:\r\n    def guild_relative_weight(addr: address, time: uint256) -> uint256: view\r\n    def get_guild_weight(addr: address) -> uint256: view\r\n    def add_member(guild_addr: address, user_addr: address): nonpayable\r\n    def remove_member(user_addr: address): nonpayable\r\n    def voting_escrow() -> address: view\r\n    def gas_type_escrow(token: address) -> address: view\r\n    def checkpoint_guild(addr: address): nonpayable\r\n    def refresh_guild_votes(user_addr: address, guild_addr: address): nonpayable\r\n    def belongs_to_guild(user_addr: address, guild_addr: address) -> bool: view\r\n\r\ninterface Minter:\r\n    def minted(user: address, guild: address) -> uint256: view\r\n    def controller() -> address: view\r\n    def token() -> address: view\r\n    def rewardVestingEscrow() -> address: view\r\n\r\ninterface VotingEscrow:\r\n    def user_point_epoch(addr: address) -> uint256: view\r\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\r\n\r\ninterface GasEscrow:\r\n    def user_point_epoch(addr: address) -> uint256: view\r\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\r\n\r\ninterface RewardVestingEscrow:\r\n    def claimable_tokens(addr: address) -> uint256: nonpayable\r\n\r\n\r\nDECIMALS: constant(uint256) = 10 ** 18\r\n\r\nTOKENLESS_PRODUCTION: constant(uint256) = 40\r\n\r\nminter: public(address)\r\nvrh_token: public(address)\r\ncontroller: public(address)\r\nvoting_escrow: public(address)\r\ngas_escrow: public(address)\r\nfuture_epoch_time: public(uint256)\r\n\r\nworking_balances: public(HashMap[address, uint256])\r\nworking_supply: public(uint256)\r\nperiod_timestamp: public(uint256[100000000000000000000000000000])\r\nperiod: public(int128)\r\n\r\nlast_change_rate: public(uint256)\r\n\r\n# 1e18 * \u222b(rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\r\n\r\n# 1e18 * \u222b(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\r\nintegrate_inv_supply_of: public(HashMap[address, uint256])\r\nintegrate_checkpoint_of: public(HashMap[address, uint256])\r\n\r\n# \u222b(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\n# Units: rate * t = already number of coins per address to issue\r\nintegrate_fraction: public(HashMap[address, uint256])\r\n\r\ninflation_rate: public(uint256)\r\nis_paused: public(bool)\r\nWEEK: constant(uint256) = 604800\r\nDAY: constant(uint256) = 86400\r\n\r\n# guild variables\r\nowner: public(address) # guild owner address\r\n\r\n# Proportion of what the guild owner gets\r\ncommission_rate: public(HashMap[uint256, uint256])  # time -> commission_rate\r\ntotal_owner_bonus: public(HashMap[address, uint256]) # owner address -> owner bonus\r\n\r\nevent UpdateLiquidityLimit:\r\n    user: address\r\n    original_balance: uint256\r\n    original_supply: uint256\r\n    working_balance: uint256\r\n    working_supply: uint256\r\n\r\nevent TriggerPause:\r\n    guild: address\r\n    pause: bool\r\n\r\nevent SetCommissionRate:\r\n    commission_rate: uint256\r\n    effective_time: uint256\r\n\r\n@external\r\ndef __init__():\r\n    self.owner = msg.sender\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef initialize(_owner: address, _commission_rate: uint256, _token: address, _gas_escrow: address, _minter: address) -> bool:\r\n\r\n    #@notice Initialize the contract to create a guild\r\n    assert self.owner == ZERO_ADDRESS  # dev: can only initialize once\r\n\r\n    self.is_paused = False\r\n    self.owner = _owner\r\n    self.period_timestamp[0] = block.timestamp\r\n\r\n    assert _minter != ZERO_ADDRESS\r\n    self.minter = _minter\r\n\r\n    self.vrh_token = _token\r\n    _controller: address = Minter(_minter).controller()\r\n    self.controller = _controller\r\n    self.voting_escrow = GuildController(_controller).voting_escrow()\r\n\r\n    assert _gas_escrow != ZERO_ADDRESS\r\n    self.gas_escrow = _gas_escrow\r\n\r\n    assert _commission_rate >= 0 and _commission_rate <= 20, 'Rate has to be minimally 0% and maximum 20%'\r\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\r\n    self.commission_rate[next_time] = _commission_rate\r\n    self.last_change_rate = next_time # Record last updated commission rate\r\n    self.inflation_rate = VRH20(self.vrh_token).rate()\r\n    self.future_epoch_time = VRH20(self.vrh_token).future_epoch_time_write()\r\n\r\n    return True\r\n\r\n\r\n@internal\r\ndef _get_commission_rate():\r\n    \"\"\"\r\n    @notice Fill historic commission rate week-over-week for missed checkins\r\n            and return the commission rate for the future week\r\n    \"\"\"\r\n    t: uint256 = self.last_change_rate\r\n    if t > 0:\r\n        w: uint256 = self.commission_rate[t]\r\n        for i in range(500):\r\n            if t > block.timestamp:\r\n                break\r\n            t += WEEK\r\n            self.commission_rate[t] = w\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address):\r\n    \"\"\"\r\n    @notice Checkpoint for a user\r\n    @param addr User address\r\n    \"\"\"\r\n    _token: address = self.vrh_token\r\n    _controller: address = self.controller\r\n    _period: int128 = self.period\r\n    _period_time: uint256 = self.period_timestamp[_period]\r\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\r\n    _owner_bonus: uint256 = 0\r\n\r\n    rate: uint256 = self.inflation_rate\r\n    new_rate: uint256 = rate\r\n    prev_future_epoch: uint256 = self.future_epoch_time\r\n    if prev_future_epoch >= _period_time:\r\n        self.future_epoch_time = VRH20(_token).future_epoch_time_write()\r\n        new_rate = VRH20(_token).rate()\r\n        self.inflation_rate = new_rate\r\n\r\n    GuildController(_controller).checkpoint_guild(self)\r\n\r\n    _working_balance: uint256 = self.working_balances[addr]\r\n    _working_supply: uint256 = self.working_supply\r\n    \r\n    if self.is_paused:\r\n        rate = 0  # Stop distributing inflation as soon as paused\r\n\r\n    # Update integral of 1/supply\r\n    if block.timestamp > _period_time:\r\n        prev_week_time: uint256 = _period_time\r\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n        # Fill missing check-in for commission rate\r\n        self._get_commission_rate()\r\n\r\n        for i in range(500):\r\n            dt: uint256 = week_time - prev_week_time\r\n            w: uint256 = GuildController(_controller).guild_relative_weight(self, prev_week_time / WEEK * WEEK)\r\n            commission_rate: uint256 = self.commission_rate[prev_week_time / WEEK * WEEK]\r\n\r\n            if _working_supply > 0:\r\n                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\r\n                    # If we went across one or multiple epochs, apply the rate\r\n                    # of the first epoch until it ends, and then the rate of\r\n                    # the last epoch.\r\n                    # If more than one epoch is crossed - the gauge gets less,\r\n                    # but that'd meen it wasn't called for more than 1 year\r\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply * (100 - commission_rate) / 100\r\n                    _owner_bonus += rate * w * (prev_future_epoch - prev_week_time) * commission_rate / 100\r\n                    \r\n                    rate = new_rate\r\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply * (100 - commission_rate) / 100\r\n                    _owner_bonus += rate * w * (week_time - prev_future_epoch) * commission_rate / 100\r\n                else:\r\n                    _integrate_inv_supply += rate * w * dt / _working_supply * (100 - commission_rate) / 100\r\n                    _owner_bonus += rate * w * dt * commission_rate / 100\r\n                    \r\n                # On precisions of the calculation\r\n                # rate ~= 10e18\r\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\r\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\r\n                # The largest loss is at dt = 1\r\n                # Loss is 1e-9 - acceptable\r\n\r\n            if week_time == block.timestamp:\r\n                break\r\n            prev_week_time = week_time\r\n            week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    _period += 1\r\n    self.period = _period\r\n    self.period_timestamp[_period] = block.timestamp\r\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\r\n\r\n    # Update user-specific integrals\r\n    # calculate owner bonus\r\n    if _owner_bonus > 0:\r\n        self.integrate_fraction[self.owner] += _owner_bonus / 10 ** 18\r\n        self.total_owner_bonus[self.owner] += _owner_bonus / 10 ** 18\r\n\r\n    # calculate for all members (including owner)\r\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\r\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\r\n    self.integrate_checkpoint_of[addr] = block.timestamp\r\n\r\n\r\n@external\r\ndef set_commission_rate(increase: bool):\r\n    assert self.owner == msg.sender,'Only guild owner can change commission rate'\r\n    assert block.timestamp >= self.last_change_rate, \"Can only change commission rate once every week\"\r\n    \r\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\r\n    commission_rate: uint256 = self.commission_rate[self.last_change_rate]\r\n\r\n    # 0 == decrease, 1 equals increase\r\n    if increase == True :\r\n        commission_rate += 1\r\n        assert commission_rate <= 20, 'Maximum is 20'\r\n    else:\r\n        commission_rate -= 1\r\n        assert commission_rate >= 0, 'Minimum is 0'\r\n    \r\n    self.commission_rate[next_time] = commission_rate\r\n    self.last_change_rate = next_time\r\n    log SetCommissionRate(commission_rate, next_time)\r\n\r\n\r\n@internal\r\ndef _update_liquidity_limit(addr: address, bu: uint256, S: uint256):\r\n    \"\"\"\r\n    @notice Calculate limits which depend on the amount of VRH token per-user.\r\n            Effectively it calculates working balances to apply amplification\r\n            of veVRH production by gas\r\n    @param addr User address\r\n    @param bu User's amount of veVRH\r\n    @param S Total amount of veVRH in a guild\r\n    \"\"\"\r\n    # To be called after totalSupply is updated\r\n    _gas_escrow: address = self.gas_escrow\r\n    wi: uint256 = ERC20(_gas_escrow).balanceOf(addr) # gas balance of a user\r\n    W: uint256 = ERC20(_gas_escrow).totalSupply() # gas total of all users\r\n\r\n    lim: uint256 = bu * TOKENLESS_PRODUCTION / 100 # 0.4bu\r\n\r\n    # Boost portion below : game tokens (gas)\r\n    if (S > 0) and wi > 0:\r\n        lim += S * wi / W * (100 - TOKENLESS_PRODUCTION) / 100\r\n\r\n    lim = min(bu, lim)\r\n    old_bal: uint256 = self.working_balances[addr]\r\n    self.working_balances[addr] = lim\r\n    _working_supply: uint256 = self.working_supply + lim - old_bal\r\n    self.working_supply = _working_supply\r\n\r\n    log UpdateLiquidityLimit(addr, bu, S, lim, _working_supply)\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert (msg.sender == addr) or (msg.sender == self.minter)  # dev: unauthorized\r\n\r\n    # check that user truly belongs to guild\r\n    _controller: address = self.controller\r\n    assert GuildController(_controller).belongs_to_guild(addr, self), \"Not in guild\"\r\n    \r\n    _user_voting_power: uint256 = ERC20(self.voting_escrow).balanceOf(addr)\r\n    if _user_voting_power != 0:\r\n        GuildController(_controller).refresh_guild_votes(addr, self)\r\n    self._checkpoint(addr)\r\n    _guild_voting_power: uint256 = GuildController(_controller).get_guild_weight(self)\r\n    self._update_liquidity_limit(addr, _user_voting_power, _guild_voting_power)\r\n    \r\n    return True\r\n\r\n\r\n@external\r\ndef update_working_balance(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.minter  # dev: unauthorized\r\n\r\n    _controller: address = self.controller\r\n    assert GuildController(_controller).belongs_to_guild(addr, self), \"Not in guild\"\r\n\r\n    self._checkpoint(addr)\r\n    _user_voting_power: uint256 = ERC20(self.voting_escrow).balanceOf(addr)\r\n    _guild_voting_power: uint256 = GuildController(_controller).get_guild_weight(self)\r\n    self._update_liquidity_limit(addr, _user_voting_power, _guild_voting_power)\r\n    return True\r\n\r\n\r\n@external\r\ndef claimable_tokens(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    _rewardVestingEscrow: address = Minter(self.minter).rewardVestingEscrow()\r\n    _reward_vesting_claimable: uint256 = RewardVestingEscrow(_rewardVestingEscrow).claimable_tokens(addr)\r\n    return self.integrate_fraction[addr] - Minter(self.minter).minted(addr, self) + _reward_vesting_claimable\r\n\r\n\r\n@external\r\ndef kick(addr: address):\r\n    \"\"\"\r\n    @notice Kick `addr` for abusing their boost\r\n    @dev Only if either they had abusing gas boost, or their voting escrow lock expired\r\n    @param addr Address to kick\r\n    \"\"\"\r\n\r\n    _voting_escrow: address = self.voting_escrow\r\n    _gas_escrow: address = self.gas_escrow\r\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\r\n    t_gas: uint256 = GasEscrow(_gas_escrow).user_point_history__ts(\r\n        addr, GasEscrow(_gas_escrow).user_point_epoch(addr))\r\n    _balance: uint256 = ERC20(self.voting_escrow).balanceOf(addr)\r\n    _gas_balance: uint256 = ERC20(self.gas_escrow).balanceOf(addr)\r\n\r\n    assert (_balance == 0) or (_gas_balance == 0 or t_gas > t_last)  # dev: kick not allowed\r\n    assert self.working_balances[addr] > _balance * 2 * TOKENLESS_PRODUCTION / 100 # dev: kick not needed\r\n\r\n    self._checkpoint(addr)\r\n    _user_voting_power: uint256 = _balance\r\n    _guild_voting_power: uint256 = GuildController(self.controller).get_guild_weight(self)\r\n    self._update_liquidity_limit(addr, _user_voting_power, _guild_voting_power)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef join_guild():\r\n    \"\"\"\r\n    @notice Join into this guild and start mining\r\n    \"\"\"\r\n    addr: address = msg.sender\r\n    GuildController(self.controller).add_member(self, addr)\r\n    self._checkpoint(addr)\r\n    _user_voting_power: uint256 = ERC20(self.voting_escrow).balanceOf(addr)\r\n    _guild_voting_power: uint256 = GuildController(self.controller).get_guild_weight(self)\r\n    self._update_liquidity_limit(addr, _user_voting_power, _guild_voting_power)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef leave_guild():\r\n    \"\"\"\r\n    @notice Leave this guild and stop mining\r\n    \"\"\"\r\n    GuildController(self.controller).remove_member(msg.sender)\r\n    _user_voting_power: uint256 = 0 # set user's working balance to 0 after minting remaining and leave guild\r\n    _guild_voting_power: uint256 = GuildController(self.controller).get_guild_weight(self)\r\n    self._update_liquidity_limit(msg.sender, _user_voting_power, _guild_voting_power)\r\n\r\n\r\n@external\r\ndef transfer_ownership(new_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of Guild to `new_owner`\r\n    @param new_owner Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.controller # only GuildController can access this\r\n    old_owner: address = self.owner\r\n    self._checkpoint(old_owner) # updates current owner integrate fraction and bonus before transferring ownership\r\n    _user_voting_power: uint256 = ERC20(self.voting_escrow).balanceOf(old_owner)\r\n    _guild_voting_power: uint256 = GuildController(self.controller).get_guild_weight(self)\r\n    self._update_liquidity_limit(old_owner, _user_voting_power, _guild_voting_power)\r\n    self.owner = new_owner\r\n\r\n\r\n@external\r\ndef toggle_pause():\r\n    assert msg.sender == self.controller # only GuildController can access this\r\n    self.is_paused = not self.is_paused\r\n\r\n    log TriggerPause(self, self.is_paused)", "ABI": "[{\"name\":\"UpdateLiquidityLimit\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":false},{\"name\":\"original_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"original_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"working_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"working_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TriggerPause\",\"inputs\":[{\"name\":\"guild\",\"type\":\"address\",\"indexed\":false},{\"name\":\"pause\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetCommissionRate\",\"inputs\":[{\"name\":\"commission_rate\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"effective_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_commission_rate\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_gas_escrow\",\"type\":\"address\"},{\"name\":\"_minter\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":483411},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_commission_rate\",\"inputs\":[{\"name\":\"increase\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":92095},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":23122682},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_working_balance\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":23117631},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimable_tokens\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":23028846},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kick\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":23128158},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"join_guild\",\"inputs\":[],\"outputs\":[],\"gas\":23175870},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"leave_guild\",\"inputs\":[],\"outputs\":[],\"gas\":157227},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer_ownership\",\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":23148959},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_pause\",\"inputs\":[],\"outputs\":[],\"gas\":44028},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2760},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vrh_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2790},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2820},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2850},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gas_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2880},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_epoch_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2910},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3206},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2970},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period_timestamp\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3045},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":3030},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_change_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3060},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3135},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3386},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3416},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3446},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3210},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3240},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3270},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"commission_rate\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3415},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_owner_bonus\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3596}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}