{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title Basic redeemer\r\n@author 1up\r\n@license GNU AGPLv3\r\n@notice\r\n    Redeem discount token and lock into protocol's voting escrow.\r\n    Redemption cost can be paid either by sending ETH or by selling some of the rewards.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Redeemer:\r\n    def redeem(_account: address, _receiver: address, _lt_amount: uint256, _dt_amount: uint256, _data: Bytes[256]) -> uint256: payable\r\nimplements: Redeemer\r\n\r\ninterface VotingEscrow:\r\n    def modify_lock(_amount: uint256, _unlock_time: uint256, _account: address): nonpayable\r\n\r\ninterface LiquidLocker:\r\n    def token() -> address: view\r\n    def mint(_receiver: address) -> uint256: nonpayable\r\n\r\ninterface YearnRedemption:\r\n    def eth_required(amount: uint256) -> uint256: view\r\n    def redeem(amount: uint256) -> uint256: payable\r\n\r\ninterface CurvePool:\r\n    def exchange(\r\n        _i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool\r\n    ) -> uint256: nonpayable\r\n\r\nvoting_escrow: public(immutable(VotingEscrow))\r\nliquid_locker: public(immutable(LiquidLocker))\r\nlocking_token: public(immutable(ERC20))\r\ndiscount_token: public(immutable(ERC20))\r\nproxy: public(immutable(address))\r\ngauge_rewards: public(immutable(address))\r\nstaking_rewards: public(immutable(address))\r\nmanagement: public(address)\r\npending_management: public(address)\r\ntreasury: public(address)\r\nyearn_redemption: public(YearnRedemption)\r\ncurve_pool: public(CurvePool)\r\n\r\nevent Redeem:\r\n    account: indexed(address)\r\n    receiver: address\r\n    lt_amount: uint256\r\n    dt_amount: uint256\r\n    value: uint256\r\n    minted: uint256\r\n\r\nevent ClaimExcess:\r\n    excess: uint256\r\n\r\nevent SetTreasury:\r\n    treasury: address\r\n\r\nevent SetYearnRedemption:\r\n    yearn_redemption: address\r\n\r\nevent SetCurvePool:\r\n    curve_pool: address\r\n\r\nevent PendingManagement:\r\n    management: address\r\n\r\nevent SetManagement:\r\n    management: address\r\n\r\nSCALE: constant(uint256) = 69_420\r\n\r\n@external\r\ndef __init__(\r\n    _voting_escrow: address, _liquid_locker: address, _locking_token: address, _discount_token: address, \r\n    _proxy: address, _gauge_rewards: address, _staking_rewards: address,\r\n):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _voting_escrow Voting escrow\r\n    @param _liquid_locker Liquid locker\r\n    @param _locking_token Locking token\r\n    @param _discount_token Discount token\r\n    @param _proxy Proxy\r\n    @param _gauge_rewards Gauge rewards contract\r\n    @param _staking_rewards Staking rewards contract\r\n    \"\"\"\r\n    voting_escrow = VotingEscrow(_voting_escrow)\r\n    liquid_locker = LiquidLocker(_liquid_locker)\r\n    locking_token = ERC20(_locking_token)\r\n    discount_token = ERC20(_discount_token)\r\n    proxy = _proxy\r\n    gauge_rewards = _gauge_rewards\r\n    staking_rewards = _staking_rewards\r\n    self.management = msg.sender\r\n    self.treasury = msg.sender\r\n    assert locking_token.approve(_voting_escrow, max_value(uint256), default_return_value=True)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    \"\"\"\r\n    @notice Receive ETH from Curve pool swaps\r\n    \"\"\"\r\n    assert msg.sender == self.curve_pool.address\r\n\r\n@external\r\n@payable\r\ndef redeem(_account: address, _receiver: address, _lt_amount: uint256, _dt_amount: uint256, _data: Bytes[256]) -> uint256:\r\n    \"\"\"\r\n    @notice Redeem discount token into locking token and lock into liquid locker\r\n    @param _account User performing the redemption\r\n    @param _receiver Receiver of rewards\r\n    @param _lt_amount Amount of locking tokens\r\n    @param _dt_amount Amount of discount tokens\r\n    @param _data Additional data\r\n    @return Amount of liquid locker tokens created\r\n    @dev Can only be called by either of the reward contracts\r\n    \"\"\"\r\n    assert msg.sender in [gauge_rewards, staking_rewards]\r\n    assert _lt_amount > 0 or _dt_amount > 0\r\n\r\n    # claim locking token rewards\r\n    if _lt_amount > 0:\r\n        assert locking_token.transferFrom(msg.sender, self, _lt_amount, default_return_value=True)\r\n    amount: uint256 = _lt_amount + _dt_amount\r\n\r\n    # redeem discount token rewards\r\n    if _dt_amount > 0:\r\n        assert discount_token.transferFrom(msg.sender, self, _dt_amount, default_return_value=True)\r\n        if msg.value > 0:\r\n            # redemption cost is paid for\r\n            self._redeem_yearn(_receiver, _dt_amount, msg.value)\r\n        else:\r\n            # pay for redemption cost by selling some rewards\r\n            sell_amount: uint256 = _abi_decode(_data, uint256)\r\n            amount -= sell_amount\r\n            self._redeem_curve(_receiver, _dt_amount, sell_amount)\r\n    else:\r\n        assert msg.value == 0\r\n\r\n    # deposit into our lock and mint\r\n    voting_escrow.modify_lock(amount, 0, proxy)\r\n    minted: uint256 = liquid_locker.mint(_receiver)\r\n    assert minted >= amount * SCALE\r\n    log Redeem(_account, _receiver, _lt_amount, _dt_amount, msg.value, minted)\r\n    return minted\r\n\r\n@internal\r\ndef _redeem_yearn(_receiver: address, _amount: uint256, _eth_amount: uint256):\r\n    \"\"\"\r\n    @notice Redeem through Yearn. Refunds any excess above 0.3%\r\n    \"\"\"\r\n    value: uint256 = self.yearn_redemption.eth_required(_amount)\r\n    assert value > 0\r\n    if _eth_amount > value:\r\n        # return anything above 0.3%\r\n        raw_call(_receiver, b\"\", value=_eth_amount - value)\r\n    value -= value * 3 / 1000\r\n    assert _eth_amount >= value, \"slippage\"\r\n    self.yearn_redemption.redeem(_amount, value=value)\r\n\r\n@internal\r\ndef _redeem_curve(_receiver: address, _dt_amount: uint256, _sell_amount: uint256):\r\n    \"\"\"\r\n    @notice Partial sell through Curve, then redeem through Yearn\r\n    \"\"\"\r\n    # min_dy is set to zero because discount token redemption already has built in slippage check\r\n    eth_amount: uint256 = self.curve_pool.exchange(0, 1, _sell_amount, 0, True)\r\n    self._redeem_yearn(_receiver, _dt_amount - _sell_amount, eth_amount)\r\n\r\n@external\r\ndef claim_excess():\r\n    \"\"\"\r\n    @notice Claim excess ETH by sending it to the treasury\r\n    \"\"\"\r\n    value: uint256 = self.balance\r\n    assert value > 0\r\n    raw_call(self.treasury, b\"\", value=value)\r\n    log ClaimExcess(value)\r\n\r\n@external\r\ndef set_treasury(_treasury: address):\r\n    \"\"\"\r\n    @notice Set new treasury address, recipient of excess ETH\r\n    @param _treasury Treasury address\r\n    @dev Can only be called by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _treasury != empty(address)\r\n    self.treasury = _treasury\r\n    log SetTreasury(_treasury)\r\n\r\n@external\r\ndef set_yearn_redemption(_yearn_redemption: address):\r\n    \"\"\"\r\n    @notice\r\n        Set new Yearn redemption contract. Can be set to zero\r\n        to effectively disable redemptions.\r\n    @param _yearn_redemption Yearn redemption contract\r\n    @dev Can only be called by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n\r\n    previous: address = self.yearn_redemption.address\r\n    if previous != empty(address):\r\n        # retract previous allowance\r\n        assert discount_token.approve(previous, 0, default_return_value=True)\r\n    if _yearn_redemption != empty(address):\r\n        # set new allowance\r\n        assert discount_token.approve(_yearn_redemption, max_value(uint256), default_return_value=True)\r\n\r\n    self.yearn_redemption = YearnRedemption(_yearn_redemption)\r\n    log SetYearnRedemption(_yearn_redemption)\r\n\r\n@external\r\ndef set_curve_pool(_curve_pool: address):\r\n    \"\"\"\r\n    @notice\r\n        Set new Curve pool contract. Can be set to zero\r\n        to effectively disable redemptions without ETH.\r\n    @param _curve_pool Curve pool contract\r\n    @dev Can only be called by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n\r\n    previous: address = self.curve_pool.address\r\n    if previous != empty(address):\r\n        # retract previous allowance\r\n        assert discount_token.approve(previous, 0, default_return_value=True)\r\n    if _curve_pool != empty(address):\r\n        # set new allowance\r\n        assert discount_token.approve(_curve_pool, max_value(uint256), default_return_value=True)\r\n\r\n    self.curve_pool = CurvePool(_curve_pool)\r\n    log SetCurvePool(_curve_pool)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)", "ABI": "[{\"name\":\"Redeem\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":false},{\"name\":\"lt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"dt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"minted\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimExcess\",\"inputs\":[{\"name\":\"excess\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetTreasury\",\"inputs\":[{\"name\":\"treasury\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetYearnRedemption\",\"inputs\":[{\"name\":\"yearn_redemption\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetCurvePool\",\"inputs\":[{\"name\":\"curve_pool\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_voting_escrow\",\"type\":\"address\"},{\"name\":\"_liquid_locker\",\"type\":\"address\"},{\"name\":\"_locking_token\",\"type\":\"address\"},{\"name\":\"_discount_token\",\"type\":\"address\"},{\"name\":\"_proxy\",\"type\":\"address\"},{\"name\":\"_gauge_rewards\",\"type\":\"address\"},{\"name\":\"_staking_rewards\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_lt_amount\",\"type\":\"uint256\"},{\"name\":\"_dt_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_excess\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_treasury\",\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_yearn_redemption\",\"inputs\":[{\"name\":\"_yearn_redemption\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_curve_pool\",\"inputs\":[{\"name\":\"_curve_pool\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"liquid_locker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locking_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"discount_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proxy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_rewards\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"staking_rewards\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"treasury\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"yearn_redemption\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"curve_pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Basic redeemer", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000090c1f9220d90d3966fbee24045edd73e1d588ad500000000000000000000000095710bde45c8d384a976cc58cc7a7e489576b0980000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e00000000000000000000000041252e8691e964f7de35156b68493bab6797a275000000000000000000000000242521ca01f330f050a65ff5b8ebbe92198ae64f00000000000000000000000035440c602bc4f01bbec6cb616ccb901c9df5475f000000000000000000000000fe9c8a785eab9ee13a908af10a51229d35e3b0d2", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}