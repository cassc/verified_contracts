{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BENSYC.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: WTFPL v6.9\\npragma solidity >0.8.0 <0.9.0;\\n\\nimport \\\"src/Interface.sol\\\";\\nimport \\\"src/Util.sol\\\";\\nimport \\\"src/Base.sol\\\";\\n\\n/**\\n * @author 0xc0de4c0ffee, sshmatrix\\n * @title BENSYC Core\\n */\\n\\ncontract BoredENSYachtClub is BENSYC {\\n    using Util for uint256;\\n    using Util for bytes;\\n\\n    /// @dev : maximum supply of subdomains\\n    uint256 public immutable maxSupply;\\n\\n    /// @dev : namehash of 'boredensyachtclub.eth'\\n    bytes32 public immutable DomainHash;\\n\\n    /// @dev : start time of mint\\n    uint256 public immutable startTime;\\n\\n    /**\\n     * @dev Constructor\\n     * @param _resolver : default Resolver\\n     * @param _maxSupply : maximum supply of subdomains\\n     * @param _startTime : start time of mint\\n     */\\n    constructor(address _resolver, uint256 _maxSupply, uint256 _startTime) {\\n        Dev = msg.sender;\\n        ENS = iENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\\n        DefaultResolver = _resolver;\\n        DomainHash = keccak256(\\n            abi.encodePacked(keccak256(abi.encodePacked(bytes32(0), keccak256(\\\"eth\\\"))), keccak256(\\\"boredensyachtclub\\\"))\\n        );\\n        maxSupply = _maxSupply;\\n        startTime = _startTime;\\n        // Interface\\n        supportsInterface[type(iERC165).interfaceId] = true;\\n        supportsInterface[type(iERC173).interfaceId] = true;\\n        supportsInterface[type(iERC721Metadata).interfaceId] = true;\\n        supportsInterface[type(iERC721).interfaceId] = true;\\n        supportsInterface[type(iERC2981).interfaceId] = true;\\n    }\\n\\n    /**\\n     * @dev EIP721: returns owner of token ID\\n     * @param id : token ID\\n     * @return : address of owner\\n     */\\n    function ownerOf(uint256 id) public view isValidToken(id) returns (address) {\\n        return _ownerOf[id];\\n    }\\n\\n    /**\\n     * @dev returns namehash of token ID\\n     * @param id : token ID\\n     * @return : namehash of corresponding subdomain\\n     */\\n    function ID2Namehash(uint256 id) public view isValidToken(id) returns (bytes32) {\\n        return keccak256(abi.encodePacked(DomainHash, ID2Labelhash[id]));\\n    }\\n\\n    /**\\n     * @dev mint() function for single sudomain\\n     */\\n    function mint() external payable {\\n        if (!active) {\\n            revert MintingPaused();\\n        }\\n\\n        if (block.timestamp < startTime) {\\n            revert TooSoonToMint();\\n        }\\n\\n        if (totalSupply >= maxSupply) {\\n            revert MintEnded();\\n        }\\n\\n        if (msg.value < mintPrice) {\\n            revert InsufficientEtherSent(mintPrice, msg.value);\\n        }\\n\\n        uint256 _id = totalSupply;\\n        bytes32 _labelhash = keccak256(abi.encodePacked(_id.toString()));\\n        ENS.setSubnodeRecord(DomainHash, _labelhash, msg.sender, DefaultResolver, 0);\\n        ID2Labelhash[_id] = _labelhash;\\n        Namehash2ID[keccak256(abi.encodePacked(DomainHash, _labelhash))] = _id;\\n        unchecked {\\n            ++totalSupply;\\n            ++balanceOf[msg.sender];\\n        }\\n        _ownerOf[_id] = msg.sender;\\n        emit Transfer(address(0), msg.sender, _id);\\n    }\\n\\n    /**\\n     * @dev : batchMint() function for sudomains\\n     * @param batchSize : number of subdomains to mint in the batch (maximum batchSize = 12)\\n     */\\n    function batchMint(uint256 batchSize) external payable {\\n        if (!active) {\\n            revert MintingPaused();\\n        }\\n\\n        if (block.timestamp < startTime) {\\n            revert TooSoonToMint();\\n        }\\n\\n        if (batchSize > 12 || totalSupply + batchSize > maxSupply) {\\n            // maximum batchSize = floor of [12, maxSupply - totalSupply]\\n            revert OversizedBatch();\\n        }\\n\\n        if (msg.value < mintPrice * batchSize) {\\n            revert InsufficientEtherSent(mintPrice * batchSize, msg.value);\\n        }\\n\\n        uint256 _id = totalSupply;\\n        uint256 _mint = _id + batchSize;\\n        bytes32 _labelhash;\\n        while (_id < _mint) {\\n            _labelhash = keccak256(abi.encodePacked(_id.toString()));\\n            ENS.setSubnodeRecord(DomainHash, _labelhash, msg.sender, DefaultResolver, 0);\\n            ID2Labelhash[_id] = _labelhash;\\n            Namehash2ID[keccak256(abi.encodePacked(DomainHash, _labelhash))] = _id;\\n            _ownerOf[_id] = msg.sender;\\n            emit Transfer(address(0), msg.sender, _id);\\n            unchecked {\\n                ++_id;\\n            }\\n        }\\n        unchecked {\\n            totalSupply = _mint;\\n            balanceOf[msg.sender] += batchSize;\\n        }\\n    }\\n\\n    /**\\n     * @dev : generic _transfer function\\n     * @param from : address of sender\\n     * @param to : address of receiver\\n     * @param id : subdomain token ID\\n     */\\n    function _transfer(address from, address to, uint256 id, bytes memory data) internal {\\n        if (to == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        if (_ownerOf[id] != from) {\\n            revert NotSubdomainOwner(_ownerOf[id], from, id);\\n        }\\n\\n        if (msg.sender != _ownerOf[id] && !isApprovedForAll[from][msg.sender] && msg.sender != getApproved[id]) {\\n            revert Unauthorized(msg.sender, from, id);\\n        }\\n\\n        ENS.setSubnodeOwner(DomainHash, ID2Labelhash[id], to);\\n        unchecked {\\n            --balanceOf[from]; // subtract from owner\\n            ++(balanceOf[to]); // add to receiver\\n        }\\n        _ownerOf[id] = to; // change ownership\\n        delete getApproved[id]; // reset approved\\n        emit Transfer(from, to, id);\\n        if (to.code.length > 0) {\\n            try iERC721Receiver(to).onERC721Received(msg.sender, from, id, data) returns (bytes4 retval) {\\n                if (retval != iERC721Receiver.onERC721Received.selector) {\\n                    revert ERC721IncompatibleReceiver(to);\\n                }\\n            } catch {\\n                revert ERC721IncompatibleReceiver(to);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev : transfer function\\n     * @param from : from address\\n     * @param to : to address\\n     * @param id : token ID\\n     */\\n    function transferFrom(address from, address to, uint256 id) external payable {\\n        _transfer(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev : safeTransferFrom function with extra data\\n     * @param from : from address\\n     * @param to : to address\\n     * @param id : token ID\\n     * @param data : extra data\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) external payable {\\n        _transfer(from, to, id, data);\\n    }\\n\\n    /**\\n     * @dev : safeTransferFrom function\\n     * @param from : from address\\n     * @param to : to address\\n     * @param id : token ID\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id) external payable {\\n        _transfer(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev : grants approval for a token ID\\n     * @param approved : operator address to be approved\\n     * @param id : token ID\\n     */\\n    function approve(address approved, uint256 id) external payable {\\n        if (msg.sender != _ownerOf[id]) {\\n            revert Unauthorized(msg.sender, _ownerOf[id], id);\\n        }\\n\\n        getApproved[id] = approved;\\n        emit Approval(msg.sender, approved, id);\\n    }\\n\\n    /**\\n     * @dev : sets Controller (for all tokens)\\n     * @param operator : operator address to be set as Controller\\n     * @param approved : bool to set\\n     */\\n    function setApprovalForAll(address operator, bool approved) external payable {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev : generate metadata path corresponding to token ID\\n     * @param id : token ID\\n     * @return : IPFS path to metadata directory\\n     */\\n    function tokenURI(uint256 id) external view isValidToken(id) returns (string memory) {\\n        return string.concat(\\\"ipfs://\\\", metaIPFS, \\\"/\\\", id.toString(), \\\".json\\\");\\n    }\\n\\n    /**\\n     * @dev : royalty payment to Dev (or multi-sig)\\n     * @param id : token ID\\n     * @param _salePrice : sale price\\n     * @return : ether amount to be paid as royalty to Dev (or multi-sig)\\n     */\\n    function royaltyInfo(uint256 id, uint256 _salePrice) external view returns (address, uint256) {\\n        id; //silence warning\\n        return (Dev, _salePrice / 100 * royalty);\\n    }\\n\\n    // Contract Management\\n\\n    /**\\n     * @dev : transfer contract ownership to new Dev\\n     * @param newDev : new Dev\\n     */\\n    function transferOwnership(address newDev) external onlyDev {\\n        emit OwnershipTransferred(Dev, newDev);\\n        Dev = newDev;\\n    }\\n\\n    /**\\n     * @dev : get owner of contract\\n     * @return : address of controlling dev or multi-sig wallet\\n     */\\n    function owner() external view returns (address) {\\n        return Dev;\\n    }\\n\\n    /**\\n     * @dev : Toggle if contract is active or paused, only Dev can toggle\\n     */\\n    function toggleActive() external onlyDev {\\n        active = !active;\\n    }\\n\\n    /**\\n     * @dev : sets Default Resolver\\n     * @param _resolver : resolver address\\n     */\\n    function setDefaultResolver(address _resolver) external onlyDev {\\n        DefaultResolver = _resolver;\\n    }\\n\\n    /**\\n     * @dev : sets OpenSea contractURI\\n     * @param _contractURI : URI value\\n     */\\n    function setContractURI(string calldata _contractURI) external onlyDev {\\n        contractURI = _contractURI;\\n    }\\n\\n    //\\n    /**\\n     * @dev EIP2981 royalty standard\\n     * @param _royalty : royalty (1 = 1 %)\\n     */\\n    function setRoyalty(uint256 _royalty) external onlyDev {\\n        royalty = _royalty;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: WTFPL v6.9\\npragma solidity >=0.8.4;\\n\\ninterface iOverloadResolver {\\n    function addr(bytes32 node, uint256 coinType) external view returns (bytes memory);\\n}\\n\\ninterface iResolver {\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n    function addr(bytes32 node) external view returns (address payable);\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n    function text(bytes32 node, string calldata key) external view returns (string memory);\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\\ninterface iCCIP {\\n    function resolve(bytes memory name, bytes memory data) external view returns (bytes memory);\\n}\\n\\ninterface iERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n}\\n\\ninterface iENS {\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n    event Transfer(bytes32 indexed node, address owner);\\n    event NewResolver(bytes32 indexed node, address resolver);\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n    function recordExists(bytes32 node) external view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\\ninterface iERC2981 {\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\\ninterface iERC165 {\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\ninterface iERC173 {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n    function transferOwnership(address _newOwner) external;\\n}\\n\\ninterface iERC721 {\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    function balanceOf(address _owner) external view returns (uint256);\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\ninterface iERC721Receiver {\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data)\\n        external\\n        returns (bytes4);\\n}\\n\\ninterface iERC721Metadata {\\n    function name() external view returns (string memory _name);\\n    function symbol() external view returns (string memory _symbol);\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\ninterface iBENSYC {\\n    function totalSupply() external view returns (uint256);\\n    function Dev() external view returns (address);\\n    function Namehash2ID(bytes32 node) external view returns (uint256);\\n    function ID2Namehash(uint256 id) external view returns (bytes32);\\n    function ownerOf(uint256 id) external view returns (address);\\n}\\n\\ninterface iToken {\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n}\\n\"\r\n    },\r\n    \"src/Util.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: WTFPL v6.9\\npragma solidity >0.8.0 <0.9.0;\\n\\n// Utility functions\\nlibrary Util {\\n    /**\\n     * @dev Convert uint value to string number\\n     * @param value : uint value to be converted\\n     * @return : number as string\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev\\n     * @param buffer : bytes to be converted to hex\\n     * @return : hex string\\n     */\\n    function toHexString(bytes memory buffer) internal pure returns (string memory) {\\n        bytes memory converted = new bytes(buffer.length * 2);\\n        bytes memory _base = \\\"0123456789abcdef\\\";\\n        for (uint256 i; i < buffer.length; i++) {\\n            converted[i * 2] = _base[uint8(buffer[i]) / 16];\\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % 16];\\n        }\\n        return string(abi.encodePacked(\\\"0x\\\", converted));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Base.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: WTFPL v6.9\\npragma solidity >0.8.0 <0.9.0;\\n\\nimport \\\"src/Interface.sol\\\";\\n\\n/**\\n * @title BENSYC Definitions\\n */\\n\\nabstract contract BENSYC {\\n    /// @dev : ENS Contract Interface\\n    iENS public ENS;\\n\\n    /// @dev Pause/Resume contract\\n    bool public active = false;\\n\\n    /// @dev : Controller/Dev address\\n    address public Dev;\\n\\n    /// @dev : Modifier to allow only dev\\n    modifier onlyDev() {\\n        if (msg.sender != Dev) {\\n            revert OnlyDev(Dev, msg.sender);\\n        }\\n        _;\\n    }\\n\\n    // ERC721 details\\n    string public name = \\\"BoredENSYachtClub.eth\\\";\\n    string public symbol = \\\"BENSYC\\\";\\n\\n    /// @dev : Default resolver used by this contract\\n    address public DefaultResolver;\\n\\n    /// @dev : Current/Live supply of subdomains\\n    uint256 public totalSupply;\\n\\n    /// @dev : $ETH per subdomain mint\\n    uint256 public mintPrice = 0.01 ether;\\n\\n    /// @dev : Opensea Contract URI\\n    string public contractURI = \\\"ipfs://QmceyxoNqfPv1LNfYnmgxasXr8m8ghC3TbYuFbbqhH8pfV\\\";\\n\\n    /// @dev : ERC2981 Royalty info; 5 = 5%\\n    uint256 public royalty = 5;\\n\\n    /// @dev : IPFS hash of metadata directory\\n    string public metaIPFS = \\\"QmYgWXKADuSgWziNgmpYa4PAmhFL3W7aGLR5C1dkRuNGfM\\\";\\n\\n    mapping(address => uint256) public balanceOf;\\n    mapping(uint256 => address) internal _ownerOf;\\n    mapping(uint256 => address) public getApproved;\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    mapping(bytes4 => bool) public supportsInterface;\\n    mapping(uint256 => bytes32) public ID2Labelhash;\\n    mapping(bytes32 => uint256) public Namehash2ID;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event Approval(address indexed _owner, address indexed approved, uint256 indexed id);\\n    event ApprovalForAll(address indexed _owner, address indexed operator, bool approved);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    error Unauthorized(address operator, address owner, uint256 id);\\n    error NotSubdomainOwner(address owner, address from, uint256 id);\\n    error InsufficientEtherSent(uint256 size, uint256 yourSize);\\n    error ERC721IncompatibleReceiver(address addr);\\n    error OnlyDev(address _dev, address _you);\\n    error InvalidTokenID(uint256 id);\\n    error MintingPaused();\\n    error MintEnded();\\n    error ZeroAddress();\\n    error OversizedBatch();\\n    error TooSoonToMint();\\n\\n    modifier isValidToken(uint256 id) {\\n        if (id >= totalSupply) {\\n            revert InvalidTokenID(id);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev : setInterface\\n     * @param sig : signature\\n     * @param value : boolean\\n     */\\n    function setInterface(bytes4 sig, bool value) external payable onlyDev {\\n        require(sig != 0xffffffff, \\\"INVALID_INTERFACE_SELECTOR\\\");\\n        supportsInterface[sig] = value;\\n    }\\n\\n    /**\\n     * @dev : withdraw ether to multisig, anyone can trigger\\n     */\\n    function withdrawEther() external payable {\\n        (bool ok,) = Dev.call{value: address(this).balance}(\\\"\\\");\\n        require(ok, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /**\\n     * @dev : to be used in case some tokens get locked in the contract\\n     * @param token : token to release\\n     */\\n    function withdrawToken(address token) external payable {\\n        iERC20(token).transferFrom(address(this), Dev, iERC20(token).balanceOf(address(this)));\\n    }\\n\\n    /// @dev : revert on fallback\\n    fallback() external payable {\\n        revert();\\n    }\\n\\n    /// @dev : revert on receive\\n    receive() external payable {\\n        revert();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 6666\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ERC721IncompatibleReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yourSize\",\"type\":\"uint256\"}],\"name\":\"InsufficientEtherSent\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"InvalidTokenID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NotSubdomainOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_you\",\"type\":\"address\"}],\"name\":\"OnlyDev\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OversizedBatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooSoonToMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DefaultResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DomainHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENS\",\"outputs\":[{\"internalType\":\"contract iENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ID2Labelhash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ID2Namehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Namehash2ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaIPFS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setDefaultResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setInterface\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_royalty\",\"type\":\"uint256\"}],\"name\":\"setRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BoredENSYachtClub", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "6666", "ConstructorArguments": "00000000000000000000000028b16971b1331a294c13c3a1012f0cd0577fa130000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000631b2ac0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}