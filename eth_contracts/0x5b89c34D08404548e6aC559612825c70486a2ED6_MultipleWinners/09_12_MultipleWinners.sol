// SPDX-License-Identifier: GPL-3.0
pragma solidity =0.6.12;

import "./PeriodicPrizeStrategy.sol";
import "./interfaces/ITulipArt.sol";

contract MultipleWinners is PeriodicPrizeStrategy {
    uint256 internal __numberOfWinners;

    event NumberOfWinnersSet(uint256 numberOfWinners);
    event NoWinners();

    /// @notice Initialize the contract with default variables.
    /// @param _prizePeriodStart: The starting block of the prize period.
    /// @param _prizePeriodBlocks: The duration of the prize period in blocks.
    /// @param _tulipArt: The staking contract used to draw winners.
    /// @param _rng: The RNG service to use.
    /// @param _numberOfWinners: Number of winners of the lottery prize draw.
    constructor(
        uint256 _prizePeriodStart,
        uint256 _prizePeriodBlocks,
        uint32 _rngRequestTimeout,
        ITulipArt _tulipArt,
        RNGInterface _rng,
        uint256 _numberOfWinners
    ) public {
        PeriodicPrizeStrategy.initialize(
            _prizePeriodStart,
            _prizePeriodBlocks,
            _rngRequestTimeout,
            _tulipArt,
            _rng
        );

        _setNumberOfWinners(_numberOfWinners);
    }

    /// @param _count: number of winners that the lottery will have.
    function setNumberOfWinners(uint256 _count)
        external
        onlyOwner
        requireRngNotInFlight
    {
        _setNumberOfWinners(_count);
    }

    /// @return returns the amount of winners per lottery round.
    function numberOfWinners() external view returns (uint256) {
        return __numberOfWinners;
    }

    /// @notice Sets the number of possible winners for the lottery.
    /// @param _count: new number of winners to be set. Must be more than 1.
    function _setNumberOfWinners(uint256 _count) internal {
        require(_count > 0, "MultipleWinners/winners-gte-one");

        __numberOfWinners = _count;
        emit NumberOfWinnersSet(_count);
    }

    /// @notice Chooses the winners and sets their prizes based on %staked and
    /// random numbers.
    /// @param _randomNumber: number generated by the Chainlink VRF node.
    function _distribute(uint256 _randomNumber) internal override {
        // main winner is simply the first that is drawn
        address mainWinner = tulipArt.draw(_randomNumber);

        // If drawing yields no winner, then there is no one to pick
        // @NOTE with the way the staking contract is done this is unreachable
        // This is kept here just incase any future changes occur
        if (mainWinner == address(0)) {
            emit NoWinners();
            return;
        }

        address[] memory winners = new address[](__numberOfWinners);
        winners[0] = mainWinner;
        uint256 nextRandom = _randomNumber;
        for (
            uint256 winnerCount = 1;
            winnerCount < __numberOfWinners;
            winnerCount++
        ) {
            // add some arbitrary numbers to the previous random number to
            // ensure no matches with the UniformRandomNumber lib
            bytes32 nextRandomHash = keccak256(
                abi.encodePacked(nextRandom + 499 + winnerCount * 521)
            );
            nextRandom = uint256(nextRandomHash);
            winners[winnerCount] = tulipArt.draw(nextRandom);
        }

        // Set the winners for the round
        for (uint256 i = 0; i < winners.length; i++) {
            // SET WINNERS the NFT numbers should be by the minter contract
            tulipArt.setWinner(winners[i]);
        }
    }
}