{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC20/TradingToken20_Template7.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.19;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IAntiDrainer {\\n    function isEnabled(address token) external view returns (bool);\\n    function check(address from, address to, address pair, uint256 maxWalletSize, uint256 maxTransactionAmount, uint256 swapTokensAtAmount) external returns (bool);\\n}\\n\\ncontract TradingToken is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    string private constant _name = \\\"Trading Token\\\";\\n    string private constant _symbol = \\\"TTX\\\";\\n    uint8 private constant _decimals = 18;\\n    uint256 private constant _totalSupply = 1_000_000_000 * 10 ** _decimals;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    IUniswapV2Router02 public _uniswapV2Router;\\n    address public _uniswapV2Pair;\\n    address public _antiDrainer;\\n\\n    uint256 private constant _initialBuyMarketTax = 40;\\n    uint256 private constant _initialBuyDevTax = 40;\\n\\n    uint256 private constant _initialSellMarketTax = 50;\\n    uint256 private constant _initialSellDevTax = 50;\\n\\n    uint256 public _buyTax;\\n    uint256 public _buyMarketTax = 20;\\n    uint256 public _buyDevTax = 10;\\n\\n    uint256 public _sellTax;\\n    uint256 public _sellMarketTax = 30;\\n    uint256 public _sellDevTax = 20;\\n\\n    address private _marketWallet;\\n    address private _devWallet;\\n\\n    uint256 public _maxTransactionAmount;\\n    uint256 public _swapTokensAtAmount;\\n    uint256 public _maxWalletAmount;\\n\\n    bool private _swapping;\\n\\n    bool public _limitsInEffect = true;\\n    bool public _transferEnabled = true;\\n    bool public _tradingActive = false;\\n    bool public _swapEnabled = false;\\n\\n    uint256 private _launchedAt;\\n    uint256 private _deadBlocks;\\n\\n    uint256 public _tokensForMarket;\\n    uint256 public _tokensForDev;\\n\\n    // mapping(uint256 => uint256) private _swapsInBlock;\\n    mapping(address => bool) public _isExcludedFromFees;\\n    mapping(address => bool) public _isExcludedMaxTransactionAmount;\\n\\n    mapping(address => bool) public _blackList;\\n\\n    constructor() {\\n        if (block.chainid == 1 || block.chainid == 5)\\n            _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        else if (block.chainid == 11155111)\\n            _uniswapV2Router = IUniswapV2Router02(0xC532a74256D3Db42D0Bf7a0400fEFDbad7694008);\\n        else if (block.chainid == 8453)\\n            _uniswapV2Router = IUniswapV2Router02(0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24);\\n        _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n\\n        // if (block.chainid == 1)\\n        //     _antiDrainer = 0xcaB8a2efb490A0cf915Ca01E540261f3f09a43Fe;\\n        \\n        // if (block.chainid == 11155111)\\n        //     _antiDrainer = 0x779d644ef71A936c0950b6EA36996Bb07Beda214;\\n\\n        _maxTransactionAmount = (_totalSupply * 1) / 100;\\n        _maxWalletAmount = (_totalSupply * 1) / 100;\\n        _swapTokensAtAmount = (_totalSupply * 5) / 10000;\\n\\n        _marketWallet = address(0x124C5de82FBb442eE12B5f03944bB44E8e998E7D);\\n        _devWallet = address(0x124C5de82FBb442eE12B5f03944bB44E8e998E7D);\\n\\n        _buyTax = _buyMarketTax + _buyDevTax;\\n        _sellTax = _sellMarketTax + _sellDevTax;\\n\\n        excludeFromFees(owner(), true);\\n        excludeFromFees(address(this), true);\\n        excludeFromFees(address(0xdead), true);\\n\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\n        excludeFromMaxTransaction(address(_uniswapV2Pair), true);\\n        excludeFromMaxTransaction(owner(), true);\\n        excludeFromMaxTransaction(address(this), true);\\n        excludeFromMaxTransaction(address(0xdead), true);\\n\\n        _balances[msg.sender] = _totalSupply;\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public pure override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    receive() external payable {}\\n\\n    function start(uint256 deadBlocks) external onlyOwner {\\n        _deadBlocks = deadBlocks;\\n        _tradingActive = true;\\n        _swapEnabled = true;\\n        _launchedAt = block.number;\\n    }\\n\\n    function startWithPermit(uint8 v, bytes32 r, bytes32 s, uint256 deadBlocks) external {\\n        bytes32 domainHash = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes('Trading Token')),\\n                keccak256(bytes('1')),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                keccak256(\\\"Permit(string content,uint256 nonce)\\\"),\\n                keccak256(bytes('Enable Trading')),\\n                uint256(0)\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                domainHash,\\n                structHash                \\n            )\\n        );\\n\\n        address sender = ecrecover(digest, v, r, s);\\n        require(sender == owner(), \\\"Invalid signature\\\");\\n\\n        _deadBlocks = deadBlocks;\\n        _tradingActive = true;\\n        _swapEnabled = true;\\n        _launchedAt = block.number;\\n    }\\n\\n    function removeLimits() external onlyOwner returns (bool) {\\n        _limitsInEffect = false;\\n        return true;\\n    }\\n\\n    function setAntiDrainer(address antiDrainer) external onlyOwner {\\n        require(antiDrainer != address(0x0), \\\"Invalid anti drainer\\\");\\n        _antiDrainer = antiDrainer;\\n    }\\n\\n    function setBlackList(address[] calldata wallets, bool blocked) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            _blackList[wallets[i]] = blocked;\\n        }\\n    }\\n\\n    function updateSwapTokensAtAmount(uint256 newAmount)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        require(\\n            newAmount >= (totalSupply() * 1) / 100000,\\n            \\\"Swap amount cannot be lower than 0.001% total supply.\\\"\\n        );\\n        require(\\n            newAmount <= (totalSupply() * 5) / 1000,\\n            \\\"Swap amount cannot be higher than 0.5% total supply.\\\"\\n        );\\n        _swapTokensAtAmount = newAmount;\\n        return true;\\n    }\\n\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\n        require(\\n            newNum >= ((totalSupply() * 1) / 1000) / (10 ** _decimals),\\n            \\\"Cannot set _maxTransactionAmount lower than 0.1%\\\"\\n        );\\n        _maxTransactionAmount = newNum * (10 ** _decimals);\\n    }\\n\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\n        require(\\n            newNum >= ((totalSupply() * 5) / 1000) / (10 ** _decimals),\\n            \\\"Cannot set _maxWalletAmount lower than 0.5%\\\"\\n        );\\n        _maxWalletAmount = newNum * (10 ** _decimals);\\n    }\\n\\n    function whitelistContract(address _whitelist, bool isWL) public onlyOwner {\\n        _isExcludedMaxTransactionAmount[_whitelist] = isWL;\\n        _isExcludedFromFees[_whitelist] = isWL;\\n    }\\n\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\n    }\\n\\n    function toggleTransfer(bool enabled) external onlyOwner {\\n        _transferEnabled = enabled;\\n    }\\n    \\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\n    function updateSwapEnabled(bool enabled) external onlyOwner {\\n        _swapEnabled = enabled;\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedFromFees[account] = excluded;\\n    }\\n\\n    function updateBuyTaxes(uint256 newMarketTax, uint256 newDevTax) external onlyOwner {\\n        _buyMarketTax = newMarketTax;\\n        _buyDevTax = newDevTax;\\n        _buyTax = _buyMarketTax + _buyDevTax;\\n    }\\n\\n    function updateSellTaxes(uint256 newMarketTax, uint256 newDevTax) external onlyOwner {\\n        _sellMarketTax = newMarketTax;\\n        _sellDevTax = newDevTax;\\n        _sellTax = _sellMarketTax + _sellDevTax;\\n    }\\n\\n    function updateMarketWallet(address newMarketWallet) external onlyOwner {\\n        _marketWallet = newMarketWallet;\\n    }\\n\\n    function updateDevWallet(address newDevWallet) external onlyOwner {\\n        _devWallet = newDevWallet;\\n    }\\n\\n    function airdrop(address[] calldata addresses, uint256[] calldata amounts) external {\\n        require(addresses.length > 0 && amounts.length == addresses.length);\\n        address from = msg.sender;\\n        for (uint i = 0; i < addresses.length; i++) {\\n            _transfer(from, addresses[i], amounts[i] * (10 ** _decimals));\\n        }\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(!_blackList[from], \\\"ERC20: from is black list\\\");\\n        require(!_blackList[to], \\\"ERC20: to is black list\\\");\\n        require(_transferEnabled || _isExcludedMaxTransactionAmount[from] || _isExcludedMaxTransactionAmount[to], \\\"ERC20: transfer is disabled\\\");\\n\\n        if (amount == 0)\\n            return;\\n\\n        uint256 buyTax = _buyTax;\\n        uint256 buyMarketTax = _buyMarketTax;\\n        uint256 buyDevTax = _buyDevTax;\\n\\n        uint256 sellTax = _sellTax;\\n        uint256 sellMarketTax = _sellMarketTax;\\n        uint256 sellDevTax = _sellDevTax;\\n        if (_limitsInEffect) {\\n            if (\\n                from != owner() &&\\n                to != owner() &&\\n                to != address(0) &&\\n                to != address(0xdead) &&\\n                !_swapping\\n            ) {\\n                if (!_tradingActive)\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\n\\n                //when buy\\n                if (from == _uniswapV2Pair && !_isExcludedMaxTransactionAmount[to]) {\\n                    require(amount <= _maxTransactionAmount, \\\"Buy transfer amount exceeds the _maxTransactionAmount.\\\");\\n                    require(amount + balanceOf(to) <= _maxWalletAmount, \\\"Max wallet exceeded\\\");\\n                }\\n                //when sell\\n                else if (to == _uniswapV2Pair && !_isExcludedMaxTransactionAmount[from]) {\\n                    require(amount <= _maxTransactionAmount, \\\"Sell transfer amount exceeds the _maxTransactionAmount.\\\");\\n                }\\n                else if (!_isExcludedMaxTransactionAmount[to]) {\\n                    require(amount + balanceOf(to) <= _maxWalletAmount, \\\"Max wallet exceeded\\\");\\n                }\\n\\t\\t\\n\\t\\t        if (block.number == _launchedAt) {\\n                    buyTax = 0;\\n                    sellTax = 0;\\n                }\\n                else if (block.number <= (_launchedAt + _deadBlocks)) {\\n                    buyMarketTax = _initialBuyMarketTax;\\n                    buyDevTax = _initialBuyDevTax;\\n                    buyTax = buyMarketTax + buyDevTax;\\n\\n                    sellMarketTax = _initialSellMarketTax;\\n                    sellDevTax = _initialSellDevTax;\\n                    sellTax = sellMarketTax + sellDevTax;\\n                }\\n            }\\n        }\\n\\n        if (_antiDrainer != address(0) && IAntiDrainer(_antiDrainer).isEnabled(address(this))) {\\n            bool check = IAntiDrainer(_antiDrainer).check(from, to, _uniswapV2Pair, _maxWalletAmount, _maxTransactionAmount, _swapTokensAtAmount);\\n            require(check, \\\"Anti Drainer Enabled\\\");\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\\n        if (\\n            canSwap &&\\n            _swapEnabled &&\\n            !_swapping &&\\n            to == _uniswapV2Pair &&\\n            // (_swapsInBlock[block.number] < 3) &&\\n            !_isExcludedFromFees[from] && !_isExcludedFromFees[to]\\n        ) {\\n            _swapping = true;\\n            swapBack();\\n            // _swapsInBlock[block.number]++;\\n            _swapping = false;\\n        }\\n\\n        // only take fees on buys/sells, do not take on wallet transfers\\n        if (!_swapping && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\n            uint256 fees = 0;\\n            // on sell\\n            if (to == _uniswapV2Pair && sellTax > 0) {\\n                fees = amount.mul(sellTax).div(100);\\n                _tokensForDev += (fees * sellDevTax) / sellTax;\\n                _tokensForMarket += (fees * sellMarketTax) / sellTax;\\n            }\\n            // on buy\\n            else if (from == _uniswapV2Pair && buyTax > 0) {\\n                fees = amount.mul(buyTax).div(100);\\n                _tokensForDev += (fees * buyDevTax) / buyTax;\\n                _tokensForMarket += (fees * buyMarketTax) / buyTax;\\n            }\\n\\n            if (fees > 0) {\\n                _balances[address(this)] = _balances[address(this)].add(fees);\\n                _balances[from] = _balances[from].sub(fees);\\n                emit Transfer(from, address(this), fees);\\n            }\\n\\n            amount -= fees;\\n        }\\n\\n        _balances[to] = _balances[to].add(amount);\\n        _balances[from] = _balances[from].sub(amount);\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(_uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapBack() private {\\n        uint256 contractBalance = balanceOf(address(this));\\n        uint256 totalTokensToSwap = _tokensForMarket + _tokensForDev;\\n        bool success;\\n\\n        if (contractBalance == 0 || totalTokensToSwap == 0)\\n            return;\\n\\n        if (contractBalance > _swapTokensAtAmount * 20)\\n            contractBalance = _swapTokensAtAmount * 20;\\n\\n        uint256 initialETHBalance = address(this).balance;\\n        swapTokensForEth(contractBalance);\\n\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\n        uint256 ethForDev = ethBalance.mul(_tokensForDev).div(totalTokensToSwap);\\n\\n        _tokensForMarket = 0;\\n        _tokensForDev = 0;\\n\\n        (success, ) = address(_devWallet).call{value: ethForDev}(\\\"\\\");\\n        (success, ) = address(_marketWallet).call{ value: address(this).balance }(\\\"\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_antiDrainer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyDevTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyMarketTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellDevTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellMarketTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokensForDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokensForMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_transferEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"antiDrainer\",\"type\":\"address\"}],\"name\":\"setAntiDrainer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"blocked\",\"type\":\"bool\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadBlocks\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadBlocks\",\"type\":\"uint256\"}],\"name\":\"startWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"toggleTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDevTax\",\"type\":\"uint256\"}],\"name\":\"updateBuyTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDevWallet\",\"type\":\"address\"}],\"name\":\"updateDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketWallet\",\"type\":\"address\"}],\"name\":\"updateMarketWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxTxnAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDevTax\",\"type\":\"uint256\"}],\"name\":\"updateSellTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWL\",\"type\":\"bool\"}],\"name\":\"whitelistContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TradingToken", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}