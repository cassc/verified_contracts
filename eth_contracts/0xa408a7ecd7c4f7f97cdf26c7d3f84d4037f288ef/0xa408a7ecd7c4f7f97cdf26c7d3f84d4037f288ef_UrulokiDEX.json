{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UrulokiDex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Uruloki DEX is NOT LICENSED FOR COPYING.\\n// Uruloki DEX (C) 2022. All Rights Reserved.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ninterface IUniswapV2Router {\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Factory {\\n    function getPair(\\n        address tokenA, \\n        address tokenB\\n    ) external view returns (address pair);\\n}\\n\\ninterface IOrderMgr {\\n    //// Define enums\\n    enum OrderType {\\n        TargetPrice,\\n        PriceRange\\n    }\\n    enum OrderStatus {\\n        Active,\\n        Cancelled,\\n        OutOfFunds,\\n        Completed\\n    }\\n\\n    //// Define structs\\n    // One time order, it's a base order struct\\n    struct OrderBase {\\n        address userAddress;\\n        address pairedTokenAddress;\\n        address tokenAddress;\\n        OrderType orderType;\\n        uint256 targetPrice;\\n        bool isBuy;\\n        uint256 maxPrice;\\n        uint256 minPrice;\\n        OrderStatus status;\\n        uint256 amount;\\n        uint256 slippage;\\n        bool isContinuous;\\n    }\\n\\n    // Continuous Order, it's an extended order struct, including the base order struct\\n    struct Order {\\n        OrderBase orderBase;\\n        uint256 numExecutions;\\n        uint256 resetPercentage;\\n        bool hasPriceReset;\\n    }\\n\\n    function createOneTimeOrder(\\n        address userAddress,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 targetPrice,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage\\n    ) external returns (uint256);\\n\\n    function createContinuousOrder(\\n        address userAddress,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 targetPrice,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage,\\n        uint256 resetPercentage\\n    ) external returns (uint256);\\n\\n    function updateOrder(\\n        uint256 orderId,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 targetPrice,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage,\\n        uint256 resetPercentage\\n    ) external;\\n\\n    function cancelOrder(uint256 orderId) external returns (uint256);\\n\\n    function orderCounter() external view returns (uint256);\\n\\n    function getOrder(uint256 orderId) external view returns (Order memory);\\n\\n    function setOrderStatus(\\n        uint256 orderId,\\n        IOrderMgr.OrderStatus status\\n    ) external;\\n\\n    function incNumExecutions(uint256 orderId) external;\\n\\n    function setHasPriceReset(uint256 orderId, bool flag) external;\\n}\\n\\ninterface IERC20Ext is IERC20 {\\n    function decimals() external view returns (uint8);\\n}\\n\\ncontract UrulokiDEX is ReentrancyGuard {\\n    //// Define events\\n    // Event emitted when a one-time order is created\\n    event OneTimeOrderCreated(uint256 orderId);\\n\\n    // Event emitted when a continuous order is created\\n    event ContinuousOrderCreated(uint256 orderId);\\n\\n    // Event emitted when a one-time order is edited\\n    event OneTimeOrderEdited(uint256 orderId);\\n\\n    // Event emitted when a continuous order is edited\\n    event ContinuousOrderEdited(uint256 orderId);\\n\\n    // Event emitted when an order is canceled\\n    event OrderCanceled(uint256 orderId);\\n\\n    // Event emitted when the price is outside of the specified price range\\n    event ExecutedOutOfPrice(uint256 orderId, bool isBuy, uint256 price);\\n\\n    // Event emitted when a one-time order is successfully executed\\n    event ExecutedOneTimeOrder(\\n        uint256 orderId,\\n        bool isBuy,\\n        uint256 pairAmount,\\n        uint256 tokenAmount,\\n        uint256 price\\n    );\\n\\n    // Event emitted when a continuous order is successfully executed\\n    event ExecutedContinuousOrder(\\n        uint256 orderId,\\n        bool isBuy,\\n        uint256 price\\n    );\\n\\n    // Event emitted when funds are withdrawn from a user's address\\n    event FundsWithdrawn(\\n        address userAddress,\\n        address tokenAddress,\\n        uint256 amount\\n    );\\n\\n    // Event emitted when the owner of the contract is changed\\n    event BackendOwner(address newOwner);\\n\\n    // Event emitted when an order is out of funds\\n    event OutOfFunds(uint256 orderId);\\n\\n    // Event emitted when a swap during order execution fails\\n    event SwapFailed(uint256 orderId);\\n\\n    // This event is emitted when no valid pairs for USDC, USDT, TSUKA, or WETH are found for the specified order\\n    event PairNotFound(uint256 orderId);\\n\\n    //// Define constants\\n    address private constant UNISWAP_V2_ROUTER =\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address private constant UNISWAP_V2_FACTORY =\\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\\n    address private constant WETH =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address private constant USDT =\\n        0xc28ab4E347dd26C5809540e7dB0CEa473D91439c;\\n    address private constant USDC =\\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address private constant TSUKA =\\n        0xc5fB36dd2fb59d3B98dEfF88425a3F425Ee469eD;\\n\\n    //// Define variables\\n    mapping(address => mapping(address => uint256)) public balances;\\n\\n    IUniswapV2Router private uniswapRouter =\\n        IUniswapV2Router(UNISWAP_V2_ROUTER);\\n    IUniswapV2Factory private uniswapFactory =\\n        IUniswapV2Factory(UNISWAP_V2_FACTORY);\\n\\n    address public backend_owner;\\n    address public orderMgrAddress;\\n    IOrderMgr _orderMgr;\\n\\n    constructor() {\\n        backend_owner = msg.sender;\\n    }\\n\\n    modifier initOneTimeOrderBalance (\\n        uint256 orderId\\n    ) {\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\n\\n        // Validate order owner\\n        require(\\n            order.orderBase.userAddress == msg.sender,\\n            \\\"msg.sender is not order owner\\\"\\n        );\\n\\n        // Check if the order is a one-time order\\n        require(!order.orderBase.isContinuous, \\\"Incorrect order type\\\");\\n\\n        // Check if the order status is active\\n        require(order.orderBase.status == IOrderMgr.OrderStatus.Active, \\\"Incorrect order status\\\");\\n\\n        // Update the balances based on the order type\\n        if(order.orderBase.isBuy) {\\n            balances[msg.sender][order.orderBase.pairedTokenAddress] += order.orderBase.amount;\\n        } else {\\n            balances[msg.sender][order.orderBase.tokenAddress] += order.orderBase.amount;\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * @dev Validates a one-time order by checking the user's balance and updating it if necessary\\n     * @param pairedTokenAddress The address of the paired token\\n     * @param tokenAddress The address of the token\\n     * @param isBuy Boolean indicating if it's a buy order\\n     * @param amount The amount of tokens in the order\\n     * @return bool Returns true if the order is valid, false otherwise\\n     */\\n    function validateOneTimeOrder(\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        // if buying token, pair token is spendable else if sell, the token is spendable\\n        if (isBuy) {\\n            // Check if the user has enough balance\\n            if(balances[msg.sender][pairedTokenAddress] >= amount) {\\n                // Update the user's balance\\n                balances[msg.sender][pairedTokenAddress] -= amount;\\n            } else \\n                return false;\\n        } else {\\n            // Check if the user has enough balance\\n            if(balances[msg.sender][tokenAddress] >= amount) {\\n                // Update the user's balance\\n                balances[msg.sender][tokenAddress] -= amount;\\n            } else \\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    // set backend owner address\\n    function setBackendOwner(address new_owner) public {\\n        require(msg.sender == backend_owner, \\\"Not admin\\\");\\n        backend_owner = new_owner;\\n        emit BackendOwner(backend_owner);\\n    }\\n\\n    function setOrderMgr(address _orderMgrAddress) public {\\n        require(msg.sender == backend_owner, \\\"setOrderMgr: not allowed\\\");\\n        require(\\n            _orderMgrAddress != address(0),\\n            \\\"setOrderMgr: invalid orderMgrAddress\\\"\\n        );\\n        orderMgrAddress = _orderMgrAddress;\\n        _orderMgr = IOrderMgr(_orderMgrAddress);\\n    }\\n\\n    /**\\n     * @notice allows users to make a deposit\\n     * @dev token should be transferred from the user wallet to the contract\\n     * @param tokenAddress token address\\n     * @param amount deposit amount\\n     */\\n    function addFunds(\\n        address tokenAddress,\\n        uint256 amount\\n    ) external nonReentrant {\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\n\\n        IERC20 token = IERC20(tokenAddress);\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n\\n        require(\\n            token.transferFrom(msg.sender, address(this), amount),\\n            \\\"Transfer failed\\\"\\n        );\\n\\n        // Update the user's balance\\n        uint256 balanceDiff = token.balanceOf(address(this)) - balanceBefore;\\n        balances[USDT][tokenAddress] += balanceDiff;\\n        balances[msg.sender][tokenAddress] += balanceDiff;\\n    }\\n\\n    /**\\n     * @dev funds withdrawal external call\\n     * @param tokenAddress token address\\n     * @param amount token amount\\n     */\\n    function withdrawFunds(\\n        address tokenAddress,\\n        uint256 amount\\n    ) external nonReentrant {\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\n\\n        // Check if the user has enough balance to withdraw\\n        require(\\n            balances[msg.sender][tokenAddress] >= amount,\\n            \\\"Insufficient balance\\\"\\n        );\\n\\n        // Update the user's balance\\n        balances[msg.sender][tokenAddress] -= amount;\\n\\n        // Transfer ERC20 token to the user\\n        IERC20 token = IERC20(tokenAddress);\\n        require(token.transfer(msg.sender, amount), \\\"Transfer failed\\\");\\n        // Emit event\\n        emit FundsWithdrawn(msg.sender, tokenAddress, amount);\\n    }\\n\\n    /**\\n     * @notice create non-continuous price range order\\n     * @dev The orders are only executed when the market price is less than or equal to the minPrice and greater than or equal to the maxPrice\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     */\\n    function createNonContinuousPriceRangeOrder(\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage\\n    )   external nonReentrant {\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\n\\n        uint256 id = _orderMgr.createOneTimeOrder(\\n            msg.sender,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            0,\\n            minPrice,\\n            maxPrice,\\n            amount,\\n            slippage\\n        );\\n        // Emit an event\\n        emit OneTimeOrderCreated(id);\\n    }\\n\\n    /**\\n     * @notice creates a non-continuous order with a target price\\n     * @dev Target price orders are only executed when certain conditions are met:\\n     * - For buy orders, the market price must be less than or equal to the target price\\n     * - For sell orders, the market price must be greater than or equal to the target price\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     */\\n    function createNonContinuousTargetPriceOrder(\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 targetPrice,\\n        uint256 amount,\\n        uint256 slippage\\n    )   external nonReentrant {\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\n\\n        // Create a new order\\n        uint256 id = _orderMgr.createOneTimeOrder(\\n            msg.sender,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            targetPrice,\\n            0,\\n            0,\\n            amount,\\n            slippage\\n        );\\n\\n        // Emit event\\n        emit OneTimeOrderCreated(id);\\n    }\\n\\n    /**\\n     * @notice creates a continuous order with price range\\n     * @dev The orders are only executed continuely when the market price is less than or equal to the minPrice and greater than or equal to the maxPrice\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\n     */\\n    function createContinuousPriceRangeOrder(\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage,\\n        uint256 resetPercentage\\n    ) external nonReentrant {\\n        uint256 id = _orderMgr.createContinuousOrder(\\n            msg.sender,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            0,\\n            minPrice,\\n            maxPrice,\\n            amount,\\n            slippage,\\n            resetPercentage\\n        );\\n\\n        // Emit an event\\n        emit ContinuousOrderCreated(id);\\n    }\\n\\n    /**\\n     * @notice creates a continuous order with a target price\\n     * @dev The orders are only executed continuely when certain conditions are met:\\n     * - For buy orders, the market price must be less than or equal to the target price\\n     * - For sell orders, the market price must be greater than or equal to the target price\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\n     */\\n    function createContinuousTargetPriceOrder(\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 targetPrice,\\n        uint256 amount,\\n        uint256 slippage,\\n        uint256 resetPercentage\\n    ) external nonReentrant {\\n        // Create the ContinuousOrder struct\\n        uint256 id = _orderMgr.createContinuousOrder(\\n            msg.sender,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            targetPrice,\\n            0,\\n            0,\\n            amount,\\n            slippage,\\n            resetPercentage\\n        );\\n\\n        // Emit an event\\n        emit ContinuousOrderCreated(id);\\n    }\\n\\n    /**\\n     * @dev cancel exist order\\n     * @param orderId order id\\n     */\\n    function cancelOrder(uint256 orderId) external {\\n        // Validate order owner\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\n        require(\\n            order.orderBase.userAddress == msg.sender,\\n            \\\"msg.sender is not order owner\\\"\\n        );\\n\\n        _orderMgr.cancelOrder(orderId);\\n        if (!order.orderBase.isContinuous)\\n            if (order.orderBase.isBuy) {\\n                balances[msg.sender][order.orderBase.pairedTokenAddress] += order\\n                    .orderBase\\n                    .amount;\\n            } else {\\n                balances[msg.sender][order.orderBase.tokenAddress] += order\\n                    .orderBase\\n                    .amount;\\n            }\\n\\n        // Emit event\\n        emit OrderCanceled(orderId);\\n    }\\n\\n    /**\\n     * @notice process a one-time order\\n     * @dev internal function\\n     * @param orderId id of the order\\n     */\\n    function _processOneTimeOrder(IOrderMgr.Order memory order, uint256 orderId) internal returns (bool) {\\n        // Get the price in amount\\n        (uint256 price, bool isExistPair) = _getPairPrice(\\n            order.orderBase.tokenAddress,\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\n        );\\n        \\n        if(!isExistPair) {\\n            emit PairNotFound(orderId);\\n            return false;\\n        }\\n\\n        address fromToken;\\n        address toToken;\\n        uint256 toAmount;\\n        bool swapStatus;\\n\\n        // Check if the order type is PriceRange\\n        if (order.orderBase.orderType == IOrderMgr.OrderType.PriceRange) {\\n            if (\\n                order.orderBase.minPrice > price || price > order.orderBase.maxPrice\\n            ) {\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\n                return false;\\n            }\\n        }\\n\\n        if (order.orderBase.isBuy) {\\n            // Check if the order type is TargetPrice\\n            if (order.orderBase.orderType == IOrderMgr.OrderType.TargetPrice) {\\n                if (\\n                    price > order.orderBase.targetPrice\\n                ) {\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\n                    return false;\\n                }\\n            }\\n            fromToken = order.orderBase.pairedTokenAddress;\\n            toToken = order.orderBase.tokenAddress;\\n        } else {\\n            // Check if the order type is TargetPrice\\n            if (order.orderBase.orderType == IOrderMgr.OrderType.TargetPrice) {\\n                if (price < order.orderBase.targetPrice) {\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\n                    return false;\\n                }\\n            }\\n            fromToken = order.orderBase.tokenAddress;\\n            toToken = order.orderBase.pairedTokenAddress;\\n        }\\n\\n        (toAmount, swapStatus) = _swapTokens(\\n            order.orderBase.pairedTokenAddress, \\n            order.orderBase.tokenAddress,\\n            order.orderBase.isBuy,\\n            order.orderBase.amount,\\n            order.orderBase.slippage\\n        );\\n\\n        if(swapStatus) {\\n            balances[order.orderBase.userAddress][toToken] += toAmount;\\n\\n            _orderMgr.setOrderStatus(orderId, IOrderMgr.OrderStatus.Completed);\\n            emit ExecutedOneTimeOrder(\\n                orderId,\\n                order.orderBase.isBuy,\\n                order.orderBase.amount,\\n                toAmount,\\n                price\\n            );\\n\\n            return true;\\n        } else {\\n            emit SwapFailed(orderId);\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @notice process a continuous order\\n     * @dev internal function\\n     * @param orderId id of the order\\n     */\\n    function _processContinuousOrder(IOrderMgr.Order memory order, uint256 orderId) internal returns (bool){\\n        if (order.orderBase.targetPrice == 0) {\\n            // Price range order\\n            return _processContinuousPriceRangeOrder(order, orderId);\\n        } else {\\n            // Target price order\\n            return _processContinuousTargetPriceOrder(order, orderId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to process a continuous price range order\\n     * @param order The order memory instance\\n     * @param orderId Order ID\\n     * @return bool Returns true if the order is processed successfully, false otherwise\\n     */\\n    function _processContinuousPriceRangeOrder(\\n        IOrderMgr.Order memory order,\\n        uint256 orderId\\n    ) internal returns(bool) {\\n        // Get the price in amount\\n        (uint256 price, bool isExistPair) = _getPairPrice(\\n            order.orderBase.tokenAddress,\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\n        );\\n\\n        // Check if the price is not found for the pair\\n        if(!isExistPair) {\\n            emit PairNotFound(orderId);\\n            return false;\\n        }\\n\\n        // Check if the order has price reset\\n        if (order.hasPriceReset) {\\n            // Check if the price is within the specified range\\n            if (\\n                order.orderBase.minPrice > price || price > order.orderBase.maxPrice\\n            ) {\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\n                return false;\\n            }\\n            address fromToken;\\n            address toToken;\\n            uint256 toAmount;\\n            bool swapStatus;\\n\\n            // Determine the tokens for swapping based on the order type\\n            if (order.orderBase.isBuy) {\\n                fromToken = order.orderBase.pairedTokenAddress;\\n                toToken = order.orderBase.tokenAddress;\\n            } else {\\n                fromToken = order.orderBase.tokenAddress;\\n                toToken = order.orderBase.pairedTokenAddress;\\n            }\\n\\n            // Check if the user has enough balance of the fromToken\\n            if (\\n                balances[order.orderBase.userAddress][fromToken] >=\\n                order.orderBase.amount\\n            ) {\\n                // Swap tokens\\n                (toAmount, swapStatus) = _swapTokens(\\n                    order.orderBase.pairedTokenAddress,\\n                    order.orderBase.tokenAddress,\\n                    order.orderBase.isBuy,\\n                    order.orderBase.amount,\\n                    order.orderBase.slippage\\n                );\\n\\n                if(swapStatus) {\\n                    // Update user's balances\\n                    balances[order.orderBase.userAddress][toToken] += toAmount;\\n                    balances[order.orderBase.userAddress][fromToken] -= order\\n                        .orderBase\\n                        .amount;\\n                    \\n                    // Update order status and execution count\\n                    _orderMgr.setOrderStatus(orderId, IOrderMgr.OrderStatus.Active);\\n                    _orderMgr.incNumExecutions(orderId);\\n                    _orderMgr.setHasPriceReset(orderId, false);\\n\\n                    emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\n                } else {\\n                    emit SwapFailed(orderId);\\n                }\\n            } else {\\n                // Set order status as out of funds\\n                _orderMgr.setOrderStatus(\\n                    orderId,\\n                    IOrderMgr.OrderStatus.OutOfFunds\\n                );\\n                emit OutOfFunds(orderId);\\n            }\\n        } else {\\n            // Calculate the lower and upper price differences based on the reset percentage\\n            uint256 lowerDiff = (order.orderBase.minPrice *\\n                order.resetPercentage) / 100;\\n            uint256 upperDiff = (order.orderBase.maxPrice *\\n                order.resetPercentage) / 100;\\n\\n            // Check if the price is outside the adjusted range\\n            if (\\n                price > order.orderBase.minPrice - lowerDiff\\n                && price < order.orderBase.maxPrice + upperDiff\\n            ) {\\n                return false;\\n            }\\n\\n            // Set hasPriceReset to true for the order\\n            _orderMgr.setHasPriceReset(orderId, true);\\n        }\\n        \\n        return true;\\n    }\\n\\n    /**\\n     * @dev Processes a continuous order with a target price\\n     * @param order The order to process\\n     * @param orderId The ID of the order\\n     * @return bool Returns true if the order is successfully processed, false otherwise\\n     */\\n    function _processContinuousTargetPriceOrder(\\n        IOrderMgr.Order memory order,\\n        uint256 orderId\\n    ) internal returns (bool) {\\n        // Get the price in amount\\n        (uint256 price, bool isExistPair) = _getPairPrice(\\n            order.orderBase.tokenAddress,\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\n        );\\n\\n        // Check if the price is 0, indicating that the pair does not exist\\n        if(!isExistPair) {\\n            emit PairNotFound(orderId);\\n            return false;\\n        }\\n\\n        // Check if the order is a buy order\\n        if (order.orderBase.isBuy) {\\n            // Check if the order has price reset\\n            if (order.hasPriceReset) {\\n                // Check if the current price is greater than the target price\\n                if (price > order.orderBase.targetPrice) {\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\n                    return false;\\n                }\\n\\n                // Swap tokens and update balances\\n                uint256 toAmount;\\n                bool swapStatus;\\n\\n                // Check if the user has sufficient balance of fromToken\\n                if (\\n                    balances[order.orderBase.userAddress][order.orderBase.pairedTokenAddress] >=\\n                    order.orderBase.amount\\n                ) {\\n                    (toAmount, swapStatus) = _swapTokens(\\n                        order.orderBase.pairedTokenAddress,\\n                        order.orderBase.tokenAddress,\\n                        order.orderBase.isBuy,\\n                        order.orderBase.amount,\\n                        order.orderBase.slippage\\n                    );\\n\\n                    if(swapStatus) {\\n                        // Update user's balances\\n                        balances[order.orderBase.userAddress][order.orderBase.tokenAddress] += toAmount;\\n                        balances[order.orderBase.userAddress][order.orderBase.pairedTokenAddress] -= order\\n                            .orderBase\\n                            .amount;\\n\\n                        // Update order status and execution count\\n                        _orderMgr.setOrderStatus(\\n                            orderId,\\n                            IOrderMgr.OrderStatus.Active\\n                        );\\n                        _orderMgr.incNumExecutions(orderId);\\n                        _orderMgr.setHasPriceReset(orderId, false);\\n\\n                        emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\n                    } else {\\n                        emit SwapFailed(orderId);\\n                    }\\n                } else {\\n                    // Set order status as out of funds\\n                    _orderMgr.setOrderStatus(\\n                        orderId,\\n                        IOrderMgr.OrderStatus.OutOfFunds\\n                    );\\n                    emit OutOfFunds(orderId);\\n                }\\n            } else {\\n                uint256 diff = (order.orderBase.targetPrice *\\n                    order.resetPercentage) / 100;\\n\\n                // Check if the current price is less than the target price plus the difference\\n                if (price < order.orderBase.targetPrice + diff) {\\n                    return false;\\n                }\\n                _orderMgr.setHasPriceReset(orderId, true);\\n            }\\n        } else {\\n            // Check if the order has price reset\\n            if (order.hasPriceReset) {\\n                // Check if the current price is less than the target price\\n                if (price < order.orderBase.targetPrice) {\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\n                    return false;\\n                }\\n\\n                // Swap tokens and update balances\\n                uint256 toAmount;\\n                bool swapStatus;\\n\\n                // Check if the user has sufficient balance of fromToken\\n                if (\\n                    balances[order.orderBase.userAddress][order.orderBase.tokenAddress] >=\\n                    order.orderBase.amount\\n                ) {\\n                    (toAmount, swapStatus) = _swapTokens(\\n                        order.orderBase.pairedTokenAddress,\\n                        order.orderBase.tokenAddress,\\n                        order.orderBase.isBuy,\\n                        order.orderBase.amount,\\n                        order.orderBase.slippage\\n                    );\\n\\n                    if(swapStatus) {\\n                        balances[order.orderBase.userAddress][order.orderBase.pairedTokenAddress] += toAmount;\\n                        balances[order.orderBase.userAddress][order.orderBase.tokenAddress] -= order\\n                            .orderBase\\n                            .amount;\\n\\n                        _orderMgr.setOrderStatus(\\n                            orderId,\\n                            IOrderMgr.OrderStatus.Active\\n                        );\\n                        _orderMgr.incNumExecutions(orderId);\\n                        _orderMgr.setHasPriceReset(orderId, false);\\n\\n                        emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\n                    } else {\\n                        emit SwapFailed(orderId);\\n                    }\\n                } else {\\n                    _orderMgr.setOrderStatus(\\n                        orderId,\\n                        IOrderMgr.OrderStatus.OutOfFunds\\n                    );\\n                    emit OutOfFunds(orderId);\\n                }\\n            } else {\\n                uint256 diff = (order.orderBase.targetPrice *\\n                    order.resetPercentage) / 100;\\n\\n                // Check if the current price is greater than the target price minus the difference\\n                if (price > order.orderBase.targetPrice - diff) {\\n                    return false;\\n                }\\n                _orderMgr.setHasPriceReset(orderId, true);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n    /**\\n     * @dev Processes multiple orders based on the provided order IDs\\n     * @param orderIds An array of order IDs to process\\n     */\\n    function processOrders(\\n        uint256[] memory orderIds\\n    ) external {\\n        IOrderMgr.Order memory order;\\n\\n        // Iterate through each order ID in the orderIds array\\n        for (uint256 i = 0; i < orderIds.length; i++) {\\n            uint256 orderId = orderIds[i];\\n            order = _orderMgr.getOrder(orderId);\\n            \\n            // Check if the tokenAddress of the order is the zero address\\n            // If it is, skip to the next iteration of the loop\\n            if (order.orderBase.tokenAddress == address(0))\\n                continue;\\n\\n            // Check if the order is a continuous order\\n            if (order.orderBase.isContinuous == true) {\\n                // If the order is cancelled, skip to the next iteration of the loop\\n                if (order.orderBase.status == IOrderMgr.OrderStatus.Cancelled)\\n                    continue;\\n                _processContinuousOrder(order, orderId);\\n            } else {\\n                // If the order is not active, skip to the next iteration of the loop\\n                if (order.orderBase.status != IOrderMgr.OrderStatus.Active)\\n                    continue;\\n                _processOneTimeOrder(order, orderId);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Swaps tokens from one token to another using the Uniswap router\\n     * @param _pairedTokenAddress The address of the paired token\\n     * @param _tokenAddress The address of the token to swap to\\n     * @param _isBuy Indicates whether it is a buy or sell order\\n     * @param _amount The amount of tokens to swap\\n     * @param _slippage The maximum acceptable slippage for the swap\\n     * @return uint256 The amount of tokens received after the swap\\n     * @return bool The status of the swap (true if successful, false otherwise)\\n     */\\n    function _swapTokens(\\n        address _pairedTokenAddress,\\n        address _tokenAddress,\\n        bool _isBuy,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) internal returns (uint256, bool) {\\n        address _fromTokenAddress;\\n        address _toTokenAddress;\\n        address _middlePath = address(0);\\n\\n        if(_isBuy) {\\n            _fromTokenAddress = _pairedTokenAddress;\\n            _toTokenAddress = _tokenAddress;\\n        } else {\\n            _fromTokenAddress = _tokenAddress;\\n            _toTokenAddress = _pairedTokenAddress;\\n        }\\n\\n        if(!checkIfPairExists(_pairedTokenAddress, _tokenAddress)) {\\n            if(_pairedTokenAddress != WETH && checkIfPairExists(WETH, _tokenAddress)) {\\n                _middlePath = WETH;\\n            } else if (_pairedTokenAddress != USDC && checkIfPairExists(USDC, _tokenAddress)) {\\n                _middlePath = USDC;\\n            } else if(_pairedTokenAddress != USDT && checkIfPairExists(USDT, _tokenAddress)) {\\n                _middlePath = USDT;\\n            } else if(\\n                _pairedTokenAddress != TSUKA && \\n                _tokenAddress != TSUKA &&\\n                checkIfPairExists(TSUKA, _pairedTokenAddress) &&\\n                checkIfPairExists(TSUKA, _tokenAddress)\\n            ) {\\n                _middlePath = TSUKA;\\n            }\\n        } \\n\\n        IERC20 fromToken = IERC20(_fromTokenAddress);\\n        \\n        fromToken.approve(address(uniswapRouter), _amount);\\n\\n        uint256 balanceBefore = IERC20(_toTokenAddress).balanceOf(address(this));\\n\\n        if(_middlePath == address(0)) {\\n            address[] memory path = new address[](2);\\n            path[0] = _fromTokenAddress;\\n            path[1] = _toTokenAddress;\\n            \\n            uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                _amount,\\n                _slippage,\\n                path,\\n                address(this),\\n                block.timestamp\\n            );\\n        } else {\\n            address[] memory path = new address[](3);\\n            path[0] = _fromTokenAddress;\\n            path[1] = _middlePath;\\n            path[2] = _toTokenAddress;\\n            \\n            uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                _amount,\\n                _slippage,\\n                path,\\n                address(this),\\n                block.timestamp\\n            );\\n        }\\n        \\n        uint256 toAmount = IERC20(_toTokenAddress).balanceOf(address(this)) - balanceBefore;\\n\\n        // Return the amount of tokens received and the status of the swap\\n        return (toAmount, true);\\n    }\\n\\n    /**\\n    * @dev Checks if a pair exists for the given tokens in the Uniswap exchange\\n    * @param token1 The address of the first token\\n    * @param token2 The address of the second token\\n    * @return bool Returns true if a pair exists, false otherwise\\n    */\\n    function checkIfPairExists(\\n        address token1,\\n        address token2\\n    ) internal view returns(bool) {\\n        // Get the pair address from the Uniswap factory contract\\n        address pair = uniswapFactory.getPair(token1, token2);\\n        \\n        // If the pair address is equal to the zero address, it means the pair does not exist.\\n        if(pair == address(0)) return false;\\n        else return true;\\n    }\\n\\n    /**\\n    * @dev Retrieves the price of a token pair based on the specified token address and amount\\n    * @param _tokenAddress The address of the token\\n    * @param _amount The amount of the token\\n    * @return uint256 The price of the token pair\\n    */\\n    function _getPairPrice(\\n        address _tokenAddress,\\n        uint256 _amount\\n    ) internal view returns (uint256, bool) {\\n        // Check if a pair exists for USDC and the specified token\\n        if (checkIfPairExists(USDC, _tokenAddress)) {\\n            address[] memory path = new address[](2);\\n            path[0] = _tokenAddress;\\n            path[1] = USDC;\\n            return (getAmountOut(path, _amount), true);\\n        }\\n        \\n        // Check if a pair exists for USDT and the specified token\\n        if (checkIfPairExists(USDT, _tokenAddress)) {\\n            address[] memory path = new address[](2);\\n            path[0] = _tokenAddress;\\n            path[1] = USDT;\\n            return (getAmountOut(path, _amount), true);\\n        }\\n        \\n        // Check if a pair exists for WETH and the specified token\\n        if (checkIfPairExists(WETH, _tokenAddress)) {\\n            address[] memory path = new address[](3);\\n            path[0] = _tokenAddress;\\n            path[1] = WETH;\\n            path[2] = USDC;\\n            return (getAmountOut(path, _amount), true);\\n        }\\n        \\n        // Check if a pair exists for TSUKA and the specified token\\n        if (checkIfPairExists(TSUKA, _tokenAddress)) {\\n            address[] memory path = new address[](3);\\n            path[0] = _tokenAddress;\\n            path[1] = TSUKA;\\n            path[2] = USDC;\\n            return (getAmountOut(path, _amount), true);\\n        }\\n        \\n        // If no pair exists, return 0\\n        return (0, false);\\n    }\\n\\n    /**\\n     * @dev Retrieves the amount out for a given input amount and path of token addresses\\n     * @param path The array of token addresses representing the path\\n     * @param amount The input amount\\n     * @return uint256 The amount out\\n     */\\n    function getAmountOut(\\n        address[] memory path,\\n        uint256 amount\\n    ) internal view returns (uint256) {\\n        // Get the amounts out for the specified input amount and path\\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(amount, path);\\n        \\n        // The getAmountsOut function from the Uniswap router contract is called with the specified input amount and path\\n        // It returns an array of amounts representing the output amounts at each step of the path\\n\\n        // Return the amount out of the final token.\\n        // The amount out is obtained by accessing the last element of the amountsOut array using path.length - 1\\n        // This represents the output amount of the final token in the path after the swap\\n        return amountsOut[path.length - 1];\\n    }\\n\\n    /**\\n     * @dev Retrieves the price of a token based on the specified token address\\n     * @param _tokenAddress The address of the token\\n     * @return uint256 The price of the token\\n     */\\n    function getTokenPrice(\\n        address _tokenAddress\\n    ) external view returns (uint256) {\\n        // Get the decimals of the token\\n        uint256 tokenDecimals = 10 ** IERC20Ext(_tokenAddress).decimals();\\n\\n        // Get the pair price for the specified token\\n        (uint256 price, ) = _getPairPrice(_tokenAddress, tokenDecimals);\\n        return price;\\n    }\\n\\n    /**\\n     * @notice edit a continuous order with target price\\n     * @param orderId Order id\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\n     */\\n    function editContinuousTargetPriceOrder(\\n        uint256 orderId,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 targetPrice,\\n        uint256 amount,\\n        uint256 slippage,\\n        uint256 resetPercentage\\n    ) external {\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\n        // Validate order owner\\n        require(\\n            order.orderBase.userAddress == msg.sender,\\n            \\\"msg.sender is not order owner\\\"\\n        );\\n        // Is continous order\\n        require(order.orderBase.isContinuous == true, \\\"Incorrect order type\\\");\\n\\n        _orderMgr.updateOrder(\\n            orderId,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            targetPrice,\\n            0,\\n            0,\\n            amount,\\n            slippage,\\n            resetPercentage\\n        );\\n\\n        // Emit an event\\n        emit ContinuousOrderEdited(orderId);\\n    }\\n\\n    /**\\n     * @notice edit a continuous order with price range\\n     * @param orderId order id\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\n     */\\n    function editContinuousPriceRangeOrder(\\n        uint256 orderId,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage,\\n        uint256 resetPercentage\\n    ) external {\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\n        // Validate order owner\\n        require(\\n            order.orderBase.userAddress == msg.sender,\\n            \\\"msg.sender is not order owner\\\"\\n        );\\n        // Is continous order\\n        require(order.orderBase.isContinuous == true, \\\"Incorrect order type\\\");\\n\\n        _orderMgr.updateOrder(\\n            orderId,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            0,\\n            minPrice,\\n            maxPrice,\\n            amount,\\n            slippage,\\n            resetPercentage\\n        );\\n\\n        // Emit an event\\n        emit ContinuousOrderEdited(orderId);\\n    }\\n\\n    /**\\n     * @notice Edit non-continuous order with price range\\n     * @param orderId Order id\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     */\\n    function editNonContinuousPriceRangeOrder(\\n        uint256 orderId,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        bool isBuy,\\n        uint256 minPrice,\\n        uint256 maxPrice,\\n        uint256 amount,\\n        uint256 slippage\\n    ) \\n        external\\n        nonReentrant\\n        initOneTimeOrderBalance(orderId)\\n    {\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\n\\n        _orderMgr.updateOrder(\\n            orderId,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            0,\\n            minPrice,\\n            maxPrice,\\n            amount,\\n            slippage,\\n            0\\n        );\\n        // Emit an event\\n        emit OneTimeOrderEdited(orderId);\\n    }\\n\\n    /**\\n     * @notice Edit a non-continuous order with a target price\\n     * @dev Target price order is only executed when the market price is equal to the target price\\n     * @param orderId Order id\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\n     * @param tokenAddress The address of the token being traded\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\n     */\\n    function editNonContinuousTargetPriceOrder(\\n        uint256 orderId,\\n        address pairedTokenAddress,\\n        address tokenAddress,\\n        uint256 targetPrice,\\n        bool isBuy,\\n        uint256 amount,\\n        uint256 slippage\\n    ) \\n        external\\n        nonReentrant\\n        initOneTimeOrderBalance(orderId)\\n    {\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\n\\n        _orderMgr.updateOrder(\\n            orderId,\\n            pairedTokenAddress,\\n            tokenAddress,\\n            isBuy,\\n            targetPrice,\\n            0,\\n            0,\\n            amount,\\n            slippage,\\n            0\\n        );\\n\\n        // Emit event\\n        emit OneTimeOrderEdited(orderId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"BackendOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ContinuousOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ContinuousOrderEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedContinuousOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pairAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedOneTimeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedOutOfPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OneTimeOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OneTimeOrderEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OutOfFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"PairNotFound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"SwapFailed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backend_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"createNonContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"createNonContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"editContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"editContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"editNonContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"editNonContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderMgrAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderIds\",\"type\":\"uint256[]\"}],\"name\":\"processOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"setBackendOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_orderMgrAddress\",\"type\":\"address\"}],\"name\":\"setOrderMgr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UrulokiDEX", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}