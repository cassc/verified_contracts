{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsCanvasStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {CanvasHeader, IOpenAvatarGen0AssetsCanvasStore} from '../interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {FuseGuard} from '../lib/FuseGuard.sol';\\nimport {KeepAlive} from '../lib/KeepAlive.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsCanvasStore\\n * @dev This contract stores canvas headers\\n * @dev This contract is used for off-chain rendering\\n */\\ncontract OpenAvatarGen0AssetsCanvasStore is IOpenAvatarGen0AssetsCanvasStore, FuseGuard, KeepAlive {\\n  /// @dev Event emitted when a canvas is added.\\n  event CanvasAdd(uint8 id);\\n\\n  /// @dev Event emitted when the fuse is burned to disable adding a new canvas.\\n  event FuseBurnedCanAddCanvas();\\n\\n  /// @dev Rvert error when canvas already exists.\\n  error CanvasAlreadyExists(uint8 id);\\n  /// @dev Revert error when canvas does not exist.\\n  error CanvasDoesNotExist(uint8 id);\\n  /// @dev Revert error when canvas size is invalid.\\n  error InvalidCanvasSize(uint8 width, uint8 height);\\n\\n  /// @dev The canvas bytes per pixel.\\n  /// @dev the only reason this is separate and named with CANVAS_ prefix is because\\n  // there is another one in PaletteStore and they conflict\\n  uint8 public constant CANVAS_BYTES_PER_PIXEL = 4; // RGBA\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The canvas ids.\\n  uint8[] public canvasIds;\\n  /// @dev The canvas headers.\\n  mapping(uint => CanvasHeader) public canvasHeaders;\\n  /// @dev Whether a canvas exists.\\n  mapping(uint => bool) public canvasExists;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for adding a new canvas.\\n  bool public fuseBurnedCanAddCanvas = false;\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the configured owner\\n    // using a proxy allows for using same bytecode in test and prod\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // canvas\\n      interfaceId == 0x91411495 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreRead.\\n      interfaceId == 0x4d4a1c57 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreWrite.\\n      interfaceId == 0xdc0b08c2; // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStore.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable adding a new canvas.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanAddCanvas() external onlyOwner {\\n    if (fuseBurnedCanAddCanvas) return;\\n    fuseBurnedCanAddCanvas = true;\\n    emit FuseBurnedCanAddCanvas();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable adding a new canvas.\\n   * @return Whether the fuse is burned to permanently disable adding a new canvas.\\n   */\\n  function isFuseBurnedCanAddCanvas() external view returns (bool) {\\n    return fuseBurnedCanAddCanvas;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Canvas\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Add a canvas to the store.\\n   * @param header The canvas header.\\n   */\\n  function addCanvas(CanvasHeader calldata header) external override onlyOwner {\\n    if (fuseBurnedCanAddCanvas) revert OperationBlockedByBurnedFuse();\\n    if (canvasExists[header.id]) revert CanvasAlreadyExists(header.id);\\n    if (header.width == 0 || header.height == 0) revert InvalidCanvasSize(header.width, header.height);\\n    canvasHeaders[header.id] = header;\\n    canvasIds.push(header.id);\\n    canvasExists[header.id] = true;\\n    emit CanvasAdd(header.id);\\n  }\\n\\n  /**\\n   * @notice Return the number of canvases stored in the contract.\\n   * @return The number of canvases stored in the contract.\\n   */\\n  function hasCanvas(uint8 id) external view override returns (bool) {\\n    return canvasExists[id];\\n  }\\n\\n  /**\\n   * @notice Return the canvas header.\\n   * @param id The canvas to query.\\n   * @return The canvas header.\\n   * @dev Returns all zeroes if the canvas does not exist.\\n   */\\n  function getCanvasHeader(uint8 id) external view override returns (CanvasHeader memory) {\\n    return canvasHeaders[id];\\n  }\\n\\n  /**\\n   * @notice Return the number of canvases stored in the contract.\\n   * @return The number of canvases stored in the contract.\\n   */\\n  function getNumCanvasIds() external view override returns (uint) {\\n    return canvasIds.length;\\n  }\\n\\n  /**\\n   * @notice Return the number of canvases stored in the contract.\\n   * @return The array of canvas ids stored in the contract.\\n   */\\n  function getCanvasIds() external view override returns (uint8[] memory) {\\n    return canvasIds;\\n  }\\n\\n  /**\\n   * @notice Return the height of the canvas.\\n   * @param id The canvas to query.\\n   * @return The height of the canvas.\\n   */\\n  function getCanvasHeight(uint8 id) public view override returns (uint8) {\\n    return canvasHeaders[id].height;\\n  }\\n\\n  /**\\n   * @notice Return the width of the canvas.\\n   * @param id The canvas to query.\\n   * @return The width of the canvas.\\n   */\\n  function getCanvasWidth(uint8 id) public view override returns (uint8) {\\n    return canvasHeaders[id].width;\\n  }\\n\\n  /**\\n   * @notice Return the number of bytes in the canvas.\\n   * @param id The canvas to query.\\n   * @return The number of bytes in the canvas.\\n   */\\n  function getCanvasNumBytes(uint8 id) public view override returns (uint) {\\n    return CANVAS_BYTES_PER_PIXEL * uint(canvasHeaders[id].width) * uint(canvasHeaders[id].height);\\n  }\\n\\n  /**\\n   * @notice Return the number of pixels in the canvas.\\n   * @param id The canvas to query.\\n   * @return The number of pixels in the canvas.\\n   */\\n  function getCanvasNumPixels(uint8 id) public view override returns (uint) {\\n    return uint(canvasHeaders[id].width) * uint(canvasHeaders[id].height);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsPaletteStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStore, UploadPaletteBatchInput, UploadPaletteInput} from '../interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol';\\nimport {FuseGuard} from '../lib/FuseGuard.sol';\\nimport {KeepAlive} from '../lib/KeepAlive.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsPaletteStore\\n * @dev This contract stores color palettes by (code, index).\\n * @dev All palettes of a given code should be the same length.\\n */\\ncontract OpenAvatarGen0AssetsPaletteStore is IOpenAvatarGen0AssetsPaletteStore, FuseGuard, KeepAlive {\\n  /// @dev Error for invalid palette code.\\n  error InvalidPaletteCode(uint8 code);\\n  /// @dev Error for empty palette array.\\n  error EmptyPaletteArray();\\n  /// @dev Error for invalid palette index.\\n  error PaletteIndexOutOfBounds(uint8 code, uint8 index);\\n  /// @dev Error for palette already exists.\\n  error PaletteAlreadyExists(uint8 code, uint8 index);\\n  /// @dev Error for invalid palette length.\\n  error InvalidPaletteLength(uint length);\\n  /// @dev Error for invalid transparent color code.\\n  error InvalidTransparentColorCode(bytes4 code);\\n  /// @dev Event emitted when the fuse is burned to disable uploading a new palette.\\n  event FuseBurnedCanUploadPalette();\\n  /// @dev Event emitted when a palette is uploaded.\\n  event PaletteUpload(uint8 code, uint8 index);\\n\\n  /// @dev RGBA color depth.\\n  uint8 public constant DEPTH = 4;\\n  /// @dev Whether the canvas has an alpha channel.\\n  bool public constant HAS_ALPHA_CHANNEL = true;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The color palettes.\\n  /// @dev 5D array\\n  ///        bytes4 -----------> (red, green, blue, alpha) color\\n  ///        bytes4[] ---------> A color palette\\n  ///        bytes4[][] -------> A set of color palettes (for a palette code)\\n  ///        bytes4[][][] -----> All the color palette sets for all the palette codes\\n  bytes4[][][] public palettes;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for uploading a palette.\\n  bool public fuseBurnedCanUploadPalette = false;\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the configured owner\\n    // using a proxy allows for using same bytecode in test and prod\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Return whether the canvas has an alpha channel.\\n   * @return Whether the canvas has an alpha channel.\\n   */\\n  function hasAlphaChannel() external pure override returns (bool) {\\n    return HAS_ALPHA_CHANNEL;\\n  }\\n\\n  /**\\n   * @notice Return the number of bytes per pixel.\\n   * @return The number of bytes per pixel.\\n   */\\n  function getBytesPerPixel() public pure override returns (uint8) {\\n    return DEPTH;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // palette\\n      interfaceId == 0x5577825f || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreRead.\\n      interfaceId == 0x9c9764e9 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreWrite.\\n      interfaceId == 0xc9e0e6b6; // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStore.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable uploading a new palette.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanUploadPalette() external onlyOwner {\\n    if (fuseBurnedCanUploadPalette) return;\\n    fuseBurnedCanUploadPalette = true;\\n    emit FuseBurnedCanUploadPalette();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable uploading a new palette.\\n   * @return Whether the fuse is burned to permanently disable uploading a new palette.\\n   */\\n  function isFuseBurnedCanUploadPalette() external view returns (bool) {\\n    return fuseBurnedCanUploadPalette;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Palettes\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Get the number of palette codes.\\n   */\\n  function getNumPaletteCodes() external view override returns (uint) {\\n    return palettes.length;\\n  }\\n\\n  /**\\n   * @notice Get the number of palettes for the given layer and index.\\n   * @param code The palette code.\\n   */\\n  function getNumPalettes(uint8 code) external view override returns (uint) {\\n    return (code < palettes.length) ? palettes[code].length : 0;\\n  }\\n\\n  /**\\n   * @notice Get the palette for the given palette code and index.\\n   * @param code The code for which to get the palette.\\n   * @param index The index of the palette to get.\\n   * @return The palette for the given layer, pattern, index.\\n   * @dev Returns an empty array if the palette does not exist.\\n   */\\n  function getPalette(uint8 code, uint8 index) external view override returns (bytes4[] memory) {\\n    if (code < palettes.length) {\\n      bytes4[][] storage codePalettes = palettes[code];\\n      if (index < codePalettes.length) {\\n        return codePalettes[index];\\n      }\\n    }\\n    // return empty array if not found\\n    return new bytes4[](0);\\n  }\\n\\n  /**\\n   * @notice Store the given palette in the contract\\n   * @param input The palette to store.\\n   */\\n  function uploadPalette(UploadPaletteInput calldata input) external override onlyOwner {\\n    // check fuse\\n    if (fuseBurnedCanUploadPalette) revert OperationBlockedByBurnedFuse();\\n\\n    // should always include transparent (will revert later if index 0 is not transparent)\\n    if (input.palette.length == 0) revert InvalidPaletteLength(input.palette.length);\\n\\n    // Base Case: palettes[code] does not exist yet\\n    if (input.code == palettes.length) {\\n      // create new array of palettes\\n      palettes.push(new bytes4[][](0));\\n    }\\n    // Append Case: palettes[code] exists\\n    if (input.code < palettes.length) {\\n      bytes4[][] storage codePalettes = palettes[input.code];\\n\\n      // 3 cases:\\n      // 1. index == length, append (happy path)\\n      // 2. index < length, revert\\n      // 3. index > length, revert\\n      uint ct = codePalettes.length;\\n      if (input.index == ct) {\\n        // append\\n        // check that the first color is transparent\\n        if (input.palette[0] != 0x00000000) {\\n          revert InvalidTransparentColorCode(input.palette[0]);\\n        }\\n        // TODO: verify length of each palette matches the same as the first\\n        // palette uploaded for that code\\n        codePalettes.push(input.palette);\\n        emit PaletteUpload(input.code, input.index);\\n      } else if (input.index < ct) {\\n        // already exists\\n        revert PaletteAlreadyExists(input.code, input.index);\\n      } else {\\n        // index > ct out of bounds\\n        revert PaletteIndexOutOfBounds(input.code, input.index);\\n      }\\n    } else {\\n      // out of bounds\\n      revert InvalidPaletteCode(input.code);\\n    }\\n  }\\n\\n  /**\\n   * @notice Store the given palettes in the contract\\n   * @param input The paletted to store.\\n   */\\n  function uploadPaletteBatch(UploadPaletteBatchInput calldata input) external override onlyOwner {\\n    _uploadPaletteBatch(input);\\n  }\\n\\n  /**\\n   * @notice Store the given palettes in the contract\\n   * @param input The paletted to store.\\n   */\\n  function _uploadPaletteBatch(UploadPaletteBatchInput calldata input) internal {\\n    // check fuse\\n    if (fuseBurnedCanUploadPalette) revert OperationBlockedByBurnedFuse();\\n\\n    // should always include transparent (will revert later if index 0 is not transparent)\\n    if (input.palettes.length == 0) revert EmptyPaletteArray();\\n\\n    // Base Case: palettes[code] does not exist yet\\n    if (input.code == palettes.length) {\\n      // create new array of palettes\\n      palettes.push(new bytes4[][](0));\\n    }\\n    // Append Case: palettes[code] exists\\n    if (input.code < palettes.length) {\\n      bytes4[][] storage codePalettes = palettes[input.code];\\n\\n      // 3 cases:\\n      // 1. index == length, append (happy path)\\n      // 2. index < length, revert\\n      // 3. index > length, revert\\n      uint ct = codePalettes.length;\\n      if (input.fromIndex == ct) {\\n        // append all palettes\\n        uint len = input.palettes.length;\\n        for (uint i = 0; i < len; ) {\\n          bytes4[] calldata palette = input.palettes[i];\\n          // check that the first color is transparent\\n          if (palette[0] != 0x00000000) {\\n            revert InvalidTransparentColorCode(palette[0]);\\n          }\\n          // TODO: verify length of each palette matches?\\n          codePalettes.push(palette);\\n          emit PaletteUpload(input.code, uint8(i));\\n          unchecked {\\n            ++i;\\n          }\\n        }\\n      } else if (input.fromIndex < ct) {\\n        // already exists\\n        revert PaletteAlreadyExists(input.code, input.fromIndex);\\n      } else {\\n        // index > ct out of bounds\\n        revert PaletteIndexOutOfBounds(input.code, input.fromIndex);\\n      }\\n    } else {\\n      // out of bounds\\n      revert InvalidPaletteCode(input.code);\\n    }\\n  }\\n\\n  /**\\n   * @notice Batch upload multiple palette batches.\\n   * @param inputs The palette batches to upload.\\n   */\\n  function uploadPaletteBatches(UploadPaletteBatchInput[] calldata inputs) external override onlyOwner {\\n    uint len = inputs.length;\\n    for (uint i = 0; i < len; ) {\\n      _uploadPaletteBatch(inputs[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsPatternStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsPatternStore, OptionalPatternHeader, PatternHeader, PatternBlob, UploadPatternInput} from '../interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol';\\nimport {OpenAvatarGen0AssetsCanvasStore} from './OpenAvatarGen0AssetsCanvasStore.sol';\\nimport {OpenAvatarGen0AssetsPaletteStore} from './OpenAvatarGen0AssetsPaletteStore.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsPatternStore\\n * @dev This contract stores assets via:\\n * - canvas\\n * - layer\\n * - pattern\\n * and for palettes, by:\\n * - palette code\\n * - palette\\n */\\ncontract OpenAvatarGen0AssetsPatternStore is\\n  IOpenAvatarGen0AssetsPatternStore,\\n  OpenAvatarGen0AssetsCanvasStore,\\n  OpenAvatarGen0AssetsPaletteStore\\n{\\n  /// @dev Event emitted when the fuse is burned to disable adding a new layer.\\n  event FuseBurnedCanAddLayer();\\n  /// @dev Event emitted when the fuse is burned to disable uploading a pattern.\\n  event FuseBurnedCanUploadPattern();\\n  /// @dev Event emitted when a layer is added to a canvas.\\n  event LayerAdd(uint8 canvasId, uint8 layer);\\n  /// @dev Event emitted when a pattern is uploaded.\\n  event PatternUpload(uint8 canvasId, uint8 layer, uint8 pattern);\\n\\n  /// @dev Revert error when layer already exists.\\n  error LayerAlreadyExists(uint8 canvasId, uint8 layer);\\n  /// @dev Revert error when layer index is out of bounds.\\n  error LayerIndexOutOfBounds(uint8 canvasId, uint8 layer);\\n  /// @dev Revert error when pattern has invalid length.\\n  error InvalidPatternLength(uint width, uint height, uint length);\\n  /// @dev Revert error when pattern already exists.\\n  error PatternAlreadyExists(uint8 canvasId, uint8 layer, uint8 index);\\n  /// @dev Revert error when pattern index is out of bounds.\\n  error PatternIndexOutOfBounds(uint8 canvasId, uint8 layer, uint8 index);\\n  /// @dev Revert error when palette code does not exist.\\n  error UnknownPaletteCode(uint8 code);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Each pattern has a corresponding header describing the pattern data\\n  /// @dev Every pattern is an arbitrary blob of bytes\\n  mapping(uint => PatternBlob[][]) public patterns;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for adding a new layer.\\n  bool public fuseBurnedCanAddLayer = false;\\n  /// @dev Flag to indicate if the fuse has been burned for uploading a pattern.\\n  bool public fuseBurnedCanUploadPattern = false;\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(\\n    address ownerProxy\\n  ) OpenAvatarGen0AssetsCanvasStore(ownerProxy) OpenAvatarGen0AssetsPaletteStore(ownerProxy) {}\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view virtual override(OpenAvatarGen0AssetsCanvasStore, OpenAvatarGen0AssetsPaletteStore) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // canvas\\n      interfaceId == 0x91411495 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreRead.\\n      interfaceId == 0x4d4a1c57 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreWrite.\\n      interfaceId == 0xdc0b08c2 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStore.\\n      // palette\\n      interfaceId == 0x5577825f || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreRead.\\n      interfaceId == 0x9c9764e9 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreWrite.\\n      interfaceId == 0xc9e0e6b6 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStore.\\n      // pattern\\n      interfaceId == 0x32c8b38e || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreRead.\\n      interfaceId == 0xcd89a9e1 || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreWrite.\\n      interfaceId == 0xff411a6f; // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStore.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable adding a new layer.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanAddLayer() external onlyOwner {\\n    if (fuseBurnedCanAddLayer) return;\\n    fuseBurnedCanAddLayer = true;\\n    emit FuseBurnedCanAddLayer();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable adding a new layer.\\n   * @return Whether the fuse is burned to permanently disable adding a new layer.\\n   */\\n  function isFuseBurnedCanAddLayer() external view returns (bool) {\\n    return fuseBurnedCanAddLayer;\\n  }\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable uploading a new pattern.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanUploadPattern() external onlyOwner {\\n    if (fuseBurnedCanUploadPattern) return;\\n    fuseBurnedCanUploadPattern = true;\\n    emit FuseBurnedCanUploadPattern();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable uploading a new pattern.\\n   * @return Whether the fuse is burned to permanently disable uploading a new pattern.\\n   */\\n  function isFuseBurnedCanUploadPattern() external view returns (bool) {\\n    return fuseBurnedCanUploadPattern;\\n  }\\n\\n  /**************************************************************************\\n   * Helpers\\n   *************************************************************************/\\n\\n  /**\\n   * @notice Pack four uint8 values into a single uint32.\\n   * @param a The first uint8 value.\\n   * @param b The second uint8 value.\\n   * @param c The third uint8 value.\\n   * @param d The fourth uint8 value.\\n   * @param e The fifth uint8 value.\\n   * @return The packed uint40 value.\\n   */\\n  function packUint40(uint8 a, uint8 b, uint8 c, uint8 d, uint8 e) public pure returns (uint40) {\\n    return (uint40(a) << 32) | (uint40(b) << 24) | (uint40(c) << 16) | (uint40(d) << 8) | uint40(e);\\n  }\\n\\n  /**************************************************************************\\n   * Layers\\n   *************************************************************************/\\n\\n  /**\\n   * @notice Get the number of layers stored in the contract.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @return The number of layers stored in the contract.\\n   */\\n  function getNumLayers(uint8 canvasId) public view override returns (uint) {\\n    return patterns[canvasId].length;\\n  }\\n\\n  /**\\n   * @notice Add a new layer to the contract. The layer must not already exist. Layer indices may be skipped.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer to add.\\n   * @dev This function is only callable by the contract owner.\\n   */\\n  function addLayer(uint8 canvasId, uint8 layer) public override onlyOwner {\\n    if (fuseBurnedCanAddLayer) revert OperationBlockedByBurnedFuse();\\n    if (!canvasExists[canvasId]) revert CanvasDoesNotExist(canvasId);\\n    unchecked {\\n      // layers can be skipped when adding to reserve for later\\n      // so we need to fill in the skipped layers with empty arrays\\n      PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n      while (canvasPatterns.length < layer + 1) {\\n        canvasPatterns.push(new PatternBlob[](0));\\n      }\\n\\n      // now we have backfilled the layers, so procede with the main data\\n      PatternBlob[] storage patternsArrayForNewLayer = canvasPatterns[layer];\\n      if (patternsArrayForNewLayer.length == 0) {\\n        // transparent means no height/width/offsets\\n        // transparent layer has all zeros\\n        // transparent pattern is empty bytes\\n        patternsArrayForNewLayer.push(PatternBlob(PatternHeader(0, 0, 0, 0, 0), new bytes(0)));\\n        emit LayerAdd(canvasId, layer);\\n      } else {\\n        revert LayerAlreadyExists(canvasId, layer);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Add multiple layers to the contract. The layers must not already exist. Layer indices may be skipped.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layers_ The layers to add.\\n   * @dev This function is only callable by the contract owner.\\n   */\\n  function addLayers(uint8 canvasId, uint8[] calldata layers_) public override onlyOwner {\\n    if (!canvasExists[canvasId]) revert CanvasDoesNotExist(canvasId);\\n    uint len = layers_.length;\\n    for (uint i = 0; i < len; ) {\\n      addLayer(canvasId, layers_[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**************************************************************************\\n   * Patterns\\n   *************************************************************************/\\n\\n  /**\\n   * @notice Get the number of patterns for the given layer and index.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer for which to get the number of patterns.\\n   * @return The number of patterns for the given layer and index.\\n   */\\n  function getNumPatterns(uint8 canvasId, uint8 layer) public view override returns (uint) {\\n    PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n    if (layer < canvasPatterns.length) {\\n      return canvasPatterns[layer].length;\\n    } else {\\n      // we have a choice to return 0 or revert\\n      // since any valid layer always has a transparent pattern, we can return 0\\n      // and callers can use that to determine if the layer exists without handling\\n      // a revert\\n      return 0;\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the pattern header for the given layer and index.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer for which to get the pattern header.\\n   * @param index The index of the pattern header to get.\\n   * @return The pattern header for the given layer and index.\\n   */\\n  function getPatternHeader(\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 index\\n  ) external view override returns (OptionalPatternHeader memory) {\\n    PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n    if (layer < canvasPatterns.length) {\\n      PatternBlob[] storage layerPatterns = canvasPatterns[layer];\\n      if (index < layerPatterns.length) {\\n        return OptionalPatternHeader(true, layerPatterns[index].header);\\n      }\\n    }\\n    return OptionalPatternHeader(false, PatternHeader(0, 0, 0, 0, 0));\\n  }\\n\\n  /**\\n   * @notice Get the pattern for the given layer and index.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer for which to get the pattern data.\\n   * @param index The index of the pattern to get.\\n   * @return The pattern for the given layer and index.\\n   */\\n  function getPatternData(uint8 canvasId, uint8 layer, uint8 index) public view override returns (bytes memory) {\\n    PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n    if (layer < canvasPatterns.length) {\\n      PatternBlob[] storage layerPatterns = canvasPatterns[layer];\\n      if (index < layerPatterns.length) {\\n        return layerPatterns[index].data;\\n      }\\n    }\\n    return new bytes(0);\\n  }\\n\\n  /**\\n   * @notice Store the given pattern in the contract.\\n   * @param input The input.\\n   */\\n  function uploadPattern(UploadPatternInput calldata input) public override onlyOwner {\\n    if (fuseBurnedCanUploadPattern) revert OperationBlockedByBurnedFuse();\\n    if (!canvasExists[input.canvasId]) revert CanvasDoesNotExist(input.canvasId);\\n    // consistency checks\\n    if (input.data.length != uint(input.width) * uint(input.height)) {\\n      revert InvalidPatternLength(input.width, input.height, input.data.length);\\n    }\\n    if (input.paletteCode < palettes.length) {\\n      PatternBlob[][] storage canvasPatterns = patterns[input.canvasId];\\n      if (input.layer < canvasPatterns.length) {\\n        PatternBlob[] storage layerPatterns = canvasPatterns[input.layer];\\n        uint ct = layerPatterns.length;\\n\\n        // 3 cases:\\n        // 1. index == length, append (happy path)\\n        // 2. index < length, revert\\n        // 3. index > length, revert\\n        if (input.index == ct) {\\n          // append\\n          layerPatterns.push(\\n            PatternBlob(\\n              PatternHeader(input.width, input.height, input.offsetX, input.offsetY, input.paletteCode),\\n              input.data\\n            )\\n          );\\n\\n          emit PatternUpload(input.canvasId, input.layer, input.index);\\n        } else if (input.index < ct) {\\n          // already exists\\n          revert PatternAlreadyExists(input.canvasId, input.layer, input.index);\\n        } else {\\n          // out of bounds\\n          revert PatternIndexOutOfBounds(input.canvasId, input.layer, input.index);\\n        }\\n      } else {\\n        revert LayerIndexOutOfBounds(input.canvasId, input.layer);\\n      }\\n    } else {\\n      revert UnknownPaletteCode(input.paletteCode);\\n    }\\n  }\\n\\n  /**\\n   * @notice Batch upload multiple patterns.\\n   * @param inputs The uploadPattern inputs.\\n   */\\n  function uploadPatterns(UploadPatternInput[] calldata inputs) public override onlyOwner {\\n    if (fuseBurnedCanUploadPattern) revert OperationBlockedByBurnedFuse();\\n    uint len = inputs.length;\\n    for (uint i = 0; i < len; ) {\\n      uploadPattern(inputs[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/ens/registry/ENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n  /**\\n   * @dev Returns the address that owns the specified node.\\n   * @param node The specified node.\\n   * @return address of the owner.\\n   */\\n  function owner(bytes32 node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/ens/reverseRegistrar/IReverseRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\ninterface IReverseRegistrar {\\n  /**\\n   * @dev Transfers ownership of the reverse ENS record associated with the\\n   *      calling account.\\n   * @param owner The address to set as the owner of the reverse record in ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function claim(address owner) external returns (bytes32);\\n\\n  /**\\n   * @dev Sets the `name()` record for the reverse ENS record associated with\\n   * the calling account. First updates the resolver to the default reverse\\n   * resolver if necessary.\\n   * @param name The name to set for this address.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function setName(string memory name) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nstruct CanvasHeader {\\n  uint8 id;\\n  uint8 width;\\n  uint8 height;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStoreRead\\n * @dev This interface reads canvas headers.\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStoreRead {\\n  function hasCanvas(uint8 id) external view returns (bool);\\n\\n  function getCanvasHeader(uint8 id) external view returns (CanvasHeader memory);\\n\\n  function getNumCanvasIds() external view returns (uint);\\n\\n  function getCanvasIds() external view returns (uint8[] memory);\\n\\n  function getCanvasHeight(uint8 id) external view returns (uint8);\\n\\n  function getCanvasWidth(uint8 id) external view returns (uint8);\\n\\n  function getCanvasNumBytes(uint8 id) external view returns (uint);\\n\\n  function getCanvasNumPixels(uint8 id) external view returns (uint);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStoreWrite\\n * @dev This interface writes canvas headers\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStoreWrite {\\n  function addCanvas(CanvasHeader calldata header) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStore\\n * @dev This interface reads and writes canvas headers\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStore is\\n  IOpenAvatarGen0AssetsCanvasStoreRead,\\n  IOpenAvatarGen0AssetsCanvasStoreWrite\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStoreRead\\n * @dev This interface allows reading from the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStoreRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Constants\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function hasAlphaChannel() external view returns (bool);\\n\\n  function getBytesPerPixel() external view returns (uint8);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Palettes\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumPaletteCodes() external view returns (uint);\\n\\n  function getNumPalettes(uint8 code) external view returns (uint);\\n\\n  function getPalette(uint8 code, uint8 index) external view returns (bytes4[] memory);\\n}\\n\\nstruct UploadPaletteInput {\\n  uint8 code;\\n  uint8 index;\\n  bytes4[] palette;\\n}\\n\\nstruct UploadPaletteBatchInput {\\n  uint8 code;\\n  uint8 fromIndex;\\n  bytes4[][] palettes;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStoreWrite\\n * @dev This interface allows writing to the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStoreWrite {\\n  function uploadPalette(UploadPaletteInput calldata input) external;\\n\\n  function uploadPaletteBatch(UploadPaletteBatchInput calldata input) external;\\n\\n  function uploadPaletteBatches(UploadPaletteBatchInput[] calldata input) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStore\\n * @dev This interface allows reading from and writing to the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStore is\\n  IOpenAvatarGen0AssetsPaletteStoreRead,\\n  IOpenAvatarGen0AssetsPaletteStoreWrite\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsCanvasStore, IOpenAvatarGen0AssetsCanvasStoreRead, IOpenAvatarGen0AssetsCanvasStoreWrite} from './IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead, IOpenAvatarGen0AssetsPaletteStoreWrite, IOpenAvatarGen0AssetsPaletteStore} from './IOpenAvatarGen0AssetsPaletteStore.sol';\\n\\nstruct PatternHeader {\\n  /// @dev width of the pattern\\n  uint8 width;\\n  /// @dev height of the pattern\\n  uint8 height;\\n  /// @dev x offset of the pattern within the canvas\\n  uint8 offsetX;\\n  /// @dev y offset of the pattern within the canvas\\n  uint8 offsetY;\\n  /// @dev the palette code for the pattern\\n  uint8 paletteCode;\\n}\\n\\nstruct OptionalPatternHeader {\\n  /// @dev true if the header exists\\n  bool exists;\\n  /// @dev the pattern header\\n  /// @dev all zeroes is valid header\\n  PatternHeader header;\\n}\\n\\nstruct PatternBlob {\\n  /// @dev the pattern header\\n  PatternHeader header;\\n  /// @dev the pattern data\\n  bytes data;\\n}\\n\\nstruct UploadPatternInput {\\n  /// @dev the canvas id\\n  uint8 canvasId;\\n  /// @dev index of the layer within the canvas\\n  uint8 layer;\\n  /// @dev index of the pattern within the layer\\n  uint8 index;\\n  /// @dev width of the pattern\\n  uint8 width;\\n  /// @dev height of the pattern\\n  uint8 height;\\n  /// @dev x offset of the pattern within the canvas\\n  uint8 offsetX;\\n  /// @dev y offset of the pattern within the canvas\\n  uint8 offsetY;\\n  /// @dev the palette code for the pattern\\n  uint8 paletteCode;\\n  /// @dev the pattern data\\n  bytes data;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStoreRead\\n * @dev This interface reads pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStoreRead is IOpenAvatarGen0AssetsCanvasStoreRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumLayers(uint8 canvasId) external view returns (uint);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Patterns\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumPatterns(uint8 canvasId, uint8 layer) external view returns (uint);\\n\\n  function getPatternHeader(\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 index\\n  ) external view returns (OptionalPatternHeader memory);\\n\\n  function getPatternData(uint8 canvasId, uint8 layer, uint8 index) external view returns (bytes memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStoreWrite\\n * @dev This interface writes pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStoreWrite is IOpenAvatarGen0AssetsCanvasStoreWrite {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function addLayer(uint8 canvasId, uint8 layer) external;\\n\\n  function addLayers(uint8 canvasId, uint8[] calldata layers) external;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Patterns\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function uploadPattern(UploadPatternInput calldata input) external;\\n\\n  function uploadPatterns(UploadPatternInput[] calldata inputs) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStore\\n * @dev This interface reads and writes pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStore is\\n  IOpenAvatarGen0AssetsPatternStoreRead,\\n  IOpenAvatarGen0AssetsPatternStoreWrite,\\n  IOpenAvatarGen0AssetsCanvasStore\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/ENSReverseClaimer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {ENS} from '../dependencies/ens/registry/ENS.sol';\\nimport {IReverseRegistrar} from '../dependencies/ens/reverseRegistrar/IReverseRegistrar.sol';\\n\\n/**\\n * @title ENSReverseClaimer\\n * @dev This contract is used to claim reverse ENS records.\\n */\\nabstract contract ENSReverseClaimer is Ownable {\\n  /// @dev The namehash of 'addr.reverse', the domain at which reverse records\\n  ///      are stored in ENS.\\n  bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n  /**\\n   * @dev Transfers ownership of the reverse ENS record associated with the\\n   *      contract.\\n   * @param ens The ENS registry.\\n   * @param claimant The address to set as the owner of the reverse record in\\n   *                 ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function claimReverseENS(ENS ens, address claimant) external onlyOwner returns (bytes32) {\\n    return IReverseRegistrar(ens.owner(ADDR_REVERSE_NODE)).claim(claimant);\\n  }\\n\\n  /**\\n   * @dev Sets the reverse ENS record associated with the contract.\\n   * @param ens The ENS registry.\\n   * @param name The name to set as the reverse record in ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function setReverseENS(ENS ens, string calldata name) external onlyOwner returns (bytes32) {\\n    return IReverseRegistrar(ens.owner(ADDR_REVERSE_NODE)).setName(name);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/FuseGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title FuseGuard\\n * @dev A contract that manages fuses.\\n */\\nabstract contract FuseGuard {\\n  /// @dev Revert error when operation is blocked by burned fuse.\\n  error OperationBlockedByBurnedFuse();\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/KeepAlive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title KeepAlive\\n * @dev KeepAlive is a contract designed to maintain its onchain presence in\\n * case of state expiration by using payable receive() and fallback() functions,\\n * while allow the owner to still withdraw funds.\\n * fallback():\\n *   - Default function that gets executed when no other function in the contract\\n *     matches the provided function signature, or when the contract receives\\n *     Ether along with data\\n *   - Can be payable or non-payable\\n *   - Must be marked external\\n * receive():\\n *   - Introduced in Solidity 0.6.0\\n *   - Special function that is executed when a contract receives Ether without\\n *     any data\\n *   - Must be payable\\n *   - Must be marked external\\n *   - Makes it easier to differentiate between intended Ether transfers and\\n *     other function calls\\n */\\ncontract KeepAlive is Ownable {\\n  /**\\n   * @notice Fallback function.\\n   * @dev fallback():\\n   *  - Default function that gets executed when no other function in the contract\\n   *    matches the provided function signature, or when the contract receives\\n   *    Ether along with data\\n   *  - Can be payable or non-payable\\n   *  - Must be marked external\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  fallback() external payable {}\\n\\n  /**\\n   * @notice Receive funds.\\n   * @dev receive():\\n   *   - Introduced in Solidity 0.6.0\\n   *   - Special function that is executed when a contract receives Ether without\\n   *     any data\\n   *   - Must be payable\\n   *   - Must be marked external\\n   *   - Makes it easier to differentiate between intended Ether transfers and\\n   *     other function calls\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  receive() external payable {}\\n\\n  /**\\n   * @notice Withdraw funds from the contract.\\n   */\\n  function withdraw(uint amount) external onlyOwner {\\n    payable(msg.sender).transfer(amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarSentinel\\n * @dev An interface for the OpenAvatar sentinel.\\n */\\ninterface IOpenAvatarSentinel {\\n  /// @dev Returns true\\n  function openAvatar() external view returns (bool);\\n}\\n\\n/**\\n * @title IOpenAvatarGeneration\\n * @dev An interface for the OpenAvatar generation.\\n */\\ninterface IOpenAvatarGeneration {\\n  /// @dev Returns the generation of the OpenAvatar\\n  function openAvatarGeneration() external view returns (uint);\\n}\\n\\n/**\\n * @title IOpenAvatar\\n * @dev The OpenAvatar interface.\\n */\\ninterface IOpenAvatar is IOpenAvatarSentinel, IOpenAvatarGeneration {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsCanvasStore, IOpenAvatarGen0AssetsCanvasStoreRead, IOpenAvatarGen0AssetsCanvasStoreWrite} from './core/interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead, IOpenAvatarGen0AssetsPaletteStoreWrite, IOpenAvatarGen0AssetsPaletteStore} from './core/interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol';\\nimport {IOpenAvatarGen0AssetsPatternStoreRead, IOpenAvatarGen0AssetsPatternStoreWrite, IOpenAvatarGen0AssetsPatternStore} from './core/interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol';\\n\\n/**\\n * @title IOpenAvatarGen0AssetsRead\\n * @dev This interface reads asset data\\n */\\ninterface IOpenAvatarGen0AssetsRead is\\n  IOpenAvatarGen0AssetsCanvasStoreRead,\\n  IOpenAvatarGen0AssetsPatternStoreRead,\\n  IOpenAvatarGen0AssetsPaletteStoreRead\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsWrite\\n * @dev This interface writes asset data\\n */\\ninterface IOpenAvatarGen0AssetsWrite is\\n  IOpenAvatarGen0AssetsCanvasStoreWrite,\\n  IOpenAvatarGen0AssetsPatternStoreWrite,\\n  IOpenAvatarGen0AssetsPaletteStoreWrite\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatarGen0Assets\\n * @dev This interface reads and writes asset data\\n */\\ninterface IOpenAvatarGen0Assets is IOpenAvatarGen0AssetsRead, IOpenAvatarGen0AssetsWrite {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGen0Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {OpenAvatarGen0AssetsCanvasStore} from './core/assets/OpenAvatarGen0AssetsCanvasStore.sol';\\nimport {OpenAvatarGen0AssetsPaletteStore} from './core/assets/OpenAvatarGen0AssetsPaletteStore.sol';\\nimport {OpenAvatarGen0AssetsPatternStore} from './core/assets/OpenAvatarGen0AssetsPatternStore.sol';\\nimport {ENSReverseClaimer} from './core/lib/ENSReverseClaimer.sol';\\nimport {IOpenAvatarGen0Assets} from './IOpenAvatarGen0Assets.sol';\\nimport {OpenAvatarGenerationZero} from './OpenAvatarGenerationZero.sol';\\n\\n/**\\n * @title OpenAvatarGen0Assets\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @dev This contract is responsible for storing OpenAvatar art assets and\\n *      metadata. The art was created by hand by the contract author.\\n *\\n * Immutability:\\n * - This contract references no other contracts\\n * - All assets are stored in append-only arrays.\\n * - Once uploaded, no asset can be modified or deleted.\\n * - So, asset references are immutable and reads are invariant.\\n * - Fuses can be burned to prevent contract owner uploading further assets.\\n * - If all fuses are burned, no further assets can be uploaded and storage is\\n *   effectively frozen.\\n *\\n * Terminology:\\n * Colors are stored as color palettes.\\n * Patterns are byte arrays that reference colors in a palette.\\n *\\n * - Palettes:\\n *   - A \\\"palette\\\" is an array of RGBA colors (bytes4[]).\\n *   - A \\\"palette code\\\" defines an array of palettes (bytes4[][]).\\n *\\n * - Canvas\\n *   - A \\\"canvas\\\" is an image canvas with header (uint8 id, uint8 height,\\n *   uint8 width), and an array of layers.\\n *\\n * - Layer\\n *   - A \\\"layer\\\" is a layer of a canvas, which references an array of patterns.\\n *\\n * - Pattern\\n *  - A \\\"pattern\\\" is a byte array that references colors by index in a palette.\\n *\\n * Fuses:\\n * - A fuse can be burned to prevent adding new canvases.\\n * - A fuse can be burned to prevent adding new layers (for all canvases).\\n * - A fuse can be burned to prevent adding new patterns (for all layers).\\n * - A fuse can be burned to prevent adding new palettes (for all patterns).\\n *\\n * Solidity:\\n * Due to C3 Linearization, we cannot \\\"is\\\" IOpenAvatarGen0Assets.\\n * However, IOpenAvatarGen0Assets is indeed implemented fully by OpenAvatarGen0AssetsPatternStore.\\n */\\ncontract OpenAvatarGen0Assets is OpenAvatarGenerationZero, OpenAvatarGen0AssetsPatternStore, ENSReverseClaimer {\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(address ownerProxy) OpenAvatarGen0AssetsPatternStore(ownerProxy) {}\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure override(OpenAvatarGenerationZero, OpenAvatarGen0AssetsPatternStore) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // assets\\n      interfaceId == 0x67bf31d1 || // ERC165 interface ID for IOpenAvatarGen0AssetsRead.\\n      interfaceId == 0x511ecd08 || // ERC165 interface ID for IOpenAvatarGen0AssetsWrite.\\n      interfaceId == 0x36a1fcd9 || // ERC165 interface ID for IOpenAvatarGen0Assets.\\n      // canvas\\n      interfaceId == 0x91411495 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreRead.\\n      interfaceId == 0x4d4a1c57 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreWrite.\\n      interfaceId == 0xdc0b08c2 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStore.\\n      // palette\\n      interfaceId == 0x5577825f || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreRead.\\n      interfaceId == 0x9c9764e9 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreWrite.\\n      interfaceId == 0xc9e0e6b6 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStore.\\n      // pattern\\n      interfaceId == 0x32c8b38e || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreRead.\\n      interfaceId == 0xcd89a9e1 || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreWrite.\\n      interfaceId == 0xff411a6f; // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStore.\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGenerationZero.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatar} from './IOpenAvatar.sol';\\n\\n/**\\n * @title IOpenAvatarGeneration\\n * @dev OpenAvatar Generation 0 common definitions.\\n */\\nabstract contract OpenAvatarGenerationZero is IOpenAvatar {\\n  /// @dev OpenAvatar Generation 0.\\n  uint public constant OPENAVATAR_GENERATION_ZERO = 0;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarGeneration\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns 0, in reference to Open Avatar Generation 0.\\n   * @return 0 (zero).\\n   */\\n  function openAvatarGeneration() external pure returns (uint) {\\n    return OPENAVATAR_GENERATION_ZERO;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarSentinel\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns true.\\n   * @dev This is a sentinel function to indicate that this contract is an\\n   * OpenAvatar contract.\\n   * @return True.\\n   */\\n  function openAvatar() public pure returns (bool) {\\n    return true;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4; // ERC165 interface ID for IOpenAvatar.\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"shanghai\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"CanvasAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"CanvasDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyPaletteArray\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"}],\"name\":\"InvalidCanvasSize\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"}],\"name\":\"InvalidPaletteCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"InvalidPaletteLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"InvalidPatternLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"code\",\"type\":\"bytes4\"}],\"name\":\"InvalidTransparentColorCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"}],\"name\":\"LayerAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"}],\"name\":\"LayerIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperationBlockedByBurnedFuse\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"PaletteAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"PaletteIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"PatternAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"PatternIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"}],\"name\":\"UnknownPaletteCode\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"CanvasAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanAddCanvas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanAddLayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanUploadPalette\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanUploadPattern\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"}],\"name\":\"LayerAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"PaletteUpload\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"pattern\",\"type\":\"uint8\"}],\"name\":\"PatternUpload\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"CANVAS_BYTES_PER_PIXEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPTH\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HAS_ALPHA_CHANNEL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPENAVATAR_GENERATION_ZERO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"}],\"internalType\":\"struct CanvasHeader\",\"name\":\"header\",\"type\":\"tuple\"}],\"name\":\"addCanvas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"}],\"name\":\"addLayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"layers_\",\"type\":\"uint8[]\"}],\"name\":\"addLayers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanAddCanvas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanAddLayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanUploadPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanUploadPattern\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"canvasExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"canvasHeaders\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"canvasIds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"}],\"name\":\"claimReverseENS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanAddCanvas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanAddLayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanUploadPalette\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanUploadPattern\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBytesPerPixel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"getCanvasHeader\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"}],\"internalType\":\"struct CanvasHeader\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"getCanvasHeight\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCanvasIds\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"getCanvasNumBytes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"getCanvasNumPixels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"getCanvasWidth\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumCanvasIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"}],\"name\":\"getNumLayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumPaletteCodes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"}],\"name\":\"getNumPalettes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"}],\"name\":\"getNumPatterns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getPalette\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getPatternData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getPatternHeader\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetX\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"paletteCode\",\"type\":\"uint8\"}],\"internalType\":\"struct PatternHeader\",\"name\":\"header\",\"type\":\"tuple\"}],\"internalType\":\"struct OptionalPatternHeader\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasAlphaChannel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"hasCanvas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanAddCanvas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanAddLayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanUploadPalette\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanUploadPattern\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGeneration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"a\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"c\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"d\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"e\",\"type\":\"uint8\"}],\"name\":\"packUint40\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"palettes\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"patterns\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetX\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"paletteCode\",\"type\":\"uint8\"}],\"internalType\":\"struct PatternHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setReverseENS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"palette\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct UploadPaletteInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"uploadPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fromIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[][]\",\"name\":\"palettes\",\"type\":\"bytes4[][]\"}],\"internalType\":\"struct UploadPaletteBatchInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"uploadPaletteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"code\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fromIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[][]\",\"name\":\"palettes\",\"type\":\"bytes4[][]\"}],\"internalType\":\"struct UploadPaletteBatchInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"}],\"name\":\"uploadPaletteBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetX\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"paletteCode\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct UploadPatternInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"uploadPattern\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"canvasId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetX\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offsetY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"paletteCode\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct UploadPatternInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"}],\"name\":\"uploadPatterns\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OpenAvatarGen0Assets", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000000027390b412440c58100929acfeae2", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}