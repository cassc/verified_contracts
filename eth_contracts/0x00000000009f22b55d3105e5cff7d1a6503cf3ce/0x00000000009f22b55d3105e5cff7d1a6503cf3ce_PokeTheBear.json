{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PokeTheBear.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {LowLevelWETH} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\\\";\\nimport {LowLevelERC20Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\\\";\\nimport {PackableReentrancyGuard} from \\\"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\\\";\\nimport {Pausable} from \\\"@looksrare/contracts-libs/contracts/Pausable.sol\\\";\\n\\nimport {ITransferManager} from \\\"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\\\";\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {VRFCoordinatorV2Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport {VRFConsumerBaseV2} from \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\n\\nimport {IPokeTheBear} from \\\"./interfaces/IPokeTheBear.sol\\\";\\n\\n//       \u2229\uff3f\uff3f\uff3f\u2229\\n//      |\u30ce      \u30fd\\n//     /   \u25cf    \u25cf | \u30af\u30de\u2500\u2500\uff01\uff01\\n//    |     (_\u25cf_) \u30df\\n//   \u5f61\uff64     |\u222a|  \uff64\uff40\uff3c\\n// / \uff3f\uff3f    \u30fd\u30ce /\u00b4>   )\\n// (\uff3f\uff3f\uff3f\uff09     /  (_\uff0f\\n//   |        /\\n//   |   \uff0f\uff3c  \uff3c\\n//   | /     )   )\\n//    \u222a     \uff08   \uff3c\\n//            \uff3c\uff3f)\\n\\n/**\\n * @title Poke The Bear, a bear might maul you to death if you poke it.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract PokeTheBear is\\n    IPokeTheBear,\\n    AccessControl,\\n    Pausable,\\n    PackableReentrancyGuard,\\n    LowLevelERC20Transfer,\\n    LowLevelWETH,\\n    VRFConsumerBaseV2\\n{\\n    /**\\n     * @notice Operators are allowed to commit rounds\\n     */\\n    bytes32 private constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n\\n    /**\\n     * @notice 100% in basis points.\\n     */\\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS = 10_000;\\n\\n    /**\\n     * @notice The maximum number of players per round.\\n     */\\n    uint256 private constant MAXIMUM_NUMBER_OF_PLAYERS_PER_ROUND = 32;\\n\\n    /**\\n     * @notice The minimum duration for a round.\\n     */\\n    uint40 private constant MINIMUM_ROUND_DURATION = 1 minutes;\\n\\n    /**\\n     * @notice The maximum duration for a round.\\n     */\\n    uint40 private constant MAXIMUM_ROUND_DURATION = 1 hours;\\n\\n    /**\\n     * @notice Wrapped native token address. (WETH for most chains)\\n     */\\n    address private immutable WRAPPED_NATIVE_TOKEN;\\n\\n    /**\\n     * @notice The key hash of the Chainlink VRF.\\n     */\\n    bytes32 private immutable KEY_HASH;\\n\\n    /**\\n     * @notice The subscription ID of the Chainlink VRF.\\n     */\\n    uint64 private immutable SUBSCRIPTION_ID;\\n\\n    /**\\n     * @notice The Chainlink VRF coordinator.\\n     */\\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\\n\\n    /**\\n     * @notice The transfer manager to handle ERC-20 deposits.\\n     */\\n    ITransferManager private immutable TRANSFER_MANAGER;\\n\\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\\n\\n    mapping(uint256 caveId => mapping(uint256 => Round)) private rounds;\\n\\n    /**\\n     * @notice Player participations in each round.\\n     * @dev 65,536 x 256 = 16,777,216 rounds, which is enough for 5 minutes rounds for 159 years.\\n     */\\n    mapping(address playerAddress => mapping(uint256 caveId => uint256[65536] roundIds)) private playerParticipations;\\n\\n    mapping(uint256 caveId => Cave) public caves;\\n\\n    /**\\n     * @notice The address of the protocol fee recipient.\\n     */\\n    address public protocolFeeRecipient;\\n\\n    /**\\n     * @notice The next cave ID.\\n     */\\n    uint256 public nextCaveId = 1;\\n\\n    /**\\n     * @param _owner The owner of the contract.\\n     * @param _protocolFeeRecipient The address of the protocol fee recipient.\\n     * @param wrappedNativeToken The wrapped native token address.\\n     * @param _transferManager The transfer manager to handle ERC-20 deposits.\\n     * @param keyHash The key hash of the Chainlink VRF.\\n     * @param vrfCoordinator The Chainlink VRF coordinator.\\n     * @param subscriptionId The subscription ID of the Chainlink VRF.\\n     */\\n    constructor(\\n        address _owner,\\n        address _operator,\\n        address _protocolFeeRecipient,\\n        address wrappedNativeToken,\\n        address _transferManager,\\n        bytes32 keyHash,\\n        address vrfCoordinator,\\n        uint64 subscriptionId\\n    ) VRFConsumerBaseV2(vrfCoordinator) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\\n        _grantRole(OPERATOR_ROLE, _operator);\\n        WRAPPED_NATIVE_TOKEN = wrappedNativeToken;\\n        KEY_HASH = keyHash;\\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n        SUBSCRIPTION_ID = subscriptionId;\\n        TRANSFER_MANAGER = ITransferManager(_transferManager);\\n\\n        _updateProtocolFeeRecipient(_protocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function addCave(\\n        uint256 enterAmount,\\n        address enterCurrency,\\n        uint8 playersPerRound,\\n        uint40 roundDuration,\\n        uint16 protocolFeeBp\\n    ) external returns (uint256 caveId) {\\n        _validateIsOwner();\\n\\n        if (playersPerRound < 2) {\\n            revert InsufficientNumberOfPlayers();\\n        }\\n\\n        if (playersPerRound > MAXIMUM_NUMBER_OF_PLAYERS_PER_ROUND) {\\n            revert ExceedsMaximumNumberOfPlayersPerRound();\\n        }\\n\\n        if (protocolFeeBp > 2_500) {\\n            revert ProtocolFeeBasisPointsTooHigh();\\n        }\\n\\n        unchecked {\\n            if (\\n                (enterAmount - ((enterAmount * protocolFeeBp) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS)) %\\n                    (playersPerRound - 1) !=\\n                0\\n            ) {\\n                revert IndivisibleEnterAmount();\\n            }\\n        }\\n\\n        if (roundDuration < MINIMUM_ROUND_DURATION || roundDuration > MAXIMUM_ROUND_DURATION) {\\n            revert InvalidRoundDuration();\\n        }\\n\\n        caveId = nextCaveId;\\n\\n        caves[caveId].enterAmount = enterAmount;\\n        caves[caveId].enterCurrency = enterCurrency;\\n        caves[caveId].playersPerRound = playersPerRound;\\n        caves[caveId].roundDuration = roundDuration;\\n        caves[caveId].protocolFeeBp = protocolFeeBp;\\n        caves[caveId].isActive = true;\\n\\n        _open({caveId: caveId, roundId: 1});\\n\\n        unchecked {\\n            ++nextCaveId;\\n        }\\n\\n        emit CaveAdded(caveId, enterAmount, enterCurrency, roundDuration, playersPerRound, protocolFeeBp);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function removeCave(uint256 caveId) external {\\n        _validateIsOwner();\\n\\n        Cave storage cave = caves[caveId];\\n        if (cave.roundsCount < cave.lastCommittedRoundId) {\\n            revert RoundsIncomplete();\\n        }\\n\\n        caves[caveId].isActive = false;\\n        emit CaveRemoved(caveId);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function commit(CommitmentCalldata[] calldata commitments) external {\\n        _validateIsOperator();\\n        uint256 commitmentsLength = commitments.length;\\n        for (uint256 i; i < commitmentsLength; ) {\\n            uint256 caveId = commitments[i].caveId;\\n            Cave storage cave = caves[caveId];\\n            if (!cave.isActive) {\\n                revert InactiveCave();\\n            }\\n\\n            uint256 startingRoundId = cave.lastCommittedRoundId + 1;\\n\\n            bytes32[] calldata perCaveCommitments = commitments[i].commitments;\\n            uint256 perCaveCommitmentsLength = perCaveCommitments.length;\\n\\n            for (uint256 j; j < perCaveCommitmentsLength; ) {\\n                uint256 roundId = startingRoundId + j;\\n                bytes32 commitment = perCaveCommitments[j];\\n\\n                if (commitment == bytes32(0)) {\\n                    revert InvalidCommitment(caveId, roundId);\\n                }\\n\\n                rounds[caveId][roundId].commitment = commitment;\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            cave.lastCommittedRoundId = uint40(startingRoundId + perCaveCommitmentsLength - 1);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit CommitmentsSubmitted(commitments);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function updateProtocolFeeRecipient(address _protocolFeeRecipient) external {\\n        _validateIsOwner();\\n        _updateProtocolFeeRecipient(_protocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     * @notice As rounds to enter are in numerical order and cannot be skipped,\\n               entering multiple rounds can revert when a round in between is already filled.\\n               Resolve by sending multiple transactions of consecutive rounds if such issue exists.\\n               Fee on transfer tokens will not be supported.\\n     * @dev Players can still deposit into the round past the cutoff time. Only when other players start withdrawing\\n     *      or deposit into the next round, the current round will be cancelled and no longer accept deposits.\\n     */\\n    function enter(\\n        uint256 caveId,\\n        uint256 startingRoundId,\\n        uint256 numberOfRounds\\n    ) external payable nonReentrant whenNotPaused {\\n        Cave storage cave = caves[caveId];\\n\\n        address enterCurrency = cave.enterCurrency;\\n        uint256 enterAmount = cave.enterAmount * numberOfRounds;\\n\\n        if (enterCurrency == address(0)) {\\n            if (msg.value != enterAmount) {\\n                revert InvalidEnterAmount();\\n            }\\n        } else {\\n            if (msg.value != 0) {\\n                revert InvalidEnterCurrency();\\n            }\\n            TRANSFER_MANAGER.transferERC20(enterCurrency, msg.sender, address(this), enterAmount);\\n        }\\n\\n        _enter(caveId, startingRoundId, numberOfRounds);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     * @dev Player index starts from 1 as the array has a fixed length of 32 and\\n     *      0 is used to indicate an empty slot.\\n     */\\n    function reveal(uint256 requestId, uint256 playerIndices, bytes32 salt) external whenNotPaused {\\n        RandomnessRequest storage randomnessRequest = randomnessRequests[requestId];\\n        uint256 caveId = randomnessRequest.caveId;\\n        uint256 roundId = randomnessRequest.roundId;\\n\\n        Round storage round = rounds[caveId][roundId];\\n        if (round.status != RoundStatus.Drawn) {\\n            revert InvalidRoundStatus();\\n        }\\n\\n        if (keccak256(abi.encodePacked(playerIndices, salt)) != round.commitment) {\\n            revert HashedPlayerIndicesDoesNotMatchCommitment();\\n        }\\n\\n        uint256 numberOfPlayers = round.players.length;\\n        uint256 losingIndex = (randomnessRequest.randomWord % numberOfPlayers) + 1;\\n\\n        // Check numbers are nonrepeating and within the range\\n        uint256 playerIndicesBitmap;\\n        for (uint256 i; i < numberOfPlayers; ) {\\n            uint8 playerIndex = uint8(playerIndices >> (i * 8));\\n\\n            // Player index starts from 1\\n            if (playerIndex == 0 || playerIndex > numberOfPlayers) {\\n                revert InvalidPlayerIndex(caveId, roundId);\\n            }\\n\\n            uint256 bitmask = 1 << playerIndex;\\n\\n            if (playerIndicesBitmap & bitmask != 0) {\\n                revert RepeatingPlayerIndex();\\n            }\\n\\n            playerIndicesBitmap |= bitmask;\\n\\n            round.playerIndices[i] = playerIndex;\\n\\n            if (playerIndex == losingIndex) {\\n                round.players[i].isLoser = true;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        round.salt = salt;\\n        round.status = RoundStatus.Revealed;\\n\\n        emit RoundStatusUpdated(caveId, roundId, RoundStatus.Revealed);\\n\\n        Cave storage cave = caves[caveId];\\n        _transferTokens(\\n            protocolFeeRecipient,\\n            cave.enterCurrency,\\n            (cave.enterAmount * cave.protocolFeeBp) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS\\n        );\\n\\n        _open(caveId, _unsafeAdd(roundId, 1));\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function refund(WithdrawalCalldata[] calldata refundCalldataArray) external nonReentrant whenNotPaused {\\n        TransferAccumulator memory transferAccumulator;\\n        uint256 refundCount = refundCalldataArray.length;\\n\\n        Withdrawal[] memory withdrawalEventData = new Withdrawal[](refundCount);\\n\\n        for (uint256 i; i < refundCount; ) {\\n            WithdrawalCalldata calldata refundCalldata = refundCalldataArray[i];\\n            uint256 caveId = refundCalldata.caveId;\\n            Cave storage cave = caves[caveId];\\n            uint256 roundsCount = refundCalldata.playerDetails.length;\\n\\n            Withdrawal memory withdrawal = withdrawalEventData[i];\\n            withdrawal.caveId = caveId;\\n            withdrawal.roundIds = new uint256[](roundsCount);\\n\\n            for (uint256 j; j < roundsCount; ) {\\n                PlayerWithdrawalCalldata calldata playerDetails = refundCalldata.playerDetails[j];\\n                uint256 roundId = playerDetails.roundId;\\n\\n                Round storage round = rounds[caveId][roundId];\\n                RoundStatus roundStatus = round.status;\\n                uint256 currentNumberOfPlayers = round.players.length;\\n\\n                {\\n                    if (roundStatus < RoundStatus.Revealed) {\\n                        if (!_cancellable(round, roundStatus, cave.playersPerRound, currentNumberOfPlayers)) {\\n                            revert InvalidRoundStatus();\\n                        }\\n                        _cancel(caveId, roundId);\\n                    }\\n\\n                    uint256 playerIndex = playerDetails.playerIndex;\\n                    if (playerIndex >= currentNumberOfPlayers) {\\n                        revert InvalidPlayerIndex(caveId, roundId);\\n                    }\\n\\n                    Player storage player = round.players[playerIndex];\\n                    _validatePlayerCanWithdraw(caveId, roundId, player);\\n                    player.withdrawn = true;\\n                }\\n\\n                withdrawal.roundIds[j] = roundId;\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            _accumulateOrTransferTokenOut(cave.enterAmount * roundsCount, cave.enterCurrency, transferAccumulator);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (transferAccumulator.amount != 0) {\\n            _transferTokens(msg.sender, transferAccumulator.tokenAddress, transferAccumulator.amount);\\n        }\\n\\n        emit DepositsRefunded(withdrawalEventData, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     * @dev If a player chooses to rollover his prizes, only the principal is rolled over. The profit is\\n     *      always sent back to the player.\\n     */\\n    function rollover(RolloverCalldata[] calldata rolloverCalldataArray) external payable nonReentrant whenNotPaused {\\n        TransferAccumulator memory entryAccumulator;\\n        TransferAccumulator memory prizeAccumulator;\\n        Rollover[] memory rolloverEventData = new Rollover[](rolloverCalldataArray.length);\\n\\n        uint256 msgValueLeft = msg.value;\\n        for (uint256 i; i < rolloverCalldataArray.length; ) {\\n            RolloverCalldata calldata rolloverCalldata = rolloverCalldataArray[i];\\n            uint256 roundsCount = rolloverCalldata.playerDetails.length;\\n            if (roundsCount == 0) {\\n                revert InvalidPlayerDetails();\\n            }\\n\\n            uint256 caveId = rolloverCalldata.caveId;\\n            Cave storage cave = caves[caveId];\\n            uint256 numberOfExtraRoundsToEnter = rolloverCalldata.numberOfExtraRoundsToEnter;\\n            address enterCurrency = cave.enterCurrency;\\n\\n            // Enter extra rounds\\n            if (numberOfExtraRoundsToEnter != 0) {\\n                if (enterCurrency == address(0)) {\\n                    msgValueLeft -= cave.enterAmount * numberOfExtraRoundsToEnter;\\n                } else {\\n                    if (enterCurrency == entryAccumulator.tokenAddress) {\\n                        entryAccumulator.amount += cave.enterAmount * numberOfExtraRoundsToEnter;\\n                    } else {\\n                        if (entryAccumulator.amount != 0) {\\n                            TRANSFER_MANAGER.transferERC20(\\n                                entryAccumulator.tokenAddress,\\n                                msg.sender,\\n                                address(this),\\n                                entryAccumulator.amount\\n                            );\\n                        }\\n\\n                        entryAccumulator.tokenAddress = enterCurrency;\\n                        entryAccumulator.amount = cave.enterAmount * numberOfExtraRoundsToEnter;\\n                    }\\n                }\\n            }\\n\\n            Rollover memory rolloverEvent = rolloverEventData[i];\\n            rolloverEvent.caveId = caveId;\\n            rolloverEvent.rolledOverRoundIds = new uint256[](roundsCount);\\n\\n            uint256 prizeAmount;\\n\\n            for (uint256 j; j < roundsCount; ) {\\n                PlayerWithdrawalCalldata calldata playerDetails = rolloverCalldata.playerDetails[j];\\n\\n                RoundStatus roundStatus = _handleRolloverRound(playerDetails, caveId, cave.playersPerRound);\\n\\n                if (roundStatus == RoundStatus.Revealed) {\\n                    prizeAmount += _prizeAmount(cave);\\n                }\\n\\n                rolloverEvent.rolledOverRoundIds[j] = playerDetails.roundId;\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            uint256 startingRoundId = rolloverCalldata.startingRoundId;\\n            rolloverEvent.rollingOverToRoundIdStart = startingRoundId;\\n\\n            _enter({\\n                caveId: caveId,\\n                startingRoundId: startingRoundId,\\n                numberOfRounds: roundsCount + numberOfExtraRoundsToEnter\\n            });\\n\\n            if (prizeAmount != 0) {\\n                _accumulateOrTransferTokenOut(prizeAmount, enterCurrency, prizeAccumulator);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (msgValueLeft != 0) {\\n            revert InvalidEnterAmount();\\n        }\\n\\n        if (entryAccumulator.amount != 0) {\\n            TRANSFER_MANAGER.transferERC20(\\n                entryAccumulator.tokenAddress,\\n                msg.sender,\\n                address(this),\\n                entryAccumulator.amount\\n            );\\n        }\\n\\n        if (prizeAccumulator.amount != 0) {\\n            _transferTokens(msg.sender, prizeAccumulator.tokenAddress, prizeAccumulator.amount);\\n        }\\n\\n        emit DepositsRolledOver(rolloverEventData, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function claimPrizes(WithdrawalCalldata[] calldata claimPrizeCalldataArray) external nonReentrant whenNotPaused {\\n        TransferAccumulator memory transferAccumulator;\\n        uint256 claimPrizeCount = claimPrizeCalldataArray.length;\\n\\n        Withdrawal[] memory withdrawalEventData = new Withdrawal[](claimPrizeCount);\\n\\n        for (uint256 i; i < claimPrizeCount; ) {\\n            WithdrawalCalldata calldata claimPrizeCalldata = claimPrizeCalldataArray[i];\\n            uint256 caveId = claimPrizeCalldata.caveId;\\n\\n            Cave storage cave = caves[caveId];\\n            uint256 roundAmount = cave.enterAmount + _prizeAmount(cave);\\n\\n            PlayerWithdrawalCalldata[] calldata playerDetailsArray = claimPrizeCalldata.playerDetails;\\n            uint256 roundsCount = playerDetailsArray.length;\\n\\n            Withdrawal memory withdrawal = withdrawalEventData[i];\\n            withdrawal.caveId = caveId;\\n            withdrawal.roundIds = new uint256[](roundsCount);\\n\\n            for (uint256 j; j < roundsCount; ) {\\n                PlayerWithdrawalCalldata calldata playerDetails = playerDetailsArray[j];\\n                uint256 roundId = playerDetails.roundId;\\n\\n                Round storage round = rounds[caveId][roundId];\\n                if (round.status != RoundStatus.Revealed) {\\n                    revert InvalidRoundStatus();\\n                }\\n\\n                Player storage player = round.players[playerDetails.playerIndex];\\n                _validatePlayerCanWithdraw(caveId, roundId, player);\\n\\n                player.withdrawn = true;\\n\\n                withdrawal.roundIds[j] = roundId;\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            _accumulateOrTransferTokenOut(roundAmount * roundsCount, cave.enterCurrency, transferAccumulator);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (transferAccumulator.amount != 0) {\\n            _transferTokens(msg.sender, transferAccumulator.tokenAddress, transferAccumulator.amount);\\n        }\\n\\n        emit PrizesClaimed(withdrawalEventData, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function cancel(uint256 caveId) external nonReentrant {\\n        Cave storage cave = caves[caveId];\\n        uint40 roundsCount = cave.roundsCount;\\n        Round storage round = rounds[caveId][roundsCount];\\n        if (!_cancellable(round, round.status, cave.playersPerRound, round.players.length)) {\\n            revert NotCancellable();\\n        }\\n        _cancel(caveId, roundsCount);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function cancel(uint256 caveId, uint256 numberOfRounds) external nonReentrant whenPaused {\\n        _validateIsOwner();\\n\\n        Cave storage cave = caves[caveId];\\n        uint256 startingRoundId = cave.roundsCount;\\n        uint256 lastRoundId = startingRoundId + numberOfRounds - 1;\\n\\n        if (numberOfRounds == 0 || lastRoundId > cave.lastCommittedRoundId) {\\n            revert NotCancellable();\\n        }\\n\\n        for (uint256 roundId = startingRoundId; roundId <= lastRoundId; ) {\\n            rounds[caveId][roundId].status = RoundStatus.Cancelled;\\n            unchecked {\\n                ++roundId;\\n            }\\n        }\\n\\n        cave.roundsCount = uint40(lastRoundId);\\n\\n        emit RoundsCancelled(caveId, startingRoundId, numberOfRounds);\\n    }\\n\\n    function getRound(\\n        uint256 caveId,\\n        uint256 roundId\\n    )\\n        external\\n        view\\n        returns (\\n            RoundStatus status,\\n            uint40 cutoffTime,\\n            uint40 drawnAt,\\n            bytes32 commitment,\\n            bytes32 salt,\\n            uint8[32] memory playerIndices,\\n            Player[] memory players\\n        )\\n    {\\n        Round memory round = rounds[caveId][roundId];\\n        return (\\n            round.status,\\n            round.cutoffTime,\\n            round.drawnAt,\\n            round.commitment,\\n            round.salt,\\n            round.playerIndices,\\n            round.players\\n        );\\n    }\\n\\n    /**\\n     * @dev Checks if the round is cancellable. A round is cancellable if its status is Cancelled,\\n     *      its status is Open but it has passed its cutoff time, its status is Drawing but Chainlink VRF\\n     *      callback did not happen on time, or its status is Drawn but the result was not revealed.\\n     * @param caveId The ID of the cave.\\n     * @param roundId The ID of the round.\\n     */\\n    function cancellable(uint256 caveId, uint256 roundId) external view returns (bool) {\\n        Round storage round = rounds[caveId][roundId];\\n        return _cancellable(round, round.status, caves[caveId].playersPerRound, round.players.length);\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function togglePaused() external {\\n        _validateIsOwner();\\n        paused() ? _unpause() : _pause();\\n    }\\n\\n    /**\\n     * @inheritdoc IPokeTheBear\\n     */\\n    function isPlayerInRound(uint256 caveId, uint256 roundId, address player) public view returns (bool) {\\n        uint256 bucket = roundId >> 8;\\n        uint256 slot = 1 << (roundId & 0xff);\\n        return playerParticipations[player][caveId][bucket] & slot != 0;\\n    }\\n\\n    /**\\n     * @param requestId The ID of the request\\n     * @param randomWords The random words returned by Chainlink\\n     */\\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n        if (randomnessRequests[requestId].exists) {\\n            uint256 caveId = randomnessRequests[requestId].caveId;\\n            uint256 roundId = randomnessRequests[requestId].roundId;\\n\\n            Round storage round = rounds[caveId][roundId];\\n\\n            if (round.status == RoundStatus.Drawing) {\\n                round.status = RoundStatus.Drawn;\\n                randomnessRequests[requestId].randomWord = randomWords[0];\\n\\n                emit RoundStatusUpdated(caveId, roundId, RoundStatus.Drawn);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This function is used to enter rounds, charging is done outside of this function.\\n     * @param caveId The ID of the cave.\\n     * @param startingRoundId The ID of the starting round.\\n     * @param numberOfRounds The number of rounds to enter.\\n     */\\n    function _enter(uint256 caveId, uint256 startingRoundId, uint256 numberOfRounds) private {\\n        if (startingRoundId == 0 || numberOfRounds == 0) {\\n            revert InvalidRoundParameters();\\n        }\\n\\n        Cave storage cave = caves[caveId];\\n\\n        if (!cave.isActive) {\\n            revert InactiveCave();\\n        }\\n\\n        uint256 endingRoundIdPlusOne = startingRoundId + numberOfRounds;\\n\\n        if (_unsafeSubtract(endingRoundIdPlusOne, 1) > cave.lastCommittedRoundId) {\\n            revert CommitmentNotAvailable();\\n        }\\n\\n        Round storage startingRound = rounds[caveId][startingRoundId];\\n        // We just need to check the first round's status. If the first round is open,\\n        // subsequent rounds will not be drawn/cancelled as well.\\n        RoundStatus startingRoundStatus = startingRound.status;\\n        if (startingRoundStatus > RoundStatus.Open) {\\n            revert RoundCannotBeEntered(caveId, startingRoundId);\\n        }\\n\\n        uint8 playersPerRound = cave.playersPerRound;\\n\\n        if (startingRoundStatus == RoundStatus.None) {\\n            if (startingRoundId > 1) {\\n                uint256 lastRoundId = _unsafeSubtract(startingRoundId, 1);\\n                Round storage lastRound = rounds[caveId][lastRoundId];\\n                if (_cancellable(lastRound, lastRound.status, playersPerRound, lastRound.players.length)) {\\n                    _cancel(caveId, lastRoundId);\\n                    // The current round is now open (_cancel calls _open), we can manually change startingRoundStatus without touching the storage.\\n                    startingRoundStatus = RoundStatus.Open;\\n                }\\n            }\\n        }\\n\\n        for (uint256 roundId = startingRoundId; roundId < endingRoundIdPlusOne; ) {\\n            if (isPlayerInRound(caveId, roundId, msg.sender)) {\\n                revert PlayerAlreadyParticipated(caveId, roundId, msg.sender);\\n            }\\n            // Starting round already exists from outside the loop so we can reuse it for gas efficiency.\\n            Round storage round = roundId == startingRoundId ? startingRound : rounds[caveId][roundId];\\n            uint256 newNumberOfPlayers = _unsafeAdd(round.players.length, 1);\\n            // This is not be a problem for the current open round, but this\\n            // can be a problem for future rounds.\\n            if (newNumberOfPlayers > playersPerRound) {\\n                revert RoundCannotBeEntered(caveId, roundId);\\n            }\\n\\n            round.players.push(Player({addr: msg.sender, isLoser: false, withdrawn: false}));\\n            _markPlayerInRound(caveId, roundId, msg.sender);\\n\\n            // Start countdown only for the current round and only if it is the first player.\\n            if (roundId == startingRoundId) {\\n                if (startingRoundStatus == RoundStatus.Open) {\\n                    if (round.cutoffTime == 0) {\\n                        round.cutoffTime = uint40(block.timestamp) + cave.roundDuration;\\n                    }\\n\\n                    if (newNumberOfPlayers == playersPerRound) {\\n                        _draw(caveId, roundId);\\n                    }\\n                }\\n            }\\n\\n            unchecked {\\n                ++roundId;\\n            }\\n        }\\n\\n        emit RoundsEntered(caveId, startingRoundId, numberOfRounds, msg.sender);\\n    }\\n\\n    /**\\n     * @param caveId The ID of the cave.\\n     * @param roundId The ID of the round to draw.\\n     */\\n    function _draw(uint256 caveId, uint256 roundId) private {\\n        rounds[caveId][roundId].status = RoundStatus.Drawing;\\n        rounds[caveId][roundId].drawnAt = uint40(block.timestamp);\\n\\n        uint256 requestId = VRF_COORDINATOR.requestRandomWords({\\n            keyHash: KEY_HASH,\\n            subId: SUBSCRIPTION_ID,\\n            minimumRequestConfirmations: uint16(3),\\n            callbackGasLimit: uint32(500_000),\\n            numWords: uint32(1)\\n        });\\n\\n        if (randomnessRequests[requestId].exists) {\\n            revert RandomnessRequestAlreadyExists();\\n        }\\n\\n        randomnessRequests[requestId].exists = true;\\n        randomnessRequests[requestId].caveId = uint40(caveId);\\n        randomnessRequests[requestId].roundId = uint40(roundId);\\n\\n        emit RandomnessRequested(caveId, roundId, requestId);\\n        emit RoundStatusUpdated(caveId, roundId, RoundStatus.Drawing);\\n    }\\n\\n    /**\\n     * @dev This function cancels the current round and opens the next round.\\n     * @param caveId The ID of the cave.\\n     * @param roundId The ID of the round to cancel.\\n     */\\n    function _cancel(uint256 caveId, uint256 roundId) private {\\n        rounds[caveId][roundId].status = RoundStatus.Cancelled;\\n        emit RoundStatusUpdated(caveId, roundId, RoundStatus.Cancelled);\\n        _open(caveId, _unsafeAdd(roundId, 1));\\n    }\\n\\n    /**\\n     * @dev This function opens a new round.\\n     *      If the new round is already fully filled, it will be drawn immediately.\\n     *      If the round is partially filled, the countdown starts.\\n     * @param caveId The ID of the cave.\\n     * @param roundId The ID of the round to open.\\n     */\\n    function _open(uint256 caveId, uint256 roundId) private {\\n        Round storage round = rounds[caveId][roundId];\\n        uint256 playersCount = round.players.length;\\n        Cave storage cave = caves[caveId];\\n\\n        if (playersCount == cave.playersPerRound) {\\n            _draw(caveId, roundId);\\n        } else {\\n            round.status = RoundStatus.Open;\\n            cave.roundsCount = uint40(roundId);\\n            emit RoundStatusUpdated(caveId, roundId, RoundStatus.Open);\\n\\n            if (playersCount != 0) {\\n                round.cutoffTime = uint40(block.timestamp) + cave.roundDuration;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @param playerDetails Information about the player to rollover.\\n     * @param caveId The ID of the cave.\\n     * @param playersPerRound The number of required players.\\n     */\\n    function _handleRolloverRound(\\n        PlayerWithdrawalCalldata calldata playerDetails,\\n        uint256 caveId,\\n        uint8 playersPerRound\\n    ) private returns (RoundStatus roundStatus) {\\n        uint256 roundId = playerDetails.roundId;\\n        uint256 playerIndex = playerDetails.playerIndex;\\n        Round storage round = rounds[caveId][roundId];\\n        roundStatus = round.status;\\n        uint256 currentNumberOfPlayers = round.players.length;\\n\\n        if (roundStatus < RoundStatus.Revealed) {\\n            if (!_cancellable(round, roundStatus, playersPerRound, currentNumberOfPlayers)) {\\n                revert InvalidRoundStatus();\\n            }\\n            _cancel(caveId, roundId);\\n        }\\n\\n        if (playerIndex >= currentNumberOfPlayers) {\\n            revert InvalidPlayerIndex(caveId, roundId);\\n        }\\n\\n        Player storage player = round.players[playerIndex];\\n        _validatePlayerCanWithdraw(caveId, roundId, player);\\n        player.withdrawn = true;\\n    }\\n\\n    /**\\n     * @param recipient The recipient of the transfer.\\n     * @param currency The transfer currency.\\n     * @param amount The transfer amount.\\n     */\\n    function _transferTokens(address recipient, address currency, uint256 amount) private {\\n        if (currency == address(0)) {\\n            _transferETHAndWrapIfFailWithGasLimit(WRAPPED_NATIVE_TOKEN, recipient, amount, gasleft());\\n        } else {\\n            _executeERC20DirectTransfer(currency, recipient, amount);\\n        }\\n    }\\n\\n    /**\\n     * @param tokenAmount The amount of tokens to accumulate.\\n     * @param tokenAddress The token address to accumulate.\\n     * @param transferAccumulator The transfer accumulator state so far.\\n     */\\n    function _accumulateOrTransferTokenOut(\\n        uint256 tokenAmount,\\n        address tokenAddress,\\n        TransferAccumulator memory transferAccumulator\\n    ) private {\\n        if (tokenAddress == transferAccumulator.tokenAddress) {\\n            transferAccumulator.amount += tokenAmount;\\n        } else {\\n            if (transferAccumulator.amount != 0) {\\n                _transferTokens(msg.sender, transferAccumulator.tokenAddress, transferAccumulator.amount);\\n            }\\n\\n            transferAccumulator.tokenAddress = tokenAddress;\\n            transferAccumulator.amount = tokenAmount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Marks a player as participated in a round.\\n     * @dev A round starts with the ID 1 and the bitmap starts with the index 0, therefore we need to subtract 1.\\n     * @param caveId The ID of the cave.\\n     * @param roundId The ID of the round.\\n     * @param player The address of the player.\\n     */\\n    function _markPlayerInRound(uint256 caveId, uint256 roundId, address player) private {\\n        uint256 bucket = roundId >> 8;\\n        uint256 slot = 1 << (roundId & 0xff);\\n        playerParticipations[player][caveId][bucket] |= slot;\\n    }\\n\\n    /**\\n     * @notice Checks if the round data fulfills an expired open round.\\n     * @param roundStatus The status of the round.\\n     * @param cutoffTime The cutoff time of the round.\\n     * @param currentNumberOfPlayers The current number of players in the round.\\n     * @param playersPerRound The maximum number of players in a round.\\n     */\\n    function _isExpiredOpenRound(\\n        RoundStatus roundStatus,\\n        uint40 cutoffTime,\\n        uint256 currentNumberOfPlayers,\\n        uint8 playersPerRound\\n    ) private view returns (bool) {\\n        return\\n            roundStatus == RoundStatus.Open &&\\n            cutoffTime != 0 &&\\n            block.timestamp >= cutoffTime &&\\n            currentNumberOfPlayers < playersPerRound;\\n    }\\n\\n    /**\\n     * @notice Checks if the round is pending VRF or commitment reveal for too long. We tolerate a delay of up to 1 day.\\n     * @param roundStatus The status of the round.\\n     * @param round The round to check.\\n     */\\n    function _pendingVRFOrRevealForTooLong(RoundStatus roundStatus, Round storage round) private view returns (bool) {\\n        return\\n            (roundStatus == RoundStatus.Drawing || roundStatus == RoundStatus.Drawn) &&\\n            block.timestamp >= round.drawnAt + 1 days;\\n    }\\n\\n    /**\\n     * @dev player.isLoser is a check for claimPrize only, but it is also useful to act as an invariant for refund.\\n     * @param caveId The ID of the cave.\\n     * @param roundId The ID of the round.\\n     * @param player The player.\\n     */\\n    function _validatePlayerCanWithdraw(uint256 caveId, uint256 roundId, Player storage player) private view {\\n        if (player.isLoser || player.withdrawn || player.addr != msg.sender) {\\n            revert IneligibleToWithdraw(caveId, roundId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if the round is cancellable. A round is cancellable if its status is Cancelled,\\n     *      its status is Open but it has passed its cutoff time, its status is Drawing but Chainlink VRF\\n     *      callback did not happen on time, or its status is Drawn but the result was not revealed.\\n     * @param round The round to check.\\n     * @param roundStatus The status of the round.\\n     * @param playersPerRound The maximum number of players in the round.\\n     * @param currentNumberOfPlayers The current number of players in the round.\\n     */\\n    function _cancellable(\\n        Round storage round,\\n        RoundStatus roundStatus,\\n        uint8 playersPerRound,\\n        uint256 currentNumberOfPlayers\\n    ) private view returns (bool) {\\n        return\\n            _isExpiredOpenRound(roundStatus, round.cutoffTime, currentNumberOfPlayers, playersPerRound) ||\\n            _pendingVRFOrRevealForTooLong(roundStatus, round);\\n    }\\n\\n    /**\\n     * @param _protocolFeeRecipient The new protocol fee recipient address\\n     */\\n    function _updateProtocolFeeRecipient(address _protocolFeeRecipient) internal {\\n        if (_protocolFeeRecipient == address(0)) {\\n            revert InvalidValue();\\n        }\\n        protocolFeeRecipient = _protocolFeeRecipient;\\n        emit ProtocolFeeRecipientUpdated(_protocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @notice Calculates the prize amount.\\n     * @param cave The cave to calculate the prize amount.\\n     */\\n    function _prizeAmount(Cave storage cave) private view returns (uint256) {\\n        return\\n            (cave.enterAmount * (_unsafeSubtract(ONE_HUNDRED_PERCENT_IN_BASIS_POINTS, cave.protocolFeeBp))) /\\n            ONE_HUNDRED_PERCENT_IN_BASIS_POINTS /\\n            _unsafeSubtract(cave.playersPerRound, 1);\\n    }\\n\\n    /**\\n     * Unsafe math functions.\\n     */\\n\\n    function _unsafeAdd(uint256 a, uint256 b) private pure returns (uint256) {\\n        unchecked {\\n            return a + b;\\n        }\\n    }\\n\\n    function _unsafeSubtract(uint256 a, uint256 b) private pure returns (uint256) {\\n        unchecked {\\n            return a - b;\\n        }\\n    }\\n\\n    function _validateIsOwner() private view {\\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\\n            revert NotOwner();\\n        }\\n    }\\n\\n    function _validateIsOperator() private view {\\n        if (!hasRole(OPERATOR_ROLE, msg.sender)) {\\n            revert NotOperator();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IWETH} from \\\"../interfaces/generic/IWETH.sol\\\";\\n\\n/**\\n * @title LowLevelWETH\\n * @notice This contract contains a function to transfer ETH with an option to wrap to WETH.\\n *         If the ETH transfer fails within a gas limit, the amount in ETH is wrapped to WETH and then transferred.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelWETH {\\n    /**\\n     * @notice It transfers ETH to a recipient with a specified gas limit.\\n     *         If the original transfers fails, it wraps to WETH and transfers the WETH to recipient.\\n     * @param _WETH WETH address\\n     * @param _to Recipient address\\n     * @param _amount Amount to transfer\\n     * @param _gasLimit Gas limit to perform the ETH transfer\\n     */\\n    function _transferETHAndWrapIfFailWithGasLimit(\\n        address _WETH,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _gasLimit\\n    ) internal {\\n        bool status;\\n\\n        assembly {\\n            status := call(_gasLimit, _to, _amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!status) {\\n            IWETH(_WETH).deposit{value: _amount}();\\n            IWETH(_WETH).transfer(_to, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"../interfaces/generic/IERC20.sol\\\";\\n\\n// Errors\\nimport {ERC20TransferFail, ERC20TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC20Transfer\\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC20Transfer {\\n    /**\\n     * @notice Execute ERC20 transferFrom\\n     * @param currency Currency address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFromFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFromFail();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC20 (direct) transfer\\n     * @param currency Currency address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IReentrancyGuard} from \\\"./interfaces/IReentrancyGuard.sol\\\";\\n\\n/**\\n * @title PackableReentrancyGuard\\n * @notice This contract protects against reentrancy attacks.\\n *         It is adjusted from OpenZeppelin.\\n *         The only difference between this contract and ReentrancyGuard\\n *         is that _status is uint8 instead of uint256 so that it can be\\n *         packed with other contracts' storage variables.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract PackableReentrancyGuard is IReentrancyGuard {\\n    uint8 private _status;\\n\\n    /**\\n     * @notice Modifier to wrap functions to prevent reentrancy calls.\\n     */\\n    modifier nonReentrant() {\\n        if (_status == 2) {\\n            revert ReentrancyFail();\\n        }\\n\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n\\n    constructor() {\\n        _status = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title Pausable\\n * @notice This contract makes it possible to pause the contract.\\n *         It is adjusted from OpenZeppelin.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    error IsPaused();\\n    error NotPaused();\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert IsPaused();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert NotPaused();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n// Enums\\nimport {TokenType} from \\\"../enums/TokenType.sol\\\";\\n\\n/**\\n * @title ITransferManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface ITransferManager {\\n    /**\\n     * @notice This struct is only used for transferBatchItemsAcrossCollections.\\n     * @param tokenAddress Token address\\n     * @param tokenType 0 for ERC721, 1 for ERC1155\\n     * @param itemIds Array of item ids to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    struct BatchTransferItem {\\n        address tokenAddress;\\n        TokenType tokenType;\\n        uint256[] itemIds;\\n        uint256[] amounts;\\n    }\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are granted by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsGranted(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are revoked by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsRemoved(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if a new operator is added to the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorAllowed(address operator);\\n\\n    /**\\n     * @notice It is emitted if an operator is removed from the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorRemoved(address operator);\\n\\n    /**\\n     * @notice It is returned if the operator to approve has already been approved by the user.\\n     */\\n    error OperatorAlreadyApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the operator to revoke has not been previously approved by the user.\\n     */\\n    error OperatorNotApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is already allowed by the owner.\\n     * @dev This error can only be returned for owner operations.\\n     */\\n    error OperatorAlreadyAllowed();\\n\\n    /**\\n     * @notice It is returned if the operator to approve is not in the global allowlist defined by the owner.\\n     * @dev This error can be returned if the user tries to grant approval to an operator address not in the\\n     *      allowlist or if the owner tries to remove the operator from the global allowlist.\\n     */\\n    error OperatorNotAllowed();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is invalid.\\n     *         For a transfer called to be valid, the operator must be in the global allowlist and\\n     *         approved by the 'from' user.\\n     */\\n    error TransferCallerInvalid();\\n\\n    /**\\n     * @notice This function transfers ERC20 tokens.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount amount\\n     */\\n    function transferERC20(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     */\\n    function transferItemERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     */\\n    function transferItemsERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     * @param amount Amount\\n     */\\n    function transferItemERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     * @dev It does not allow batch transferring if from = msg.sender since native function should be used.\\n     */\\n    function transferItemsERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items across an array of tokens that can be ERC20, ERC721 and ERC1155.\\n     * @param items Array of BatchTransferItem\\n     * @param from Sender address\\n     * @param to Recipient address\\n     */\\n    function transferBatchItemsAcrossCollections(\\n        BatchTransferItem[] calldata items,\\n        address from,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @notice This function allows a user to grant approvals for an array of operators.\\n     *         Users cannot grant approvals if the operator is not allowed by this contract's owner.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be globally allowed to be approved.\\n     */\\n    function grantApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows a user to revoke existing approvals for an array of operators.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be approved at the user level to be revoked.\\n     */\\n    function revokeApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows an operator to be added for the shared transfer system.\\n     *         Once the operator is allowed, users can grant NFT approvals to this operator.\\n     * @param operator Operator address to allow\\n     * @dev Only callable by owner.\\n     */\\n    function allowOperator(address operator) external;\\n\\n    /**\\n     * @notice This function allows the user to remove an operator for the shared transfer system.\\n     * @param operator Operator address to remove\\n     * @dev Only callable by owner.\\n     */\\n    function removeOperator(address operator) external;\\n\\n    /**\\n     * @notice This returns whether the user has approved the operator address.\\n     * The first address is the user and the second address is the operator.\\n     */\\n    function hasUserApprovedOperator(address user, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPokeTheBear.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IPokeTheBear {\\n    /**\\n     * @notice The status of a round.\\n     *         None: The round hasn't started yet.\\n     *         Open: The round is open for players to enter.\\n     *         Drawing: The round is being drawn using Chainlink VRF.\\n     *         Drawn: The round has been drawn. Chainlink VRF has returned a random number.\\n     *         Revealed: The loser has been revealed.\\n     *         Cancelled: The round has been cancelled.\\n     */\\n    enum RoundStatus {\\n        None,\\n        Open,\\n        Drawing,\\n        Drawn,\\n        Revealed,\\n        Cancelled\\n    }\\n\\n    /**\\n     * @notice A player in a round.\\n     * @param addr The address of the player.\\n     * @param isLoser Whether the player is the loser.\\n     * @param withdrawn Whether the player has withdrawn the prize or the original deposit.\\n     */\\n    struct Player {\\n        address addr;\\n        bool isLoser;\\n        bool withdrawn;\\n    }\\n\\n    /**\\n     * @notice A round of Poke The Bear.\\n     * @param status The status of the round.\\n     * @param cutoffTime The cutoff time to start or cancel the round if there aren't enough players.\\n     * @param drawnAt The timestamp when the round was drawn.\\n     * @param commitment The commitment of the shuffled player indices.\\n     * @param salt The salt used to generate the commitment.\\n     * @param playerIndices The player indices.\\n     * @param players The players.\\n     */\\n    struct Round {\\n        RoundStatus status;\\n        uint40 cutoffTime;\\n        uint40 drawnAt;\\n        bytes32 commitment;\\n        bytes32 salt;\\n        uint8[32] playerIndices;\\n        Player[] players;\\n    }\\n\\n    /**\\n     * @param exists Whether the request exists.\\n     * @param caveId The id of the cave.\\n     * @param roundId The id of the round.\\n     * @param randomWord The random words returned by Chainlink VRF.\\n     *                   If randomWord == 0, then the request is still pending.\\n     */\\n    struct RandomnessRequest {\\n        bool exists;\\n        uint40 caveId;\\n        uint40 roundId;\\n        uint256 randomWord;\\n    }\\n\\n    /**\\n     * @notice A cave of Poke The Bear.\\n     * @param enterAmount The amount to enter the cave with.\\n     * @param enterCurrency The currency to enter the cave with.\\n     * @param roundsCount The number of rounds in the cave.\\n     * @param lastCommittedRoundId The last committed round ID.\\n     * @param roundDuration The duration of a round.\\n     * @param playersPerRound The maximum number of players in a round.\\n     * @param protocolFeeBp The protocol fee in basis points.\\n     */\\n    struct Cave {\\n        uint256 enterAmount;\\n        address enterCurrency;\\n        uint40 roundsCount;\\n        uint40 lastCommittedRoundId;\\n        uint40 roundDuration;\\n        uint8 playersPerRound;\\n        uint16 protocolFeeBp;\\n        bool isActive;\\n    }\\n\\n    /**\\n     * @notice The calldata for commitments.\\n     * @param caveId The cave ID of the commitments.\\n     * @param commitments The commitments. The pre-image of the commitment is the shuffled player indices.\\n     */\\n    struct CommitmentCalldata {\\n        uint256 caveId;\\n        bytes32[] commitments;\\n    }\\n\\n    /**\\n     * @notice The calldata for a withdrawal/claim/rollover.\\n     * @param caveId The cave ID of the withdrawal/claim/rollover.\\n     * @param playerDetails The player's details in the rounds' players array.\\n     */\\n    struct WithdrawalCalldata {\\n        uint256 caveId;\\n        PlayerWithdrawalCalldata[] playerDetails;\\n    }\\n\\n    /**\\n     * @notice The calldata for a withdrawal/claim/rollover.\\n     * @param caveId The cave ID of the withdrawal/claim/rollover.\\n     * @param startingRoundId The starting round ID to enter.\\n     * @param numberOfExtraRoundsToEnter The number of extra rounds to enter, in addition to rollover rounds.\\n     * @param playerDetails The player's details in the rounds' players array.\\n     */\\n    struct RolloverCalldata {\\n        uint256 caveId;\\n        uint256 startingRoundId;\\n        uint256 numberOfExtraRoundsToEnter;\\n        PlayerWithdrawalCalldata[] playerDetails;\\n    }\\n\\n    /**\\n     * @notice The calldata for a single player withdrawal/claim/rollover.\\n     * @param roundId The round ID of the withdrawal/claim/rollover.\\n     * @param playerIndex The player index of the withdrawal/claim/rollover.\\n     */\\n    struct PlayerWithdrawalCalldata {\\n        uint256 roundId;\\n        uint256 playerIndex;\\n    }\\n\\n    /**\\n     * @notice The withdrawal/claim/rollover.\\n     * @param caveId The cave ID of the withdrawal/claim/rollover.\\n     * @param roundIds The round IDs to withdraw/claim/rollover.\\n     */\\n    struct Withdrawal {\\n        uint256 caveId;\\n        uint256[] roundIds;\\n    }\\n\\n    /**\\n     * @notice The rollover for event emission.\\n     * @param caveId The cave ID of the rollover.\\n     * @param rolledOverRoundIds The rolled over round IDs.\\n     * @param rollingOverToRoundIdStart The starting round ID to roll into\\n     */\\n    struct Rollover {\\n        uint256 caveId;\\n        uint256[] rolledOverRoundIds;\\n        uint256 rollingOverToRoundIdStart;\\n    }\\n\\n    /**\\n     * @notice This is used to accumulate the amount of tokens to be transferred.\\n     * @param tokenAddress The address of the token.\\n     * @param amount The amount of tokens accumulated.\\n     */\\n    struct TransferAccumulator {\\n        address tokenAddress;\\n        uint256 amount;\\n    }\\n\\n    event CommitmentsSubmitted(CommitmentCalldata[] commitments);\\n    event DepositsRolledOver(Rollover[] rollovers, address player);\\n    event DepositsRefunded(Withdrawal[] deposits, address player);\\n    event PrizesClaimed(Withdrawal[] prizes, address player);\\n    event ProtocolFeeRecipientUpdated(address protocolFeeRecipient);\\n    event RoundStatusUpdated(uint256 caveId, uint256 roundId, RoundStatus status);\\n    event RoundsCancelled(uint256 caveId, uint256 startingRoundId, uint256 numberOfRounds);\\n    event RoundsEntered(uint256 caveId, uint256 startingRoundId, uint256 numberOfRounds, address player);\\n    event RandomnessRequested(uint256 caveId, uint256 roundId, uint256 requestId);\\n    event CaveAdded(\\n        uint256 caveId,\\n        uint256 enterAmount,\\n        address enterCurrency,\\n        uint40 roundDuration,\\n        uint8 playersPerRound,\\n        uint16 protocolFeeBp\\n    );\\n    event CaveRemoved(uint256 caveId);\\n\\n    error CommitmentNotAvailable();\\n    error ExceedsMaximumNumberOfPlayersPerRound();\\n    error HashedPlayerIndicesDoesNotMatchCommitment();\\n    error InactiveCave();\\n    error IndivisibleEnterAmount();\\n    error IneligibleToWithdraw(uint256 caveId, uint256 roundId);\\n    error InvalidEnterAmount();\\n    error InsufficientNumberOfPlayers();\\n    error InvalidCommitment(uint256 caveId, uint256 roundId);\\n    error InvalidPlayerDetails();\\n    error InvalidPlayerIndex(uint256 caveId, uint256 roundId);\\n    error InvalidRoundDuration();\\n    error InvalidRoundParameters();\\n    error InvalidRoundStatus();\\n    error InvalidEnterCurrency();\\n    error InvalidValue();\\n    error NotOperator();\\n    error NotOwner();\\n    error NotCancellable();\\n    error PlayerAlreadyParticipated(uint256 caveId, uint256 roundId, address player);\\n    error ProtocolFeeBasisPointsTooHigh();\\n    error RepeatingPlayerIndex();\\n    error RandomnessRequestAlreadyExists();\\n    error RoundCannotBeEntered(uint256 caveId, uint256 roundId);\\n    error RoundsIncomplete();\\n\\n    /**\\n     * @notice Add a new cave. Only callable by the contract owner.\\n     * @param enterAmount The amount to enter the cave with.\\n     * @param enterCurrency The currency to enter the cave with.\\n     * @param playersPerRound The maximum number of players in a round.\\n     * @param roundDuration The duration of a round.\\n     * @param protocolFeeBp The protocol fee in basis points. Max 25%.\\n     */\\n    function addCave(\\n        uint256 enterAmount,\\n        address enterCurrency,\\n        uint8 playersPerRound,\\n        uint40 roundDuration,\\n        uint16 protocolFeeBp\\n    ) external returns (uint256 caveId);\\n\\n    /**\\n     * @notice Remove a cave. Only callable by the contract owner.\\n     * @param caveId The cave ID to remove.\\n     */\\n    function removeCave(uint256 caveId) external;\\n\\n    /**\\n     * @dev Update the protocol fee recipient. Only callable by the contract owner.\\n     * @param _protocolFeeRecipient The address of the protocol fee recipient\\n     */\\n    function updateProtocolFeeRecipient(address _protocolFeeRecipient) external;\\n\\n    /**\\n     * @notice Enter the current round of a cave.\\n     * @param caveId The cave ID of the round to enter.\\n     * @param startingRoundId The starting round ID to enter.\\n     * @param numberOfRounds The number of rounds to enter, starting from the starting round ID.\\n     */\\n    function enter(uint256 caveId, uint256 startingRoundId, uint256 numberOfRounds) external payable;\\n\\n    /**\\n     * @notice Commit the player indices for multiple rounds.\\n     * @param commitments The array of commitments.\\n     */\\n    function commit(CommitmentCalldata[] calldata commitments) external;\\n\\n    /**\\n     * @notice Reveal the result of a round.\\n     * @param requestId The Chainlink VRF request ID.\\n     * @param playerIndices The indices of the players.\\n     * @param salt The salt used to concatenate with the playerIndices to generate the commitment.\\n     */\\n    function reveal(uint256 requestId, uint256 playerIndices, bytes32 salt) external;\\n\\n    /**\\n     * @notice Get a refund for cancelled rounds.\\n     * @param refundCalldataArray The array of refund calldata.\\n     */\\n    function refund(WithdrawalCalldata[] calldata refundCalldataArray) external;\\n\\n    /**\\n     * @notice Rollover cancelled rounds' deposits to the current round + upcoming rounds.\\n     * @param rolloverCalldataArray The array of rollover calldata.\\n     */\\n    function rollover(RolloverCalldata[] calldata rolloverCalldataArray) external payable;\\n\\n    /**\\n     * @notice Claim prizes for multiple rounds.\\n     * @param claimPrizeCalldataArray The array of claim prize calldata.\\n     */\\n    function claimPrizes(WithdrawalCalldata[] calldata claimPrizeCalldataArray) external;\\n\\n    /**\\n     * @notice Cancel the latest round when the round is expired.\\n     * @param caveId The cave ID of the round to cancel.\\n     */\\n    function cancel(uint256 caveId) external;\\n\\n    /**\\n     * @notice Allow the contract owner to cancel the current and future rounds if the contract is paused.\\n     * @param caveId The cave ID of the rounds to cancel.\\n     * @param numberOfRounds The number of rounds to cancel..\\n     */\\n    function cancel(uint256 caveId, uint256 numberOfRounds) external;\\n\\n    /**\\n     * @notice Get a round of a given cave.\\n     * @param caveId The cave ID.\\n     * @param roundId The round ID.\\n     */\\n    function getRound(\\n        uint256 caveId,\\n        uint256 roundId\\n    )\\n        external\\n        view\\n        returns (\\n            RoundStatus status,\\n            uint40 cutoffTime,\\n            uint40 drawnAt,\\n            bytes32 commitment,\\n            bytes32 salt,\\n            uint8[32] memory playerIndices,\\n            Player[] memory players\\n        );\\n\\n    /**\\n     * @notice Check if the player is in a specific round.\\n     * @param caveId The cave ID.\\n     * @param roundId The round ID.\\n     * @return The player's address.\\n     */\\n    function isPlayerInRound(uint256 caveId, uint256 roundId, address player) external view returns (bool);\\n\\n    /**\\n     * @notice This function allows the owner to pause/unpause the contract.\\n     */\\n    function togglePaused() external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the ETH transfer fails.\\n */\\nerror ETHTransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 approval fails.\\n */\\nerror ERC20ApprovalFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transfer fails.\\n */\\nerror ERC20TransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transferFrom fails.\\n */\\nerror ERC20TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC721 transferFrom fails.\\n */\\nerror ERC721TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\\n */\\nerror ERC1155SafeTransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\\n */\\nerror ERC1155SafeBatchTransferFromFail();\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the call recipient is not a contract.\\n */\\nerror NotAContract();\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/IReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IReentrancyGuard\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IReentrancyGuard {\\n    /**\\n     * @notice This is returned when there is a reentrant call.\\n     */\\n    error ReentrancyFail();\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-transfer-manager/contracts/enums/TokenType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nenum TokenType {\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@looksrare/=node_modules/@looksrare/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 888888\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedNativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transferManager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommitmentNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaximumNumberOfPlayersPerRound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HashedPlayerIndicesDoesNotMatchCommitment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InactiveCave\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndivisibleEnterAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"IneligibleToWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNumberOfPlayers\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"InvalidCommitment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEnterAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEnterCurrency\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPlayerDetails\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"InvalidPlayerIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoundDuration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoundParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoundStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCancellable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"PlayerAlreadyParticipated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolFeeBasisPointsTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RandomnessRequestAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepeatingPlayerIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"RoundCannotBeEntered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoundsIncomplete\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"enterAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"enterCurrency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"roundDuration\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"playersPerRound\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"protocolFeeBp\",\"type\":\"uint16\"}],\"name\":\"CaveAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"}],\"name\":\"CaveRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"commitments\",\"type\":\"bytes32[]\"}],\"indexed\":false,\"internalType\":\"struct IPokeTheBear.CommitmentCalldata[]\",\"name\":\"commitments\",\"type\":\"tuple[]\"}],\"name\":\"CommitmentsSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"roundIds\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct IPokeTheBear.Withdrawal[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"DepositsRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rolledOverRoundIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rollingOverToRoundIdStart\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IPokeTheBear.Rollover[]\",\"name\":\"rollovers\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"DepositsRolledOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"roundIds\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct IPokeTheBear.Withdrawal[]\",\"name\":\"prizes\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"PrizesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"ProtocolFeeRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"RandomnessRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IPokeTheBear.RoundStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"RoundStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfRounds\",\"type\":\"uint256\"}],\"name\":\"RoundsCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfRounds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"RoundsEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"enterAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"enterCurrency\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"playersPerRound\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"roundDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"protocolFeeBp\",\"type\":\"uint16\"}],\"name\":\"addCave\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfRounds\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"cancellable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"}],\"name\":\"caves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"enterAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"enterCurrency\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"roundsCount\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"lastCommittedRoundId\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"roundDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint8\",\"name\":\"playersPerRound\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"protocolFeeBp\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct IPokeTheBear.PlayerWithdrawalCalldata[]\",\"name\":\"playerDetails\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPokeTheBear.WithdrawalCalldata[]\",\"name\":\"claimPrizeCalldataArray\",\"type\":\"tuple[]\"}],\"name\":\"claimPrizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"commitments\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct IPokeTheBear.CommitmentCalldata[]\",\"name\":\"commitments\",\"type\":\"tuple[]\"}],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingRoundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfRounds\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"internalType\":\"enum IPokeTheBear.RoundStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"cutoffTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"drawnAt\",\"type\":\"uint40\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint8[32]\",\"name\":\"playerIndices\",\"type\":\"uint8[32]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLoser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"internalType\":\"struct IPokeTheBear.Player[]\",\"name\":\"players\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"isPlayerInRound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextCaveId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"randomnessRequests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"caveId\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"roundId\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"randomWord\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct IPokeTheBear.PlayerWithdrawalCalldata[]\",\"name\":\"playerDetails\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPokeTheBear.WithdrawalCalldata[]\",\"name\":\"refundCalldataArray\",\"type\":\"tuple[]\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"}],\"name\":\"removeCave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerIndices\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"caveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingRoundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfExtraRoundsToEnter\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct IPokeTheBear.PlayerWithdrawalCalldata[]\",\"name\":\"playerDetails\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPokeTheBear.RolloverCalldata[]\",\"name\":\"rolloverCalldataArray\",\"type\":\"tuple[]\"}],\"name\":\"rollover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"updateProtocolFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PokeTheBear", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "888888", "ConstructorArguments": "000000000000000000000000b5a9e5a319c7fda551a30be592c77394bf935c6f000000000000000000000000842ca39dfd984d4349ce8d8c95577e2bf42f4db0000000000000000000000000c8c57e4c73c71f72ca0a7e043e5d2d144f98ef13000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000ea4af05656c17b90f4d64add29e1d8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef000000000000000000000000271682deb8c4e0901d1a1550ad2e64d568e6990900000000000000000000000000000000000000000000000000000000000002de", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}