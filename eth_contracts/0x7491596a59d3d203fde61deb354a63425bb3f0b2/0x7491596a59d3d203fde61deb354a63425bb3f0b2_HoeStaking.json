{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ncontract HoeStaking {\r\n    IERC20 public immutable stakingToken;\r\n    IERC20 public immutable rewardsToken;\r\n\r\n    address public owner;\r\n\r\n    // Duration of rewards to be paid out (in seconds)\r\n    uint public duration;\r\n    // Timestamp of when the rewards finish\r\n    uint public finishAt;\r\n    // Minimum of last updated time and reward finish time\r\n    uint public updatedAt;\r\n    // Reward to be paid out per second\r\n    uint public rewardRate;\r\n    // Sum of (reward rate * dt * 1e18 / total supply)\r\n    uint public rewardPerTokenStored;\r\n    // User address => rewardPerTokenStored\r\n    mapping(address => uint) public userRewardPerTokenPaid;\r\n    // User address => rewards to be claimed\r\n    mapping(address => uint) public rewards;\r\n\r\n    // Total staked\r\n    uint public totalSupply;\r\n    // User address => staked amount\r\n    mapping(address => uint) public balanceOf;\r\n\r\n    constructor(address _stakingToken, address _rewardToken) {\r\n        owner = msg.sender;\r\n        stakingToken = IERC20(_stakingToken);\r\n        rewardsToken = IERC20(_rewardToken);\r\n        duration = 86400;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier updateReward(address _account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        updatedAt = lastTimeRewardApplicable();\r\n\r\n        if (_account != address(0)) {\r\n            rewards[_account] = earned(_account);\r\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint) {\r\n        return _min(finishAt, block.timestamp);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint) {\r\n        if (totalSupply == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n\r\n        return\r\n            rewardPerTokenStored +\r\n            (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\r\n            totalSupply;\r\n    }\r\n\r\n    function stake(uint _amount, address _staker) external updateReward(_staker) {\r\n        require(_amount > 0, \"amount = 0\");\r\n        require(msg.sender == address(stakingToken));\r\n        balanceOf[_staker] += _amount;\r\n        totalSupply += _amount;\r\n    }\r\n\r\n    function unstake() external updateReward(msg.sender) {\r\n        uint _amount = balanceOf[msg.sender];\r\n        require(_amount > 0, \"amount = 0\");\r\n        balanceOf[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        stakingToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    function earned(address _account) public view returns (uint) {\r\n        return\r\n            ((balanceOf[_account] *\r\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18) +\r\n            rewards[_account];\r\n    }\r\n\r\n    function claimReward() external updateReward(msg.sender) {\r\n        uint reward = rewards[msg.sender];\r\n        if (reward > 0) {\r\n            rewards[msg.sender] = 0;\r\n            rewardsToken.transfer(msg.sender, reward);\r\n        }\r\n    }\r\n\r\n    function setRewardsDuration(uint _duration) external onlyOwner {\r\n        require(finishAt < block.timestamp, \"reward duration not finished\");\r\n        duration = _duration;\r\n    }\r\n\r\n    function notifyRewardAmount(\r\n        uint _amount\r\n    ) external onlyOwner updateReward(address(0)) {\r\n        if (block.timestamp >= finishAt) {\r\n            rewardRate = _amount / duration;\r\n        } else {\r\n            uint remainingRewards = (finishAt - block.timestamp) * rewardRate;\r\n            rewardRate = (_amount + remainingRewards) / duration;\r\n        }\r\n\r\n        require(rewardRate > 0, \"reward rate = 0\");\r\n        require(\r\n            rewardRate * duration <= rewardsToken.balanceOf(address(this)),\r\n            \"reward amount > balance\"\r\n        );\r\n\r\n        finishAt = block.timestamp + duration;\r\n        updatedAt = block.timestamp;\r\n    }\r\n\r\n    function swapback() external onlyOwner {\r\n        stakingToken.transfer(owner, stakingToken.balanceOf(address(this)));\r\n        rewardsToken.transfer(owner, rewardsToken.balanceOf(address(this)));\r\n    }\r\n\r\n    function recoverETH() external onlyOwner {\r\n        owner.call{value:address(this).balance}(\"\");\r\n    }\r\n\r\n    function _min(uint x, uint y) private pure returns (uint) {\r\n        return x <= y ? x : y;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setRewardsDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HoeStaking", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000180ac832e15491bb7ad9de6447934723ce0477b000000000000000000000000076e222b07c53d28b89b0bac18602810fc22b49a8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a25c932b8bf164a233bc209f6ff0e76955ce7815428e0c7952043327c711222f"}