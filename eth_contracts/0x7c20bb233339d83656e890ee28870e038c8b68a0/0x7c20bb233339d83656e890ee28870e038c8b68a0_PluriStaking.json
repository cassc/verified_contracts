{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: pluri_stakeholder (1).sol\r\n\r\n\r\npragma solidity ^0.8.25;\r\n\r\n\r\n\r\n/**\r\n * @title IERC20PluriMethods\r\n * @notice Extends the IERC20 interface with additional functionality for Pluri tokens.\r\n **/\r\ninterface IERC20PluriMethods is IERC20 {\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function isActiveMinter(address account) external view returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function TAX() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Pluri Token Staking Contract\r\n * @dev This contract is used to stake Pluri tokens and distribute rewards to stakers and the faucet.\r\n * Features: \r\n *       - Automatic distrubution of Pluri for users and stakers.\r\n *       - Automatic self regulating quantity of Pluri minted to balance inflation.\r\n *       - Taxes from Pluri contract are divided among stakeholders, and users whom claim from the faucet.\r\n *       - Orphaned contract to prevent rule changes.\r\n *       - Stakeholder rug pull prevention, stakeholders won't be able to unstake in mass. Every 30 days, a max potential amount of unstakes are generated. 8% of the epochs stakeholders at time of calculation. Minimum of 30 days required to have the oppurtunity to unstake.\r\n *             Example, if there are 12 stakeholders, only 1 will be allowed to unstake within 30 days. Then when the 30 days is up, another staker is allowed to unstake for that 30 days. First come first serve. \r\n *       \r\n *       - Tokens that are distrubuted via mints do not contain transaction history, while tokens collected from taxes will be decoupled from their transaction histroy.   \r\n *       - Incase of an urgent exploit(s), the contract will be removed of it's mint status from the Pluri token contract and a new stakeholder and faucet contract will be deployed allowing updates. Stakeholders will be able to unstake immediatly if this occurs and mints will no longer occur protecting financial stability.\r\n *       - Anybody can earn Pluri by using the faucet, costing only the native tokens gas amount.\r\n *\r\n * How does the tokenomics work?\r\n *     Definitions:\r\n *              - Wait List    | A queue that tracks the order, staked and unstaked stakeholders\r\n *              - Epoch        | A list genreated from the wait list, tracks whom to distrubute rewards to.\r\n *              - Faucet       | A seperate contract that is always the last stakeholder in the lists. Provides the public the ability to claim Pluri (Call auto mint function)\r\n *              - Tax          | Collected tax from data transactions from Pluri contract.\r\n *              - Staking      | To lock 21,000 Pluri tokens within the staking contract for 30 days minimum, earning more Pluri in the process. \r\n *              - Unstake      | To withdrawl 21,000 Pluri from the staking contract, no longer earning stakeholder rewards.\r\n *              - Faucet Claim | The ability to use the faucet to earn Pluri. Each claim is generated in 60 second intervals.\r\n *              - Gas          | Fee required to successfully conduct a transaction or execute a contract with the chains native token.\r\n *              - Tax reward   | The stakeholders contract balance of Pluri divided by epoch list size (balance of pluri / epoch stakeholder count)\r\n *     Proccess:          \r\n *          1. 11 people and the faucet become stakeholders\r\n *          2. The 12 stakeholders are entered into the wait list\r\n *          3. An epoch is generated and copys the wait list order of stakeholders\r\n *          4. The tax reward is determined (balance of pluri in stakeholder contract / epoch stakeholder count), if tax reward cannot be given evenly, no tax reward will be given\r\n *          5. Every 60 seconds a possible faucet claim is generated\r\n *          6. A public user triggers a faucet claim, paying a small transaction fee (gas)\r\n *          7. The epoch then picks whose turn it is to receive rewards based on the order\r\n *          8. 1 Pluri is minted to the selected stakeholder and tax rewards are transferred\r\n *          9. The public user is minted (1 / epoch list size) of Pluri, and (tax reward / epoch list size) of tax reward is transferred to the public user\r\n *          (Repeat 5-8 until it's faucets turn)\r\n *          10. When a public user triggers a faucet claim, when it's the faucets turn in the epoch, no Pluri is minted to the faucet. The public user recieves minted (1 / epoch list size) of Pluri, and (tax reward / epoch list size) of tax reward transferred, with a bonus remainder value for the minted and tax\r\n *          11. After reaching the faucet's turn, the epoch ends, and the cycle starts over from step 3\r\n *\r\n *   Visual of exampele distribution:\r\n *     \r\n *          Epoch list size = 12\r\n *          Stakeholder contract balance of Tax = 0.0000014 Pluri\r\n *          Stakeholder Reward (SR) = 1 Pluri\r\n *          Claim Reward (CR) = 0.0833... Pluri  ( / epoch list size)\r\n *          Claim Reward Remainder (CRR) = 0.000000000000000004 Pluri  (1 % epoch list size)\r\n *\r\n *          Tax Reward (TR) = 0.0000001 Pluri  ( Stakeholder contract balance of Tax / epoch list size)\r\n *          Faucet Tax Reward (FTR) = 0.000000008333... Pluri (Tax Reward / epoch list size)\r\n *          Faucet Tax Reward Remainder (FTRR) = 0.000000000000000004 Pluri (FTR % epoch list size)\r\n *\r\n *          (P) - Pluri Token\r\n *          S Reward - Stakeholder base reward\r\n *          ST Reward - Stakeholder tax reward\r\n *\r\n *          U Reward - Public User base reward\r\n *          UT Reward - Public User tax reward\r\n *           \r\n *          Epoch Rewards for Stakeholders\r\n *  Stakeholders  | user1, user2, user3, user4, user5, user6, user7, user8, user9, user10, user11, faucet |\r\n *      S Reward  | SR     SR     SR     SR     SR     SR     SR     SR     SR     SR      SR      0\r\n *     ST Reward  | TR     TR     TR     TR     TR     TR     TR     TR     TR     TR      TR      0\r\n *\r\n *          Epoch Rewards for public people that claim at the faucet\r\n *  Public Claims | person1, person2, person3, person4, person5, person6, person7, person8, person9, person10, person11, person12 |\r\n *              U | CR       CR       CR       CR       CR       CR       CR       CR       CR       CR        CR        CR + CRR\r\n *             UT | FTR      FTR      FTR      FTR      FTR      FTR      FTR      FTR      FTR      FTR       FTR       FTR + FTRR\r\n **/\r\ncontract PluriStaking is Ownable{\r\n    IERC20PluriMethods private pluriToken;\r\n\r\n    event Staked(address indexed staker, uint256 amount, uint256 timestamp);\r\n    event Unstaked(address indexed unstaker, uint256 amount, uint256 timestamp);    \r\n    event RewardsDistributed(address indexed recipient, uint256 mintedReward, uint256 taxReward, uint256 timestamp, RewardType rewardType);\r\n    event FaucetAddressInitialized(address indexed newFaucetAddress, uint256 timestamp);\r\n    event EpochStarted(uint256 numberOfStakeholders, uint256 timestamp);\r\n\r\n    \r\n    address public faucetAddress;\r\n    \r\n    /// @notice Struct to store stakeholder information.\r\n    /// @dev Since Pluri is automatically distrubuted to stakers, earnings is used only for informational purposes.\r\n    struct StakeHolder {\r\n        uint256 stakedAt;\r\n        uint256 index;\r\n        uint256 earnings;\r\n    }\r\n\r\n    struct EpochStakeHolder {\r\n        address stakerAddress;\r\n        uint256 stakedAt;\r\n    }\r\n\r\n    /// @notice Struct to represent an epoch in the staking process.\r\n    struct Epoch {\r\n        EpochStakeHolder[] stakeholders;\r\n        uint256 currentIndex;\r\n        uint256 epochSize;\r\n    }\r\n\r\n    /// @notice Enum for different types of rewards.\r\n    enum RewardType { Staker, Faucet }\r\n\r\n    uint256 public constant STAKING_AMOUNT = 21000 * 10 ** 18; // assuming 18 decimals\r\n    uint256 public constant MINT_AMOUNT = 1 * 10 ** 18;\r\n    uint256 public constant LOCKIN_TIME = 30 days; \r\n    uint256 public lastAutoMintTimestamp;\r\n    uint256 public lastContainerTimestamp = 0;\r\n    uint256 public currentUnstakeLimit = 0;\r\n    uint256 public unstakeCounter = 0;\r\n    uint256 public taxAmount = 0;\r\n\r\n\r\n\r\n    \r\n    mapping(address => StakeHolder) public stakeholdersInfo;\r\n    Epoch public currentEpoch;\r\n    EpochStakeHolder[] public currentStakeholders;\r\n    bool public epochInitialized = false;\r\n\r\n    \r\n    /// @notice Constructor to initialize the PluriStaking contract.\r\n    /// @param _pluriToken Address of the Pluri token Proxy contract.\r\n    constructor(address _pluriToken){\r\n        pluriToken = IERC20PluriMethods(_pluriToken);\r\n        lastAutoMintTimestamp = block.timestamp;\r\n    }\r\n\r\n    /// @notice Internal function to set the faucet address.\r\n    /// @dev This function can only be called once and is used to initialize the faucet address. This needs to be called last after after all other inital stakers have staked.\r\n    /// @param _faucetAddress The address of the faucet.\r\n\r\n    function setFaucetAddress(address _faucetAddress) external onlyOwner returns (bool) {\r\n        require(_faucetAddress != address(0), \"Pluri Error: Faucet address cannot be 0\");\r\n        require(faucetAddress == address(0), \"Pluri Error: Faucet already initialized\");\r\n\r\n        EpochStakeHolder memory newFaucetStakeHolder = EpochStakeHolder({\r\n            stakerAddress: _faucetAddress,\r\n            stakedAt: block.timestamp\r\n        });\r\n        currentStakeholders.push(newFaucetStakeHolder);\r\n\r\n        StakeHolder memory newStakeHolderInfo = StakeHolder({\r\n            stakedAt: block.timestamp,\r\n            index: currentStakeholders.length - 1,\r\n            earnings: 0\r\n        });\r\n        stakeholdersInfo[_faucetAddress] = newStakeHolderInfo;\r\n\r\n        faucetAddress = _faucetAddress;\r\n        emit FaucetAddressInitialized(_faucetAddress, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n\r\n    function updateUnstakeLimit() private {\r\n        if (block.timestamp >= lastContainerTimestamp + 30 days) { \r\n            uint256 epochSize = currentEpoch.stakeholders.length;\r\n            uint256 newLimit = epochSize * 8 / 100; // 8% of the epoch size\r\n            currentUnstakeLimit = newLimit >= 1 ? newLimit : 1; //Mininum 1 person can unstake within 30 day period\r\n            unstakeCounter = 0; \r\n            lastContainerTimestamp = block.timestamp;\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Starts a new epoch, used when the current epoch is full (has 12 stakeholders).\r\n    /// @dev Resets the currentEpoch and prepares it for a new cycle of rewards.\r\n\r\n    function startEpoch(bool firstInitalize) private {\r\n        currentEpoch.stakeholders = currentStakeholders;\r\n        currentEpoch.currentIndex = 0;\r\n        currentEpoch.epochSize = currentStakeholders.length;\r\n        uint256 totalBalance = pluriToken.balanceOf(address(this));\r\n        if(firstInitalize == true){\r\n            // Balance is not updated with 11th stakeholder pluri on initalization.\r\n            totalBalance += STAKING_AMOUNT;\r\n        }\r\n        uint256 totalStaked = (currentStakeholders.length - 1) * STAKING_AMOUNT;\r\n        uint256 availableTax = 0;\r\n        // Inlcude pluriToken.Tax to add a buffer\r\n        if(totalBalance > (totalStaked + pluriToken.TAX())){\r\n            uint256 taxDifference = totalBalance - totalStaked - pluriToken.TAX(); // Reserve buffer\r\n            if(taxDifference >= pluriToken.TAX() * currentStakeholders.length){\r\n                availableTax = taxDifference / currentStakeholders.length;\r\n            }\r\n        } \r\n        \r\n        taxAmount = availableTax;\r\n        emit EpochStarted(currentStakeholders.length, block.timestamp);\r\n    }\r\n\r\n\r\n    /// @notice Allows a user to stake their Pluri tokens.\r\n    /// @dev Adds the staker to the currentEpoch, and if they are the 12th stakeholder, starts epoch initalization.\r\n    /// A stakeholder must stake 21,000 PLURI for 30 days to participate in the rewards system. Will be added to next epoch.\r\n    function stake() external returns (bool) {\r\n        require(stakeholdersInfo[msg.sender].stakedAt == 0, \"Pluri Error: Already staked\");\r\n        require(faucetAddress != address(0), \"Pluri Error: Faucet address not set\");\r\n        uint256 balance = pluriToken.balanceOf(msg.sender);\r\n        uint256 allowance = pluriToken.allowance(msg.sender, address(this));\r\n        \r\n        require(balance >= STAKING_AMOUNT, \"Pluri Error: Insufficient PLURI balance to stake\");\r\n        require(allowance >= STAKING_AMOUNT, \"Pluri Error: Contract not allowed to transfer enough PLURI tokens\");\r\n        stakeholdersInfo[msg.sender].stakedAt = block.timestamp;\r\n         // Add the new stakeholder\r\n\r\n        EpochStakeHolder memory newStakeholder = EpochStakeHolder({\r\n            stakerAddress: msg.sender,\r\n            stakedAt: block.timestamp\r\n        });\r\n        currentStakeholders.push(newStakeholder);\r\n\r\n        // Swap the new stakeholder with the faucet address to ensure the faucet is always last.\r\n        if (currentStakeholders.length > 1) {\r\n            uint256 faucetIndex = stakeholdersInfo[faucetAddress].index;\r\n            EpochStakeHolder memory faucet = currentStakeholders[faucetIndex];\r\n            currentStakeholders[faucetIndex] = newStakeholder;\r\n            currentStakeholders[currentStakeholders.length - 1] = faucet;\r\n            stakeholdersInfo[msg.sender].index = faucetIndex;\r\n            stakeholdersInfo[faucetAddress].index = currentStakeholders.length - 1;\r\n        }\r\n        \r\n        if (!epochInitialized && currentStakeholders.length == 12) {\r\n            startEpoch(true);\r\n            epochInitialized = true;\r\n            \r\n        }\r\n        require(pluriToken.transferFrom(msg.sender, address(this), STAKING_AMOUNT), \"Pluri Error: Transfer failed\");\r\n        emit Staked(msg.sender, STAKING_AMOUNT, block.timestamp);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /// @notice Called by the faucet to auto mint Pluri tokens and automatically distribute rewards. Self regulates based on the number of stakeholders. \r\n    /// @dev Manages the distribution of rewards to stakeholder and minter and resets the epoch as needed. Faucet does not recieve rewards.\r\n    /// @param minter The address of the entity calling through the faucet.\r\n    function autoMint(address minter) external returns (bool) {\r\n        require(msg.sender == faucetAddress, \"Pluri Error: Only faucet can execute this\");\r\n        require(epochInitialized, \"Pluri Error: Epoch not initialized\");\r\n        require(block.timestamp >= lastAutoMintTimestamp + 60, \"Pluri Error: Must wait at least 60 seconds between autoMint calls\");\r\n        lastAutoMintTimestamp = lastAutoMintTimestamp + 60;\r\n        updateUnstakeLimit();\r\n\r\n        Epoch storage epoch = currentEpoch;\r\n        EpochStakeHolder memory recipient = epoch.stakeholders[epoch.currentIndex];\r\n        \r\n        // Determines the amount of Pluri to mint for the entity that utlized the faucet. \r\n        uint256 faucetReward = MINT_AMOUNT / epoch.epochSize;\r\n        uint256 faucetTaxReward = taxAmount / epoch.epochSize;\r\n\r\n        if (recipient.stakerAddress == faucetAddress) {\r\n            // Faucet Stakeholder turn\r\n            // Bonus of all remainders collected for mints - given to the minter only for faucet turn.\r\n            uint256 extraReward = MINT_AMOUNT % epoch.epochSize;\r\n            uint256 extraFaucetTaxReward = faucetTaxReward % epoch.epochSize;\r\n            \r\n\r\n            //Clean up the epoch and start a new epoch.\r\n            delete currentEpoch;\r\n            startEpoch(false);\r\n\r\n\r\n            require(pluriToken.mint(minter, faucetReward + extraReward), \"Pluri Error: Minting failed\");\r\n            require(pluriToken.transfer(minter, faucetTaxReward + extraFaucetTaxReward), \"Pluri Error: Transfer failed\");\r\n\r\n            emit RewardsDistributed(minter, faucetReward + extraReward, taxAmount + extraFaucetTaxReward,  block.timestamp, RewardType.Faucet);\r\n        } else {\r\n            //  Stakeholder turn\r\n            epoch.currentIndex++;\r\n\r\n            // Update the stakeholder's earnings for informational purposes\r\n            if(stakeholdersInfo[recipient.stakerAddress].stakedAt == recipient.stakedAt){\r\n                stakeholdersInfo[recipient.stakerAddress].earnings += MINT_AMOUNT;\r\n                stakeholdersInfo[recipient.stakerAddress].earnings += taxAmount;\r\n            }\r\n\r\n            require(pluriToken.mint(minter, faucetReward), \"Pluri Error: Minting failed\");\r\n            require(pluriToken.transfer(minter, faucetTaxReward), \"Pluri Error: Transfer failed\");\r\n\r\n            require(pluriToken.mint(recipient.stakerAddress, MINT_AMOUNT), \"Pluri Error: Minting failed\");\r\n            require(pluriToken.transfer(recipient.stakerAddress, taxAmount), \"Pluri Error: Transfer failed\");\r\n\r\n            emit RewardsDistributed(minter, faucetReward, faucetTaxReward, block.timestamp, RewardType.Faucet);\r\n            emit RewardsDistributed(recipient.stakerAddress, MINT_AMOUNT, taxAmount, block.timestamp, RewardType.Staker);\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n    /// @notice Allows a stakeholder to unstake their tokens after the lock-in period of 30 days. Unstaking can happen at any time if the contract is no longer a minter.\r\n    /// @dev Manages the unstaking process and updates the stakeholder list for the next Epoch.\r\n    function unstake() external returns (bool) {\r\n        require(stakeholdersInfo[msg.sender].stakedAt != 0, \"Pluri Error: Not a stakeholder\");\r\n        bool isActiveMinter = pluriToken.isActiveMinter(address(this));\r\n        if(isActiveMinter) {\r\n            require(block.timestamp >= stakeholdersInfo[msg.sender].stakedAt + LOCKIN_TIME, \"Pluri Error: Cannot unstake until 30 days have passed\");\r\n            updateUnstakeLimit();\r\n            require(unstakeCounter < currentUnstakeLimit, \"Pluri Error: Unstake limit reached for the current period\");\r\n            unstakeCounter += 1;\r\n        }\r\n        uint256 stakerIndex = stakeholdersInfo[msg.sender].index;\r\n        \r\n        // Swap the last element (faucet) with the staker's address\r\n        currentStakeholders[stakerIndex] = currentStakeholders[currentStakeholders.length - 1];\r\n\r\n        // Pop the last element\r\n        currentStakeholders.pop();\r\n\r\n        // Delete the staker info\r\n        delete stakeholdersInfo[msg.sender];\r\n\r\n        // If the faucet is not the last item in the array, the if statement will trigger making the faucet last.\r\n        if (stakerIndex < currentStakeholders.length - 1) {\r\n            // Faucet is located at  currentStakeholders[stakerIndex] - swap faucet with last stakeholder now\r\n            EpochStakeHolder memory faucet = currentStakeholders[stakerIndex];\r\n            currentStakeholders[stakerIndex] = currentStakeholders[currentStakeholders.length - 1];\r\n            currentStakeholders[currentStakeholders.length - 1] = faucet;\r\n\r\n            // Update indices for faucet and the swapped address\r\n            stakeholdersInfo[faucetAddress].index = currentStakeholders.length - 1;\r\n            stakeholdersInfo[currentStakeholders[stakerIndex].stakerAddress].index = stakerIndex;\r\n        }\r\n        require(pluriToken.transfer(msg.sender, STAKING_AMOUNT), \"Pluri Error: Unstaking transfer failed\");\r\n        emit Unstaked(msg.sender, STAKING_AMOUNT, block.timestamp);\r\n        return true;\r\n\r\n    }\r\n\r\n    /// @notice Retrieves the address of a stakeholder at a given index in the current epoch.\r\n    /// @param index The index of the stakeholder in the epoch.\r\n    /// @return The address of the stakeholder at the specified index.\r\n    function getCurrentEpochStakeholderFromIndex(uint index) external view returns (EpochStakeHolder memory) {\r\n        Epoch storage epoch = currentEpoch;\r\n        return epoch.stakeholders[index];\r\n    }\r\n\r\n     /// @notice Function to get the list of all stakeholders in the current epoch.\r\n    /// @return An array of addresses representing all stakeholders in the current epoch.\r\n    function getCurrentEpochStakeholders() external view returns (EpochStakeHolder[] memory) {\r\n        return currentEpoch.stakeholders;\r\n    }\r\n\r\n    /// @notice Function to get the list of all current next set of stakeholders outside of the epoch.\r\n    /// @return An array of addresses representing all current stakeholders.\r\n    function getCurrentListOfStakeholders() external view returns (EpochStakeHolder[] memory) {\r\n        return currentStakeholders;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pluriToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfStakeholders\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"EpochStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFaucetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FaucetAddressInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taxReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum PluriStaking.RewardType\",\"name\":\"rewardType\",\"type\":\"uint8\"}],\"name\":\"RewardsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unstaker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LOCKIN_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"autoMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentStakeholders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentUnstakeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"faucetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getCurrentEpochStakeholderFromIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct PluriStaking.EpochStakeHolder\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochStakeholders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct PluriStaking.EpochStakeHolder[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentListOfStakeholders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct PluriStaking.EpochStakeHolder[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAutoMintTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastContainerTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_faucetAddress\",\"type\":\"address\"}],\"name\":\"setFaucetAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeholdersInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PluriStaking", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006337c3e9c04a0fc81e8cf689029efad88d67fe2d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8d21a3e22eca0f7a514894be3fa6e6c7c9fbe9d5e4a4bae6a10c399cdc3854bc"}