{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ninterface IERC1155 {\r\n    function balanceOf(\r\n        address account,\r\n        uint256 id\r\n    ) external view returns (uint256);\r\n\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n}\r\n\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\ninterface IERC1155Metadata {\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\ncontract NFTInformer {\r\n    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\r\n    bytes4 private constant ERC1155_INTERFACE_ID = 0xd9b67a26;\r\n\r\n    struct NFTInfo {\r\n        address addr;\r\n        bool isERC721;\r\n        bool isERC1155;\r\n        string name;\r\n        string symbol;\r\n        string uri;\r\n    }\r\n\r\n    function getNFTInfo(\r\n        address[] memory tokenAddresses\r\n    ) public view returns (NFTInfo[] memory) {\r\n        NFTInfo[] memory infos = new NFTInfo[](tokenAddresses.length);\r\n\r\n        for (uint i = 0; i < tokenAddresses.length; i++) {\r\n            NFTInfo memory info;\r\n            address tokenAddress = tokenAddresses[i];\r\n\r\n            uint256 codeSize;\r\n            assembly {\r\n                codeSize := extcodesize(tokenAddress)\r\n            }\r\n\r\n            if (codeSize > 0) {\r\n                IERC165 token = IERC165(tokenAddress);\r\n                bool supportsERC165 = false;\r\n\r\n                // Verificar si implementa ERC165\r\n                try token.supportsInterface(type(IERC165).interfaceId) returns (\r\n                    bool result\r\n                ) {\r\n                    supportsERC165 = result;\r\n                } catch {\r\n                    supportsERC165 = false;\r\n                }\r\n\r\n                if (supportsERC165) {\r\n                    // Verificar ERC721 mediante ERC165\r\n                    try token.supportsInterface(ERC721_INTERFACE_ID) returns (\r\n                        bool result\r\n                    ) {\r\n                        if (result) {\r\n                            info.isERC721 = true;\r\n                        }\r\n                    } catch {}\r\n\r\n                    // Verificar ERC1155 mediante ERC165\r\n                    try token.supportsInterface(ERC1155_INTERFACE_ID) returns (\r\n                        bool result\r\n                    ) {\r\n                        if (result) {\r\n                            info.isERC1155 = true;\r\n                        }\r\n                    } catch {}\r\n                }\r\n\r\n                // Si no implementa ERC165 o no soporta las interfaces esperadas, verificar m\u00e9todos espec\u00edficos\r\n                if (!info.isERC721) {\r\n                    try IERC721(tokenAddress).balanceOf(address(0)) returns (\r\n                        uint256\r\n                    ) {\r\n                        try IERC721(tokenAddress).ownerOf(0) returns (address) {\r\n                            info.isERC721 = true;\r\n                        } catch {}\r\n                    } catch {}\r\n                }\r\n\r\n                if (!info.isERC1155) {\r\n                    try\r\n                        IERC1155(tokenAddress).balanceOf(address(0), 0)\r\n                    returns (uint256) {\r\n                        address[] memory owners = new address[](1);\r\n                        owners[0] = address(0);\r\n                        uint256[] memory ids = new uint256[](1);\r\n                        ids[0] = 0;\r\n                        try\r\n                            IERC1155(tokenAddress).balanceOfBatch(owners, ids)\r\n                        returns (uint256[] memory) {\r\n                            info.isERC1155 = true;\r\n                        } catch {}\r\n                    } catch {}\r\n                }\r\n\r\n                // Obtener nombre y s\u00edmbolo si es ERC721\r\n                if (info.isERC721) {\r\n                    try IERC721Metadata(tokenAddress).name() returns (\r\n                        string memory name\r\n                    ) {\r\n                        info.name = name;\r\n                    } catch {}\r\n\r\n                    try IERC721Metadata(tokenAddress).symbol() returns (\r\n                        string memory symbol\r\n                    ) {\r\n                        info.symbol = symbol;\r\n                    } catch {}\r\n                }\r\n\r\n                // Obtener URI si es ERC1155\r\n                if (info.isERC1155) {\r\n                    try IERC1155Metadata(tokenAddress).uri(0) returns (\r\n                        string memory uri\r\n                    ) {\r\n                        info.uri = uri;\r\n                    } catch {}\r\n                }\r\n            }\r\n\r\n            info.addr = tokenAddress;\r\n            infos[i] = info;\r\n        }\r\n\r\n        return infos;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getNFTInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isERC721\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct NFTInformer.NFTInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NFTInformer", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://74391b058bcb91d7e9129f4da666d4de0c30408e10c2ed84ad5d4a14623e62c4"}