{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/RocketStorageInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketStorageInterface {\\n\\n    // Deploy status\\n    function getDeployedStatus() external view returns (bool);\\n\\n    // Guardian\\n    function getGuardian() external view returns(address);\\n    function setGuardian(address _newAddress) external;\\n    function confirmGuardian() external;\\n\\n    // Getters\\n    function getAddress(bytes32 _key) external view returns (address);\\n    function getUint(bytes32 _key) external view returns (uint);\\n    function getString(bytes32 _key) external view returns (string memory);\\n    function getBytes(bytes32 _key) external view returns (bytes memory);\\n    function getBool(bytes32 _key) external view returns (bool);\\n    function getInt(bytes32 _key) external view returns (int);\\n    function getBytes32(bytes32 _key) external view returns (bytes32);\\n\\n    // Setters\\n    function setAddress(bytes32 _key, address _value) external;\\n    function setUint(bytes32 _key, uint _value) external;\\n    function setString(bytes32 _key, string calldata _value) external;\\n    function setBytes(bytes32 _key, bytes calldata _value) external;\\n    function setBool(bytes32 _key, bool _value) external;\\n    function setInt(bytes32 _key, int _value) external;\\n    function setBytes32(bytes32 _key, bytes32 _value) external;\\n\\n    // Deleters\\n    function deleteAddress(bytes32 _key) external;\\n    function deleteUint(bytes32 _key) external;\\n    function deleteString(bytes32 _key) external;\\n    function deleteBytes(bytes32 _key) external;\\n    function deleteBool(bytes32 _key) external;\\n    function deleteInt(bytes32 _key) external;\\n    function deleteBytes32(bytes32 _key) external;\\n\\n    // Arithmetic\\n    function addUint(bytes32 _key, uint256 _amount) external;\\n    function subUint(bytes32 _key, uint256 _amount) external;\\n\\n    // Protected storage\\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\\n    function confirmWithdrawalAddress(address _nodeAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/types/MinipoolDeposit.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents the type of deposits required by a minipool\\n\\nenum MinipoolDeposit {\\n    None,       // Marks an invalid deposit type\\n    Full,       // The minipool requires 32 ETH from the node operator, 16 ETH of which will be refinanced from user deposits\\n    Half,       // The minipool required 16 ETH from the node operator to be matched with 16 ETH from user deposits\\n    Empty,      // The minipool requires 0 ETH from the node operator to be matched with 32 ETH from user deposits (trusted nodes only)\\n    Variable    // Indicates this minipool is of the new generation that supports a variable deposit amount\\n}\\n\"\r\n    },\r\n    \"contracts/types/MinipoolStatus.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents a minipool's status within the network\\n\\nenum MinipoolStatus {\\n    Initialised,    // The minipool has been initialised and is awaiting a deposit of user ETH\\n    Prelaunch,      // The minipool has enough ETH to begin staking and is awaiting launch by the node operator\\n    Staking,        // The minipool is currently staking\\n    Withdrawable,   // NO LONGER USED\\n    Dissolved       // The minipool has been dissolved and its user deposited ETH has been returned to the deposit pool\\n}\\n\"\r\n    },\r\n    \"contracts/contract/minipool/RocketMinipoolStorageLayout.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../interface/RocketStorageInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\n\\n// The RocketMinipool contract storage layout, shared by RocketMinipoolDelegate\\n\\n// ******************************************************\\n// Note: This contract MUST NOT BE UPDATED after launch.\\n// All deployed minipool contracts must maintain a\\n// Consistent storage layout with RocketMinipoolDelegate.\\n// ******************************************************\\n\\nabstract contract RocketMinipoolStorageLayout {\\n    // Storage state enum\\n    enum StorageState {\\n        Undefined,\\n        Uninitialised,\\n        Initialised\\n    }\\n\\n\\t// Main Rocket Pool storage contract\\n    RocketStorageInterface internal rocketStorage = RocketStorageInterface(0);\\n\\n    // Status\\n    MinipoolStatus internal status;\\n    uint256 internal statusBlock;\\n    uint256 internal statusTime;\\n    uint256 internal withdrawalBlock;\\n\\n    // Deposit type\\n    MinipoolDeposit internal depositType;\\n\\n    // Node details\\n    address internal nodeAddress;\\n    uint256 internal nodeFee;\\n    uint256 internal nodeDepositBalance;\\n    bool internal nodeDepositAssigned;          // NO LONGER IN USE\\n    uint256 internal nodeRefundBalance;\\n    uint256 internal nodeSlashBalance;\\n\\n    // User deposit details\\n    uint256 internal userDepositBalanceLegacy;\\n    uint256 internal userDepositAssignedTime;\\n\\n    // Upgrade options\\n    bool internal useLatestDelegate = false;\\n    address internal rocketMinipoolDelegate;\\n    address internal rocketMinipoolDelegatePrev;\\n\\n    // Local copy of RETH address\\n    address internal rocketTokenRETH;\\n\\n    // Local copy of penalty contract\\n    address internal rocketMinipoolPenalty;\\n\\n    // Used to prevent direct access to delegate and prevent calling initialise more than once\\n    StorageState internal storageState = StorageState.Undefined;\\n\\n    // Whether node operator has finalised the pool\\n    bool internal finalised;\\n\\n    // Trusted member scrub votes\\n    mapping(address => bool) internal memberScrubVotes;\\n    uint256 internal totalScrubVotes;\\n\\n    // Variable minipool\\n    uint256 internal preLaunchValue;\\n    uint256 internal userDepositBalance;\\n\\n    // Vacant minipool\\n    bool internal vacant;\\n    uint256 internal preMigrationBalance;\\n\\n    // User distribution\\n    bool internal userDistributed;\\n    uint256 internal userDistributeTime;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/casper/DepositInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface DepositInterface {\\n    function deposit(bytes calldata _pubkey, bytes calldata _withdrawalCredentials, bytes calldata _signature, bytes32 _depositDataRoot) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/deposit/RocketDepositPoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDepositPoolInterface {\\n    function getBalance() external view returns (uint256);\\n    function getNodeBalance() external view returns (uint256);\\n    function getUserBalance() external view returns (int256);\\n    function getExcessBalance() external view returns (uint256);\\n    function deposit() external payable;\\n    function getMaximumDepositAmount() external view returns (uint256);\\n    function nodeDeposit(uint256 _totalAmount) external payable;\\n    function nodeCreditWithdrawal(uint256 _amount) external;\\n    function recycleDissolvedDeposit() external payable;\\n    function recycleExcessCollateral() external payable;\\n    function recycleLiquidatedStake() external payable;\\n    function assignDeposits() external;\\n    function maybeAssignDeposits() external returns (bool);\\n    function withdrawExcessBalance(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/minipool/RocketMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\nimport \\\"../RocketStorageInterface.sol\\\";\\n\\ninterface RocketMinipoolInterface {\\n    function version() external view returns (uint8);\\n    function initialise(address _nodeAddress) external;\\n    function getStatus() external view returns (MinipoolStatus);\\n    function getFinalised() external view returns (bool);\\n    function getStatusBlock() external view returns (uint256);\\n    function getStatusTime() external view returns (uint256);\\n    function getScrubVoted(address _member) external view returns (bool);\\n    function getDepositType() external view returns (MinipoolDeposit);\\n    function getNodeAddress() external view returns (address);\\n    function getNodeFee() external view returns (uint256);\\n    function getNodeDepositBalance() external view returns (uint256);\\n    function getNodeRefundBalance() external view returns (uint256);\\n    function getNodeDepositAssigned() external view returns (bool);\\n    function getPreLaunchValue() external view returns (uint256);\\n    function getNodeTopUpValue() external view returns (uint256);\\n    function getVacant() external view returns (bool);\\n    function getPreMigrationBalance() external view returns (uint256);\\n    function getUserDistributed() external view returns (bool);\\n    function getUserDepositBalance() external view returns (uint256);\\n    function getUserDepositAssigned() external view returns (bool);\\n    function getUserDepositAssignedTime() external view returns (uint256);\\n    function getTotalScrubVotes() external view returns (uint256);\\n    function calculateNodeShare(uint256 _balance) external view returns (uint256);\\n    function calculateUserShare(uint256 _balance) external view returns (uint256);\\n    function preDeposit(uint256 _bondingValue, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external payable;\\n    function deposit() external payable;\\n    function userDeposit() external payable;\\n    function distributeBalance(bool _rewardsOnly) external;\\n    function beginUserDistribute() external;\\n    function userDistributeAllowed() external view returns (bool);\\n    function refund() external;\\n    function slash() external;\\n    function finalise() external;\\n    function canStake() external view returns (bool);\\n    function canPromote() external view returns (bool);\\n    function stake(bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\\n    function prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) external;\\n    function promote() external;\\n    function dissolve() external;\\n    function close() external;\\n    function voteScrub() external;\\n    function reduceBondAmount() external;\\n}\\n\"\r\n    },\r\n    \"contracts/types/MinipoolDetails.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"./MinipoolDeposit.sol\\\";\\nimport \\\"./MinipoolStatus.sol\\\";\\n\\n// A struct containing all the information on-chain about a specific minipool\\n\\nstruct MinipoolDetails {\\n    bool exists;\\n    address minipoolAddress;\\n    bytes pubkey;\\n    MinipoolStatus status;\\n    uint256 statusBlock;\\n    uint256 statusTime;\\n    bool finalised;\\n    MinipoolDeposit depositType;\\n    uint256 nodeFee;\\n    uint256 nodeDepositBalance;\\n    bool nodeDepositAssigned;\\n    uint256 userDepositBalance;\\n    bool userDepositAssigned;\\n    uint256 userDepositAssignedTime;\\n    bool useLatestDelegate;\\n    address delegate;\\n    address previousDelegate;\\n    address effectiveDelegate;\\n    uint256 penaltyCount;\\n    uint256 penaltyRate;\\n    address nodeAddress;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/minipool/RocketMinipoolManagerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolDetails.sol\\\";\\nimport \\\"./RocketMinipoolInterface.sol\\\";\\n\\ninterface RocketMinipoolManagerInterface {\\n    function getMinipoolCount() external view returns (uint256);\\n    function getStakingMinipoolCount() external view returns (uint256);\\n    function getFinalisedMinipoolCount() external view returns (uint256);\\n    function getActiveMinipoolCount() external view returns (uint256);\\n    function getMinipoolRPLSlashed(address _minipoolAddress) external view returns (bool);\\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\\n    function getPrelaunchMinipools(uint256 offset, uint256 limit) external view returns (address[] memory);\\n    function getMinipoolAt(uint256 _index) external view returns (address);\\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) external view returns (uint256);\\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\\n    function getMinipoolDestroyed(address _minipoolAddress) external view returns (bool);\\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) external;\\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) external pure returns (bytes memory);\\n    function createMinipool(address _nodeAddress, uint256 _salt) external returns (RocketMinipoolInterface);\\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) external returns (RocketMinipoolInterface);\\n    function removeVacantMinipool() external;\\n    function getVacantMinipoolCount() external view returns (uint256);\\n    function getVacantMinipoolAt(uint256 _index) external view returns (address);\\n    function destroyMinipool() external;\\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\\n    function getMinipoolDepositType(address _minipoolAddress) external view returns (MinipoolDeposit);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/minipool/RocketMinipoolQueueInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketMinipoolQueueInterface {\\n    function getTotalLength() external view returns (uint256);\\n    function getContainsLegacy() external view returns (bool);\\n    function getLengthLegacy(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getLength() external view returns (uint256);\\n    function getTotalCapacity() external view returns (uint256);\\n    function getEffectiveCapacity() external view returns (uint256);\\n    function getNextCapacityLegacy() external view returns (uint256);\\n    function getNextDepositLegacy() external view returns (MinipoolDeposit, uint256);\\n    function enqueueMinipool(address _minipool) external;\\n    function dequeueMinipoolByDepositLegacy(MinipoolDeposit _depositType) external returns (address minipoolAddress);\\n    function dequeueMinipools(uint256 _maxToDequeue) external returns (address[] memory minipoolAddress);\\n    function removeMinipool(MinipoolDeposit _depositType) external;\\n    function getMinipoolAt(uint256 _index) external view returns(address);\\n    function getMinipoolPosition(address _minipool) external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/minipool/RocketMinipoolPenaltyInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketMinipoolPenaltyInterface {\\n    // Max penalty rate\\n    function setMaxPenaltyRate(uint256 _rate) external;\\n    function getMaxPenaltyRate() external view returns (uint256);\\n\\n    // Penalty rate\\n    function setPenaltyRate(address _minipoolAddress, uint256 _rate) external;\\n    function getPenaltyRate(address _minipoolAddress) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/node/RocketNodeStakingInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNodeStakingInterface {\\n    function getTotalRPLStake() external view returns (uint256);\\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHMatched(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHProvided(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHCollateralisationRatio(address _nodeAddress) external view returns (uint256);\\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHMatchedLimit(address _nodeAddress) external view returns (uint256);\\n    function stakeRPL(uint256 _amount) external;\\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external;\\n    function setStakeRPLForAllowed(address _caller, bool _allowed) external;\\n    function withdrawRPL(uint256 _amount) external;\\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketDAOProtocolSettingsMinipoolInterface {\\n    function getLaunchBalance() external view returns (uint256);\\n    function getPreLaunchValue() external pure returns (uint256);\\n    function getDepositUserAmount(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getFullDepositUserAmount() external view returns (uint256);\\n    function getHalfDepositUserAmount() external view returns (uint256);\\n    function getVariableDepositAmount() external view returns (uint256);\\n    function getSubmitWithdrawableEnabled() external view returns (bool);\\n    function getBondReductionEnabled() external view returns (bool);\\n    function getLaunchTimeout() external view returns (uint256);\\n    function getMaximumCount() external view returns (uint256);\\n    function isWithinUserDistributeWindow(uint256 _time) external view returns (bool);\\n    function hasUserDistributeWindowPassed(uint256 _time) external view returns (bool);\\n    function getUserDistributeWindowStart() external view returns (uint256);\\n    function getUserDistributeWindowLength() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDAONodeTrustedSettingsMinipoolInterface {\\n    function getScrubPeriod() external view returns(uint256);\\n    function getPromotionScrubPeriod() external view returns(uint256);\\n    function getScrubQuorum() external view returns(uint256);\\n    function getCancelBondReductionQuorum() external view returns(uint256);\\n    function getScrubPenaltyEnabled() external view returns(bool);\\n    function isWithinBondReductionWindow(uint256 _time) external view returns (bool);\\n    function getBondReductionWindowStart() external view returns (uint256);\\n    function getBondReductionWindowLength() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDAOProtocolSettingsNodeInterface {\\n    function getRegistrationEnabled() external view returns (bool);\\n    function getSmoothingPoolRegistrationEnabled() external view returns (bool);\\n    function getDepositEnabled() external view returns (bool);\\n    function getVacantMinipoolsEnabled() external view returns (bool);\\n    function getMinimumPerMinipoolStake() external view returns (uint256);\\n    function getMaximumPerMinipoolStake() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/dao/node/RocketDAONodeTrustedInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDAONodeTrustedInterface {\\n    function getBootstrapModeDisabled() external view returns (bool);\\n    function getMemberQuorumVotesRequired() external view returns (uint256);\\n    function getMemberAt(uint256 _index) external view returns (address);\\n    function getMemberCount() external view returns (uint256);\\n    function getMemberMinRequired() external view returns (uint256);\\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\\n    function getMemberID(address _nodeAddress) external view returns (string memory);\\n    function getMemberUrl(address _nodeAddress) external view returns (string memory);\\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\\n    function getMemberRPLBondAmount(address _nodeAddress) external view returns (uint256);\\n    function getMemberIsChallenged(address _nodeAddress) external view returns (bool);\\n    function getMemberUnbondedValidatorCount(address _nodeAddress) external view returns (uint256);\\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) external;\\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) external;\\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) external;\\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) external;\\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\\n    function memberJoinRequired(string memory _id, string memory _url) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/network/RocketNetworkFeesInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNetworkFeesInterface {\\n    function getNodeDemand() external view returns (int256);\\n    function getNodeFee() external view returns (uint256);\\n    function getNodeFeeByDemand(int256 _nodeDemand) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/token/RocketTokenRETHInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface RocketTokenRETHInterface is IERC20 {\\n    function getEthValue(uint256 _rethAmount) external view returns (uint256);\\n    function getRethValue(uint256 _ethAmount) external view returns (uint256);\\n    function getExchangeRate() external view returns (uint256);\\n    function getTotalCollateral() external view returns (uint256);\\n    function getCollateralRate() external view returns (uint256);\\n    function depositExcess() external payable;\\n    function depositExcessCollateral() external;\\n    function mint(uint256 _ethAmount, address _to) external;\\n    function burn(uint256 _rethAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/node/RocketNodeDepositInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketNodeDepositInterface {\\n    function getNodeDepositCredit(address _nodeOperator) external view returns (uint256);\\n    function increaseDepositCreditBalance(address _nodeOperator, uint256 _amount) external;\\n    function deposit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\\n    function depositWithCredit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\\n    function isValidDepositAmount(uint256 _amount) external pure returns (bool);\\n    function getDepositAmounts() external pure returns (uint256[] memory);\\n    function createVacantMinipool(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, uint256 _salt, address _expectedMinipoolAddress, uint256 _currentBalance) external;\\n    function increaseEthMatched(address _nodeAddress, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/minipool/RocketMinipoolBondReducerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >0.5.0 <0.9.0;\\npragma abicoder v2;\\n\\ninterface RocketMinipoolBondReducerInterface {\\n    function beginReduceBondAmount(address _minipoolAddress, uint256 _newBondAmount) external;\\n    function getReduceBondTime(address _minipoolAddress) external view returns (uint256);\\n    function getReduceBondValue(address _minipoolAddress) external view returns (uint256);\\n    function getReduceBondCancelled(address _minipoolAddress) external view returns (bool);\\n    function canReduceBondAmount(address _minipoolAddress) external view returns (bool);\\n    function voteCancelReduction(address _minipoolAddress) external;\\n    function reduceBondAmount() external returns (uint256);\\n    function getLastBondReductionTime(address _minipoolAddress) external view returns (uint256);\\n    function getLastBondReductionPrevValue(address _minipoolAddress) external view returns (uint256);\\n    function getLastBondReductionPrevNodeFee(address _minipoolAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/contract/minipool/RocketMinipoolDelegate.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./RocketMinipoolStorageLayout.sol\\\";\\nimport \\\"../../interface/casper/DepositInterface.sol\\\";\\nimport \\\"../../interface/deposit/RocketDepositPoolInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolManagerInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolQueueInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\\\";\\nimport \\\"../../interface/node/RocketNodeStakingInterface.sol\\\";\\nimport \\\"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\\\";\\nimport \\\"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol\\\";\\nimport \\\"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\\\";\\nimport \\\"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\\\";\\nimport \\\"../../interface/network/RocketNetworkFeesInterface.sol\\\";\\nimport \\\"../../interface/token/RocketTokenRETHInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\nimport \\\"../../interface/node/RocketNodeDepositInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolBondReducerInterface.sol\\\";\\n\\n/// @notice Provides the logic for each individual minipool in the Rocket Pool network\\n/// @dev Minipools exclusively DELEGATECALL into this contract it is never called directly\\ncontract RocketMinipoolDelegate is RocketMinipoolStorageLayout, RocketMinipoolInterface {\\n\\n    // Constants\\n    uint8 public constant override version = 3;                   // Used to identify which delegate contract each minipool is using\\n    uint256 constant calcBase = 1 ether;                          // Fixed point arithmetic uses this for value for precision\\n    uint256 constant legacyPrelaunchAmount = 16 ether;            // The amount of ETH initially deposited when minipool is created (for legacy minipools)\\n\\n    // Libs\\n    using SafeMath for uint;\\n\\n    // Events\\n    event StatusUpdated(uint8 indexed status, uint256 time);\\n    event ScrubVoted(address indexed member, uint256 time);\\n    event BondReduced(uint256 previousBondAmount, uint256 newBondAmount, uint256 time);\\n    event MinipoolScrubbed(uint256 time);\\n    event MinipoolPrestaked(bytes validatorPubkey, bytes validatorSignature, bytes32 depositDataRoot, uint256 amount, bytes withdrawalCredentials, uint256 time);\\n    event MinipoolPromoted(uint256 time);\\n    event MinipoolVacancyPrepared(uint256 bondAmount, uint256 currentBalance, uint256 time);\\n    event EtherDeposited(address indexed from, uint256 amount, uint256 time);\\n    event EtherWithdrawn(address indexed to, uint256 amount, uint256 time);\\n    event EtherWithdrawalProcessed(address indexed executed, uint256 nodeAmount, uint256 userAmount, uint256 totalBalance, uint256 time);\\n\\n    // Status getters\\n    function getStatus() override external view returns (MinipoolStatus) { return status; }\\n    function getFinalised() override external view returns (bool) { return finalised; }\\n    function getStatusBlock() override external view returns (uint256) { return statusBlock; }\\n    function getStatusTime() override external view returns (uint256) { return statusTime; }\\n    function getScrubVoted(address _member) override external view returns (bool) { return memberScrubVotes[_member]; }\\n\\n    // Deposit type getter\\n    function getDepositType() override external view returns (MinipoolDeposit) { return depositType; }\\n\\n    // Node detail getters\\n    function getNodeAddress() override external view returns (address) { return nodeAddress; }\\n    function getNodeFee() override external view returns (uint256) { return nodeFee; }\\n    function getNodeDepositBalance() override external view returns (uint256) { return nodeDepositBalance; }\\n    function getNodeRefundBalance() override external view returns (uint256) { return nodeRefundBalance; }\\n    function getNodeDepositAssigned() override external view returns (bool) { return userDepositAssignedTime != 0; }\\n    function getPreLaunchValue() override external view returns (uint256) { return preLaunchValue; }\\n    function getNodeTopUpValue() override external view returns (uint256) { return nodeDepositBalance.sub(preLaunchValue); }\\n    function getVacant() override external view returns (bool) { return vacant; }\\n    function getPreMigrationBalance() override external view returns (uint256) { return preMigrationBalance; }\\n    function getUserDistributed() override external view returns (bool) { return userDistributed; }\\n\\n    // User deposit detail getters\\n    function getUserDepositBalance() override public view returns (uint256) {\\n        if (depositType == MinipoolDeposit.Variable) {\\n            return userDepositBalance;\\n        } else {\\n            return userDepositBalanceLegacy;\\n        }\\n    }\\n    function getUserDepositAssigned() override external view returns (bool) { return userDepositAssignedTime != 0; }\\n    function getUserDepositAssignedTime() override external view returns (uint256) { return userDepositAssignedTime; }\\n    function getTotalScrubVotes() override external view returns (uint256) { return totalScrubVotes; }\\n\\n    /// @dev Prevent direct calls to this contract\\n    modifier onlyInitialised() {\\n        require(storageState == StorageState.Initialised, \\\"Storage state not initialised\\\");\\n        _;\\n    }\\n\\n    /// @dev Prevent multiple calls to initialise\\n    modifier onlyUninitialised() {\\n        require(storageState == StorageState.Uninitialised, \\\"Storage state already initialised\\\");\\n        _;\\n    }\\n\\n    /// @dev Only allow access from the owning node address\\n    modifier onlyMinipoolOwner(address _nodeAddress) {\\n        require(_nodeAddress == nodeAddress, \\\"Invalid minipool owner\\\");\\n        _;\\n    }\\n\\n    /// @dev Only allow access from the owning node address or their withdrawal address\\n    modifier onlyMinipoolOwnerOrWithdrawalAddress(address _nodeAddress) {\\n        require(_nodeAddress == nodeAddress || _nodeAddress == rocketStorage.getNodeWithdrawalAddress(nodeAddress), \\\"Invalid minipool owner\\\");\\n        _;\\n    }\\n\\n    /// @dev Only allow access from the latest version of the specified Rocket Pool contract\\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\\n        require(_contractAddress == getContractAddress(_contractName), \\\"Invalid or outdated contract\\\");\\n        _;\\n    }\\n\\n    /// @dev Get the address of a Rocket Pool network contract\\n    /// @param _contractName The internal name of the contract to retrieve the address for\\n    function getContractAddress(string memory _contractName) private view returns (address) {\\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        require(contractAddress != address(0x0), \\\"Contract not found\\\");\\n        return contractAddress;\\n    }\\n\\n    /// @dev Called once on creation to initialise starting state\\n    /// @param _nodeAddress The address of the node operator who will own this minipool\\n    function initialise(address _nodeAddress) override external onlyUninitialised {\\n        // Check parameters\\n        require(_nodeAddress != address(0x0), \\\"Invalid node address\\\");\\n        // Load contracts\\n        RocketNetworkFeesInterface rocketNetworkFees = RocketNetworkFeesInterface(getContractAddress(\\\"rocketNetworkFees\\\"));\\n        // Set initial status\\n        status = MinipoolStatus.Initialised;\\n        statusBlock = block.number;\\n        statusTime = block.timestamp;\\n        // Set details\\n        depositType = MinipoolDeposit.Variable;\\n        nodeAddress = _nodeAddress;\\n        nodeFee = rocketNetworkFees.getNodeFee();\\n        // Set the rETH address\\n        rocketTokenRETH = getContractAddress(\\\"rocketTokenRETH\\\");\\n        // Set local copy of penalty contract\\n        rocketMinipoolPenalty = getContractAddress(\\\"rocketMinipoolPenalty\\\");\\n        // Intialise storage state\\n        storageState = StorageState.Initialised;\\n    }\\n\\n    /// @notice Performs the initial pre-stake on the beacon chain to set the withdrawal credentials\\n    /// @param _bondValue The amount of the stake which will be provided by the node operator\\n    /// @param _validatorPubkey The public key of the validator\\n    /// @param _validatorSignature A signature over the deposit message object\\n    /// @param _depositDataRoot The hash tree root of the deposit data object\\n    function preDeposit(uint256 _bondValue, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external payable onlyLatestContract(\\\"rocketNodeDeposit\\\", msg.sender) onlyInitialised {\\n        // Check current status & node deposit status\\n        require(status == MinipoolStatus.Initialised, \\\"The pre-deposit can only be made while initialised\\\");\\n        require(preLaunchValue == 0, \\\"Pre-deposit already performed\\\");\\n        // Update node deposit details\\n        nodeDepositBalance = _bondValue;\\n        preLaunchValue = msg.value;\\n        // Emit ether deposited event\\n        emit EtherDeposited(msg.sender, preLaunchValue, block.timestamp);\\n        // Perform the pre-stake to lock in withdrawal credentials on beacon chain\\n        preStake(_validatorPubkey, _validatorSignature, _depositDataRoot);\\n    }\\n\\n    /// @notice Performs the second deposit which provides the validator with the remaining balance to become active\\n    function deposit() override external payable onlyLatestContract(\\\"rocketDepositPool\\\", msg.sender) onlyInitialised {\\n        // Check current status & node deposit status\\n        require(status == MinipoolStatus.Initialised, \\\"The node deposit can only be assigned while initialised\\\");\\n        require(userDepositAssignedTime == 0, \\\"The user deposit has already been assigned\\\");\\n        // Set the minipool status to prelaunch (ready for node to call `stake()`)\\n        setStatus(MinipoolStatus.Prelaunch);\\n        // Update deposit details\\n        userDepositBalance = msg.value.add(preLaunchValue).sub(nodeDepositBalance);\\n        userDepositAssignedTime = block.timestamp;\\n        // Emit ether deposited event\\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    /// @notice Assign user deposited ETH to the minipool and mark it as prelaunch\\n    /// @dev No longer used in \\\"Variable\\\" type minipools (only retained for legacy minipools still in queue)\\n    function userDeposit() override external payable onlyLatestContract(\\\"rocketDepositPool\\\", msg.sender) onlyInitialised {\\n        // Check current status & user deposit status\\n        require(status >= MinipoolStatus.Initialised && status <= MinipoolStatus.Staking, \\\"The user deposit can only be assigned while initialised, in prelaunch, or staking\\\");\\n        require(userDepositAssignedTime == 0, \\\"The user deposit has already been assigned\\\");\\n        // Progress initialised minipool to prelaunch\\n        if (status == MinipoolStatus.Initialised) { setStatus(MinipoolStatus.Prelaunch); }\\n        // Update user deposit details\\n        userDepositBalance = msg.value;\\n        userDepositAssignedTime = block.timestamp;\\n        // Refinance full minipool\\n        if (depositType == MinipoolDeposit.Full) {\\n            // Update node balances\\n            nodeDepositBalance = nodeDepositBalance.sub(msg.value);\\n            nodeRefundBalance = nodeRefundBalance.add(msg.value);\\n        }\\n        // Emit ether deposited event\\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    /// @notice Refund node ETH refinanced from user deposited ETH\\n    function refund() override external onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) onlyInitialised {\\n        // Check refund balance\\n        require(nodeRefundBalance > 0, \\\"No amount of the node deposit is available for refund\\\");\\n        // If this minipool was distributed by a user, force finalisation on the node operator\\n        if (!finalised && userDistributed) {\\n            // Note: _refund is called inside _finalise\\n            _finalise();\\n        } else {\\n            // Refund node\\n            _refund();\\n        }\\n    }\\n\\n    /// @notice Called to slash node operator's RPL balance if withdrawal balance was less than user deposit\\n    function slash() external override onlyInitialised {\\n        // Check there is a slash balance\\n        require(nodeSlashBalance > 0, \\\"No balance to slash\\\");\\n        // Perform slash\\n        _slash();\\n    }\\n\\n    /// @notice Returns true when `stake()` can be called by node operator taking into consideration the scrub period\\n    function canStake() override external view onlyInitialised returns (bool) {\\n        // Check status\\n        if (status != MinipoolStatus.Prelaunch) {\\n            return false;\\n        }\\n        // Get contracts\\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\\\"rocketDAONodeTrustedSettingsMinipool\\\"));\\n        // Get scrub period\\n        uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getScrubPeriod();\\n        // Check if we have been in prelaunch status for long enough\\n        return block.timestamp > statusTime + scrubPeriod;\\n    }\\n\\n    /// @notice Returns true when `promote()` can be called by node operator taking into consideration the scrub period\\n    function canPromote() override external view onlyInitialised returns (bool) {\\n        // Check status\\n        if (status != MinipoolStatus.Prelaunch) {\\n            return false;\\n        }\\n        // Get contracts\\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\\\"rocketDAONodeTrustedSettingsMinipool\\\"));\\n        // Get scrub period\\n        uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getPromotionScrubPeriod();\\n        // Check if we have been in prelaunch status for long enough\\n        return block.timestamp > statusTime + scrubPeriod;\\n    }\\n\\n    /// @notice Progress the minipool to staking, sending its ETH deposit to the deposit contract. Only accepts calls from the minipool owner (node) while in prelaunch and once scrub period has ended\\n    /// @param _validatorSignature A signature over the deposit message object\\n    /// @param _depositDataRoot The hash tree root of the deposit data object\\n    function stake(bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external onlyMinipoolOwner(msg.sender) onlyInitialised {\\n        // Get contracts\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        {\\n            // Get scrub period\\n            RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\\\"rocketDAONodeTrustedSettingsMinipool\\\"));\\n            uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getScrubPeriod();\\n            // Check current status\\n            require(status == MinipoolStatus.Prelaunch, \\\"The minipool can only begin staking while in prelaunch\\\");\\n            require(block.timestamp > statusTime + scrubPeriod, \\\"Not enough time has passed to stake\\\");\\n            require(!vacant, \\\"Cannot stake a vacant minipool\\\");\\n        }\\n        // Progress to staking\\n        setStatus(MinipoolStatus.Staking);\\n        // Load contracts\\n        DepositInterface casperDeposit = DepositInterface(getContractAddress(\\\"casperDeposit\\\"));\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        // Get launch amount\\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\\n        uint256 depositAmount;\\n        // Legacy minipools had a prestake equal to the bond amount\\n        if (depositType == MinipoolDeposit.Variable) {\\n            depositAmount = launchAmount.sub(preLaunchValue);\\n        } else {\\n            depositAmount = launchAmount.sub(legacyPrelaunchAmount);\\n        }\\n        // Check minipool balance\\n        require(address(this).balance >= depositAmount, \\\"Insufficient balance to begin staking\\\");\\n        // Retrieve validator pubkey from storage\\n        bytes memory validatorPubkey = rocketMinipoolManager.getMinipoolPubkey(address(this));\\n        // Send staking deposit to casper\\n        casperDeposit.deposit{value : depositAmount}(validatorPubkey, rocketMinipoolManager.getMinipoolWithdrawalCredentials(address(this)), _validatorSignature, _depositDataRoot);\\n        // Increment node's number of staking minipools\\n        rocketMinipoolManager.incrementNodeStakingMinipoolCount(nodeAddress);\\n    }\\n\\n    /// @dev Sets the bond value and vacancy flag on this minipool\\n    /// @param _bondAmount The bond amount selected by the node operator\\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\\n    function prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) override external onlyLatestContract(\\\"rocketMinipoolManager\\\", msg.sender) onlyInitialised {\\n        // Check status\\n        require(status == MinipoolStatus.Initialised, \\\"Must be in initialised status\\\");\\n        // Sanity check that refund balance is zero\\n        require(nodeRefundBalance == 0, \\\"Refund balance not zero\\\");\\n        // Check balance\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\\n        require(_currentBalance >= launchAmount, \\\"Balance is too low\\\");\\n        // Store bond amount\\n        nodeDepositBalance = _bondAmount;\\n        // Calculate user amount from launch amount\\n        userDepositBalance = launchAmount.sub(nodeDepositBalance);\\n        // Flag as vacant\\n        vacant = true;\\n        preMigrationBalance = _currentBalance;\\n        // Refund the node whatever rewards they have accrued prior to becoming a RP validator\\n        nodeRefundBalance = _currentBalance.sub(launchAmount);\\n        // Set status to preLaunch\\n        setStatus(MinipoolStatus.Prelaunch);\\n        // Emit event\\n        emit MinipoolVacancyPrepared(_bondAmount, _currentBalance, block.timestamp);\\n    }\\n\\n    /// @dev Promotes this minipool to a complete minipool\\n    function promote() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\\n        // Check status\\n        require(status == MinipoolStatus.Prelaunch, \\\"The minipool can only promote while in prelaunch\\\");\\n        require(vacant, \\\"Cannot promote a non-vacant minipool\\\");\\n        // Get contracts\\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\\\"rocketDAONodeTrustedSettingsMinipool\\\"));\\n        // Clear vacant flag\\n        vacant = false;\\n        // Check scrub period\\n        uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getPromotionScrubPeriod();\\n        require(block.timestamp > statusTime + scrubPeriod, \\\"Not enough time has passed to promote\\\");\\n        // Progress to staking\\n        setStatus(MinipoolStatus.Staking);\\n        // Increment node's number of staking minipools\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        rocketMinipoolManager.incrementNodeStakingMinipoolCount(nodeAddress);\\n        // Set deposit assigned time\\n        userDepositAssignedTime = block.timestamp;\\n        // Increase node operator's deposit credit\\n        RocketNodeDepositInterface rocketNodeDepositInterface = RocketNodeDepositInterface(getContractAddress(\\\"rocketNodeDeposit\\\"));\\n        rocketNodeDepositInterface.increaseDepositCreditBalance(nodeAddress, userDepositBalance);\\n        // Remove from vacant set\\n        rocketMinipoolManager.removeVacantMinipool();\\n        // Emit event\\n        emit MinipoolPromoted(block.timestamp);\\n    }\\n\\n    /// @dev Stakes the balance of this minipool into the deposit contract to set withdrawal credentials to this contract\\n    /// @param _validatorSignature A signature over the deposit message object\\n    /// @param _depositDataRoot The hash tree root of the deposit data object\\n    function preStake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) internal {\\n        // Load contracts\\n        DepositInterface casperDeposit = DepositInterface(getContractAddress(\\\"casperDeposit\\\"));\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        // Set minipool pubkey\\n        rocketMinipoolManager.setMinipoolPubkey(_validatorPubkey);\\n        // Get withdrawal credentials\\n        bytes memory withdrawalCredentials = rocketMinipoolManager.getMinipoolWithdrawalCredentials(address(this));\\n        // Send staking deposit to casper\\n        casperDeposit.deposit{value : preLaunchValue}(_validatorPubkey, withdrawalCredentials, _validatorSignature, _depositDataRoot);\\n        // Emit event\\n        emit MinipoolPrestaked(_validatorPubkey, _validatorSignature, _depositDataRoot, preLaunchValue, withdrawalCredentials, block.timestamp);\\n    }\\n\\n    /// @notice Distributes the contract's balance.\\n    ///         If balance is greater or equal to 8 ETH, the NO can call to distribute capital and finalise the minipool.\\n    ///         If balance is greater or equal to 8 ETH, users who have called `beginUserDistribute` and waited the required\\n    ///         amount of time can call to distribute capital.\\n    ///         If balance is lower than 8 ETH, can be called by anyone and is considered a partial withdrawal and funds are\\n    ///         split as rewards.\\n    /// @param _rewardsOnly If set to true, will revert if balance is not being treated as rewards\\n    function distributeBalance(bool _rewardsOnly) override external onlyInitialised {\\n        // Get node withdrawal address\\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n        bool ownerCalling = msg.sender == nodeAddress || msg.sender == nodeWithdrawalAddress;\\n        // If dissolved, distribute everything to the owner\\n        if (status == MinipoolStatus.Dissolved) {\\n            require(ownerCalling, \\\"Only owner can distribute dissolved minipool\\\");\\n            distributeToOwner();\\n            return;\\n        }\\n        // Can only be called while in staking status\\n        require(status == MinipoolStatus.Staking, \\\"Minipool must be staking\\\");\\n        // Get withdrawal amount, we must also account for a possible node refund balance on the contract\\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\\n        if (totalBalance >= 8 ether) {\\n            // Prevent funding front runs of distribute balance\\n            require(!_rewardsOnly, \\\"Balance exceeds 8 ether\\\");\\n            // Consider this a full withdrawal\\n            _distributeBalance(totalBalance);\\n            if (ownerCalling) {\\n                // Finalise the minipool if the owner is calling\\n                _finalise();\\n            } else {\\n                // Require user wait period to pass before allowing user to distribute\\n                require(userDistributeAllowed(), \\\"Only owner can distribute right now\\\");\\n                // Mark this minipool as having been distributed by a user\\n                userDistributed = true;\\n            }\\n        } else {\\n            // Just a partial withdraw\\n            distributeSkimmedRewards();\\n            // If node operator is calling, save a tx by calling refund immediately\\n            if (ownerCalling && nodeRefundBalance > 0) {\\n                _refund();\\n            }\\n        }\\n        // Reset distribute waiting period\\n        userDistributeTime = 0;\\n    }\\n\\n    /// @dev Distribute the entire balance to the minipool owner\\n    function distributeToOwner() internal {\\n        // Get balance\\n        uint256 balance = address(this).balance;\\n        // Get node withdrawal address\\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n        // Transfer balance\\n        (bool success,) = nodeWithdrawalAddress.call{value : balance}(\\\"\\\");\\n        require(success, \\\"Node ETH balance was not successfully transferred to node operator\\\");\\n        // Emit ether withdrawn event\\n        emit EtherWithdrawn(nodeWithdrawalAddress, balance, block.timestamp);\\n    }\\n\\n    /// @notice Allows a user (other than the owner of this minipool) to signal they want to call distribute.\\n    ///         After waiting the required period, anyone may then call `distributeBalance()`.\\n    function beginUserDistribute() override external onlyInitialised {\\n        require(status == MinipoolStatus.Staking, \\\"Minipool must be staking\\\");\\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\\n        require (totalBalance >= 8 ether, \\\"Balance too low\\\");\\n        // Prevent calls resetting distribute time before window has passed\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        uint256 timeElapsed = block.timestamp.sub(userDistributeTime);\\n        require(rocketDAOProtocolSettingsMinipool.hasUserDistributeWindowPassed(timeElapsed), \\\"User distribution already pending\\\");\\n        // Store current time\\n        userDistributeTime = block.timestamp;\\n    }\\n\\n    /// @notice Returns true if enough time has passed for a user to distribute\\n    function userDistributeAllowed() override public view returns (bool) {\\n        // Get contracts\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        // Calculate if time elapsed since call to `beginUserDistribute` is within the allowed window\\n        uint256 timeElapsed = block.timestamp.sub(userDistributeTime);\\n        return(rocketDAOProtocolSettingsMinipool.isWithinUserDistributeWindow(timeElapsed));\\n    }\\n\\n    /// @notice Allows the owner of this minipool to finalise it after a user has manually distributed the balance\\n    function finalise() override external onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) onlyInitialised {\\n        require(userDistributed, \\\"Can only manually finalise after user distribution\\\");\\n        _finalise();\\n    }\\n\\n    /// @dev Perform any slashings, refunds, and unlock NO's stake\\n    function _finalise() private {\\n        // Get contracts\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        // Can only finalise the pool once\\n        require(!finalised, \\\"Minipool has already been finalised\\\");\\n        // Set finalised flag\\n        finalised = true;\\n        // If slash is required then perform it\\n        if (nodeSlashBalance > 0) {\\n            _slash();\\n        }\\n        // Refund node operator if required\\n        if (nodeRefundBalance > 0) {\\n            _refund();\\n        }\\n        // Send any left over ETH to rETH contract\\n        if (address(this).balance > 0) {\\n            // Send user amount to rETH contract\\n            payable(rocketTokenRETH).transfer(address(this).balance);\\n        }\\n        // Trigger a deposit of excess collateral from rETH contract to deposit pool\\n        RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral();\\n        // Unlock node operator's RPL\\n        rocketMinipoolManager.incrementNodeFinalisedMinipoolCount(nodeAddress);\\n        rocketMinipoolManager.decrementNodeStakingMinipoolCount(nodeAddress);\\n    }\\n\\n    /// @dev Distributes balance to user and node operator\\n    /// @param _balance The amount to distribute\\n    function _distributeBalance(uint256 _balance) private {\\n        // Deposit amounts\\n        uint256 nodeAmount = 0;\\n        uint256 userCapital = getUserDepositBalance();\\n        // Check if node operator was slashed\\n        if (_balance < userCapital) {\\n            // Only slash on first call to distribute\\n            if (withdrawalBlock == 0) {\\n                // Record shortfall for slashing\\n                nodeSlashBalance = userCapital.sub(_balance);\\n            }\\n        } else {\\n            // Calculate node's share of the balance\\n            nodeAmount = _calculateNodeShare(_balance);\\n        }\\n        // User amount is what's left over from node's share\\n        uint256 userAmount = _balance.sub(nodeAmount);\\n        // Pay node operator via refund\\n        nodeRefundBalance = nodeRefundBalance.add(nodeAmount);\\n        // Pay user amount to rETH contract\\n        if (userAmount > 0) {\\n            // Send user amount to rETH contract\\n            payable(rocketTokenRETH).transfer(userAmount);\\n        }\\n        // Save block to prevent multiple withdrawals within a few blocks\\n        withdrawalBlock = block.number;\\n        // Log it\\n        emit EtherWithdrawalProcessed(msg.sender, nodeAmount, userAmount, _balance, block.timestamp);\\n    }\\n\\n    /// @notice Given a balance, this function returns what portion of it belongs to the node taking into\\n    /// consideration the 8 ether reward threshold, the minipool's commission rate and any penalties it may have\\n    /// attracted. Another way of describing this function is that if this contract's balance was\\n    /// `_balance + nodeRefundBalance` this function would return how much of that balance would be paid to the node\\n    /// operator if a distribution occurred\\n    /// @param _balance The balance to calculate the node share of. Should exclude nodeRefundBalance\\n    function calculateNodeShare(uint256 _balance) override public view returns (uint256) {\\n        // Sub 8 ether balance is treated as rewards\\n        if (_balance < 8 ether) {\\n            return calculateNodeRewards(nodeDepositBalance, getUserDepositBalance(), _balance);\\n        } else {\\n            return _calculateNodeShare(_balance);\\n        }\\n    }\\n\\n    /// @notice Performs the same calculation as `calculateNodeShare` but on the user side\\n    /// @param _balance The balance to calculate the node share of. Should exclude nodeRefundBalance\\n    function calculateUserShare(uint256 _balance) override external view returns (uint256) {\\n        // User's share is just the balance minus node refund minus node's share\\n        return _balance.sub(calculateNodeShare(_balance));\\n    }\\n\\n    /// @dev Given a balance, this function returns what portion of it belongs to the node taking into\\n    /// consideration the minipool's commission rate and any penalties it may have attracted\\n    /// @param _balance The balance to calculate the node share of (with nodeRefundBalance already subtracted)\\n    function _calculateNodeShare(uint256 _balance) internal view returns (uint256) {\\n        uint256 userCapital = getUserDepositBalance();\\n        uint256 nodeCapital = nodeDepositBalance;\\n        uint256 nodeShare = 0;\\n        // Calculate the total capital (node + user)\\n        uint256 capital = userCapital.add(nodeCapital);\\n        if (_balance > capital) {\\n            // Total rewards to share\\n            uint256 rewards = _balance.sub(capital);\\n            nodeShare = nodeCapital.add(calculateNodeRewards(nodeCapital, userCapital, rewards));\\n        } else if (_balance > userCapital) {\\n            nodeShare = _balance.sub(userCapital);\\n        }\\n        // Check if node has an ETH penalty\\n        uint256 penaltyRate = RocketMinipoolPenaltyInterface(rocketMinipoolPenalty).getPenaltyRate(address(this));\\n        if (penaltyRate > 0) {\\n            uint256 penaltyAmount = nodeShare.mul(penaltyRate).div(calcBase);\\n            if (penaltyAmount > nodeShare) {\\n                penaltyAmount = nodeShare;\\n            }\\n            nodeShare = nodeShare.sub(penaltyAmount);\\n        }\\n        return nodeShare;\\n    }\\n\\n    /// @dev Calculates what portion of rewards should be paid to the node operator given a capital ratio\\n    /// @param _nodeCapital The node supplied portion of the capital\\n    /// @param _userCapital The user supplied portion of the capital\\n    /// @param _rewards The amount of rewards to split\\n    function calculateNodeRewards(uint256 _nodeCapital, uint256 _userCapital, uint256 _rewards) internal view returns (uint256) {\\n        // Calculate node and user portion based on proportions of capital provided\\n        uint256 nodePortion = _rewards.mul(_nodeCapital).div(_userCapital.add(_nodeCapital));\\n        uint256 userPortion = _rewards.sub(nodePortion);\\n        // Calculate final node amount as combination of node capital, node share and commission on user share\\n        return nodePortion.add(userPortion.mul(nodeFee).div(calcBase));\\n    }\\n\\n    /// @notice Dissolve the minipool, returning user deposited ETH to the deposit pool.\\n    function dissolve() override external onlyInitialised {\\n        // Check current status\\n        require(status == MinipoolStatus.Prelaunch, \\\"The minipool can only be dissolved while in prelaunch\\\");\\n        // Load contracts\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        // Check if minipool is timed out\\n        require(block.timestamp.sub(statusTime) >= rocketDAOProtocolSettingsMinipool.getLaunchTimeout(), \\\"The minipool can only be dissolved once it has timed out\\\");\\n        // Perform the dissolution\\n        _dissolve();\\n    }\\n\\n    /// @notice Withdraw node balances from the minipool and close it. Only accepts calls from the owner\\n    function close() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\\n        // Check current status\\n        require(status == MinipoolStatus.Dissolved, \\\"The minipool can only be closed while dissolved\\\");\\n        // Distribute funds to owner\\n        distributeToOwner();\\n        // Destroy minipool\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        require(rocketMinipoolManager.getMinipoolExists(address(this)), \\\"Minipool already closed\\\");\\n        rocketMinipoolManager.destroyMinipool();\\n        // Clear state\\n        nodeDepositBalance = 0;\\n        nodeRefundBalance = 0;\\n        userDepositBalance = 0;\\n        userDepositBalanceLegacy = 0;\\n        userDepositAssignedTime = 0;\\n    }\\n\\n    /// @notice Can be called by trusted nodes to scrub this minipool if its withdrawal credentials are not set correctly\\n    function voteScrub() override external onlyInitialised {\\n        // Check current status\\n        require(status == MinipoolStatus.Prelaunch, \\\"The minipool can only be scrubbed while in prelaunch\\\");\\n        // Get contracts\\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\\\"rocketDAONodeTrusted\\\"));\\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\\\"rocketDAONodeTrustedSettingsMinipool\\\"));\\n        // Must be a trusted member\\n        require(rocketDAONode.getMemberIsValid(msg.sender), \\\"Not a trusted member\\\");\\n        // Can only vote once\\n        require(!memberScrubVotes[msg.sender], \\\"Member has already voted to scrub\\\");\\n        memberScrubVotes[msg.sender] = true;\\n        // Emit event\\n        emit ScrubVoted(msg.sender, block.timestamp);\\n        // Check if required quorum has voted\\n        uint256 quorum = rocketDAONode.getMemberCount().mul(rocketDAONodeTrustedSettingsMinipool.getScrubQuorum()).div(calcBase);\\n        if (totalScrubVotes.add(1) > quorum) {\\n            // Slash RPL equal to minimum stake amount (if enabled)\\n            if (!vacant && rocketDAONodeTrustedSettingsMinipool.getScrubPenaltyEnabled()){\\n                RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\\\"rocketNodeStaking\\\"));\\n                RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\\\"rocketDAOProtocolSettingsNode\\\"));\\n                RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n                uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\\n                // Slash amount is minRplStake * userCapital\\n                // In prelaunch userDepositBalance hasn't been set so we calculate it as 32 ETH - bond amount\\n                rocketNodeStaking.slashRPL(\\n                    nodeAddress,\\n                        launchAmount.sub(nodeDepositBalance)\\n                        .mul(rocketDAOProtocolSettingsNode.getMinimumPerMinipoolStake())\\n                        .div(calcBase)\\n                );\\n            }\\n            // Dissolve this minipool, recycling ETH back to deposit pool\\n            _dissolve();\\n            // Emit event\\n            emit MinipoolScrubbed(block.timestamp);\\n        } else {\\n            // Increment total\\n            totalScrubVotes = totalScrubVotes.add(1);\\n        }\\n    }\\n\\n    /// @notice Reduces the ETH bond amount and credits the owner the difference\\n    function reduceBondAmount() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\\n        require(status == MinipoolStatus.Staking, \\\"Minipool must be staking\\\");\\n        // If balance is greater than 8 ether, it is assumed to be capital not skimmed rewards. So prevent reduction\\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\\n        require(totalBalance < 8 ether, \\\"Cannot reduce bond with balance of 8 ether or more\\\");\\n        // Distribute any skimmed rewards\\n        distributeSkimmedRewards();\\n        // Approve reduction and handle external state changes\\n        RocketMinipoolBondReducerInterface rocketBondReducer = RocketMinipoolBondReducerInterface(getContractAddress(\\\"rocketMinipoolBondReducer\\\"));\\n        uint256 previousBond = nodeDepositBalance;\\n        uint256 newBond = rocketBondReducer.reduceBondAmount();\\n        // Update user/node balances\\n        userDepositBalance = getUserDepositBalance().add(previousBond.sub(newBond));\\n        nodeDepositBalance = newBond;\\n        // Reset node fee to current network rate\\n        RocketNetworkFeesInterface rocketNetworkFees = RocketNetworkFeesInterface(getContractAddress(\\\"rocketNetworkFees\\\"));\\n        uint256 prevFee = nodeFee;\\n        uint256 newFee = rocketNetworkFees.getNodeFee();\\n        nodeFee = newFee;\\n        // Update staking minipool counts and fee numerator\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        rocketMinipoolManager.updateNodeStakingMinipoolCount(previousBond, newBond, prevFee, newFee);\\n        // Break state to prevent rollback exploit\\n        if (depositType != MinipoolDeposit.Variable) {\\n            userDepositBalanceLegacy = 2 ** 256 - 1;\\n            depositType = MinipoolDeposit.Variable;\\n        }\\n        // Emit event\\n        emit BondReduced(previousBond, newBond, block.timestamp);\\n    }\\n\\n    /// @dev Distributes the current contract balance based on capital ratio and node fee\\n    function distributeSkimmedRewards() internal {\\n        uint256 rewards = address(this).balance.sub(nodeRefundBalance);\\n        uint256 nodeShare = calculateNodeRewards(nodeDepositBalance, getUserDepositBalance(), rewards);\\n        // Pay node operator via refund mechanism\\n        nodeRefundBalance = nodeRefundBalance.add(nodeShare);\\n        // Deposit user share into rETH contract\\n        payable(rocketTokenRETH).transfer(rewards.sub(nodeShare));\\n    }\\n\\n    /// @dev Set the minipool's current status\\n    /// @param _status The new status\\n    function setStatus(MinipoolStatus _status) private {\\n        // Update status\\n        status = _status;\\n        statusBlock = block.number;\\n        statusTime = block.timestamp;\\n        // Emit status updated event\\n        emit StatusUpdated(uint8(_status), block.timestamp);\\n    }\\n\\n    /// @dev Transfer refunded ETH balance to the node operator\\n    function _refund() private {\\n        // Prevent vacant minipools from calling\\n        require(vacant == false, \\\"Vacant minipool cannot refund\\\");\\n        // Update refund balance\\n        uint256 refundAmount = nodeRefundBalance;\\n        nodeRefundBalance = 0;\\n        // Get node withdrawal address\\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n        // Transfer refund amount\\n        (bool success,) = nodeWithdrawalAddress.call{value : refundAmount}(\\\"\\\");\\n        require(success, \\\"ETH refund amount was not successfully transferred to node operator\\\");\\n        // Emit ether withdrawn event\\n        emit EtherWithdrawn(nodeWithdrawalAddress, refundAmount, block.timestamp);\\n    }\\n\\n    /// @dev Slash node operator's RPL balance based on nodeSlashBalance\\n    function _slash() private {\\n        // Get contracts\\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\\\"rocketNodeStaking\\\"));\\n        // Slash required amount and reset storage value\\n        uint256 slashAmount = nodeSlashBalance;\\n        nodeSlashBalance = 0;\\n        rocketNodeStaking.slashRPL(nodeAddress, slashAmount);\\n    }\\n\\n    /// @dev Dissolve this minipool\\n    function _dissolve() private {\\n        // Get contracts\\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\\\"rocketDepositPool\\\"));\\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\\\"rocketMinipoolQueue\\\"));\\n        // Progress to dissolved\\n        setStatus(MinipoolStatus.Dissolved);\\n        if (vacant) {\\n            // Vacant minipools waiting to be promoted need to be removed from the set maintained by the minipool manager\\n            RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n            rocketMinipoolManager.removeVacantMinipool();\\n        } else {\\n            if (depositType == MinipoolDeposit.Full) {\\n                // Handle legacy Full type minipool\\n                rocketMinipoolQueue.removeMinipool(MinipoolDeposit.Full);\\n            } else {\\n                // Transfer user balance to deposit pool\\n                uint256 userCapital = getUserDepositBalance();\\n                rocketDepositPool.recycleDissolvedDeposit{value : userCapital}();\\n                // Emit ether withdrawn event\\n                emit EtherWithdrawn(address(rocketDepositPool), userCapital, block.timestamp);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBondAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBondAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"BondReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"EtherDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawalProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"validatorPubkey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"validatorSignature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositDataRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"withdrawalCredentials\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MinipoolPrestaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MinipoolPromoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MinipoolScrubbed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MinipoolVacancyPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ScrubVoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StatusUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"beginUserDistribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"calculateNodeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"calculateUserShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canPromote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dissolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_rewardsOnly\",\"type\":\"bool\"}],\"name\":\"distributeBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositType\",\"outputs\":[{\"internalType\":\"enum MinipoolDeposit\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeDepositAssigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeRefundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeTopUpValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPreLaunchValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPreMigrationBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"getScrubVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum MinipoolStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatusBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatusTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalScrubVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDepositAssigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDepositAssignedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDistributed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVacant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"initialise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_validatorPubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_validatorSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_depositDataRoot\",\"type\":\"bytes32\"}],\"name\":\"preDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentBalance\",\"type\":\"uint256\"}],\"name\":\"prepareVacancy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"promote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reduceBondAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_validatorSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_depositDataRoot\",\"type\":\"bytes32\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userDistributeAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteScrub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RocketMinipoolDelegate", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "15000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}