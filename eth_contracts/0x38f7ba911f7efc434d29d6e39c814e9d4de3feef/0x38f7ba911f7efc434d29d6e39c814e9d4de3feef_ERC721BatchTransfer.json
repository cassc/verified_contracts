{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/utils/ERC721BatchTransfer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @title ERC721 Batch Transfer\\n *\\n * @notice Transfer ERC721 tokens in batches to a single wallet or multiple wallets. This supports ERC721M and ERC721CM contracts.\\n * @notice To use any of the methods in this contract the user has to approve this contract to control their tokens using either `setApproveForAll` or `approve` functions from the ERC721 contract.\\n */\\ncontract ERC721BatchTransfer {\\n    error InvalidArguments();\\n    error NotOwnerOfToken();\\n\\n    event BatchTransferToSingle(\\n        address indexed contractAddress,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    event BatchTransferToMultiple(\\n        address indexed contractAddress,\\n        uint256 amount\\n    );\\n\\n    /** \\n     * @notice Transfer multiple tokens to the same wallet using the ERC721.transferFrom method.\\n     * @notice If you don't know what that means, use the `safeBatchTransferToSingleWallet` method instead\\n     * @param erc721Contract the address of the nft contract\\n     * @param to the address that will receive the nfts\\n     * @param tokenIds the list of tokens that will be transferred\\n     */\\n    function batchTransferToSingleWallet(\\n        IERC721 erc721Contract,\\n        address to,\\n        uint256[] calldata tokenIds\\n    ) external {\\n        uint256 length = tokenIds.length;\\n        for (uint256 i; i < length; ) {\\n            uint256 tokenId = tokenIds[i];\\n            address owner = erc721Contract.ownerOf(tokenId);\\n            if (msg.sender != owner) {\\n                revert NotOwnerOfToken();\\n            }\\n            erc721Contract.transferFrom(owner, to, tokenId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit BatchTransferToSingle(address(erc721Contract), to, length);\\n    }\\n\\n    /**\\n     * @notice transfer multiple tokens to the same wallet using the `ERC721.safeTransferFrom` method\\n     * @param erc721Contract the address of the nft contract\\n     * @param to the address that will receive the nfts\\n     * @param tokenIds the list of tokens that will be transferred\\n     */\\n    function safeBatchTransferToSingleWallet(\\n        IERC721 erc721Contract,\\n        address to,\\n        uint256[] calldata tokenIds\\n    ) external {\\n        uint256 length = tokenIds.length;\\n        for (uint256 i; i < length; ) {\\n            uint256 tokenId = tokenIds[i];\\n            address owner = erc721Contract.ownerOf(tokenId);\\n            if (msg.sender != owner) {\\n                revert NotOwnerOfToken();\\n            }\\n            erc721Contract.safeTransferFrom(owner, to, tokenId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit BatchTransferToSingle(address(erc721Contract), to, length);\\n    }\\n\\n    /**\\n     * @notice Transfer multiple tokens to multiple wallets using the ERC721.transferFrom method\\n     * @notice If you don't know what that means, use the `safeBatchTransferToMultipleWallets` method instead\\n     * @notice The tokens in `tokenIds` will be transferred to the addresses in the same position in `tos`\\n     * @notice E.g.: if tos = [0x..1, 0x..2, 0x..3] and tokenIds = [1, 2, 3], then:\\n     *         0x..1 will receive token 1;\\n     *         0x..2 will receive token 2;\\n     *         0x..3 will receive token 3;\\n     * @param erc721Contract the address of the nft contract\\n     * @param tos the list of addresses that will receive the nfts\\n     * @param tokenIds the list of tokens that will be transferred\\n     */\\n    function batchTransferToMultipleWallets(\\n        IERC721 erc721Contract,\\n        address[] calldata tos,\\n        uint256[] calldata tokenIds\\n    ) external {\\n        uint256 length = tokenIds.length;\\n        if (tos.length != length) revert InvalidArguments();\\n\\n        for (uint256 i; i < length; ) {\\n            uint256 tokenId = tokenIds[i];\\n            address owner = erc721Contract.ownerOf(tokenId);\\n            address to = tos[i];\\n            if (msg.sender != owner) {\\n                revert NotOwnerOfToken();\\n            }\\n            erc721Contract.transferFrom(owner, to, tokenId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit BatchTransferToMultiple(address(erc721Contract), length);\\n    }\\n\\n    /**\\n     * @notice Transfer multiple tokens to multiple wallets using the ERC721.safeTransferFrom method\\n     * @notice The tokens in `tokenIds` will be transferred to the addresses in the same position in `tos`\\n     * @notice E.g.: if tos = [0x..1, 0x..2, 0x..3] and tokenIds = [1, 2, 3], then:\\n     *         0x..1 will receive token 1;\\n     *         0x..2 will receive token 2;\\n     *         0x..3 will receive token 3;\\n     * @param erc721Contract the address of the nft contract\\n     * @param tos the list of addresses that will receive the nfts\\n     * @param tokenIds the list of tokens that will be transferred\\n     */\\n    function safeBatchTransferToMultipleWallets(\\n        IERC721 erc721Contract,\\n        address[] calldata tos,\\n        uint256[] calldata tokenIds\\n    ) external {\\n        uint256 length = tokenIds.length;\\n        if (tos.length != length) revert InvalidArguments();\\n\\n        for (uint256 i; i < length; ) {\\n            uint256 tokenId = tokenIds[i];\\n            address owner = erc721Contract.ownerOf(tokenId);\\n            address to = tos[i];\\n            if (msg.sender != owner) {\\n                revert NotOwnerOfToken();\\n            }\\n            erc721Contract.safeTransferFrom(owner, to, tokenId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit BatchTransferToMultiple(address(erc721Contract), length);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwnerOfToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BatchTransferToMultiple\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BatchTransferToSingle\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"erc721Contract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferToMultipleWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"erc721Contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferToSingleWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"erc721Contract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferToMultipleWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"erc721Contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferToSingleWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC721BatchTransfer", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}