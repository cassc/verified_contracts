{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.6;\r\n\r\n// solhint-disable\r\n\r\n/**\r\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\r\n * supported.\r\n */\r\nfunction _require(bool condition, uint256 errorCode) pure {\r\n    if (!condition) _revert(errorCode);\r\n}\r\n\r\n/**\r\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\r\n */\r\nfunction _revert(uint256 errorCode) pure {\r\n    // We're going to dynamically create a revert string based on the error code, with the following format:\r\n    // 'BAL#{errorCode}'\r\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\r\n    //\r\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\r\n    // number (8 to 16 bits) than the individual string characters.\r\n    //\r\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\r\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\r\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\r\n    assembly {\r\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\r\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\r\n        // the '0' character.\r\n\r\n        let units := add(mod(errorCode, 10), 0x30)\r\n\r\n        errorCode := div(errorCode, 10)\r\n        let tenths := add(mod(errorCode, 10), 0x30)\r\n\r\n        errorCode := div(errorCode, 10)\r\n        let hundreds := add(mod(errorCode, 10), 0x30)\r\n\r\n        // With the individual characters, we can now construct the full string. The \"BAL#\" part is a known constant\r\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\r\n        // characters to it, each shifted by a multiple of 8.\r\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\r\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\r\n        // array).\r\n\r\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\r\n\r\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\r\n        // message will have the following layout:\r\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\r\n\r\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\r\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\r\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\r\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n        // The string length is fixed: 7 characters.\r\n        mstore(0x24, 7)\r\n        // Finally, the string itself is stored.\r\n        mstore(0x44, revertReason)\r\n\r\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\r\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\r\n        revert(0, 100)\r\n    }\r\n}\r\n\r\nlibrary Errors {\r\n    // Math\r\n    uint256 internal constant ADD_OVERFLOW = 0;\r\n    uint256 internal constant SUB_OVERFLOW = 1;\r\n    uint256 internal constant SUB_UNDERFLOW = 2;\r\n    uint256 internal constant MUL_OVERFLOW = 3;\r\n    uint256 internal constant ZERO_DIVISION = 4;\r\n    uint256 internal constant DIV_INTERNAL = 5;\r\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\r\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\r\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\r\n    uint256 internal constant INVALID_EXPONENT = 9;\r\n\r\n    // Input\r\n    uint256 internal constant OUT_OF_BOUNDS = 100;\r\n    uint256 internal constant UNSORTED_ARRAY = 101;\r\n    uint256 internal constant UNSORTED_TOKENS = 102;\r\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\r\n    uint256 internal constant ZERO_TOKEN = 104;\r\n\r\n    // Shared pools\r\n    uint256 internal constant MIN_TOKENS = 200;\r\n    uint256 internal constant MAX_TOKENS = 201;\r\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\r\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\r\n    uint256 internal constant MINIMUM_BPT = 204;\r\n    uint256 internal constant CALLER_NOT_VAULT = 205;\r\n    uint256 internal constant UNINITIALIZED = 206;\r\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\r\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\r\n    uint256 internal constant EXPIRED_PERMIT = 209;\r\n    uint256 internal constant NOT_TWO_TOKENS = 210;\r\n\r\n    // Pools\r\n    uint256 internal constant MIN_AMP = 300;\r\n    uint256 internal constant MAX_AMP = 301;\r\n    uint256 internal constant MIN_WEIGHT = 302;\r\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\r\n    uint256 internal constant MAX_IN_RATIO = 304;\r\n    uint256 internal constant MAX_OUT_RATIO = 305;\r\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\r\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\r\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\r\n    uint256 internal constant INVALID_TOKEN = 309;\r\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\r\n    uint256 internal constant ZERO_INVARIANT = 311;\r\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\r\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\r\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\r\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\r\n    uint256 internal constant ORACLE_BAD_SECS = 316;\r\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\r\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\r\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\r\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\r\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\r\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\r\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\r\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\r\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\r\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\r\n    uint256 internal constant SWAPS_DISABLED = 327;\r\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\r\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\r\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\r\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\r\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\r\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\r\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\r\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\r\n\r\n    // Lib\r\n    uint256 internal constant REENTRANCY = 400;\r\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\r\n    uint256 internal constant PAUSED = 402;\r\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\r\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\r\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\r\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\r\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\r\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\r\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\r\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\r\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\r\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\r\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\r\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\r\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\r\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\r\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\r\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\r\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\r\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\r\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\r\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\r\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\r\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\r\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\r\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\r\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\r\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\r\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\r\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\r\n\r\n    // Vault\r\n    uint256 internal constant INVALID_POOL_ID = 500;\r\n    uint256 internal constant CALLER_NOT_POOL = 501;\r\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\r\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\r\n    uint256 internal constant INVALID_SIGNATURE = 504;\r\n    uint256 internal constant EXIT_BELOW_MIN = 505;\r\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\r\n    uint256 internal constant SWAP_LIMIT = 507;\r\n    uint256 internal constant SWAP_DEADLINE = 508;\r\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\r\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\r\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\r\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\r\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\r\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\r\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\r\n    uint256 internal constant INSUFFICIENT_ETH = 516;\r\n    uint256 internal constant UNALLOCATED_ETH = 517;\r\n    uint256 internal constant ETH_TRANSFER = 518;\r\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\r\n    uint256 internal constant TOKENS_MISMATCH = 520;\r\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\r\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\r\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\r\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\r\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\r\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\r\n    uint256 internal constant POOL_NO_TOKENS = 527;\r\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\r\n\r\n    // Fees\r\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\r\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\r\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\r\n * Adapted from OpenZeppelin's SafeMath library\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        _require(c >= a, Errors.ADD_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b <= a, Errors.SUB_OVERFLOW);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers of 256 bits.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers of 256 bits.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        bool roundUp\r\n    ) internal pure returns (uint256) {\r\n        return roundUp ? divUp(a, b) : divDown(a, b);\r\n    }\r\n\r\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b != 0, Errors.ZERO_DIVISION);\r\n        return a / b;\r\n    }\r\n\r\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b != 0, Errors.ZERO_DIVISION);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            return 1 + (a - 1) / b;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        _require(address(this).balance >= amount, Errors.ADDRESS_INSUFFICIENT_BALANCE);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        _require(success, Errors.ADDRESS_CANNOT_SEND_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        _require(isContract(target), Errors.CALL_TO_NON_CONTRACT);\r\n\r\n        (bool success, bytes memory returndata) = target.call(data);\r\n        return verifyCallResult(success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                _revert(Errors.LOW_LEVEL_CALL_FAILED);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _require(owner() == msg.sender, Errors.CALLER_IS_NOT_OWNER);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        _require(newOwner != address(0), Errors.NEW_OWNER_IS_ZERO);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _enterNonReentrant();\r\n        _;\r\n        _exitNonReentrant();\r\n    }\r\n\r\n    function _enterNonReentrant() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        _require(_status != _ENTERED, Errors.REENTRANCY);\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _exitNonReentrant() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     *\r\n     * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\r\n     */\r\n    function _callOptionalReturn(address token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n        (bool success, bytes memory returndata) = token.call(data);\r\n\r\n        // If the low-level call didn't succeed we return whatever was returned from it.\r\n        assembly {\r\n            if eq(success, 0) {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n        }\r\n\r\n        // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\r\n        _require(returndata.length == 0 || abi.decode(returndata, (bool)), Errors.SAFE_ERC20_CALL_FAILED);\r\n    }\r\n}\r\n\r\n/**\r\n * staking contract for ERC20 tokens or ETH\r\n */\r\ncontract Distribute is Ownable, ReentrancyGuard {\r\n    using Math for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /**\r\n     @dev This value is used so when reward token distribution is computed\r\n     the difference in precision between staking and reward token doesnt interfere\r\n     with bond increase computation\r\n     This will be computed based on the difference between decimals\r\n     of the staking token and the reward token\r\n     If both tokens have the same amount of decimals then this value is 1\r\n     If reward token has less decimals then amounts will be multiplied by this value\r\n     to match the staking token precision\r\n     If staking token has less decimals then this value will also be 1\r\n    */\r\n    uint256 public DECIMALS_ADJUSTMENT;\r\n\r\n    uint256 public constant INITIAL_BOND_VALUE = 1_000_000;\r\n\r\n    uint256 public bond_value = INITIAL_BOND_VALUE;\r\n    //just for info\r\n    uint256 public staker_count;\r\n\r\n    uint256 private _total_staked;\r\n    uint256 private _temp_pool;\r\n    // the amount of dust left to distribute after the bond value has been updated\r\n    uint256 public to_distribute;\r\n    mapping(address => uint256) private _bond_value_addr;\r\n    mapping(address => uint256) private _stakes;\r\n    mapping(address => uint256) private pending_rewards;\r\n    uint256 immutable staking_decimals;\r\n\r\n    /// @dev token to distribute\r\n    IERC20 immutable public reward_token;\r\n\r\n    /**\r\n        @dev Initialize the contract\r\n        @param _staking_decimals Number of decimals of the staking token\r\n        @param _reward_decimals Number of decimals of the reward token\r\n        @param _reward_token The token used for rewards. Set to 0 for ETH\r\n    */\r\n    constructor(uint256 _staking_decimals, uint256 _reward_decimals, IERC20 _reward_token) {\r\n        require(address(_reward_token) != address(0), \"Distribute: Invalid reward token\");\r\n        reward_token = _reward_token;\r\n        // sanitize reward token decimals\r\n        (bool success, uint256 checked_decimals) = tryGetDecimals(address(_reward_token));\r\n        if(success) {\r\n            require(checked_decimals == _reward_decimals, \"Distribute: Invalid reward decimals\");\r\n        }\r\n        staking_decimals = _staking_decimals;\r\n        if(_staking_decimals > _reward_decimals) {\r\n            DECIMALS_ADJUSTMENT = 10**(_staking_decimals - _reward_decimals);\r\n        } else {\r\n            DECIMALS_ADJUSTMENT = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to call the `decimals()` function on an ERC-20 token contract.\r\n     * @param tokenAddress The address of the ERC-20 token contract.\r\n     * @return success Indicates if the call was successful.\r\n     * @return decimals The number of decimals the token uses, or 0 if the call failed.\r\n     */\r\n    function tryGetDecimals(address tokenAddress) public view returns (bool success, uint8 decimals) {\r\n        bytes memory payload = abi.encodeWithSignature(\"decimals()\");\r\n        // Low-level call to the token contract\r\n        bytes memory returnData;\r\n        (success, returnData) = tokenAddress.staticcall(payload);\r\n        \r\n        // If call was successful and returned data is the expected length for uint8\r\n        if (success && returnData.length == 32) {\r\n            // Decode the return data\r\n            decimals = abi.decode(returnData, (uint8));\r\n        } else {\r\n            // Default to 0 decimals if call failed or returned unexpected data\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev Stakes a certain amount, this MUST transfer the given amount from the caller\r\n        @param account Address who will own the stake afterwards\r\n        @param amount Amount to stake\r\n    */\r\n    function stakeFor(address account, uint256 amount) public onlyOwner nonReentrant {\r\n        require(account != address(0), \"Distribute: Invalid account\");\r\n        require(amount > 0, \"Distribute: Amount must be greater than zero\");\r\n        _total_staked = _total_staked.add(amount);\r\n        uint256 stake = _stakes[account];\r\n        if(stake == 0) {\r\n            staker_count++;\r\n        }\r\n        uint256 accumulated_reward = getReward(account);\r\n        if(accumulated_reward > 0) {\r\n            // set pending rewards to the current reward\r\n            pending_rewards[account] = accumulated_reward;\r\n        }\r\n        _stakes[account] = stake.add(amount);\r\n        // reset bond value for this account\r\n        _bond_value_addr[account] = bond_value;\r\n    }\r\n\r\n    /**\r\n        @dev unstakes a certain amount, if unstaking is currently not possible the function MUST revert\r\n        @param account From whom\r\n        @param amount Amount to remove from the stake\r\n    */\r\n    function unstakeFrom(address payable account, uint256 amount) public onlyOwner nonReentrant {\r\n        require(account != address(0), \"Distribute: Invalid account\");\r\n        require(amount > 0, \"Distribute: Amount must be greater than zero\");\r\n        uint256 stake = _stakes[account];\r\n        require(amount <= stake, \"Distribute: Dont have enough staked\");\r\n        uint256 to_reward = _getReward(account, amount);\r\n        _total_staked -= amount;\r\n        stake -= amount;\r\n        _stakes[account] = stake;\r\n        if(stake == 0) {\r\n            staker_count--;\r\n        }\r\n\r\n        if(to_reward == 0) return;\r\n\r\n        // void pending rewards\r\n        pending_rewards[account] = 0;\r\n\r\n        //take into account dust error during payment too\r\n        if(address(reward_token) != address(0)) {\r\n            reward_token.safeTransfer(account, to_reward);\r\n        }\r\n        else {\r\n            Address.sendValue(account, to_reward);\r\n        }\r\n    }\r\n\r\n     /**\r\n        @dev Withdraws rewards (basically unstake then restake)\r\n        @param account From whom\r\n        @param amount Amount to remove from the stake\r\n    */\r\n    function withdrawFrom(address payable account, uint256 amount) external onlyOwner {\r\n        unstakeFrom(account, amount);\r\n        stakeFor(account, amount);\r\n    }\r\n\r\n    /**\r\n        @dev Called contracts to distribute dividends\r\n        Updates the bond value\r\n        @param amount Amount of token to distribute\r\n        @param from Address from which to take the token\r\n    */\r\n    function distribute(uint256 amount, address from) external payable onlyOwner nonReentrant {\r\n        if(address(reward_token) != address(0)) {\r\n            if(amount == 0) return;\r\n            reward_token.safeTransferFrom(from, address(this), amount);\r\n            require(msg.value == 0, \"Distribute: Illegal distribution\");\r\n        } else {\r\n            amount = msg.value;\r\n        }\r\n        // bond precision is always based on 1 unit of staked token\r\n        uint256 total_bonds = _total_staked / 10**staking_decimals;\r\n\r\n        if(total_bonds == 0) {\r\n            // not enough staked to compute bonds account, put into temp pool\r\n            _temp_pool = _temp_pool.add(amount);\r\n            return;\r\n        }\r\n\r\n        // if a temp pool existed, add it to the current distribution\r\n        if(_temp_pool > 0) {\r\n            amount = amount.add(_temp_pool);\r\n            _temp_pool = 0;\r\n        }\r\n\r\n        uint256 temp_to_distribute = to_distribute + amount;\r\n        // bond value is always computed on decimals adjusted rewards\r\n        uint256 bond_increase = temp_to_distribute * DECIMALS_ADJUSTMENT / total_bonds;\r\n        // adjust back for distributed total\r\n        uint256 distributed_total = total_bonds.mul(bond_increase) / DECIMALS_ADJUSTMENT;\r\n        bond_value = bond_value.add(bond_increase);\r\n        //collect the dust because of the PRECISION used for bonds\r\n        //it will be reinjected into the next distribution\r\n        to_distribute = temp_to_distribute - distributed_total;\r\n    }\r\n\r\n    /**\r\n        @dev Returns the current total staked for an address\r\n        @param account address owning the stake\r\n        @return the total staked for this account\r\n    */\r\n    function totalStakedFor(address account) external view returns (uint256) {\r\n        return _stakes[account];\r\n    }\r\n    \r\n    /**\r\n        @return current staked token\r\n    */\r\n    function totalStaked() external view returns (uint256) {\r\n        return _total_staked;\r\n    }\r\n\r\n    /**\r\n        @dev Returns how much the user can withdraw currently\r\n        @param account Address of the user to check reward for\r\n        @return the amount account will perceive if he unstakes now\r\n    */\r\n    function getReward(address account) public view returns (uint256) {\r\n        return _getReward(account,_stakes[account]);\r\n    }\r\n\r\n    /**\r\n        @dev returns the total amount of stored rewards\r\n    */\r\n    function getTotalReward() external view returns (uint256) {\r\n        if(address(reward_token) != address(0)) {\r\n            return reward_token.balanceOf(address(this));\r\n        } else {\r\n            return address(this).balance;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev Returns how much the user can withdraw currently\r\n        @param account Address of the user to check reward for\r\n        @param amount Number of stakes\r\n        @return reward the amount account will perceive if he unstakes now\r\n    */\r\n    function _getReward(address account, uint256 amount) internal view returns (uint256 reward) {\r\n        // we apply decimals adjustement as bond value is computed on decimals adjusted rewards\r\n        uint256 accountBonds = amount.divDown(10**staking_decimals);\r\n        reward = accountBonds.mul(bond_value.sub(_bond_value_addr[account])).divDown(DECIMALS_ADJUSTMENT);\r\n        // adding pending rewards\r\n        reward = reward.add(pending_rewards[account]);\r\n    }\r\n}\r\n\r\n//https://github.com/ethereum/EIPs/blob/master/EIPS/eip-900.md\r\ninterface IERC900 {\r\n    event Staked(address indexed addr, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed addr, uint256 amount, uint256 total, bytes data);\r\n\r\n    function stake(uint256 amount, bytes calldata data) external;\r\n    function stakeFor(address addr, uint256 amount, bytes calldata data) external;\r\n    function unstake(uint256 amount, bytes calldata data) external;\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n    function totalStaked() external view returns (uint256);\r\n    function token() external view returns (address);\r\n    function supportsHistory() external pure returns (bool);\r\n\r\n    // optional\r\n    //function lastStakedFor(address addr) public view returns (uint256);\r\n    //function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256);\r\n    //function totalStakedAt(uint256 blockNumber) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * An IERC900 staking contract\r\n */\r\ncontract StakingDoubleERC20 is IERC900  {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @dev handle to access ERC20 token token contract to make transfers\r\n    IERC20 private _token;\r\n    Distribute immutable public staking_contract_ohm;\r\n    Distribute immutable public staking_contract_eefi;\r\n\r\n    event ProfitOHM(uint256 amount);\r\n    event ProfitEEFI(uint256 amount);\r\n    event StakeChanged(uint256 total, uint256 timestamp);\r\n\r\n    constructor(IERC20 stake_token, uint256 stake_decimals, IERC20 eefi) {\r\n        require(address(stake_token) != address(0), \"StakingDoubleERC20: Invalid stake token\");\r\n        require(address(eefi) != address(0), \"StakingDoubleERC20: Invalid eefi token\");\r\n        _token = stake_token;\r\n        // we do not need to sanitize the decimals here because the Distribute contract will do it\r\n        staking_contract_ohm = new Distribute(stake_decimals, 9, IERC20(0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5));\r\n        staking_contract_eefi = new Distribute(stake_decimals, 18, eefi);\r\n    }\r\n\r\n    /**\r\n        @dev Takes OHM from sender and puts it in the reward pool\r\n        @param amount Amount of token to add to rewards\r\n    */\r\n    function distribute_ohm(uint256 amount) external {\r\n        staking_contract_ohm.distribute(amount, msg.sender);\r\n        emit ProfitOHM(amount);\r\n    }\r\n\r\n    /**\r\n        @dev Takes EEFI from sender and puts it in the reward pool\r\n        @param amount Amount of token to add to rewards\r\n    */\r\n    function distribute_eefi(uint256 amount) external {\r\n        staking_contract_eefi.distribute(amount, msg.sender);\r\n        emit ProfitEEFI(amount);\r\n    }\r\n\r\n    /**\r\n        @dev Sends any reward token mistakingly sent to the main contract to the reward pool\r\n    */\r\n    function forward() external {\r\n        IERC20 rewardToken = IERC20(staking_contract_ohm.reward_token());\r\n        uint256 balance = rewardToken.balanceOf(address(this));\r\n        if(balance > 0) {\r\n            rewardToken.approve(address(staking_contract_ohm), balance);\r\n            staking_contract_ohm.distribute(balance, address(this));\r\n            emit ProfitOHM(balance);\r\n        }\r\n\r\n        rewardToken = IERC20(staking_contract_eefi.reward_token());\r\n        balance = rewardToken.balanceOf(address(this));\r\n        if(balance > 0) {\r\n            rewardToken.approve(address(staking_contract_eefi), balance);\r\n            staking_contract_eefi.distribute(balance, address(this));\r\n            emit ProfitEEFI(balance);\r\n        }\r\n    }\r\n    \r\n    /**\r\n        @dev Stakes a certain amount of tokens, this MUST transfer the given amount from the account\r\n        @param amount Amount of ERC20 token to stake\r\n        @param data Additional data as per the EIP900\r\n    */\r\n    function stake(uint256 amount, bytes calldata data) external override {\r\n        stakeFor(msg.sender, amount, data);\r\n    }\r\n\r\n    /**\r\n        @dev Stakes a certain amount of tokens, this MUST transfer the given amount from the caller\r\n        @param account Address who will own the stake afterwards\r\n        @param amount Amount of ERC20 token to stake\r\n        @param data Additional data as per the EIP900\r\n    */\r\n    function stakeFor(address account, uint256 amount, bytes calldata data) public override {\r\n        //transfer the ERC20 token from the account, he must have set an allowance of {amount} tokens\r\n        _token.safeTransferFrom(msg.sender, address(this), amount);\r\n        staking_contract_ohm.stakeFor(account, amount);\r\n        staking_contract_eefi.stakeFor(account, amount);\r\n        emit Staked(account, amount, totalStakedFor(account), data);\r\n        emit StakeChanged(staking_contract_ohm.totalStaked(), block.timestamp);\r\n    }\r\n\r\n    /**\r\n        @dev Unstakes a certain amount of tokens, this SHOULD return the given amount of tokens to the account, if unstaking is currently not possible the function MUST revert\r\n        @param amount Amount of ERC20 token to remove from the stake\r\n        @param data Additional data as per the EIP900\r\n    */\r\n    function unstake(uint256 amount, bytes calldata data) external override {\r\n        staking_contract_ohm.unstakeFrom(payable(msg.sender), amount);\r\n        staking_contract_eefi.unstakeFrom(payable(msg.sender), amount);\r\n        _token.safeTransfer(msg.sender, amount);\r\n        emit Unstaked(msg.sender, amount, totalStakedFor(msg.sender), data);\r\n        emit StakeChanged(staking_contract_ohm.totalStaked(), block.timestamp);\r\n    }\r\n\r\n     /**\r\n        @dev Withdraws rewards (basically unstake then restake)\r\n        @param amount Amount of ERC20 token to remove from the stake\r\n    */\r\n    function withdraw(uint256 amount) external {\r\n        staking_contract_ohm.withdrawFrom(payable(msg.sender), amount);\r\n        staking_contract_eefi.withdrawFrom(payable(msg.sender),amount);\r\n    }\r\n\r\n    /**\r\n        @dev Returns the current total of tokens staked for an address\r\n        @param account address owning the stake\r\n        @return the total of staked tokens of this address\r\n    */\r\n    function totalStakedFor(address account) public view override returns (uint256) {\r\n        return staking_contract_ohm.totalStakedFor(account);\r\n    }\r\n    \r\n    /**\r\n        @dev Returns the current total of tokens staked\r\n        @return the total of staked tokens\r\n    */\r\n    function totalStaked() external view override returns (uint256) {\r\n        return staking_contract_ohm.totalStaked();\r\n    }\r\n\r\n    /**\r\n        @dev returns the total rewards stored for ohm and eefi\r\n    */\r\n    function totalReward() external view returns (uint256 _ohm, uint256 _eefi) {\r\n        _ohm = staking_contract_ohm.getTotalReward();\r\n        _eefi = staking_contract_eefi.getTotalReward();\r\n    }\r\n\r\n    /**\r\n        @dev Address of the token being used by the staking interface\r\n        @return ERC20 token token address\r\n    */\r\n    function token() external view override returns (address) {\r\n        return address(_token);\r\n    }\r\n\r\n    /**\r\n        @dev MUST return true if the optional history functions are implemented, otherwise false\r\n        We dont want this\r\n    */\r\n    function supportsHistory() external pure override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n        @param account Address of the user to check reward for\r\n        @return _ohm the amount of OHM the account will receive if they unstake now\r\n        @return _eefi the amount of EEFI the account will receive if they unstake now\r\n    */\r\n    function getReward(address account) public view returns (uint256 _ohm, uint256 _eefi) {\r\n        _ohm = staking_contract_ohm.getReward(account);\r\n        _eefi = staking_contract_eefi.getReward(account);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"stake_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stake_decimals\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"eefi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitEEFI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitOHM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"StakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distribute_eefi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distribute_ohm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ohm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_eefi\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking_contract_eefi\",\"outputs\":[{\"internalType\":\"contract Distribute\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking_contract_ohm\",\"outputs\":[{\"internalType\":\"contract Distribute\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ohm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_eefi\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingDoubleERC20", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000079fe75708e834c5a6857a8b17eeac651907c1da8000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000857ffc55b1aa61a7ff847c82072790cae73cd883", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e3c8f5b0478c3c8bc19371bd791d304c85e974760944a1795256fe82b7b4442e"}