{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libs/LinearDistributionIntervalDecrease.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * This is the library that calculates the reward for the period with linear distribution and interval decrease.\\n * Supports the constant reward amount (decreaseAmount_ = 0)\\n */\\nlibrary LinearDistributionIntervalDecrease {\\n    /**\\n     * The function to calculate the reward for the period.\\n     * @param initialAmount_ The initial reward amount.\\n     * @param decreaseAmount_ The reward decrease amount.\\n     * @param payoutStart_ The timestamp when the period starts to pay out rewards.\\n     * @param interval_ The interval in seconds between reward decreases.\\n     * @param startTime_ The timestamp when the period starts.\\n     * @param endTime_ The timestamp when the period ends.\\n     * @return The reward amount.\\n     */\\n    function getPeriodReward(\\n        uint256 initialAmount_,\\n        uint256 decreaseAmount_,\\n        uint128 payoutStart_,\\n        uint128 interval_,\\n        uint128 startTime_,\\n        uint128 endTime_\\n    ) external pure returns (uint256) {\\n        if (interval_ == 0) {\\n            return 0;\\n        }\\n\\n        // 'startTime_' can't be less than 'payoutStart_'\\n        if (startTime_ < payoutStart_) {\\n            startTime_ = payoutStart_;\\n        }\\n\\n        uint128 maxEndTime_ = _calculateMaxEndTime(payoutStart_, interval_, initialAmount_, decreaseAmount_);\\n\\n        if (endTime_ > maxEndTime_) {\\n            endTime_ = maxEndTime_;\\n        }\\n\\n        // Return 0 when calculation 'startTime_' is bigger then 'endTime_'...\\n        if (startTime_ >= endTime_) {\\n            return 0;\\n        }\\n\\n        // Calculate interval that less then 'interval_' range\\n        uint256 timePassedBefore_ = startTime_ - payoutStart_;\\n        if ((timePassedBefore_ / interval_) == ((endTime_ - payoutStart_) / interval_)) {\\n            uint256 intervalsPassed_ = timePassedBefore_ / interval_;\\n            uint256 intervalFullReward_ = initialAmount_ - intervalsPassed_ * decreaseAmount_;\\n\\n            return (intervalFullReward_ * (endTime_ - startTime_)) / interval_;\\n        }\\n\\n        // Calculate interval that more then 'interval_' range\\n        uint256 firstPeriodReward_ = _calculatePartPeriodReward(\\n            payoutStart_,\\n            startTime_,\\n            interval_,\\n            initialAmount_,\\n            decreaseAmount_,\\n            true\\n        );\\n\\n        uint256 secondPeriodReward_ = _calculateFullPeriodReward(\\n            payoutStart_,\\n            startTime_,\\n            endTime_,\\n            interval_,\\n            initialAmount_,\\n            decreaseAmount_\\n        );\\n\\n        uint256 thirdPeriodReward_ = _calculatePartPeriodReward(\\n            payoutStart_,\\n            endTime_,\\n            interval_,\\n            initialAmount_,\\n            decreaseAmount_,\\n            false\\n        );\\n\\n        return firstPeriodReward_ + secondPeriodReward_ + thirdPeriodReward_;\\n    }\\n\\n    function _calculateMaxEndTime(\\n        uint128 payoutStart_,\\n        uint128 interval_,\\n        uint256 initialAmount_,\\n        uint256 decreaseAmount_\\n    ) private pure returns (uint128) {\\n        if (decreaseAmount_ == 0) {\\n            return type(uint128).max;\\n        }\\n\\n        uint256 maxIntervals_ = _divideCeil(initialAmount_, decreaseAmount_);\\n\\n        return uint128(payoutStart_ + maxIntervals_ * interval_);\\n    }\\n\\n    function _calculatePartPeriodReward(\\n        uint128 payoutStart_,\\n        uint128 startTime_,\\n        uint128 interval_,\\n        uint256 initialAmount_,\\n        uint256 decreaseAmount_,\\n        bool toEnd_\\n    ) private pure returns (uint256) {\\n        uint256 intervalsPassed_ = (startTime_ - payoutStart_) / interval_;\\n        uint256 decreaseRewardAmount_ = intervalsPassed_ * decreaseAmount_;\\n        if (decreaseRewardAmount_ >= initialAmount_) {\\n            return 0;\\n        }\\n        uint256 intervalFullReward_ = initialAmount_ - decreaseRewardAmount_;\\n\\n        uint256 intervalPart_;\\n        if (toEnd_) {\\n            intervalPart_ = interval_ * (intervalsPassed_ + 1) + payoutStart_ - startTime_;\\n        } else {\\n            intervalPart_ = startTime_ - interval_ * intervalsPassed_ - payoutStart_;\\n        }\\n\\n        if (intervalPart_ == interval_) {\\n            return 0;\\n        }\\n\\n        return (intervalFullReward_ * intervalPart_) / interval_;\\n    }\\n\\n    function _calculateFullPeriodReward(\\n        uint128 payoutStart_,\\n        uint128 startTime_,\\n        uint128 endTime_,\\n        uint128 interval_,\\n        uint256 initialAmount_,\\n        uint256 decreaseAmount_\\n    ) private pure returns (uint256) {\\n        // START calculate initial reward when period start\\n        uint256 timePassedBefore_ = startTime_ - payoutStart_;\\n        uint256 intervalsPassedBefore_ = _divideCeil(timePassedBefore_, interval_);\\n\\n        uint256 decreaseRewardAmount_ = intervalsPassedBefore_ * decreaseAmount_;\\n\\n        if (decreaseRewardAmount_ >= initialAmount_) {\\n            return 0;\\n        }\\n\\n        uint256 initialReward_ = initialAmount_ - decreaseRewardAmount_;\\n        // END\\n\\n        // Intervals passed\\n        uint256 ip_ = ((endTime_ - payoutStart_ - intervalsPassedBefore_ * interval_) / interval_);\\n        if (ip_ == 0) {\\n            return 0;\\n        }\\n\\n        return initialReward_ * ip_ - (decreaseAmount_ * (ip_ * (ip_ - 1))) / 2;\\n    }\\n\\n    function _divideCeil(uint256 a_, uint256 b_) private pure returns (uint256) {\\n        return (a_ + b_ - 1) / b_;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decreaseAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"payoutStart_\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"interval_\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"startTime_\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endTime_\",\"type\":\"uint128\"}],\"name\":\"getPeriodReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "LinearDistributionIntervalDecrease", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}