{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/WhaleGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport \\\"./WhaleToken.sol\\\";\\nimport \\\"./RewardsVesting.sol\\\";\\n\\n// errors\\n    \\n    // emitted when the deposit is not the right amount\\n    error IncorrectDepositAmount();\\n\\n    // emitted when the deposit timelock has not passed\\n    error DepositTimelockNotPassed();\\n\\n    // emitted when the user deposits twice in the same block\\n    error DepositCooldown();\\n\\n    // emitted when the user is already the claimer\\n    error AlreadyClaimer();\\n\\n    // emitted when the claimer is not the sender\\n    error NotClaimer();\\n\\n    // emitted when the claim time has not passed\\n    error ClaimTimeNotPassed();\\n    \\n \\ncontract WhaleGame {\\n\\n// events\\n\\n    // emitted when a user deposits\\n    event Deposited(address indexed user, uint256 indexed amount);\\n\\n    // emitted when a user claims\\n    event Claim(uint256 indexed round, uint256 indexed amount, address indexed user, address vestingContract);\\n\\n// deps\\n\\n    // the $WHALE token\\n    WhaleToken public whaleToken;\\n\\n// constants\\n\\n    // initial deposit cost (in wei) for each round\\n    uint256 public constant INITIAL_DEPOSIT_COST = 5e16 wei;\\n\\n    // fee charged for each deposit that goes to back the token (in percents)\\n    uint256 public constant FEE_RATE = 50;\\n\\n    // incremental rate of growth for deposits (in tenths of percents)\\n    uint256 public constant GROWTH_RATE = 33; // 3.3%\\n\\n    // the minimum amount of time elapsed between each deposit\\n    uint256 public constant BUFFER_PERIOD = 15 seconds;\\n\\n    // the amount of time a user has to wait in between deposits\\n    uint256 public constant DEPOSIT_TIMELOCK = 12 hours;\\n\\n    // the amount of time a user has to wait in before claiming\\n    uint256 public constant CLAIM_TIMELOCK = 1 days;\\n\\n    // the decay factor on the token emissions between rounds (in percents)\\n    uint256 public constant DECAY_FACTOR = 85;\\n\\n    // the lowest multiplier for WHALE token rewards \u2014 initial rewards are 10x this amount\\n    uint256 public constant MIN_TOKEN_MULTIPLIER = 1e17;\\n\\n    // base number of tokens minted before mutliplier is applied\\n    uint256 public constant BASE_TOKENS_MINTED = 100_000;\\n\\n// states\\n\\n    // the current token reward multiplier\\n    uint256 public tokenMultiplier = 1e18; // this value decays per round until 1e17\\n\\n    // the current game round\\n    uint256 public round;\\n\\n    // the eligible claimer\\n    address public claimer;\\n\\n    // the current deposit cost\\n    uint256 public depositCost;\\n\\n    // the current claim time\\n    uint256 public claimTime;\\n\\n    // the timestamp of the most recent deposit, used to create a time buffers between deposits\\n    uint256 public lastDepositTimestamp;\\n\\n    // an arbitrary message broadcasted by the most recent depositor\\n    string public graffiti;\\n\\n// mappings\\n\\n    // deposit timelock for users\\n    mapping(address => uint256) public userDepositTimelock;\\n\\n    // rewards vesting contract for each round\\n    mapping(uint256 => RewardsVesting) public vestingContractForRound;\\n\\n\\n\\n\\n// functions\\n\\n    constructor () {\\n        // deploy the whale token\\n        whaleToken = new WhaleToken();\\n\\n        // initialize the game state\\n        _resetGame();\\n    }\\n\\n    function deposit(string memory graffiti_) external payable {\\n\\n    // input validations\\n        \\n        // 1. check that the deposit is the right amount\\n        if (msg.value != depositCost) revert IncorrectDepositAmount();\\n\\n        // 2. check that the current time is not before the next deposit timestamp of the msg.sender\\n        if (userDepositTimelock[msg.sender] != 0 && block.timestamp < userDepositTimelock[msg.sender]) revert DepositTimelockNotPassed();\\n\\n        // 3. check that the current block is not the same as the previous deposit block with a 15 second time buffer\\n        if (block.timestamp < lastDepositTimestamp + BUFFER_PERIOD) revert DepositCooldown();\\n\\n        // 4. check that the msg.sender is not already the first claimer\\n        if (msg.sender == claimer) revert AlreadyClaimer();\\n\\n    \\n    // state updates\\n\\n        // 1. set the next deposit timestamp of the msg.sender to 12 hours from now\\n        userDepositTimelock[msg.sender] = block.timestamp + DEPOSIT_TIMELOCK;\\n\\n        // 2. set the last deposit timestamp to the current time\\n        lastDepositTimestamp = block.timestamp;\\n\\n        // 3. set the claimer to the message sender\\n        claimer = payable(msg.sender);\\n\\n        // 4. set the claim time to 1 day from now\\n        claimTime = block.timestamp + CLAIM_TIMELOCK;\\n\\n        // 5. calculate the fee to send to the token contract\\n        uint256 fee = depositCost * FEE_RATE / 100;\\n\\n        // 6. then increment the deposit cost by growth rate (3.3%)\\n        depositCost = depositCost * (1000 + GROWTH_RATE) / 1000;\\n\\n        // 7. set the new message to display on the bulletin\\n        graffiti = graffiti_;\\n\\n\\n    // external interactions       \\n\\n        // mint the multiplier adjusted token reward for this round to the depositor\\n        whaleToken.mint(msg.sender, BASE_TOKENS_MINTED * tokenMultiplier);\\n\\n        // send fee to the token contract\\n        SafeTransferLib.safeTransferETH(address(whaleToken), fee);\\n\\n        // emit the deposit event\\n        emit Deposited(msg.sender, msg.value);\\n    }\\n\\n\\n    function claim() external {\\n    \\n    // input validations\\n\\n        // check that the claimer is the sender\\n        if (msg.sender != claimer) revert NotClaimer();\\n\\n        // require that the claim time has passed\\n        if (block.timestamp < claimTime) revert ClaimTimeNotPassed();\\n\\n    // state updates\\n\\n        // decay the token reward multiplier by decay 85%\\n        tokenMultiplier = (tokenMultiplier * DECAY_FACTOR / 100); \\n\\n        // set up the Rewards Vesting contract\\n        RewardsVesting vestingContract = new RewardsVesting(this, round, payable(msg.sender));\\n        vestingContractForRound[round] = vestingContract;\\n\\n        // reset the game\\n        _resetGame();\\n\\n    // external interactions\\n\\n        // send the balance to the Vesting contract \\n        SafeTransferLib.safeTransferETH(address(vestingContract), address(this).balance);\\n\\n        // unlock fee redemptions on the token after round 10\\n        if (round == 11) {\\n            whaleToken.unlockRedemptions();\\n        }\\n\\n        // emit the claim event ()\\n        emit Claim(round - 1, address(this).balance, msg.sender, address(vestingContract));\\n    }   \\n\\n\\n    function _resetGame() internal {\\n        // set the claimer to the zero address\\n        claimer = payable(address(0));\\n\\n        // set the deposit cost to .1 ether\\n        depositCost = INITIAL_DEPOSIT_COST;\\n\\n        // set the new last deposit timestamp to the current time\\n        lastDepositTimestamp = block.timestamp;\\n\\n        // set the claim time to the latest possible time\\n        claimTime = type(uint256).max;\\n\\n        // wipe the message\\n        graffiti = \\\"\\\";\\n\\n        // increment the round\\n        round++;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/WhaleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.13;\\n\\nimport { ERC20 } from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\n// The $WHALE token contract\\n\\ncontract WhaleToken is ERC20 {\\n    \\n    address whaleGame;\\n    uint256 constant PRECISION = 1e18;\\n    bool public redemptionsLocked;\\n\\n    // errors\\n    error OnlyWhaleGame();\\n    error RedemptionsLocked();\\n\\n    // events\\n    event Redeemed(address indexed to, uint256 amount);\\n    \\n\\n    constructor() ERC20(\\\"Whale Game Token\\\", \\\"WHALE\\\", 18) {\\n        whaleGame = msg.sender;\\n        redemptionsLocked = true;\\n    }\\n\\n    // check that this isn't exploitable\\n    receive() external payable {}\\n\\n\\n    //\\n    function mint(address to_, uint256 amount_) external {\\n        // check that the sender is the whale game\\n        if (msg.sender != whaleGame) revert OnlyWhaleGame();\\n\\n        // mint tokens to the to_ address\\n        _mint(to_, amount_);\\n    }\\n\\n\\n    function redeem(uint256 amount_) external {\\n        // require redemptions to be unlocked\\n        if (redemptionsLocked) revert RedemptionsLocked();\\n\\n        // calculate the amount of ETH to return based on the current total supply\\n        uint256 expectedOut = (address(this).balance * amount_) / totalSupply;\\n\\n        // burn tokens from the message sender\\n        _burn(msg.sender, amount_);\\n\\n        // transfer the ETH to the redeemer\\n        SafeTransferLib.safeTransferETH(msg.sender, expectedOut);\\n\\n        // emit the Redeemed event\\n        emit Redeemed(msg.sender, amount_);\\n    }\\n\\n    function unlockRedemptions() external {\\n        // check the sender is the whale game\\n        if (msg.sender != whaleGame) revert OnlyWhaleGame();\\n\\n        // unlock redemptions\\n        redemptionsLocked = false;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"src/RewardsVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n \\nimport \\\"./WhaleGame.sol\\\";\\nimport { SafeTransferLib } from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\nerror NotAuthorized();\\nerror NotVested();\\n\\ncontract RewardsVesting {\\n\\n    WhaleGame public whaleGame;\\n    uint256 public roundWon;\\n    address payable public winner;\\n\\n    constructor(WhaleGame whaleGame_, uint256 roundWon_, address payable winner_) {\\n        whaleGame = whaleGame_;\\n        roundWon = roundWon_;\\n        winner = winner_;\\n    }\\n\\n    // receives eth from the whale game\\n    receive() external payable {}\\n\\n    function claim() external {\\n        // require the msg.sender is the winner\\n        if (msg.sender != winner) revert NotAuthorized();\\n        \\n        // require 5 rounds have passed\\n        if (whaleGame.round() < roundWon + 5) revert NotVested();\\n\\n        // pay out the reward      \\n        SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);  \\n    }\\n\\n\\n    function earlyClaim() external {\\n        // require the msg.sender is the winner\\n        if (msg.sender != winner) revert NotAuthorized();\\n\\n        // There's a 20% fee per early round to claim. So if you claim 4 rounds early, \\n        // you get 20% of the reward. 3 rounds early, 40% of the reward, 2 rounds -> 60%, 1 round -> 80%\\n        uint256 vestedRounds = (whaleGame.round() - roundWon) > 5 ? 5 : (whaleGame.round() - roundWon);\\n        SafeTransferLib.safeTransferETH(payable(winner), address(this).balance * vestedRounds / 5);\\n\\n        // transfer the remaining balance to the whale token\\n        if (address(this).balance > 0) {\\n            SafeTransferLib.safeTransferETH(payable(address(whaleGame.whaleToken())), address(this).balance);  \\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"prb-test/=lib/prb-test/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimTimeNotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositCooldown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositTimelockNotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectDepositAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotClaimer\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vestingContract\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TOKENS_MINTED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUFFER_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIM_TIMELOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECAY_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_TIMELOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GROWTH_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_DEPOSIT_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TOKEN_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"graffiti_\",\"type\":\"string\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"graffiti\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDepositTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDepositTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingContractForRound\",\"outputs\":[{\"internalType\":\"contract RewardsVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleToken\",\"outputs\":[{\"internalType\":\"contract WhaleToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WhaleGame", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}