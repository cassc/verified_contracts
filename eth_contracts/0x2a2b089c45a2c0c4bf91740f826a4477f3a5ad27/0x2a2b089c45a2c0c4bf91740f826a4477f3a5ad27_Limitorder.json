{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2024-02-05\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2023-10-13\r\n*/\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n//\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface Ifactory {\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\ninterface Irouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract Limitorder is Ownable {\r\n    uint public orderId;\r\n    Irouter public router;\r\n    address public signer;\r\n    bool public lockStatus;\r\n    uint256 public expiration_time = 90 days;\r\n    uint256 public processFee = 0.001e18;\r\n\r\n    struct userDetails {\r\n        bool initiate;\r\n        bool completed;\r\n        address useraddress;\r\n        uint8 flag;\r\n        address[] path;\r\n        uint depAmt;\r\n        uint expectAmt;\r\n        uint expiry;\r\n    }\r\n\r\n    mapping(uint => userDetails) public users;\r\n\r\n    event Initialize(\r\n        uint orderid,\r\n        uint8 flag,\r\n        address indexed from,\r\n        uint DepAmt,\r\n        uint Fee,\r\n        uint ExpectAmt,\r\n        address[] path\r\n    );\r\n    event Swap(\r\n        address indexed from,\r\n        uint Orderid,\r\n        uint8 _flag,\r\n        uint givenAmt,\r\n        uint getAmount,\r\n        uint AmountOutMin\r\n    );\r\n\r\n    constructor(address _router, address _signer) {\r\n        router = Irouter(_router);\r\n        signer = _signer;\r\n    }\r\n\r\n    modifier onlySigner() {\r\n        require(msg.sender == signer, \"Only signer\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if lockStatus is true\r\n     */\r\n    modifier isLock() {\r\n        require(lockStatus == false, \" Contract Locked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by other contract\r\n     */\r\n    modifier isContractCheck(address _user) {\r\n        require(!isContract(_user), \"Invalid address\");\r\n        _;\r\n    }\r\n\r\n    modifier isValidUser(uint id) {\r\n        require(msg.sender == users[id].useraddress, \"Invalid user\");\r\n        _;\r\n    }\r\n\r\n    modifier isPairExist(address[] memory path) {\r\n        require(\r\n            Ifactory(router.factory()).getPair(path[0], path[1]) != address(0),\r\n            \"Invalid user\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function updateRouter (address _router) external onlyOwner {\r\n        router = Irouter(_router);\r\n    }\r\n\r\n    function initialize(\r\n        uint _depAmt,\r\n        address[] memory path,\r\n        uint8 _flag,\r\n        uint _expectAmt\r\n    ) external payable isPairExist(path) isLock {\r\n        require(_flag >= 1 && _flag <= 3, \"Incorrect flag\");\r\n        require(_depAmt > 0, \"Incorrect params\");\r\n\r\n        address _user = _msgSender();\r\n\r\n        orderId++;\r\n        userDetails storage user = users[orderId];\r\n\r\n        if (_flag == 1)\r\n            require(msg.value >= _depAmt + processFee, \"Incorrect flag1 amt\");\r\n        else {\r\n            require(msg.value == processFee, \"Incorrect flag2 amt\");\r\n            tokenSafeTransferFrom(\r\n                IERC20(path[0]),\r\n                _user,\r\n                address(this),\r\n                _depAmt\r\n            );\r\n        }\r\n\r\n        sendEth(owner(), processFee);\r\n\r\n        user.depAmt = _depAmt;\r\n        user.initiate = true;\r\n        user.useraddress = _user;\r\n        user.path = path;\r\n        user.flag = _flag;\r\n        user.expectAmt = _expectAmt;\r\n        user.expiry = block.timestamp + expiration_time;\r\n\r\n        emit Initialize(\r\n            orderId,\r\n            _flag,\r\n            _user,\r\n            _depAmt,\r\n            processFee,\r\n            _expectAmt,\r\n            path\r\n        );\r\n    }\r\n\r\n    function swap(uint _orderId, uint _amountOutMin) public onlySigner {\r\n        require(_orderId > 0 && _orderId <= orderId, \"Incorrect id\");\r\n        userDetails storage user = users[_orderId];\r\n        require(!user.completed, \"Already completed\");\r\n        require(user.initiate, \"No order for swap\");\r\n        require(user.expiry >= block.timestamp,'Order Expiry');\r\n        uint inAmt = _update(user);\r\n\r\n        if (user.flag == 1) {\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                value: inAmt\r\n            }(_amountOutMin, user.path, user.useraddress, block.timestamp + 900);\r\n        } else if (user.flag == 2) {\r\n            IERC20(user.path[0]).approve(address(router),inAmt);\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                inAmt,\r\n                _amountOutMin,\r\n                user.path,\r\n                user.useraddress,\r\n                block.timestamp + 900\r\n            );\r\n        } else {\r\n            IERC20(user.path[0]).approve(address(router),inAmt);\r\n            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                inAmt,\r\n                _amountOutMin,\r\n                user.path,\r\n                user.useraddress,\r\n                block.timestamp + 900\r\n            );\r\n        }\r\n\r\n        user.completed = true;\r\n        emit Swap(user.useraddress, _orderId, user.flag, inAmt, user.expectAmt,_amountOutMin);\r\n    }\r\n\r\n    function _update(userDetails storage user) internal returns (uint) {\r\n        uint[] memory amt = router.getAmountsIn(user.expectAmt, user.path);\r\n        if (user.flag == 1) {\r\n            if (amt[0] < user.depAmt) {\r\n                sendEth(user.useraddress, user.depAmt - amt[0]);\r\n                return amt[0];\r\n            } else return amt[0];\r\n        } else {\r\n            if (amt[0] < user.depAmt) {\r\n                tokenSafeTransfer(\r\n                    IERC20(user.path[0]),\r\n                    user.useraddress,\r\n                    user.depAmt - amt[0]\r\n                );\r\n                return amt[0];\r\n            } else return amt[0];\r\n        }\r\n    }\r\n\r\n    function cancel(uint id) external isValidUser(id) {\r\n        require(id > 0, \"Incorrect id\");\r\n        userDetails storage user = users[id];\r\n        address _user = _msgSender();\r\n        require(\r\n            !user.completed && _user == user.useraddress,\r\n            \"No order for cancel\"\r\n        );\r\n\r\n        uint amount = user.depAmt;\r\n\r\n        require(amount > 0, \"Invalid Amount\");\r\n\r\n        if (user.flag == 1) sendEth(_user, amount);\r\n        else tokenSafeTransfer(IERC20(user.path[0]), _user, amount);\r\n        user.initiate = false;\r\n    }\r\n\r\n    function viewPath(uint _id) public view returns (address[] memory) {\r\n        return users[_id].path;\r\n    }\r\n\r\n    function updateSigner(address _signer) external  onlyOwner {\r\n        signer = _signer;\r\n    }\r\n\r\n    function updateExpiryTime (uint256 _time) external  onlyOwner {\r\n        expiration_time = _time;\r\n    }\r\n\r\n    function updateFee (uint256 _fee) external onlyOwner {\r\n        processFee = _fee; \r\n    }\r\n\r\n    function emergencyWithdraw(\r\n        address source,\r\n        address user,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if (source == address(0)) sendEth(user, amount);\r\n        else tokenSafeTransfer(IERC20(source), user, amount);\r\n    }\r\n\r\n    function contractLock(bool _lockStatus) external onlyOwner returns (bool) {\r\n        lockStatus = _lockStatus;\r\n        return true;\r\n    }\r\n\r\n    function isContract(address _account) public view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_account)\r\n        }\r\n        if (size != 0) return true;\r\n        return false;\r\n    }\r\n\r\n    function sendEth(address _devAddr, uint256 _amt) internal {\r\n        bool success;\r\n        assembly {\r\n            success := call(gas(), _devAddr, _amt, 0, 0, 0, 0)\r\n        }\r\n        require(success, \"Transfer Failed\");\r\n    }\r\n\r\n    function tokenSafeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(\r\n                freeMemoryPointer,\r\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(\r\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\r\n                    iszero(returndatasize())\r\n                ),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function tokenSafeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(\r\n                freeMemoryPointer,\r\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(\r\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\r\n                    iszero(returndatasize())\r\n                ),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"DepAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ExpectAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Orderid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_flag\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"givenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"AmountOutMin\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lockStatus\",\"type\":\"bool\"}],\"name\":\"contractLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expiration_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depAmt\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"_flag\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_expectAmt\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract Irouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"updateExpiryTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"updateSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initiate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"depAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"viewPath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Limitorder", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000e4de842d21c2cde9fadb3baa666ea7aaad8d95a9", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://19c290ebddb4a5b2f70820eaf77d5b59d1b14214ea8a3cad385da5a4befa17f9"}