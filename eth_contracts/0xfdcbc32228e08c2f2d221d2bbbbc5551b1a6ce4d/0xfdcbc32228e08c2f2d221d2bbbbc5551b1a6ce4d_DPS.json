{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// solhint-disable-next-line interface-starts-with-i\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/dream-presale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\\\";\\r\\n\\r\\n\\r\\ncontract DPS {\\r\\n    AggregatorV3Interface internal SHIB_ETH_Feed;\\r\\n    AggregatorV3Interface internal ETH_USD_Feed;\\r\\n\\r\\n    uint MAX_TOTAL = 10000000000000;\\r\\n    uint MAX_WALLET =  250000000000;\\r\\n    uint MIN_ENTRY =     5000000000;\\r\\n    uint raisedValue = 0;\\r\\n\\r\\n    mapping(address => Commit[]) PreSaleCommits;\\r\\n    address[] committedWallets;\\r\\n\\r\\n    struct Commit {\\r\\n        address wa;\\r\\n        string currency;\\r\\n        uint qty;\\r\\n        uint USDValue;\\r\\n    }\\r\\n\\r\\n    struct ExportData {\\r\\n        address wallet;\\r\\n        uint totalUSDValue;\\r\\n    }\\r\\n    \\r\\n    address adminWallet = 0x5E2614e1965640d7760324Cf9E7F138EA091AC4C;\\r\\n    address ownerWallet = 0x75d9df1efe6d860218AFCF5c688F3DAd61638d83;\\r\\n\\r\\n// testnet\\r\\n    // address presaleWallet = 0x8ef3782e967DB943233bE4f09D67d4fd51EA0102;\\r\\n    address presaleWallet = 0x5E2614e1965640d7760324Cf9E7F138EA091AC4C;\\r\\n\\r\\n    IERC20 internal constant ERC20_Shib =\\r\\n        IERC20(0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE);\\r\\n\\r\\n    IERC20 internal constant ERC20_USDT =\\r\\n        IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\\r\\n\\r\\n    IERC20 internal constant ERC20_USDC =\\r\\n        IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\r\\n\\r\\n\\r\\n    event PreSaleCommit(\\r\\n        address indexed buyer,\\r\\n        uint usdValue\\r\\n    );\\r\\n\\r\\n    constructor() { \\r\\n        SHIB_ETH_Feed = AggregatorV3Interface(0x8dD1CD88F43aF196ae478e91b9F5E4Ac69A97C61);\\r\\n        ETH_USD_Feed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\r\\n    }\\r\\n\\r\\n    function addCommitForValue(uint qty, string calldata currency) public payable {\\r\\n        uint i = 0;\\r\\n        uint walletCommit = 0;\\r\\n        uint usdValue = 0;\\r\\n\\r\\n        while (i < PreSaleCommits[msg.sender].length) {\\r\\n            walletCommit = walletCommit + PreSaleCommits[msg.sender][i].USDValue;\\r\\n            i++;\\r\\n        }\\r\\n\\r\\n        bytes32 inputHash = keccak256(abi.encodePacked(currency));\\r\\n\\r\\n        if (inputHash == keccak256(abi.encodePacked(\\\"SHIB\\\"))) {\\r\\n            usdValue = getUSDValue(qty, currency);\\r\\n            require(ERC20_Shib.balanceOf(msg.sender) >= qty, \\\"nsf\\\");\\r\\n            ERC20_Shib.transferFrom(msg.sender, presaleWallet, qty);\\r\\n\\r\\n        } else if (inputHash == keccak256(abi.encodePacked(\\\"USDC\\\"))) {\\r\\n            usdValue = qty; // USDC uses 8 decimals\\r\\n            require(ERC20_USDC.balanceOf(msg.sender) >= qty, \\\"nsf\\\");\\r\\n            ERC20_USDC.transferFrom(msg.sender, presaleWallet, qty);\\r\\n\\r\\n        } else if (inputHash == keccak256(abi.encodePacked(\\\"USDT\\\"))) {\\r\\n            usdValue = qty; // USDT uses 8 decimals\\r\\n            require(ERC20_USDT.balanceOf(msg.sender) >= qty, \\\"nsf\\\");\\r\\n            ERC20_USDT.transferFrom(msg.sender, presaleWallet, qty);\\r\\n\\r\\n        } else if (inputHash == keccak256(abi.encodePacked(\\\"ETH\\\"))) {\\r\\n            usdValue = getUSDValue(qty, currency);\\r\\n            require(msg.value >= qty, \\\"nsf\\\"); // ETH uses 18 decimals\\r\\n            (bool success, ) = presaleWallet.call{value: qty}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n\\r\\n        } else {\\r\\n            revert(\\\"Invalid Currency\\\");\\r\\n        }\\r\\n\\r\\n        require(usdValue + walletCommit <= MAX_WALLET, \\\"Pre-Sale Wallet Limit Reached\\\");\\r\\n        require(usdValue > MIN_ENTRY, \\\"Min $50 Required\\\");\\r\\n        addCommit(msg.sender, currency, qty, usdValue);\\r\\n    }\\r\\n\\r\\n    function addCommit(address wa, string memory currency, uint qty, uint256 usdValue) private {\\r\\n        require(usdValue + raisedValue <= MAX_TOTAL, \\\"Pre-Sale Total Limit Reached\\\");\\r\\n\\r\\n        Commit memory c = Commit(\\r\\n            msg.sender,\\r\\n            currency,\\r\\n            qty,\\r\\n            usdValue\\r\\n        );\\r\\n\\r\\n        raisedValue = raisedValue + usdValue;\\r\\n        PreSaleCommits[msg.sender].push(c);\\r\\n\\r\\n        bool isAlreadyCommitted = false;\\r\\n        for (uint i = 0; i < committedWallets.length; i++) {\\r\\n            if (committedWallets[i] == wa) {\\r\\n                isAlreadyCommitted = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (!isAlreadyCommitted) {\\r\\n            committedWallets.push(wa);\\r\\n        }\\r\\n\\r\\n        emit PreSaleCommit(wa, usdValue);\\r\\n    }    \\r\\n\\r\\n    function getWalletCommits(address wa) public view returns(Commit[] memory) {\\r\\n        if (wa != msg.sender) {\\r\\n            require(msg.sender == adminWallet || msg.sender == ownerWallet);\\r\\n        }\\r\\n    \\r\\n        uint count = PreSaleCommits[wa].length;\\r\\n\\r\\n        Commit[] memory returnCommits = new Commit[](count);\\r\\n        for (uint i = 0; i < count; i++) {\\r\\n            returnCommits[i] = PreSaleCommits[wa][i];\\r\\n        }\\r\\n\\r\\n        return returnCommits;\\r\\n    }\\r\\n\\r\\n    function getWalletTotal(address wa) public view returns(uint) {\\r\\n        if (wa != msg.sender) {\\r\\n            require(msg.sender == adminWallet || msg.sender == ownerWallet);\\r\\n        }\\r\\n    \\r\\n        uint i = 0;\\r\\n        uint walletCommit = 0;\\r\\n\\r\\n        while (i < PreSaleCommits[wa].length) {\\r\\n            walletCommit = walletCommit + PreSaleCommits[wa][i].USDValue;\\r\\n            i++;\\r\\n        }\\r\\n\\r\\n        return walletCommit;\\r\\n    }\\r\\n\\r\\n    function getRaisedValue() public view returns(uint val) {\\r\\n        return raisedValue;\\r\\n    }\\r\\n\\r\\n    function getFullExport() public view isAdmin returns(ExportData[] memory) {\\r\\n        uint length = committedWallets.length;\\r\\n        ExportData[] memory data = new ExportData[](length);\\r\\n\\r\\n        for (uint i = 0; i < length; i++) {\\r\\n            address wallet = committedWallets[i];\\r\\n            uint totalUSDValue = 0;\\r\\n\\r\\n            for (uint j = 0; j < PreSaleCommits[wallet].length; j++) {\\r\\n                totalUSDValue += PreSaleCommits[wallet][j].USDValue;\\r\\n            }\\r\\n\\r\\n            data[i] = ExportData(wallet, totalUSDValue);\\r\\n        }\\r\\n\\r\\n        return data;\\r\\n    }\\r\\n\\r\\n    function getUSDValue(uint quantity, string calldata currency) public view returns (uint) {\\r\\n        int price = 0;\\r\\n\\r\\n        bytes32 inputHash = keccak256(abi.encodePacked(currency));\\r\\n\\r\\n        if (inputHash == keccak256(abi.encodePacked(\\\"SHIB\\\"))) {\\r\\n\\r\\n            (, int shibEthPrice, , ,) = SHIB_ETH_Feed.latestRoundData();\\r\\n            (, int ethUsdPrice, , ,) = ETH_USD_Feed.latestRoundData();\\r\\n            \\r\\n            // Calculate SHIB to USD price\\r\\n            // qty * shibEthPrice * ethUsdPrice / 10^36\\r\\n            int shibUsdValue = (int(quantity) * shibEthPrice * ethUsdPrice) / int(10 ** 36);\\r\\n            \\r\\n            return uint256(shibUsdValue); // Already in 8 decimals\\r\\n        } else if (inputHash == keccak256(abi.encodePacked(\\\"ETH\\\"))) {\\r\\n            (, price, , ,) = ETH_USD_Feed.latestRoundData();\\r\\n            return (uint256(price) * quantity) / (10 ** 18);\\r\\n\\r\\n        } else {\\r\\n            revert(\\\"Invalid Currency\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier isAdmin() {\\r\\n        require(msg.sender == adminWallet || msg.sender == ownerWallet);\\r\\n\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"name\":\"PreSaleCommit\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"addCommitForValue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFullExport\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalUSDValue\",\"type\":\"uint256\"}],\"internalType\":\"struct DPS.ExportData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRaisedValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"getUSDValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wa\",\"type\":\"address\"}],\"name\":\"getWalletCommits\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wa\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDValue\",\"type\":\"uint256\"}],\"internalType\":\"struct DPS.Commit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wa\",\"type\":\"address\"}],\"name\":\"getWalletTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DPS", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}