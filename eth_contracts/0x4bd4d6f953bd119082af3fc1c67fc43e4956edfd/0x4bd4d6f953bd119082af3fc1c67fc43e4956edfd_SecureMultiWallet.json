{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/diamond/interfaces/IGovernanceProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IGovernanceProxy {\\n    function execute(bytes calldata callData) external returns (bytes memory);\\n}\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nlibrary Address {\\n    /**\\n     * @dev Check if the address is a contract\\n            *WARN*: this function will always return `false` if called from a constructor\\n     * @param _addr The address to check\\n     */\\n    function isContract(address _addr) internal returns (bool isContract) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/GovernanceProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IGovernanceProxy} from \\\"../diamond/interfaces/IGovernanceProxy.sol\\\";\\n\\ncontract GovernanceProxy is IGovernanceProxy {\\n    address[] allowedContracts;\\n\\n    constructor(address[] memory _allowedContracts) {\\n        allowedContracts = _allowedContracts;\\n    }\\n\\n    function execute(bytes calldata callData) external returns (bytes memory) {\\n        bool canExecute = false;\\n        for (uint256 i = 0; i < allowedContracts.length; i++) {\\n            if (allowedContracts[i] == msg.sender) {\\n                canExecute = true;\\n                break;\\n            }\\n        }\\n        require(canExecute, \\\"only diamond can execute\\\");\\n        (bool success, bytes memory returndata) = address(msg.sender).call(callData);\\n        if (!success) {\\n            revert(string(returndata));\\n        }\\n        return returndata;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/HexUtils.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\nlibrary HexUtils {\\n    // Convert 32 hexadecimal digits into 16 bytes.\\n    function hexToBytes16 (bytes32 h) internal pure returns (bytes16 b) {\\n        unchecked {\\n            // Ensure all chars below 128\\n            require (h & 0x8080808080808080808080808080808080808080808080808080808080808080 == 0);\\n\\n            // Subtract '0' from every char\\n            h = bytes32 (uint256 (h) - 0x3030303030303030303030303030303030303030303030303030303030303030);\\n\\n            // Ensure all chars still below 128, i.e. no underflow in the previous line\\n            require (h & 0x8080808080808080808080808080808080808080808080808080808080808080 == 0);\\n\\n            // Calculate mask for chars that originally were above '9'\\n            bytes32 ndm = bytes32 ((((uint256(h) + 0x7676767676767676767676767676767676767676767676767676767676767676) & 0x8080808080808080808080808080808080808080808080808080808080808080) >> 7) * 0xFF);\\n\\n            // Subtract 7 ('A' - '0') from every char that originally was above '9'\\n            h = bytes32 (uint256 (h) - uint256 (ndm & 0x0707070707070707070707070707070707070707070707070707070707070707));\\n\\n            // Ensure all chars still below 128, i.e. no underflow in the previous line\\n            require (h & 0x8080808080808080808080808080808080808080808080808080808080808080 == 0);\\n\\n            // Ensure chars that originally were above '9' are now above 9\\n            require (uint256 (h) - uint256 (ndm & 0x0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A) & 0x8080808080808080808080808080808080808080808080808080808080808080 == 0);\\n\\n            // Calculate Mask for chars that originally were above 'F'\\n            bytes32 lcm = bytes32 ((((uint256(h) + 0x7070707070707070707070707070707070707070707070707070707070707070) & 0x8080808080808080808080808080808080808080808080808080808080808080) >> 7) * 0xFF);\\n\\n            // Subtract 32 ('a' - 'A') from all chars that oroginally were above 'F'\\n            h = bytes32 (uint256 (h) - uint256 (lcm & 0x2020202020202020202020202020202020202020202020202020202020202020));\\n\\n            // Ensure chars that originally were above 'F' are now above 9\\n            require (uint256 (h) - uint256 (lcm & 0x0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A) & 0x8080808080808080808080808080808080808080808080808080808080808080 == 0);\\n\\n            // Ensure all chars are below 16\\n            require (h & 0xF0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0 == 0);\\n\\n            // 0x0A0B0C0D... -> 0xAB00CD00...\\n            h = (h & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) << 4 | (h & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) << 8;\\n\\n            // 0xAA00BB00CC00DD00... -> 0xAABB0000CCDD0000...\\n            h = h & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000 | (h & 0x0000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF00) << 8;\\n\\n            // 0xAAAA0000BBBB0000CCCC0000DDDD0000... -> 0xAAAABBBB00000000CCCCDDDD00000000...\\n            h = h & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000 | (h & 0x00000000FFFF000000000000FFFF000000000000FFFF000000000000FFFF0000) << 16;\\n\\n            // 0xAAAAAAAA00000000BBBBBBBB00000000CCCCCCCC00000000DDDDDDDD00000000 -> 0xAAAAAAAABBBBBBBB0000000000000000CCCCCCCCDDDDDDDD0000000000000000\\n            h = h & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000 | (h & 0x0000000000000000FFFFFFFF000000000000000000000000FFFFFFFF00000000) << 32;\\n\\n            // 0xAAAAAAAAAAAAAAAA0000000000000000BBBBBBBBBBBBBBBB0000000000000000 -> 0xAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBB00000000000000000000000000000000\\n            h = h & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 | (h & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF0000000000000000) << 64;\\n\\n            // Trim to 16 bytes\\n            b = bytes16 (h);\\n        }\\n    }\\n\\n    // Source: https://gist.github.com/3sGgpQ8H/cdd466309eac55852b88b3da6da92cce\\n    function parseAddress(string memory s) internal pure returns (address, bool) {\\n        if (bytes(s).length != 42) {\\n            return (address(0), false);\\n        }\\n        bytes2 prefix;\\n        bytes32 leftHex;\\n        bytes32 rightHex;\\n        assembly {\\n            prefix := mload (add (s, 0x20))\\n            leftHex := mload (add (s, 0x22))\\n            rightHex := mload (add (s, 0x2A))\\n        }\\n        if (prefix != '0x') {\\n            return (address(0), false);\\n        }\\n        bytes16 left = hexToBytes16(leftHex);\\n        bytes16 right = hexToBytes16(rightHex);\\n        return (address (bytes20 (left) | bytes20 (right) >> 32), true);\\n    }\\n\\n    function toHex16(bytes16 data) internal pure returns (bytes32 result) {\\n        result = bytes32 (data) & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 |\\n            (bytes32 (data) & 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 64;\\n        result = result & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000 |\\n            (result & 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >> 32;\\n        result = result & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000 |\\n            (result & 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >> 16;\\n        result = result & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000 |\\n            (result & 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >> 8;\\n        result = (result & 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >> 4 |\\n            (result & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >> 8;\\n        result = bytes32 (0x3030303030303030303030303030303030303030303030303030303030303030 +\\n        uint256 (result) +\\n        (uint256 (result) + 0x0606060606060606060606060606060606060606060606060606060606060606 >> 4 &\\n            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) * 39);\\n    }\\n\\n    function addressToString(address data) internal pure returns (string memory) {\\n        return string(abi.encodePacked(\\\"0x\\\", bytes20(toHex16 (bytes16(bytes20(data)))), bytes20(toHex16(bytes16(bytes20(data) << 4 * 8)) << 12 * 8)));\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/IBank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\nabstract contract IBank {\\n    function whitelistToken(address token, string calldata denom, bool transferFromNoBoolReturn) external {}\\n    function transferFrom(address from, address to, string calldata id, uint256 amount) external {}\\n    function queryTokenContractFromDenom(string calldata id) external view returns (address) {}\\n\\n     bytes32 constant ICS_BANK_STORAGE_POSITION = keccak256(\\\"ibc.ics20_bank\\\");\\n\\n    struct Token {\\n        address tokenContract;\\n        // IERC20.transferFrom doesn't return a bool, so we need to check the balance before and after\\n        bool transferFromNoBoolReturn;\\n    }\\n// 999995999991\\n//\\n\\n    struct Ics20BankStorage {\\n        // Native token denom\\n        string _nativeTokenDenom;\\n\\n        /**\\n         * White-lists of ERC-20 IBC tokens\\n         */\\n        mapping(string => Token) _denomToTokenContract;\\n        mapping(address => string) _tokenContractToDenom;\\n        bool _initialized;\\n    }\\n\\n    function icsBankStorage() internal pure returns (Ics20BankStorage storage ds) {\\n        bytes32 position = ICS_BANK_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function sendTransfer(\\n        string calldata denom,\\n        uint256 amount,\\n        string calldata receiver,\\n        string calldata sourcePort,\\n        string calldata sourceChannel,\\n        uint64 timeoutHeight,\\n        uint64 timeoutTimestamp,\\n        string calldata memo\\n    ) external payable {}\\n}\"\r\n    },\r\n    \"contracts/utils/RolesSimple.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\nabstract contract RolesSimple is Context {\\n    mapping (bytes32 => address) private _roles;\\n\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n\\n    event RoleTransferred(bytes32 indexed role, address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner role.\\n     */\\n    constructor() {\\n        _transferRole(OWNER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the given role.\\n     */\\n    modifier onlyRole(bytes32 id) {\\n        _checkRole(id);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the role.\\n     */\\n    function role(bytes32 id) public view virtual returns (address) {\\n        return _roles[id];\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkRole(bytes32 id) internal view virtual {\\n        require(role(id) == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without role. It will not be possible to call\\n     * `onlyRole` functions. Can only be called by the current role.\\n     */\\n    function renounceRole(bytes32 id) public virtual onlyRole(id) {\\n        _transferRole(id, address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers the role of the contract to a new account (`newOwner`).\\n     * Can only be called by the current role owner.\\n     */\\n    function transferRole(bytes32 id, address newOwner) public virtual onlyRole(id) {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferRole(id, newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers role to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferRole(bytes32 id, address newOwner) internal virtual {\\n        address oldOwner = _roles[id];\\n        _roles[id] = newOwner;\\n        emit RoleTransferred(id, oldOwner, newOwner);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/utils/SecureMultiWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ncontract SecureMultiWallet {\\n    event FundsDeposited(address indexed depositor, uint amount, uint newBalance);\\n    event TransactionSubmitted(\\n        address indexed initiator,\\n        uint indexed txID,\\n        address indexed target,\\n        uint amount,\\n        bytes payload\\n    );\\n    event TransactionConfirmed(address indexed approver, uint indexed txID);\\n    event ConfirmationRevoked(address indexed approver, uint indexed txID);\\n    event TransactionExecuted(address indexed executor, uint indexed txID);\\n\\n    address[] public authorizedUsers;\\n    mapping(address => bool) public isAuthorized;\\n    uint public requiredApprovals;\\n\\n    struct PendingTransaction {\\n        address target;\\n        uint amount;\\n        bytes payload;\\n        bool hasBeenExecuted;\\n        uint approvalCount;\\n    }\\n\\n    // mapping from tx ID => approver => bool\\n    mapping(uint => mapping(address => bool)) public hasConfirmed;\\n\\n    PendingTransaction[] public pendingTransactions;\\n\\n    modifier onlyAuthorized() {\\n        require(isAuthorized[msg.sender], \\\"Unauthorized\\\");\\n        _;\\n    }\\n\\n    modifier transactionExists(uint _txID) {\\n        require(_txID < pendingTransactions.length, \\\"Transaction not found\\\");\\n        _;\\n    }\\n\\n    modifier notYetExecuted(uint _txID) {\\n        require(!pendingTransactions[_txID].hasBeenExecuted, \\\"Transaction already executed\\\");\\n        _;\\n    }\\n\\n    modifier notYetConfirmed(uint _txID) {\\n        require(!hasConfirmed[_txID][msg.sender], \\\"Transaction already approved\\\");\\n        _;\\n    }\\n\\n    constructor(address[] memory _users, uint _requiredApprovals) {\\n        require(_users.length > 0, \\\"Users required\\\");\\n        require(\\n            _requiredApprovals > 0 &&\\n                _requiredApprovals <= _users.length,\\n            \\\"Invalid approval count\\\"\\n        );\\n\\n        for (uint i = 0; i < _users.length; i++) {\\n            address user = _users[i];\\n\\n            require(user != address(0), \\\"Invalid user\\\");\\n            require(!isAuthorized[user], \\\"Duplicate user\\\");\\n\\n            isAuthorized[user] = true;\\n            authorizedUsers.push(user);\\n        }\\n\\n        requiredApprovals = _requiredApprovals;\\n    }\\n\\n    receive() external payable {\\n        emit FundsDeposited(msg.sender, msg.value, address(this).balance);\\n    }\\n\\n    function addTransaction(\\n        address _target,\\n        uint _amount,\\n        bytes memory _payload\\n    ) public onlyAuthorized {\\n        uint txID = pendingTransactions.length;\\n\\n        pendingTransactions.push(\\n            PendingTransaction({\\n                target: _target,\\n                amount: _amount,\\n                payload: _payload,\\n                hasBeenExecuted: false,\\n                approvalCount: 0\\n            })\\n        );\\n\\n        emit TransactionSubmitted(msg.sender, txID, _target, _amount, _payload);\\n    }\\n\\n    function approveTransaction(\\n        uint _txID\\n    ) public onlyAuthorized transactionExists(_txID) notYetExecuted(_txID) notYetConfirmed(_txID) {\\n        PendingTransaction storage pendingTx = pendingTransactions[_txID];\\n        pendingTx.approvalCount += 1;\\n        hasConfirmed[_txID][msg.sender] = true;\\n\\n        emit TransactionConfirmed(msg.sender, _txID);\\n    }\\n\\n    function runTransaction(\\n        uint _txID\\n    ) public onlyAuthorized transactionExists(_txID) notYetExecuted(_txID) {\\n        PendingTransaction storage pendingTx = pendingTransactions[_txID];\\n\\n        require(\\n            pendingTx.approvalCount >= requiredApprovals,\\n            \\\"Insufficient approvals\\\"\\n        );\\n\\n        pendingTx.hasBeenExecuted = true;\\n\\n        (bool success, ) = pendingTx.target.call{value: pendingTx.amount}(\\n            pendingTx.payload\\n        );\\n        require(success, \\\"Transaction execution failed\\\");\\n\\n        emit TransactionExecuted(msg.sender, _txID);\\n    }\\n\\n    function retractApproval(\\n        uint _txID\\n    ) public onlyAuthorized transactionExists(_txID) notYetExecuted(_txID) {\\n        PendingTransaction storage pendingTx = pendingTransactions[_txID];\\n\\n        require(hasConfirmed[_txID][msg.sender], \\\"No prior approval found\\\");\\n\\n        pendingTx.approvalCount -= 1;\\n        hasConfirmed[_txID][msg.sender] = false;\\n\\n        emit ConfirmationRevoked(msg.sender, _txID);\\n    }\\n\\n    function listUsers() public view returns (address[] memory) {\\n        return authorizedUsers;\\n    }\\n\\n    function countTransactions() public view returns (uint) {\\n        return pendingTransactions.length;\\n    }\\n\\n    function fetchTransaction(\\n        uint _txID\\n    )\\n        public\\n        view\\n        returns (\\n            address target,\\n            uint amount,\\n            bytes memory payload,\\n            bool hasBeenExecuted,\\n            uint approvalCount\\n        )\\n    {\\n        PendingTransaction storage pendingTx = pendingTransactions[_txID];\\n\\n        return (\\n            pendingTx.target,\\n            pendingTx.amount,\\n            pendingTx.payload,\\n            pendingTx.hasBeenExecuted,\\n            pendingTx.approvalCount\\n        );\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solidity-rlp/=node_modules/solidity-rlp/\",\r\n      \"solidity-mpt/=node_modules/solidity-mpt/\",\r\n      \"solidity-stringutils/=node_modules/solidity-stringutils/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 256,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_requiredApprovals\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"ConfirmationRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"TransactionConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"TransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"TransactionSubmitted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"addTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txID\",\"type\":\"uint256\"}],\"name\":\"approveTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorizedUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txID\",\"type\":\"uint256\"}],\"name\":\"fetchTransaction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasBeenExecuted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"approvalCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasBeenExecuted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"approvalCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredApprovals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txID\",\"type\":\"uint256\"}],\"name\":\"retractApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txID\",\"type\":\"uint256\"}],\"name\":\"runTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SecureMultiWallet", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "256", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000fa446e45a4fa68a3032ec7bc1ccaea5630055a47000000000000000000000000f25aaffe769258449261aa651cbe030b3d53cfc70000000000000000000000003294a7f1664e9c6b2caf173d603245c49d65ce38", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1380d67cdc21ccb8c507cb6b2f9e3cebab94625ea631118f8286ecf95d3e3e40"}