{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\n// Part: IDiamondCut\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {\r\n        Add,\r\n        Replace,\r\n        Remove\r\n    }\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\n// Part: LibDiamond\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION =\r\n \r\n       keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        mapping(bytes4 => bytes32) facets;\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        uint16 selectorCount;\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        address contractOwner;\r\n        mapping(address => bool) isOwner;\r\n    }\r\n\r\n    function \r\ndiamondStorage()\r\n        internal\r\n        pure\r\n        returns (DiamondStorage storage ds)\r\n    {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n       \r\n     ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(\r\n            msg.sender == diamondStorage().contractOwner,\r\n            \"Must be contract owner\"\r\n        );\r\n    }\r\n\r\n    event DiamondCut(\r\n        IDiamondCut.FacetCut[] _diamondCut,\r\n        address _init,\r\n        bytes _calldata\r\n    );\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK =\r\n        bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        if (selectorCount & 7 > 0) {\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (\r\n            uint256 facetIndex;\r\n       \r\n     facetIndex < _diamondCut.length;\r\n            facetIndex++\r\n        ) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        if (selectorCount & 7 > 0) {\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"Add facet has no code\");\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n  \r\n              bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(\r\n                    address(bytes20(oldFacet)) == address(0),\r\n                    \"Can't add function that already exists\"\r\n                );\r\n                ds.facets[selector] =\r\n                    bytes20(_newFacetAddress) |\r\n                    bytes32(_selectorCount);\r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                _selectorSlot =\r\n\r\n     (_selectorSlot &\r\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n\r\n if (selectorInSlotPosition == 224) {\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n\r\n       _selectorCount++;\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(\r\n                _newFacetAddress,\r\n \r\n               \"Replace facet has no code\"\r\n            );\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n\r\n      selectorIndex++\r\n            ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address \r\noldFacetAddress = address(bytes20(oldFacet));\r\n                require(\r\n                    oldFacetAddress != address(this),\r\n                    \"Can't replace immutable function\"\r\n                );\r\n                require(\r\n                    oldFacetAddress != _newFacetAddress,\r\n                    \"Can't replace function with same function\"\r\n\r\n       );\r\n                require(\r\n                    oldFacetAddress != address(0),\r\n                    \"Can't replace function that doesn't exist\"\r\n                );\r\n       \r\n         ds.facets[selector] =\r\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                    bytes20(_newFacetAddress);\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(\r\n                _newFacetAddress == address(0),\r\n                \"Remove facet address must be address(0)\"\r\n            );\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n                if (_selectorSlot == 0) {\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n\r\n  {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(\r\n\r\n   address(bytes20(oldFacet)) != address(0),\r\n                        \"Can't remove function that doesn't exist\"\r\n                    );\r\n                    require(\r\n\r\n           address(bytes20(oldFacet)) != address(this),\r\n                        \"Can't remove immutable function\"\r\n                    );\r\n                    lastSelector = bytes4(\r\n                        _selectorSlot << (selectorInSlotIndex << 5)\r\n                    );\r\n                    if (lastSelector != selector) {\r\n                        ds.facets[lastSelector] =\r\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                            bytes20(ds.facets[lastSelector]);\r\n                    }\r\n\r\n   delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n        \r\n            oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\r\n                        oldSelectorsSlotCount\r\n                    ];\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    _selectorSlot =\r\n\r\n      (_selectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n\r\n       _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata)\r\n        internal\r\n    {\r\n        if (_init == address(0)) {\r\n            require(\r\n                _calldata.length == 0,\r\n                \"_init is address(0) but_calldata is not empty\"\r\n\r\n );\r\n        } else {\r\n            require(\r\n                _calldata.length > 0,\r\n                \"_calldata is empty but _init is not address(0)\"\r\n            );\r\n            if \r\n(_init != address(this)) {\r\n                enforceHasContractCode(_init, \"_init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"_init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(\r\n        address _contract,\r\n        string memory _errorMessage\r\n    ) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n\r\n// File: Diamond.sol\r\n\r\ncontract Diamond {\r\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\r\n        LibDiamond.setContractOwner(_contractOwner);\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\r\n        bytes4[] memory functionSelectors = new bytes4[](1);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondCutFacet,\r\n            action: IDiamondCut.FacetCutAction.Add,\r\n      \r\n      functionSelectors: functionSelectors\r\n        });\r\n        LibDiamond.diamondCut(cut, address(0), \"\");\r\n    }\r\n\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n     \r\n       let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 {\r\n        \r\n        revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003524eedc4109b053f01c30ff6d3d7c7c87d1377d0000000000000000000000004e8f5869b20ab504205b0dfaed170d9fdc4feed2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x59495e94aa7b503527683cd9f756e362652c2086", "SwarmSource": "ipfs://3f9da6728b2e0431b7e5adfc4d2db8d1349a01c1bf52fa4e6b3db1f28e92ba98"}