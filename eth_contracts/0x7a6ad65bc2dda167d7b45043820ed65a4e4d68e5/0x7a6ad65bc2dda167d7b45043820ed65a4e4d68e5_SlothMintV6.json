{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SlothMintV6.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./interfaces/ISloth.sol\\\";\\nimport \\\"./interfaces/ISlothItemV2.sol\\\";\\nimport \\\"./interfaces/ISpecialSlothItem.sol\\\";\\nimport \\\"./interfaces/ISlothMintV2.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ncontract SlothMintV6 is Ownable, ISlothMintV2 {\\n  address private _slothAddr;\\n  address private _slothItemAddr;\\n  address private _specialSlothItemAddr;\\n  address private _piementAddress;\\n  bool public publicSale;\\n  mapping(uint256 => bool) public forSaleCollabo;\\n  mapping(uint256 => uint256) public collaboSaleEndTimes;\\n  mapping(uint256 => uint256) public collaboSalePricePatterns;\\n\\n  uint256 public immutable maxPerAddressDuringMint;\\n  uint256 public immutable collectionSize;\\n  uint256 public immutable itemCollectionSize;\\n  uint256 public immutable clothesSize;\\n  uint256 public immutable itemSize;\\n  uint256 public currentItemCount;\\n  uint256 public currentClothesCount;\\n  mapping(uint256 => uint256) public collaboItemSizes;\\n  mapping(uint256 => uint256) public currentCollaboItemCounts;\\n\\n  uint256 private constant _MINT_WITH_CLOTHES_PRICE = 0.021 ether;\\n  uint256 private constant _MINT_WITH_COLLABO_PRICE = 0.03 ether;\\n  uint256 private constant _MINT_WITH_COLLABO_PRICE2 = 0.04 ether;\\n  uint256 private constant _MINT_COLLABO_PRICE = 0.01 ether;\\n  uint256 private constant _MINT_COLLABO_PRICE2 = 0.02 ether;\\n  address private _treasuryAddress = 0x452Ccc6d4a818D461e20837B417227aB70C72B56;\\n\\n  constructor(uint256 newMaxPerAddressDuringMint, uint256 newCollectionSize, uint256 newItemCollectionSize, uint256 newClothesSize, uint256 newItemSize, uint256 newCurrentClothesCount, uint256 newCurrentItemCount) {\\n    maxPerAddressDuringMint = newMaxPerAddressDuringMint;\\n    collectionSize = newCollectionSize;\\n    itemCollectionSize = newItemCollectionSize;\\n    clothesSize = newClothesSize;\\n    itemSize = newItemSize;\\n    currentClothesCount = newCurrentClothesCount;\\n    currentItemCount = newCurrentItemCount;\\n  }\\n\\n  function setSlothAddr(address newSlothAddr) external onlyOwner {\\n    _slothAddr = newSlothAddr;\\n  }\\n  function setSlothItemAddr(address newSlothItemAddr) external onlyOwner {\\n    _slothItemAddr = newSlothItemAddr;\\n  }\\n  function setSpecialSlothItemAddr(address newSpecialSlothItemAddr) external onlyOwner {\\n    _specialSlothItemAddr = newSpecialSlothItemAddr;\\n  }\\n  function setPiementAddress(address newPiementAddress) external onlyOwner {\\n    _piementAddress = newPiementAddress;\\n  }\\n\\n  function _itemMint(uint256 quantity, address to) private {\\n    require(currentItemCount + quantity <= itemSize, \\\"exceeds item size\\\");\\n\\n    ISlothItemV2(_slothItemAddr).itemMint(to, quantity);\\n    currentItemCount += quantity;\\n  }\\n\\n  function publicMintWithClothes(uint8 quantity) payable external {\\n    require(msg.value == _MINT_WITH_CLOTHES_PRICE * quantity, \\\"wrong price\\\");\\n    require(ISloth(_slothAddr).numberMinted(msg.sender) + quantity <= maxPerAddressDuringMint, \\\"wrong num\\\");\\n\\n    _publicMint(quantity, msg.sender);\\n    emit mintWithCloth(quantity);\\n  }\\n\\n  function _publicMint(uint8 quantity, address to) private {\\n    require(publicSale, \\\"inactive\\\");\\n    require(ISloth(_slothAddr).totalSupply() + quantity <= collectionSize, \\\"exceeds collection size\\\");\\n    require(currentClothesCount + quantity <= clothesSize, \\\"exceeds clothes size\\\");\\n\\n    ISloth(_slothAddr).mint(to, quantity);\\n    ISlothItemV2(_slothItemAddr).clothesMint(to, quantity);\\n    currentClothesCount += quantity;\\n  }\\n\\n  function publicMintWithClothesAndItem(uint8 quantity, uint8 itemQuantity) payable external {\\n    require(msg.value == itemPrice(itemQuantity) + _MINT_WITH_CLOTHES_PRICE * quantity, \\\"wrong price\\\");\\n    require(ISlothItemV2(_slothItemAddr).totalSupply() + (quantity + itemQuantity) <= itemCollectionSize, \\\"exceeds item collection size\\\");\\n    require(ISloth(_slothAddr).numberMinted(msg.sender) + quantity <= maxPerAddressDuringMint, \\\"wrong num\\\");\\n    require(ISlothItemV2(_slothItemAddr).getItemMintCount(msg.sender) + itemQuantity <= 99, \\\"wrong item num\\\");\\n\\n    _publicMint(quantity, msg.sender);\\n    _itemMint(itemQuantity, msg.sender);\\n    emit mintWithClothAndItem(quantity, itemQuantity, false);\\n  }\\n\\n  function publicItemMint(uint8 quantity) payable external {\\n    require(publicSale, \\\"inactive\\\");\\n    require(msg.value == itemPrice(quantity), \\\"wrong price\\\");\\n    require(ISlothItemV2(_slothItemAddr).totalSupply() + quantity <= itemCollectionSize, \\\"exceeds item collection size\\\");\\n    require(ISlothItemV2(_slothItemAddr).getItemMintCount(msg.sender) + quantity <= 99, \\\"wrong item num\\\");\\n\\n    _itemMint(quantity, msg.sender);\\n    emit mintItem(quantity);\\n  }\\n\\n  function mintForPiement(address transferAddress, uint256 itemQuantity) payable public {\\n    uint8 quantity = 1;\\n    require(msg.value == itemPrice(itemQuantity) + _MINT_WITH_CLOTHES_PRICE * quantity, \\\"wrong price\\\");\\n    require(ISlothItemV2(_slothItemAddr).totalSupply() + (quantity + itemQuantity) <= itemCollectionSize, \\\"exceeds item collection size\\\");\\n    if (msg.sender == owner()) {\\n      _publicMint(quantity, transferAddress);\\n      _itemMint(itemQuantity, transferAddress);\\n      return;\\n    }\\n    require(msg.sender == _piementAddress, \\\"worng address\\\");\\n\\n    _publicMint(quantity, transferAddress);\\n    _itemMint(itemQuantity, transferAddress);\\n  }\\n  function mintForPiementItem1(address transferAddress) payable public {\\n    mintForPiement(transferAddress, 1);\\n    emit mintWithClothAndItem(1, 1, true);\\n  }\\n  function mintForPiementItem3(address transferAddress) payable public {\\n    mintForPiement(transferAddress, 3);\\n    emit mintWithClothAndItem(1, 3, true);\\n  }\\n  function mintForPiementItem6(address transferAddress) payable public {\\n    mintForPiement(transferAddress, 6);\\n    emit mintWithClothAndItem(1, 6, true);\\n  }\\n  function mintForPiementItem9(address transferAddress) payable public {\\n    mintForPiement(transferAddress, 9);\\n    emit mintWithClothAndItem(1, 9, true);\\n  }\\n\\n  function _isSaleEnded(uint256 specialType) internal view returns (bool) {\\n    if (collaboSaleEndTimes[specialType] == 0) {\\n      return false;\\n    }\\n    return block.timestamp >= collaboSaleEndTimes[specialType];\\n  }\\n\\n  function checkAllowCollaboMint(uint8 quantity, uint256 specialType) internal view {\\n    require(forSaleCollabo[specialType], \\\"inactive collabo\\\");\\n    require(!_isSaleEnded(specialType), \\\"ended\\\");\\n    require(currentCollaboItemCounts[specialType] + quantity <= collaboItemSizes[specialType], \\\"collabo sold out\\\");\\n  }\\n\\n  function collaboMintValue(uint8 quantity, uint256 specialType) internal view returns (uint256) {\\n    if (collaboSalePricePatterns[specialType] == 1) {\\n      return _MINT_COLLABO_PRICE2 * quantity;\\n    }\\n    return _MINT_COLLABO_PRICE * quantity;\\n  }\\n\\n  function withCollaboMintValue(uint8 quantity, uint256 specialType) internal view returns (uint256) {\\n    if (collaboSalePricePatterns[specialType] == 1) {\\n      return _MINT_WITH_COLLABO_PRICE2 * quantity;\\n    }\\n    return _MINT_WITH_COLLABO_PRICE * quantity;\\n  }\\n\\n  function mintCollaboWithBody(uint8 quantity, uint256 specialType) internal {\\n    checkAllowCollaboMint(quantity, specialType);\\n    require(ISlothItemV2(_slothItemAddr).totalSupply() + quantity <= itemCollectionSize, \\\"exceeds item collection size\\\");\\n    require(msg.value ==  withCollaboMintValue(quantity, specialType), \\\"wrong price\\\");\\n\\n    _publicMint(quantity, msg.sender);\\n    ISpecialSlothItem(_specialSlothItemAddr).mintCollaboCloth(msg.sender, quantity, specialType);\\n    currentCollaboItemCounts[specialType] += quantity;\\n  }\\n\\n  function mintCollaboCloth(uint8 quantity, uint256 specialType) internal {\\n    checkAllowCollaboMint(quantity, specialType);\\n    require(msg.value ==  collaboMintValue(quantity, specialType), \\\"wrong price\\\");\\n    require(ISloth(_slothAddr).balanceOf(msg.sender) > 0, \\\"need sloth\\\");\\n    ISpecialSlothItem(_specialSlothItemAddr).mintCollaboCloth(msg.sender, quantity, specialType);\\n    currentCollaboItemCounts[specialType] += quantity;\\n  }\\n\\n  function publicMintWithClothesAndCollaboForPiement(address transferAddress, uint256 specialType) payable external {\\n    checkAllowCollaboMint(1, specialType);\\n    require(ISlothItemV2(_slothItemAddr).totalSupply() + 1 <= itemCollectionSize, \\\"exceeds item collection size\\\");\\n    require(currentClothesCount + 1 <= clothesSize, \\\"exceeds clothes size\\\");\\n    require(msg.value ==  withCollaboMintValue(1, specialType), \\\"wrong price\\\");\\n    if (msg.sender == owner()) {\\n      _publicMint(1, transferAddress);\\n      ISpecialSlothItem(_specialSlothItemAddr).mintCollaboCloth(transferAddress, 1, specialType);\\n      currentCollaboItemCounts[specialType] += 1;\\n      return;\\n    }\\n    require(msg.sender == _piementAddress, \\\"worng address\\\");\\n    _publicMint(1, transferAddress);\\n    ISpecialSlothItem(_specialSlothItemAddr).mintCollaboCloth(transferAddress, 1, specialType);\\n    currentCollaboItemCounts[specialType] += 1;\\n    emit mintWithClothAndCollabo(1, specialType, true);\\n  }\\n\\n  function publicMintWithClothesAndVerylongAnimals(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 3);\\n    emit mintWithClothAndCollabo(quantity, 3, false);\\n  }\\n  function pulicMintOnlyVerylongAnimals(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 3);\\n    emit mintCollabo(quantity, 3);\\n  }\\n\\n  function publicMintWithClothesAndTakanotsumedan(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 4);\\n    emit mintWithClothAndCollabo(quantity, 4, false);\\n  }\\n  function pulicMintOnlyTakanotsumedan(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 4);\\n    emit mintCollabo(quantity, 4);\\n  }\\n\\n  function publicMintWithClothesAndMocomocoworkers(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 5);\\n    emit mintWithClothAndCollabo(quantity, 5, false);\\n  }\\n  function pulicMintOnlyMocomocoworkers(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 5);\\n    emit mintCollabo(quantity, 5);\\n  }\\n\\n  function publicMintWithClothesAndTorichan(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 6);\\n    emit mintWithClothAndCollabo(quantity, 6, false);\\n  }\\n  function pulicMintOnlyTorichan(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 6);\\n    emit mintCollabo(quantity, 6);\\n  }\\n\\n  function publicMintWithClothesAndGyozao(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 7);\\n    emit mintWithClothAndCollabo(quantity, 7, false);\\n  }\\n  function pulicMintOnlyGyozao(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 7);\\n    emit mintCollabo(quantity, 7);\\n  }\\n\\n  function publicMintWithClothesAndAstroOtto(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 8);\\n    emit mintWithClothAndCollabo(quantity, 8, false);\\n  }\\n  function pulicMintOnlyAstroOtto(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 8);\\n    emit mintCollabo(quantity, 8);\\n  }\\n\\n  function publicMintWithClothesAndYoshioka(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 9);\\n    emit mintWithClothAndCollabo(quantity, 9, false);\\n  }\\n  function pulicMintOnlyYoshioka(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 9);\\n    emit mintCollabo(quantity, 9);\\n  }\\n\\n  function publicMintWithClothesAndDJRIO(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 10);\\n    emit mintWithClothAndCollabo(quantity, 10, false);\\n  }\\n  function pulicMintOnlyDJRIO(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 10);\\n    emit mintCollabo(quantity, 10);\\n  }\\n\\n  function publicMintWithClothesAndShimonzgate(uint8 quantity) payable external {\\n    mintCollaboWithBody(quantity, 11);\\n    emit mintWithClothAndCollabo(quantity, 11, false);\\n  }\\n  function pulicMintOnlyShimonzgate(uint8 quantity) payable external {\\n    mintCollaboCloth(quantity, 11);\\n    emit mintCollabo(quantity, 11);\\n  }\\n\\n  function setPublicSale(bool newPublicSale) external onlyOwner {\\n    publicSale = newPublicSale;\\n  }\\n  function setSaleCollabo(uint256[] calldata specialTypeArray, bool[] calldata newSaleCollaboArray) external onlyOwner {\\n    for (uint256 i = 0; i < specialTypeArray.length; i++) {\\n      forSaleCollabo[specialTypeArray[i]] = newSaleCollaboArray[i];\\n    }\\n  }\\n  function setCollaboItemSizes(uint256[] calldata specialTypeArray, uint256[] calldata itemSizeArray) external onlyOwner {\\n    for (uint256 i = 0; i < specialTypeArray.length; i++) {\\n      collaboItemSizes[specialTypeArray[i]] = itemSizeArray[i];\\n    }\\n  }\\n  function setCollaboSaleEndTimes(uint256[] calldata specialTypeArray, uint256[] calldata endTimeArray) external onlyOwner {\\n    for (uint256 i = 0; i < specialTypeArray.length; i++) {\\n      collaboSaleEndTimes[specialTypeArray[i]] = endTimeArray[i];\\n    }\\n  }\\n  function setCollaboSalePricePatterns(uint256[] calldata specialTypeArray, uint256[] calldata pricePatternArray) external onlyOwner {\\n    for (uint256 i = 0; i < specialTypeArray.length; i++) {\\n      collaboSalePricePatterns[specialTypeArray[i]] = pricePatternArray[i];\\n    }\\n  }\\n \\n  function itemPrice(uint256 quantity) internal pure returns(uint256) {\\n    uint256 price = 0;\\n    if (quantity == 1) {\\n      price = 20;\\n    } else if (quantity == 2) {\\n      price = 39;\\n    } else if (quantity == 3) {\\n      price = 56;\\n    } else if (quantity == 4) {\\n      price = 72;\\n    } else if (quantity == 5) {\\n      price = 88;\\n    } else if (quantity == 6) {\\n      price = 100;\\n    } else if (quantity == 7) {\\n      price = 115 ;\\n    } else if (quantity == 8) {\\n      price = 125 ;\\n    } else if (quantity == 9) {\\n      price = 135;\\n    } else {\\n      price = 15 * quantity;\\n    }\\n    return price * 1 ether / 1000;\\n  }\\n\\n  function withdraw() external onlyOwner {\\n    (bool sent,) = _treasuryAddress.call{value: address(this).balance}(\\\"\\\");\\n    require(sent, \\\"Failed to send Ether\\\");\\n  }\\n\\n  function ownerMint(uint8 quantity, uint256 itemQuantity) external onlyOwner {\\n    require(ISlothItemV2(_slothItemAddr).totalSupply() + (quantity + itemQuantity) <= itemCollectionSize, \\\"exceeds item collection size\\\");\\n\\n    if (quantity > 0) {\\n      _publicMint(quantity, msg.sender);\\n    }\\n    if (itemQuantity > 0) {\\n      _itemMint(itemQuantity, msg.sender);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISloth.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\n\\ninterface ISloth is IERC721AQueryableUpgradeable {\\n  function mint(address sender, uint8 quantity) external;\\n  function numberMinted(address sender) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISpecialSlothItem.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./IItemType.sol\\\";\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\n\\ninterface ISpecialSlothItem is IERC721AQueryableUpgradeable, IItemType {\\n  function getItemType(uint256 tokenId) external view returns (ItemType);\\n  function getSpecialType(uint256 tokenId) external view returns (uint256);\\n  function getClothType(uint256 tokenId) external view returns (uint256);\\n  function exists(uint256 tokenId) external view returns (bool);\\n  function isCombinational(uint256 _specialType) external view returns (bool);\\n  function mintPoupelle(address sender, uint256 quantity) external;\\n  function mintCollaboCloth(address sender, uint256 quantity, uint256 _specialType) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISlothItemV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\n\\ninterface ISlothItemV2 is IERC721AQueryableUpgradeable {\\n  enum ItemType { CLOTHES, HEAD, HAND, FOOT, STAMP }\\n\\n  function getItemType(uint256 tokenId) external view returns (ItemType);\\n  function getItemMintCount(address sender) external view returns (uint256);\\n  function exists(uint256 tokenId) external view returns (bool);\\n  function clothesMint(address sender, uint256 quantity) external;\\n  function itemMint(address sender, uint256 quantity) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISlothMintV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title Interface for Auction Houses\\n */\\ninterface ISlothMintV2 {\\n  event mintWithCloth(\\n    uint256 quantity\\n  );\\n  event mintWithClothAndItem(\\n    uint256 quantity,\\n    uint256 itemQuantity,\\n    bool piement\\n  );\\n  event mintWithClothAndPoupelle(\\n    uint256 quantity,\\n    bool piement\\n  );\\n  event mintPoupelle(\\n    uint256 quantity\\n  );\\n  event mintItem(\\n    uint256 quantity\\n  );\\n  event mintWithClothAndCollabo(\\n    uint256 quantity,\\n    uint256 specialType,\\n    bool piement\\n  );\\n  event mintCollabo(\\n    uint256 quantity,\\n    uint256 specialType\\n  );\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.2\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../extensions/IERC721AQueryableUpgradeable.sol';\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/extensions/IERC721AQueryableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.2\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721AUpgradeable.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryableUpgradeable is IERC721AUpgradeable {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/IERC721AUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.2\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721AUpgradeable {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * The caller cannot approve to their own address.\\n     */\\n    error ApproveToCaller();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IItemType.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IItemType {\\n  enum ItemType { CLOTHES, HEAD, HAND, FOOT, STAMP }\\n  enum ItemMintType { SLOTH_ITEM, SPECIAL_SLOTH_ITEM, USER_GENERATED_SLOTH_ITEM }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxPerAddressDuringMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCollectionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newItemCollectionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newClothesSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newItemSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCurrentClothesCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCurrentItemCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"specialType\",\"type\":\"uint256\"}],\"name\":\"mintCollabo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintPoupelle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintWithCloth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"specialType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"piement\",\"type\":\"bool\"}],\"name\":\"mintWithClothAndCollabo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"piement\",\"type\":\"bool\"}],\"name\":\"mintWithClothAndItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"piement\",\"type\":\"bool\"}],\"name\":\"mintWithClothAndPoupelle\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"clothesSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collaboItemSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collaboSaleEndTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collaboSalePricePatterns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentClothesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentCollaboItemCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentItemCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forSaleCollabo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemCollectionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPerAddressDuringMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemQuantity\",\"type\":\"uint256\"}],\"name\":\"mintForPiement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferAddress\",\"type\":\"address\"}],\"name\":\"mintForPiementItem1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferAddress\",\"type\":\"address\"}],\"name\":\"mintForPiementItem3\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferAddress\",\"type\":\"address\"}],\"name\":\"mintForPiementItem6\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferAddress\",\"type\":\"address\"}],\"name\":\"mintForPiementItem9\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"itemQuantity\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicItemMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothes\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndAstroOtto\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"specialType\",\"type\":\"uint256\"}],\"name\":\"publicMintWithClothesAndCollaboForPiement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndDJRIO\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndGyozao\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"itemQuantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndMocomocoworkers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndShimonzgate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndTakanotsumedan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndTorichan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndVerylongAnimals\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"publicMintWithClothesAndYoshioka\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyAstroOtto\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyDJRIO\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyGyozao\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyMocomocoworkers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyShimonzgate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyTakanotsumedan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyTorichan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyVerylongAnimals\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"pulicMintOnlyYoshioka\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"specialTypeArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"itemSizeArray\",\"type\":\"uint256[]\"}],\"name\":\"setCollaboItemSizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"specialTypeArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"endTimeArray\",\"type\":\"uint256[]\"}],\"name\":\"setCollaboSaleEndTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"specialTypeArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"pricePatternArray\",\"type\":\"uint256[]\"}],\"name\":\"setCollaboSalePricePatterns\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPiementAddress\",\"type\":\"address\"}],\"name\":\"setPiementAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newPublicSale\",\"type\":\"bool\"}],\"name\":\"setPublicSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"specialTypeArray\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"newSaleCollaboArray\",\"type\":\"bool[]\"}],\"name\":\"setSaleCollabo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSlothAddr\",\"type\":\"address\"}],\"name\":\"setSlothAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSlothItemAddr\",\"type\":\"address\"}],\"name\":\"setSlothItemAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSpecialSlothItemAddr\",\"type\":\"address\"}],\"name\":\"setSpecialSlothItemAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SlothMintV6", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000138800000000000000000000000000000000000000000000000000000000000084d00000000000000000000000000000000000000000000000000000000000001388000000000000000000000000000000000000000000000000000000000000232800000000000000000000000000000000000000000000000000000000000008cd000000000000000000000000000000000000000000000000000000000000116f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}