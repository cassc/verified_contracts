{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC721 is IERC165 {\\n   \\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    \\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\\ncontract TransferManager {\\n\\n    address public admin;\\n    address public signer;\\n    address payable public vaultWallet;\\n    string public salt = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n\\n    uint private _transferFee;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    event WithdrawItem(address indexed sender, address indexed receiver, uint256 indexed tokenId, string userId, uint nonce);\\n    \\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Not admin\\\");\\n        _;\\n    }\\n\\n    modifier onlySigner() {\\n        require(msg.sender == signer, \\\"Not signer\\\");\\n        _;\\n    }\\n\\n    constructor(address _signer, address payable _vaultWallet) {\\n        admin = msg.sender;\\n        signer = _signer;\\n        vaultWallet = _vaultWallet;\\n    }\\n\\n    function setAdmin(address _newAdmin) external onlyAdmin {\\n        require(_newAdmin != address(0), \\\"Invalid address\\\");\\n        \\n        admin = _newAdmin;\\n    }\\n    \\n    function setSalt(string memory _salt) external onlyAdmin {\\n        salt = _salt;\\n    }\\n\\n    function setSignerAddress(address _signer) public onlyAdmin {\\n        require(_signer != address(0), \\\"Invalid address\\\");\\n        \\n        signer = _signer;\\n    }\\n\\n    function setVaultAddress(address payable _vaultWallet) public onlyAdmin {\\n        require(_vaultWallet != address(0), \\\"Invalid vault address\\\");\\n        \\n        vaultWallet = _vaultWallet;\\n    }\\n\\n    function setTransferFee() external payable onlyAdmin {\\n        _transferFee = msg.value;\\n    }\\n\\n    function getTransferFee() public view returns(uint) {\\n        return _transferFee;\\n    }\\n\\n    function getMessageHash(address _nft, address _from, address _to, string memory _userId, uint256 _tokenId, uint256 _nonce, uint256 _expired_at)\\n        public pure returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(_nft, _from, _to, _userId, _tokenId, _nonce, _expired_at));\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 _messageHash) public view returns (bytes32) {\\n        /*\\n        Signature is produced by signing a keccak256 hash with the following format:\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return keccak256(abi.encodePacked(salt, _messageHash));\\n    }\\n\\n    function verify(address _nft, address _from, address _to, string memory _userId, \\n        uint256 _tokenId, uint256 _nonce, uint256 _expired_at, bytes memory signature\\n    )\\n        public view returns (bool)\\n    {\\n        bytes32 messageHash = getMessageHash(_nft, _from, _to, _userId, _tokenId, _nonce, _expired_at);\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n\\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\\n    }\\n\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\\n        public pure returns (address)\\n    {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig)\\n        public pure returns (bytes32 r, bytes32 s, uint8 v)\\n    {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n\\n        assembly {\\n            /*\\n            First 32 bytes stores the length of the signature\\n            add(sig, 32) = pointer of sig + 32\\n            effectively, skips first 32 bytes of signature\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\n            */\\n\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // implicitly return (r, s, v)\\n    }\\n\\n    function transferItem(address _nft, address _to, string memory _userId, uint256 _tokenId, uint256 _nonce, uint256 _expired_at,\\n            bytes memory signature) public payable {\\n                \\n        require(_nonce > 0 , \\\"Invalid nonce number\\\");\\n        require(nonces[msg.sender] < _nonce , \\\"Nonce is ready use\\\");\\n        require(block.timestamp < _expired_at, \\\"Signature is expired\\\");\\n        require(verify(_nft, msg.sender, _to, _userId, _tokenId, _nonce, _expired_at, signature) == true, \\\"Invalid signature\\\");\\n\\n        require(msg.value == _transferFee, \\\"fee is not correct\\\");\\n\\n        nonces[msg.sender] = _nonce;\\n        IERC721(_nft).transferFrom(signer, _to, _tokenId);\\n\\n        if(msg.value > 0) vaultWallet.transfer(msg.value);\\n        \\n        emit WithdrawItem(msg.sender, _to, _tokenId, _userId, _nonce);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_vaultWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"userId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawItem\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expired_at\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_salt\",\"type\":\"string\"}],\"name\":\"setSalt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSignerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_vaultWallet\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expired_at\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expired_at\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TransferManager", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e8a0518eee8a9d41b31b7e6273acbb00b390040f0000000000000000000000008260c20b4ce2014d760be6de7cdd98c4f12b68f8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}