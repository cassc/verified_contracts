{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/TSAggregatorStargate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {SafeTransferLib} from \\\"../lib/SafeTransferLib.sol\\\";\\nimport {TSAggregator} from \\\"./TSAggregator.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IOracle} from \\\"./interfaces/IOracle.sol\\\";\\nimport {IStargateRouter} from \\\"./interfaces/IStargateRouter.sol\\\";\\nimport {IThorchainRouter} from \\\"./interfaces/IThorchainRouter.sol\\\";\\nimport {IUniswapRouterV2} from \\\"./interfaces/IUniswapRouterV2.sol\\\";\\n\\n// 101 1 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH) Ethereum\\n// 102 2 0x4Fabb145d64652a948d72533023f6E7A623C7C53 (BUSD) BNB (USDT)\\n// 106 1 0xfe9A29aB92522D14Fc65880d817214261D8479AE (SNOW) Avalanche\\n// 109 1 0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0 (MATIC) Polygon\\n// 110 1 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5 (cETH) Arbitrum\\n// 111 1 0x030bA81f1c18d280636F32af80b9AAd02Cf0854e (aETH) Optimism\\n// 112 1 0x4E15361FD6b4BB609Fa63C81A2be19d873717870 (FTM) Fantom\\n\\ninterface ISwapAdapter {\\n    function swap(address input, address output, uint256 amount, uint256 amountOutMin, address to, bytes calldata data)\\n        external;\\n}\\n\\ncontract TSAggregatorStargate is TSAggregator {\\n    error UnconfiguredChain();\\n    error UnconfiguredToken();\\n    error SwapCallReverted();\\n\\n    using SafeTransferLib for address;\\n\\n    struct ChainConfig {\\n        uint256 chainId;\\n        uint256 poolId;\\n        address target;\\n    }\\n\\n    struct TokenConfig {\\n        address token;\\n        address target;\\n        bytes data;\\n    }\\n\\n    uint256 private constant ACTION_SWAP = 1;\\n    uint256 private constant ACTION_DEPOSIT = 2;\\n    uint256 public constant sourcePoolId = 1;\\n    IStargateRouter public stargate;\\n    IERC20 public bridgeToken;\\n    IOracle public ethOracle;\\n    IUniswapRouterV2 public router;\\n    uint256 public slippage = 100;\\n    mapping(address => ChainConfig) public chainConfigs;\\n    mapping(uint256 => TokenConfig) public tokenConfigs;\\n\\n    event SetChainConfig(address indexed chainToken, uint256 chainId, uint256 poolId, address target);\\n    event SetTokenConfig(uint256 indexed id, address token, address target, bytes data);\\n    event SwapTo(address to, address token, uint256 amount, uint256 amountToken, uint256 fee);\\n    event SwapIn(address from, address token, uint256 amount, uint256 out, uint256 fee, address vault, string memo);\\n    event SwapOut(address to, address token, uint256 amount, uint256 fee);\\n\\n    constructor(address _stargate, address _router, address _bridgeToken, address _ethOracle)\\n        TSAggregator(address(0))\\n    {\\n        stargate = IStargateRouter(_stargate);\\n        bridgeToken = IERC20(_bridgeToken);\\n        ethOracle = IOracle(_ethOracle);\\n        router = IUniswapRouterV2(_router);\\n    }\\n\\n    function setEthOracle(address _ethOracle) external isOwner {\\n        ethOracle = IOracle(_ethOracle);\\n    }\\n\\n    function setRouter(address _router) external isOwner {\\n        router = IUniswapRouterV2(_router);\\n    }\\n\\n    function setSlippage(uint256 _slippage) external isOwner {\\n        slippage = _slippage;\\n    }\\n\\n    function setChainConfig(address chainToken, uint256 chainId, uint256 poolId, address target) external isOwner {\\n        chainConfigs[chainToken] = ChainConfig({chainId: chainId, poolId: poolId, target: target});\\n        emit SetChainConfig(chainToken, chainId, poolId, target);\\n    }\\n\\n    function setTokenConfig(uint256 id, address token, address target, bytes calldata data) external isOwner {\\n        tokenConfigs[id] = TokenConfig({token: token, target: target, data: data});\\n        emit SetTokenConfig(id, token, target, data);\\n    }\\n\\n    // Funds coming from an other chain, we either swap to ETH and deposit into TC,\\n    // or swap to final target\\n    function sgReceive(uint16 chainId, bytes memory, uint256, address bridgeToken, uint256 bridgeAmount, bytes memory payload)\\n        external\\n    {\\n        require(msg.sender == address(stargate), \\\"!stargate\\\");\\n        (uint256 action, bytes memory innerPayload) = abi.decode(payload, (uint256, bytes));\\n        if (action == ACTION_DEPOSIT) {\\n            (address tcRouter, address vault, string memory memo, address from, uint256 deadline) =\\n                abi.decode(innerPayload, (address, address, string, address, uint256));\\n            uint256 price = uint256(ethOracle.latestAnswer()) * 1e18 / ethOracle.decimals();\\n            uint256 minAmtOut = _slip(bridgeAmount) * (10 ** IERC20(bridgeToken).decimals()) / price;\\n            IERC20(bridgeToken).approve(address(router), bridgeAmount);\\n            address[] memory path = new address[](2);\\n            path[0] = bridgeToken;\\n            path[1] = router.WETH();\\n            try router.swapExactTokensForETH(bridgeAmount, minAmtOut, path, address(this), deadline) {\\n                uint256 out = address(this).balance;\\n                uint256 outMinusFee = skimFee(out);\\n                IThorchainRouter(tcRouter).depositWithExpiry{value: outMinusFee}(\\n                    payable(vault), address(0), outMinusFee, memo, deadline\\n                );\\n                //emit SwapIn(msg.sender, bridgeToken, bridgeAmount, out, out - outMinusFee, vault, memo);\\n            } catch {\\n                IERC20(bridgeToken).transfer(from, bridgeAmount);\\n            }\\n        } else if (action == ACTION_SWAP) {\\n            (uint256 tokenId, address to, uint256 amountOutMin) =\\n                abi.decode(innerPayload, (uint256, address, uint256));\\n            TokenConfig memory tokenConfig = tokenConfigs[tokenId];\\n            if (tokenConfig.target == address(0)) revert UnconfiguredToken();\\n            uint256 amountFee = getFee(bridgeAmount);\\n            if (amountFee > 0) IERC20(bridgeToken).transfer(feeRecipient, amountFee);\\n            IERC20(bridgeToken).approve(tokenConfig.target, bridgeAmount - amountFee);\\n            ISwapAdapter(tokenConfig.target).swap(\\n                bridgeToken, tokenConfig.token, bridgeAmount - amountFee, amountOutMin, to, tokenConfig.data\\n            );\\n        }\\n    }\\n\\n    // Takes ETH from a TC swap and sends it to a destination chain for the final leg\\n    // `token` is not needed (we want to avoid whitelisting) so we reuse it as \\\"target chain\\\"\\n    // `amountOutMin` is still it's normal self, but the 3 least significant digits\\n    // are used to specify the \\\"tokenId\\\" on the desitination chain (selects a \\\"TokenConfig\\\")\\n    function swapOut(address token, address to, uint256 amountOutMin) public payable nonReentrant {\\n        uint256 tokenId = amountOutMin % 100000 / 100;\\n        amountOutMin = _parseAmountOutMin(amountOutMin);\\n        ChainConfig memory chainConfig = chainConfigs[token];\\n        if (chainConfig.target == address(0)) revert UnconfiguredChain();\\n        uint256 amount = skimFee(msg.value);\\n\\n        bytes memory data = abi.encode(ACTION_SWAP, abi.encode(tokenId, to, amountOutMin));\\n        IStargateRouter.lzTxObj memory txObj = IStargateRouter.lzTxObj(500000, 0, \\\"0x\\\");\\n        (uint256 fee,) = stargate.quoteLayerZeroFee(\\n            uint16(chainConfig.chainId), uint8(chainConfig.poolId),\\n            abi.encodePacked(chainConfig.target), data, txObj\\n        );\\n\\n        {\\n            uint256 price = uint256(ethOracle.latestAnswer()) * 1e18 / ethOracle.decimals();\\n            uint256 minAmtOut = _slip(amount - fee) * (10 ** bridgeToken.decimals()) / price;\\n            address[] memory path = new address[](2);\\n            path[0] = address(router.WETH());\\n            path[1] = address(bridgeToken);\\n            router.swapExactETHForTokens{value: amount - fee}(minAmtOut, path, address(this), type(uint256).max);\\n        }\\n\\n        stargateSwap(chainConfig.chainId, sourcePoolId, chainConfig.poolId, chainConfig.target, data, to, fee);\\n    }\\n\\n    // Takes any token on current chain, swaps to bridge token and initiates a TC deposit\\n    function swapAndDeposit(\\n        uint256 targetChainId,\\n        uint256 targetPoolId,\\n        address targetContract,\\n        address token,\\n        address target,\\n        bytes calldata data,\\n        uint256 amount,\\n        bytes calldata payload\\n    ) external payable nonReentrant {\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\n        IERC20(token).approve(target, amount);\\n        {\\n            (bool success,) = target.call(data);\\n            if (!success) revert SwapCallReverted();\\n        }\\n        // payload = address tcRouter, address vault, string calldata memo, uint256 deadline\\n        bytes memory data = abi.encode(ACTION_DEPOSIT, payload);\\n        stargateSwap(targetChainId, sourcePoolId, targetPoolId, targetContract, data, msg.sender, 0);\\n    }\\n\\n    // Takes any token on current chain, swaps to bridge token and initiates a swap on the target chain\\n    function swapAndSwap(\\n        uint256 targetChainId,\\n        uint256 targetPoolId,\\n        address targetContract,\\n        address token,\\n        address target,\\n        bytes calldata data,\\n        uint256 amount,\\n        uint256 tokenId,\\n        uint256 amountOutMin\\n    ) external payable nonReentrant {\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\n        IERC20(token).approve(target, amount);\\n        {\\n            (bool success,) = target.call(data);\\n            if (!success) revert SwapCallReverted();\\n        }\\n        bytes memory data = abi.encode(ACTION_SWAP, abi.encode(tokenId, msg.sender, amountOutMin));\\n        stargateSwap(targetChainId, sourcePoolId, targetPoolId, targetContract, data, msg.sender, 0);\\n    }\\n\\n    function stargateSwap(uint256 targetChainId, uint256 sourcePoolId, uint256 targetPoolId, address targetContract, bytes memory data, address to, uint256 fee) internal {\\n        uint256 tokenAmount = bridgeToken.balanceOf(address(this));\\n        bridgeToken.approve(address(stargate), tokenAmount);\\n        IStargateRouter.lzTxObj memory txObj = IStargateRouter.lzTxObj(500000, 0, \\\"0x\\\");\\n        if (fee == 0) {\\n            (fee,) = stargate.quoteLayerZeroFee(\\n                uint16(targetChainId), uint8(targetPoolId),\\n                abi.encodePacked(targetContract), data, txObj\\n            );\\n        }\\n        stargate.swap{value: fee}(\\n            uint16(targetChainId),\\n            sourcePoolId,\\n            targetPoolId,\\n            payable(to),\\n            tokenAmount,\\n            _slip(tokenAmount),\\n            txObj,\\n            abi.encodePacked(targetContract),\\n            data\\n        );\\n        msg.sender.call{value: address(this).balance}(\\\"\\\");\\n    }\\n\\n    function getFee(uint256 targetChainId, uint256 targetPoolId) external view returns (uint256) {\\n        IStargateRouter.lzTxObj memory txObj = IStargateRouter.lzTxObj(500000, 0, \\\"0x\\\");\\n        bytes memory data = abi.encode(address(0), address(0), \\\"=:ETH.ETH:123456\\\", address(0), 123456);\\n        (uint256 fee,) = stargate.quoteLayerZeroFee(uint16(targetChainId), uint8(targetPoolId), abi.encodePacked(address(0)), data, txObj);\\n        return fee;\\n    }\\n\\n    function _slip(uint256 amount) internal view returns (uint256) {\\n        return amount * (10000 - slippage) / 10000;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/TSAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport { SafeTransferLib } from \\\"../lib/SafeTransferLib.sol\\\";\\nimport { ReentrancyGuard } from \\\"../lib/ReentrancyGuard.sol\\\";\\nimport { Owners } from \\\"./Owners.sol\\\";\\nimport { TSAggregatorTokenTransferProxy } from './TSAggregatorTokenTransferProxy.sol';\\n\\nabstract contract TSAggregator is Owners, ReentrancyGuard {\\n    using SafeTransferLib for address;\\n\\n    event FeeSet(uint256 fee, address feeRecipient);\\n\\n    uint256 public fee;\\n    address public feeRecipient;\\n    TSAggregatorTokenTransferProxy public tokenTransferProxy;\\n\\n    constructor(address _tokenTransferProxy) {\\n        _setOwner(msg.sender, true);\\n        tokenTransferProxy = TSAggregatorTokenTransferProxy(_tokenTransferProxy);\\n    }\\n\\n    // Needed for the swap router to be able to send back ETH\\n    receive() external payable {}\\n\\n    function setFee(uint256 _fee, address _feeRecipient) external isOwner {\\n        require(_fee <= 1000, \\\"fee can not be more than 10%\\\");\\n        fee = _fee;\\n        feeRecipient = _feeRecipient;\\n        emit FeeSet(_fee, _feeRecipient);\\n    }\\n\\n    function skimFee(uint256 amount) internal returns (uint256) {\\n        uint256 amountFee = getFee(amount);\\n        if (amountFee > 0) {\\n            feeRecipient.safeTransferETH(amountFee);\\n            amount -= amountFee;\\n        }\\n        return amount;\\n    }\\n\\n    function getFee(uint256 amount) internal view returns (uint256) {\\n        if (fee != 0 && feeRecipient != address(0)) {\\n            return (amount * fee) / 10000;\\n        }\\n        return 0;\\n    }\\n\\n    // Parse amountOutMin treating the last 2 digits as an exponent\\n    // So 1504 = 150000. This allows for compressed memos on chains\\n    // with limited space like Bitcoin\\n    function _parseAmountOutMin(uint256 amount) internal pure returns (uint256) {\\n      return amount / 100 * (10 ** (amount % 100));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IOracle {\\n    function latestAnswer() external view returns (int256);\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStargateRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IStargateRouter {\\n    struct lzTxObj {\\n        uint256 dstGasForCall;\\n        uint256 dstNativeAmount;\\n        bytes dstNativeAddr;\\n    }\\n\\n    function quoteLayerZeroFee(\\n        uint16 _dstChainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        lzTxObj memory _lzTxParams\\n    ) external view returns (uint256, uint256);\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IThorchainRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IThorchainRouter {\\n    function depositWithExpiry(\\n        address payable vault,\\n        address asset,\\n        uint amount,\\n        string memory memo,\\n        uint expiration\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IUniswapRouterV2 {\\n    function WETH() external view returns (address);\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Owners.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nabstract contract Owners {\\n    event OwnerSet(address indexed owner, bool active);\\n\\n    mapping(address => bool) public owners;\\n\\n    modifier isOwner() {\\n        require(owners[msg.sender], \\\"Unauthorized\\\");\\n        _;\\n    }\\n\\n    function _setOwner(address owner, bool active) internal virtual {\\n      owners[owner] = active;\\n      emit OwnerSet(owner, active);\\n    }\\n\\n    function setOwner(address owner, bool active) external virtual isOwner {\\n      _setOwner(owner, active);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/TSAggregatorTokenTransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport { SafeTransferLib } from \\\"../lib/SafeTransferLib.sol\\\";\\nimport { Owners } from \\\"./Owners.sol\\\";\\n\\ncontract TSAggregatorTokenTransferProxy is Owners {\\n    using SafeTransferLib for address;\\n\\n    constructor() {\\n        _setOwner(msg.sender, true);\\n    }\\n\\n    function transferTokens(address token, address from, address to, uint256 amount) external isOwner {\\n        require(from == tx.origin || _isContract(from), \\\"Invalid from address\\\");\\n        token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stargate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridgeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SwapCallReverted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnconfiguredChain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnconfiguredToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"FeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chainToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"SetChainConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SetTokenConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"SwapIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SwapOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SwapTo\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridgeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainConfigs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethOracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPoolId\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chainToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"setChainConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ethOracle\",\"type\":\"address\"}],\"name\":\"setEthOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"setSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bridgeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sgReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sourcePoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargate\",\"outputs\":[{\"internalType\":\"contract IStargateRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPoolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"swapAndDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPoolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"swapAndSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"swapOut\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenConfigs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTransferProxy\",\"outputs\":[{\"internalType\":\"contract TSAggregatorTokenTransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TSAggregatorStargate", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008731d54e9d02c286767d56ac03e8037c07e01e980000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}