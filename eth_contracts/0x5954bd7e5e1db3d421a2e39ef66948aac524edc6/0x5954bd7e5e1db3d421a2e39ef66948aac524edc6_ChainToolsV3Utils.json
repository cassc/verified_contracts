{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ctls/v3Utils.sol\": {\r\n      \"content\": \"/*                              \\r\\n                    CHAINTOOLS 2023. DEFI REIMAGINED\\r\\n\\r\\n                                                               2023\\r\\n\\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800            2021           \u28f0\u28fe\u28ff\u28f6\u2844\u2800\u2800\u2800\u2800\u2800\\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28002019\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800     \u2839\u28ffV4\u2844\u2877\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u28e4\u28fe\u28ff\u28f7\u28e6\u2840\u2800\u2800\u2800\u2800   \u28ff\u28ff\u284f\u2801\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800 \u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u2804\u2800\u2800\u2800  \u28f0\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u281f\u281b\u280b\u2800\u2800\u2800 \u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2809\u2809\u2809\u2801\u2880\u28f4\u28ff\u28ffV3\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800  \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2800\u2800\u2800\u2800\u2800 \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800 \u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2840\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800        2017\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ffV2\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800 \u28b9\u28ff \u28ff\u28ff\u28ff\u28ff\u2819\u28bf\u28c6\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e4\u28f4\u28e6\u28e4\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2808\u28bb\u28ff\u28ff\u28ff\u28ff\u281b\u283f\u283f\u2836\u2836\u28f6\u2800  \u28ff \u28b8\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u2807\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28ff\u28ff\u28ff\u28ff\u28f7\u2846\u2800\u2800\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u2809\u281b\u28bf\u28f7\u2844\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2800  \u2839\u2807\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u28e0\u28f4\u28ff\u28ffV1\u28ff\u28ff\u28ff\u284f\u281b\u2803\u2800\u2800\u2800\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2818\u280b\u2801\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800  \u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2838\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800  \u2800\u28ff\u28ff\u285f\u28bf\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2809\u2819\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2800 \u2888\u28ff\u28ff\u285f\u28b9\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u287f\u2808\u28ff\u28ff\u285f\u2800\u2800\u2800\u2800\u2800  \u28b8\u28ff\u28ff\u2800\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u283b\u28ff\u28ff\u28ff\u28ff\u28f6\u28c4\u2800\u2800\u2800\u28b0\u28ff\u28ff\u285f\u2801\u28fe\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28f6\u28ff\u281f\u280b\u2800\u28bc\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800  \u28ff\u28ff\u2801\u2800\u28b9\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2880\u28f4\u28ff\u287f\u280b\u28b9\u28ff\u2847\u2800\u2800\u2808\u2819\u28ff\u28c7\u2819\u28ff\u28f7\u2800\u2800\u28b8\u28ff\u285f\u2800\u2800\u28bb\u28ff\u284f\u2800\u2800\u2800\u2800\u2800\u2880\u28fc\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800   \u28a8\u28ff\u2847\u2800\u2800\u2800\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u28f4\u28ff\u285f\u2809\u2800\u2800\u28fe\u28ff\u2847\u2800\u2800\u2800\u2800\u2888\u28ff\u2844\u2800\u2809\u2800\u2800\u28fc\u28ff\u2846\u2800\u2800\u28b8\u28ff\u28f7\u2800\u2800\u2800\u2800\u28b4\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ef\u2840\u2800\u2800\u2800\u2800    \u28b8\u28ff\u28c7\u2800\u2800\u2800\u28ba\u28ff\u2844\u2800\u2800\u2800   \\r\\n\u2808\u283b\u2837\u2804\u2800\u2800\u28ff\u28ff\u28f7\u28e4\u28e0\u2800\u2800\u2808\u283d\u2837\u2800\u2800\u2800\u2838\u281f\u281b\u281b\u2812\u2836\u2838\u28ff\u28ff\u28f7\u28e6\u28e4\u28c4\u2808\u283b\u2837\u2804\u2800\u2800\u2800\u283e\u283f\u283f\u28ff\u28f6\u28e4\u2800    \u2818\u281b\u281b\u281b\u2812\u2800\u2838\u283f\u283f\u2826 \\r\\n\\r\\n\\r\\nTelegram: https://t.me/ChaintoolsOfficial\\r\\nWebsite: https://www.chaintools.ai/\\r\\nWhitepaper: https://chaintools-whitepaper.gitbook.io/\\r\\nTwitter: https://twitter.com/ChaintoolsTech\\r\\ndApp: https://www.chaintools.wtf/\\r\\n*/\\r\\n\\r\\n// import \\\"forge-std/console.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function getAmountsOut(\\r\\n        uint256 amountIn,\\r\\n        address[] memory path\\r\\n    ) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\r\\n}\\r\\n\\r\\ninterface IV2Pair {\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function kLast() external view returns (uint lastK);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (uint stamp, uint res0, uint res1);\\r\\n\\r\\n    function burn(\\r\\n        address to\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n}\\r\\n\\r\\ninterface IV3Pool {\\r\\n    function liquidity() external view returns (uint128 Liq);\\r\\n\\r\\n    struct Info {\\r\\n        // the amount of liquidity owned by this position\\r\\n        uint128 liquidity;\\r\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\r\\n        uint256 feeGrowthInside0LastX128;\\r\\n        uint256 feeGrowthInside1LastX128;\\r\\n        // the fees owed to the position owner in token0/token1\\r\\n        uint128 tokensOwed0;\\r\\n        uint128 tokensOwed1;\\r\\n    }\\r\\n\\r\\n    function initialize(uint160 sqrtPriceX96) external;\\r\\n\\r\\n    function positions(\\r\\n        bytes32 key\\r\\n    ) external view returns (IV3Pool.Info memory liqInfo);\\r\\n\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96,\\r\\n        bytes memory data\\r\\n    ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n    function burn(\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function collect(\\r\\n        address recipient,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount0Requested,\\r\\n        uint128 amount1Requested\\r\\n    ) external returns (uint128 amount0, uint128 amount1);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function slot0()\\r\\n        external\\r\\n        view\\r\\n        returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\\r\\n\\r\\n    function flash(\\r\\n        address recipient,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function uniswapV3FlashCallback(\\r\\n        uint256 fee0,\\r\\n        uint256 fee1,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function mint(\\r\\n        address recipient,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n}\\r\\n\\r\\ninterface IWETH {\\r\\n    function withdraw(uint256 wad) external;\\r\\n\\r\\n    function approve(address who, uint256 wad) external returns (bool);\\r\\n\\r\\n    function deposit() external payable;\\r\\n\\r\\n    function transfer(address dst, uint256 wad) external returns (bool);\\r\\n\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IQuoterV2 {\\r\\n    function quoteExactInputSingle(\\r\\n        address tokenIn,\\r\\n        address tokenOut,\\r\\n        uint24 fee,\\r\\n        uint256 amountIn,\\r\\n        uint160 sqrtPriceLimitX96\\r\\n    ) external returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\ninterface IV3Factory {\\r\\n    function getPool(\\r\\n        address token0,\\r\\n        address token1,\\r\\n        uint24 poolFee\\r\\n    ) external view returns (address);\\r\\n\\r\\n    function createPool(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint24 fee\\r\\n    ) external returns (address);\\r\\n}\\r\\n\\r\\ninterface INonfungiblePositionManager {\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function increaseLiquidity(\\r\\n        INonfungiblePositionManager.IncreaseLiquidityParams calldata params\\r\\n    ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function tokenOfOwnerByIndex(\\r\\n        address owner,\\r\\n        uint256 index\\r\\n    ) external view returns (uint256 tokenId);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    struct MintParams {\\r\\n        address token0;\\r\\n        address token1;\\r\\n        uint24 fee;\\r\\n        int24 tickLower;\\r\\n        int24 tickUpper;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function mint(\\r\\n        MintParams calldata mp\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 tokenId,\\r\\n            uint128 liquidity,\\r\\n            uint256 amount0,\\r\\n            uint256 amount1\\r\\n        );\\r\\n\\r\\n    function collect(\\r\\n        CollectParams calldata params\\r\\n    ) external payable returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    struct CollectParams {\\r\\n        uint256 tokenId;\\r\\n        address recipient;\\r\\n        uint128 amount0Max;\\r\\n        uint128 amount1Max;\\r\\n    }\\r\\n\\r\\n    struct DecreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint128 liquidity;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function decreaseLiquidity(\\r\\n        DecreaseLiquidityParams calldata dl\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function positions(\\r\\n        uint256 tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint96 nonce,\\r\\n            address operator,\\r\\n            address token0,\\r\\n            address token1,\\r\\n            uint24 fee,\\r\\n            int24 tickLower,\\r\\n            int24 tickUpper,\\r\\n            uint128 liquidity,\\r\\n            uint256 feeGrowthInside0LastX128,\\r\\n            uint256 feeGrowthInside1LastX128,\\r\\n            uint128 tokensOwed0,\\r\\n            uint128 tokensOwed1\\r\\n        );\\r\\n}\\r\\n\\r\\ninterface IRouterV3 {\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    function WETH9() external view returns (address);\\r\\n\\r\\n    struct ExactOutputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountOut;\\r\\n        uint256 amountInMaximum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    function exactOutputSingle(\\r\\n        ExactOutputSingleParams calldata params\\r\\n    ) external returns (uint256 amountIn);\\r\\n\\r\\n    function exactInputSingle(\\r\\n        ExactInputSingleParams calldata params\\r\\n    ) external payable returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\nlibrary FixedPoint96 {\\r\\n    uint8 internal constant RESOLUTION = 96;\\r\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\r\\n}\\r\\n\\r\\nlibrary FullMath {\\r\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n    function mulDiv(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = a * b\\r\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n            // then use the Chinese Remainder Theorem to reconstruct\\r\\n            // the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2**256 + prod0\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(a, b, not(0))\\r\\n                prod0 := mul(a, b)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division\\r\\n            if (prod1 == 0) {\\r\\n                require(denominator > 0);\\r\\n                assembly {\\r\\n                    result := div(prod0, denominator)\\r\\n                }\\r\\n                return result;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2**256.\\r\\n            // Also prevents denominator == 0\\r\\n            require(denominator > prod1);\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n            // Compute remainder using mulmod\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                remainder := mulmod(a, b, denominator)\\r\\n            }\\r\\n            // Subtract 256 bit number from 512 bit number\\r\\n            assembly {\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator\\r\\n            // Compute largest power of two divisor of denominator.\\r\\n            // Always >= 1.\\r\\n            uint256 twos = uint256(-int256(denominator) & int256(denominator));\\r\\n            // console.log(twos, \\\"TWOS?!??!?!?!\\\");\\r\\n            // Divide denominator by power of two\\r\\n            assembly {\\r\\n                denominator := div(denominator, twos)\\r\\n            }\\r\\n\\r\\n            // Divide [prod1 prod0] by the factors of two\\r\\n            assembly {\\r\\n                prod0 := div(prod0, twos)\\r\\n            }\\r\\n            // Shift in bits from prod1 into prod0. For this we need\\r\\n            // to flip `twos` such that it is 2**256 / twos.\\r\\n            // If twos is zero, then it becomes one\\r\\n            assembly {\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2**256\\r\\n            // Now that denominator is an odd number, it has an inverse\\r\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n            // Compute the inverse by starting with a seed that is correct\\r\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n            uint256 inv = (3 * denominator) ^ 2;\\r\\n            // Now use Newton-Raphson iteration to improve the precision.\\r\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n            // arithmetic, doubling the correct bits in each step.\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying\\r\\n            // with the modular inverse of denominator. This will give us the\\r\\n            // correct result modulo 2**256. Since the precoditions guarantee\\r\\n            // that the outcome is less than 2**256, this is the final result.\\r\\n            // We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inv;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            result = mulDiv(a, b, denominator);\\r\\n            if (mulmod(a, b, denominator) > 0) {\\r\\n                require(result < type(uint256).max);\\r\\n                result++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Babylonian {\\r\\n    // credit for this implementation goes to\\r\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\r\\n        // however that code costs significantly more gas\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx >= 0x100000000000000000000000000000000) {\\r\\n            xx >>= 128;\\r\\n            r <<= 64;\\r\\n        }\\r\\n        if (xx >= 0x10000000000000000) {\\r\\n            xx >>= 64;\\r\\n            r <<= 32;\\r\\n        }\\r\\n        if (xx >= 0x100000000) {\\r\\n            xx >>= 32;\\r\\n            r <<= 16;\\r\\n        }\\r\\n        if (xx >= 0x10000) {\\r\\n            xx >>= 16;\\r\\n            r <<= 8;\\r\\n        }\\r\\n        if (xx >= 0x100) {\\r\\n            xx >>= 8;\\r\\n            r <<= 4;\\r\\n        }\\r\\n        if (xx >= 0x10) {\\r\\n            xx >>= 4;\\r\\n            r <<= 2;\\r\\n        }\\r\\n        if (xx >= 0x8) {\\r\\n            r <<= 1;\\r\\n        }\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r < r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary LiquidityAmounts {\\r\\n    /// @notice Downcasts uint256 to uint128\\r\\n    /// @param x The uint258 to be downcasted\\r\\n    /// @return y The passed value, downcasted to uint128\\r\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\r\\n        require((y = uint128(x)) == x);\\r\\n    }\\r\\n\\r\\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\r\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\r\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\r\\n    /// @param liquidity The liquidity being valued\\r\\n    /// @return amount0 The amount of token0\\r\\n    function getAmount0ForLiquidity(\\r\\n        uint160 sqrtRatioAX96,\\r\\n        uint160 sqrtRatioBX96,\\r\\n        uint128 liquidity\\r\\n    ) internal pure returns (uint256 amount0) {\\r\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\r\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n\\r\\n        return\\r\\n            FullMath.mulDiv(\\r\\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\\r\\n                sqrtRatioBX96 - sqrtRatioAX96,\\r\\n                sqrtRatioBX96\\r\\n            ) / sqrtRatioAX96;\\r\\n    }\\r\\n\\r\\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\r\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\r\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\r\\n    /// @param liquidity The liquidity being valued\\r\\n    /// @return amount1 The amount of token1\\r\\n    function getAmount1ForLiquidity(\\r\\n        uint160 sqrtRatioAX96,\\r\\n        uint160 sqrtRatioBX96,\\r\\n        uint128 liquidity\\r\\n    ) internal pure returns (uint256 amount1) {\\r\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\r\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n\\r\\n        return\\r\\n            FullMath.mulDiv(\\r\\n                liquidity,\\r\\n                sqrtRatioBX96 - sqrtRatioAX96,\\r\\n                FixedPoint96.Q96\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\r\\n    /// pool prices and the prices at the tick boundaries\\r\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\r\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\r\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\r\\n    /// @param liquidity The liquidity being valued\\r\\n    /// @return amount0 The amount of token0\\r\\n    /// @return amount1 The amount of token1\\r\\n    function getAmountsForLiquidity(\\r\\n        uint160 sqrtRatioX96,\\r\\n        uint160 sqrtRatioAX96,\\r\\n        uint160 sqrtRatioBX96,\\r\\n        uint128 liquidity\\r\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\r\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\r\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n\\r\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n            amount0 = getAmount0ForLiquidity(\\r\\n                sqrtRatioAX96,\\r\\n                sqrtRatioBX96,\\r\\n                liquidity\\r\\n            );\\r\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n            amount0 = getAmount0ForLiquidity(\\r\\n                sqrtRatioX96,\\r\\n                sqrtRatioBX96,\\r\\n                liquidity\\r\\n            );\\r\\n            amount1 = getAmount1ForLiquidity(\\r\\n                sqrtRatioAX96,\\r\\n                sqrtRatioX96,\\r\\n                liquidity\\r\\n            );\\r\\n        } else {\\r\\n            amount1 = getAmount1ForLiquidity(\\r\\n                sqrtRatioAX96,\\r\\n                sqrtRatioBX96,\\r\\n                liquidity\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\r\\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\\r\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\r\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\r\\n    /// @param amount0 The amount0 being sent in\\r\\n    /// @return liquidity The amount of returned liquidity\\r\\n    function getLiquidityForAmount0(\\r\\n        uint160 sqrtRatioAX96,\\r\\n        uint160 sqrtRatioBX96,\\r\\n        uint256 amount0\\r\\n    ) internal pure returns (uint128 liquidity) {\\r\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\r\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n        uint256 intermediate = FullMath.mulDiv(\\r\\n            sqrtRatioAX96,\\r\\n            sqrtRatioBX96,\\r\\n            uint256(0x1000000000000000000000000)\\r\\n        );\\r\\n        return\\r\\n            toUint128(\\r\\n                FullMath.mulDiv(\\r\\n                    amount0,\\r\\n                    intermediate,\\r\\n                    sqrtRatioBX96 - sqrtRatioAX96\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\r\\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\r\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\r\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\r\\n    /// @param amount1 The amount1 being sent in\\r\\n    /// @return liquidity The amount of returned liquidity\\r\\n    function getLiquidityForAmount1(\\r\\n        uint160 sqrtRatioAX96,\\r\\n        uint160 sqrtRatioBX96,\\r\\n        uint256 amount1\\r\\n    ) internal pure returns (uint128 liquidity) {\\r\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\r\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n        return\\r\\n            toUint128(\\r\\n                FullMath.mulDiv(\\r\\n                    amount1,\\r\\n                    uint256(0x1000000000000000000000000),\\r\\n                    sqrtRatioBX96 - sqrtRatioAX96\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\r\\n    /// pool prices and the prices at the tick boundaries\\r\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\r\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\r\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\r\\n    /// @param amount0 The amount of token0 being sent in\\r\\n    /// @param amount1 The amount of token1 being sent in\\r\\n    /// @return liquidity The maximum amount of liquidity received\\r\\n    function getLiquidityForAmounts(\\r\\n        uint160 sqrtRatioX96,\\r\\n        uint160 sqrtRatioAX96,\\r\\n        uint160 sqrtRatioBX96,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1\\r\\n    ) internal pure returns (uint128 liquidity) {\\r\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\r\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n\\r\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n            liquidity = getLiquidityForAmount0(\\r\\n                sqrtRatioAX96,\\r\\n                sqrtRatioBX96,\\r\\n                amount0\\r\\n            );\\r\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n            uint128 liquidity0 = getLiquidityForAmount0(\\r\\n                sqrtRatioX96,\\r\\n                sqrtRatioBX96,\\r\\n                amount0\\r\\n            );\\r\\n            uint128 liquidity1 = getLiquidityForAmount1(\\r\\n                sqrtRatioAX96,\\r\\n                sqrtRatioX96,\\r\\n                amount1\\r\\n            );\\r\\n\\r\\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\r\\n        } else {\\r\\n            liquidity = getLiquidityForAmount1(\\r\\n                sqrtRatioAX96,\\r\\n                sqrtRatioBX96,\\r\\n                amount1\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary TickMath {\\r\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\r\\n    int24 internal constant MIN_TICK = -887272;\\r\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\r\\n    int24 internal constant MAX_TICK = 887272;\\r\\n\\r\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\r\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\r\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\r\\n    uint160 internal constant MAX_SQRT_RATIO =\\r\\n        1461446703485210103287273052203988822378723970342;\\r\\n\\r\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\r\\n    /// @dev Throws if |tick| > max tick\\r\\n    /// @param tick The input tick for the above formula\\r\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\r\\n    /// at the given tick\\r\\n    function getSqrtRatioAtTick(\\r\\n        int24 tick\\r\\n    ) internal pure returns (uint160 sqrtPriceX96) {\\r\\n        uint256 absTick = tick < 0\\r\\n            ? uint256(-int256(tick))\\r\\n            : uint256(int256(tick));\\r\\n        require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\r\\n\\r\\n        uint256 ratio = absTick & 0x1 != 0\\r\\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\\r\\n            : 0x100000000000000000000000000000000;\\r\\n        if (absTick & 0x2 != 0)\\r\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\r\\n        if (absTick & 0x4 != 0)\\r\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\r\\n        if (absTick & 0x8 != 0)\\r\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\r\\n        if (absTick & 0x10 != 0)\\r\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\r\\n        if (absTick & 0x20 != 0)\\r\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\r\\n        if (absTick & 0x40 != 0)\\r\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\r\\n        if (absTick & 0x80 != 0)\\r\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\r\\n        if (absTick & 0x100 != 0)\\r\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\r\\n        if (absTick & 0x200 != 0)\\r\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\r\\n        if (absTick & 0x400 != 0)\\r\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\r\\n        if (absTick & 0x800 != 0)\\r\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\r\\n        if (absTick & 0x1000 != 0)\\r\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\r\\n        if (absTick & 0x2000 != 0)\\r\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\r\\n        if (absTick & 0x4000 != 0)\\r\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\r\\n        if (absTick & 0x8000 != 0)\\r\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\r\\n        if (absTick & 0x10000 != 0)\\r\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\r\\n        if (absTick & 0x20000 != 0)\\r\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\r\\n        if (absTick & 0x40000 != 0)\\r\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\r\\n        if (absTick & 0x80000 != 0)\\r\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\r\\n\\r\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\r\\n\\r\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\r\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\r\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\r\\n        sqrtPriceX96 = uint160(\\r\\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IYieldVault {\\r\\n    function balanceOf(\\r\\n        uint tokenId\\r\\n    ) external view returns (uint128 b0, uint128 b1);\\r\\n}\\r\\n\\r\\ninterface IV2Factory {\\r\\n    function getPair(address, address) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IChainTools {\\r\\n    function adjustFomo(uint16 a, uint256 b, address w) external;\\r\\n\\r\\n    function zapFromETH(\\r\\n        uint256 minOut,\\r\\n        address to,\\r\\n        uint256 flag,\\r\\n        address upper\\r\\n    ) external payable returns (uint256 tokenId);\\r\\n\\r\\n    function getYieldBooster() external view returns (address yb);\\r\\n\\r\\n    function swapBack() external;\\r\\n\\r\\n    function flashReward() external;\\r\\n\\r\\n    function getUpperRef(address who) external view returns (address ref);\\r\\n}\\r\\n\\r\\ncontract ChainToolsV3Utils {\\r\\n    //New - Router\\r\\n    IUniswapV2Router02 internal immutable router;\\r\\n    INonfungiblePositionManager internal immutable positionManager;\\r\\n    IV2Factory internal immutable v2Factory;\\r\\n    address internal immutable quoter;\\r\\n    address internal CTLS;\\r\\n    address internal immutable WETH;\\r\\n    address internal immutable multiSig;\\r\\n    address internal immutable dev = msg.sender;\\r\\n    address internal immutable v3Router;\\r\\n    address internal immutable uniswapV3Pool;\\r\\n    IYieldVault internal yieldVault;\\r\\n\\r\\n    error Auth();\\r\\n    error Max0();\\r\\n    error Max1();\\r\\n\\r\\n    constructor(address _ctls, address _v3pool) {\\r\\n        positionManager = INonfungiblePositionManager(\\r\\n            0xC36442b4a4522E871399CD717aBDD847Ab11FE88\\r\\n        );\\r\\n        v2Factory = IV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\r\\n        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        CTLS = _ctls;\\r\\n        v3Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\r\\n        WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n\\r\\n        IERC20(WETH).approve(address(positionManager), type(uint256).max);\\r\\n        IERC20(CTLS).approve(address(positionManager), type(uint256).max);\\r\\n        quoter = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\r\\n        multiSig = 0xb0Df68E0bf4F54D06A4a448735D2a3d7D97A2222;\\r\\n        IERC20(WETH).approve(address(v3Router), type(uint256).max);\\r\\n        IERC20(CTLS).approve(address(v3Router), type(uint256).max);\\r\\n        uniswapV3Pool = _v3pool;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint amountIn,\\r\\n        uint reserveIn,\\r\\n        uint reserveOut\\r\\n    ) internal pure returns (uint amountOut) {\\r\\n        uint amountInWithFee = amountIn * 997;\\r\\n        amountOut =\\r\\n            (amountInWithFee * reserveOut) /\\r\\n            ((reserveIn * 1000) + amountInWithFee);\\r\\n    }\\r\\n\\r\\n    function _swapV2TokenIn(\\r\\n        address token,\\r\\n        address _pair,\\r\\n        uint amount,\\r\\n        uint minOut,\\r\\n        bool isToken0Weth\\r\\n    ) internal returns (uint amountOut) {\\r\\n        token.call(\\r\\n                abi.encodeWithSelector(\\r\\n                    IERC20.transferFrom.selector,\\r\\n                    msg.sender,\\r\\n                    _pair,\\r\\n                    amount\\r\\n                )\\r\\n        );\\r\\n\\r\\n        if (isToken0Weth) {\\r\\n            \\r\\n            (uint reserve0, uint reserve1, ) = IV2Pair(_pair)\\r\\n                .getReserves();\\r\\n            uint balAft = IERC20(token).balanceOf(_pair);\\r\\n            amountOut = getAmountOut(balAft - reserve1, reserve1, reserve0);\\r\\n            if (minOut > amountOut) revert Max0();\\r\\n            assembly {\\r\\n\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0x022c0d9f00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), amountOut)\\r\\n                mstore(add(inputMem, 0x24), 0)\\r\\n                mstore(add(inputMem, 0x44), address())\\r\\n                mstore(add(inputMem, 0x64), 0x80)\\r\\n                mstore(add(inputMem, 0x84), 0)\\r\\n                pop(call(gas(), _pair, 0, inputMem, 0xA4, 0, 0))\\r\\n            }\\r\\n        } else {\\r\\n            (uint256 reserve0, uint256 reserve1, ) = IV2Pair(_pair)\\r\\n                .getReserves();\\r\\n\\r\\n            uint256 balAft = IERC20(token).balanceOf(_pair);\\r\\n            amountOut = getAmountOut(balAft - reserve0, reserve0, reserve1);\\r\\n            if (minOut > amountOut) revert Max0();\\r\\n            \\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0x022c0d9f00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), 0)\\r\\n                mstore(add(inputMem, 0x24), amountOut)\\r\\n                mstore(add(inputMem, 0x44), address())\\r\\n                mstore(add(inputMem, 0x64), 0x80)\\r\\n                mstore(add(inputMem, 0x84), 0)\\r\\n                pop(call(gas(), _pair, 0, inputMem, 0xA4, 0, 0))\\r\\n            }\\r\\n         \\r\\n        }\\r\\n\\r\\n        IWETH(WETH).withdraw(amountOut);\\r\\n    }\\r\\n\\r\\n    function zapFromToken(\\r\\n        address fromToken,\\r\\n        uint256 amountIn,\\r\\n        uint256 minOut,\\r\\n        uint256 minOut2,\\r\\n        bool isV2,\\r\\n        uint24 poolFee,\\r\\n        uint256 flag,\\r\\n        address ref\\r\\n    ) external returns (uint256 tokenId, uint amountOutV2OrV3) {\\r\\n        \\r\\n        {\\r\\n            address _weth = WETH;\\r\\n            if (fromToken == WETH) {\\r\\n                fromToken.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        IERC20.transferFrom.selector,\\r\\n                        msg.sender,\\r\\n                        address(this),\\r\\n                        amountIn\\r\\n                    )\\r\\n                );\\r\\n                assembly {\\r\\n                    let inputMem := mload(0x40)\\r\\n                    mstore(\\r\\n                        inputMem,\\r\\n                        0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\\r\\n                    )\\r\\n                    mstore(add(inputMem, 0x04), amountIn)\\r\\n                    pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\\r\\n                }\\r\\n                return (\\r\\n                    IChainTools(CTLS).zapFromETH{value: amountIn}(\\r\\n                        minOut2,\\r\\n                        msg.sender,\\r\\n                        flag,\\r\\n                        ref\\r\\n                    ),\\r\\n                    amountIn\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (isV2) {\\r\\n            {\\r\\n                address pair = v2Factory.getPair(fromToken, WETH);\\r\\n                amountOutV2OrV3 = _swapV2TokenIn(fromToken, pair, amountIn, minOut, IV2Pair(pair).token0() == WETH);\\r\\n\\r\\n                return (\\r\\n                    IChainTools(CTLS).zapFromETH{value: address(this).balance}(\\r\\n                        minOut2,\\r\\n                        msg.sender,\\r\\n                        flag,\\r\\n                        ref\\r\\n                    ),\\r\\n                    amountOutV2OrV3\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            fromToken.call(\\r\\n                abi.encodeWithSelector(\\r\\n                    IERC20.transferFrom.selector,\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    amountIn\\r\\n                )\\r\\n            );\\r\\n            {\\r\\n                if (fromToken != address(CTLS) && fromToken != WETH) {\\r\\n                    if (\\r\\n                        IERC20(fromToken).allowance(\\r\\n                            address(this),\\r\\n                            address(v3Router)\\r\\n                        ) < amountIn\\r\\n                    ) {\\r\\n                        fromToken.call(\\r\\n                            abi.encodeWithSelector(\\r\\n                                IERC20.approve.selector,\\r\\n                                address(v3Router),\\r\\n                                amountIn\\r\\n                            )\\r\\n                        );\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            uint256 gotOut = IRouterV3(v3Router).exactInputSingle(\\r\\n                IRouterV3.ExactInputSingleParams({\\r\\n                    tokenIn: fromToken,\\r\\n                    tokenOut: WETH,\\r\\n                    fee: poolFee,\\r\\n                    recipient: address(this),\\r\\n                    deadline: block.timestamp,\\r\\n                    amountIn: amountIn,\\r\\n                    amountOutMinimum: minOut,\\r\\n                    sqrtPriceLimitX96: 0\\r\\n                })\\r\\n            );\\r\\n            {\\r\\n                address _weth = WETH;\\r\\n\\r\\n                assembly {\\r\\n                    let inputMem := mload(0x40)\\r\\n                    mstore(\\r\\n                        inputMem,\\r\\n                        0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\\r\\n                    )\\r\\n                    mstore(add(inputMem, 0x04), gotOut)\\r\\n                    pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\\r\\n                }\\r\\n                return (\\r\\n                    IChainTools(CTLS).zapFromETH{value: gotOut}(\\r\\n                        minOut2,\\r\\n                        msg.sender,\\r\\n                        flag,\\r\\n                        ref\\r\\n                    ),\\r\\n                    gotOut\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    fallback() external payable {}\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function getPosition(\\r\\n        uint256 tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (address token0, address token1, uint128 liquidity)\\r\\n    {\\r\\n        (, , token0, token1, , , , liquidity, , , , ) = positionManager\\r\\n            .positions(tokenId);\\r\\n    }\\r\\n\\r\\n    function findPoolFee(\\r\\n        address token0,\\r\\n        address token1\\r\\n    ) public view returns (uint24 poolFee) {\\r\\n        address factory = IRouterV3(v3Router).factory();\\r\\n        uint128 highestLiq;\\r\\n        try IV3Factory(factory).getPool(token0, token1, 100) returns (\\r\\n            address pool100\\r\\n        ) {\\r\\n            if (pool100 != address(0)) {\\r\\n                try IV3Pool(pool100).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 100;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n        try IV3Factory(factory).getPool(token0, token1, 500) returns (\\r\\n            address pool500\\r\\n        ) {\\r\\n            if (pool500 != address(0)) {\\r\\n                try IV3Pool(pool500).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 500;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n        try IV3Factory(factory).getPool(token0, token1, 3000) returns (\\r\\n            address pool3000\\r\\n        ) {\\r\\n            if (pool3000 != address(0)) {\\r\\n                try IV3Pool(pool3000).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 3000;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n\\r\\n        try IV3Factory(factory).getPool(token0, token1, 10000) returns (\\r\\n            address pool10000\\r\\n        ) {\\r\\n            if (pool10000 != address(0)) {\\r\\n                try IV3Pool(pool10000).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 10000;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n    }\\r\\n\\r\\n    function getDeviation(\\r\\n        uint256 amountIn,\\r\\n        uint256 startTickDeviation\\r\\n    ) external pure returns (uint256 adjusted) {\\r\\n        adjusted = (amountIn * (10000 + startTickDeviation)) / 20000;\\r\\n    }\\r\\n\\r\\n    function getStartTickDeviation(\\r\\n        int24 currentTick\\r\\n    ) external pure returns (uint256 perc) {\\r\\n        int24 startTickDeviation;\\r\\n\\r\\n        if (currentTick > -106400) {\\r\\n            startTickDeviation = currentTick + -106400;\\r\\n        } else {\\r\\n            startTickDeviation = -106400 + currentTick;\\r\\n        }\\r\\n        if (startTickDeviation < 0) {\\r\\n            startTickDeviation = -startTickDeviation;\\r\\n        }\\r\\n        perc = (uint256(int256(startTickDeviation)) * 75) / 107400;\\r\\n    }\\r\\n\\r\\n    function getCurrentTick() external view returns (int24 cTick) {\\r\\n        (, cTick, , , , , ) = IV3Pool(uniswapV3Pool).slot0();\\r\\n        cTick = (cTick / 200) * 200;\\r\\n    }\\r\\n\\r\\n    function getTickDistance(\\r\\n        uint256 flag\\r\\n    ) external pure returns (int24 tickDistance) {\\r\\n        if (flag == 0) {\\r\\n            //default\\r\\n            tickDistance = 30000;\\r\\n        } else if (flag == 1) {\\r\\n            tickDistance = 20000;\\r\\n        } else if (flag == 2) {\\r\\n            tickDistance = 10000;\\r\\n        } else if (flag == 3) {\\r\\n            tickDistance = 5000;\\r\\n        } else if (flag == 4) {\\r\\n            tickDistance = 2000;\\r\\n        } else if (flag == 5) {\\r\\n            tickDistance = 1000;\\r\\n        } else if (flag == 6) {\\r\\n            tickDistance = 600;\\r\\n        } else {\\r\\n            revert(\\\"invalid_flag\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setVault(address vault) external {\\r\\n        require(msg.sender == multiSig || msg.sender == dev, \\\"dev\\\");\\r\\n        yieldVault = IYieldVault(vault);\\r\\n    }\\r\\n\\r\\n    function setCTLS(address ctlsNew) external {\\r\\n        require(msg.sender == multiSig || msg.sender == dev, \\\"dev\\\");\\r\\n        CTLS = ctlsNew;\\r\\n    }\\r\\n\\r\\n    function balanceOfMany(\\r\\n        uint256[] calldata tokenIds\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 balance0Total,\\r\\n            uint128 balance1Total,\\r\\n            uint256[] memory returnTokenIds,\\r\\n            uint128[] memory balances0,\\r\\n            uint128[] memory balances1\\r\\n        )\\r\\n    {\\r\\n        uint256 size = tokenIds.length;\\r\\n        balances0 = new uint128[](size);\\r\\n        balances1 = new uint128[](size);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint256 i; i < size; ++i) {\\r\\n                uint256 tokenId = tokenIds[i];\\r\\n                (uint128 bal0, uint128 bal1) = yieldVault.balanceOf(tokenId);\\r\\n\\r\\n                balance0Total += bal0;\\r\\n                balance1Total += bal1;\\r\\n\\r\\n                balances0[i] = bal0;\\r\\n                balances1[i] = bal1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        returnTokenIds = tokenIds;\\r\\n    }\\r\\n\\r\\n    function findApprovalToken(\\r\\n        address pool\\r\\n    ) external view returns (address token) {\\r\\n        return\\r\\n            this.findApprovalToken(\\r\\n                IV3Pool(pool).token0(),\\r\\n                IV3Pool(pool).token1()\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function findApprovalToken(\\r\\n        address token0,\\r\\n        address token1\\r\\n    ) external view returns (address token) {\\r\\n        require(token0 == WETH || token1 == WETH, \\\"Not WETH Pair\\\");\\r\\n        token = token0 == WETH ? token1 : token0;\\r\\n        if (token == CTLS || token == WETH) {\\r\\n            token = address(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw(\\r\\n        address token,\\r\\n        address toAddress,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(msg.sender == multiSig, \\\"multiSig\\\");\\r\\n        if (amount != 0) IERC20(token).transfer(toAddress, amount);\\r\\n        if (address(this).balance > 0) {\\r\\n            multiSig.call{value: address(this).balance}(\\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //CallStatic\\r\\n    function getV2RemovedLiqudityFeeOnTransfer(\\r\\n        address pair,\\r\\n        uint amount\\r\\n    ) external returns (uint a0, uint a1) {\\r\\n        uint balance0Before = IERC20(IV2Pair(pair).token0()).balanceOf(\\r\\n            msg.sender\\r\\n        );\\r\\n        uint balance1Before = IERC20(IV2Pair(pair).token1()).balanceOf(\\r\\n            msg.sender\\r\\n        );\\r\\n\\r\\n        IERC20(pair).transferFrom(msg.sender, pair, amount);\\r\\n\\r\\n        IV2Pair(pair).burn(msg.sender);\\r\\n\\r\\n        uint balance0After = IERC20(IV2Pair(pair).token0()).balanceOf(\\r\\n            msg.sender\\r\\n        );\\r\\n        uint balance1After = IERC20(IV2Pair(pair).token1()).balanceOf(\\r\\n            msg.sender\\r\\n        );\\r\\n\\r\\n        a0 = balance0After - balance0Before;\\r\\n        a1 = balance1After - balance1Before;\\r\\n    }\\r\\n\\r\\n    function getPositionAmounts(\\r\\n        uint256 tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address token0,\\r\\n            address token1,\\r\\n            uint128 liquidity,\\r\\n            uint256 amount0,\\r\\n            uint256 amount1\\r\\n        )\\r\\n    {\\r\\n        int24 lower;\\r\\n        int24 upper;\\r\\n        int24 current = this.getCurrentTick();\\r\\n\\r\\n        (\\r\\n            ,\\r\\n            ,\\r\\n            token0,\\r\\n            token1,\\r\\n            ,\\r\\n            lower,\\r\\n            upper,\\r\\n            liquidity,\\r\\n            ,\\r\\n            ,\\r\\n            ,\\r\\n\\r\\n        ) = positionManager.positions(tokenId);\\r\\n\\r\\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\\r\\n            TickMath.getSqrtRatioAtTick(current),\\r\\n            TickMath.getSqrtRatioAtTick(lower),\\r\\n            TickMath.getSqrtRatioAtTick(upper),\\r\\n            liquidity\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getAmountsFromLiquidity(\\r\\n        uint128 liquidity,\\r\\n        int24 lower,\\r\\n        int24 upper\\r\\n    ) external view returns (uint256 amount0, uint256 amount1) {\\r\\n        int24 current = this.getCurrentTick();\\r\\n\\r\\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\\r\\n            TickMath.getSqrtRatioAtTick(current),\\r\\n            TickMath.getSqrtRatioAtTick(lower),\\r\\n            TickMath.getSqrtRatioAtTick(upper),\\r\\n            liquidity\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function findMaxAddDouble(\\r\\n        uint256 amount0Desired,\\r\\n        uint256 amount1Desired,\\r\\n        int24 lower,\\r\\n        int24 upper\\r\\n    ) external view returns (uint256 amount0Max, uint256 amount1Max) {\\r\\n        // int24 current = this.getCurrentTick();\\r\\n        int24 cTick;\\r\\n        uint160 sqrtPrice;\\r\\n        (sqrtPrice, cTick, , , , , ) = IV3Pool(uniswapV3Pool).slot0();\\r\\n\\r\\n        (amount0Max, amount1Max) = LiquidityAmounts.getAmountsForLiquidity(\\r\\n            sqrtPrice,\\r\\n            TickMath.getSqrtRatioAtTick(lower),\\r\\n            TickMath.getSqrtRatioAtTick(upper),\\r\\n            //Liq\\r\\n            LiquidityAmounts.getLiquidityForAmounts(\\r\\n                sqrtPrice,\\r\\n                TickMath.getSqrtRatioAtTick(lower),\\r\\n                TickMath.getSqrtRatioAtTick(upper),\\r\\n                amount0Desired,\\r\\n                amount1Desired\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function findMaxAddSingle(\\r\\n        bool isAmount0,\\r\\n        uint256 amountDesired,\\r\\n        int24 lower,\\r\\n        int24 upper\\r\\n    ) external pure returns (uint256 amountMax) {\\r\\n        if (isAmount0) {\\r\\n            (amountMax) = LiquidityAmounts.getAmount0ForLiquidity(\\r\\n                TickMath.getSqrtRatioAtTick(lower),\\r\\n                TickMath.getSqrtRatioAtTick(upper),\\r\\n                //Liq\\r\\n                LiquidityAmounts.getLiquidityForAmount0(\\r\\n                    TickMath.getSqrtRatioAtTick(lower),\\r\\n                    TickMath.getSqrtRatioAtTick(upper),\\r\\n                    amountDesired\\r\\n                )\\r\\n            );\\r\\n        } else {\\r\\n            (amountMax) = LiquidityAmounts.getAmount1ForLiquidity(\\r\\n                TickMath.getSqrtRatioAtTick(lower),\\r\\n                TickMath.getSqrtRatioAtTick(upper),\\r\\n                //Liq\\r\\n                LiquidityAmounts.getLiquidityForAmount1(\\r\\n                    TickMath.getSqrtRatioAtTick(lower),\\r\\n                    TickMath.getSqrtRatioAtTick(upper),\\r\\n                    amountDesired\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 42000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ctls\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_v3pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Auth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Max0\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Max1\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfMany\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balance0Total\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"balance1Total\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"returnTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"balances0\",\"type\":\"uint128[]\"},{\"internalType\":\"uint128[]\",\"name\":\"balances1\",\"type\":\"uint128[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"findApprovalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"findApprovalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"lower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upper\",\"type\":\"int24\"}],\"name\":\"findMaxAddDouble\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAmount0\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountDesired\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"lower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upper\",\"type\":\"int24\"}],\"name\":\"findMaxAddSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"findPoolFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"poolFee\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upper\",\"type\":\"int24\"}],\"name\":\"getAmountsFromLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTick\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"cTick\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTickDeviation\",\"type\":\"uint256\"}],\"name\":\"getDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjusted\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPositionAmounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"currentTick\",\"type\":\"int24\"}],\"name\":\"getStartTickDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"getTickDistance\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tickDistance\",\"type\":\"int24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getV2RemovedLiqudityFeeOnTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"a0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ctlsNew\",\"type\":\"address\"}],\"name\":\"setCTLS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isV2\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"poolFee\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"zapFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutV2OrV3\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChainToolsV3Utils", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "42000", "ConstructorArguments": "000000000000000000000000dbecdd726f6ad8e24afc78fe3cc8eb7b73c2d94d000000000000000000000000ceb492c5e67385e2a08265352d646a0c32a5d085", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a58660a48ab2dc011b97e80b3f8f0e42b5e93f736cb96410943cb8fcb00d2b8b"}