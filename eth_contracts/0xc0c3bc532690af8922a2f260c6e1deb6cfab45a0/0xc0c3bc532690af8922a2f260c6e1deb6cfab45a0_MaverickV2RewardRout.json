{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@maverick/v2-common/contracts/base/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\ninterface IMulticall {\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/base/IPayableMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\ninterface IPayableMulticall {\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/base/PayableMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\nimport {IPayableMulticall} from \\\"./IPayableMulticall.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6ba452dea4258afe77726293435f10baf2bed265/contracts/utils/Multicall.sol\\n\\n/*\\n * @notice Payable multicall; requires all functions in the multicall to also be\\n * payable.\\n */\\nabstract contract PayableMulticall is IPayableMulticall {\\n    /**\\n     * @dev This function allows multiple calls to different contract functions\\n     * in a single transaction.\\n     * @param data An array of encoded function call data.\\n     * @return results An array of the results of the function calls.\\n     */\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IMaverickV2Pool} from \\\"./IMaverickV2Pool.sol\\\";\\n\\ninterface IMaverickV2Factory {\\n    error FactoryInvalidProtocolFeeRatio(uint8 protocolFeeRatioD3);\\n    error FactoryInvalidLendingFeeRate(uint256 protocolLendingFeeRateD18);\\n    error FactoryProtocolFeeOnRenounce(uint8 protocolFeeRatioD3);\\n    error FactorAlreadyInitialized();\\n    error FactorNotInitialized();\\n    error FactoryInvalidTokenOrder(IERC20 _tokenA, IERC20 _tokenB);\\n    error FactoryInvalidFee();\\n    error FactoryInvalidKinds(uint8 kinds);\\n    error FactoryInvalidTickSpacing(uint256 tickSpacing);\\n    error FactoryInvalidLookback(uint256 lookback);\\n    error FactoryInvalidTokenDecimals(uint8 decimalsA, uint8 decimalsB);\\n    error FactoryPoolAlreadyExists(\\n        uint256 feeAIn,\\n        uint256 feeBIn,\\n        uint256 tickSpacing,\\n        uint256 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint8 kinds,\\n        address accessor\\n    );\\n    error FactoryAccessorMustBeNonZero();\\n\\n    event PoolCreated(\\n        IMaverickV2Pool poolAddress,\\n        uint8 protocolFeeRatio,\\n        uint256 feeAIn,\\n        uint256 feeBIn,\\n        uint256 tickSpacing,\\n        uint256 lookback,\\n        int32 activeTick,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint8 kinds,\\n        address accessor\\n    );\\n    event SetFactoryProtocolFeeRatio(uint8 protocolFeeRatioD3);\\n    event SetFactoryProtocolLendingFeeRate(uint256 lendingFeeRateD18);\\n    event SetFactoryProtocolFeeReceiver(address receiver);\\n\\n    struct DeployParameters {\\n        uint64 feeAIn;\\n        uint64 feeBIn;\\n        uint32 lookback;\\n        int32 activeTick;\\n        uint64 tokenAScale;\\n        uint64 tokenBScale;\\n        // slot\\n        IERC20 tokenA;\\n        // slot\\n        IERC20 tokenB;\\n        // slot\\n        uint16 tickSpacing;\\n        uint8 options;\\n        address accessor;\\n    }\\n\\n    /**\\n     * @notice Called by deployer library to initialize a pool.\\n     */\\n    function deployParameters()\\n        external\\n        view\\n        returns (\\n            uint64 feeAIn,\\n            uint64 feeBIn,\\n            uint32 lookback,\\n            int32 activeTick,\\n            uint64 tokenAScale,\\n            uint64 tokenBScale,\\n            // slot\\n            IERC20 tokenA,\\n            // slot\\n            IERC20 tokenB,\\n            // slot\\n            uint16 tickSpacing,\\n            uint8 options,\\n            address accessor\\n        );\\n\\n    /**\\n     * @notice Create a new MaverickV2Pool with symmetric swap fees.\\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\\n     * D18 scale.\\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\\n     * bin width.\\n     * @param lookback Pool lookback in seconds.\\n     * @param tokenA Address of tokenA.\\n     * @param tokenB Address of tokenB.\\n     * @param activeTick Tick position that contains the active bins.\\n     * @param kinds 1-15 number to represent the active kinds\\n     * 0b0001 = static;\\n     * 0b0010 = right;\\n     * 0b0100 = left;\\n     * 0b1000 = both.\\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     */\\n    function create(\\n        uint64 fee,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds\\n    ) external returns (IMaverickV2Pool);\\n\\n    /**\\n     * @notice Create a new MaverickV2Pool.\\n     * @param feeAIn Fraction of the pool swap amount for tokenA-input swaps\\n     * that is retained as an LP in D18 scale.\\n     * @param feeBIn Fraction of the pool swap amount for tokenB-input swaps\\n     * that is retained as an LP in D18 scale.\\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\\n     * bin width.\\n     * @param lookback Pool lookback in seconds.\\n     * @param tokenA Address of tokenA.\\n     * @param tokenB Address of tokenB.\\n     * @param activeTick Tick position that contains the active bins.\\n     * @param kinds 1-15 number to represent the active kinds\\n     * 0b0001 = static;\\n     * 0b0010 = right;\\n     * 0b0100 = left;\\n     * 0b1000 = both.\\n     * e.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     */\\n    function create(\\n        uint64 feeAIn,\\n        uint64 feeBIn,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds\\n    ) external returns (IMaverickV2Pool);\\n\\n    /**\\n     * @notice Create a new MaverickV2PoolPermissioned with symmetric swap fees\\n     * with all functions permissioned.  Set fee to zero to make the pool fee settable by the accessor.\\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\\n     * D18 scale.\\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\\n     * bin width.\\n     * @param lookback Pool lookback in seconds.\\n     * @param tokenA Address of tokenA.\\n     * @param tokenB Address of tokenB.\\n     * @param activeTick Tick position that contains the active bins.\\n     * @param kinds 1-15 number to represent the active kinds\\n     * 0b0001 = static;\\n     * 0b0010 = right;\\n     * 0b0100 = left;\\n     * 0b1000 = both.\\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     * @param accessor Only address that can access the pool's public write functions.\\n     */\\n    function createPermissioned(\\n        uint64 fee,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds,\\n        address accessor\\n    ) external returns (IMaverickV2Pool);\\n\\n    /**\\n     * @notice Create a new MaverickV2PoolPermissioned with all functions\\n     * permissioned. Set fees to zero to make the pool fee settable by the\\n     * accessor.\\n     * @param feeAIn Fraction of the pool swap amount for tokenA-input swaps\\n     * that is retained as an LP in D18 scale.\\n     * @param feeBIn Fraction of the pool swap amount for tokenB-input swaps\\n     * that is retained as an LP in D18 scale.\\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\\n     * bin width.\\n     * @param lookback Pool lookback in seconds.\\n     * @param tokenA Address of tokenA.\\n     * @param tokenB Address of tokenB.\\n     * @param activeTick Tick position that contains the active bins.\\n     * @param kinds 1-15 number to represent the active kinds\\n     * 0b0001 = static;\\n     * 0b0010 = right;\\n     * 0b0100 = left;\\n     * 0b1000 = both.\\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     * @param accessor only address that can access the pool's public write functions.\\n     */\\n    function createPermissioned(\\n        uint64 feeAIn,\\n        uint64 feeBIn,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds,\\n        address accessor\\n    ) external returns (IMaverickV2Pool);\\n\\n    /**\\n     * @notice Create a new MaverickV2PoolPermissioned with the option to make\\n     * a subset of function permissionless. Set fee to zero to make the pool\\n     * fee settable by the accessor.\\n     * @param feeAIn Fraction of the pool swap amount for tokenA-input swaps\\n     * that is retained as an LP in D18 scale.\\n     * @param feeBIn Fraction of the pool swap amount for tokenB-input swaps\\n     * that is retained as an LP in D18 scale.\\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\\n     * bin width.\\n     * @param lookback Pool lookback in seconds.\\n     * @param tokenA Address of tokenA.\\n     * @param tokenB Address of tokenB.\\n     * @param activeTick Tick position that contains the active bins.\\n     * @param kinds 1-15 number to represent the active kinds\\n     * 0b0001 = static;\\n     * 0b0010 = right;\\n     * 0b0100 = left;\\n     * 0b1000 = both.\\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     * @param accessor only address that can access the pool's public permissioned write functions.\\n     * @param  permissionedLiquidity If true, then only accessor can call\\n     * pool's liquidity management functions: `flashLoan`,\\n     * `migrateBinsUpstack`, `addLiquidity`, `removeLiquidity`.\\n     * @param  permissionedSwap If true, then only accessor can call\\n     * pool's swap function.\\n     */\\n    function createPermissioned(\\n        uint64 feeAIn,\\n        uint64 feeBIn,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds,\\n        address accessor,\\n        bool permissionedLiquidity,\\n        bool permissionedSwap\\n    ) external returns (IMaverickV2Pool pool);\\n\\n    /**\\n     * @notice Update the protocol fee ratio for a pool. Can be called\\n     * permissionlessly allowing any user to sync the pool protocol fee value\\n     * with the factory protocol fee value.\\n     * @param pool The pool for which to update.\\n     */\\n    function updateProtocolFeeRatioForPool(IMaverickV2Pool pool) external;\\n\\n    /**\\n     * @notice Update the protocol lending fee rate for a pool. Can be called\\n     * permissionlessly allowing any user to sync the pool protocol lending fee\\n     * rate value with the factory value.\\n     * @param pool The pool for which to update.\\n     */\\n    function updateProtocolLendingFeeRateForPool(IMaverickV2Pool pool) external;\\n\\n    /**\\n     * @notice Claim protocol fee for a pool and transfer it to the protocolFeeReceiver.\\n     * @param pool The pool from which to claim the protocol fee.\\n     * @param isTokenA A boolean indicating whether tokenA (true) or tokenB\\n     * (false) is being collected.\\n     */\\n    function claimProtocolFeeForPool(IMaverickV2Pool pool, bool isTokenA) external;\\n\\n    /**\\n     * @notice Claim protocol fee for a pool and transfer it to the protocolFeeReceiver.\\n     * @param pool The pool from which to claim the protocol fee.\\n     */\\n    function claimProtocolFeeForPool(IMaverickV2Pool pool) external;\\n\\n    /**\\n     * @notice Bool indicating whether the pool was deployed from this factory.\\n     */\\n    function isFactoryPool(IMaverickV2Pool pool) external view returns (bool);\\n\\n    /**\\n     * @notice Address that receives the protocol fee when users call\\n     * `claimProtocolFeeForPool`.\\n     */\\n    function protocolFeeReceiver() external view returns (address);\\n\\n    /**\\n     * @notice Lookup a pool for given parameters.\\n     *\\n     * @dev  options bit map of kinds and function permissions\\n     * 0b000001 = static;\\n     * 0b000010 = right;\\n     * 0b000100 = left;\\n     * 0b001000 = both;\\n     * 0b010000 = liquidity functions are permissioned\\n     * 0b100000 = swap function is permissioned\\n     */\\n    function lookupPermissioned(\\n        uint256 feeAIn,\\n        uint256 feeBIn,\\n        uint256 tickSpacing,\\n        uint256 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint8 options,\\n        address accessor\\n    ) external view returns (IMaverickV2Pool);\\n\\n    /**\\n     * @notice Lookup a pool for given parameters.\\n     */\\n    function lookupPermissioned(\\n        IERC20 _tokenA,\\n        IERC20 _tokenB,\\n        address accessor,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Pool[] memory pools);\\n\\n    /**\\n     * @notice Lookup a pool for given parameters.\\n     */\\n    function lookupPermissioned(\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Pool[] memory pools);\\n\\n    /**\\n     * @notice Lookup a pool for given parameters.\\n     */\\n    function lookup(\\n        uint256 feeAIn,\\n        uint256 feeBIn,\\n        uint256 tickSpacing,\\n        uint256 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint8 kinds\\n    ) external view returns (IMaverickV2Pool);\\n\\n    /**\\n     * @notice Lookup a pool for given parameters.\\n     */\\n    function lookup(\\n        IERC20 _tokenA,\\n        IERC20 _tokenB,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Pool[] memory pools);\\n\\n    /**\\n     * @notice Lookup a pool for given parameters.\\n     */\\n    function lookup(uint256 startIndex, uint256 endIndex) external view returns (IMaverickV2Pool[] memory pools);\\n\\n    /**\\n     * @notice Count of permissionless pools.\\n     */\\n    function poolCount() external view returns (uint256 _poolCount);\\n\\n    /**\\n     * @notice Count of permissioned pools.\\n     */\\n    function poolPermissionedCount() external view returns (uint256 _poolCount);\\n\\n    /**\\n     * @notice Count of pools for a given accessor and token pair.  For\\n     * permissionless pools, pass `accessor = address(0)`.\\n     */\\n    function poolByTokenCount(\\n        IERC20 _tokenA,\\n        IERC20 _tokenB,\\n        address accessor\\n    ) external view returns (uint256 _poolCount);\\n\\n    /**\\n     * @notice Get the current factory owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Proportion of protocol fee to collect on each swap.  Value is in\\n     * 3-decimal format with a maximum value of 0.25e3.\\n     */\\n    function protocolFeeRatioD3() external view returns (uint8);\\n\\n    /**\\n     * @notice Fee rate charged by the protocol for flashloans.  Value is in\\n     * 18-decimal format with a maximum value of 0.02e18.\\n     */\\n    function protocolLendingFeeRateD18() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IMaverickV2Factory} from \\\"./IMaverickV2Factory.sol\\\";\\n\\ninterface IMaverickV2Pool {\\n    error PoolZeroLiquidityAdded();\\n    error PoolMinimumLiquidityNotMet();\\n    error PoolLocked();\\n    error PoolInvalidFee();\\n    error PoolTicksNotSorted(uint256 index, int256 previousTick, int256 tick);\\n    error PoolTicksAmountsLengthMismatch(uint256 ticksLength, uint256 amountsLength);\\n    error PoolBinIdsAmountsLengthMismatch(uint256 binIdsLength, uint256 amountsLength);\\n    error PoolKindNotSupported(uint256 kinds, uint256 kind);\\n    error PoolInsufficientBalance(uint256 deltaLpAmount, uint256 accountBalance);\\n    error PoolReservesExceedMaximum(uint256 amount);\\n    error PoolValueExceedsBits(uint256 amount, uint256 bits);\\n    error PoolTickMaxExceeded(uint256 tick);\\n    error PoolMigrateBinFirst();\\n    error PoolCurrentTickBeyondSwapLimit(int32 startingTick);\\n    error PoolSenderNotAccessor(address sender_, address accessor);\\n    error PoolSenderNotFactory(address sender_, address accessor);\\n    error PoolFunctionNotImplemented();\\n    error PoolTokenNotSolvent(uint256 internalReserve, uint256 tokenBalance, IERC20 token);\\n\\n    event PoolSwap(address sender, address recipient, SwapParams params, uint256 amountIn, uint256 amountOut);\\n\\n    event PoolAddLiquidity(\\n        address sender,\\n        address recipient,\\n        uint256 subaccount,\\n        AddLiquidityParams params,\\n        uint256 tokenAAmount,\\n        uint256 tokenBAmount,\\n        uint32[] binIds\\n    );\\n\\n    event PoolMigrateBinsUpStack(address sender, uint32 binId, uint32 maxRecursion);\\n\\n    event PoolRemoveLiquidity(\\n        address sender,\\n        address recipient,\\n        uint256 subaccount,\\n        RemoveLiquidityParams params,\\n        uint256 tokenAOut,\\n        uint256 tokenBOut\\n    );\\n\\n    event PoolSetVariableFee(uint256 newFeeAIn, uint256 newFeeBIn);\\n\\n    /**\\n     * @notice Tick state parameters.\\n     */\\n    struct TickState {\\n        uint128 reserveA;\\n        uint128 reserveB;\\n        uint128 totalSupply;\\n        uint32[4] binIdsByTick;\\n    }\\n\\n    /**\\n     * @notice Tick data parameters.\\n     * @param currentReserveA Current reserve of token A.\\n     * @param currentReserveB Current reserve of token B.\\n     * @param currentLiquidity Current liquidity amount.\\n     */\\n    struct TickData {\\n        uint256 currentReserveA;\\n        uint256 currentReserveB;\\n        uint256 currentLiquidity;\\n    }\\n\\n    /**\\n     * @notice Bin state parameters.\\n     * @param mergeBinBalance LP token balance that this bin possesses of the merge bin.\\n     * @param mergeId Bin ID of the bin that this bin has merged into.\\n     * @param totalSupply Total amount of LP tokens in this bin.\\n     * @param kind One of the 4 kinds (0=static, 1=right, 2=left, 3=both).\\n     * @param tick The lower price tick of the bin in its current state.\\n     * @param tickBalance Balance of the tick.\\n     */\\n    struct BinState {\\n        uint128 mergeBinBalance;\\n        uint128 tickBalance;\\n        uint128 totalSupply;\\n        uint8 kind;\\n        int32 tick;\\n        uint32 mergeId;\\n    }\\n\\n    /**\\n     * @notice Parameters for swap.\\n     * @param amount Amount of the token that is either the input if exactOutput is false\\n     * or the output if exactOutput is true.\\n     * @param tokenAIn Boolean indicating whether tokenA is the input.\\n     * @param exactOutput Boolean indicating whether the amount specified is\\n     * the exact output amount (true).\\n     * @param tickLimit The furthest tick a swap will execute in. If no limit\\n     * is desired, value should be set to type(int32).max for a tokenAIn swap\\n     * and type(int32).min for a swap where tokenB is the input.\\n     */\\n    struct SwapParams {\\n        uint256 amount;\\n        bool tokenAIn;\\n        bool exactOutput;\\n        int32 tickLimit;\\n    }\\n\\n    /**\\n     * @notice Parameters associated with adding liquidity.\\n     * @param kind One of the 4 kinds (0=static, 1=right, 2=left, 3=both).\\n     * @param ticks Array of ticks to add liquidity to.\\n     * @param amounts Array of bin LP amounts to add.\\n     */\\n    struct AddLiquidityParams {\\n        uint8 kind;\\n        int32[] ticks;\\n        uint128[] amounts;\\n    }\\n\\n    /**\\n     * @notice Parameters for each bin that will have liquidity removed.\\n     * @param binIds Index array of the bins losing liquidity.\\n     * @param amounts Array of bin LP amounts to remove.\\n     */\\n    struct RemoveLiquidityParams {\\n        uint32[] binIds;\\n        uint128[] amounts;\\n    }\\n\\n    /**\\n     * @notice State of the pool.\\n     * @param reserveA Pool tokenA balanceOf at end of last operation\\n     * @param reserveB Pool tokenB balanceOf at end of last operation\\n     * @param lastTwaD8 Value of log time weighted average price at last block.\\n     * Value is 8-decimal scale and is in the fractional tick domain.  E.g. a\\n     * value of 12.3e8 indicates the TWAP was 3/10ths of the way into the 12th\\n     * tick.\\n     * @param lastLogPriceD8 Value of log price at last block. Value is\\n     * 8-decimal scale and is in the fractional tick domain.  E.g. a value of\\n     * 12.3e8 indicates the price was 3/10ths of the way into the 12th tick.\\n     * @param lastTimestamp Last block.timestamp value in seconds for latest\\n     * swap transaction.\\n     * @param activeTick Current tick position that contains the active bins.\\n     * @param isLocked Pool isLocked, E.g., locked or unlocked; isLocked values\\n     * defined in Pool.sol.\\n     * @param binCounter Index of the last bin created.\\n     * @param protocolFeeRatioD3 Ratio of the swap fee that is kept for the\\n     * protocol.\\n     */\\n    struct State {\\n        uint128 reserveA;\\n        uint128 reserveB;\\n        int64 lastTwaD8;\\n        int64 lastLogPriceD8;\\n        uint40 lastTimestamp;\\n        int32 activeTick;\\n        bool isLocked;\\n        uint32 binCounter;\\n        uint8 protocolFeeRatioD3;\\n    }\\n\\n    /**\\n     * @notice Internal data used for data passing between Pool and Bin code.\\n     */\\n    struct BinDelta {\\n        uint128 deltaA;\\n        uint128 deltaB;\\n    }\\n\\n    /**\\n     * @notice 1-15 number to represent the active kinds.\\n     * @notice 0b0001 = static;\\n     * @notice 0b0010 = right;\\n     * @notice 0b0100 = left;\\n     * @notice 0b1000 = both;\\n     *\\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     */\\n    function kinds() external view returns (uint8 _kinds);\\n\\n    /**\\n     * @notice Returns whether a pool has permissioned functions. If true, the\\n     * `accessor()` of the pool can set the pool fees.  Other functions in the\\n     * pool may also be permissioned; whether or not they are can be determined\\n     * through calls to `permissionedLiquidity()` and `permissionedSwap()`.\\n     */\\n    function permissionedPool() external view returns (bool _permissionedPool);\\n\\n    /**\\n     * @notice Returns whether a pool has permissioned liquidity management\\n     * functions. If true, the pool is incompatible with permissioned pool\\n     * liquidity management infrastructure.\\n     */\\n    function permissionedLiquidity() external view returns (bool _permissionedLiquidity);\\n\\n    /**\\n     * @notice Returns whether a pool has a permissioned swap functions. If\\n     * true, the pool is incompatible with permissioned pool swap router\\n     * infrastructure.\\n     */\\n    function permissionedSwap() external view returns (bool _permissionedSwap);\\n\\n    /**\\n     * @notice Pool swap fee for the given direction (A-in or B-in swap) in\\n     * 18-decimal format. E.g. 0.01e18 is a 1% swap fee.\\n     */\\n    function fee(bool tokenAIn) external view returns (uint256);\\n\\n    /**\\n     * @notice TickSpacing of pool where 1.0001^tickSpacing is the bin width.\\n     */\\n    function tickSpacing() external view returns (uint256);\\n\\n    /**\\n     * @notice Lookback period of pool in seconds.\\n     */\\n    function lookback() external view returns (uint256);\\n\\n    /**\\n     * @notice Address of Pool accessor.  This is Zero address for\\n     * permissionless pools.\\n     */\\n    function accessor() external view returns (address);\\n\\n    /**\\n     * @notice Pool tokenA.  Address of tokenA is such that tokenA < tokenB.\\n     */\\n    function tokenA() external view returns (IERC20);\\n\\n    /**\\n     * @notice Pool tokenB.\\n     */\\n    function tokenB() external view returns (IERC20);\\n\\n    /**\\n     * @notice Deploying factory of the pool and also contract that has ability\\n     * to set and collect protocol fees for the pool.\\n     */\\n    function factory() external view returns (IMaverickV2Factory);\\n\\n    /**\\n     * @notice Most significant bit of scale value is a flag to indicate whether\\n     * tokenA has more or less than 18 decimals.  Scale is used in conjuction\\n     * with Math.toScale/Math.fromScale functions to convert from token amounts\\n     * to D18 scale internal pool accounting.\\n     */\\n    function tokenAScale() external view returns (uint256);\\n\\n    /**\\n     * @notice Most significant bit of scale value is a flag to indicate whether\\n     * tokenA has more or less than 18 decimals.  Scale is used in conjuction\\n     * with Math.toScale/Math.fromScale functions to convert from token amounts\\n     * to D18 scale internal pool accounting.\\n     */\\n    function tokenBScale() external view returns (uint256);\\n\\n    /**\\n     * @notice ID of bin at input tick position and kind.\\n     */\\n    function binIdByTickKind(int32 tick, uint256 kind) external view returns (uint32);\\n\\n    /**\\n     * @notice Accumulated tokenA protocol fee.\\n     */\\n    function protocolFeeA() external view returns (uint128);\\n\\n    /**\\n     * @notice Accumulated tokenB protocol fee.\\n     */\\n    function protocolFeeB() external view returns (uint128);\\n\\n    /**\\n     * @notice Lending fee rate on flash loans.\\n     */\\n    function lendingFeeRateD18() external view returns (uint256);\\n\\n    /**\\n     * @notice External function to get the current time-weighted average price.\\n     */\\n    function getCurrentTwa() external view returns (int256);\\n\\n    /**\\n     * @notice External function to get the state of the pool.\\n     */\\n    function getState() external view returns (State memory);\\n\\n    /**\\n     * @notice Return state of Bin at input binId.\\n     */\\n    function getBin(uint32 binId) external view returns (BinState memory bin);\\n\\n    /**\\n     * @notice Return state of Tick at input tick position.\\n     */\\n    function getTick(int32 tick) external view returns (TickState memory tickState);\\n\\n    /**\\n     * @notice Retrieves the balance of a user within a bin.\\n     * @param user The user's address.\\n     * @param subaccount The subaccount for the user.\\n     * @param binId The ID of the bin.\\n     */\\n    function balanceOf(address user, uint256 subaccount, uint32 binId) external view returns (uint128 lpToken);\\n\\n    /**\\n     * @notice Add liquidity to a pool. This function allows users to deposit\\n     * tokens into a liquidity pool.\\n     * @dev This function will call `maverickV2AddLiquidityCallback` on the\\n     * calling contract to collect the tokenA/tokenB payment.\\n     * @param recipient The account that will receive credit for the added liquidity.\\n     * @param subaccount The account that will receive credit for the added liquidity.\\n     * @param params Parameters containing the details for adding liquidity,\\n     * such as token types and amounts.\\n     * @param data Bytes information that gets passed to the callback.\\n     * @return tokenAAmount The amount of token A added to the pool.\\n     * @return tokenBAmount The amount of token B added to the pool.\\n     * @return binIds An array of bin IDs where the liquidity is stored.\\n     */\\n    function addLiquidity(\\n        address recipient,\\n        uint256 subaccount,\\n        AddLiquidityParams calldata params,\\n        bytes calldata data\\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds);\\n\\n    /**\\n     * @notice Removes liquidity from the pool.\\n     * @dev Liquidy can only be removed from a bin that is either unmerged or\\n     * has a mergeId of an unmerged bin.  If a bin is merged more than one\\n     * level deep, it must be migrated up the merge stack to the root bin\\n     * before liquidity removal.\\n     * @param recipient The address to receive the tokens.\\n     * @param subaccount The subaccount for the recipient.\\n     * @param params The parameters for removing liquidity.\\n     * @return tokenAOut The amount of token A received.\\n     * @return tokenBOut The amount of token B received.\\n     */\\n    function removeLiquidity(\\n        address recipient,\\n        uint256 subaccount,\\n        RemoveLiquidityParams calldata params\\n    ) external returns (uint256 tokenAOut, uint256 tokenBOut);\\n\\n    /**\\n     * @notice Migrate bins up the linked list of merged bins so that its\\n     * mergeId is the currrent active bin.\\n     * @dev Liquidy can only be removed from a bin that is either unmerged or\\n     * has a mergeId of an unmerged bin.  If a bin is merged more than one\\n     * level deep, it must be migrated up the merge stack to the root bin\\n     * before liquidity removal.\\n     * @param binId The ID of the bin to migrate.\\n     * @param maxRecursion The maximum recursion depth for the migration.\\n     */\\n    function migrateBinUpStack(uint32 binId, uint32 maxRecursion) external;\\n\\n    /**\\n     * @notice Swap tokenA/tokenB assets in the pool.  The swap user has two\\n     * options for funding their swap.\\n     * - The user can push the input token amount to the pool before calling\\n     * the swap function. In order to avoid having the pool call the callback,\\n     * the user should pass a zero-length `data` bytes object with the swap\\n     * call.\\n     * - The user can send the input token amount to the pool when the pool\\n     * calls the `maverickV2SwapCallback` function on the calling contract.\\n     * That callback has input parameters that specify the token address of the\\n     * input token, the input and output amounts, and the bytes data sent to\\n     * the swap function.\\n     * @dev  If the users elects to do a callback-based swap, the output\\n     * assets will be sent before the callback is called, allowing the user to\\n     * execute flash swaps.  However, the pool does have reentrancy protection,\\n     * so a swapper will not be able to interact with the same pool again\\n     * while they are in the callback function.\\n     * @param recipient The address to receive the output tokens.\\n     * @param params Parameters containing the details of the swap\\n     * @param data Bytes information that gets passed to the callback.\\n     */\\n    function swap(\\n        address recipient,\\n        SwapParams memory params,\\n        bytes calldata data\\n    ) external returns (uint256 amountIn, uint256 amountOut);\\n\\n    /**\\n     * @notice Loan tokenA/tokenB assets from the pool to recipient. The fee\\n     * rate of a loan is determined by `lendingFeeRateD18`, which is set at the\\n     * protocol level by the factory.  This function calls\\n     * `maverickV2FlashLoanCallback` on the calling contract.  At the end of\\n     * the callback, the caller must pay back the loan with fee (if there is a\\n     * fee).\\n     * @param recipient The address to receive the loaned tokens.\\n     * @param amountB Loan amount of tokenA sent to recipient.\\n     * @param amountB Loan amount of tokenB sent to recipient.\\n     * @param data Bytes information that gets passed to the callback.\\n     */\\n    function flashLoan(\\n        address recipient,\\n        uint256 amountA,\\n        uint256 amountB,\\n        bytes calldata data\\n    ) external returns (uint128 lendingFeeA, uint128 lendingFeeB);\\n\\n    /**\\n     * @notice Sets fee for permissioned pools.  May only be called by the\\n     * accessor.\\n     */\\n    function setFee(uint256 newFeeAIn, uint256 newFeeBIn) external;\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\n// factory contraints on pools\\nuint8 constant MAX_PROTOCOL_FEE_RATIO_D3 = 0.25e3; // 25%\\nuint256 constant MAX_PROTOCOL_LENDING_FEE_RATE_D18 = 0.02e18; // 2%\\nuint64 constant MAX_POOL_FEE_D18 = 0.9e18; // 90%\\nuint64 constant MIN_LOOKBACK = 1 seconds;\\nuint64 constant MAX_TICK_SPACING = 10_000;\\n\\n// pool constraints\\nuint8 constant NUMBER_OF_KINDS = 4;\\nint32 constant NUMBER_OF_KINDS_32 = int32(int8(NUMBER_OF_KINDS));\\nuint256 constant MAX_TICK = 322_378; // max price 1e14 in D18 scale\\nint32 constant MAX_TICK_32 = int32(int256(MAX_TICK));\\nint32 constant MIN_TICK_32 = int32(-int256(MAX_TICK));\\nuint256 constant MAX_BINS_TO_MERGE = 3;\\nuint128 constant MINIMUM_LIQUIDITY = 1e8;\\n\\n// accessor named constants\\nuint8 constant ALL_KINDS_MASK = 0xF; // 0b1111\\nuint8 constant PERMISSIONED_LIQUIDITY_MASK = 0x10; // 0b010000\\nuint8 constant PERMISSIONED_SWAP_MASK = 0x20; // 0b100000\\nuint8 constant OPTIONS_MASK = ALL_KINDS_MASK | PERMISSIONED_LIQUIDITY_MASK | PERMISSIONED_SWAP_MASK; // 0b111111\\n\\n// named values\\naddress constant MERGED_LP_BALANCE_ADDRESS = address(0);\\nuint256 constant MERGED_LP_BALANCE_SUBACCOUNT = 0;\\nuint128 constant ONE = 1e18;\\nuint128 constant ONE_SQUARED = 1e36;\\nint256 constant INT256_ONE = 1e18;\\nuint256 constant ONE_D8 = 1e8;\\nuint256 constant ONE_D3 = 1e3;\\nint40 constant INT_ONE_D8 = 1e8;\\nint40 constant HALF_TICK_D8 = 0.5e8;\\nuint8 constant DEFAULT_DECIMALS = 18;\\nuint256 constant DEFAULT_SCALE = 1;\\nbytes constant EMPTY_PRICE_BREAKS = hex\\\"010000000000000000000000\\\";\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\nimport {Math as OzMath} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport {ONE, DEFAULT_SCALE, DEFAULT_DECIMALS, INT_ONE_D8, ONE_SQUARED} from \\\"./Constants.sol\\\";\\n\\n/**\\n * @notice Math functions.\\n */\\nlibrary Math {\\n    /**\\n     * @notice Returns the lesser of two values.\\n     * @param x First uint256 value.\\n     * @param y Second uint256 value.\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the lesser of two uint128 values.\\n     * @param x First uint128 value.\\n     * @param y Second uint128 value.\\n     */\\n    function min128(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the lesser of two int256 values.\\n     * @param x First int256 value.\\n     * @param y Second int256 value.\\n     */\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the greater of two uint256 values.\\n     * @param x First uint256 value.\\n     * @param y Second uint256 value.\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the greater of two int256 values.\\n     * @param x First int256 value.\\n     * @param y Second int256 value.\\n     */\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the greater of two uint128 values.\\n     * @param x First uint128 value.\\n     * @param y Second uint128 value.\\n     */\\n    function max128(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Thresholds a value to be within the specified bounds.\\n     * @param value The value to bound.\\n     * @param lowerLimit The minimum allowable value.\\n     * @param upperLimit The maximum allowable value.\\n     */\\n    function boundValue(\\n        uint256 value,\\n        uint256 lowerLimit,\\n        uint256 upperLimit\\n    ) internal pure returns (uint256 outputValue) {\\n        outputValue = min(max(value, lowerLimit), upperLimit);\\n    }\\n\\n    /**\\n     * @notice Returns the difference between two uint128 values or zero if the result would be negative.\\n     * @param x The minuend.\\n     * @param y The subtrahend.\\n     */\\n    function clip128(uint128 x, uint128 y) internal pure returns (uint128) {\\n        unchecked {\\n            return x < y ? 0 : x - y;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the difference between two uint256 values or zero if the result would be negative.\\n     * @param x The minuend.\\n     * @param y The subtrahend.\\n     */\\n    function clip(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            return x < y ? 0 : x - y;\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one uint256 by another, rounding down to the nearest\\n     * integer.\\n     * @param x The dividend.\\n     * @param y The divisor.\\n     */\\n    function divFloor(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivFloor(x, ONE, y);\\n    }\\n\\n    /**\\n     * @notice Divides one uint256 by another, rounding up to the nearest integer.\\n     * @param x The dividend.\\n     * @param y The divisor.\\n     */\\n    function divCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivCeil(x, ONE, y);\\n    }\\n\\n    /**\\n     * @notice Multiplies two uint256 values and then divides by ONE, rounding down.\\n     * @param x The multiplicand.\\n     * @param y The multiplier.\\n     */\\n    function mulFloor(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return OzMath.mulDiv(x, y, ONE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two uint256 values and then divides by ONE, rounding up.\\n     * @param x The multiplicand.\\n     * @param y The multiplier.\\n     */\\n    function mulCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivCeil(x, y, ONE);\\n    }\\n\\n    /**\\n     * @notice Calculates the multiplicative inverse of a uint256, rounding down.\\n     * @param x The value to invert.\\n     */\\n    function invFloor(uint256 x) internal pure returns (uint256) {\\n        unchecked {\\n            return ONE_SQUARED / x;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the multiplicative inverse of a uint256, rounding up.\\n     * @param denominator The value to invert.\\n     */\\n    function invCeil(uint256 denominator) internal pure returns (uint256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            // divide z - 1 by the denominator and add 1.\\n            z := add(div(sub(ONE_SQUARED, 1), denominator), 1)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two uint256 values and divides by a third, rounding down.\\n     * @param x The multiplicand.\\n     * @param y The multiplier.\\n     * @param k The divisor.\\n     */\\n    function mulDivFloor(uint256 x, uint256 y, uint256 k) internal pure returns (uint256 result) {\\n        result = OzMath.mulDiv(x, y, max(1, k));\\n    }\\n\\n    /**\\n     * @notice Multiplies two uint256 values and divides by a third, rounding up if there's a remainder.\\n     * @param x The multiplicand.\\n     * @param y The multiplier.\\n     * @param k The divisor.\\n     */\\n    function mulDivCeil(uint256 x, uint256 y, uint256 k) internal pure returns (uint256 result) {\\n        result = mulDivFloor(x, y, k);\\n        if (mulmod(x, y, max(1, k)) != 0) result = result + 1;\\n    }\\n\\n    /**\\n     * @notice Multiplies two uint256 values and divides by a third, rounding\\n     * down. Will revert if `x * y` is larger than `type(uint256).max`.\\n     * @param x The first operand for multiplication.\\n     * @param y The second operand for multiplication.\\n     * @param denominator The divisor after multiplication.\\n     */\\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n            if iszero(denominator) {\\n                denominator := 1\\n            }\\n\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two uint256 values and divides by a third, rounding\\n     * up. Will revert if `x * y` is larger than `type(uint256).max`.\\n     * @param x The first operand for multiplication.\\n     * @param y The second operand for multiplication.\\n     * @param denominator The divisor after multiplication.\\n     */\\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n            if iszero(denominator) {\\n                denominator := 1\\n            }\\n\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies a uint256 by another and divides by a constant,\\n     * rounding down. Will revert if `x * y` is larger than\\n     * `type(uint256).max`.\\n     * @param x The multiplicand.\\n     * @param y The multiplier.\\n     */\\n    function mulDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, ONE);\\n    }\\n\\n    /**\\n     * @notice Divides a uint256 by another, rounding down the result. Will\\n     * revert if `x * 1e18` is larger than `type(uint256).max`.\\n     * @param x The dividend.\\n     * @param y The divisor.\\n     */\\n    function divDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, ONE, y);\\n    }\\n\\n    /**\\n     * @notice Divides a uint256 by another, rounding up the result. Will\\n     * revert if `x * 1e18` is larger than `type(uint256).max`.\\n     * @param x The dividend.\\n     * @param y The divisor.\\n     */\\n    function divUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, ONE, y);\\n    }\\n\\n    /**\\n     * @notice Scales a number based on a difference in decimals from a default.\\n     * @param decimals The new decimal precision.\\n     */\\n    function scale(uint8 decimals) internal pure returns (uint256) {\\n        unchecked {\\n            if (decimals == DEFAULT_DECIMALS) {\\n                return DEFAULT_SCALE;\\n            } else {\\n                return 10 ** (DEFAULT_DECIMALS - decimals);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adjusts a scaled amount to the token decimal scale.\\n     * @param amount The scaled amount.\\n     * @param scaleFactor The scaling factor to adjust by.\\n     * @param ceil Whether to round up (true) or down (false).\\n     */\\n    function ammScaleToTokenScale(uint256 amount, uint256 scaleFactor, bool ceil) internal pure returns (uint256 z) {\\n        unchecked {\\n            if (scaleFactor == DEFAULT_SCALE || amount == 0) {\\n                return amount;\\n            } else {\\n                if (!ceil) return amount / scaleFactor;\\n                assembly (\\\"memory-safe\\\") {\\n                    z := add(div(sub(amount, 1), scaleFactor), 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adjusts a token amount to the D18 AMM scale.\\n     * @param amount The amount in token scale.\\n     * @param scaleFactor The scale factor for adjustment.\\n     */\\n    function tokenScaleToAmmScale(uint256 amount, uint256 scaleFactor) internal pure returns (uint256) {\\n        if (scaleFactor == DEFAULT_SCALE) {\\n            return amount;\\n        } else {\\n            return amount * scaleFactor;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of a signed 32-bit integer.\\n     * @param x The integer to take the absolute value of.\\n     */\\n    function abs32(int32 x) internal pure returns (uint32) {\\n        unchecked {\\n            return uint32(x < 0 ? -x : x);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of a signed 256-bit integer.\\n     * @param x The integer to take the absolute value of.\\n     */\\n    function abs(int256 x) internal pure returns (uint256) {\\n        unchecked {\\n            return uint256(x < 0 ? -x : x);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the integer square root of a uint256 rounded down.\\n     * @param x The number to take the square root of.\\n     */\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        // from https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/FixedPointMathLib.sol\\n        assembly (\\\"memory-safe\\\") {\\n            let y := x\\n            z := 181\\n\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            z := shr(18, mul(z, add(y, 65536)))\\n\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes the floor of a D8-scaled number as an int32, ignoring\\n     * potential overflow in the cast.\\n     * @param val The D8-scaled number.\\n     */\\n    function floorD8Unchecked(int256 val) internal pure returns (int32) {\\n        int32 val32;\\n        bool check;\\n        unchecked {\\n            val32 = int32(val / INT_ONE_D8);\\n            check = (val < 0 && val % INT_ONE_D8 != 0);\\n        }\\n        return check ? val32 - 1 : val32;\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/libraries/PoolLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\nimport {SafeCast as Cast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {IMaverickV2Pool} from \\\"../interfaces/IMaverickV2Pool.sol\\\";\\nimport {TickMath} from \\\"./TickMath.sol\\\";\\nimport {Math} from \\\"./Math.sol\\\";\\n\\n/**\\n * @notice Library of pool functions.\\n */\\nlibrary PoolLib {\\n    using Cast for uint256;\\n\\n    struct AddLiquidityInfo {\\n        uint256 deltaA;\\n        uint256 deltaB;\\n        bool tickLtActive;\\n        uint256 tickSpacing;\\n        int32 tick;\\n    }\\n\\n    /**\\n     * @notice Check to ensure that the ticks are in ascending order and amount\\n     * array is same length as tick array.\\n     * @param ticks An array of int32 values representing ticks to be checked.\\n     * @param amountsLength Amount array length.\\n     */\\n    function uniqueOrderedTicksCheck(int32[] memory ticks, uint256 amountsLength) internal pure {\\n        unchecked {\\n            if (ticks.length != amountsLength)\\n                revert IMaverickV2Pool.PoolTicksAmountsLengthMismatch(ticks.length, amountsLength);\\n            int32 lastTick = type(int32).min;\\n            for (uint256 i; i < ticks.length; ) {\\n                if (ticks[i] <= lastTick) revert IMaverickV2Pool.PoolTicksNotSorted(i, lastTick, ticks[i]);\\n                lastTick = ticks[i];\\n                i = i + 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Compute bin reserves assuming the bin is not merged; not accurate\\n     * reflection of reserves for merged bins.\\n     * @param bin The storage reference to the state for this bin.\\n     * @param tick The memory reference to the state for this tick.\\n     * @return reserveA The reserve amount for token A.\\n     * @return reserveB The reserve amount for token B.\\n     */\\n    function binReserves(\\n        IMaverickV2Pool.BinState storage bin,\\n        IMaverickV2Pool.TickState memory tick\\n    ) internal view returns (uint128 reserveA, uint128 reserveB) {\\n        return binReserves(bin.tickBalance, tick.reserveA, tick.reserveB, tick.totalSupply);\\n    }\\n\\n    /**\\n     * @notice Compute bin reserves assuming the bin is not merged; not accurate\\n     * reflection of reserves for merged bins.\\n     * @param tickBalance Bin's balance in the tick.\\n     * @param tickReserveA Tick's tokenA reserves.\\n     * @param tickReserveB Tick's tokenB reserves.\\n     * @param tickTotalSupply Tick total supply of bin balances.\\n     */\\n    function binReserves(\\n        uint128 tickBalance,\\n        uint128 tickReserveA,\\n        uint128 tickReserveB,\\n        uint128 tickTotalSupply\\n    ) internal pure returns (uint128 reserveA, uint128 reserveB) {\\n        if (tickTotalSupply != 0) {\\n            reserveA = reserveValue(tickReserveA, tickBalance, tickTotalSupply);\\n            reserveB = reserveValue(tickReserveB, tickBalance, tickTotalSupply);\\n        }\\n    }\\n\\n    /**\\n     * @notice Reserves of a bin in a tick.\\n     * @param tickReserve Tick reserve amount in a given token.\\n     * @param tickBalance Bin's balance in the tick.\\n     * @param tickTotalSupply Tick total supply of bin balances.\\n     */\\n    function reserveValue(\\n        uint128 tickReserve,\\n        uint128 tickBalance,\\n        uint128 tickTotalSupply\\n    ) internal pure returns (uint128 reserve) {\\n        reserve = Math.mulDivFloor(tickReserve, tickBalance, tickTotalSupply).toUint128();\\n        reserve = Math.min128(tickReserve, reserve);\\n    }\\n\\n    /**\\n     * @notice Calculate delta A, delta B, and delta Tick Balance based on delta\\n     * LP balance and the Tick/Bin state.\\n     */\\n    function deltaTickBalanceFromDeltaLpBalance(\\n        uint256 binTickBalance,\\n        uint256 binTotalSupply,\\n        IMaverickV2Pool.TickState memory tickState,\\n        uint128 deltaLpBalance,\\n        AddLiquidityInfo memory addLiquidityInfo\\n    ) internal pure returns (uint256 deltaTickBalance) {\\n        unchecked {\\n            if (tickState.reserveA != 0 || tickState.reserveB != 0) {\\n                // if there are already reserves, then we just contribute pro rata\\n                // deltaLiquidity = deltaBinLP / binTS * binTickBalance / tickTS * tickL\\n                uint256 numerator = Math.max(1, binTickBalance) * uint256(deltaLpBalance);\\n                uint256 denominator = Math.max(1, tickState.totalSupply) * Math.max(1, binTotalSupply);\\n                addLiquidityInfo.deltaA = Math.mulDivCeil(tickState.reserveA, numerator, denominator);\\n                addLiquidityInfo.deltaB = Math.mulDivCeil(tickState.reserveB, numerator, denominator);\\n            } else {\\n                _setRequiredDeltaReservesForEmptyTick(deltaLpBalance, addLiquidityInfo);\\n            }\\n\\n            // round down the amount credited to the tick; this could lead to a\\n            // small add amount getting zero reserves credit.\\n            deltaTickBalance = tickState.totalSupply == 0\\n                ? deltaLpBalance\\n                : Math.mulDivDown(deltaLpBalance, Math.max(1, binTickBalance), binTotalSupply);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates deltaA = liquidity * (sqrt(upper) - sqrt(lower))\\n     * @notice Calculates deltaB = liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n     * @notice i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n     * @notice we set liquidity = deltaLpBalance / (1.0001^(tick * tickspacing) - 1)\\n     * @notice which simplifies the A/B amounts to:\\n     * @notice deltaA = deltaLpBalance * sqrt(lower)\\n     * @notice deltaB = deltaLpBalance / sqrt(upper)\\n     */\\n    function _setRequiredDeltaReservesForEmptyTick(\\n        uint128 deltaLpBalance,\\n        AddLiquidityInfo memory addLiquidityInfo\\n    ) internal pure {\\n        // No reserves, so we will use deltaLpBalance as liquidity to be added.\\n        // In this logic branch, the tick is empty, so we know the tick will be\\n        // a one-asset add.\\n        (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(\\n            addLiquidityInfo.tickSpacing,\\n            addLiquidityInfo.tick\\n        );\\n\\n        addLiquidityInfo.deltaA = addLiquidityInfo.tickLtActive ? Math.mulCeil(deltaLpBalance, sqrtLowerTickPrice) : 0;\\n        addLiquidityInfo.deltaB = addLiquidityInfo.tickLtActive ? 0 : Math.divCeil(deltaLpBalance, sqrtUpperTickPrice);\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\nimport {Math as OzMath} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {Math} from \\\"./Math.sol\\\";\\nimport {MAX_TICK, ONE} from \\\"./Constants.sol\\\";\\n\\n/**\\n * @notice Math functions related to tick operations.\\n */\\nlibrary TickMath {\\n    using Math for uint256;\\n\\n    error TickMaxExceeded(int256 tick);\\n\\n    /**\\n     * @notice Compute the lower and upper sqrtPrice of a tick.\\n     * @param tickSpacing The tick spacing used for calculations.\\n     * @param _tick The input tick value.\\n     */\\n    function tickSqrtPrices(\\n        uint256 tickSpacing,\\n        int32 _tick\\n    ) internal pure returns (uint256 sqrtLowerPrice, uint256 sqrtUpperPrice) {\\n        unchecked {\\n            sqrtLowerPrice = tickSqrtPrice(tickSpacing, _tick);\\n            sqrtUpperPrice = tickSqrtPrice(tickSpacing, _tick + 1);\\n        }\\n    }\\n\\n    /**\\n     * @notice Compute the base tick value from the pool tick and the\\n     * tickSpacing.  Revert if base tick is beyond the max tick boundary.\\n     * @param tickSpacing The tick spacing used for calculations.\\n     * @param _tick The input tick value.\\n     */\\n    function subTickIndex(uint256 tickSpacing, int32 _tick) internal pure returns (uint32 subTick) {\\n        subTick = Math.abs32(_tick);\\n        subTick *= uint32(tickSpacing);\\n        if (subTick > MAX_TICK) {\\n            revert TickMaxExceeded(_tick);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the square root price for a given tick and tick spacing.\\n     * @param tickSpacing The tick spacing used for calculations.\\n     * @param _tick The input tick value.\\n     * @return _result The square root price.\\n     */\\n    function tickSqrtPrice(uint256 tickSpacing, int32 _tick) internal pure returns (uint256 _result) {\\n        unchecked {\\n            uint256 tick = subTickIndex(tickSpacing, _tick);\\n\\n            uint256 ratio = tick & 0x1 != 0 ? 0xfffcb933bd6fad9d3af5f0b9f25db4d6 : 0x100000000000000000000000000000000;\\n            if (tick & 0x2 != 0) ratio = (ratio * 0xfff97272373d41fd789c8cb37ffcaa1c) >> 128;\\n            if (tick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656ac9229c67059486f389) >> 128;\\n            if (tick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e81259b3cddc7a064941) >> 128;\\n            if (tick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f67b19e8887e0bd251eb7) >> 128;\\n            if (tick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98cd2e57b660be99eb2c4a) >> 128;\\n            if (tick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c9838804e327cb417cafcb) >> 128;\\n            if (tick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99d51e2cc356c2f617dbe0) >> 128;\\n            if (tick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900aecf64236ab31f1f9dcb5) >> 128;\\n            if (tick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac4d9194200696907cf2e37) >> 128;\\n            if (tick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b88206f8abe8a3b44dd9be) >> 128;\\n            if (tick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c578ef4f1d17b2b235d480) >> 128;\\n            if (tick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd254ee83bdd3f248e7e785e) >> 128;\\n            if (tick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d8f7dd10e744d913d033333) >> 128;\\n            if (tick & 0x4000 != 0) ratio = (ratio * 0x70d869a156ddd32a39e257bc3f50aa9b) >> 128;\\n            if (tick & 0x8000 != 0) ratio = (ratio * 0x31be135f97da6e09a19dc367e3b6da40) >> 128;\\n            if (tick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7e5a9780b0cc4e25d61a56) >> 128;\\n            if (tick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedbcb3a6ccb7ce618d14225) >> 128;\\n            if (tick & 0x40000 != 0) ratio = (ratio * 0x2216e584f630389b2052b8db590e) >> 128;\\n            if (_tick > 0) ratio = type(uint256).max / ratio;\\n            _result = (ratio * ONE) >> 128;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate liquidity of a tick.\\n     * @param reserveA Tick reserve of token A.\\n     * @param reserveB Tick reserve of token B.\\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\\n     */\\n    function getTickL(\\n        uint256 reserveA,\\n        uint256 reserveB,\\n        uint256 sqrtLowerTickPrice,\\n        uint256 sqrtUpperTickPrice\\n    ) internal pure returns (uint256 liquidity) {\\n        // known:\\n        // - sqrt price values are different\\n        // - reserveA and reserveB fit in 128 bit\\n        // - sqrt price is in (1e-7, 1e7)\\n        // - D18 max for uint256 is 1.15e59\\n        // - D18 min is 1e-18\\n\\n        unchecked {\\n            // diff is in (5e-12, 4e6); max tick spacing is 10_000\\n            uint256 diff = sqrtUpperTickPrice - sqrtLowerTickPrice;\\n\\n            // Need to maximize precision by shifting small values A and B up so\\n            // that they use more of the available bit range. Two constraints to\\n            // consider: we need A * B * diff / sqrtPrice to be bigger than 1e-18\\n            // when the bump is not in play.  This constrains the threshold for\\n            // bumping to be at least 77 bit; ie, either a or b needs 2^77 which\\n            // means that term A * B * diff / sqrtPrice > 1e-18.\\n            //\\n            // At the other end, the second constraint is that b^2 needs to fit in\\n            // a 256-bit number, so, post bump, the max reserve value needs to be\\n            // less than 6e22. With a 78-bit threshold and a 57-bit bump, we have A\\n            // and B are in (1.4e-1, 4.4e22 (2^(78+57))) with bump, and one of A or\\n            // B is at least 2^78 without the bump, but the other reserve value may\\n            // be as small as 1 wei.\\n            uint256 precisionBump = 0;\\n            if ((reserveA >> 78) == 0 && (reserveB >> 78) == 0) {\\n                precisionBump = 57;\\n                reserveA <<= precisionBump;\\n                reserveB <<= precisionBump;\\n            }\\n\\n            if (reserveB == 0) return Math.divDown(reserveA, diff) >> precisionBump;\\n            if (reserveA == 0)\\n                return Math.mulDivDown(reserveB.mulDown(sqrtLowerTickPrice), sqrtUpperTickPrice, diff) >> precisionBump;\\n\\n            // b is in (7.2e-9 (2^57 / 1e7 / 2), 2.8e29  (2^(78+57) * 1e7 / 2)) with bump\\n            // b is in a subset of the same range without bump\\n            uint256 b = (reserveA.divDown(sqrtUpperTickPrice) + reserveB.mulDown(sqrtLowerTickPrice)) >> 1;\\n\\n            // b^2 is in (5.1e-17, 4.8e58); and will not overflow on either end;\\n            // A*B is in (3e-13 (2^78 / 1e18 * 1e-18), 1.9e45) without bump and is in a subset range with bump\\n            // A*B*diff/sqrtUpper is in (1.5e-17 (3e-13 * 5e-12 * 1e7), 7.6e58);\\n\\n            // Since b^2 is at the upper edge of the precision range, we are not\\n            // able to multiply the argument of the sqrt by 1e18, instead, we move\\n            // this factor outside of the sqrt. The resulting loss of precision\\n            // means that this liquidity value is a lower bound on the tick\\n            // liquidity\\n            return\\n                OzMath.mulDiv(\\n                    b +\\n                        Math.sqrt(\\n                            (OzMath.mulDiv(b, b, ONE) +\\n                                OzMath.mulDiv(reserveB.mulFloor(reserveA), diff, sqrtUpperTickPrice))\\n                        ) *\\n                        1e9,\\n                    sqrtUpperTickPrice,\\n                    diff\\n                ) >> precisionBump;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate square root price of a tick. Returns left edge of the\\n     * tick if the tick has no reserves.\\n     * @param reserveA Tick reserve of token A.\\n     * @param reserveB Tick reserve of token B.\\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\\n     * @return sqrtPrice The calculated square root price.\\n     */\\n    function getSqrtPrice(\\n        uint256 reserveA,\\n        uint256 reserveB,\\n        uint256 sqrtLowerTickPrice,\\n        uint256 sqrtUpperTickPrice,\\n        uint256 liquidity\\n    ) internal pure returns (uint256 sqrtPrice) {\\n        unchecked {\\n            if (reserveA == 0) {\\n                return sqrtLowerTickPrice;\\n            }\\n            if (reserveB == 0) {\\n                return sqrtUpperTickPrice;\\n            }\\n            sqrtPrice = Math.sqrt(\\n                ONE *\\n                    (reserveA + liquidity.mulDown(sqrtLowerTickPrice)).divDown(\\n                        reserveB + liquidity.divDown(sqrtUpperTickPrice)\\n                    )\\n            );\\n            sqrtPrice = Math.boundValue(sqrtPrice, sqrtLowerTickPrice, sqrtUpperTickPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate square root price of a tick. Returns left edge of the\\n     * tick if the tick has no reserves.\\n     * @param reserveA Tick reserve of token A.\\n     * @param reserveB Tick reserve of token B.\\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\\n     * @return sqrtPrice The calculated square root price.\\n     * @return liquidity The calculated liquidity.\\n     */\\n    function getTickSqrtPriceAndL(\\n        uint256 reserveA,\\n        uint256 reserveB,\\n        uint256 sqrtLowerTickPrice,\\n        uint256 sqrtUpperTickPrice\\n    ) internal pure returns (uint256 sqrtPrice, uint256 liquidity) {\\n        liquidity = getTickL(reserveA, reserveB, sqrtLowerTickPrice, sqrtUpperTickPrice);\\n        sqrtPrice = getSqrtPrice(reserveA, reserveB, sqrtLowerTickPrice, sqrtUpperTickPrice, liquidity);\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-common/contracts/libraries/TransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// As the copyright holder of this work, Ubiquity Labs retains\\n// the right to distribute, use, and modify this code under any license of\\n// their choosing, in addition to the terms of the GPL-v2 or later.\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @notice Low-gas transfer functions.\\n */\\nlibrary TransferLib {\\n    error TransferFailed(IERC20 token, address to, uint256 amount);\\n    error TransferFromFailed(IERC20 token, address from, address to, uint256 amount);\\n\\n    // implementation adapted from\\n    // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\\n\\n    /**\\n     * @notice Transfer token amount.  Amount is sent from caller address to `to` address.\\n     */\\n    function transfer(IERC20 token, address to, uint256 amount) internal {\\n        bool success;\\n        assembly (\\\"memory-safe\\\") {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(memPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            // Append arguments. Addresses are assumed clean. Transfer will fail otherwise.\\n            mstore(add(memPointer, 0x4), to)\\n            mstore(add(memPointer, 0x24), amount) // Append the \\\"amount\\\" argument.\\n            // 68 bytes total\\n\\n            // fail if reverted; only allocate 32 bytes for return to ensure we\\n            // only use mem slot 0 which is scatch space and memory safe to use.\\n            success := call(gas(), token, 0, memPointer, 68, 0, 32)\\n            // handle transfers that return 1/true and ensure the value is from\\n            // the return and not dirty bits left in the scratch space.\\n            let returnedOne := and(eq(mload(0), 1), gt(returndatasize(), 31))\\n            // handle transfers that return nothing\\n            let noReturn := iszero(returndatasize())\\n            // good if didn't revert and the return is either empty or true\\n            success := and(success, or(returnedOne, noReturn))\\n        }\\n\\n        if (!success) revert TransferFailed(token, to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer token amount.  Amount is sent from `from` address to `to` address.\\n     */\\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(memPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            // Append arguments. Addresses are assumed clean. Transfer will fail otherwise.\\n            mstore(add(memPointer, 0x4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(memPointer, 0x24), to) // Append the \\\"to\\\" argument.\\n            mstore(add(memPointer, 0x44), amount) // Append the \\\"amount\\\" argument.\\n            // 100 bytes total\\n\\n            // fail if reverted; only allocate 32 bytes for return to ensure we\\n            // only use mem slot 0 which is scatch space and memory safe to use.\\n            success := call(gas(), token, 0, memPointer, 100, 0, 32)\\n            // handle transfers that return 1/true and ensure the value is from\\n            // the return and not dirty bits left in the scratch space.\\n            let returnedOne := and(eq(mload(0), 1), gt(returndatasize(), 31))\\n            // handle transfers that return nothing\\n            let noReturn := iszero(returndatasize())\\n            // good if didn't revert and the return is either empty or true\\n            success := and(success, or(returnedOne, noReturn))\\n        }\\n\\n        if (!success) revert TransferFromFailed(token, from, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2Reward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {INft} from \\\"@maverick/v2-supplemental/contracts/positionbase/INft.sol\\\";\\nimport {IMulticall} from \\\"@maverick/v2-common/contracts/base/IMulticall.sol\\\";\\n\\nimport {IMaverickV2VotingEscrow} from \\\"./IMaverickV2VotingEscrow.sol\\\";\\nimport {IMaverickV2RewardVault} from \\\"./IMaverickV2RewardVault.sol\\\";\\nimport {IRewardAccounting} from \\\"../rewardbase/IRewardAccounting.sol\\\";\\n\\ninterface IMaverickV2Reward is INft, IMulticall, IRewardAccounting {\\n    event NotifyRewardAmount(\\n        address sender,\\n        IERC20 rewardTokenAddress,\\n        uint256 amount,\\n        uint256 duration,\\n        uint256 rewardRate\\n    );\\n    event GetReward(\\n        address sender,\\n        uint256 tokenId,\\n        address recipient,\\n        uint8 rewardTokenIndex,\\n        uint256 stakeDuration,\\n        IERC20 rewardTokenAddress,\\n        RewardOutput rewardOutput,\\n        uint256 lockupId\\n    );\\n    event UnStake(address indexed sender, uint256 indexed tokenId, address indexed recipient, uint256 amount);\\n    event Stake(address indexed sender, uint256 indexed tokenId, uint256 amount);\\n\\n    error RewardDurationOutOfBounds(uint256 duration, uint256 minDuration, uint256 maxDuration);\\n    error RewardZeroAmount();\\n    error RewardNotValidRewardToken(IERC20 rewardTokenAddress);\\n    error RewardNotValidIndex(uint8 index);\\n    error RewardTokenCannotBeStakingToken(IERC20 stakingToken);\\n    error RewardTransferNotSupported();\\n    error RewardNotApprovedGetter(uint256 tokenId, address approved, address getter);\\n    error RewardUnboostedTimePeriodNotMet(uint256 timestamp, uint256 minTimestamp);\\n\\n    struct RewardInfo {\\n        // Timestamp of when the rewards finish\\n        uint256 finishAt;\\n        // Minimum of last updated time and reward finish time\\n        uint256 updatedAt;\\n        // Reward to be paid out per second\\n        uint256 rewardRate;\\n        // Escrowed rewards\\n        uint256 escrowedReward;\\n        // Sum of (reward rate * dt * 1e18 / total supply)\\n        uint256 rewardPerTokenStored;\\n        // Reward Token to be emitted\\n        IERC20 rewardToken;\\n        // ve locking contract\\n        IMaverickV2VotingEscrow veRewardToken;\\n        // amount available to push to ve as incentive\\n        uint128 unboostedAmount;\\n        // timestamp of unboosted push\\n        uint256 lastUnboostedPushTimestamp;\\n    }\\n\\n    struct ContractInfo {\\n        // Reward Name\\n        string name;\\n        // Reward Symbol\\n        string symbol;\\n        // total supply staked\\n        uint256 totalSupply;\\n        // staking token\\n        IERC20 stakingToken;\\n    }\\n\\n    struct EarnedInfo {\\n        // earned\\n        uint256 earned;\\n        // reward token\\n        IERC20 rewardToken;\\n    }\\n\\n    struct RewardOutput {\\n        uint256 amount;\\n        bool asVe;\\n        IMaverickV2VotingEscrow veContract;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MAX_DURATION() external view returns (uint256);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MIN_DURATION() external view returns (uint256);\\n\\n    /**\\n     * @notice This function retrieves the minimum time gap in seconds that\\n     * must have elasped between calls to `pushUnboostedToVe()`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function UNBOOSTED_MIN_TIME_GAP() external view returns (uint256);\\n\\n    /**\\n     * @notice This function retrieves the address of the token used for\\n     * staking in this reward contract.\\n     * @return The address of the staking token (IERC20).\\n     */\\n    function stakingToken() external view returns (IERC20);\\n\\n    /**\\n     * @notice This function retrieves the address of the MaverickV2RewardVault\\n     * contract associated with this reward contract.\\n     * @return The address of the IMaverickV2RewardVault contract.\\n     */\\n    function vault() external view returns (IMaverickV2RewardVault);\\n\\n    /**\\n     * @notice This function retrieves information about all available reward tokens for this reward contract.\\n     * @return info An array of RewardInfo structs containing details about each reward token.\\n     */\\n    function rewardInfo() external view returns (RewardInfo[] memory info);\\n\\n    /**\\n     * @notice This function retrieves information about all available reward\\n     * tokens and overall contract details for this reward contract.\\n     * @return info An array of RewardInfo structs containing details about each reward token.\\n     * @return _contractInfo A ContractInfo struct containing overall contract details.\\n     */\\n    function contractInfo() external view returns (RewardInfo[] memory info, ContractInfo memory _contractInfo);\\n\\n    /**\\n     * @notice This function calculates the total amount of all earned rewards\\n     * for a specific tokenId across all reward tokens.\\n     * @param tokenId The address of the tokenId for which to calculate earned rewards.\\n     * @return earnedInfo An array of EarnedInfo structs containing details about earned rewards for each supported token.\\n     */\\n    function earned(uint256 tokenId) external view returns (EarnedInfo[] memory earnedInfo);\\n\\n    /**\\n     * @notice This function calculates the total amount of earned rewards for\\n     * a specific tokenId for a particular reward token.\\n     * @param tokenId The address of the tokenId for which to calculate earned rewards.\\n     * @param rewardTokenAddress The address of the specific reward token.\\n     * @return amount The total amount of earned rewards for the specified token.\\n     */\\n    function earned(uint256 tokenId, IERC20 rewardTokenAddress) external view returns (uint256);\\n\\n    /**\\n     * @notice This function retrieves the internal index associated with a specific reward token address.\\n     * @param  rewardToken The address of the reward token to get the index for.\\n     * @return rewardTokenIndex The internal index of the token within the reward contract (uint8).\\n     */\\n    function tokenIndex(IERC20 rewardToken) external view returns (uint8 rewardTokenIndex);\\n\\n    /**\\n     * @notice This function retrieves the total number of supported reward tokens in this reward contract.\\n     * @return count The total number of reward tokens (uint256).\\n     */\\n    function rewardTokenCount() external view returns (uint256);\\n\\n    /**\\n     * @notice This function transfers a specified amount of reward tokens from\\n     * the caller to distribute them over a defined duration. The caller will\\n     * need to approve this rewards contract to make the transfer on the\\n     * caller's behalf. See `notifyRewardAmount` for details of how the\\n     * duration is set by the rewards contract.\\n     * @param rewardToken The address of the reward token to transfer.\\n     * @param duration The duration (in seconds) over which to distribute the rewards.\\n     * @param amount The amount of reward tokens to transfer.\\n     * @return _duration The duration in seconds that the incentives will be distributed over.\\n     */\\n    function transferAndNotifyRewardAmount(\\n        IERC20 rewardToken,\\n        uint256 duration,\\n        uint256 amount\\n    ) external returns (uint256 _duration);\\n\\n    /**\\n     * @notice This function notifies the vault to distribute a previously\\n     * transferred amount of reward tokens over a defined duration. (Assumes\\n     * tokens are already in the contract).\\n     * @dev The duration of the distribution may not be the same as the input\\n     * duration.  If this notify amount is less than the amount already pending\\n     * disbursement, then this new amount will be distributed as the same rate\\n     * as the existing rate and that will dictate the duration.  Alternatively,\\n     * if the amount is more than the pending disbursement, then the input\\n     * duration will be honored and all pending disbursement tokens will also be\\n     * distributed at this newly set rate.\\n     * @param rewardToken The address of the reward token to distribute.\\n     * @param duration The duration (in seconds) over which to distribute the rewards.\\n     * @return _duration The duration in seconds that the incentives will be distributed over.\\n     */\\n    function notifyRewardAmount(IERC20 rewardToken, uint256 duration) external returns (uint256 _duration);\\n\\n    /**\\n     * @notice This function transfers a specified amount of staking tokens\\n     * from the caller to the staking `vault()` and stakes them on the\\n     * recipient's behalf.  The user has to approve this reward contract to\\n     * transfer the staking token on their behalf for this function not to\\n     * revert.\\n     * @param tokenId Nft tokenId to stake for the staked tokens.\\n     * @param _amount The amount of staking tokens to transfer and stake.\\n     * @return amount The amount of staking tokens staked.  May differ from\\n     * input if there were unstaked tokens in the vault prior to this call.\\n     * @return stakedTokenId TokenId where liquidity was staked to.  This may\\n     * differ from the input tokenIf if the input `tokenId=0`.\\n     */\\n    function transferAndStake(\\n        uint256 tokenId,\\n        uint256 _amount\\n    ) external returns (uint256 amount, uint256 stakedTokenId);\\n\\n    /**\\n     * @notice This function stakes the staking tokens to the specified\\n     * tokenId. If `tokenId=0` is passed in, then this function will look up\\n     * the caller's tokenIds and stake to the zero-index tokenId.  If the user\\n     * does not yet have a staking NFT tokenId, this function will mint one for\\n     * the sender and stake to that newly-minted tokenId.\\n     *\\n     * @dev The amount staked is derived by looking at the new balance on\\n     * the `vault()`. So, for staking to yield a non-zero balance, the user\\n     * will need to have transfered the `stakingToken()` to the `vault()` prior\\n     * to calling `stake`.  Note, tokens sent to the reward contract instead\\n     * of the vault will not be stakable and instead will be eligible to be\\n     * disbursed as rewards to stakers.  This is an advanced usage function.\\n     * If in doubt about the mechanics of staking, use `transferAndStake()`\\n     * instead.\\n     * @param tokenId The address of the tokenId whose tokens to stake.\\n     * @return amount The amount of staking tokens staked (uint256).\\n     * @return stakedTokenId TokenId where liquidity was staked to.  This may\\n     * differ from the input tokenIf if the input `tokenId=0`.\\n     */\\n    function stake(uint256 tokenId) external returns (uint256 amount, uint256 stakedTokenId);\\n\\n    /**\\n     * @notice This function initiates unstaking of a specified amount of\\n     * staking tokens for the caller and sends them to a recipient.\\n     * @param tokenId The address of the tokenId whose tokens to unstake.\\n     * @param amount The amount of staking tokens to unstake (uint256).\\n     */\\n    function unstakeToOwner(uint256 tokenId, uint256 amount) external;\\n\\n    /**\\n     * @notice This function initiates unstaking of a specified amount of\\n     * staking tokens on behalf of a specific tokenId and sends them to a recipient.\\n     * @dev To unstakeFrom, the caller must have an approval allowance of at\\n     * least `amount`.  Approvals follow the ERC-721 approval interface.\\n     * @param tokenId The address of the tokenId whose tokens to unstake.\\n     * @param recipient The address to which the unstaked tokens will be sent.\\n     * @param amount The amount of staking tokens to unstake (uint256).\\n     */\\n    function unstake(uint256 tokenId, address recipient, uint256 amount) external;\\n\\n    /**\\n     * @notice This function retrieves the claimable reward for a specific\\n     * reward token and stake duration for the caller.\\n     * @param tokenId The address of the tokenId whose reward to claim.\\n     * @param rewardTokenIndex The internal index of the reward token.\\n     * @param stakeDuration The duration (in seconds) for which the rewards were staked.\\n     * @return rewardOutput A RewardOutput struct containing details about the claimable reward.\\n     */\\n    function getRewardToOwner(\\n        uint256 tokenId,\\n        uint8 rewardTokenIndex,\\n        uint256 stakeDuration\\n    ) external returns (RewardOutput memory rewardOutput);\\n\\n    /**\\n     * @notice This function retrieves the claimable reward for a specific\\n     * reward token, stake duration, and lockup ID for the caller.\\n     * @param tokenId The address of the tokenId whose reward to claim.\\n     * @param rewardTokenIndex The internal index of the reward token.\\n     * @param stakeDuration The duration (in seconds) for which the rewards were staked.\\n     * @param lockupId The unique identifier for the specific lockup (optional).\\n     * @return rewardOutput A RewardOutput struct containing details about the claimable reward.\\n     */\\n    function getRewardToOwnerForExistingVeLockup(\\n        uint256 tokenId,\\n        uint8 rewardTokenIndex,\\n        uint256 stakeDuration,\\n        uint256 lockupId\\n    ) external returns (RewardOutput memory);\\n\\n    /**\\n     * @notice This function retrieves the claimable reward for a specific\\n     * reward token and stake duration for a specified tokenId and sends it to\\n     * a recipient.  If the reward is staked in the corresponding veToken, a\\n     * new lockup in the ve token will be created.\\n     * @param tokenId The address of the tokenId whose reward to claim.\\n     * @param recipient The address to which the claimed reward will be sent.\\n     * @param rewardTokenIndex The internal index of the reward token.\\n     * @param stakeDuration The duration (in seconds) for which the rewards\\n     * will be staked in the ve contract.\\n     * @return rewardOutput A RewardOutput struct containing details about the claimable reward.\\n     */\\n    function getReward(\\n        uint256 tokenId,\\n        address recipient,\\n        uint8 rewardTokenIndex,\\n        uint256 stakeDuration\\n    ) external returns (RewardOutput memory);\\n\\n    /**\\n     * @notice This function retrieves a list of all supported tokens in the reward contract.\\n     * @param includeStakingToken A flag indicating whether to include the staking token in the list.\\n     * @return tokens An array of IERC20 token addresses.\\n     */\\n    function tokenList(bool includeStakingToken) external view returns (IERC20[] memory tokens);\\n\\n    /**\\n     * @notice This function retrieves the veToken contract associated with a\\n     * specific index within the reward contract.\\n     * @param index The index of the veToken to retrieve.\\n     * @return output The IMaverickV2VotingEscrow contract associated with the index.\\n     */\\n    function veTokenByIndex(uint8 index) external view returns (IMaverickV2VotingEscrow output);\\n\\n    /**\\n     * @notice This function retrieves the reward token contract associated\\n     * with a specific index within the reward contract.\\n     * @param index The index of the reward token to retrieve.\\n     * @return output The IERC20 contract associated with the index.\\n     */\\n    function rewardTokenByIndex(uint8 index) external view returns (IERC20 output);\\n\\n    /**\\n     * @notice This function calculates the boosted amount an tokenId would\\n     * receive based on their veToken balance and stake duration.\\n     * @param tokenId The address of the tokenId for which to calculate the boosted amount.\\n     * @param veToken The IMaverickV2VotingEscrow contract representing the veToken used for boosting.\\n     * @param rawAmount The raw (unboosted) amount.\\n     * @param stakeDuration The duration (in seconds) for which the rewards would be staked.\\n     * @return earnedAmount The boosted amount the tokenId would receive (uint256).\\n     * @return asVe A boolean indicating whether the boosted amount is\\n     * staked in the veToken (true) or is disbursed without ve staking required (false).\\n     */\\n    function boostedAmount(\\n        uint256 tokenId,\\n        IMaverickV2VotingEscrow veToken,\\n        uint256 rawAmount,\\n        uint256 stakeDuration\\n    ) external view returns (uint256 earnedAmount, bool asVe);\\n\\n    /**\\n     * @notice This function is used to push unboosted rewards to the veToken\\n     * contract.  This unboosted reward amount is then distributed to the\\n     * veToken holders. This function will revert if less than\\n     * `UNBOOSTED_MIN_TIME_GAP()` seconds have passed since the last call.\\n     * @param rewardTokenIndex The internal index of the reward token.\\n     * @return amount The amount of unboosted rewards pushed (uint128).\\n     * @return timepoint The timestamp associated with the pushed rewards (uint48).\\n     * @return batchIndex The batch index for the pushed rewards (uint256).\\n     */\\n    function pushUnboostedToVe(\\n        uint8 rewardTokenIndex\\n    ) external returns (uint128 amount, uint48 timepoint, uint256 batchIndex);\\n\\n    /**\\n     * @notice Mints an NFT stake to a user.  This NFT will not possesses any\\n     * assets until a user `stake`s asset to the NFT tokenId as part of a\\n     * separate call.\\n     * @param recipient The address that owns the output NFT\\n     */\\n    function mint(address recipient) external returns (uint256 tokenId);\\n\\n    /**\\n     * @notice Mints an NFT stake to caller.  This NFT will not possesses any\\n     * assets until a user `stake`s asset to the NFT tokenId as part of a\\n     * separate call.\\n     */\\n    function mintToSender() external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2RewardFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IMaverickV2BoostedPositionFactory} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2BoostedPositionFactory.sol\\\";\\n\\nimport {IMaverickV2VotingEscrowFactory} from \\\"./IMaverickV2VotingEscrowFactory.sol\\\";\\nimport {IMaverickV2VotingEscrow} from \\\"./IMaverickV2VotingEscrow.sol\\\";\\nimport {IMaverickV2Reward} from \\\"./IMaverickV2Reward.sol\\\";\\n\\ninterface IMaverickV2RewardFactory {\\n    error RewardFactoryNotFactoryBoostedPosition();\\n    error RewardFactoryTooManyRewardTokens();\\n    error RewardFactoryRewardAndVeLengthsAreNotEqual();\\n    error RewardFactoryInvalidVeBaseTokenPair();\\n    error RewardFactoryTokensNotSorted(uint256 index, IERC20 lastRewardToken, IERC20 rewardToken);\\n\\n    event CreateRewardsContract(\\n        IERC20 stakeToken,\\n        IERC20[] rewardTokens,\\n        IMaverickV2VotingEscrow[] veTokens,\\n        IMaverickV2Reward rewardsContract,\\n        bool isFactoryBoostedPosition\\n    );\\n\\n    /**\\n     * @notice This function creates a new MaverickV2Reward contract associated\\n     * with a specific stake token contract and set of reward and voting\\n     * escrow tokens.\\n     * @param stakeToken Token to be staked in reward contract; e.g. a boosted position contract.\\n     * @param rewardTokens An array of IERC20 token addresses representing the available reward tokens.\\n     * @param veTokens An array of IMaverickV2VotingEscrow contract addresses\\n     * representing the associated veTokens for boosting.\\n     * @return rewardsContract The newly created IMaverickV2Reward contract.\\n     */\\n    function createRewardsContract(\\n        IERC20 stakeToken,\\n        IERC20[] memory rewardTokens,\\n        IMaverickV2VotingEscrow[] memory veTokens\\n    ) external returns (IMaverickV2Reward rewardsContract);\\n\\n    /**\\n     * @notice This function retrieves the address of the MaverickV2BoostedPositionFactory contract.\\n     * @return factory The address of the IMaverickV2BoostedPositionFactory contract.\\n     */\\n    function boostedPositionFactory() external returns (IMaverickV2BoostedPositionFactory);\\n\\n    /**\\n     * @notice This function retrieves the address of the MaverickV2VotingEscrowFactory contract.\\n     * @return factory The address of the IMaverickV2VotingEscrowFactory contract.\\n     */\\n    function votingEscrowFactory() external returns (IMaverickV2VotingEscrowFactory);\\n\\n    /**\\n     * @notice This function checks if a provided IMaverickV2Reward contract is\\n     * a valid contract created by this factory.\\n     * @param reward The IMaverickV2Reward contract to check.\\n     * @return isFactoryContract True if the contract is a valid factory-created reward contract, False otherwise.\\n     */\\n    function isFactoryContract(IMaverickV2Reward reward) external returns (bool);\\n\\n    /**\\n     * @notice This function retrieves a list of all MaverickV2Reward contracts\\n     * associated with a specific staking token contract within a specified\\n     * range.\\n     * @param stakeToken Lookup token.\\n     * @param startIndex The starting index of the list to retrieve.\\n     * @param endIndex The ending index of the list to retrieve.\\n     * @return rewardsContract An array of IMaverickV2Reward contracts\\n     * associated with the BoostedPosition within the specified range.\\n     */\\n    function rewardsForStakeToken(\\n        IERC20 stakeToken,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Reward[] memory rewardsContract);\\n\\n    /**\\n     * @notice Returns the number of reward contracts this factory has deployed\\n     * for a given staking token.\\n     */\\n    function rewardsForStakeTokenCount(IERC20 stakeToken) external view returns (uint256 count);\\n\\n    /**\\n     * @notice This function retrieves a list of all MaverickV2Reward contracts within a specified range.\\n     * @param startIndex The starting index of the list to retrieve.\\n     * @param endIndex The ending index of the list to retrieve.\\n     * @return rewardsContract An array of IMaverickV2Reward contracts within the specified range.\\n     */\\n    function rewards(\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Reward[] memory rewardsContract);\\n\\n    /**\\n     * @notice Returns the number of reward contracts this factory has deployed.\\n     */\\n    function rewardsCount() external view returns (uint256 count);\\n\\n    /**\\n     * @notice This function retrieves a list of all MaverickV2Reward contracts\\n     * within a specified range that have a staking token that is a boosted\\n     * position from the maverick boosted position contract.\\n     * @param startIndex The starting index of the list to retrieve.\\n     * @param endIndex The ending index of the list to retrieve.\\n     * @return rewardsContract An array of IMaverickV2Reward contracts within the specified range.\\n     */\\n    function boostedPositionRewards(\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Reward[] memory);\\n\\n    /**\\n     * @notice Returns the number of reward contracts where the staking token\\n     * is a booste position that this factory has deployed.\\n     */\\n    function boostedPositionRewardsCount() external view returns (uint256 count);\\n\\n    /**\\n     * @notice This function retrieves a list of all MaverickV2Reward contracts\\n     * within a specified range that have a staking token that is not a boosted\\n     * position from the maverick boosted position contract.\\n     * @param startIndex The starting index of the list to retrieve.\\n     * @param endIndex The ending index of the list to retrieve.\\n     * @return rewardsContract An array of IMaverickV2Reward contracts within the specified range.\\n     */\\n    function nonBoostedPositionRewards(\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2Reward[] memory);\\n\\n    /**\\n     * @notice Returns the number of reward contracts where the staking token\\n     * is not a booste position that this factory has deployed.\\n     */\\n    function nonBoostedPositionRewardsCount() external view returns (uint256 count);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2RewardRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IMaverickV2PoolLens} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2PoolLens.sol\\\";\\nimport {IMaverickV2BoostedPosition} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2BoostedPosition.sol\\\";\\nimport {IMaverickV2LiquidityManager} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2LiquidityManager.sol\\\";\\n\\nimport {IMaverickV2RewardFactory} from \\\"./IMaverickV2RewardFactory.sol\\\";\\nimport {IMaverickV2VotingEscrowWSync} from \\\"./IMaverickV2VotingEscrowWSync.sol\\\";\\nimport {IMaverickV2Reward} from \\\"./IMaverickV2Reward.sol\\\";\\nimport {IMaverickV2VotingEscrow} from \\\"./IMaverickV2VotingEscrow.sol\\\";\\n\\ninterface IMaverickV2RewardRouter is IMaverickV2LiquidityManager {\\n    /**\\n     * @notice This function stakes any new staking token balance that are in\\n     * the `reward.vault()` for a specified recipient tokenId.  Passing input\\n     * `tokenId=0` will cause the stake to mint to either the first tokenId for\\n     * the caller, or a new NFT tokenId if the sender does not yet have one.\\n     * @param reward The IMaverickV2Reward contract for which to stake.\\n     * @param tokenId Nft tokenId to stake for the staked tokens.\\n     * @return amount The amount of staking tokens staked.  May differ from\\n     * input if there were unstaked tokens in the vault prior to this call.\\n     * @return stakedTokenId TokenId where liquidity was staked to.  This may\\n     * differ from the input tokenId if the input `tokenId=0`.\\n     */\\n    function stake(\\n        IMaverickV2Reward reward,\\n        uint256 tokenId\\n    ) external payable returns (uint256 amount, uint256 stakedTokenId);\\n\\n    /**\\n     * @notice This function retrieves the address of the MaverickV2RewardFactory\\n     * contract associated with this contract.\\n     */\\n    function rewardFactory() external view returns (IMaverickV2RewardFactory);\\n\\n    /**\\n     * @notice This function transfers a specified amount of reward tokens from\\n     * the caller to a reward contract and notifies it to distribute them over\\n     * a defined duration.\\n     * @param reward The IMaverickV2Reward contract to notify.\\n     * @param rewardToken The address of the reward token to transfer.\\n     * @param duration The duration (in seconds) over which to distribute the rewards.\\n     * @return _duration The duration in seconds that the incentives will be distributed over.\\n     */\\n    function notifyRewardAmount(\\n        IMaverickV2Reward reward,\\n        IERC20 rewardToken,\\n        uint256 duration\\n    ) external payable returns (uint256 _duration);\\n\\n    /**\\n     * @notice This function transfers a specified amount of staking tokens from\\n     * the caller, stakes them on the recipient's behalf, and\\n     * associates them with a specified reward contract.\\n     * @param reward The IMaverickV2Reward contract for which to stake.\\n     * @param tokenId Nft tokenId to stake for the staked tokens.\\n     * @param _amount The amount of staking tokens to transfer and stake.\\n     * @return amount The amount of staking tokens staked.  May differ from\\n     * input if there were unstaked tokens in the vault prior to this call.\\n     * @return stakedTokenId TokenId where liquidity was staked to.  This may\\n     * differ from the input tokenIf if the input `tokenId=0`.\\n     *\\n     */\\n    function transferAndStake(\\n        IMaverickV2Reward reward,\\n        uint256 tokenId,\\n        uint256 _amount\\n    ) external payable returns (uint256 amount, uint256 stakedTokenId);\\n\\n    /**\\n     * @notice This function transfers a specified amount of reward tokens\\n     *  from the caller and adds them to the reward contract as incentives.\\n     * @param reward The IMaverickV2Reward contract to notify.\\n     * @param rewardToken The address of the reward token to transfer.\\n     * @param duration The duration (in seconds) over which to distribute the rewards.\\n     * @param amount The amount of staking tokens to stake (uint256).\\n     * @return _duration The duration in seconds that the incentives will be distributed over.\\n     */\\n    function transferAndNotifyRewardAmount(\\n        IMaverickV2Reward reward,\\n        IERC20 rewardToken,\\n        uint256 duration,\\n        uint256 amount\\n    ) external payable returns (uint256 _duration);\\n\\n    /**\\n     * @notice This function creates a new BoostedPosition contract, adds\\n     * liquidity to a pool using the provided parameters, stakes the received\\n     * LP tokens, and associates them with a specified reward contract.\\n     * @param recipient The address to which the minted LP tokens will be\\n     * credited.\\n     * @param params A struct containing parameters for creating the\\n     * BoostedPosition (see IMaverickV2PoolLens.CreateBoostedPositionInputs).\\n     * @param rewardTokens An array of IERC20 token addresses representing the\\n     * available reward tokens for the staked LP position.\\n     * @param veTokens An array of IMaverickV2VotingEscrow contract addresses\\n     * representing the veTokens used for boosting.\\n     * @return boostedPosition The created IMaverickV2BoostedPosition contract.\\n     * @return mintedLpAmount The amount of LP tokens minted from the added liquidity.\\n     * @return tokenAAmount The amount of token A deposited for liquidity.\\n     * @return tokenBAmount The amount of token B deposited for liquidity.\\n     * @return stakeAmount The amount of LP tokens staked in the reward contract.\\n     * @return reward The IMaverickV2Reward contract.\\n     * @return tokenId Token on reward contract where user liquidity was staked.\\n     */\\n    function createBoostedPositionAndAddLiquidityAndStake(\\n        address recipient,\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params,\\n        IERC20[] memory rewardTokens,\\n        IMaverickV2VotingEscrow[] memory veTokens\\n    )\\n        external\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint256 stakeAmount,\\n            IMaverickV2Reward reward,\\n            uint256 tokenId\\n        );\\n\\n    /**\\n     * @notice This function is similar to\\n     * `createBoostedPositionAndAddLiquidityAndStake` but stakes the minted LP\\n     * tokens for the caller (msg.sender) instead of a specified recipient.\\n     * @param params A struct containing parameters for creating the\\n     * BoostedPosition (see IMaverickV2PoolLens.CreateBoostedPositionInputs).\\n     * @param rewardTokens An array of IERC20 token addresses representing the\\n     * available reward tokens for the staked LP position.\\n     * @param veTokens An array of IMaverickV2VotingEscrow contract addresses\\n     * representing the veTokens used for boosting.\\n     * @return boostedPosition The created IMaverickV2BoostedPosition contract.\\n     * @return mintedLpAmount The amount of LP tokens minted from the added liquidity.\\n     * @return tokenAAmount The amount of token A deposited for liquidity.\\n     * @return tokenBAmount The amount of token B deposited for liquidity.\\n     * @return stakeAmount The amount of LP tokens staked in the reward contract.\\n     * @return reward The IMaverickV2Reward contract associated with the staked LP position.\\n     * @return tokenId Token on reward contract where user liquidity was staked.\\n     */\\n    function createBoostedPositionAndAddLiquidityAndStakeToSender(\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params,\\n        IERC20[] memory rewardTokens,\\n        IMaverickV2VotingEscrow[] memory veTokens\\n    )\\n        external\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint256 stakeAmount,\\n            IMaverickV2Reward reward,\\n            uint256 tokenId\\n        );\\n\\n    /**\\n     * @notice This function adds liquidity to a pool using a pre-created\\n     * BoostedPosition contract, stakes the received LP tokens, and associates\\n     * them with a specified reward contract.\\n     * @param tokenId Token on reward contract where liquidity is to be staked.\\n     * @param boostedPosition The IMaverickV2BoostedPosition contract representing the existing boosted position.\\n     * @param packedSqrtPriceBreaks A packed representation of sqrt price\\n     * breaks for the liquidity range (see\\n     * IMaverickV2Pool.IAddLiquidityParams).\\n     * @param packedArgs Additional packed arguments for adding liquidity (see\\n     * IMaverickV2Pool.IAddLiquidityParams).\\n     * @param reward The IMaverickV2Reward contract for which to stake the LP tokens.\\n     * @return mintedLpAmount The amount of LP tokens minted from the added liquidity.\\n     * @return tokenAAmount The amount of token A deposited for liquidity.\\n     * @return tokenBAmount The amount of token B deposited for liquidity.\\n     * @return stakeAmount The amount of LP tokens staked in the reward contract.\\n     *\\n     */\\n    function addLiquidityAndMintBoostedPositionAndStake(\\n        uint256 tokenId,\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs,\\n        IMaverickV2Reward reward\\n    )\\n        external\\n        payable\\n        returns (uint256 mintedLpAmount, uint256 tokenAAmount, uint256 tokenBAmount, uint256 stakeAmount);\\n\\n    /**\\n     * @notice This function is similar to\\n     * `addLiquidityAndMintBoostedPositionAndStake` but uses the caller\\n     * (msg.sender) as the recipient for the minted reward stake.\\n     * @param sendersTokenIndex Token index of sender on the reward contract to\\n     * mint to.  If sender does not have a token already, then this call will\\n     * mint one for the user.\\n     * @param boostedPosition The IMaverickV2BoostedPosition contract representing the existing boosted position.\\n     * @param packedSqrtPriceBreaks A packed representation of sqrt price breaks for the liquidity range (see IMaverickV2Pool.IAddLiquidityParams).\\n     * @param packedArgs Additional packed arguments for adding liquidity (see IMaverickV2Pool.IAddLiquidityParams).\\n     * @param reward The IMaverickV2Reward contract for which to stake the LP tokens.\\n     * @return mintedLpAmount The amount of LP tokens minted from the added liquidity.\\n     * @return tokenAAmount The amount of token A deposited for liquidity.\\n     * @return tokenBAmount The amount of token B deposited for liquidity.\\n     * @return stakeAmount The amount of LP tokens staked in the reward contract.\\n     * @return tokenId Token on reward contract where user liquidity was staked.\\n     */\\n    function addLiquidityAndMintBoostedPositionAndStakeToSender(\\n        uint256 sendersTokenIndex,\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs,\\n        IMaverickV2Reward reward\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint256 stakeAmount,\\n            uint256 tokenId\\n        );\\n\\n    /**\\n     * @notice This function syncs the balance of a staker's votes on the\\n     * legacy ve mav contract with the new V2 ve mav contract.\\n     * @param ve The IMaverickV2VotingEscrowWSync contract to interact with.\\n     * @param staker The address of the user whose veToken lock may need syncing.\\n     * @param  legacyLockupIndexes A list of indexes to synchronize from the\\n     * legacy veMav to the V2 ve contract.\\n     *\\n     */\\n    function sync(\\n        IMaverickV2VotingEscrowWSync ve,\\n        address staker,\\n        uint256[] memory legacyLockupIndexes\\n    ) external returns (uint256[] memory newBalance);\\n\\n    function mintTokenInRewardToSender(IMaverickV2Reward reward) external payable returns (uint256 tokenId);\\n\\n    function mintTokenInReward(IMaverickV2Reward reward, address recipient) external payable returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2RewardVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMaverickV2RewardVault {\\n    error RewardVaultUnauthorizedAccount(address caller, address owner);\\n\\n    /**\\n     * @notice This function allows the owner of the reward vault to withdraw a\\n     * specified amount of staking tokens to a recipient address.  If non-owner\\n     * calls this function, it will revert.\\n     * @param recipient The address to which the withdrawn staking tokens will be sent.\\n     * @param amount The amount of staking tokens to withdraw.\\n     */\\n    function withdraw(address recipient, uint256 amount) external;\\n\\n    /**\\n     * @notice This function retrieves the address of the owner of the reward\\n     * vault contract.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice This function retrieves the address of the ERC20 token used for\\n     * staking within the reward vault.\\n     */\\n    function stakingToken() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2VotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IVotes} from \\\"@openzeppelin/contracts/governance/utils/IVotes.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\n\\nimport {IHistoricalBalance} from \\\"../votingescrowbase/IHistoricalBalance.sol\\\";\\n\\ninterface IMaverickV2VotingEscrowBase is IVotes, IHistoricalBalance {\\n    error VotingEscrowTransferNotSupported();\\n    error VotingEscrowInvalidAddress(address);\\n    error VotingEscrowInvalidAmount(uint256);\\n    error VotingEscrowInvalidDuration(uint256 duration, uint256 minDuration, uint256 maxDuration);\\n    error VotingEscrowInvalidEndTime(uint256 newEnd, uint256 oldEnd);\\n    error VotingEscrowStakeStillLocked(uint256 currentTime, uint256 endTime);\\n    error VotingEscrowStakeAlreadyRedeemed();\\n    error VotingEscrowNotApprovedExtender(address account, address extender, uint256 lockupId);\\n    error VotingEscrowIncentiveAlreadyClaimed(address account, uint256 batchIndex);\\n    error VotingEscrowNoIncentivesToClaim(address account, uint256 batchIndex);\\n    error VotingEscrowInvalidExtendIncentiveToken(IERC20 incentiveToken);\\n    error VotingEscrowNoSupplyAtTimepoint();\\n    error VotingEscrowIncentiveTimepointInFuture(uint256 timestamp, uint256 claimTimepoint);\\n\\n    event Stake(address indexed user, uint256 lockupId, Lockup);\\n    event Unstake(address indexed user, uint256 lockupId, Lockup);\\n    event ExtenderApproval(address staker, address extender, uint256 lockupId, bool newState);\\n    event ClaimIncentiveBatch(uint256 batchIndex, address account, uint256 claimAmount);\\n    event CreateNewIncentiveBatch(\\n        address user,\\n        uint256 amount,\\n        uint256 timepoint,\\n        uint256 stakeDuration,\\n        IERC20 incentiveToken\\n    );\\n\\n    struct Lockup {\\n        uint128 amount;\\n        uint128 end;\\n        uint256 votes;\\n    }\\n\\n    struct ClaimInformation {\\n        bool timepointInPast;\\n        bool hasClaimed;\\n        uint128 claimAmount;\\n    }\\n\\n    struct BatchInformation {\\n        uint128 totalIncentives;\\n        uint128 stakeDuration;\\n        uint48 claimTimepoint;\\n        IERC20 incentiveToken;\\n    }\\n\\n    struct TokenIncentiveTotals {\\n        uint128 totalIncentives;\\n        uint128 claimedIncentives;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MIN_STAKE_DURATION() external returns (uint256 duration);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MAX_STAKE_DURATION() external returns (uint256 duration);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function YEAR_BASE() external returns (uint256);\\n\\n    /**\\n     * @notice This function retrieves the address of the ERC20 token used as the base token for staking and rewards.\\n     * @return baseToken The address of the IERC20 base token contract.\\n     */\\n    function baseToken() external returns (IERC20);\\n\\n    /**\\n     * @notice This function retrieves the starting timestamp. This may be used\\n     * for reward calculations or other time-based logic.\\n     */\\n    function startTimestamp() external returns (uint256 timestamp);\\n\\n    /**\\n     * @notice This function retrieves the details of a specific lockup for a given staker and lockup index.\\n     * @param staker The address of the staker for which to retrieve the lockup details.\\n     * @param index The index of the lockup within the staker's lockup history.\\n     * @return lockup A Lockup struct containing details about the lockup (see struct definition for details).\\n     */\\n    function getLockup(address staker, uint256 index) external view returns (Lockup memory lockup);\\n\\n    /**\\n     * @notice This function retrieves the total number of lockups associated with a specific staker.\\n     * @param staker The address of the staker for which to retrieve the lockup count.\\n     * @return count The total number of lockups for the staker.\\n     */\\n    function lockupCount(address staker) external view returns (uint256 count);\\n\\n    /**\\n     * @notice This function simulates a lockup scenario, providing details about the resulting lockup structure for a specified amount and duration.\\n     * @param amount The amount of tokens to be locked.\\n     * @param duration The duration of the lockup period.\\n     * @return lockup A Lockup struct containing details about the simulated lockup (see struct definition for details).\\n     */\\n    function previewVotes(uint128 amount, uint256 duration) external view returns (Lockup memory lockup);\\n\\n    /**\\n     * @notice This function grants approval for a designated extender contract to manage a specific lockup on behalf of the staker.\\n     * @param extender The address of the extender contract to be approved.\\n     * @param lockupId The ID of the lockup for which to grant approval.\\n     */\\n    function approveExtender(address extender, uint256 lockupId) external;\\n\\n    /**\\n     * @notice This function revokes approval previously granted to an extender contract for managing a specific lockup.\\n     * @param extender The address of the extender contract whose approval is being revoked.\\n     * @param lockupId The ID of the lockup for which to revoke approval.\\n     */\\n    function revokeExtender(address extender, uint256 lockupId) external;\\n\\n    /**\\n     * @notice This function checks whether a specific account has been approved by a staker to manage a particular lockup through an extender contract.\\n     * @param account The address of the account to check for approval (may be the extender or another account).\\n     * @param extender The address of the extender contract for which to check approval.\\n     * @param lockupId The ID of the lockup to verify approval for.\\n     * @return isApproved True if the account is approved for the lockup, False otherwise (bool).\\n     */\\n    function isApprovedExtender(address account, address extender, uint256 lockupId) external view returns (bool);\\n\\n    /**\\n     * @notice This function extends the lockup period for the caller (msg.sender) for a specified lockup ID, adding a new duration and amount.\\n     * @param lockupId The ID of the lockup to be extended.\\n     * @param duration The additional duration to extend the lockup by.\\n     * @param amount The additional amount of tokens to be locked.\\n     * @return newLockup A Lockup struct containing details about the newly extended lockup (see struct definition for details).\\n     */\\n    function extendForSender(\\n        uint256 lockupId,\\n        uint256 duration,\\n        uint128 amount\\n    ) external returns (Lockup memory newLockup);\\n\\n    /**\\n     * @notice This function extends the lockup period for a specified account, adding a new duration and amount. The caller (msg.sender) must be authorized to manage the lockup through an extender contract.\\n     * @param account The address of the account whose lockup is being extended.\\n     * @param lockupId The ID of the lockup to be extended.\\n     * @param duration The additional duration to extend the lockup by.\\n     * @param amount The additional amount of tokens to be locked.\\n     * @return newLockup A Lockup struct containing details about the newly extended lockup (see struct definition for details).\\n     */\\n    function extendForAccount(\\n        address account,\\n        uint256 lockupId,\\n        uint256 duration,\\n        uint128 amount\\n    ) external returns (Lockup memory newLockup);\\n\\n    /**\\n     * @notice This function merges multiple lockups associated with the caller\\n     * (msg.sender) into a single new lockup.\\n     * @param lockupIds An array containing the IDs of the lockups to be merged.\\n     * @return newLockup A Lockup struct containing details about the newly merged lockup (see struct definition for details).\\n     */\\n    function merge(uint256[] memory lockupIds) external returns (Lockup memory newLockup);\\n\\n    /**\\n     * @notice This function unstakes the specified lockup ID for the caller (msg.sender), returning the details of the unstaked lockup.\\n     * @param lockupId The ID of the lockup to be unstaked.\\n     * @param to The address to which the unstaked tokens should be sent (optional, defaults to msg.sender).\\n     * @return lockup A Lockup struct containing details about the unstaked lockup (see struct definition for details).\\n     */\\n    function unstake(uint256 lockupId, address to) external returns (Lockup memory lockup);\\n\\n    /**\\n     * @notice This function is a simplified version of `unstake` that automatically sends the unstaked tokens to the caller (msg.sender).\\n     * @param lockupId The ID of the lockup to be unstaked.\\n     * @return lockup A Lockup struct containing details about the unstaked lockup (see struct definition for details).\\n     */\\n    function unstakeToSender(uint256 lockupId) external returns (Lockup memory lockup);\\n\\n    /**\\n     * @notice This function stakes a specified amount of tokens for the caller\\n     * (msg.sender) for a defined duration.\\n     * @param amount The amount of tokens to be staked.\\n     * @param duration The duration of the lockup period.\\n     * @return lockup A Lockup struct containing details about the newly\\n     * created lockup (see struct definition for details).\\n     */\\n    function stakeToSender(uint128 amount, uint256 duration) external returns (Lockup memory lockup);\\n\\n    /**\\n     * @notice This function stakes a specified amount of tokens for a defined\\n     * duration, allowing the caller (msg.sender) to specify an optional\\n     * recipient for the staked tokens.\\n     * @param amount The amount of tokens to be staked.\\n     * @param duration The duration of the lockup period.\\n     * @param to The address to which the staked tokens will be credited (optional, defaults to msg.sender).\\n     * @return lockup A Lockup struct containing details about the newly\\n     * created lockup (see struct definition for details).\\n     */\\n    function stake(uint128 amount, uint256 duration, address to) external returns (Lockup memory);\\n\\n    /**\\n     * @notice This function retrieves the total incentive information for a specific ERC-20 token.\\n     * @param token The address of the ERC20 token for which to retrieve incentive totals.\\n     * @return totals A TokenIncentiveTotals struct containing details about\\n     * the token's incentives (see struct definition for details).\\n     */\\n    function incentiveTotals(IERC20 token) external view returns (TokenIncentiveTotals memory);\\n\\n    /**\\n     * @notice This function retrieves the total number of created incentive batches.\\n     * @return count The total number of incentive batches.\\n     */\\n    function incentiveBatchCount() external view returns (uint256);\\n\\n    /**\\n     * @notice This function retrieves claim information for a specific account and incentive batch index.\\n     * @param account The address of the account for which to retrieve claim information.\\n     * @param batchIndex The index of the incentive batch for which to retrieve\\n     * claim information.\\n     * @return claimInformation A ClaimInformation struct containing details about the\\n     * account's claims for the specified batch (see struct definition for\\n     * details).\\n     * @return batchInformation A BatchInformation struct containing details about the\\n     * specified batch (see struct definition for details).\\n     */\\n    function claimAndBatchInformation(\\n        address account,\\n        uint256 batchIndex\\n    ) external view returns (ClaimInformation memory claimInformation, BatchInformation memory batchInformation);\\n\\n    /**\\n     * @notice This function retrieves batch information for a incentive batch index.\\n     * @param batchIndex The index of the incentive batch for which to retrieve\\n     * claim information.\\n     * @return info A BatchInformation struct containing details about the\\n     * specified batch (see struct definition for details).\\n     */\\n    function incentiveBatchInformation(uint256 batchIndex) external view returns (BatchInformation memory info);\\n\\n    /**\\n     * @notice This function allows claiming rewards from a specific incentive\\n     * batch while simultaneously extending a lockup with the claimed tokens.\\n     * @param batchIndex The index of the incentive batch from which to claim rewards.\\n     * @param lockupId The ID of the lockup to be extended with the claimed tokens.\\n     * @return lockup A Lockup struct containing details about the updated\\n     * lockup after extension (see struct definition for details).\\n     * @return claimAmount The amount of tokens claimed from the incentive batch.\\n     */\\n    function claimFromIncentiveBatchAndExtend(\\n        uint256 batchIndex,\\n        uint256 lockupId\\n    ) external returns (Lockup memory lockup, uint128 claimAmount);\\n\\n    /**\\n     * @notice This function allows claiming rewards from a specific incentive\\n     * batch, without extending any lockups.\\n     * @param batchIndex The index of the incentive batch from which to claim rewards.\\n     * @return lockup A Lockup struct containing details about the user's\\n     * lockup that might have been affected by the claim (see struct definition\\n     * for details).\\n     * @return claimAmount The amount of tokens claimed from the incentive batch.\\n     */\\n    function claimFromIncentiveBatch(uint256 batchIndex) external returns (Lockup memory lockup, uint128 claimAmount);\\n\\n    /**\\n     * @notice This function creates a new incentive batch for a specified amount\\n     * of incentive tokens, timepoint, stake duration, and associated ERC-20\\n     * token. An incentive batch is a reward of incentives put up by the\\n     * caller at a certain timepoint.  The incentive batch is claimable by ve\\n     * holders after the timepoint has passed.  The ve holders will receive\\n     * their incentive pro rata of their vote balance (`pastbalanceOf`) at that\\n     * timepoint.  The incentivizer can specify that users have to stake the\\n     * resulting incentive for a given `stakeDuration` number of seconds.\\n     * `stakeDuration` can either be zero, meaning that no staking is required\\n     * on redemption, or can be a number between `MIN_STAKE_DURATION()` and\\n     * `MAX_STAKE_DURATION()`.\\n     * @param amount The total amount of incentive tokens to be distributed in the batch.\\n     * @param timepoint The timepoint at which the incentive batch starts accruing rewards.\\n     * @param stakeDuration The duration of the lockup period required to be\\n     * eligible for the incentive batch rewards.\\n     * @param incentiveToken The address of the ERC20 token used for the incentive rewards.\\n     * @return index The index of the newly created incentive batch.\\n     */\\n    function createIncentiveBatch(\\n        uint128 amount,\\n        uint48 timepoint,\\n        uint128 stakeDuration,\\n        IERC20 incentiveToken\\n    ) external returns (uint256 index);\\n}\\n\\ninterface IMaverickV2VotingEscrow is IMaverickV2VotingEscrowBase, IERC20Metadata, IERC6372 {}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2VotingEscrowFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IMaverickV2VotingEscrow} from \\\"./IMaverickV2VotingEscrow.sol\\\";\\n\\ninterface IMaverickV2VotingEscrowFactory {\\n    error VotingEscrowTokenAlreadyExists(IERC20 baseToken, IMaverickV2VotingEscrow veToken);\\n\\n    event CreateVotingEscrow(IERC20 baseToken, IMaverickV2VotingEscrow veToken);\\n\\n    /**\\n     * @notice This function retrieves the address of the legacy Maverick V1\\n     * Voting Escrow (veMAV) token.  The address will be zero for blockchains\\n     * where this contract is deployed that do not have a legacy MAV contract\\n     * deployed.\\n     * @return legacyVeMav The address of the IERC20 legacy veMav token.\\n     */\\n    function legacyVeMav() external view returns (IERC20);\\n\\n    /**\\n     * @notice This function checks whether a provided IMaverickV2VotingEscrow\\n     * contract address was created by this factory.\\n     * @param veToken The address of the IMaverickV2VotingEscrow contract to be checked.\\n     * @return isFactoryToken True if the veToken was created by this factory, False otherwise (bool).\\n     */\\n    function isFactoryToken(IMaverickV2VotingEscrow veToken) external view returns (bool);\\n\\n    /**\\n     * @notice This function creates a new Maverick V2 Voting Escrow (veToken)\\n     * contract for a specified ERC20 base token.\\n     * @dev Once the ve contract is created, it will call `name()` and\\n     * `symbol()` on the `baseToken`.  If those functions do not exist, the ve\\n     * creation will revert.\\n     * @param baseToken The address of the ERC-20 token to be used as the base token for the new veToken.\\n     * @return veToken The address of the newly created IMaverickV2VotingEscrow contract.\\n     */\\n    function createVotingEscrow(IERC20 baseToken) external returns (IMaverickV2VotingEscrow veToken);\\n\\n    /**\\n     * @notice This function retrieves a paginated list of existing Maverick V2\\n     * Voting Escrow (veToken) contracts within a specified index range.\\n     * @param startIndex The starting index for the desired range of veTokens.\\n     * @param endIndex The ending index for the desired range of veTokens.\\n     * @return votingEscrows An array of IMaverickV2VotingEscrow addresses\\n     * representing the veTokens within the specified range.\\n     */\\n    function votingEscrows(\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2VotingEscrow[] memory votingEscrows);\\n\\n    /**\\n     * @notice This function retrieves the total number of deployed Maverick V2\\n     * Voting Escrow (veToken) contracts.\\n     * @return count The total number of veTokens.\\n     */\\n    function votingEscrowsCount() external view returns (uint256 count);\\n\\n    /**\\n     * @notice This function retrieves the address of the existing Maverick V2\\n     * Voting Escrow (veToken) contract associated with a specific ERC20 base\\n     * token.\\n     * @param baseToken The address of the ERC-20 base token for which to retrieve the veToken address.\\n     * @return veToken The address of the IMaverickV2VotingEscrow contract\\n     * associated with the base token, or the zero address if none exists.\\n     */\\n    function veForBaseToken(IERC20 baseToken) external view returns (IMaverickV2VotingEscrow veToken);\\n\\n    /**\\n     * @notice This function retrieves the default base token used for creating\\n     * new voting escrow contracts.  This state variable is only used\\n     * temporarily when a new veToken is deployed.\\n     * @return baseToken The address of the default ERC-20 base token.\\n     */\\n    function baseTokenParameter() external returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/interfaces/IMaverickV2VotingEscrowWSync.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMaverickV2VotingEscrowWSync {\\n    error VotingEscrowLockupEndTooShortToSync(uint256 legacyLockupEnd, uint256 minimumLockupEnd);\\n\\n    event Sync(address staker, uint256 legacyLockupIndex, uint256 newBalance);\\n\\n    /**\\n     * @notice This function retrieves the minimum lockup duration required for\\n     * a legacy lockup to be eligible for synchronization.\\n     * @return minSyncDuration The minimum allowed lockup end time.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MIN_SYNC_DURATION() external pure returns (uint256 minSyncDuration);\\n\\n    /**\\n     * @notice This function retrieves the address of the legacy Maverick V1\\n     * Voting Escrow (veMav) token.\\n     * @return legacyVeMav The address of the IERC20 legacy veMav token.\\n     */\\n    function legacyVeMav() external view returns (IERC20);\\n\\n    /**\\n     * @notice This function retrieves the synced balance for a specific legacy lockup index of a user.\\n     * @param staker The address of the user for whom to retrieve the synced balance.\\n     * @param legacyLockupIndex The index of the legacy lockup for which to\\n     * retrieve the synced balance.\\n     * @return balance The synced balance associated with the legacy lockup.\\n     */\\n    function syncBalances(address staker, uint256 legacyLockupIndex) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice This function synchronizes a specific legacy lockup index for a\\n     * user within the contract.  If the legacy lockup.end is not at least\\n     * `block.timestamp + MIN_SYNC_DURATION()`, this function will revert.\\n     * @param staker The address of the user for whom to perform synchronization.\\n     * @param legacyLockupIndex The index of the legacy lockup to be\\n     * synchronized.\\n     * @return newBalance The new balance resulting from the synchronization\\n     * process.\\n     */\\n    function sync(address staker, uint256 legacyLockupIndex) external returns (uint256 newBalance);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/MaverickV2RewardRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\n\\nimport {MaverickV2LiquidityManager} from \\\"@maverick/v2-supplemental/contracts/MaverickV2LiquidityManager.sol\\\";\\nimport {IMaverickV2PoolLens} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2PoolLens.sol\\\";\\nimport {IMaverickV2BoostedPosition} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2BoostedPosition.sol\\\";\\nimport {IWETH9} from \\\"@maverick/v2-supplemental/contracts/paymentbase/IWETH9.sol\\\";\\nimport {IMaverickV2Position} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2Position.sol\\\";\\nimport {IMaverickV2BoostedPositionFactory} from \\\"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2BoostedPositionFactory.sol\\\";\\n\\nimport {IMaverickV2Reward} from \\\"./interfaces/IMaverickV2Reward.sol\\\";\\nimport {IMaverickV2RewardRouter} from \\\"./interfaces/IMaverickV2RewardRouter.sol\\\";\\nimport {IMaverickV2RewardFactory} from \\\"./interfaces/IMaverickV2RewardFactory.sol\\\";\\nimport {IMaverickV2VotingEscrow} from \\\"./interfaces/IMaverickV2VotingEscrow.sol\\\";\\nimport {IMaverickV2VotingEscrowWSync} from \\\"./interfaces/IMaverickV2VotingEscrowWSync.sol\\\";\\n\\n/**\\n * @notice Liquidity and Reward contract to facilitate multi-step interactions\\n * with adding and staking liquidity in Maverick V2.  This contracts inherits\\n * all of the functionality of `MaverickV2LiquidityManager` that allows the\\n * creation of pools and BPs and adds mechanisms to interact with the various\\n * reward and ve functionality that are present in v2-rewards.  All of the\\n * functions are specified as `payable` to enable multicall transactions that\\n * involve functions that require ETH and those that do not.\\n */\\ncontract MaverickV2RewardRouter is IMaverickV2RewardRouter, MaverickV2LiquidityManager {\\n    using SafeERC20 for IERC20;\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    IMaverickV2RewardFactory public immutable rewardFactory;\\n\\n    constructor(\\n        IMaverickV2Factory _factory,\\n        IWETH9 _weth,\\n        IMaverickV2Position _position,\\n        IMaverickV2BoostedPositionFactory _boostedPositionFactory,\\n        IMaverickV2RewardFactory _rewardFactory\\n    ) MaverickV2LiquidityManager(_factory, _weth, _position, _boostedPositionFactory) {\\n        rewardFactory = _rewardFactory;\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function stake(\\n        IMaverickV2Reward reward,\\n        uint256 tokenId\\n    ) public payable returns (uint256 amount, uint256 stakedTokenId) {\\n        stakedTokenId = tokenId;\\n        if (stakedTokenId == 0) {\\n            if (reward.tokenOfOwnerByIndexExists(msg.sender, 0)) {\\n                stakedTokenId = reward.tokenOfOwnerByIndex(msg.sender, 0);\\n            } else {\\n                stakedTokenId = reward.mint(msg.sender);\\n            }\\n        }\\n        return reward.stake(stakedTokenId);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function transferAndStake(\\n        IMaverickV2Reward reward,\\n        uint256 tokenId,\\n        uint256 _amount\\n    ) public payable returns (uint256 amount, uint256 stakedTokenId) {\\n        reward.stakingToken().safeTransferFrom(msg.sender, address(reward.vault()), _amount);\\n        return stake(reward, tokenId);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function notifyRewardAmount(\\n        IMaverickV2Reward reward,\\n        IERC20 rewardToken,\\n        uint256 duration\\n    ) public payable returns (uint256 _duration) {\\n        return reward.notifyRewardAmount(rewardToken, duration);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function transferAndNotifyRewardAmount(\\n        IMaverickV2Reward reward,\\n        IERC20 rewardToken,\\n        uint256 duration,\\n        uint256 amount\\n    ) public payable returns (uint256 _duration) {\\n        rewardToken.safeTransferFrom(msg.sender, address(reward), amount);\\n        return reward.notifyRewardAmount(rewardToken, duration);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function createBoostedPositionAndAddLiquidityAndStake(\\n        address recipient,\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params,\\n        IERC20[] memory rewardTokens,\\n        IMaverickV2VotingEscrow[] memory veTokens\\n    )\\n        public\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint256 stakeAmount,\\n            IMaverickV2Reward reward,\\n            uint256 tokenId\\n        )\\n    {\\n        (boostedPosition, mintedLpAmount, tokenAAmount, tokenBAmount) = createBoostedPositionAndAddLiquidity(\\n            address(this),\\n            params\\n        );\\n        reward = rewardFactory.createRewardsContract(boostedPosition, rewardTokens, veTokens);\\n        tokenId = reward.mint(recipient);\\n        boostedPosition.transfer(address(reward.vault()), boostedPosition.balanceOf(address(this)));\\n        (stakeAmount, ) = reward.stake(tokenId);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function createBoostedPositionAndAddLiquidityAndStakeToSender(\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params,\\n        IERC20[] memory rewardTokens,\\n        IMaverickV2VotingEscrow[] memory veTokens\\n    )\\n        public\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint256 stakeAmount,\\n            IMaverickV2Reward reward,\\n            uint256 tokenId\\n        )\\n    {\\n        return createBoostedPositionAndAddLiquidityAndStake(msg.sender, params, rewardTokens, veTokens);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function addLiquidityAndMintBoostedPositionAndStake(\\n        uint256 tokenId,\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs,\\n        IMaverickV2Reward reward\\n    ) public payable returns (uint256 mintedLpAmount, uint256 tokenAAmount, uint256 tokenBAmount, uint256 stakeAmount) {\\n        (mintedLpAmount, tokenAAmount, tokenBAmount) = addLiquidityAndMintBoostedPosition(\\n            address(reward.vault()),\\n            boostedPosition,\\n            packedSqrtPriceBreaks,\\n            packedArgs\\n        );\\n        (stakeAmount, ) = reward.stake(tokenId);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function addLiquidityAndMintBoostedPositionAndStakeToSender(\\n        uint256 sendersTokenIndex,\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs,\\n        IMaverickV2Reward reward\\n    )\\n        public\\n        payable\\n        returns (\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint256 stakeAmount,\\n            uint256 tokenId\\n        )\\n    {\\n        if (reward.tokenOfOwnerByIndexExists(msg.sender, sendersTokenIndex)) {\\n            tokenId = reward.tokenOfOwnerByIndex(msg.sender, sendersTokenIndex);\\n        } else {\\n            tokenId = reward.mint(msg.sender);\\n        }\\n\\n        (mintedLpAmount, tokenAAmount, tokenBAmount, stakeAmount) = addLiquidityAndMintBoostedPositionAndStake(\\n            tokenId,\\n            boostedPosition,\\n            packedSqrtPriceBreaks,\\n            packedArgs,\\n            reward\\n        );\\n    }\\n\\n    function mintTokenInRewardToSender(IMaverickV2Reward reward) public payable returns (uint256 tokenId) {\\n        tokenId = reward.mint(msg.sender);\\n    }\\n\\n    function mintTokenInReward(IMaverickV2Reward reward, address recipient) public payable returns (uint256 tokenId) {\\n        tokenId = reward.mint(recipient);\\n    }\\n\\n    /// @inheritdoc IMaverickV2RewardRouter\\n    function sync(\\n        IMaverickV2VotingEscrowWSync ve,\\n        address staker,\\n        uint256[] memory legacyLockupIndexes\\n    ) public returns (uint256[] memory newBalance) {\\n        uint256 length = legacyLockupIndexes.length;\\n        newBalance = new uint256[](length);\\n        for (uint256 k; k < length; k++) {\\n            newBalance[k] = ve.sync(staker, k);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/rewardbase/IRewardAccounting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\ninterface IRewardAccounting {\\n    error InsufficientBalance(uint256 tokenId, uint256 currentBalance, uint256 value);\\n\\n    /**\\n     * @notice Balance of stake for a given `tokenId` account.\\n     */\\n    function stakeBalanceOf(uint256 tokenId) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice Sum of all balances across all tokenIds.\\n     */\\n    function stakeTotalSupply() external view returns (uint256 supply);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-rewards/contracts/votingescrowbase/IHistoricalBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\ninterface IHistoricalBalance {\\n    /**\\n     * @notice This function retrieves the historical balance of an account at\\n     * a specific point in time.\\n     * @param account The address of the account for which to retrieve the\\n     * historical balance.\\n     * @param timepoint The timepoint (block number or timestamp depending on\\n     * implementation) at which to query the balance (uint256).\\n     * @return balance The balance of the account at the specified timepoint.\\n     */\\n    function getPastBalanceOf(address account, uint256 timepoint) external view returns (uint256 balance);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/base/Checks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {IChecks} from \\\"./IChecks.sol\\\";\\nimport {PoolInspection} from \\\"../libraries/PoolInspection.sol\\\";\\n\\nabstract contract Checks is IChecks {\\n    /// @inheritdoc IChecks\\n    function checkSqrtPrice(IMaverickV2Pool pool, uint256 minSqrtPrice, uint256 maxSqrtPrice) public payable {\\n        uint256 sqrtPrice = PoolInspection.poolSqrtPrice(pool);\\n        if (sqrtPrice < minSqrtPrice || sqrtPrice > maxSqrtPrice)\\n            revert PositionExceededPriceBounds(sqrtPrice, minSqrtPrice, maxSqrtPrice);\\n    }\\n\\n    /// @inheritdoc IChecks\\n    function checkDeadline(uint256 deadline) public payable {\\n        if (block.timestamp > deadline) revert PositionDeadlinePassed(deadline, block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/base/IChecks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\ninterface IChecks {\\n    error PositionExceededPriceBounds(uint256 sqrtPrice, uint256 minSqrtPrice, uint256 maxSqrtPrice);\\n    error PositionDeadlinePassed(uint256 deadline, uint256 blockTimestamp);\\n\\n    /**\\n     * @notice Function to check if the price of a pool is within specified bounds.\\n     * @param pool The MaverickV2Pool contract to check.\\n     * @param minSqrtPrice The minimum acceptable square root price.\\n     * @param maxSqrtPrice The maximum acceptable square root price.\\n     */\\n    function checkSqrtPrice(IMaverickV2Pool pool, uint256 minSqrtPrice, uint256 maxSqrtPrice) external payable;\\n\\n    /**\\n     * @notice Function to check if a given deadline has passed.\\n     * @param deadline The timestamp representing the deadline.\\n     */\\n    function checkDeadline(uint256 deadline) external payable;\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/base/IMigrateBins.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\ninterface IMigrateBins {\\n    function migrateBinsUpStack(IMaverickV2Pool pool, uint32[] calldata binIds, uint32 maxRecursion) external payable;\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/base/MigrateBins.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {IMigrateBins} from \\\"./IMigrateBins.sol\\\";\\n\\nabstract contract MigrateBins is IMigrateBins {\\n    /**\\n     * @dev Migrates bins up the stack in the pool.\\n     * @param pool The MaverickV2Pool contract.\\n     * @param binIds An array of bin IDs to migrate.\\n     * @param maxRecursion The maximum recursion depth.\\n     */\\n    function migrateBinsUpStack(IMaverickV2Pool pool, uint32[] memory binIds, uint32 maxRecursion) public payable {\\n        for (uint256 i = 0; i < binIds.length; i++) {\\n            pool.migrateBinUpStack(binIds[i], maxRecursion);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/boostedpositionbase/IBoostedPositionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {IMulticall} from \\\"@maverick/v2-common/contracts/base/IMulticall.sol\\\";\\n\\nimport {IChecks} from \\\"../base/IChecks.sol\\\";\\n\\ninterface IBoostedPositionBase is IERC20Metadata, IChecks, IMulticall {\\n    /**\\n     * @notice BP Pool.\\n     */\\n    function pool() external view returns (IMaverickV2Pool pool_);\\n\\n    /**\\n     * @notice BP Bin kind (static, right, left, both).\\n     */\\n    function kind() external view returns (uint8 kind_);\\n\\n    /**\\n     * @notice Number of bins in the BP.\\n     */\\n    function binCount() external view returns (uint8 binCount_);\\n\\n    /**\\n     * @notice Liquidity balance in BP bins since last mint/burn operation.\\n     */\\n    function getBinBalances() external view returns (uint128[] memory binBalances_);\\n\\n    /**\\n     * @notice Liquidity balance in given BP bin since last mint/burn\\n     * operation.\\n     */\\n    function binBalances(uint256 index) external view returns (uint128 binBalance);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2BoostedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IBoostedPositionBase} from \\\"../boostedpositionbase/IBoostedPositionBase.sol\\\";\\n\\ninterface IMaverickV2BoostedPosition is IBoostedPositionBase {\\n    event BoostedPositionMigrateBinLiquidity(uint32 currentBinId, uint32 newBinId, uint128 newBinBalance);\\n\\n    error BoostedPositionTooLittleLiquidityAdded(uint256 binIdIndex, uint32 binId, uint128 required, uint128 available);\\n    error BoostedPositionMovementBinNotMigrated();\\n\\n    /**\\n     * @notice Mints BP LP position to recipient.  User has to add liquidity to\\n     * BP contract before making this call as this mint function simply assigns\\n     * any new liquidity that this BP possesses in the pool to the recipient.\\n     * Accordingly, this function should only be called in the same transaction\\n     * where liquidity has been added to a pool as part of a multicall or\\n     * through a router/manager contract.\\n     */\\n    function mint(address recipient) external returns (uint256 deltaSupply);\\n\\n    /**\\n     * @notice Burns BP LP positions and redeems the underlying A/B token to the recipient.\\n     */\\n    function burn(address recipient, uint256 amount) external returns (uint256 tokenAOut, uint256 tokenBOut);\\n\\n    /**\\n     * @notice Migrates all underlying movement-mode liquidity from a merged\\n     * bin to the active parent of the merged bin.  For Static BPs, this\\n     * function is a no-op and never needs to be called.\\n     */\\n    function migrateBinLiquidityToRoot() external;\\n\\n    /**\\n     * @notice Array of ticks where the underlying BP liquidity exists.\\n     */\\n    function getTicks() external view returns (int32[] memory ticks);\\n\\n    /**\\n     * @notice Array of relative pool bin LP balance of the bins in the BP.\\n     */\\n    function getRatios() external view returns (uint128[] memory ratios_);\\n\\n    /**\\n     * @notice Array of BP binIds.  Will revert if the BP is a movement mode\\n     * and the underlying bin is merged.\\n     */\\n    function getBinIds() external view returns (uint32[] memory binIds_);\\n\\n    /**\\n     * @notice Array of BP binIds.  Will not revert if the BP is a movement mode\\n     * and the underlying bin is merged.  For statis BPs, this returns the same\\n     * value as `getBinIds`.\\n     */\\n    function getRawBinIds() external view returns (uint32[] memory);\\n\\n    /**\\n     * @notice Removes excess liquidity from the binId[0] bin and sends to\\n     * recipient. Skimming is desirable if there is more than one bin in the BP\\n     * and the skimmable amount is non-zero.\\n     * Skimming amount is only applicable if the number of bins is more than\\n     * one.  For single-bin BPs, a user can effectively \\\"skim\\\" by minting BP\\n     * tokens to themselves.\\n     */\\n    function skim(address recipient) external returns (uint256 tokenAOut, uint256 tokenBOut);\\n\\n    /**\\n     * @notice Returns the amount of binIds[0] LP balance that is skimmable in\\n     * the BP.  If this number is non-zero, it is desirable to skim before\\n     * minting to ensure that the ratio solvency checks pass.  Checking the\\n     * skimmable amount is only applicable if the number of bins is more than\\n     * one.  For single-bin BPs, a user can effectively \\\"skim\\\" by minting BP\\n     * tokens to themselves.\\n     */\\n    function skimmableAmount() external view returns (uint128 amount);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2BoostedPositionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\nimport {IMaverickV2BoostedPosition} from \\\"./IMaverickV2BoostedPosition.sol\\\";\\n\\ninterface IMaverickV2BoostedPositionFactory {\\n    error BoostedPositionFactoryNotFactoryPool();\\n    error BoostedPositionPermissionedLiquidityPool();\\n    error BoostedPositionFactoryKindNotSupportedByPool(uint8 poolKinds, uint8 kind);\\n    error BoostedPositionFactoryInvalidRatioZero(uint128 ratioZero);\\n    error BoostedPositionFactoryInvalidLengths(uint256 ratioLength, uint256 binIdsLength);\\n    error BoostedPositionFactoryInvalidLengthForKind(uint8 kind, uint256 ratiosLength);\\n    error BoostedPositionFactoryBinIdsNotSorted(uint256 index, uint32 lastBinId, uint32 thisBinId);\\n    error BoostedPositionFactoryInvalidBinKind(uint8 inputKind, uint8 binKind, uint32 binId);\\n\\n    event CreateBoostedPosition(\\n        IMaverickV2Pool pool,\\n        uint32[] binIds,\\n        uint128[] ratios,\\n        uint8 kind,\\n        IMaverickV2BoostedPosition boostedPosition\\n    );\\n\\n    /**\\n     * @notice Creates BP from the specified input parameters.  Requirements:\\n     *\\n     * - Pool must be from pool factory\\n     * - BP kind must be supported by the pool\\n     * - BinIds have to be sorted in ascending order\\n     * - ratios[0] must be 1e18; ratios are specified in D18 scale\\n     * - ratio and binId arrays have to be the same length\\n     * - movement-mode BPs can only have one binId\\n     * - static-mode BPs can have at most 24 binIds\\n     */\\n    function createBoostedPosition(\\n        IMaverickV2Pool pool,\\n        uint32[] memory binIds,\\n        uint128[] memory ratios,\\n        uint8 kind\\n    ) external returns (IMaverickV2BoostedPosition boostedPosition);\\n\\n    /**\\n     * @notice Look up BPs by range of indexes.\\n     */\\n    function lookup(uint256 startIndex, uint256 endIndex) external view returns (IMaverickV2BoostedPosition[] memory);\\n\\n    /**\\n     * @notice Returns count of all BPs deployed by the factory.\\n     */\\n    function boostedPositionsCount() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Look up BPs by range of indexes for a given pool.\\n     */\\n    function lookup(\\n        IMaverickV2Pool pool,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (IMaverickV2BoostedPosition[] memory);\\n\\n    /**\\n     * @notice Returns count of all BPs deployed by the factory for a given\\n     * pool.\\n     */\\n    function boostedPositionsByPoolCount(IMaverickV2Pool pool) external view returns (uint256 count);\\n\\n    /**\\n     * @notice Returns whether or not input BP was created by this factory.\\n     */\\n    function isFactoryBoostedPosition(IMaverickV2BoostedPosition) external returns (bool);\\n\\n    /**\\n     * @notice Pool factory that all BPs pool must be deployed from.\\n     */\\n    function poolFactory() external returns (IMaverickV2Factory);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2LiquidityManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\nimport {IMaverickV2Position} from \\\"./IMaverickV2Position.sol\\\";\\nimport {IMaverickV2BoostedPosition} from \\\"./IMaverickV2BoostedPosition.sol\\\";\\nimport {IMaverickV2PoolLens} from \\\"./IMaverickV2PoolLens.sol\\\";\\nimport {IMaverickV2BoostedPositionFactory} from \\\"./IMaverickV2BoostedPositionFactory.sol\\\";\\nimport {IArgPacker} from \\\"../liquiditybase/IArgPacker.sol\\\";\\nimport {IExactOutputSlim} from \\\"../routerbase/IExactOutputSlim.sol\\\";\\nimport {IPayment} from \\\"../paymentbase/IPayment.sol\\\";\\nimport {IChecks} from \\\"../base/IChecks.sol\\\";\\nimport {IMigrateBins} from \\\"../base/IMigrateBins.sol\\\";\\n\\ninterface IMaverickV2LiquidityManager is IPayment, IChecks, IExactOutputSlim, IArgPacker, IMigrateBins {\\n    error LiquidityManagerNotFactoryPool();\\n    error LiquidityManagerNotTokenIdOwner();\\n\\n    /**\\n     * @notice Maverick V2 NFT position contract that tracks NFT-based\\n     * liquditiy positions.\\n     */\\n    function position() external view returns (IMaverickV2Position);\\n\\n    /**\\n     * @notice Maverick V2 BP factory contract.\\n     */\\n    function boostedPositionFactory() external view returns (IMaverickV2BoostedPositionFactory);\\n\\n    /**\\n     * @notice Create Maverick V2 pool.  Function is a pass through to the pool\\n     * factory and is provided here so that is can be assembled as part of a\\n     * multicall transaction.\\n     */\\n    function createPool(\\n        uint64 fee,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds\\n    ) external payable returns (IMaverickV2Pool pool);\\n\\n    /**\\n     * @notice Create Maverick V2 pool with two-way fees.  Function is a pass\\n     * through to the pool factory and is provided here so that is can be\\n     * assembled as part of a multicall transaction.\\n     */\\n    function createPool(\\n        uint64 feeAIn,\\n        uint64 feeBIn,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds\\n    ) external payable returns (IMaverickV2Pool pool);\\n\\n    /**\\n     * @notice Add Liquidity to a Maverick V2 pool.  Function is a pass through\\n     * to the pool and is provided here so that is can be assembled as part of a\\n     * multicall transaction.  Users can add liquidity to the Position NFT\\n     * contract or a BP as part of a multicall in order to mint NFT/BP\\n     * positions.\\n     * @dev Liquidity is specified as bytes that represent a lookup table of\\n     * add parameters.  This allows an adder to specify what liquidity amounts\\n     * they wish to add conditional on the price of the pool when their\\n     * transaction is executed.  With this, users have fine-grain control of how\\n     * price slippage affects the amount of liquidity they add.  The\\n     * MaverickV2PoolLens contract has helper view functions that can be used\\n     * to easily create a combination of price breaks and packed arguments.\\n     */\\n    function addLiquidity(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        uint256 subaccount,\\n        bytes calldata packedSqrtPriceBreaks,\\n        bytes[] calldata packedArgs\\n    ) external payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds);\\n\\n    /**\\n     * @notice Add Liquidity position NFT for msg.sender by specifying\\n     * msg.sender's token index.\\n     * @dev Token index is different from tokenId.\\n     * On the Position NFT contract a user can own multiple NFT tokenIds and\\n     * these are indexes by an enumeration index which is the `index` input\\n     * here.\\n     *\\n     * See addLiquidity for a description of the add params.\\n     */\\n    function addPositionLiquidityToSenderByTokenIndex(\\n        IMaverickV2Pool pool,\\n        uint256 index,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) external payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds);\\n\\n    /**\\n     * @notice Add Liquidity position NFT for msg.sender by specifying\\n     * recipient's token index.\\n     * @dev Token index is different from tokenId.\\n     * On the Position NFT contract a user can own multiple NFT tokenIds and\\n     * these are indexes by an enumeration index which is the `index` input\\n     * here.\\n     *\\n     * See addLiquidity for a description of the add params.\\n     */\\n    function addPositionLiquidityToRecipientByTokenIndex(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        uint256 index,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) external payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds);\\n\\n    /**\\n     * @notice Pass through function to the BP bin migration.\\n     */\\n    function migrateBoostedPosition(IMaverickV2BoostedPosition boostedPosition) external payable;\\n\\n    /**\\n     * @notice Mint new tokenId in the Position NFT contract. Both mints an NFT\\n     * and adds liquidity to the pool that is held by the NFT.\\n     * @dev Caller must approve this LiquidityManager contract to spend the\\n     * caller's token A/B in order to fund the liquidity position.\\n     *\\n     * See addLiquidity for a description of the add params.\\n     */\\n    function mintPositionNft(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        bytes calldata packedSqrtPriceBreaks,\\n        bytes[] calldata packedArgs\\n    ) external payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds, uint256 tokenId);\\n\\n    /**\\n     * @notice Mint new tokenId in the Position NFt contract to msg.sender.\\n     * Both mints an NFT and adds liquidity to the pool that is held by the\\n     * NFT.\\n     */\\n    function mintPositionNftToSender(\\n        IMaverickV2Pool pool,\\n        bytes calldata packedSqrtPriceBreaks,\\n        bytes[] calldata packedArgs\\n    ) external payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds, uint256 tokenId);\\n\\n    /**\\n     * @notice Mint BP LP tokens to recipient.  This function does not add\\n     * liquidity to the BP and is only useful in conjuction with addLiquidity\\n     * as part of a multcall.\\n     */\\n    function mintBoostedPosition(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        address recipient\\n    ) external payable returns (uint256 mintedLpAmount);\\n\\n    /**\\n     * @notice Donates liqudity to a pool that is held by the position contract\\n     * and will never be retrievable.  Can be used to start a pool and ensure\\n     * there will always be a base level of liquditiy in the pool.\\n     */\\n    function donateLiquidity(IMaverickV2Pool pool, IMaverickV2Pool.AddLiquidityParams memory args) external payable;\\n\\n    /**\\n     * @notice Creates a pool at a specified price and mints a Position NFT\\n     * with liquidity to the recipient.\\n     * @dev A Maverick V2 pool has no native was to specify a starting price,\\n     * only a starting `activeTick`.  The initial pool price will be the left\\n     * edge of the initial activeTick.  In order to create a pool at a fixed\\n     * price, this function dontes a small amount of liquidity to the pool, does\\n     * a swap to the specified price, and then adds liquidity for the user.\\n     */\\n    function createPoolAtPriceAndAddLiquidity(\\n        address recipient,\\n        IMaverickV2PoolLens.CreateAndAddParamsInputs memory params\\n    )\\n        external\\n        payable\\n        returns (\\n            IMaverickV2Pool pool,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint32[] memory binIds,\\n            uint256 tokenId\\n        );\\n\\n    /**\\n     * @notice Creates a pool at a specified price and mints a Position NFT\\n     * with liquidity to msg.sender.\\n     */\\n    function createPoolAtPriceAndAddLiquidityToSender(\\n        IMaverickV2PoolLens.CreateAndAddParamsInputs memory params\\n    )\\n        external\\n        payable\\n        returns (\\n            IMaverickV2Pool pool,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint32[] memory binIds,\\n            uint256 tokenId\\n        );\\n\\n    /**\\n     * @notice Executes the multi-step process of minting BP LP positions by\\n     * adding liqudiity to a pool in the BP liquidity distribution and then\\n     * minting the BP to recipient.\\n     * @dev Caller will need to approve this LiquidityManager contract to spend\\n     * their token A/B in order to execute this function.\\n     */\\n    function addLiquidityAndMintBoostedPosition(\\n        address recipient,\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) external payable returns (uint256 mintedLpAmount, uint256 tokenAAmount, uint256 tokenBAmount);\\n\\n    /**\\n     * @notice Executes the multi-step process of minting BP LP positions by\\n     * adding liquidity to a pool in the BP liquidity distribution and then\\n     * minting the BP to msg.sender.\\n     * @dev Caller will need to approve this LiquidityManager contract to spend\\n     * their token A/B in order to execute this function.\\n     */\\n    function addLiquidityAndMintBoostedPositionToSender(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) external payable returns (uint256 mintedLpAmount, uint256 tokenAAmount, uint256 tokenBAmount);\\n\\n    /**\\n     * @notice Deploy new BP contract from the BP factory and mint BP LP tokens\\n     * to the recipient.\\n     * @dev Caller will need to approve this LiquidityManager contract to spend\\n     * their token A/B in order to execute this function.\\n     */\\n    function createBoostedPositionAndAddLiquidity(\\n        address recipient,\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params\\n    )\\n        external\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount\\n        );\\n\\n    /**\\n     * @notice Deploy new BP contract from the BP factory and mint BP LP tokens\\n     * to msg.sender.\\n     * @dev Caller will need to approve this LiquidityManager contract to spend\\n     * their token A/B in order to execute this function.\\n     */\\n    function createBoostedPositionAndAddLiquidityToSender(\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params\\n    )\\n        external\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount\\n        );\\n\\n    /**\\n     * @notice Skims excess liquidity in a BP to the recipient.\\n     */\\n    function skimBoostedPosition(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        address recipient\\n    ) external payable returns (uint256 tokenAAmount, uint256 tokenBAmount);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2PoolLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {IMaverickV2BoostedPosition} from \\\"./IMaverickV2BoostedPosition.sol\\\";\\n\\ninterface IMaverickV2PoolLens {\\n    error LensTargetPriceOutOfBounds(uint256 targetSqrtPrice, uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice);\\n    error LensTooLittleLiquidity(uint256 relativeLiquidityAmount, uint256 deltaA, uint256 deltaB);\\n    error LensTargetingTokenWithNoDelta(bool targetIsA, uint256 deltaA, uint256 deltaB);\\n\\n    /**\\n     * @notice Add liquidity slippage parameters for a distribution of liquidity.\\n     * @param pool Pool where liquidity is being added.\\n     * @param kind Bin kind; all bins must have the same kind in a given call\\n     * to addLiquidity.\\n     * @param ticks Array of tick values to add liquidity to.\\n     * @param relativeLiquidityAmounts Relative liquidity amounts for the\\n     * specified ticks.  Liquidity in this case is not bin LP balance, it is\\n     * the bin liquidity as defined by liquidity = deltaA / (sqrt(upper) -\\n     * sqrt(lower)) or deltaB = liquidity / sqrt(lower) - liquidity /\\n     * sqrt(upper).\\n     * @param addSpec Slippage specification.\\n     */\\n    struct AddParamsViewInputs {\\n        IMaverickV2Pool pool;\\n        uint8 kind;\\n        int32[] ticks;\\n        uint128[] relativeLiquidityAmounts;\\n        AddParamsSpecification addSpec;\\n    }\\n\\n    /**\\n     * @notice Multi-price add param specification.\\n     * @param slippageFactorD18 Max slippage allowed as a percent in D18 scale. e.g. 1% slippage is 0.01e18\\n     * @param numberOfPriceBreaksPerSide Number of price break values on either\\n     * side of current price.\\n     * @param targetAmount Target token contribution amount in tokenA if\\n     * targetIsA is true, otherwise this is the target amount for tokenB.\\n     * @param targetIsA  Indicates if the target amount is for tokenA or tokenB\\n     */\\n    struct AddParamsSpecification {\\n        uint256 slippageFactorD18;\\n        uint256 numberOfPriceBreaksPerSide;\\n        uint256 targetAmount;\\n        bool targetIsA;\\n    }\\n\\n    /**\\n     * @notice Boosted position creation specification and add parameters.\\n     * @param bpSpec Boosted position kind/binId/ratio information.\\n     * @param packedSqrtPriceBreaks Array of sqrt price breaks packed into\\n     * bytes.  These breaks act as a lookup table for the packedArgs array to\\n     * indicate to the Liquidity manager what add liquidity parameters from\\n     * packedArgs to use depending on the price of the pool at add time.\\n     * @param packedArgs Array of bytes arguments.  Each array element is a\\n     * packed version of addLiquidity paramters.\\n     */\\n    struct CreateBoostedPositionInputs {\\n        BoostedPositionSpecification bpSpec;\\n        bytes packedSqrtPriceBreaks;\\n        bytes[] packedArgs;\\n    }\\n\\n    /**\\n     * @notice Specification for deriving create pool parameters. Creating a pool in the liquidity manager has several steps:\\n     *\\n     * - Deploy pool\\n     * - Donate a small amount of initial liquidity in the activeTick\\n     * - Execute a small swap to set the pool price to the desired value\\n     * - Add liquidity\\n     *\\n     * In order to execute these steps, the caller must specify the parameters\\n     * of each step.  The PoolLens has helper function to derive the values\\n     * used by the LiquidityManager, but this struct is the input to that\\n     * helper function and represents the core intent of the pool creator.\\n     *\\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\\n     * D18 scale.\\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\\n     * bin width.\\n     * @param lookback Pool lookback in seconds.\\n     * @param tokenA Address of tokenA.\\n     * @param tokenB Address of tokenB.\\n     * @param activeTick Tick position that contains the active bins.\\n     * @param kinds 1-15 number to represent the active kinds\\n     * 0b0001 = static;\\n     * 0b0010 = right;\\n     * 0b0100 = left;\\n     * 0b1000 = both.\\n     * e.g. a pool with all 4 modes will have kinds = b1111 = 15\\n     * @param initialTargetB Amount of B to be donated to the pool after pool\\n     * create.  This amount needs to be big enough to meet the minimum bin\\n     * liquidity.\\n     * @param sqrtPrice Target sqrt price of the pool.\\n     * @param kind Bin kind; all bins must have the same kind in a given call\\n     * to addLiquidity.\\n     * @param ticks Array of tick values to add liquidity to.\\n     * @param relativeLiquidityAmounts Relative liquidity amounts for the\\n     * specified ticks.  Liquidity in this case is not bin LP balance, it is\\n     * the bin liquidity as defined by liquidity = deltaA / (sqrt(upper) -\\n     * sqrt(lower)) or deltaB = liquidity / sqrt(lower) - liquidity /\\n     * sqrt(upper).\\n     * @param targetAmount Target token contribution amount in tokenA if\\n     * targetIsA is true, otherwise this is the target amount for tokenB.\\n     * @param targetIsA  Indicates if the target amount is for tokenA or tokenB\\n     */\\n    struct CreateAndAddParamsViewInputs {\\n        uint64 feeAIn;\\n        uint64 feeBIn;\\n        uint16 tickSpacing;\\n        uint32 lookback;\\n        IERC20 tokenA;\\n        IERC20 tokenB;\\n        int32 activeTick;\\n        uint8 kinds;\\n        // donate params\\n        uint256 initialTargetB;\\n        uint256 sqrtPrice;\\n        // add target\\n        uint8 kind;\\n        int32[] ticks;\\n        uint128[] relativeLiquidityAmounts;\\n        uint256 targetAmount;\\n        bool targetIsA;\\n    }\\n\\n    struct Output {\\n        uint256 deltaAOut;\\n        uint256 deltaBOut;\\n        uint256[] deltaAs;\\n        uint256[] deltaBs;\\n        uint128[] deltaLpBalances;\\n    }\\n\\n    struct Reserves {\\n        uint256 amountA;\\n        uint256 amountB;\\n    }\\n\\n    struct BinPositionKinds {\\n        uint128[4] values;\\n    }\\n\\n    struct PoolState {\\n        IMaverickV2Pool.TickState[] tickStateMapping;\\n        IMaverickV2Pool.BinState[] binStateMapping;\\n        BinPositionKinds[] binIdByTickKindMapping;\\n        IMaverickV2Pool.State state;\\n        Reserves protocolFees;\\n    }\\n\\n    struct BoostedPositionSpecification {\\n        IMaverickV2Pool pool;\\n        uint32[] binIds;\\n        uint128[] ratios;\\n        uint8 kind;\\n    }\\n\\n    struct CreateAndAddParamsInputs {\\n        uint64 feeAIn;\\n        uint64 feeBIn;\\n        uint16 tickSpacing;\\n        uint32 lookback;\\n        IERC20 tokenA;\\n        IERC20 tokenB;\\n        int32 activeTick;\\n        uint8 kinds;\\n        // donate params\\n        IMaverickV2Pool.AddLiquidityParams donateParams;\\n        // swap params\\n        uint256 swapAmount;\\n        // add params\\n        IMaverickV2Pool.AddLiquidityParams addParams;\\n        bytes[] packedAddParams;\\n        uint256 deltaAOut;\\n        uint256 deltaBOut;\\n        uint256 preAddReserveA;\\n        uint256 preAddReserveB;\\n    }\\n\\n    struct TickDeltas {\\n        uint256 deltaAOut;\\n        uint256 deltaBOut;\\n        uint256[] deltaAs;\\n        uint256[] deltaBs;\\n    }\\n\\n    /**\\n     * @notice Converts add parameter slippage specification into add\\n     * parameters.  The return values are given in both raw format and as packed\\n     * values that can be used in the LiquidityManager contract.\\n     */\\n    function getAddLiquidityParams(\\n        AddParamsViewInputs memory params\\n    )\\n        external\\n        view\\n        returns (\\n            bytes memory packedSqrtPriceBreaks,\\n            bytes[] memory packedArgs,\\n            uint88[] memory sqrtPriceBreaks,\\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\\n        );\\n\\n    /**\\n     * @notice Converts add parameter slippage specification for a boosted\\n     * position into add parameters.  The return values are given in both raw\\n     * format and as packed values that can be used in the LiquidityManager\\n     * contract.\\n     */\\n    function getAddLiquidityParamsForBoostedPosition(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        AddParamsSpecification memory addSpec\\n    )\\n        external\\n        view\\n        returns (\\n            bytes memory packedSqrtPriceBreaks,\\n            bytes[] memory packedArgs,\\n            uint88[] memory sqrtPriceBreaks,\\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\\n        );\\n\\n    /**\\n     * @notice Converts add parameter slippage specification and boosted\\n     * position specification into add parameters.  The return values are given\\n     * in both raw format and as packed values that can be used in the\\n     * LiquidityManager contract.\\n     */\\n    function getCreateBoostedPositionParams(\\n        BoostedPositionSpecification memory bpSpec,\\n        AddParamsSpecification memory addSpec\\n    )\\n        external\\n        view\\n        returns (\\n            bytes memory packedSqrtPriceBreaks,\\n            bytes[] memory packedArgs,\\n            uint88[] memory sqrtPriceBreaks,\\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\\n        );\\n\\n    /**\\n     * @notice Converts add parameter slippage specification and new pool\\n     * specification into CreateAndAddParamsInputs parameters that can be used in the\\n     * LiquidityManager contract.\\n     */\\n    function getCreatePoolAtPriceAndAddLiquidityParams(\\n        CreateAndAddParamsViewInputs memory params,\\n        IMaverickV2Factory factory\\n    ) external view returns (CreateAndAddParamsInputs memory output);\\n\\n    /**\\n     * @notice View function that provides information about pool ticks within\\n     * a tick radius from the activeTick. Ticks with no reserves are not\\n     * included in part o f the return array.\\n     */\\n    function getTicksAroundActive(\\n        IMaverickV2Pool pool,\\n        int32 tickRadius\\n    ) external view returns (int32[] memory ticks, IMaverickV2Pool.TickState[] memory tickStates);\\n\\n    /**\\n     * @notice View function that provides information about pool ticks within\\n     * a range. Ticks with no reserves are not included in part o f the return\\n     * array.\\n     */\\n    function getTicks(\\n        IMaverickV2Pool pool,\\n        int32 tickStart,\\n        int32 tickEnd\\n    ) external view returns (int32[] memory ticks, IMaverickV2Pool.TickState[] memory tickStates);\\n\\n    /**\\n     * @notice View function that provides information about pool ticks within\\n     * a range.  Information returned includes all pool state needed to emulate\\n     * a swap off chain. Ticks with no reserves are not included in part o f\\n     * the return array.\\n     */\\n    function getTicksAroundActiveWLiquidity(\\n        IMaverickV2Pool pool,\\n        int32 tickRadius\\n    )\\n        external\\n        view\\n        returns (\\n            int32[] memory ticks,\\n            IMaverickV2Pool.TickState[] memory tickStates,\\n            uint256[] memory liquidities,\\n            uint256[] memory sqrtLowerTickPrices,\\n            uint256[] memory sqrtUpperTickPrices,\\n            IMaverickV2Pool.State memory poolState,\\n            uint256 sqrtPrice,\\n            uint256 feeAIn,\\n            uint256 feeBIn\\n        );\\n\\n    /**\\n     * @notice View function that provides pool state information.\\n     */\\n    function getFullPoolState(\\n        IMaverickV2Pool pool,\\n        uint32 binStart,\\n        uint32 binEnd\\n    ) external view returns (PoolState memory poolState);\\n\\n    /**\\n     * @notice View function that provides price and liquidity of a given tick.\\n     */\\n    function getTickSqrtPriceAndL(\\n        IMaverickV2Pool pool,\\n        int32 tick\\n    ) external view returns (uint256 sqrtPrice, uint256 liquidity);\\n\\n    /**\\n     * @notice Pool sqrt price.\\n     */\\n    function getPoolSqrtPrice(IMaverickV2Pool pool) external view returns (uint256 sqrtPrice);\\n\\n    /**\\n     * @notice Pool price.\\n     */\\n    function getPoolPrice(IMaverickV2Pool pool) external view returns (uint256 price);\\n\\n    /**\\n     * @notice Token scale of two tokens in a pool.\\n     */\\n    function tokenScales(IMaverickV2Pool pool) external view returns (uint256 tokenAScale, uint256 tokenBScale);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/interfaces/IMaverickV2Position.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {IMulticall} from \\\"@maverick/v2-common/contracts/base/IMulticall.sol\\\";\\nimport {IPositionImage} from \\\"./IPositionImage.sol\\\";\\nimport {INft} from \\\"../positionbase/INft.sol\\\";\\nimport {IMigrateBins} from \\\"../base/IMigrateBins.sol\\\";\\nimport {IChecks} from \\\"../base/IChecks.sol\\\";\\n\\ninterface IMaverickV2Position is INft, IMigrateBins, IMulticall, IChecks {\\n    event PositionClearData(uint256 indexed tokenId);\\n    event PositionSetData(uint256 indexed tokenId, uint256 index, PositionPoolBinIds newData);\\n\\n    error PositionDuplicatePool(uint256 index, IMaverickV2Pool pool);\\n    error PositionNotFactoryPool();\\n    error PositionPermissionedLiquidityPool();\\n\\n    struct PositionPoolBinIds {\\n        IMaverickV2Pool pool;\\n        uint32[] binIds;\\n    }\\n\\n    struct PositionFullInformation {\\n        PositionPoolBinIds poolBinIds;\\n        uint256 amountA;\\n        uint256 amountB;\\n        uint256[] binAAmounts;\\n        uint256[] binBAmounts;\\n        int32[] ticks;\\n        uint256[] liquidities;\\n    }\\n\\n    /**\\n     * @notice Contract that renders the position nft svg image.\\n     */\\n    function positionImage() external view returns (IPositionImage);\\n\\n    /**\\n     * @notice Pool factory.\\n     */\\n    function factory() external view returns (IMaverickV2Factory);\\n\\n    /**\\n     * @notice Mint NFT that holds liquidity in a Maverick V2 Pool. To mint\\n     * liquidity to an NFT, add liquidity to bins in a pool where the\\n     * add liquidity recipient is this contract and the subaccount is the\\n     * tokenId. LiquidityManager can be used to simplify minting Position NFTs.\\n     */\\n    function mint(address recipient, IMaverickV2Pool pool, uint32[] memory binIds) external returns (uint256 tokenId);\\n\\n    /**\\n     * @notice Overwrites tokenId pool/binId information for a given data index.\\n     */\\n    function setTokenIdData(uint256 tokenId, uint256 index, IMaverickV2Pool pool, uint32[] memory binIds) external;\\n\\n    /**\\n     * @notice Overwrites entire pool/binId data set for a given tokenId.\\n     */\\n    function setTokenIdData(uint256 tokenId, PositionPoolBinIds[] memory data) external;\\n\\n    /**\\n     * @notice Append new pool/binIds data array to tokenId.\\n     */\\n    function appendTokenIdData(uint256 tokenId, IMaverickV2Pool pool, uint32[] memory binIds) external;\\n\\n    /**\\n     * @notice Get array pool/binIds data for a given tokenId.\\n     */\\n    function getTokenIdData(uint256 tokenId) external view returns (PositionPoolBinIds[] memory);\\n\\n    /**\\n     * @notice Get value from array of pool/binIds data for a given tokenId.\\n     */\\n    function getTokenIdData(uint256 tokenId, uint256 index) external view returns (PositionPoolBinIds memory);\\n\\n    /**\\n     * @notice Length of array of pool/binIds data for a given tokenId.\\n     */\\n    function tokenIdDataLength(uint256 tokenId) external view returns (uint256 length);\\n\\n    /**\\n     * @notice Remove liquidity from tokenId for a given pool.  User can\\n     * specify arbitrary bins to remove from for their subaccount in the pool\\n     * even if those bins are not in the tokenIdData set.\\n     */\\n    function removeLiquidity(\\n        uint256 tokenId,\\n        address recipient,\\n        IMaverickV2Pool pool,\\n        IMaverickV2Pool.RemoveLiquidityParams memory params\\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount);\\n\\n    /**\\n     * @notice Remove liquidity from tokenId for a given pool to sender.  User\\n     * can specify arbitrary bins to remove from for their subaccount in the\\n     * pool even if those bins are not in the tokenIdData set.\\n     */\\n    function removeLiquidityToSender(\\n        uint256 tokenId,\\n        IMaverickV2Pool pool,\\n        IMaverickV2Pool.RemoveLiquidityParams memory params\\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount);\\n\\n    /**\\n     * @notice NFT asset information for a given range of pool/binIds indexes.\\n     * This function only returns the liquidity in the pools/binIds stored as\\n     * part of the tokenIdData, but it is possible that the NFT has additional\\n     * liquidity in pools/binIds that have not been recorded.\\n     */\\n    function tokenIdPositionInformation(\\n        uint256 tokenId,\\n        uint256 startIndex,\\n        uint256 stopIndex\\n    ) external view returns (PositionFullInformation[] memory output);\\n\\n    /**\\n     * @notice NFT asset information for a given pool/binIds index. This\\n     * function only returns the liquidity in the pools/binIds stored as part\\n     * of the tokenIdData, but it is possible that the NFT has additional\\n     * liquidity in pools/binIds that have not been recorded.\\n     */\\n    function tokenIdPositionInformation(\\n        uint256 tokenId,\\n        uint256 index\\n    ) external view returns (PositionFullInformation memory output);\\n\\n    /**\\n     * @notice Get remove paramters for removing a fractional part of the\\n     * liquidity owned by a given tokenId.  The fractional factor to remove is\\n     * given by proporationD18 in 18-decimal scale.\\n     */\\n    function getRemoveParams(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint256 proportionD18\\n    ) external view returns (IMaverickV2Pool.RemoveLiquidityParams memory params);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/interfaces/IPositionImage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\nimport {IMaverickV2Position} from \\\"./IMaverickV2Position.sol\\\";\\n\\ninterface IPositionImage {\\n    error PositionImageSetPositionError(address sender, address deployer, IMaverickV2Position currentPosition);\\n\\n    function position() external view returns (IMaverickV2Position _position);\\n    function setPosition(IMaverickV2Position _position) external;\\n    function image(uint256 tokenId, address tokenOwner) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.25;\\n\\n// Adapted from https://github.com/GNSPS/solidity-bytes-utils/blob/1dff13ef21304eb3634cb9e7f86c119cf280bd35/contracts/BytesLib.sol\\nlibrary BytesLib {\\n    error BytesLibToBoolOutOfBounds();\\n    error BytesLibToAddressOutOfBounds();\\n    error BytesLibSliceOverflow();\\n    error BytesLibSliceOutOfBounds();\\n    error BytesLibInvalidLength(uint256 inputLength, uint256 expectedLength);\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        // 31 is added to _length in assembly; need to check here that that\\n        // operation will not overflow\\n        if (_length > type(uint256).max - 31) revert BytesLibSliceOverflow();\\n        if (_bytes.length < _start + _length) revert BytesLibSliceOutOfBounds();\\n\\n        bytes memory tempBytes;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address addr) {\\n        unchecked {\\n            if (_bytes.length < _start + 20) revert BytesLibToAddressOutOfBounds();\\n\\n            assembly (\\\"memory-safe\\\") {\\n                addr := and(0xffffffffffffffffffffffffffffffffffffffff, mload(add(add(_bytes, 20), _start)))\\n            }\\n        }\\n    }\\n\\n    function toBool(bytes memory _bytes, uint256 _start) internal pure returns (bool) {\\n        unchecked {\\n            if (_bytes.length < _start + 1) revert BytesLibToBoolOutOfBounds();\\n            uint8 tempUint;\\n\\n            assembly (\\\"memory-safe\\\") {\\n                tempUint := mload(add(add(_bytes, 1), _start))\\n            }\\n\\n            return tempUint == 1;\\n        }\\n    }\\n\\n    function toAddressAddressBoolUint128Uint128(\\n        bytes memory _bytes\\n    ) internal pure returns (address addr1, address addr2, bool bool_, uint128 amount1, uint128 amount2) {\\n        if (_bytes.length != 73) revert BytesLibInvalidLength(_bytes.length, 73);\\n        uint8 temp;\\n        assembly (\\\"memory-safe\\\") {\\n            addr1 := and(0xffffffffffffffffffffffffffffffffffffffff, mload(add(_bytes, 20)))\\n            addr2 := and(0xffffffffffffffffffffffffffffffffffffffff, mload(add(_bytes, 40)))\\n            temp := mload(add(_bytes, 41))\\n            amount1 := and(0xffffffffffffffffffffffffffffffff, mload(add(_bytes, 57)))\\n            amount2 := and(0xffffffffffffffffffffffffffffffff, mload(add(_bytes, 73)))\\n        }\\n        bool_ = temp == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/libraries/LiquidityUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {SafeCast as Cast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {Math} from \\\"@maverick/v2-common/contracts/libraries/Math.sol\\\";\\nimport {PoolLib} from \\\"@maverick/v2-common/contracts/libraries/PoolLib.sol\\\";\\nimport {ONE, MINIMUM_LIQUIDITY} from \\\"@maverick/v2-common/contracts/libraries/Constants.sol\\\";\\nimport {TickMath} from \\\"@maverick/v2-common/contracts/libraries/TickMath.sol\\\";\\n\\nimport {IMaverickV2PoolLens} from \\\"../interfaces/IMaverickV2PoolLens.sol\\\";\\nimport {IMaverickV2BoostedPosition} from \\\"../interfaces/IMaverickV2BoostedPosition.sol\\\";\\nimport {PoolInspection} from \\\"../libraries/PoolInspection.sol\\\";\\nimport {PackLib} from \\\"../libraries/PackLib.sol\\\";\\n\\nlibrary LiquidityUtilities {\\n    using Cast for uint256;\\n\\n    error LiquidityUtilitiesTargetPriceOutOfBounds(\\n        uint256 targetSqrtPrice,\\n        uint256 sqrtLowerTickPrice,\\n        uint256 sqrtUpperTickPrice\\n    );\\n    error LiquidityUtilitiesTooLittleLiquidity(uint256 relativeLiquidityAmount, uint256 deltaA, uint256 deltaB);\\n    error LiquidityUtilitiesTargetingTokenWithNoDelta(bool targetIsA, uint256 deltaA, uint256 deltaB);\\n    error LiquidityUtilitiesNoSwapLiquidity();\\n    error LiquidityUtilitiesFailedToFindDeltaAmounts();\\n    error LiquidityUtilitiesInitialTargetBTooSmall(\\n        uint256 initialTargetB,\\n        uint256 deltaLpBalance,\\n        uint256 minimumRequiredLpBalance\\n    );\\n\\n    uint256 internal constant MIN_DELTA_RESERVES = 100;\\n\\n    /**\\n     *\\n     * @notice Return index into the price breaks array that corresponds to the\\n     * current pool price.\\n     *\\n     * @dev Price break array is N elements [e_0, e_1, ..., e_{n-1}].\\n     * @dev If price is less than e_0, then `0` is returned, if price is\\n     * betweeen e_0 and e_1, then `1` is returned, etc.  If the price is\\n     * between e_{n-2} and e_{n-1}, then n-2 is returned.  If price is larger\\n     * than e_{n-1}, then n-1 is returned.\\n     *\\n     */\\n    function priceIndexFromPriceBreaks(\\n        uint256 sqrtPrice,\\n        bytes memory packedSqrtPriceBreaks\\n    ) internal pure returns (uint256 index) {\\n        // index is zero if the pricebreaks array only has one price\\n        if (packedSqrtPriceBreaks.length == 12) return index;\\n        uint88[] memory breaks = PackLib.unpackUint88Array(packedSqrtPriceBreaks);\\n\\n        // loop terminates with `breaks.length - 1` as the max value.\\n        for (; index < breaks.length - 1; index++) {\\n            if (sqrtPrice <= breaks[index]) break;\\n        }\\n    }\\n\\n    function tokenScales(IMaverickV2Pool pool) internal view returns (uint256 tokenAScale, uint256 tokenBScale) {\\n        tokenAScale = pool.tokenAScale();\\n        tokenBScale = pool.tokenBScale();\\n    }\\n\\n    function deltaReservesFromDeltaLpBalanceAtNewPrice(\\n        IMaverickV2Pool pool,\\n        int32 tick,\\n        uint128 deltaLpBalance,\\n        uint8 kind,\\n        uint256 newSqrtPrice\\n    ) internal view returns (uint256 deltaA, uint256 deltaB) {\\n        PoolLib.AddLiquidityInfo memory addLiquidityInfo;\\n        uint32 binId = pool.binIdByTickKind(tick, kind);\\n        IMaverickV2Pool.BinState memory bin = pool.getBin(binId);\\n\\n        addLiquidityInfo.tickSpacing = pool.tickSpacing();\\n        addLiquidityInfo.tick = tick;\\n\\n        IMaverickV2Pool.TickState memory tickState;\\n        (tickState, addLiquidityInfo.tickLtActive, ) = reservesInTickForGivenPrice(pool, tick, newSqrtPrice);\\n\\n        PoolLib.deltaTickBalanceFromDeltaLpBalance(\\n            bin.tickBalance,\\n            bin.totalSupply,\\n            tickState,\\n            deltaLpBalance,\\n            addLiquidityInfo\\n        );\\n        (uint256 tokenAScale, uint256 tokenBScale) = tokenScales(pool);\\n        deltaA = Math.ammScaleToTokenScale(addLiquidityInfo.deltaA, tokenAScale, true);\\n        deltaB = Math.ammScaleToTokenScale(addLiquidityInfo.deltaB, tokenBScale, true);\\n    }\\n\\n    function deltaReservesFromDeltaLpBalancesAtNewPrice(\\n        IMaverickV2Pool pool,\\n        IMaverickV2Pool.AddLiquidityParams memory addParams,\\n        uint256 newSqrtPrice\\n    ) internal view returns (IMaverickV2PoolLens.TickDeltas memory tickDeltas) {\\n        uint256 length = addParams.ticks.length;\\n        tickDeltas.deltaAs = new uint256[](length);\\n        tickDeltas.deltaBs = new uint256[](length);\\n        for (uint256 k; k < length; k++) {\\n            (tickDeltas.deltaAs[k], tickDeltas.deltaBs[k]) = deltaReservesFromDeltaLpBalanceAtNewPrice(\\n                pool,\\n                addParams.ticks[k],\\n                addParams.amounts[k],\\n                addParams.kind,\\n                newSqrtPrice\\n            );\\n            tickDeltas.deltaAOut += tickDeltas.deltaAs[k];\\n            tickDeltas.deltaBOut += tickDeltas.deltaBs[k];\\n        }\\n    }\\n\\n    function scaleAddParams(\\n        IMaverickV2Pool.AddLiquidityParams memory addParams,\\n        uint128[] memory ratios,\\n        uint256 addAmount,\\n        uint256 targetAmount\\n    ) internal pure returns (IMaverickV2Pool.AddLiquidityParams memory addParamsScaled) {\\n        uint256 length = addParams.ticks.length;\\n        addParamsScaled.ticks = addParams.ticks;\\n        addParamsScaled.kind = addParams.kind;\\n\\n        addParamsScaled.amounts = new uint128[](length);\\n\\n        addParamsScaled.amounts[0] = Math.mulDivFloor(addParams.amounts[0], targetAmount, addAmount).toUint128();\\n        for (uint256 k = 1; k < length; k++) {\\n            addParamsScaled.amounts[k] = Math.mulCeil(addParamsScaled.amounts[0], ratios[k]).toUint128();\\n        }\\n    }\\n\\n    function getScaledAddParams(\\n        IMaverickV2Pool pool,\\n        IMaverickV2Pool.AddLiquidityParams memory addParams,\\n        uint128[] memory ratios,\\n        uint256 newSqrtPrice,\\n        uint256 targetAmount,\\n        bool targetIsA\\n    )\\n        internal\\n        view\\n        returns (\\n            IMaverickV2Pool.AddLiquidityParams memory addParamsScaled,\\n            IMaverickV2PoolLens.TickDeltas memory tickDeltas\\n        )\\n    {\\n        // find A and B amount for input addParams\\n        tickDeltas = deltaReservesFromDeltaLpBalancesAtNewPrice(pool, addParams, newSqrtPrice);\\n        uint256 unScaledAmount = targetIsA ? tickDeltas.deltaAOut : tickDeltas.deltaBOut;\\n        if (unScaledAmount == 0) revert LiquidityUtilitiesFailedToFindDeltaAmounts();\\n\\n        // scale addParams to meet the delta target\\n        addParamsScaled = scaleAddParams(\\n            addParams,\\n            ratios,\\n            targetIsA ? tickDeltas.deltaAOut : tickDeltas.deltaBOut,\\n            targetAmount\\n        );\\n        tickDeltas = deltaReservesFromDeltaLpBalancesAtNewPrice(pool, addParamsScaled, newSqrtPrice);\\n    }\\n\\n    function getAddLiquidityParamsFromRelativeBinLpBalance(\\n        IMaverickV2PoolLens.BoostedPositionSpecification memory spec,\\n        int32[] memory ticks,\\n        IMaverickV2PoolLens.AddParamsSpecification memory params\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory packedSqrtPriceBreaks,\\n            bytes[] memory packedArgs,\\n            uint88[] memory sqrtPriceBreaks,\\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\\n        )\\n    {\\n        uint256 length = params.numberOfPriceBreaksPerSide * 2 + 1;\\n        addParams = new IMaverickV2Pool.AddLiquidityParams[](length);\\n        tickDeltas = new IMaverickV2PoolLens.TickDeltas[](length);\\n\\n        uint256 sqrtPrice = PoolInspection.poolSqrtPrice(spec.pool);\\n        addParams[params.numberOfPriceBreaksPerSide].ticks = ticks;\\n        addParams[params.numberOfPriceBreaksPerSide].amounts = spec.ratios;\\n        addParams[params.numberOfPriceBreaksPerSide].kind = spec.kind;\\n        (\\n            addParams[params.numberOfPriceBreaksPerSide],\\n            tickDeltas[params.numberOfPriceBreaksPerSide]\\n        ) = getScaledAddParams(\\n            spec.pool,\\n            addParams[params.numberOfPriceBreaksPerSide],\\n            spec.ratios,\\n            sqrtPrice,\\n            params.targetAmount,\\n            params.targetIsA\\n        );\\n\\n        sqrtPriceBreaks = new uint88[](length);\\n        sqrtPriceBreaks[params.numberOfPriceBreaksPerSide] = sqrtPrice.toUint88();\\n\\n        // left of price,\\n        for (uint256 k; k < params.numberOfPriceBreaksPerSide; k++) {\\n            params.targetIsA = false;\\n            params.targetAmount = Math.mulDown(tickDeltas[params.numberOfPriceBreaksPerSide].deltaBOut, 0.99999e18);\\n            if (params.targetAmount == 0) continue;\\n\\n            // price / (factor + 1), price / (factor * (n-1) / n + 1), price / (factor * (n-2)/n + 1)...\\n            uint256 factor = Math.mulDivFloor(\\n                params.slippageFactorD18,\\n                params.numberOfPriceBreaksPerSide - k,\\n                params.numberOfPriceBreaksPerSide\\n            );\\n            sqrtPriceBreaks[k] = Math.divCeil(sqrtPrice, factor + ONE).toUint88();\\n\\n            (addParams[k], tickDeltas[k]) = getScaledAddParams(\\n                spec.pool,\\n                addParams[params.numberOfPriceBreaksPerSide],\\n                spec.ratios,\\n                sqrtPriceBreaks[k],\\n                params.targetAmount,\\n                params.targetIsA\\n            );\\n        }\\n\\n        // right of price\\n        for (uint256 k; k < params.numberOfPriceBreaksPerSide; k++) {\\n            uint256 index = params.numberOfPriceBreaksPerSide + k + 1;\\n            params.targetIsA = true;\\n            params.targetAmount = Math.mulDown(tickDeltas[params.numberOfPriceBreaksPerSide].deltaAOut, 0.99999e18);\\n            if (params.targetAmount == 0) {\\n                sqrtPriceBreaks[index - 1] = type(uint88).max;\\n                break;\\n            }\\n\\n            {\\n                // price * (factor * (1 / n) + 1), price * (factor * (2 / n) + 1), price / (factor * (3 / n) + 1)...\\n                uint256 factor = Math.mulDivFloor(params.slippageFactorD18, k + 1, params.numberOfPriceBreaksPerSide);\\n                sqrtPriceBreaks[index] = Math.mulCeil(sqrtPrice, factor + ONE).toUint88();\\n            }\\n            (addParams[index], tickDeltas[index]) = getScaledAddParams(\\n                spec.pool,\\n                addParams[params.numberOfPriceBreaksPerSide],\\n                spec.ratios,\\n                sqrtPriceBreaks[index],\\n                params.targetAmount,\\n                params.targetIsA\\n            );\\n        }\\n        sortAddParamsArray(addParams, tickDeltas);\\n        packedArgs = PackLib.packAddLiquidityArgsArray(addParams);\\n        packedSqrtPriceBreaks = PackLib.packArray(sqrtPriceBreaks);\\n    }\\n\\n    /** @notice Compute add params for N price breaks around price with max right\\n     * slippage of p * (1 + f) and max left slippage of p / (1 + f).\\n     *\\n     * The user specifies the max A and B they are willing to spend.  If the\\n     * price of the pool does not move, the user will spend exactly this\\n     * amount. If the price moves left, then the user would like to spend the\\n     * specified B amount, but will end up spending less A.  Conversely, if the\\n     * price moves right, the user will spend their max A amount, but less B.\\n     *\\n     * By having more break points, we make it so that the user gets as much\\n     * liquidity as possible at the new price. With too few break points, the\\n     * user will not have bought as much liquidity as they could have.\\n     */\\n    function getAddLiquidityParams(\\n        IMaverickV2PoolLens.AddParamsViewInputs memory params\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory packedSqrtPriceBreaks,\\n            bytes[] memory packedArgs,\\n            uint88[] memory sqrtPriceBreaks,\\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\\n        )\\n    {\\n        RelativeLiquidityInput memory input;\\n\\n        input.poolTickSpacing = params.pool.tickSpacing();\\n        (input.tokenAScale, input.tokenBScale) = tokenScales(params.pool);\\n        input.ticks = params.ticks;\\n        input.relativeLiquidityAmounts = params.relativeLiquidityAmounts;\\n\\n        uint256 length = params.addSpec.numberOfPriceBreaksPerSide * 2 + 1;\\n        addParams = new IMaverickV2Pool.AddLiquidityParams[](length);\\n        tickDeltas = new IMaverickV2PoolLens.TickDeltas[](length);\\n\\n        // initially target the bigger amount at pool price\\n        input.targetIsA = params.addSpec.targetIsA;\\n        input.targetAmount = params.addSpec.targetAmount;\\n        uint256 startingPrice = PoolInspection.poolSqrtPrice(params.pool);\\n\\n        input.newSqrtPrice = startingPrice;\\n        bool success;\\n        (\\n            addParams[params.addSpec.numberOfPriceBreaksPerSide],\\n            tickDeltas[params.addSpec.numberOfPriceBreaksPerSide],\\n            success\\n        ) = lpBalanceForArrayOfTargetAmounts(input, params.pool, params.kind);\\n        if (!success) revert LiquidityUtilitiesFailedToFindDeltaAmounts();\\n        sqrtPriceBreaks = new uint88[](length);\\n        sqrtPriceBreaks[params.addSpec.numberOfPriceBreaksPerSide] = input.newSqrtPrice.toUint88();\\n\\n        // compute slippage price\\n        // look through N breaks\\n        // compute deltas\\n        // convert to addParams\\n        //\\n\\n        // left of price,\\n        for (uint256 k; k < params.addSpec.numberOfPriceBreaksPerSide; k++) {\\n            input.targetIsA = false;\\n            input.targetAmount = tickDeltas[params.addSpec.numberOfPriceBreaksPerSide].deltaBOut;\\n\\n            // price / (factor + 1), price / (factor * (n-1) / n + 1), price / (factor * (n-2)/n + 1)...\\n            uint256 factor = Math.mulDivFloor(\\n                params.addSpec.slippageFactorD18,\\n                params.addSpec.numberOfPriceBreaksPerSide - k,\\n                params.addSpec.numberOfPriceBreaksPerSide\\n            );\\n            sqrtPriceBreaks[k] = Math.divCeil(startingPrice, factor + ONE).toUint88();\\n\\n            input.newSqrtPrice = sqrtPriceBreaks[k];\\n\\n            (addParams[k], tickDeltas[k], success) = lpBalanceForArrayOfTargetAmounts(input, params.pool, params.kind);\\n            if (!success) sqrtPriceBreaks[k] = 0;\\n        }\\n\\n        // right of price\\n        for (uint256 k; k < params.addSpec.numberOfPriceBreaksPerSide; k++) {\\n            uint256 index = params.addSpec.numberOfPriceBreaksPerSide + k + 1;\\n            input.targetIsA = true;\\n            input.targetAmount = tickDeltas[params.addSpec.numberOfPriceBreaksPerSide].deltaAOut;\\n\\n            // price * (factor * (1 / n) + 1), price * (factor * (2 / n) + 1), price / (factor * (3 / n) + 1)...\\n            uint256 factor = Math.mulDivFloor(\\n                params.addSpec.slippageFactorD18,\\n                k + 1,\\n                params.addSpec.numberOfPriceBreaksPerSide\\n            );\\n            sqrtPriceBreaks[index] = Math.mulCeil(startingPrice, factor + ONE).toUint88();\\n\\n            input.newSqrtPrice = sqrtPriceBreaks[index];\\n\\n            (addParams[index], tickDeltas[index], success) = lpBalanceForArrayOfTargetAmounts(\\n                input,\\n                params.pool,\\n                params.kind\\n            );\\n            if (!success) {\\n                sqrtPriceBreaks[index - 1] = type(uint88).max;\\n                break;\\n            }\\n        }\\n        packedArgs = PackLib.packAddLiquidityArgsArray(addParams);\\n        packedSqrtPriceBreaks = PackLib.packArray(sqrtPriceBreaks);\\n    }\\n\\n    function deltaReservesFromDeltaLiquidity(\\n        uint256 poolTickSpacing,\\n        uint256 tokenAScale,\\n        uint256 tokenBScale,\\n        int32 tick,\\n        uint128 deltaLiquidity,\\n        uint256 tickSqrtPrice\\n    ) internal pure returns (uint256 deltaA, uint256 deltaB) {\\n        (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(poolTickSpacing, tick);\\n        {\\n            uint256 lowerEdge = Math.max(sqrtLowerTickPrice, tickSqrtPrice);\\n\\n            deltaB = Math.mulDivCeil(\\n                deltaLiquidity,\\n                ONE * Math.clip(sqrtUpperTickPrice, lowerEdge),\\n                sqrtUpperTickPrice * lowerEdge\\n            );\\n        }\\n\\n        if (tickSqrtPrice < sqrtLowerTickPrice) {\\n            deltaA = 0;\\n        } else if (tickSqrtPrice >= sqrtUpperTickPrice) {\\n            deltaA = Math.mulCeil(deltaLiquidity, sqrtUpperTickPrice - sqrtLowerTickPrice);\\n            deltaB = 0;\\n        } else {\\n            deltaA = Math.mulCeil(\\n                deltaLiquidity,\\n                Math.clip(Math.min(sqrtUpperTickPrice, tickSqrtPrice), sqrtLowerTickPrice)\\n            );\\n        }\\n        deltaA = Math.ammScaleToTokenScale(deltaA, tokenAScale, true);\\n        deltaB = Math.ammScaleToTokenScale(deltaB, tokenBScale, true);\\n    }\\n\\n    function deltasFromBinLiquidityAmounts(\\n        uint256 poolTickSpacing,\\n        uint256 tokenAScale,\\n        uint256 tokenBScale,\\n        int32[] memory ticks,\\n        uint128[] memory liquidityAmounts,\\n        uint256 newSqrtPrice\\n    ) internal pure returns (uint256 deltaA, uint256 deltaB, uint256[] memory deltaAs, uint256[] memory deltaBs) {\\n        uint256 length = ticks.length;\\n        deltaAs = new uint256[](length);\\n        deltaBs = new uint256[](length);\\n        for (uint256 k = 0; k < length; k++) {\\n            (deltaAs[k], deltaBs[k]) = deltaReservesFromDeltaLiquidity(\\n                poolTickSpacing,\\n                tokenAScale,\\n                tokenBScale,\\n                ticks[k],\\n                liquidityAmounts[k],\\n                newSqrtPrice\\n            );\\n            deltaA += deltaAs[k];\\n            deltaB += deltaBs[k];\\n        }\\n    }\\n\\n    struct StateInfo {\\n        uint256 reserveA;\\n        uint256 reserveB;\\n        uint256 binTotalSupply;\\n        int32 activeTick;\\n    }\\n\\n    struct RelativeLiquidityInput {\\n        uint256 poolTickSpacing;\\n        uint256 tokenAScale;\\n        uint256 tokenBScale;\\n        int32[] ticks;\\n        uint128[] relativeLiquidityAmounts;\\n        uint256 targetAmount;\\n        bool targetIsA;\\n        uint256 newSqrtPrice;\\n    }\\n\\n    function _deltasFromRelativeBinLiquidityAmountsAndTargetAmount(\\n        RelativeLiquidityInput memory input\\n    ) internal pure returns (IMaverickV2PoolLens.TickDeltas memory output, bool success) {\\n        uint256 deltaA;\\n        uint256 deltaB;\\n        success = true;\\n\\n        (deltaA, deltaB, output.deltaAs, output.deltaBs) = deltasFromBinLiquidityAmounts(\\n            input.poolTickSpacing,\\n            input.tokenAScale,\\n            input.tokenBScale,\\n            input.ticks,\\n            input.relativeLiquidityAmounts,\\n            input.newSqrtPrice\\n        );\\n        uint256 deltaDenominator = input.targetIsA ? deltaA : deltaB;\\n\\n        if ((input.targetIsA && deltaA == 0) || (!input.targetIsA && deltaB == 0)) return (output, false);\\n\\n        for (uint256 k; k < input.ticks.length; k++) {\\n            output.deltaAs[k] = Math\\n                .mulDivFloor(Math.clip(output.deltaAs[k], 1), input.targetAmount, deltaDenominator)\\n                .toUint128();\\n            output.deltaBs[k] = Math\\n                .mulDivFloor(Math.clip(output.deltaBs[k], 1), input.targetAmount, deltaDenominator)\\n                .toUint128();\\n            if (output.deltaAs[k] < MIN_DELTA_RESERVES && output.deltaBs[k] < MIN_DELTA_RESERVES)\\n                return (output, false);\\n\\n            output.deltaAOut += output.deltaAs[k];\\n            output.deltaBOut += output.deltaBs[k];\\n        }\\n    }\\n\\n    function lpBalanceForArrayOfTargetAmountsEmptyPool(\\n        IMaverickV2PoolLens.TickDeltas memory tickDeltas,\\n        RelativeLiquidityInput memory input,\\n        StateInfo memory existingState,\\n        uint8 kind\\n    ) internal pure returns (IMaverickV2Pool.AddLiquidityParams memory addParams) {\\n        addParams.ticks = input.ticks;\\n        addParams.kind = kind;\\n        addParams.amounts = new uint128[](input.ticks.length);\\n        for (uint256 k; k < input.ticks.length; k++) {\\n            bool tickIsActive = existingState.activeTick == input.ticks[k];\\n            addParams.amounts[k] = lpBalanceRequiredForTargetReserveAmountsOneBinTick(\\n                input,\\n                input.ticks[k],\\n                Math.tokenScaleToAmmScale(tickDeltas.deltaAs[k], input.tokenAScale),\\n                Math.tokenScaleToAmmScale(tickDeltas.deltaBs[k], input.tokenBScale),\\n                tickIsActive ? existingState.reserveA : 0,\\n                tickIsActive ? existingState.reserveB : 0,\\n                tickIsActive ? existingState.binTotalSupply : 0,\\n                input.ticks[k] < existingState.activeTick\\n            ).toUint128();\\n        }\\n    }\\n\\n    function lpBalanceForArrayOfTargetAmounts(\\n        RelativeLiquidityInput memory input,\\n        IMaverickV2Pool pool,\\n        uint8 kind\\n    )\\n        internal\\n        view\\n        returns (\\n            IMaverickV2Pool.AddLiquidityParams memory addParams,\\n            IMaverickV2PoolLens.TickDeltas memory tickDeltas,\\n            bool success\\n        )\\n    {\\n        (tickDeltas, success) = _deltasFromRelativeBinLiquidityAmountsAndTargetAmount(input);\\n        addParams.ticks = input.ticks;\\n        addParams.kind = kind;\\n\\n        addParams.amounts = new uint128[](input.ticks.length);\\n        for (uint256 k; k < input.ticks.length; k++) {\\n            addParams.amounts[k] = lpBalanceRequiredForTargetReserveAmountsMultiBinTick(\\n                input,\\n                pool,\\n                input.ticks[k],\\n                kind,\\n                Math.tokenScaleToAmmScale(tickDeltas.deltaAs[k], input.tokenAScale),\\n                Math.tokenScaleToAmmScale(tickDeltas.deltaBs[k], input.tokenBScale)\\n            ).toUint128();\\n        }\\n    }\\n\\n    function donateAndSwapData(\\n        uint256 poolTickSpacing,\\n        int32 poolTick,\\n        uint256 poolFee,\\n        IERC20 tokenB,\\n        uint256 targetAmountB,\\n        uint256 targetSqrtPrice\\n    ) internal view returns (uint128 deltaLpBalanceB, uint256 swapAmount) {\\n        uint256 tokenBScale = Math.scale(IERC20Metadata(address(tokenB)).decimals());\\n\\n        targetAmountB = Math.tokenScaleToAmmScale(targetAmountB, tokenBScale);\\n        (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(poolTickSpacing, poolTick);\\n\\n        deltaLpBalanceB = Math.mulFloor(targetAmountB, sqrtUpperTickPrice).toUint128();\\n\\n        uint256 liquidity = TickMath.getTickL(0, targetAmountB, sqrtLowerTickPrice, sqrtUpperTickPrice);\\n        if (targetSqrtPrice <= sqrtLowerTickPrice || targetSqrtPrice >= sqrtUpperTickPrice)\\n            revert LiquidityUtilitiesTargetPriceOutOfBounds(targetSqrtPrice, sqrtLowerTickPrice, sqrtUpperTickPrice);\\n\\n        swapAmount = Math.mulDivCeil(\\n            liquidity,\\n            ONE * (targetSqrtPrice - sqrtLowerTickPrice),\\n            targetSqrtPrice * sqrtLowerTickPrice\\n        );\\n        swapAmount = Math.ammScaleToTokenScale(swapAmount, tokenBScale, true);\\n        swapAmount = Math.mulCeil(swapAmount, ONE - poolFee);\\n    }\\n\\n    function getCreatePoolParams(\\n        IMaverickV2PoolLens.CreateAndAddParamsViewInputs memory params,\\n        uint256 protocolFeeRatio\\n    ) internal view returns (IMaverickV2PoolLens.CreateAndAddParamsInputs memory output) {\\n        (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(\\n            params.tickSpacing,\\n            params.activeTick\\n        );\\n        RelativeLiquidityInput memory input;\\n        StateInfo memory existingState;\\n\\n        input.poolTickSpacing = params.tickSpacing;\\n        input.tokenAScale = Math.scale(IERC20Metadata(address(params.tokenA)).decimals());\\n        input.tokenBScale = Math.scale(IERC20Metadata(address(params.tokenB)).decimals());\\n        input.ticks = params.ticks;\\n        input.relativeLiquidityAmounts = params.relativeLiquidityAmounts;\\n        input.targetAmount = params.targetAmount;\\n        input.targetIsA = params.targetIsA;\\n        existingState.activeTick = params.activeTick;\\n\\n        output.donateParams.ticks = new int32[](1);\\n        output.donateParams.ticks[0] = params.activeTick;\\n        output.donateParams.amounts = new uint128[](1);\\n        if (sqrtLowerTickPrice != params.sqrtPrice) {\\n            // target price is not tick edge, need to dontate/swap\\n            (output.donateParams.amounts[0], output.swapAmount) = donateAndSwapData(\\n                params.tickSpacing,\\n                params.activeTick,\\n                params.feeAIn,\\n                params.tokenB,\\n                params.initialTargetB,\\n                params.sqrtPrice\\n            );\\n\\n            if (output.donateParams.amounts[0] < MINIMUM_LIQUIDITY)\\n                revert LiquidityUtilitiesInitialTargetBTooSmall(\\n                    params.initialTargetB,\\n                    output.donateParams.amounts[0],\\n                    MINIMUM_LIQUIDITY\\n                );\\n            existingState.binTotalSupply = output.donateParams.amounts[0];\\n\\n            existingState.reserveB = Math.tokenScaleToAmmScale(\\n                params.initialTargetB - output.swapAmount,\\n                input.tokenBScale\\n            );\\n            existingState.reserveA = emulateExactOut(\\n                Math.tokenScaleToAmmScale(output.swapAmount, input.tokenBScale),\\n                Math.tokenScaleToAmmScale(params.initialTargetB, input.tokenBScale),\\n                sqrtLowerTickPrice,\\n                sqrtUpperTickPrice,\\n                params.feeAIn,\\n                protocolFeeRatio\\n            );\\n\\n            (input.newSqrtPrice, ) = TickMath.getTickSqrtPriceAndL(\\n                existingState.reserveA,\\n                existingState.reserveB,\\n                sqrtLowerTickPrice,\\n                sqrtUpperTickPrice\\n            );\\n        } else {\\n            input.newSqrtPrice = sqrtLowerTickPrice;\\n        }\\n\\n        {\\n            (\\n                IMaverickV2PoolLens.TickDeltas memory tickDeltas,\\n                bool success\\n            ) = _deltasFromRelativeBinLiquidityAmountsAndTargetAmount(input);\\n            if (!success) revert LiquidityUtilitiesFailedToFindDeltaAmounts();\\n\\n            output.addParams = lpBalanceForArrayOfTargetAmountsEmptyPool(tickDeltas, input, existingState, params.kind);\\n            output.packedAddParams = PackLib.packAddLiquidityArgsToArray(output.addParams);\\n            output.deltaAOut = tickDeltas.deltaAOut;\\n            output.deltaBOut = tickDeltas.deltaBOut;\\n            output.preAddReserveA = existingState.reserveA;\\n            output.preAddReserveB = existingState.reserveB;\\n        }\\n    }\\n\\n    function emulateExactOut(\\n        uint256 amountOut,\\n        uint256 currentReserveB,\\n        uint256 sqrtLowerTickPrice,\\n        uint256 sqrtUpperTickPrice,\\n        uint256 fee,\\n        uint256 protocolFee\\n    ) internal pure returns (uint256 amountAIn) {\\n        uint256 existingLiquidity = TickMath.getTickL(0, currentReserveB, sqrtLowerTickPrice, sqrtUpperTickPrice);\\n\\n        if (existingLiquidity == 0) revert LiquidityUtilitiesNoSwapLiquidity();\\n\\n        uint256 binAmountIn = Math.mulDivCeil(\\n            amountOut,\\n            sqrtLowerTickPrice,\\n            Math.invFloor(sqrtLowerTickPrice) - Math.divCeil(amountOut, existingLiquidity)\\n        );\\n\\n        // some of the input is fee\\n        uint256 feeBasis = Math.mulDivCeil(binAmountIn, fee, ONE - fee);\\n        // fee is added to input amount and just increases bin liquidity\\n        // out = in / (1-fee)  -> out - fee * out = in  -> out = in + fee * out\\n        uint256 inWithoutProtocolFee = binAmountIn + feeBasis;\\n        // add on protocol fee\\n        amountAIn = protocolFee != 0\\n            ? Math.clip(inWithoutProtocolFee, Math.mulCeil(feeBasis, protocolFee))\\n            : inWithoutProtocolFee;\\n    }\\n\\n    /**\\n     * @notice Calculates deltaA = liquidity * (sqrt(upper) - sqrt(lower))\\n     *  Calculates deltaB = liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n     *  i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n     */\\n    function reservesInTickForGivenPrice(\\n        IMaverickV2Pool pool,\\n        int32 tick,\\n        uint256 newSqrtPrice\\n    ) internal view returns (IMaverickV2Pool.TickState memory tickState, bool tickLtActive, bool tickGtActive) {\\n        tickState = pool.getTick(tick);\\n        (uint256 lowerSqrtPrice, uint256 upperSqrtPrice) = TickMath.tickSqrtPrices(pool.tickSpacing(), tick);\\n\\n        tickGtActive = newSqrtPrice < lowerSqrtPrice;\\n        tickLtActive = newSqrtPrice >= upperSqrtPrice;\\n\\n        uint256 liquidity = TickMath.getTickL(tickState.reserveA, tickState.reserveB, lowerSqrtPrice, upperSqrtPrice);\\n\\n        if (liquidity == 0) {\\n            (tickState.reserveA, tickState.reserveB) = (0, 0);\\n        } else {\\n            uint256 lowerEdge = Math.max(lowerSqrtPrice, newSqrtPrice);\\n\\n            tickState.reserveA = Math\\n                .mulCeil(liquidity, Math.clip(Math.min(upperSqrtPrice, newSqrtPrice), lowerSqrtPrice))\\n                .toUint128();\\n            tickState.reserveB = Math\\n                .mulDivCeil(liquidity, ONE * Math.clip(upperSqrtPrice, lowerEdge), upperSqrtPrice * lowerEdge)\\n                .toUint128();\\n        }\\n    }\\n\\n    function lpBalanceRequiredForTargetReserveAmountsMultiBinTick(\\n        RelativeLiquidityInput memory input,\\n        IMaverickV2Pool pool,\\n        int32 tick,\\n        uint8 kind,\\n        uint256 amountAMax,\\n        uint256 amountBMax\\n    ) internal view returns (uint256 deltaLpBalance) {\\n        (IMaverickV2Pool.TickState memory tickState, bool tickLtActive, ) = reservesInTickForGivenPrice(\\n            pool,\\n            tick,\\n            input.newSqrtPrice\\n        );\\n        if (tickState.reserveB != 0 || tickState.reserveA != 0) {\\n            uint256 liquidity;\\n            {\\n                (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(\\n                    input.poolTickSpacing,\\n                    tick\\n                );\\n                liquidity = TickMath.getTickL(\\n                    tickState.reserveA,\\n                    tickState.reserveB,\\n                    sqrtLowerTickPrice,\\n                    sqrtUpperTickPrice\\n                );\\n            }\\n            uint32 binId = pool.binIdByTickKind(tick, kind);\\n            IMaverickV2Pool.BinState memory bin = pool.getBin(binId);\\n\\n            uint256 numerator = Math.max(1, uint256(tickState.totalSupply)) * Math.max(1, uint256(bin.totalSupply));\\n            if (tickState.reserveA != 0) {\\n                uint256 denominator = Math.max(1, uint256(bin.tickBalance)) * uint256(tickState.reserveA);\\n                amountAMax = Math.max(amountAMax, 1);\\n                deltaLpBalance = Math.mulDivFloor(amountAMax, numerator, denominator);\\n            } else {\\n                deltaLpBalance = type(uint256).max;\\n            }\\n            if (tickState.reserveB != 0) {\\n                uint256 denominator = Math.max(1, uint256(bin.tickBalance)) * uint256(tickState.reserveB);\\n                amountBMax = Math.max(amountBMax, 1);\\n                deltaLpBalance = Math.min(deltaLpBalance, Math.mulDivFloor(amountBMax, numerator, denominator));\\n            }\\n        } else {\\n            deltaLpBalance = emptyTickLpBalanceRequirement(input, tick, amountAMax, amountBMax, tickLtActive);\\n        }\\n    }\\n\\n    function lpBalanceRequiredForTargetReserveAmountsOneBinTick(\\n        RelativeLiquidityInput memory input,\\n        int32 tick,\\n        uint256 amountAMax,\\n        uint256 amountBMax,\\n        uint256 reserveA,\\n        uint256 reserveB,\\n        uint256 binTotalSupply,\\n        bool tickLtActive\\n    ) internal pure returns (uint256 deltaLpBalance) {\\n        if (reserveB != 0 || reserveA != 0) {\\n            deltaLpBalance = Math.min(\\n                reserveA == 0 ? type(uint256).max : Math.mulDivFloor(amountAMax, binTotalSupply, reserveA),\\n                reserveB == 0 ? type(uint256).max : Math.mulDivFloor(amountBMax, binTotalSupply, reserveB)\\n            );\\n        } else {\\n            deltaLpBalance = emptyTickLpBalanceRequirement(input, tick, amountAMax, amountBMax, tickLtActive);\\n        }\\n    }\\n\\n    function emptyTickLpBalanceRequirement(\\n        RelativeLiquidityInput memory input,\\n        int32 tick,\\n        uint256 amountAMax,\\n        uint256 amountBMax,\\n        bool tickLtActive\\n    ) internal pure returns (uint256 deltaLpBalance) {\\n        (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(input.poolTickSpacing, tick);\\n        if (tickLtActive) {\\n            deltaLpBalance = Math.divFloor(amountAMax, sqrtLowerTickPrice);\\n        } else {\\n            deltaLpBalance = Math.mulFloor(amountBMax, sqrtUpperTickPrice);\\n        }\\n    }\\n\\n    function getBoostedPositionSpec(\\n        IMaverickV2BoostedPosition boostedPosition\\n    ) internal view returns (IMaverickV2PoolLens.BoostedPositionSpecification memory spec, int32[] memory ticks) {\\n        spec.pool = boostedPosition.pool();\\n        spec.binIds = boostedPosition.getBinIds();\\n        spec.ratios = boostedPosition.getRatios();\\n        spec.kind = boostedPosition.kind();\\n        ticks = boostedPosition.getTicks();\\n    }\\n\\n    /**\\n     * @notice Sort ticks and amounts in addParams struct array in tick order.\\n     * Mutates input params array in place.\\n     *\\n     * @notice Sort operation in this function assumes that all element of the\\n     * input arrays have the same tick ordering.\\n     */\\n    function sortAddParamsArray(\\n        IMaverickV2Pool.AddLiquidityParams[] memory addParams,\\n        IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\\n    ) internal pure {\\n        uint256 breakPoints = addParams.length;\\n        uint256 length = addParams[0].ticks.length;\\n        for (uint256 i = 0; i < length - 1; i++) {\\n            for (uint256 j = 0; j < length - i - 1; j++) {\\n                // compare\\n                if (addParams[0].ticks[j] > addParams[0].ticks[j + 1]) {\\n                    // if there is a mis-ordering, flip values in all addParam structs\\n                    for (uint256 k = 0; k < breakPoints; k++) {\\n                        (addParams[k].ticks[j], addParams[k].ticks[j + 1]) = (\\n                            addParams[k].ticks[j + 1],\\n                            addParams[k].ticks[j]\\n                        );\\n                        (addParams[k].amounts[j], addParams[k].amounts[j + 1]) = (\\n                            addParams[k].amounts[j + 1],\\n                            addParams[k].amounts[j]\\n                        );\\n                        (tickDeltas[k].deltaAs[j], tickDeltas[k].deltaAs[j + 1]) = (\\n                            tickDeltas[k].deltaAs[j + 1],\\n                            tickDeltas[k].deltaAs[j]\\n                        );\\n                        (tickDeltas[k].deltaBs[j], tickDeltas[k].deltaBs[j + 1]) = (\\n                            tickDeltas[k].deltaBs[j + 1],\\n                            tickDeltas[k].deltaBs[j]\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/libraries/PackLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\n// adapted from https://github.com/latticexyz/mud/blob/main/packages/store/src/Slice.sol\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {SafeCast as Cast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {BytesLib} from \\\"./BytesLib.sol\\\";\\n\\nlibrary PackLib {\\n    using Cast for uint256;\\n    using BytesLib for bytes;\\n\\n    function unpackExactInputSingleArgsAmounts(\\n        bytes memory argsPacked\\n    )\\n        internal\\n        pure\\n        returns (address recipient, IMaverickV2Pool pool, bool tokenAIn, uint256 amountIn, uint256 amountOutMinimum)\\n    {\\n        address pool_;\\n        (recipient, pool_, tokenAIn, amountIn, amountOutMinimum) = argsPacked.toAddressAddressBoolUint128Uint128();\\n        pool = IMaverickV2Pool(pool_);\\n    }\\n\\n    function unpackAddLiquidityArgs(\\n        bytes memory argsPacked\\n    ) internal pure returns (IMaverickV2Pool.AddLiquidityParams memory args) {\\n        args.kind = uint8(argsPacked[0]);\\n        args.ticks = unpackInt32Array(argsPacked.slice(1, argsPacked.length - 1));\\n        uint256 startByte = args.ticks.length * 4 + 2;\\n        args.amounts = unpackUint128Array(argsPacked.slice(startByte, argsPacked.length - startByte));\\n    }\\n\\n    function packAddLiquidityArgs(\\n        IMaverickV2Pool.AddLiquidityParams memory args\\n    ) internal pure returns (bytes memory argsPacked) {\\n        argsPacked = abi.encodePacked(args.kind);\\n        argsPacked = bytes.concat(argsPacked, packArray(args.ticks));\\n        argsPacked = bytes.concat(argsPacked, packArray(args.amounts));\\n    }\\n\\n    function packAddLiquidityArgsToArray(\\n        IMaverickV2Pool.AddLiquidityParams memory args\\n    ) internal pure returns (bytes[] memory argsPacked) {\\n        argsPacked = new bytes[](1);\\n        argsPacked[0] = packAddLiquidityArgs(args);\\n    }\\n\\n    function packAddLiquidityArgsArray(\\n        IMaverickV2Pool.AddLiquidityParams[] memory args\\n    ) internal pure returns (bytes[] memory argsPacked) {\\n        argsPacked = new bytes[](args.length);\\n        for (uint256 k; k < args.length; k++) {\\n            argsPacked[k] = packAddLiquidityArgs(args[k]);\\n        }\\n    }\\n\\n    function unpackInt32Array(bytes memory input) internal pure returns (int32[] memory array) {\\n        uint256[] memory output = _unpackArray(input, 4);\\n        assembly (\\\"memory-safe\\\") {\\n            array := output\\n        }\\n    }\\n\\n    function unpackUint128Array(bytes memory input) internal pure returns (uint128[] memory array) {\\n        uint256[] memory output = _unpackArray(input, 16);\\n        assembly (\\\"memory-safe\\\") {\\n            array := output\\n        }\\n    }\\n\\n    function unpackUint88Array(bytes memory input) internal pure returns (uint88[] memory array) {\\n        uint256[] memory output = _unpackArray(input, 11);\\n        assembly (\\\"memory-safe\\\") {\\n            array := output\\n        }\\n    }\\n\\n    function packArray(int32[] memory array) internal pure returns (bytes memory output) {\\n        uint256[] memory input;\\n        assembly (\\\"memory-safe\\\") {\\n            input := array\\n        }\\n        output = _packArray(input, 4);\\n    }\\n\\n    function packArray(uint128[] memory array) internal pure returns (bytes memory output) {\\n        uint256[] memory input;\\n        assembly (\\\"memory-safe\\\") {\\n            input := array\\n        }\\n        output = _packArray(input, 16);\\n    }\\n\\n    function packArray(uint88[] memory array) internal pure returns (bytes memory output) {\\n        uint256[] memory input;\\n        assembly (\\\"memory-safe\\\") {\\n            input := array\\n        }\\n        output = _packArray(input, 11);\\n    }\\n\\n    /*\\n     * @notice [length, array[0], array[1],..., array[length-1]]. length is 1 bytes.\\n     * @dev Unpacked signed array elements will contain \\\"dirty bits\\\".  That is,\\n     * this function does not 0xf pad signed return elements.\\n     */\\n    function _unpackArray(bytes memory input, uint256 elementBytes) internal pure returns (uint256[] memory array) {\\n        uint256 packedPointer;\\n        uint256 arrayLength;\\n        assembly (\\\"memory-safe\\\") {\\n            // read from input pointer + 32 bytes\\n            // pad 1-byte length value to fill 32 bytes (248 pad bits)\\n            arrayLength := shr(248, mload(add(input, 0x20)))\\n            packedPointer := add(input, 0x21)\\n        }\\n\\n        uint256 padRight = 256 - 8 * elementBytes;\\n        assembly (\\\"memory-safe\\\") {\\n            // Allocate a word for each element, and a word for the array's length\\n            let allocateBytes := add(mul(arrayLength, 32), 0x20)\\n            // Allocate memory and update the free memory pointer\\n            array := mload(0x40)\\n            mstore(0x40, add(array, allocateBytes))\\n\\n            // Store array length\\n            mstore(array, arrayLength)\\n\\n            for {\\n                let i := 0\\n                let arrayCursor := add(array, 0x20) // skip array length\\n                let packedCursor := packedPointer\\n            } lt(i, arrayLength) {\\n                // Loop until we reach the end of the array\\n                i := add(i, 1)\\n                arrayCursor := add(arrayCursor, 0x20) // increment array pointer by one word\\n                packedCursor := add(packedCursor, elementBytes) // increment packed pointer by one element size\\n            } {\\n                mstore(arrayCursor, shr(padRight, mload(packedCursor))) // unpack one array element\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev [length, array[0], array[1],..., array[length-1]]. length is 1 bytes.\\n     */\\n    function _packArray(uint256[] memory array, uint256 elementBytes) internal pure returns (bytes memory output) {\\n        // cast to check size fits in 8 bits\\n        uint8 arrayLength = array.length.toUint8();\\n        uint256 packedLength = arrayLength * elementBytes + 1;\\n\\n        output = new bytes(packedLength);\\n\\n        uint256 padLeft = 256 - 8 * elementBytes;\\n        assembly (\\\"memory-safe\\\") {\\n            // Store array length\\n            mstore(add(output, 0x20), shl(248, arrayLength))\\n\\n            for {\\n                let i := 0\\n                let arrayCursor := add(array, 0x20) // skip array length\\n                let packedCursor := add(output, 0x21) // skip length\\n            } lt(i, arrayLength) {\\n                // Loop until we reach the end of the array\\n                i := add(i, 1)\\n                arrayCursor := add(arrayCursor, 0x20) // increment array pointer by one word\\n                packedCursor := add(packedCursor, elementBytes) // increment packed pointer by one element size\\n            } {\\n                mstore(packedCursor, shl(padLeft, mload(arrayCursor))) // pack one array element\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/libraries/PoolInspection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {SafeCast as Cast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {Math} from \\\"@maverick/v2-common/contracts/libraries/Math.sol\\\";\\nimport {PoolLib} from \\\"@maverick/v2-common/contracts/libraries/PoolLib.sol\\\";\\nimport {TickMath} from \\\"@maverick/v2-common/contracts/libraries/TickMath.sol\\\";\\n\\nlibrary PoolInspection {\\n    using Cast for uint256;\\n\\n    /**\\n     * @dev Calculates the square root price of a given Maverick V2 pool.\\n     * @param pool The Maverick V2 pool to inspect.\\n     * @return sqrtPrice The square root price of the pool.\\n     */\\n    function poolSqrtPrice(IMaverickV2Pool pool) internal view returns (uint256 sqrtPrice) {\\n        int32 activeTick = pool.getState().activeTick;\\n        IMaverickV2Pool.TickState memory tickState = pool.getTick(activeTick);\\n\\n        (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(\\n            pool.tickSpacing(),\\n            activeTick\\n        );\\n\\n        (sqrtPrice, ) = TickMath.getTickSqrtPriceAndL(\\n            tickState.reserveA,\\n            tickState.reserveB,\\n            sqrtLowerTickPrice,\\n            sqrtUpperTickPrice\\n        );\\n    }\\n\\n    /**\\n     * @dev Retrieves the reserves of a user's subaccount for a specific bin.\\n     */\\n    function userSubaccountBinReserves(\\n        IMaverickV2Pool pool,\\n        address user,\\n        uint256 subaccount,\\n        uint32 binId\\n    ) internal view returns (uint256 amountA, uint256 amountB, int32 tick, uint256 liquidity) {\\n        IMaverickV2Pool.BinState memory bin = pool.getBin(binId);\\n\\n        uint256 userBinLpBalance = pool.balanceOf(user, subaccount, binId);\\n        while (bin.mergeId != 0) {\\n            userBinLpBalance = bin.totalSupply == 0\\n                ? 0\\n                : Math.mulDivFloor(userBinLpBalance, bin.mergeBinBalance, bin.totalSupply);\\n            bin = pool.getBin(bin.mergeId);\\n        }\\n        tick = bin.tick;\\n\\n        IMaverickV2Pool.TickState memory tickState = pool.getTick(tick);\\n\\n        uint256 activeBinDeltaLpBalance = Math.min(userBinLpBalance, bin.totalSupply);\\n\\n        uint128 deltaTickBalance = Math\\n            .mulDivDown(activeBinDeltaLpBalance, bin.tickBalance, bin.totalSupply)\\n            .toUint128();\\n\\n        deltaTickBalance = Math.min128(deltaTickBalance, tickState.totalSupply);\\n\\n        (amountA, amountB) = PoolLib.binReserves(\\n            deltaTickBalance,\\n            tickState.reserveA,\\n            tickState.reserveB,\\n            tickState.totalSupply\\n        );\\n\\n        {\\n            (uint256 sqrtLowerTickPrice, uint256 sqrtUpperTickPrice) = TickMath.tickSqrtPrices(\\n                pool.tickSpacing(),\\n                tick\\n            );\\n            liquidity = TickMath.getTickL(amountA, amountB, sqrtLowerTickPrice, sqrtUpperTickPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the reserves of a token for all bins associated with it.\\n     * Bin reserve amounts are in pool D18 scale units.\\n     */\\n    function subaccountPositionInformation(\\n        IMaverickV2Pool pool,\\n        address user,\\n        uint256 subaccount,\\n        uint32[] memory binIds\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256[] memory binAAmounts,\\n            uint256[] memory binBAmounts,\\n            int32[] memory ticks,\\n            uint256[] memory liquidities\\n        )\\n    {\\n        binAAmounts = new uint256[](binIds.length);\\n        binBAmounts = new uint256[](binIds.length);\\n        ticks = new int32[](binIds.length);\\n        liquidities = new uint256[](binIds.length);\\n\\n        for (uint256 i; i < binIds.length; i++) {\\n            (binAAmounts[i], binBAmounts[i], ticks[i], liquidities[i]) = userSubaccountBinReserves(\\n                pool,\\n                user,\\n                subaccount,\\n                binIds[i]\\n            );\\n            amountA += binAAmounts[i];\\n            amountB += binBAmounts[i];\\n        }\\n        {\\n            uint256 tokenAScale = pool.tokenAScale();\\n            uint256 tokenBScale = pool.tokenBScale();\\n            amountA = Math.ammScaleToTokenScale(amountA, tokenAScale, false);\\n            amountB = Math.ammScaleToTokenScale(amountB, tokenBScale, false);\\n        }\\n    }\\n\\n    function binLpBalances(\\n        IMaverickV2Pool pool,\\n        uint32[] memory binIds,\\n        uint256 subaccount\\n    ) internal view returns (uint128[] memory amounts) {\\n        amounts = new uint128[](binIds.length);\\n        for (uint256 i = 0; i < binIds.length; i++) {\\n            amounts[i] = pool.balanceOf(address(this), subaccount, binIds[i]);\\n        }\\n    }\\n\\n    function lpBalanceForTargetReserveAmounts(\\n        IMaverickV2Pool pool,\\n        uint32 binId,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 scaleA,\\n        uint256 scaleB\\n    ) internal view returns (IMaverickV2Pool.AddLiquidityParams memory addParams) {\\n        amountA = Math.tokenScaleToAmmScale(amountA, scaleA);\\n        amountB = Math.tokenScaleToAmmScale(amountB, scaleB);\\n\\n        IMaverickV2Pool.BinState memory bin = pool.getBin(binId);\\n        uint128[] memory amounts = new uint128[](1);\\n\\n        IMaverickV2Pool.TickState memory tickState = pool.getTick(bin.tick);\\n        uint256 numerator = Math.max(1, uint256(tickState.totalSupply)) * Math.max(1, uint256(bin.totalSupply));\\n\\n        if (amountA != 0) {\\n            uint256 denominator = Math.max(1, uint256(bin.tickBalance)) * uint256(tickState.reserveA);\\n            amounts[0] = Math.mulDivFloor(amountA, numerator, denominator).toUint128();\\n        }\\n        if (amountB != 0) {\\n            uint256 denominator = Math.max(1, uint256(bin.tickBalance)) * uint256(tickState.reserveB);\\n\\n            if (amountA != 0) {\\n                amounts[0] = Math.min128(amounts[0], Math.mulDivFloor(amountB, numerator, denominator).toUint128());\\n            } else {\\n                amounts[0] = Math.mulDivFloor(amountB, numerator, denominator).toUint128();\\n            }\\n        }\\n        {\\n            int32[] memory ticks = new int32[](1);\\n            ticks[0] = bin.tick;\\n            addParams = IMaverickV2Pool.AddLiquidityParams({kind: bin.kind, ticks: ticks, amounts: amounts});\\n        }\\n    }\\n\\n    function maxRemoveParams(\\n        IMaverickV2Pool pool,\\n        uint32 binId,\\n        address user,\\n        uint256 subaccount\\n    ) internal view returns (IMaverickV2Pool.RemoveLiquidityParams memory params) {\\n        uint32[] memory binIds = new uint32[](1);\\n        uint128[] memory amounts = new uint128[](1);\\n        binIds[0] = binId;\\n        amounts[0] = pool.balanceOf(user, subaccount, binId);\\n        params = IMaverickV2Pool.RemoveLiquidityParams({binIds: binIds, amounts: amounts});\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/liquiditybase/ArgPacker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {PackLib} from \\\"../libraries/PackLib.sol\\\";\\nimport {IArgPacker} from \\\"./IArgPacker.sol\\\";\\n\\n/**\\n * @notice View functions that pack and unpack addLiquidity parameters.\\n */\\nabstract contract ArgPacker is IArgPacker {\\n    /// @inheritdoc IArgPacker\\n    function unpackAddLiquidityArgs(\\n        bytes memory argsPacked\\n    ) public pure returns (IMaverickV2Pool.AddLiquidityParams memory args) {\\n        return PackLib.unpackAddLiquidityArgs(argsPacked);\\n    }\\n\\n    /// @inheritdoc IArgPacker\\n    function packAddLiquidityArgs(\\n        IMaverickV2Pool.AddLiquidityParams memory args\\n    ) public pure returns (bytes memory argsPacked) {\\n        return PackLib.packAddLiquidityArgs(args);\\n    }\\n\\n    /// @inheritdoc IArgPacker\\n    function packAddLiquidityArgsArray(\\n        IMaverickV2Pool.AddLiquidityParams[] memory args\\n    ) public pure returns (bytes[] memory argsPacked) {\\n        return PackLib.packAddLiquidityArgsArray(args);\\n    }\\n\\n    /// @inheritdoc IArgPacker\\n    function unpackUint88Array(bytes memory packedArray) public pure returns (uint88[] memory fullArray) {\\n        fullArray = PackLib.unpackUint88Array(packedArray);\\n    }\\n\\n    /// @inheritdoc IArgPacker\\n    function packUint88Array(uint88[] memory fullArray) public pure returns (bytes memory packedArray) {\\n        packedArray = PackLib.packArray(fullArray);\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/liquiditybase/IArgPacker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\ninterface IArgPacker {\\n    /**\\n     * @notice Packs addLiquidity paramters into a bytes object.  The packing\\n     * is [kind, ticksArray, amountsArray] where the arrays are packed like\\n     * this: [length, array[0], array[1],..., array[length-1]]. length is 1\\n     * byte (256 total possible elements).\\n     */\\n    function packAddLiquidityArgs(\\n        IMaverickV2Pool.AddLiquidityParams memory args\\n    ) external pure returns (bytes memory argsPacked);\\n\\n    /**\\n     * @notice Unpacks packed addLiquidity parameters.\\n     */\\n    function unpackAddLiquidityArgs(\\n        bytes memory argsPacked\\n    ) external pure returns (IMaverickV2Pool.AddLiquidityParams memory args);\\n\\n    /**\\n     * @notice Packs addLiquidity paramters array element-wise.\\n     */\\n    function packAddLiquidityArgsArray(\\n        IMaverickV2Pool.AddLiquidityParams[] memory args\\n    ) external pure returns (bytes[] memory argsPacked);\\n\\n    /**\\n     * @notice Packs sqrtPrice breaks array with this format: [length,\\n     * array[0], array[1],..., array[length-1]] where length is 1 byte.\\n\\n     */\\n    function packUint88Array(uint88[] memory fullArray) external pure returns (bytes memory packedArray);\\n\\n    /**\\n     * @notice Unpacks sqrtPrice breaks bytes object into array.\\n     */\\n    function unpackUint88Array(bytes memory packedArray) external pure returns (uint88[] memory fullArray);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/MaverickV2LiquidityManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\nimport {EMPTY_PRICE_BREAKS} from \\\"@maverick/v2-common/contracts/libraries/Constants.sol\\\";\\n\\nimport {PoolInspection} from \\\"./libraries/PoolInspection.sol\\\";\\nimport {IMaverickV2Position} from \\\"./interfaces/IMaverickV2Position.sol\\\";\\nimport {IMaverickV2PoolLens} from \\\"./interfaces/IMaverickV2PoolLens.sol\\\";\\nimport {IMaverickV2BoostedPosition} from \\\"./interfaces/IMaverickV2BoostedPosition.sol\\\";\\nimport {IMaverickV2LiquidityManager} from \\\"./interfaces/IMaverickV2LiquidityManager.sol\\\";\\nimport {IMaverickV2BoostedPositionFactory} from \\\"./interfaces/IMaverickV2BoostedPositionFactory.sol\\\";\\nimport {IWETH9} from \\\"./paymentbase/IWETH9.sol\\\";\\nimport {ArgPacker} from \\\"./liquiditybase/ArgPacker.sol\\\";\\nimport {State} from \\\"./paymentbase/State.sol\\\";\\nimport {ExactOutputSlim} from \\\"./routerbase/ExactOutputSlim.sol\\\";\\nimport {LiquidityUtilities} from \\\"./libraries/LiquidityUtilities.sol\\\";\\nimport {Checks} from \\\"./base/Checks.sol\\\";\\nimport {MigrateBins} from \\\"./base/MigrateBins.sol\\\";\\n\\n/**\\n * @notice Maverick liquidity management contract that provides helper\\n * functions for minting either NFT liquidity positions or boosted positions\\n * which are fungible positions in a Maverick V2 pool.  While this contract\\n * does have public payment callback functions, these are access controlled\\n * so that they can only be called by a factory pool; so it is safe to approve\\n * this contract to spend a caller's tokens.\\n *\\n * This contract inherits \\\"Check\\\" functions that can be multicalled with\\n * liquidity management functions to create slippage and deadline constraints on\\n * transactions.\\n *\\n *\\n * @dev This contract has a multicall interface and all public functions are\\n * payable which facilitates multicall combinations of both payable\\n * interactions and non-payable interactions.\\n *\\n * @dev addLiquidity parameters are specified as a lookup table of prices where\\n * the caller specifies packedSqrtPriceBreaks and packedArgs.  During the add\\n * operation, this contract queries the pool for its current sqrtPrice and then\\n * looks up this price relative to the price breaks array (the array is packed\\n * as bytes using the conventions in the inherited ArgPacker contract to save\\n * calldata space).  If the current pool sqrt price is in between the N and N+1\\n * elements of the packedSqrtPriceBreaks array, then the add parameters from the\\n * Nth element of the packedArgs array are used in the add liquidity call.\\n *\\n * @dev This lookup table approach provides a flexible way for callers to\\n * manage price slippage between the time they submit their transaction and the\\n * time it is executed. The MaverickV2PoolLens contract provides a number of\\n * helper function to create this slippage lookup table.\\n */\\ncontract MaverickV2LiquidityManager is Checks, ExactOutputSlim, ArgPacker, MigrateBins, IMaverickV2LiquidityManager {\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    IMaverickV2Position public immutable position;\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    IMaverickV2BoostedPositionFactory public immutable boostedPositionFactory;\\n\\n    constructor(\\n        IMaverickV2Factory _factory,\\n        IWETH9 _weth,\\n        IMaverickV2Position _position,\\n        IMaverickV2BoostedPositionFactory _boostedPositionFactory\\n    ) State(_factory, _weth) {\\n        position = _position;\\n        boostedPositionFactory = _boostedPositionFactory;\\n    }\\n\\n    ///////////////////////////\\n    ////  Pool functions\\n    ///////////////////////////\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function createPool(\\n        uint64 fee,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds\\n    ) public payable returns (IMaverickV2Pool pool) {\\n        pool = factory().create(fee, fee, tickSpacing, lookback, tokenA, tokenB, activeTick, kinds);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function createPool(\\n        uint64 feeAIn,\\n        uint64 feeBIn,\\n        uint16 tickSpacing,\\n        uint32 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        int32 activeTick,\\n        uint8 kinds\\n    ) public payable returns (IMaverickV2Pool pool) {\\n        pool = factory().create(feeAIn, feeBIn, tickSpacing, lookback, tokenA, tokenB, activeTick, kinds);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function addLiquidity(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        uint256 subaccount,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds) {\\n        uint256 sqrtPrice = PoolInspection.poolSqrtPrice(pool);\\n\\n        uint256 priceIndex = LiquidityUtilities.priceIndexFromPriceBreaks(sqrtPrice, packedSqrtPriceBreaks);\\n        IMaverickV2Pool.AddLiquidityParams memory args = unpackAddLiquidityArgs(packedArgs[priceIndex]);\\n        (tokenAAmount, tokenBAmount, binIds) = pool.addLiquidity(recipient, subaccount, args, abi.encode(msg.sender));\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function donateLiquidity(IMaverickV2Pool pool, IMaverickV2Pool.AddLiquidityParams memory args) public payable {\\n        pool.addLiquidity(address(position), 0, args, abi.encode(msg.sender));\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function createPoolAtPriceAndAddLiquidityToSender(\\n        IMaverickV2PoolLens.CreateAndAddParamsInputs memory params\\n    )\\n        public\\n        payable\\n        returns (\\n            IMaverickV2Pool pool,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint32[] memory binIds,\\n            uint256 tokenId\\n        )\\n    {\\n        return createPoolAtPriceAndAddLiquidity(msg.sender, params);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function createPoolAtPriceAndAddLiquidity(\\n        address recipient,\\n        IMaverickV2PoolLens.CreateAndAddParamsInputs memory params\\n    )\\n        public\\n        payable\\n        returns (\\n            IMaverickV2Pool pool,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            uint32[] memory binIds,\\n            uint256 tokenId\\n        )\\n    {\\n        pool = createPool(\\n            params.feeAIn,\\n            params.feeBIn,\\n            params.tickSpacing,\\n            params.lookback,\\n            params.tokenA,\\n            params.tokenB,\\n            params.activeTick,\\n            params.kinds\\n        );\\n        if (params.swapAmount != 0) {\\n            donateLiquidity(pool, params.donateParams);\\n            exactOutputSingleMinimal(recipient, pool, true, params.swapAmount, type(int32).max);\\n        }\\n\\n        (tokenAAmount, tokenBAmount, binIds, tokenId) = mintPositionNft(\\n            pool,\\n            recipient,\\n            EMPTY_PRICE_BREAKS,\\n            params.packedAddParams\\n        );\\n    }\\n\\n    function maverickV2AddLiquidityCallback(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint256 amountA,\\n        uint256 amountB,\\n        bytes calldata data\\n    ) public {\\n        if (!factory().isFactoryPool(IMaverickV2Pool(msg.sender))) revert LiquidityManagerNotFactoryPool();\\n        address payer = abi.decode(data, (address));\\n        if (amountA != 0) {\\n            pay(tokenA, payer, msg.sender, amountA);\\n        }\\n        if (amountB != 0) {\\n            pay(tokenB, payer, msg.sender, amountB);\\n        }\\n    }\\n\\n    ///////////////////////////\\n    ////  Position NFT functions\\n    ///////////////////////////\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function addPositionLiquidityToSenderByTokenIndex(\\n        IMaverickV2Pool pool,\\n        uint256 index,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds) {\\n        (tokenAAmount, tokenBAmount, binIds) = addLiquidity(\\n            pool,\\n            address(position),\\n            position.tokenOfOwnerByIndex(msg.sender, index),\\n            packedSqrtPriceBreaks,\\n            packedArgs\\n        );\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function addPositionLiquidityToRecipientByTokenIndex(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        uint256 index,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds) {\\n        (tokenAAmount, tokenBAmount, binIds) = addLiquidity(\\n            pool,\\n            address(position),\\n            position.tokenOfOwnerByIndex(recipient, index),\\n            packedSqrtPriceBreaks,\\n            packedArgs\\n        );\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function mintPositionNft(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds, uint256 tokenId) {\\n        (tokenAAmount, tokenBAmount, binIds) = addLiquidity(\\n            pool,\\n            address(position),\\n            position.nextTokenId(),\\n            packedSqrtPriceBreaks,\\n            packedArgs\\n        );\\n        tokenId = position.mint(recipient, pool, binIds);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function mintPositionNftToSender(\\n        IMaverickV2Pool pool,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable returns (uint256 tokenAAmount, uint256 tokenBAmount, uint32[] memory binIds, uint256 tokenId) {\\n        return mintPositionNft(pool, msg.sender, packedSqrtPriceBreaks, packedArgs);\\n    }\\n\\n    ///////////////////////////\\n    ////  Booste Position functions\\n    ///////////////////////////\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function migrateBoostedPosition(IMaverickV2BoostedPosition boostedPosition) public payable {\\n        boostedPosition.migrateBinLiquidityToRoot();\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function skimBoostedPosition(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        address recipient\\n    ) public payable returns (uint256 tokenAAmount, uint256 tokenBAmount) {\\n        (tokenAAmount, tokenBAmount) = boostedPosition.skim(recipient);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function mintBoostedPosition(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        address recipient\\n    ) public payable returns (uint256 mintedLpAmount) {\\n        mintedLpAmount = boostedPosition.mint(recipient);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function addLiquidityAndMintBoostedPosition(\\n        address recipient,\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable virtual returns (uint256 mintedLpAmount, uint256 tokenAAmount, uint256 tokenBAmount) {\\n        boostedPosition.migrateBinLiquidityToRoot();\\n        if (boostedPosition.skimmableAmount() != 0) skimBoostedPosition(boostedPosition, recipient);\\n        (tokenAAmount, tokenBAmount, ) = addLiquidity(\\n            boostedPosition.pool(),\\n            address(boostedPosition),\\n            0,\\n            packedSqrtPriceBreaks,\\n            packedArgs\\n        );\\n        mintedLpAmount = boostedPosition.mint(recipient);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function addLiquidityAndMintBoostedPositionToSender(\\n        IMaverickV2BoostedPosition boostedPosition,\\n        bytes memory packedSqrtPriceBreaks,\\n        bytes[] memory packedArgs\\n    ) public payable returns (uint256 mintedLpAmount, uint256 tokenAAmount, uint256 tokenBAmount) {\\n        return addLiquidityAndMintBoostedPosition(msg.sender, boostedPosition, packedSqrtPriceBreaks, packedArgs);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function createBoostedPositionAndAddLiquidityToSender(\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params\\n    )\\n        public\\n        payable\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount\\n        )\\n    {\\n        return createBoostedPositionAndAddLiquidity(msg.sender, params);\\n    }\\n\\n    /// @inheritdoc IMaverickV2LiquidityManager\\n    function createBoostedPositionAndAddLiquidity(\\n        address recipient,\\n        IMaverickV2PoolLens.CreateBoostedPositionInputs memory params\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (\\n            IMaverickV2BoostedPosition boostedPosition,\\n            uint256 mintedLpAmount,\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount\\n        )\\n    {\\n        boostedPosition = boostedPositionFactory.createBoostedPosition(\\n            params.bpSpec.pool,\\n            params.bpSpec.binIds,\\n            params.bpSpec.ratios,\\n            params.bpSpec.kind\\n        );\\n        (tokenAAmount, tokenBAmount, ) = addLiquidity(\\n            params.bpSpec.pool,\\n            address(boostedPosition),\\n            0,\\n            params.packedSqrtPriceBreaks,\\n            params.packedArgs\\n        );\\n        mintedLpAmount = boostedPosition.mint(recipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/paymentbase/IPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPayableMulticall} from \\\"@maverick/v2-common/contracts/base/IPayableMulticall.sol\\\";\\n\\nimport {IState} from \\\"./IState.sol\\\";\\n\\ninterface IPayment is IPayableMulticall, IState {\\n    error PaymentSenderNotWETH9();\\n    error PaymentInsufficientBalance(address token, uint256 amountMinimum, uint256 contractBalance);\\n\\n    receive() external payable;\\n\\n    /**\\n     * @notice Unwrap WETH9 tokens into ETH and send that balance to recipient.\\n     * If less than amountMinimum WETH is avialble, then revert.\\n     */\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\\n\\n    /**\\n     * @notice Transfers specified token amount to recipient\\n     */\\n    function sweepTokenAmount(IERC20 token, uint256 amount, address recipient) external payable;\\n\\n    /**\\n     * @notice Sweep entire ERC20 token balance on this contract to recipient.\\n     * If less than amountMinimum balance is avialble, then revert.\\n     */\\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) external payable;\\n\\n    /**\\n     * @notice Send any ETH on this contract to msg.sender.\\n     */\\n    function refundETH() external payable;\\n\\n    /**\\n     * @notice For tokenA and tokenB, sweep all of the\\n     * non-WETH tokens to msg.sender.  Any WETH balance is unwrapped to ETH and\\n     * then all the ETH on this contract is sent to msg.sender.\\n     */\\n    function unwrapAndSweep(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint256 tokenAAmountMin,\\n        uint256 tokenBAmountMin\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/paymentbase/IState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IWETH9} from \\\"./IWETH9.sol\\\";\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\n\\ninterface IState {\\n    function weth() external view returns (IWETH9 _weth);\\n    function factory() external view returns (IMaverickV2Factory _factory);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/paymentbase/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH9 is IERC20 {\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/paymentbase/Payment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {TransferLib} from \\\"@maverick/v2-common/contracts/libraries/TransferLib.sol\\\";\\nimport {PayableMulticall} from \\\"@maverick/v2-common/contracts/base/PayableMulticall.sol\\\";\\n\\nimport {IWETH9} from \\\"./IWETH9.sol\\\";\\nimport {State} from \\\"./State.sol\\\";\\n\\nimport {IPayment} from \\\"./IPayment.sol\\\";\\n\\n/**\\n * @notice Payment helper function that lets user sweep ERC20 tokens off the\\n * router and liquidity manager.  Also provides mechanism to wrap and unwrap\\n * ETH/WETH so that it can be used in the Maverick pools.\\n */\\nabstract contract Payment is State, PayableMulticall, IPayment {\\n    receive() external payable {\\n        if (IWETH9(msg.sender) != weth()) revert PaymentSenderNotWETH9();\\n    }\\n\\n    /// @inheritdoc IPayment\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\\n        uint256 balanceWETH9 = weth().balanceOf(address(this));\\n        if (balanceWETH9 < amountMinimum)\\n            revert PaymentInsufficientBalance(address(weth()), amountMinimum, balanceWETH9);\\n        if (balanceWETH9 > 0) {\\n            weth().withdraw(balanceWETH9);\\n            Address.sendValue(payable(recipient), balanceWETH9);\\n        }\\n    }\\n\\n    /// @inheritdoc IPayment\\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\\n        uint256 balanceToken = token.balanceOf(address(this));\\n        if (balanceToken < amountMinimum)\\n            revert PaymentInsufficientBalance(address(token), amountMinimum, balanceToken);\\n        if (balanceToken > 0) {\\n            TransferLib.transfer(token, recipient, balanceToken);\\n        }\\n    }\\n\\n    /// @inheritdoc IPayment\\n    function sweepTokenAmount(IERC20 token, uint256 amount, address recipient) public payable {\\n        TransferLib.transfer(token, recipient, amount);\\n    }\\n\\n    /// @inheritdoc IPayment\\n    function unwrapAndSweep(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint256 tokenAAmountMin,\\n        uint256 tokenBAmountMin\\n    ) public payable {\\n        if (address(tokenA) == address(weth())) {\\n            unwrapWETH9(tokenAAmountMin, msg.sender);\\n            refundETH();\\n            sweepToken(tokenB, tokenBAmountMin, msg.sender);\\n        } else if (address(tokenB) == address(weth())) {\\n            sweepToken(tokenA, tokenAAmountMin, msg.sender);\\n            unwrapWETH9(tokenBAmountMin, msg.sender);\\n            refundETH();\\n        } else {\\n            sweepToken(tokenA, tokenAAmountMin, msg.sender);\\n            sweepToken(tokenB, tokenBAmountMin, msg.sender);\\n        }\\n    }\\n\\n    /// @inheritdoc IPayment\\n    function refundETH() public payable {\\n        if (address(this).balance > 0) Address.sendValue(payable(msg.sender), address(this).balance);\\n    }\\n\\n    /**\\n     * @notice Internal function to pay tokens or eth.\\n     * @param token ERC20 token to pay.\\n     * @param payer Address of the payer.\\n     * @param recipient Address of the recipient.\\n     * @param value Amount of tokens to pay.\\n     */\\n    function pay(IERC20 token, address payer, address recipient, uint256 value) internal {\\n        if (IWETH9(address(token)) == weth() && address(this).balance >= value) {\\n            weth().deposit{value: value}();\\n            weth().transfer(recipient, value);\\n        } else if (payer == address(this)) {\\n            TransferLib.transfer(token, recipient, value);\\n        } else {\\n            TransferLib.transferFrom(token, payer, recipient, value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/paymentbase/State.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Factory} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Factory.sol\\\";\\nimport {IWETH9} from \\\"./IWETH9.sol\\\";\\nimport {IState} from \\\"./IState.sol\\\";\\n\\nabstract contract State is IState {\\n    IWETH9 private immutable _weth;\\n    IMaverickV2Factory private immutable _factory;\\n\\n    constructor(IMaverickV2Factory __factory, IWETH9 __weth) {\\n        _factory = __factory;\\n        _weth = __weth;\\n    }\\n\\n    function weth() public view returns (IWETH9 weth_) {\\n        weth_ = _weth;\\n    }\\n\\n    function factory() public view returns (IMaverickV2Factory factory_) {\\n        factory_ = _factory;\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/positionbase/INft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC721Enumerable} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface INft is IERC721Enumerable {\\n    /**\\n     * @notice Check if an NFT exists for a given owner and index.\\n     */\\n    function tokenOfOwnerByIndexExists(address owner, uint256 index) external view returns (bool);\\n\\n    /**\\n     * @notice Return Id of the next token minted.\\n     */\\n    function nextTokenId() external view returns (uint256 nextTokenId_);\\n\\n    /**\\n     * @notice Check if the caller has access to a specific NFT by tokenId.\\n     */\\n    function checkAuthorized(address spender, uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @notice List of tokenIds by owner.\\n     */\\n    function tokenIdsOfOwner(address owner) external view returns (uint256[] memory tokenIds);\\n\\n    /**\\n     * @notice Get the token URI for a given tokenId.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/routerbase/ExactOutputSlim.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\nimport {Payment} from \\\"../paymentbase/Payment.sol\\\";\\nimport {IExactOutputSlim} from \\\"./IExactOutputSlim.sol\\\";\\nimport {Swap} from \\\"./Swap.sol\\\";\\n\\nabstract contract ExactOutputSlim is Payment, Swap, IExactOutputSlim {\\n    /**\\n     * @dev Callback function called by Maverick V2 pools when swapping tokens.\\n     * @param tokenIn The input token.\\n     * @param amountToPay The amount to pay.\\n     * @param data Additional data.\\n     */\\n    function maverickV2SwapCallback(\\n        IERC20 tokenIn,\\n        uint256 amountToPay,\\n        uint256,\\n        bytes calldata data\\n    ) external virtual {\\n        if (!factory().isFactoryPool(IMaverickV2Pool(msg.sender))) revert RouterNotFactoryPool();\\n        address payer = abi.decode(data, (address));\\n        if (amountToPay != 0) pay(tokenIn, payer, msg.sender, amountToPay);\\n    }\\n\\n    /**\\n     * @dev Perform a swap with an exact output amount.\\n     * @param recipient The recipient of the swapped tokens.\\n     * @param pool The MaverickV2 pool to use for the swap.\\n     * @param tokenAIn Whether token A is the input token.\\n     * @param amountOut The exact output amount.\\n     * @param tickLimit The tick limit for the swap.\\n     * @return amountIn The input amount required to achieve the exact output.\\n     * @return amountOut_ The actual output amount received from the swap.\\n     */\\n    function exactOutputSingleMinimal(\\n        address recipient,\\n        IMaverickV2Pool pool,\\n        bool tokenAIn,\\n        uint256 amountOut,\\n        int32 tickLimit\\n    ) public payable returns (uint256 amountIn, uint256 amountOut_) {\\n        (amountIn, amountOut_) = _exactOutputSingleWithTickCheck(pool, recipient, amountOut, tokenAIn, tickLimit);\\n    }\\n\\n    /**\\n     * @dev Perform an exact output single swap with tick limit validation.\\n     * @param pool The MaverickV2 pool to use for the swap.\\n     * @param recipient The recipient of the swapped tokens.\\n     * @param amountOut The exact output amount.\\n     * @param tokenAIn Whether token A is the input token.\\n     * @param tickLimit The tick limit for the swap.\\n     * @return amountIn The input amount required to achieve the exact output.\\n     * @return _amountOut The actual output amount received from the swap.\\n     */\\n    function _exactOutputSingleWithTickCheck(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        uint256 amountOut,\\n        bool tokenAIn,\\n        int32 tickLimit\\n    ) internal returns (uint256 amountIn, uint256 _amountOut) {\\n        IMaverickV2Pool.SwapParams memory swapParams = IMaverickV2Pool.SwapParams({\\n            amount: amountOut,\\n            tokenAIn: tokenAIn,\\n            exactOutput: true,\\n            tickLimit: tickLimit\\n        });\\n        (amountIn, _amountOut) = _swap(\\n            pool,\\n            (recipient == address(0)) ? address(this) : recipient,\\n            swapParams,\\n            abi.encode(msg.sender)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/routerbase/IExactOutputSlim.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\nimport {IRouterErrors} from \\\"./IRouterErrors.sol\\\";\\n\\ninterface IExactOutputSlim is IRouterErrors {\\n    function exactOutputSingleMinimal(\\n        address recipient,\\n        IMaverickV2Pool pool,\\n        bool tokenAIn,\\n        uint256 amountOut,\\n        int32 tickLimit\\n    ) external payable returns (uint256 amountIn, uint256 amountOut_);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/routerbase/IRouterErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\ninterface IRouterErrors {\\n    error RouterZeroSwap();\\n    error RouterNotFactoryPool();\\n    error RouterTooLittleReceived(uint256 amountOutMinimum, uint256 amountOut);\\n    error RouterTooMuchRequested(uint256 amountInMaximum, uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"@maverick/v2-supplemental/contracts/routerbase/Swap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.25;\\n\\nimport {IMaverickV2Pool} from \\\"@maverick/v2-common/contracts/interfaces/IMaverickV2Pool.sol\\\";\\n\\n/**\\n * @notice Base contract support for swaps\\n */\\nabstract contract Swap {\\n    /**\\n     * @notice Internal swap function.  Override this function to add logic\\n     * before or after a swap.\\n     */\\n    function _swap(\\n        IMaverickV2Pool pool,\\n        address recipient,\\n        IMaverickV2Pool.SwapParams memory params,\\n        bytes memory data\\n    ) internal virtual returns (uint256 amountIn, uint256 amountOut) {\\n        (amountIn, amountOut) = pool.swap(recipient, params, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/governance/utils/IVotes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\\n */\\ninterface IVotes {\\n    /**\\n     * @dev The signature used has expired.\\n     */\\n    error VotesExpiredSignature(uint256 expiry);\\n\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\\n     */\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\\n\\n    /**\\n     * @dev Returns the current amount of votes that `account` has.\\n     */\\n    function getVotes(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     */\\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `account` has chosen.\\n     */\\n    function delegates(address account) external view returns (address);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`.\\n     */\\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC6372.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5500\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMaverickV2Factory\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"contract IWETH9\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"contract IMaverickV2Position\",\"name\":\"_position\",\"type\":\"address\"},{\"internalType\":\"contract IMaverickV2BoostedPositionFactory\",\"name\":\"_boostedPositionFactory\",\"type\":\"address\"},{\"internalType\":\"contract IMaverickV2RewardFactory\",\"name\":\"_rewardFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BytesLibSliceOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BytesLibSliceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityManagerNotFactoryPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityManagerNotTokenIdOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"PaymentInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentSenderNotWETH9\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"PositionDeadlinePassed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sqrtPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSqrtPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSqrtPrice\",\"type\":\"uint256\"}],\"name\":\"PositionExceededPriceBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RouterNotFactoryPool\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"RouterTooLittleReceived\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"RouterTooMuchRequested\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RouterZeroSwap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"}],\"name\":\"TickMaxExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subaccount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"addLiquidityAndMintBoostedPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"},{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"addLiquidityAndMintBoostedPositionAndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sendersTokenIndex\",\"type\":\"uint256\"},{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"},{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"addLiquidityAndMintBoostedPositionAndStakeToSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"addLiquidityAndMintBoostedPositionToSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"addPositionLiquidityToRecipientByTokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"addPositionLiquidityToSenderByTokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boostedPositionFactory\",\"outputs\":[{\"internalType\":\"contract IMaverickV2BoostedPositionFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"checkDeadline\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSqrtPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSqrtPrice\",\"type\":\"uint256\"}],\"name\":\"checkSqrtPrice\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"ratios\",\"type\":\"uint128[]\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"}],\"internalType\":\"struct IMaverickV2PoolLens.BoostedPositionSpecification\",\"name\":\"bpSpec\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IMaverickV2PoolLens.CreateBoostedPositionInputs\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createBoostedPositionAndAddLiquidity\",\"outputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"ratios\",\"type\":\"uint128[]\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"}],\"internalType\":\"struct IMaverickV2PoolLens.BoostedPositionSpecification\",\"name\":\"bpSpec\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IMaverickV2PoolLens.CreateBoostedPositionInputs\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"contract IMaverickV2VotingEscrow[]\",\"name\":\"veTokens\",\"type\":\"address[]\"}],\"name\":\"createBoostedPositionAndAddLiquidityAndStake\",\"outputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"ratios\",\"type\":\"uint128[]\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"}],\"internalType\":\"struct IMaverickV2PoolLens.BoostedPositionSpecification\",\"name\":\"bpSpec\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IMaverickV2PoolLens.CreateBoostedPositionInputs\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"contract IMaverickV2VotingEscrow[]\",\"name\":\"veTokens\",\"type\":\"address[]\"}],\"name\":\"createBoostedPositionAndAddLiquidityAndStakeToSender\",\"outputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"ratios\",\"type\":\"uint128[]\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"}],\"internalType\":\"struct IMaverickV2PoolLens.BoostedPositionSpecification\",\"name\":\"bpSpec\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IMaverickV2PoolLens.CreateBoostedPositionInputs\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createBoostedPositionAndAddLiquidityToSender\",\"outputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"fee\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"tickSpacing\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lookback\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int32\",\"name\":\"activeTick\",\"type\":\"int32\"},{\"internalType\":\"uint8\",\"name\":\"kinds\",\"type\":\"uint8\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"feeAIn\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"feeBIn\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"tickSpacing\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lookback\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int32\",\"name\":\"activeTick\",\"type\":\"int32\"},{\"internalType\":\"uint8\",\"name\":\"kinds\",\"type\":\"uint8\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"feeAIn\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"feeBIn\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"tickSpacing\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lookback\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int32\",\"name\":\"activeTick\",\"type\":\"int32\"},{\"internalType\":\"uint8\",\"name\":\"kinds\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"donateParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"addParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"packedAddParams\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"deltaAOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaBOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preAddReserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preAddReserveB\",\"type\":\"uint256\"}],\"internalType\":\"struct IMaverickV2PoolLens.CreateAndAddParamsInputs\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createPoolAtPriceAndAddLiquidity\",\"outputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"feeAIn\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"feeBIn\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"tickSpacing\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lookback\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int32\",\"name\":\"activeTick\",\"type\":\"int32\"},{\"internalType\":\"uint8\",\"name\":\"kinds\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"donateParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"addParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"packedAddParams\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"deltaAOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaBOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preAddReserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preAddReserveB\",\"type\":\"uint256\"}],\"internalType\":\"struct IMaverickV2PoolLens.CreateAndAddParamsInputs\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createPoolAtPriceAndAddLiquidityToSender\",\"outputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"donateLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"tokenAIn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"int32\",\"name\":\"tickLimit\",\"type\":\"int32\"}],\"name\":\"exactOutputSingleMinimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut_\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IMaverickV2Factory\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"maverickV2AddLiquidityCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"maverickV2SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"maxRecursion\",\"type\":\"uint32\"}],\"name\":\"migrateBinsUpStack\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"}],\"name\":\"migrateBoostedPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintBoostedPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedLpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"mintPositionNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"packedSqrtPriceBreaks\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedArgs\",\"type\":\"bytes[]\"}],\"name\":\"mintPositionNftToSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"binIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintTokenInReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"mintTokenInRewardToSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"packAddLiquidityArgs\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"argsPacked\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams[]\",\"name\":\"args\",\"type\":\"tuple[]\"}],\"name\":\"packAddLiquidityArgsArray\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"argsPacked\",\"type\":\"bytes[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint88[]\",\"name\":\"fullArray\",\"type\":\"uint88[]\"}],\"name\":\"packUint88Array\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"packedArray\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"position\",\"outputs\":[{\"internalType\":\"contract IMaverickV2Position\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardFactory\",\"outputs\":[{\"internalType\":\"contract IMaverickV2RewardFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2BoostedPosition\",\"name\":\"boostedPosition\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"skimBoostedPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepTokenAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2VotingEscrowWSync\",\"name\":\"ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"legacyLockupIndexes\",\"type\":\"uint256[]\"}],\"name\":\"sync\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newBalance\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAndNotifyRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMaverickV2Reward\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"argsPacked\",\"type\":\"bytes\"}],\"name\":\"unpackAddLiquidityArgs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32[]\",\"name\":\"ticks\",\"type\":\"int32[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IMaverickV2Pool.AddLiquidityParams\",\"name\":\"args\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"packedArray\",\"type\":\"bytes\"}],\"name\":\"unpackUint88Array\",\"outputs\":[{\"internalType\":\"uint88[]\",\"name\":\"fullArray\",\"type\":\"uint88[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmountMin\",\"type\":\"uint256\"}],\"name\":\"unwrapAndSweep\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrapWETH9\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"weth_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MaverickV2RewardRouter", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "5500", "ConstructorArguments": "0000000000000000000000000a7e848aca42d879ef06507fca0e7b33a0a63c1e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000116193c58b40d50687c0433b2aa0cc4ae00bc32c000000000000000000000000d94c8f6d13cf480ffac686712c63471d1596cc2900000000000000000000000063ef1a657cc53747689b201aa07a76e9ef22f8fe", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xc0c3bc532690af8922a2f260c6e1deb6cfab45a0", "SwarmSource": ""}