{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n\n\n\n\ncontract MainnetActionsUtilAddresses {\n    address internal constant DFS_REG_CONTROLLER_ADDR = 0xF8f8B3C98Cf2E63Df3041b73f80F362a4cf3A576;\n    address internal constant REGISTRY_ADDR = 0x287778F121F134C66212FB16c9b53eC991D32f5b;\n    address internal constant DFS_LOGGER_ADDR = 0xcE7a977Cac4a481bc84AC06b2Da0df614e621cf3;\n    address internal constant SUB_STORAGE_ADDR = 0x1612fc28Ee0AB882eC99842Cde0Fc77ff0691e90;\n    address internal constant PROXY_AUTH_ADDR = 0x149667b6FAe2c63D1B4317C716b0D0e4d3E2bD70;\n    address internal constant LSV_PROXY_REGISTRY_ADDRESS = 0xa8a3c86c4A2DcCf350E84D2b3c46BDeBc711C16e;\n    address internal constant TRANSIENT_STORAGE = 0x2F7Ef2ea5E8c97B8687CA703A0e50Aa5a49B7eb2;\n}\n\n\n\n\n\ncontract ActionsUtilHelper is MainnetActionsUtilAddresses {\n}\n\n\n\n\n\ncontract MainnetAuthAddresses {\n    address internal constant ADMIN_VAULT_ADDR = 0xCCf3d848e08b94478Ed8f46fFead3008faF581fD;\n    address internal constant DSGUARD_FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n    address internal constant ADMIN_ADDR = 0x25eFA336886C74eA8E282ac466BdCd0199f85BB9; // USED IN ADMIN VAULT CONSTRUCTOR\n    address internal constant PROXY_AUTH_ADDRESS = 0x149667b6FAe2c63D1B4317C716b0D0e4d3E2bD70;\n    address internal constant MODULE_AUTH_ADDRESS = 0x7407974DDBF539e552F1d051e44573090912CC3D;\n}\n\n\n\n\n\ncontract AuthHelper is MainnetAuthAddresses {\n}\n\n\n\n\n\ncontract AdminVault is AuthHelper {\n    address public owner;\n    address public admin;\n\n    error SenderNotAdmin();\n\n    constructor() {\n        owner = msg.sender;\n        admin = ADMIN_ADDR;\n    }\n\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    function changeOwner(address _owner) public {\n        if (admin != msg.sender){\n            revert SenderNotAdmin();\n        }\n        owner = _owner;\n    }\n\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    function changeAdmin(address _admin) public {\n        if (admin != msg.sender){\n            revert SenderNotAdmin();\n        }\n        admin = _admin;\n    }\n\n}\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\n\nlibrary Address {\n    //insufficient balance\n    error InsufficientBalance(uint256 available, uint256 required);\n    //unable to send value, recipient may have reverted\n    error SendingValueFail();\n    //insufficient balance for call\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\n    //call to non-contract\n    error NonContractCall();\n    \n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        uint256 balance = address(this).balance;\n        if (balance < amount){\n            revert InsufficientBalance(balance, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!(success)){\n            revert SendingValueFail();\n        }\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        uint256 balance = address(this).balance;\n        if (balance < value){\n            revert InsufficientBalanceForCall(balance, value);\n        }\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        if (!(isContract(target))){\n            revert NonContractCall();\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n\n\n\n\n\n\n\ncontract AdminAuth is AuthHelper {\n    using SafeERC20 for IERC20;\n\n    AdminVault public constant adminVault = AdminVault(ADMIN_VAULT_ADDR);\n\n    error SenderNotOwner();\n    error SenderNotAdmin();\n\n    modifier onlyOwner() {\n        if (adminVault.owner() != msg.sender){\n            revert SenderNotOwner();\n        }\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (adminVault.admin() != msg.sender){\n            revert SenderNotAdmin();\n        }\n        _;\n    }\n\n    /// @notice withdraw stuck funds\n    function withdrawStuckFunds(address _token, address _receiver, uint256 _amount) public onlyOwner {\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(_receiver).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_receiver, _amount);\n        }\n    }\n\n    /// @notice Destroy the contract\n    /// @dev Deprecated method, selfdestruct will soon just send eth\n    function kill() public onlyAdmin {\n        selfdestruct(payable(msg.sender));\n    }\n}\n\n\n\n\n\ncontract DFSRegistry is AdminAuth {\n    error EntryAlreadyExistsError(bytes4);\n    error EntryNonExistentError(bytes4);\n    error EntryNotInChangeError(bytes4);\n    error ChangeNotReadyError(uint256,uint256);\n    error EmptyPrevAddrError(bytes4);\n    error AlreadyInContractChangeError(bytes4);\n    error AlreadyInWaitPeriodChangeError(bytes4);\n\n    event AddNewContract(address,bytes4,address,uint256);\n    event RevertToPreviousAddress(address,bytes4,address,address);\n    event StartContractChange(address,bytes4,address,address);\n    event ApproveContractChange(address,bytes4,address,address);\n    event CancelContractChange(address,bytes4,address,address);\n    event StartWaitPeriodChange(address,bytes4,uint256);\n    event ApproveWaitPeriodChange(address,bytes4,uint256,uint256);\n    event CancelWaitPeriodChange(address,bytes4,uint256,uint256);\n\n    struct Entry {\n        address contractAddr;\n        uint256 waitPeriod;\n        uint256 changeStartTime;\n        bool inContractChange;\n        bool inWaitPeriodChange;\n        bool exists;\n    }\n\n    mapping(bytes4 => Entry) public entries;\n    mapping(bytes4 => address) public previousAddresses;\n\n    mapping(bytes4 => address) public pendingAddresses;\n    mapping(bytes4 => uint256) public pendingWaitTimes;\n\n    /// @notice Given an contract id returns the registered address\n    /// @dev Id is keccak256 of the contract name\n    /// @param _id Id of contract\n    function getAddr(bytes4 _id) public view returns (address) {\n        return entries[_id].contractAddr;\n    }\n\n    /// @notice Helper function to easily query if id is registered\n    /// @param _id Id of contract\n    function isRegistered(bytes4 _id) public view returns (bool) {\n        return entries[_id].exists;\n    }\n\n    /////////////////////////// OWNER ONLY FUNCTIONS ///////////////////////////\n\n    /// @notice Adds a new contract to the registry\n    /// @param _id Id of contract\n    /// @param _contractAddr Address of the contract\n    /// @param _waitPeriod Amount of time to wait before a contract address can be changed\n    function addNewContract(\n        bytes4 _id,\n        address _contractAddr,\n        uint256 _waitPeriod\n    ) public onlyOwner {\n        if (entries[_id].exists){\n            revert EntryAlreadyExistsError(_id);\n        }\n\n        entries[_id] = Entry({\n            contractAddr: _contractAddr,\n            waitPeriod: _waitPeriod,\n            changeStartTime: 0,\n            inContractChange: false,\n            inWaitPeriodChange: false,\n            exists: true\n        });\n\n        emit AddNewContract(msg.sender, _id, _contractAddr, _waitPeriod);\n    }\n\n    /// @notice Reverts to the previous address immediately\n    /// @dev In case the new version has a fault, a quick way to fallback to the old contract\n    /// @param _id Id of contract\n    function revertToPreviousAddress(bytes4 _id) public onlyOwner {\n        if (!(entries[_id].exists)){\n            revert EntryNonExistentError(_id);\n        }\n        if (previousAddresses[_id] == address(0)){\n            revert EmptyPrevAddrError(_id);\n        }\n\n        address currentAddr = entries[_id].contractAddr;\n        entries[_id].contractAddr = previousAddresses[_id];\n\n        emit RevertToPreviousAddress(msg.sender, _id, currentAddr, previousAddresses[_id]);\n    }\n\n    /// @notice Starts an address change for an existing entry\n    /// @dev Can override a change that is currently in progress\n    /// @param _id Id of contract\n    /// @param _newContractAddr Address of the new contract\n    function startContractChange(bytes4 _id, address _newContractAddr) public onlyOwner {\n        if (!entries[_id].exists){\n            revert EntryNonExistentError(_id);\n        }\n        if (entries[_id].inWaitPeriodChange){\n            revert AlreadyInWaitPeriodChangeError(_id);\n        }\n\n        entries[_id].changeStartTime = block.timestamp; // solhint-disable-line\n        entries[_id].inContractChange = true;\n\n        pendingAddresses[_id] = _newContractAddr;\n\n        emit StartContractChange(msg.sender, _id, entries[_id].contractAddr, _newContractAddr);\n    }\n\n    /// @notice Changes new contract address, correct time must have passed\n    /// @param _id Id of contract\n    function approveContractChange(bytes4 _id) public onlyOwner {\n        if (!entries[_id].exists){\n            revert EntryNonExistentError(_id);\n        }\n        if (!entries[_id].inContractChange){\n            revert EntryNotInChangeError(_id);\n        }\n        if (block.timestamp < (entries[_id].changeStartTime + entries[_id].waitPeriod)){// solhint-disable-line\n            revert ChangeNotReadyError(block.timestamp, (entries[_id].changeStartTime + entries[_id].waitPeriod));\n        }\n\n        address oldContractAddr = entries[_id].contractAddr;\n        entries[_id].contractAddr = pendingAddresses[_id];\n        entries[_id].inContractChange = false;\n        entries[_id].changeStartTime = 0;\n\n        pendingAddresses[_id] = address(0);\n        previousAddresses[_id] = oldContractAddr;\n\n        emit ApproveContractChange(msg.sender, _id, oldContractAddr, entries[_id].contractAddr);\n    }\n\n    /// @notice Cancel pending change\n    /// @param _id Id of contract\n    function cancelContractChange(bytes4 _id) public onlyOwner {\n        if (!entries[_id].exists){\n            revert EntryNonExistentError(_id);\n        }\n        if (!entries[_id].inContractChange){\n            revert EntryNotInChangeError(_id);\n        }\n\n        address oldContractAddr = pendingAddresses[_id];\n\n        pendingAddresses[_id] = address(0);\n        entries[_id].inContractChange = false;\n        entries[_id].changeStartTime = 0;\n\n        emit CancelContractChange(msg.sender, _id, oldContractAddr, entries[_id].contractAddr);\n    }\n\n    /// @notice Starts the change for waitPeriod\n    /// @param _id Id of contract\n    /// @param _newWaitPeriod New wait time\n    function startWaitPeriodChange(bytes4 _id, uint256 _newWaitPeriod) public onlyOwner {\n        if (!entries[_id].exists){\n            revert EntryNonExistentError(_id);\n        }\n        if (entries[_id].inContractChange){\n            revert AlreadyInContractChangeError(_id);\n        }\n\n        pendingWaitTimes[_id] = _newWaitPeriod;\n\n        entries[_id].changeStartTime = block.timestamp; // solhint-disable-line\n        entries[_id].inWaitPeriodChange = true;\n\n        emit StartWaitPeriodChange(msg.sender, _id, _newWaitPeriod);\n    }\n\n    /// @notice Changes new wait period, correct time must have passed\n    /// @param _id Id of contract\n    function approveWaitPeriodChange(bytes4 _id) public onlyOwner {\n        if (!entries[_id].exists){\n            revert EntryNonExistentError(_id);\n        }\n        if (!entries[_id].inWaitPeriodChange){\n            revert EntryNotInChangeError(_id);\n        }\n        if (block.timestamp < (entries[_id].changeStartTime + entries[_id].waitPeriod)){ // solhint-disable-line\n            revert ChangeNotReadyError(block.timestamp, (entries[_id].changeStartTime + entries[_id].waitPeriod));\n        }\n\n        uint256 oldWaitTime = entries[_id].waitPeriod;\n        entries[_id].waitPeriod = pendingWaitTimes[_id];\n        \n        entries[_id].inWaitPeriodChange = false;\n        entries[_id].changeStartTime = 0;\n\n        pendingWaitTimes[_id] = 0;\n\n        emit ApproveWaitPeriodChange(msg.sender, _id, oldWaitTime, entries[_id].waitPeriod);\n    }\n\n    /// @notice Cancel wait period change\n    /// @param _id Id of contract\n    function cancelWaitPeriodChange(bytes4 _id) public onlyOwner {\n        if (!entries[_id].exists){\n            revert EntryNonExistentError(_id);\n        }\n        if (!entries[_id].inWaitPeriodChange){\n            revert EntryNotInChangeError(_id);\n        }\n\n        uint256 oldWaitPeriod = pendingWaitTimes[_id];\n\n        pendingWaitTimes[_id] = 0;\n        entries[_id].inWaitPeriodChange = false;\n        entries[_id].changeStartTime = 0;\n\n        emit CancelWaitPeriodChange(msg.sender, _id, oldWaitPeriod, entries[_id].waitPeriod);\n    }\n}\n\n\n\n\n\nabstract contract DSAuthority {\n    function canCall(\n        address src,\n        address dst,\n        bytes4 sig\n    ) public view virtual returns (bool);\n}\n\n\n\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"Not authorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(address(0))) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n\n\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\n\n\n\n\n\nabstract contract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) {\n        if (!(setCache(_cacheAddr))){\n            require(isAuthorized(msg.sender, msg.sig), \"Not authorized\");\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public payable virtual returns (bool);\n}\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n\n\n\n\n\ninterface ISafe {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) external returns (bool success);\n\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) external view;\n\n    function checkNSignatures(\n        address executor,\n        bytes32 dataHash,\n        bytes memory /* data */,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) external view;\n\n    function approveHash(bytes32 hashToApprove) external;\n\n    function domainSeparator() external view returns (bytes32);\n\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n\n    function nonce() external view returns (uint256);\n\n    function setFallbackHandler(address handler) external;\n\n    function getOwners() external view returns (address[] memory);\n\n    function isOwner(address owner) external view returns (bool);\n\n    function getThreshold() external view returns (uint256);\n\n    function enableModule(address module) external;\n\n    function isModuleEnabled(address module) external view returns (bool);\n\n    function disableModule(address prevModule, address module) external;\n\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    ) external view returns (address[] memory array, address next);\n}\n\n\n\n\n\ninterface IDSProxyFactory {\n    function isProxy(address _proxy) external view returns (bool);\n}\n\n\n\n\n\ncontract MainnetProxyFactoryAddresses {\n    address internal constant PROXY_FACTORY_ADDR = 0xA26e15C895EFc0616177B7c1e7270A4C7D51C997;\n}\n\n\n\n\n\ncontract DSProxyFactoryHelper is MainnetProxyFactoryAddresses {\n}\n\n\n\n\n\n\ncontract CheckWalletType is DSProxyFactoryHelper {\n    function isDSProxy(address _proxy) public view returns (bool) {\n        return IDSProxyFactory(PROXY_FACTORY_ADDR).isProxy(_proxy);\n    }\n}\n\n\n\n\n\ncontract DefisaverLogger {\n    event RecipeEvent(\n        address indexed caller,\n        string indexed logName\n    );\n\n    event ActionDirectEvent(\n        address indexed caller,\n        string indexed logName,\n        bytes data\n    );\n\n    function logRecipeEvent(\n        string memory _logName\n    ) public {\n        emit RecipeEvent(msg.sender, _logName);\n    }\n\n    function logActionDirectEvent(\n        string memory _logName,\n        bytes memory _data\n    ) public {\n        emit ActionDirectEvent(msg.sender, _logName, _data);\n    }\n}\n\n\n\n\n\n\n\n\n\n\nabstract contract ActionBase is AdminAuth, ActionsUtilHelper, CheckWalletType {\n    event ActionEvent(\n        string indexed logName,\n        bytes data\n    );\n\n    DFSRegistry public constant registry = DFSRegistry(REGISTRY_ADDR);\n\n    DefisaverLogger public constant logger = DefisaverLogger(\n        DFS_LOGGER_ADDR\n    );\n\n    //Wrong sub index value\n    error SubIndexValueError();\n    //Wrong return index value\n    error ReturnIndexValueError();\n\n    /// @dev Subscription params index range [128, 255]\n    uint8 public constant SUB_MIN_INDEX_VALUE = 128;\n    uint8 public constant SUB_MAX_INDEX_VALUE = 255;\n\n    /// @dev Return params index range [1, 127]\n    uint8 public constant RETURN_MIN_INDEX_VALUE = 1;\n    uint8 public constant RETURN_MAX_INDEX_VALUE = 127;\n\n    /// @dev If the input value should not be replaced\n    uint8 public constant NO_PARAM_MAPPING = 0;\n\n    /// @dev We need to parse Flash loan actions in a different way\n    enum ActionType { FL_ACTION, STANDARD_ACTION, FEE_ACTION, CHECK_ACTION, CUSTOM_ACTION }\n\n    /// @notice Parses inputs and runs the implemented action through a user wallet\n    /// @dev Is called by the RecipeExecutor chaining actions together\n    /// @param _callData Array of input values each value encoded as bytes\n    /// @param _subData Array of subscribed vales, replaces input values if specified\n    /// @param _paramMapping Array that specifies how return and subscribed values are mapped in input\n    /// @param _returnValues Returns values from actions before, which can be injected in inputs\n    /// @return Returns a bytes32 value through user wallet, each actions implements what that value is\n    function executeAction(\n        bytes memory _callData,\n        bytes32[] memory _subData,\n        uint8[] memory _paramMapping,\n        bytes32[] memory _returnValues\n    ) public payable virtual returns (bytes32);\n\n    /// @notice Parses inputs and runs the single implemented action through a user wallet\n    /// @dev Used to save gas when executing a single action directly\n    function executeActionDirect(bytes memory _callData) public virtual payable;\n\n    /// @notice Returns the type of action we are implementing\n    function actionType() public pure virtual returns (uint8);\n\n\n    //////////////////////////// HELPER METHODS ////////////////////////////\n\n    /// @notice Given an uint256 input, injects return/sub values if specified\n    /// @param _param The original input value\n    /// @param _mapType Indicated the type of the input in paramMapping\n    /// @param _subData Array of subscription data we can replace the input value with\n    /// @param _returnValues Array of subscription data we can replace the input value with\n    function _parseParamUint(\n        uint _param,\n        uint8 _mapType,\n        bytes32[] memory _subData,\n        bytes32[] memory _returnValues\n    ) internal pure returns (uint) {\n        if (isReplaceable(_mapType)) {\n            if (isReturnInjection(_mapType)) {\n                _param = uint(_returnValues[getReturnIndex(_mapType)]);\n            } else {\n                _param = uint256(_subData[getSubIndex(_mapType)]);\n            }\n        }\n\n        return _param;\n    }\n\n\n    /// @notice Given an addr input, injects return/sub values if specified\n    /// @param _param The original input value\n    /// @param _mapType Indicated the type of the input in paramMapping\n    /// @param _subData Array of subscription data we can replace the input value with\n    /// @param _returnValues Array of subscription data we can replace the input value with\n    function _parseParamAddr(\n        address _param,\n        uint8 _mapType,\n        bytes32[] memory _subData,\n        bytes32[] memory _returnValues\n    ) internal view returns (address) {\n        if (isReplaceable(_mapType)) {\n            if (isReturnInjection(_mapType)) {\n                _param = address(bytes20((_returnValues[getReturnIndex(_mapType)])));\n            } else {\n                /// @dev The last two values are specially reserved for proxy addr and owner addr\n                if (_mapType == 254) return address(this); // DSProxy address\n                if (_mapType == 255) return fetchOwnersOrWallet(); // owner if 1/1 wallet or the wallet itself\n\n                _param = address(uint160(uint256(_subData[getSubIndex(_mapType)])));\n            }\n        }\n\n        return _param;\n    }\n\n    /// @notice Given an bytes32 input, injects return/sub values if specified\n    /// @param _param The original input value\n    /// @param _mapType Indicated the type of the input in paramMapping\n    /// @param _subData Array of subscription data we can replace the input value with\n    /// @param _returnValues Array of subscription data we can replace the input value with\n    function _parseParamABytes32(\n        bytes32 _param,\n        uint8 _mapType,\n        bytes32[] memory _subData,\n        bytes32[] memory _returnValues\n    ) internal pure returns (bytes32) {\n        if (isReplaceable(_mapType)) {\n            if (isReturnInjection(_mapType)) {\n                _param = (_returnValues[getReturnIndex(_mapType)]);\n            } else {\n                _param = _subData[getSubIndex(_mapType)];\n            }\n        }\n\n        return _param;\n    }\n\n    /// @notice Checks if the paramMapping value indicated that we need to inject values\n    /// @param _type Indicated the type of the input\n    function isReplaceable(uint8 _type) internal pure returns (bool) {\n        return _type != NO_PARAM_MAPPING;\n    }\n\n    /// @notice Checks if the paramMapping value is in the return value range\n    /// @param _type Indicated the type of the input\n    function isReturnInjection(uint8 _type) internal pure returns (bool) {\n        return (_type >= RETURN_MIN_INDEX_VALUE) && (_type <= RETURN_MAX_INDEX_VALUE);\n    }\n\n    /// @notice Transforms the paramMapping value to the index in return array value\n    /// @param _type Indicated the type of the input\n    function getReturnIndex(uint8 _type) internal pure returns (uint8) {\n        if (!(isReturnInjection(_type))){\n            revert SubIndexValueError();\n        }\n\n        return (_type - RETURN_MIN_INDEX_VALUE);\n    }\n\n    /// @notice Transforms the paramMapping value to the index in sub array value\n    /// @param _type Indicated the type of the input\n    function getSubIndex(uint8 _type) internal pure returns (uint8) {\n        if (_type < SUB_MIN_INDEX_VALUE){\n            revert ReturnIndexValueError();\n        }\n        return (_type - SUB_MIN_INDEX_VALUE);\n    }\n\n    function fetchOwnersOrWallet() internal view returns (address) {\n        if (isDSProxy(address(this))) \n            return DSProxy(payable(address(this))).owner();\n\n        // if not DSProxy, we assume we are in context of Safe\n        address[] memory owners = ISafe(address(this)).getOwners();\n        return owners.length == 1 ? owners[0] : address(this);\n    }\n}\n\n\n\n\n\ncontract MainnetFLAddresses {\n    address internal constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant DYDX_FL_FEE_FAUCET = 0x47f159C90850D5cE09E21F931d504536840f34b4;\n\n    address internal constant AAVE_LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n    address internal constant AAVE_LENDING_POOL_ADDRESS_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\n\n    address internal constant AAVE_V3_LENDING_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\n    address internal constant AAVE_V3_LENDING_POOL_ADDRESS_PROVIDER = 0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e;\n\n    address internal constant SPARK_LENDING_POOL_ADDRESS_PROVIDER = 0x02C3eA4e34C0cBd694D2adFa2c690EECbC1793eE;\n    address internal constant SPARK_LENDING_POOL = 0xC13e21B648A5Ee794902342038FF3aDAB66BE987;\n\n    address internal constant DSS_FLASH_ADDR = 0x60744434d6339a6B27d73d9Eda62b6F66a0a04FA;\n    address internal constant DAI_ADDR = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant ST_ETH_ADDR = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n    address internal constant VAULT_ADDR = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n\n    address internal constant GHO_ADDR = 0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f;\n    address internal constant GHO_FLASH_MINTER_ADDR = 0xb639D208Bcf0589D54FaC24E655C79EC529762B8;\n    address internal constant UNI_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    address internal constant MORPHO_BLUE_ADDR = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\n\n    address internal constant RECIPE_EXECUTOR_ADDR = 0x5029336642814bC51a42bA80BF83a6322110035D;\n}\n\n\n\n\n\n\ncontract FLFeeFaucet {\n\n    using SafeERC20 for IERC20;\n\n    /// @notice Sends 2 wei to msg.sender\n    /// @dev Anyone can call this method but it's not economically feasible to drain\n    /// @param _tokenAddr Address of the token we want 2 wei\n    function my2Wei(address _tokenAddr) public {\n        IERC20(_tokenAddr).safeTransfer(msg.sender, 2);\n    }\n}\n\n\n\n\n\n\ncontract FLHelper is MainnetFLAddresses {\n    uint16 internal constant AAVE_REFERRAL_CODE = 64;\n    uint16 internal constant SPARK_REFERRAL_CODE = 0;\n    FLFeeFaucet public constant flFeeFaucet = FLFeeFaucet(DYDX_FL_FEE_FAUCET);\n}\n\n\n\n\n\ncontract MainnetCoreAddresses {\n    address internal constant REGISTRY_ADDR = 0x287778F121F134C66212FB16c9b53eC991D32f5b;\n    address internal constant PROXY_AUTH_ADDR = 0x149667b6FAe2c63D1B4317C716b0D0e4d3E2bD70;\n    address internal constant MODULE_AUTH_ADDR = 0x7407974DDBF539e552F1d051e44573090912CC3D;\n    address internal constant DEFISAVER_LOGGER = 0xcE7a977Cac4a481bc84AC06b2Da0df614e621cf3;\n\n    address internal constant SUB_STORAGE_ADDR = 0x1612fc28Ee0AB882eC99842Cde0Fc77ff0691e90;\n    address internal constant BUNDLE_STORAGE_ADDR = 0x223c6aDE533851Df03219f6E3D8B763Bd47f84cf;\n    address internal constant STRATEGY_STORAGE_ADDR = 0xF52551F95ec4A2B4299DcC42fbbc576718Dbf933;\n\n    address internal constant RECIPE_EXECUTOR_ADDR = 0x5029336642814bC51a42bA80BF83a6322110035D;\n}\n\n\n\n\n\ncontract CoreHelper is MainnetCoreAddresses {\n}\n\n\n\n\n\n\ncontract StrategyModel {\n        \n    /// @dev Group of strategies bundled together so user can sub to multiple strategies at once\n    /// @param creator Address of the user who created the bundle\n    /// @param strategyIds Array of strategy ids stored in StrategyStorage\n    struct StrategyBundle {\n        address creator;\n        uint64[] strategyIds;\n    }\n\n    /// @dev Template/Class which defines a Strategy\n    /// @param name Name of the strategy useful for logging what strategy is executing\n    /// @param creator Address of the user which created the strategy\n    /// @param triggerIds Array of identifiers for trigger - bytes4(keccak256(TriggerName))\n    /// @param actionIds Array of identifiers for actions - bytes4(keccak256(ActionName))\n    /// @param paramMapping Describes how inputs to functions are piped from return/subbed values\n    /// @param continuous If the action is repeated (continuos) or one time\n    struct Strategy {\n        string name;\n        address creator;\n        bytes4[] triggerIds;\n        bytes4[] actionIds;\n        uint8[][] paramMapping;\n        bool continuous;\n    }\n\n    /// @dev List of actions grouped as a recipe\n    /// @param name Name of the recipe useful for logging what recipe is executing\n    /// @param callData Array of calldata inputs to each action\n    /// @param subData Used only as part of strategy, subData injected from StrategySub.subData\n    /// @param actionIds Array of identifiers for actions - bytes4(keccak256(ActionName))\n    /// @param paramMapping Describes how inputs to functions are piped from return/subbed values\n    struct Recipe {\n        string name;\n        bytes[] callData;\n        bytes32[] subData;\n        bytes4[] actionIds;\n        uint8[][] paramMapping;\n    }\n\n    /// @dev Actual data of the sub we store on-chain\n    /// @dev In order to save on gas we store a keccak256(StrategySub) and verify later on\n    /// @param walletAddr Address of the users smart wallet/proxy\n    /// @param isEnabled Toggle if the subscription is active\n    /// @param strategySubHash Hash of the StrategySub data the user inputted\n    struct StoredSubData {\n        bytes20 walletAddr; // address but put in bytes20 for gas savings\n        bool isEnabled;\n        bytes32 strategySubHash;\n    }\n\n    /// @dev Instance of a strategy, user supplied data\n    /// @param strategyOrBundleId Id of the strategy or bundle, depending on the isBundle bool\n    /// @param isBundle If true the id points to bundle, if false points directly to strategyId\n    /// @param triggerData User supplied data needed for checking trigger conditions\n    /// @param subData User supplied data used in recipe\n    struct StrategySub {\n        uint64 strategyOrBundleId;\n        bool isBundle;\n        bytes[] triggerData;\n        bytes32[] subData;\n    }\n}\n\n\n\n\n\ninterface ILendingPoolAddressesProviderV2 {\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n\n\n\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n\ninterface ILendingPoolV2 {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external;\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProviderV2);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n\n\n\n\ninterface IFlashLoans {\n    function flashLoan(\n        address recipient,\n        address[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n}\n\n\n\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n\n\n\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(\n        address token\n    ) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n\n\n\n\nabstract contract IFlashLoanBase{\n    \n    struct FlashLoanParams {\n        address[] tokens;\n        uint256[] amounts;\n        uint256[] modes;\n        address onBehalfOf;\n        address flParamGetterAddr;\n        bytes flParamGetterData;\n        bytes recipeData;\n    }\n}\n\n\n\n\n\nabstract contract IDSProxy {\n    // function execute(bytes memory _code, bytes memory _data)\n    //     public\n    //     payable\n    //     virtual\n    //     returns (address, bytes32);\n\n    function execute(address _target, bytes memory _data) public payable virtual returns (bytes32);\n\n    function setCache(address _cacheAddr) public payable virtual returns (bool);\n\n    function owner() public view virtual returns (address);\n}\n\n\n\n\ntype Id is bytes32;\n\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\nstruct MorphoBluePosition {\n    uint256 supplyShares;\n    uint128 borrowShares;\n    uint128 collateral;\n}\n\nstruct Market {\n    uint128 totalSupplyAssets;\n    uint128 totalSupplyShares;\n    uint128 totalBorrowAssets;\n    uint128 totalBorrowShares;\n    uint128 lastUpdate;\n    uint128 fee;\n}\n\nstruct Authorization {\n    address authorizer;\n    address authorized;\n    bool isAuthorized;\n    uint256 nonce;\n    uint256 deadline;\n}\n\nstruct Signature {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface IMorphoBase {\n    /// @notice The EIP-712 domain separator.\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\n    /// the same chain id because the domain separator would be the same.\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice The owner of the contract.\n    /// @dev It has the power to change the owner.\n    /// @dev It has the power to set fees on markets and set the fee recipient.\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\n    function owner() external view returns (address);\n\n    /// @notice The fee recipient of all markets.\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\n    function feeRecipient() external view returns (address);\n\n    /// @notice Whether the `irm` is enabled.\n    function isIrmEnabled(address irm) external view returns (bool);\n\n    /// @notice Whether the `lltv` is enabled.\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\n\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s positions.\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\n\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\n    function nonce(address authorizer) external view returns (uint256);\n\n    /// @notice Sets `newOwner` as `owner` of the contract.\n    /// @dev Warning: No two-step transfer ownership.\n    /// @dev Warning: The owner can be set to the zero address.\n    function setOwner(address newOwner) external;\n\n    /// @notice Enables `irm` as a possible IRM for market creation.\n    /// @dev Warning: It is not possible to disable an IRM.\n    function enableIrm(address irm) external;\n\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\n    /// @dev Warning: It is not possible to disable a LLTV.\n    function enableLltv(uint256 lltv) external;\n\n    /// @notice Sets the `newFee` for the given market `marketParams`.\n    /// @dev Warning: The recipient can be the zero address.\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\n\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\n    function setFeeRecipient(address newFeeRecipient) external;\n\n    /// @notice Creates the market `marketParams`.\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\n    /// Morpho behaves as expected:\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\n    /// burn functions are not supported.\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\n    /// - The IRM should not re-enter Morpho.\n    /// - The oracle should return a price with the correct scaling.\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\n    /// (funds could get stuck):\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\n    /// `toSharesDown` overflow.\n    /// - The IRM can revert on `borrowRate`.\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\n    /// overflow.\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\n    /// `liquidate` from being used under certain market conditions.\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\n    function createMarket(MarketParams memory marketParams) external;\n\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoSupply` function with the given `data`.\n    /// @dev Either `assets` or `shares` should be zero. Most usecases should rely on `assets` as an input so the caller\n    /// is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific amount\n    /// of shares is given for full compatibility and precision.\n    /// @dev If the supply of a market gets depleted, the supply share price instantly resets to\n    /// `VIRTUAL_ASSETS`:`VIRTUAL_SHARES`.\n    /// @dev Supplying a large amount can revert for overflow.\n    /// @param marketParams The market to supply assets to.\n    /// @param assets The amount of assets to supply.\n    /// @param shares The amount of shares to mint.\n    /// @param onBehalf The address that will own the increased supply position.\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\n    /// @return assetsSupplied The amount of assets supplied.\n    /// @return sharesSupplied The amount of shares minted.\n    function supply(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\n\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` to `receiver`.\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\n    /// conversion roundings between shares and assets.\n    /// @param marketParams The market to withdraw assets from.\n    /// @param assets The amount of assets to withdraw.\n    /// @param shares The amount of shares to burn.\n    /// @param onBehalf The address of the owner of the supply position.\n    /// @param receiver The address that will receive the withdrawn assets.\n    /// @return assetsWithdrawn The amount of assets withdrawn.\n    /// @return sharesWithdrawn The amount of shares burned.\n    function withdraw(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\n\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` to `receiver`.\n    /// @dev Either `assets` or `shares` should be zero. Most usecases should rely on `assets` as an input so the caller\n    /// is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is given for\n    /// full compatibility and precision.\n    /// @dev If the borrow of a market gets depleted, the borrow share price instantly resets to\n    /// `VIRTUAL_ASSETS`:`VIRTUAL_SHARES`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Borrowing a large amount can revert for overflow.\n    /// @param marketParams The market to borrow assets from.\n    /// @param assets The amount of assets to borrow.\n    /// @param shares The amount of shares to mint.\n    /// @param onBehalf The address that will own the increased borrow position.\n    /// @param receiver The address that will receive the borrowed assets.\n    /// @return assetsBorrowed The amount of assets borrowed.\n    /// @return sharesBorrowed The amount of shares minted.\n    function borrow(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\n\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoReplay` function with the given `data`.\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\n    /// roundings between shares and assets.\n    /// @param marketParams The market to repay assets to.\n    /// @param assets The amount of assets to repay.\n    /// @param shares The amount of shares to burn.\n    /// @param onBehalf The address of the owner of the debt position.\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\n    /// @return assetsRepaid The amount of assets repaid.\n    /// @return sharesRepaid The amount of shares burned.\n    function repay(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\n\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoSupplyCollateral` function with the given `data`.\n    /// @dev Interest are not accrued since it's not required and it saves gas.\n    /// @dev Supplying a large amount can revert for overflow.\n    /// @param marketParams The market to supply collateral to.\n    /// @param assets The amount of collateral to supply.\n    /// @param onBehalf The address that will own the increased collateral position.\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\n        external;\n\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` to `receiver`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\n    /// @param marketParams The market to withdraw collateral from.\n    /// @param assets The amount of collateral to withdraw.\n    /// @param onBehalf The address of the owner of the collateral position.\n    /// @param receiver The address that will receive the collateral assets.\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\n        external;\n\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\n    /// `onMorphoLiquidate` function with the given `data`.\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\n    /// @param marketParams The market of the position.\n    /// @param borrower The owner of the position.\n    /// @param seizedAssets The amount of collateral to seize.\n    /// @param repaidShares The amount of shares to repay.\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\n    /// @return The amount of assets seized.\n    /// @return The amount of assets repaid.\n    function liquidate(\n        MarketParams memory marketParams,\n        address borrower,\n        uint256 seizedAssets,\n        uint256 repaidShares,\n        bytes memory data\n    ) external returns (uint256, uint256);\n\n    /// @notice Executes a flash loan.\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\n    /// markets combined, plus donations).\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\n    /// - `flashFee` is zero.\n    /// - `maxFlashLoan` is the token's balance of this contract.\n    /// - The receiver of `assets` is the caller.\n    /// @param token The token to flash loan.\n    /// @param assets The amount of assets to flash loan.\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\n\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\n    /// @param authorized The authorized address.\n    /// @param newIsAuthorized The new authorization status.\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\n\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\n    /// @dev Warning: Reverts if the signature has already been submitted.\n    /// @dev The signature is malleable, but it has no impact on the security here.\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\n    /// @param authorization The `Authorization` struct.\n    /// @param signature The signature.\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\n\n    /// @notice Accrues interest for the given market `marketParams`.\n    function accrueInterest(MarketParams memory marketParams) external;\n\n    /// @notice Returns the data stored on the different `slots`.\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\n}\n\ninterface IMorphoStaticTyping is IMorphoBase {\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\n    /// accrual.\n    function position(Id id, address user)\n        external\n        view\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\n\n    /// @notice The state of the market corresponding to `id`.\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\n    /// accrual.\n    function market(Id id)\n        external\n        view\n        returns (\n            uint128 totalSupplyAssets,\n            uint128 totalSupplyShares,\n            uint128 totalBorrowAssets,\n            uint128 totalBorrowShares,\n            uint128 lastUpdate,\n            uint128 fee\n        );\n\n    /// @notice The market params corresponding to `id`.\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\n    function idToMarketParams(Id id)\n        external\n        view\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\n}\n\ninterface IMorphoBlue is IMorphoBase {\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\n    /// accrual.\n    function position(Id id, address user) external view returns (MorphoBluePosition memory p);\n\n    /// @notice The state of the market corresponding to `id`.\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\n    /// interest accrual.\n    function market(Id id) external view returns (Market memory m);\n\n    /// @notice The market params corresponding to `id`.\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\n}\n\n\n\n\n\nabstract contract IUniswapV3Factory {\n    function getPool(address token0, address token1, uint24 fee) external virtual view returns (address poolAddress);\n}\n\n\n\n\n\nabstract contract IUniswapV3Pool {\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        // the most-recently updated index of the observations array\n        uint16 observationIndex;\n        // the current maximum number of observations that are being stored\n        uint16 observationCardinality;\n        // the next maximum number of observations to store, triggered in observations.write\n        uint16 observationCardinalityNext;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n    }\n\n    function slot0() external virtual view returns (Slot0 memory);\n\n    function fee() external virtual view returns (uint24 fee);\n\n    function flash(address recipient, uint256 amount0, uint256 amount1, bytes memory data) external virtual;\n}\n\n\n\n\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n    \n    error ReentrantCall();\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        if (_status == _ENTERED){\n            revert ReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\n\n\n\nabstract contract IWETH {\n    function allowance(address, address) public virtual view returns (uint256);\n\n    function balanceOf(address) public virtual view returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool);\n\n    function deposit() public payable virtual;\n\n    function withdraw(uint256) public virtual;\n}\n\n\n\n\n\n\nlibrary TokenUtils {\n    using SafeERC20 for IERC20;\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Only approves the amount if allowance is lower than amount, does not decrease allowance\n    function approveToken(\n        address _tokenAddr,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_tokenAddr == ETH_ADDR) return;\n\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\n        }\n    }\n\n    function pullTokensIfNeeded(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // handle max uint amount\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, _from);\n        }\n\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        }\n\n        return _amount;\n    }\n\n    function withdrawTokens(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, address(this));\n        }\n\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\n            if (_token != ETH_ADDR) {\n                IERC20(_token).safeTransfer(_to, _amount);\n            } else {\n                (bool success, ) = _to.call{value: _amount}(\"\");\n                require(success, \"Eth send fail\");\n            }\n        }\n\n        return _amount;\n    }\n\n    function depositWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).deposit{value: _amount}();\n    }\n\n    function withdrawWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).withdraw(_amount);\n    }\n\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\n        if (_tokenAddr == ETH_ADDR) {\n            return _acc.balance;\n        } else {\n            return IERC20(_tokenAddr).balanceOf(_acc);\n        }\n    }\n\n    function getTokenDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return IERC20(_token).decimals();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract FLAction is ActionBase, ReentrancyGuard, IFlashLoanBase, StrategyModel, FLHelper {\n    using TokenUtils for address;\n\n    /// @dev FL Initiator must be this contract\n    error UntrustedInitiator();\n    /// @dev Caller in these functions must be relevant FL source address\n    error UntrustedLender();\n    // Wrong FL payback amount sent\n    error WrongPaybackAmountError();\n    // When FL source is not found\n    error NonexistentFLSource();\n    // Revert if execution fails when using safe wallet\n    error SafeExecutionError();\n\n    enum FLSource {\n        EMPTY,\n        AAVEV2,\n        BALANCER,\n        GHO,\n        MAKER,\n        AAVEV3,\n        UNIV3,\n        SPARK,\n        MORPHO_BLUE\n    }\n\n    /// @dev Function sig of RecipeExecutor._executeActionsFromFL()\n    bytes4 public constant CALLBACK_SELECTOR =\n        bytes4(\n            keccak256(\n                \"_executeActionsFromFL((string,bytes[],bytes32[],bytes4[],uint8[][]),bytes32)\"\n            )\n        );\n\n    /// @inheritdoc ActionBase\n    function actionType() public pure override returns (uint8) {\n        return uint8(ActionType.FL_ACTION);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    function executeActionDirect(bytes memory _callData) public payable override {}\n\n    /// @inheritdoc ActionBase\n    /// @notice This action doesn't use flParamGetterAddr and flParamGetterData\n    /// @notice flParamGetterData is used to choose between FL providers\n    function executeAction(\n        bytes memory _callData,\n        bytes32[] memory,\n        uint8[] memory,\n        bytes32[] memory\n    ) public payable override returns (bytes32) {\n        FlashLoanParams memory params = abi.decode(_callData, (FlashLoanParams));\n        FLSource flSource = FLSource(uint8(bytes1(params.flParamGetterData)));\n\n        handleFlashloan(params, flSource);\n\n        return bytes32(params.amounts[0]);\n    }\n\n    function handleFlashloan(FlashLoanParams memory _flParams, FLSource _source) internal {\n        if (_source == FLSource.AAVEV2) {\n            _flAaveV2(_flParams);\n        } else if (_source == FLSource.BALANCER) {\n            _flBalancer(_flParams);\n        } else if (_source == FLSource.GHO) {\n            _flGho(_flParams);\n        } else if (_source == FLSource.MAKER) {\n            _flMaker(_flParams);\n        } else if (_source == FLSource.AAVEV3) {\n            _flAaveV3(_flParams);\n        } else if (_source == FLSource.UNIV3) {\n            _flUniV3(_flParams);\n        } else if (_source == FLSource.SPARK) {\n            _flSpark(_flParams);\n        } else if (_source == FLSource.MORPHO_BLUE) {\n            _flMorphoBlue(_flParams);\n        } else {\n            revert NonexistentFLSource();\n        }\n    }\n\n    /// @notice Gets a Fl from Aave and returns back the execution to the action address\n    /// @param _flParams All the amounts/tokens and related aave fl data\n    function _flAaveV2(FlashLoanParams memory _flParams) internal {\n        ILendingPoolV2(AAVE_LENDING_POOL).flashLoan(\n            address(this),\n            _flParams.tokens,\n            _flParams.amounts,\n            _flParams.modes,\n            _flParams.onBehalfOf,\n            _flParams.recipeData,\n            AAVE_REFERRAL_CODE\n        );\n\n        emit ActionEvent(\n            \"FLAction\",\n            abi.encode(\n                \"AAVEV2\",\n                _flParams.tokens,\n                _flParams.amounts,\n                _flParams.modes,\n                _flParams.onBehalfOf\n            )\n        );\n    }\n\n    /// @notice Gets a Fl from Aave V3 and returns back the execution to the action address\n    /// @param _flParams All the amounts/tokens and related aave fl data\n    function _flAaveV3(FlashLoanParams memory _flParams) internal {\n        ILendingPoolV2(AAVE_V3_LENDING_POOL).flashLoan(\n            address(this),\n            _flParams.tokens,\n            _flParams.amounts,\n            _flParams.modes,\n            _flParams.onBehalfOf,\n            _flParams.recipeData,\n            AAVE_REFERRAL_CODE\n        );\n\n        emit ActionEvent(\n            \"FLAction\",\n            abi.encode(\n                \"AAVEV3\",\n                _flParams.tokens,\n                _flParams.amounts,\n                _flParams.modes,\n                _flParams.onBehalfOf\n            )\n        );\n    }\n\n    /// @notice Gets a FL from Balancer and returns back the execution to the action address\n    function _flBalancer(FlashLoanParams memory _flParams) internal {\n        IFlashLoans(VAULT_ADDR).flashLoan(\n            address(this),\n            _flParams.tokens,\n            _flParams.amounts,\n            _flParams.recipeData\n        );\n\n        emit ActionEvent(\"FLAction\", abi.encode(\"BALANCER\", _flParams));\n    }\n\n    /// @notice Gets a GHO FL from Gho Flash Minter\n    function _flGho(FlashLoanParams memory _flParams) internal {\n        IERC3156FlashLender(GHO_FLASH_MINTER_ADDR).flashLoan(\n            IERC3156FlashBorrower(address(this)),\n            GHO_ADDR,\n            _flParams.amounts[0],\n            _flParams.recipeData\n        );\n\n        emit ActionEvent(\"FLAction\", abi.encode(\"GHO\", _flParams.amounts[0]));\n    }\n\n    /// @notice Gets a DAI flash loan from Maker and returns back the execution to the action address\n    /// @param _flParams All the amounts/tokens and related aave fl data\n    function _flMaker(FlashLoanParams memory _flParams) internal {\n        IERC3156FlashLender(DSS_FLASH_ADDR).flashLoan(\n            IERC3156FlashBorrower(address(this)),\n            DAI_ADDR,\n            _flParams.amounts[0],\n            _flParams.recipeData\n        );\n\n        emit ActionEvent(\"FLAction\", abi.encode(\"MAKER\", _flParams.amounts[0]));\n    }\n\n    function _flUniV3(FlashLoanParams memory _flParams) internal {\n        // modes aren't used so we set them to later know starting balances\n        _flParams.modes = new uint256[](2);\n        _flParams.modes[0] = _flParams.amounts[0] > 0 ? _flParams.tokens[0].getBalance(address(this)) : 0;\n        _flParams.modes[1] = _flParams.amounts[1] > 0 ? _flParams.tokens[1].getBalance(address(this)) : 0;\n\n        /// @dev FlashLoanParams.tokens, first two array indexes contain tokens, third index contains pool address\n        IUniswapV3Pool(_flParams.tokens[2]).flash(\n            address(this),\n            _flParams.amounts[0],\n            _flParams.amounts[1],\n            abi.encode(_flParams)\n        );\n\n        emit ActionEvent(\"FLAction\", abi.encode(\"UNIV3\", _flParams.amounts[0]));\n    }\n\n    /// @notice Gets a Fl from Spark and returns back the execution to the action address\n    function _flSpark(FlashLoanParams memory _flParams) internal {\n\n        ILendingPoolV2(SPARK_LENDING_POOL).flashLoan(\n            address(this),\n            _flParams.tokens,\n            _flParams.amounts,\n            _flParams.modes,\n            _flParams.onBehalfOf,\n            _flParams.recipeData,\n            SPARK_REFERRAL_CODE\n        );\n\n        emit ActionEvent(\"FLAction\", abi.encode(\"SPARK\", _flParams.amounts[0]));\n    }\n\n    /// @notice Gets a FL from Morpho blue and returns back the execution to the action address\n    function _flMorphoBlue(FlashLoanParams memory _params) internal {\n        IMorphoBlue(MORPHO_BLUE_ADDR).flashLoan(\n            _params.tokens[0],\n            _params.amounts[0],\n            abi.encode(_params.recipeData, _params.tokens[0])\n        );\n\n        emit ActionEvent(\"FLAction\", abi.encode(\"MORPHOBLUE\", _params.amounts[0]));\n    }\n\n    /// @notice Aave callback function that formats and calls back RecipeExecutor\n    /// FLSource == AAVE | SPARK\n    function executeOperation(\n        address[] memory _assets,\n        uint256[] memory _amounts,\n        uint256[] memory _fees,\n        address _initiator,\n        bytes memory _params\n    ) public nonReentrant returns (bool) {\n        if (msg.sender != AAVE_LENDING_POOL && msg.sender != AAVE_V3_LENDING_POOL && msg.sender != SPARK_LENDING_POOL) {\n            revert UntrustedLender();\n        }\n        if (_initiator != address(this)) {\n            revert UntrustedInitiator();\n        }\n\n        (Recipe memory currRecipe, address wallet) = abi.decode(_params, (Recipe, address));\n        uint256[] memory balancesBefore = new uint256[](_assets.length);\n        // Send FL amounts to user wallet\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            _assets[i].withdrawTokens(wallet, _amounts[i]);\n            balancesBefore[i] = _assets[i].getBalance(address(this));\n        }\n\n        _executeRecipe(wallet, currRecipe, _amounts[0] + _fees[0]);\n\n        // return FL\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 paybackAmount = _amounts[i] + _fees[i];\n            bool correctAmount = _assets[i].getBalance(address(this)) ==\n                paybackAmount + balancesBefore[i];\n\n            if (_assets[i] == ST_ETH_ADDR && !correctAmount) {\n                flFeeFaucet.my2Wei(ST_ETH_ADDR);\n                correctAmount = true;\n            }\n            if (!correctAmount) {\n                revert WrongPaybackAmountError();\n            }\n\n            _assets[i].approveToken(address(msg.sender), paybackAmount);\n        }\n\n        return true;\n    }\n\n    /// @notice Balancer FL callback function that formats and calls back RecipeExecutor\n    /// FLSource == BALANCER\n    function receiveFlashLoan(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _feeAmounts,\n        bytes memory _userData\n    ) external nonReentrant {\n        if (msg.sender != VAULT_ADDR) {\n            revert UntrustedLender();\n        }\n        (Recipe memory currRecipe, address wallet) = abi.decode(_userData, (Recipe, address));\n\n        uint256[] memory balancesBefore = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].withdrawTokens(wallet, _amounts[i]);\n            balancesBefore[i] = _tokens[i].getBalance(address(this));\n        }\n\n        _executeRecipe(wallet, currRecipe, _amounts[0] + _feeAmounts[0]);\n        \n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 paybackAmount = _amounts[i] + (_feeAmounts[i]);\n\n            if (_tokens[i].getBalance(address(this)) != paybackAmount + balancesBefore[i]) {\n                revert WrongPaybackAmountError();\n            }\n\n            _tokens[i].withdrawTokens(address(VAULT_ADDR), paybackAmount);\n        }\n    }\n\n    /// @notice ERC3156 callback function that formats and calls back RecipeExecutor\n    /// FLSource == MAKER | GHO\n    function onFlashLoan(\n        address _initiator,\n        address _token,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _data\n    ) external nonReentrant returns (bytes32) {\n        if (msg.sender != DSS_FLASH_ADDR && msg.sender != GHO_FLASH_MINTER_ADDR) {\n            revert UntrustedLender();\n        }\n        if (_initiator != address(this)) {\n            revert UntrustedInitiator();\n        }\n\n        (Recipe memory currRecipe, address wallet) = abi.decode(_data, (Recipe, address));\n        _token.withdrawTokens(wallet, _amount);\n        uint256 balanceBefore = _token.getBalance(address(this));\n\n        uint256 paybackAmount = _amount +_fee;\n\n        _executeRecipe(wallet, currRecipe, paybackAmount);\n\n        if (_token.getBalance(address(this)) != paybackAmount + balanceBefore) {\n            revert WrongPaybackAmountError();\n        }\n\n        _token.approveToken(msg.sender, paybackAmount);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function uniswapV3FlashCallback(\n        uint256 _fee0,\n        uint256 _fee1,\n        bytes memory _params\n    ) external nonReentrant {\n        FlashLoanParams memory params = abi.decode(_params, (FlashLoanParams));\n        {\n            uint24 fee = IUniswapV3Pool(msg.sender).fee();\n            address realPool = IUniswapV3Factory(UNI_V3_FACTORY).getPool(params.tokens[0], params.tokens[1], uint24(fee));\n            if (msg.sender != realPool) revert UntrustedLender();\n        }\n\n        (Recipe memory currRecipe, address wallet) = abi.decode(params.recipeData, (Recipe, address));\n\n        params.tokens[0].withdrawTokens(wallet, params.amounts[0]);\n        params.tokens[1].withdrawTokens(wallet, params.amounts[1]);\n\n        _executeRecipe(wallet, currRecipe, params.amounts[0]);\n\n        uint256 expectedBalance0 = params.modes[0] + params.amounts[0] + _fee0;\n        uint256 expectedBalance1 = params.modes[1] + params.amounts[1] + _fee1;\n\n        uint256 currBalance0 = params.amounts[0] > 0 ? params.tokens[0].getBalance(address(this)) : 0;\n        uint256 currBalance1 = params.amounts[1] > 0 ? params.tokens[1].getBalance(address(this)) : 0;\n\n        bool isCorrectAmount0 = currBalance0 == expectedBalance0;\n        bool isCorrectAmount1 = currBalance1 == expectedBalance1;\n\n        if (params.amounts[0] > 0 && params.tokens[0] == ST_ETH_ADDR && !isCorrectAmount0) {\n            flFeeFaucet.my2Wei(ST_ETH_ADDR);\n            isCorrectAmount0 = true;\n        }\n        if (params.amounts[1] > 0 && params.tokens[1] == ST_ETH_ADDR && !isCorrectAmount1) {\n            flFeeFaucet.my2Wei(ST_ETH_ADDR);\n            isCorrectAmount1 = true;\n        }\n\n        if (!isCorrectAmount0) revert WrongPaybackAmountError();\n        if (!isCorrectAmount1) revert WrongPaybackAmountError();\n\n        params.tokens[0].withdrawTokens(msg.sender, params.amounts[0] + _fee0);\n        params.tokens[1].withdrawTokens(msg.sender, params.amounts[1] + _fee1);\n    }\n\n    function onMorphoFlashLoan(uint256 assets, bytes calldata data) external nonReentrant{\n        if (msg.sender != MORPHO_BLUE_ADDR) {\n            revert UntrustedLender();\n        }\n        (bytes memory taskData, address token) = abi.decode(data, (bytes, address));\n        (Recipe memory currRecipe, address wallet) = abi.decode(taskData, (Recipe, address));\n\n        token.withdrawTokens(wallet, assets);\n\n        uint256 balanceBefore = token.getBalance(address(this));\n\n        _executeRecipe(wallet, currRecipe, assets);\n\n        if (token.getBalance(address(this)) != assets + balanceBefore) {\n            revert WrongPaybackAmountError();\n        }\n\n        token.approveToken(MORPHO_BLUE_ADDR, assets);\n    }\n\n    function _executeRecipe(address _wallet, Recipe memory _currRecipe, uint256 _paybackAmount) internal {\n        if (isDSProxy(_wallet)) {\n            IDSProxy(_wallet).execute{value: address(this).balance}(\n                RECIPE_EXECUTOR_ADDR,\n                abi.encodeWithSelector(CALLBACK_SELECTOR, _currRecipe, _paybackAmount)\n            );\n        } else {\n            bool success = ISafe(_wallet).execTransactionFromModule(\n                RECIPE_EXECUTOR_ADDR,\n                address(this).balance,\n                abi.encodeWithSelector(CALLBACK_SELECTOR, _currRecipe, _paybackAmount),\n                ISafe.Operation.DelegateCall\n            );\n\n            if (!success) {\n                revert SafeExecutionError();\n             }\n        }\n    }\n}\n", "ABI": "[{\"inputs\":[],\"name\":\"NonContractCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonexistentFLSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReturnIndexValueError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeExecutionError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubIndexValueError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UntrustedInitiator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UntrustedLender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongPaybackAmountError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"logName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ActionEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALLBACK_SELECTOR\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NO_PARAM_MAPPING\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RETURN_MAX_INDEX_VALUE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RETURN_MIN_INDEX_VALUE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUB_MAX_INDEX_VALUE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUB_MIN_INDEX_VALUE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"actionType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminVault\",\"outputs\":[{\"internalType\":\"contract AdminVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"executeAction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"executeActionDirect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fees\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flFeeFaucet\",\"outputs\":[{\"internalType\":\"contract FLFeeFaucet\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"isDSProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logger\",\"outputs\":[{\"internalType\":\"contract DefisaverLogger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onMorphoFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract DFSRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FLAction", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}