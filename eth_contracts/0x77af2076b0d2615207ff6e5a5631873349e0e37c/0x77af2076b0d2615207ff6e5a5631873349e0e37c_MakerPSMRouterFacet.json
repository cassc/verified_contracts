{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/facets/MakerPSMRouterFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// Interfaces\\nimport { IERC20 } from \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport { IMakerPSMRouter } from \\\"../interfaces/IMakerPSMRouter.sol\\\";\\n\\n// Libraries\\nimport { ERC20Utils } from \\\"../libraries/ERC20Utils.sol\\\";\\n\\n// Types\\nimport { MakerPSMData } from \\\"../AugustusV6Types.sol\\\";\\n\\n// Contracts\\nimport { MakerPSMUtils } from \\\"../util/MakerPSMUtils.sol\\\";\\nimport { Permit2Utils } from \\\"../util/Permit2Utils.sol\\\";\\n\\n/// @title MakerPSMRouter\\n/// @notice A facet for executing direct MakerPSM swaps\\ncontract MakerPSMRouterFacet is IMakerPSMRouter, MakerPSMUtils, Permit2Utils {\\n    /*//////////////////////////////////////////////////////////////\\n                               LIBRARIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    using ERC20Utils for IERC20;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _daiMaker, address _permit2) MakerPSMUtils(_daiMaker) Permit2Utils(_permit2) { }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        SWAP EXACT AMOUNT IN/OUT\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IMakerPSMRouter\\n    function swapExactAmountInOutOnMakerPSM(\\n        MakerPSMData calldata makerPSMData,\\n        bytes calldata permit\\n    )\\n        external\\n        returns (uint256 spentAmount, uint256 receivedAmount)\\n    {\\n        // Dereference makerPSMData\\n        IERC20 srcToken = makerPSMData.srcToken;\\n        uint256 toll = makerPSMData.toll;\\n        uint256 to18ConversionFactor = makerPSMData.to18ConversionFactor;\\n        address gemJoinAddress = makerPSMData.gemJoinAddress;\\n        address exchange = makerPSMData.exchange;\\n        uint256 fromAmount = makerPSMData.fromAmount;\\n        uint256 toAmount = makerPSMData.toAmount;\\n        uint256 beneficiaryDirectionApproveFlag = makerPSMData.beneficiaryDirectionApproveFlag;\\n\\n        // Decode params\\n        address beneficiary;\\n        bool approve;\\n        bool direction;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            // Parse beneficiaryDirectionApproveFlag\\n            beneficiary := and(beneficiaryDirectionApproveFlag, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n            approve := shr(255, beneficiaryDirectionApproveFlag)\\n            direction := and(1, shr(254, beneficiaryDirectionApproveFlag))\\n        }\\n\\n        // Get swap type\\n        uint256 swapType;\\n        address dai = DAI_MAKER;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            swapType := 0x1 // sellGem(address,uint256)\\n            if eq(srcToken, dai) { swapType := 0x0 } // buyGem(address,uint256)\\n        }\\n\\n        // Check if beneficiary is valid\\n        if (beneficiary == address(0)) {\\n            beneficiary = msg.sender;\\n        }\\n\\n        // Check if toAmount is valid\\n        if (toAmount == 0) {\\n            revert InvalidToAmount();\\n        }\\n\\n        // Check the length of the permit field,\\n        // if < 257 and > 0 we should execute regular permit\\n        // and if it is >= 257 we execute permit2\\n        if (permit.length < 257) {\\n            // Permit if needed\\n            if (permit.length > 0) {\\n                srcToken.permit(permit);\\n            }\\n            srcToken.safeTransferFrom(msg.sender, address(this), fromAmount);\\n        } else {\\n            // Otherwise Permit2.permitTransferFrom\\n            permit2TransferFrom(permit, address(this), fromAmount);\\n        }\\n        // Check if approve is needed\\n        if (approve) {\\n            if (address(srcToken) == DAI_MAKER) {\\n                // Approve exchange\\n                srcToken.approve(exchange);\\n            } else {\\n                // Approve gemJoinAddress\\n                srcToken.approve(gemJoinAddress);\\n            }\\n        }\\n\\n        // Execute swapExactAmountIn or swapExactAmountOut based on direction\\n        if (!direction) {\\n            // Execute swapExactAmountIn on Maker PSM\\n            _executeSwapExactAmountInOnMakerPSM(\\n                exchange, swapType, toll, to18ConversionFactor, fromAmount, beneficiary\\n            );\\n            // Return spentAmount and receivedAmount\\n            return (fromAmount, toAmount);\\n        } else {\\n            // Execute swapExactAmountOut on Maker PSM\\n            _executeSwapExactAmountOutOnMakerPSM(exchange, swapType, toll, to18ConversionFactor, toAmount, beneficiary);\\n            // Check remaining balance of srcToken\\n            uint256 remainingAmount = srcToken.balanceOf(address(this));\\n            // Transfer remaining balance to msg.sender\\n            if (remainingAmount > 1) {\\n                srcToken.safeTransfer(msg.sender, --remainingAmount);\\n            }\\n            // Return spentAmount and receivedAmount\\n            return (fromAmount - remainingAmount, toAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMakerPSMRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// Interfaces\\nimport { IErrors } from \\\"./IErrors.sol\\\";\\n\\n// Types\\nimport { MakerPSMData } from \\\"../AugustusV6Types.sol\\\";\\n\\n/// @title IMakerPSMRouter\\n/// @notice Interface for direct swaps on MakerPSM\\ninterface IMakerPSMRouter is IErrors {\\n    /*//////////////////////////////////////////////////////////////\\n                          SWAP EXACT AMOUNT IN\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Executes a swapExactAmountIn or swapExactAmountOut on Maker PSM\\n    /// @param makerPSMData Struct containing data for the swap\\n    /// @param permit Permit data for the swap\\n    /// @return spentAmount The amount of tokens spent\\n    /// @return receivedAmount The amount of tokens received\\n    function swapExactAmountInOutOnMakerPSM(\\n        MakerPSMData calldata makerPSMData,\\n        bytes calldata permit\\n    )\\n        external\\n        returns (uint256 spentAmount, uint256 receivedAmount);\\n}\\n\"\r\n    },\r\n    \"src/libraries/ERC20Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// Interfaces\\nimport { IERC20 } from \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/// @title ERC20Utils\\n/// @notice Optimized functions for ERC20 tokens\\nlibrary ERC20Utils {\\n    /*//////////////////////////////////////////////////////////////\\n                                ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error IncorrectEthAmount();\\n    error PermitFailed();\\n    error TransferFromFailed();\\n    error TransferFailed();\\n    error ApprovalFailed();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    IERC20 internal constant ETH = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                APPROVE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Vendored from Solady by @vectorized - SafeTransferLib.approveWithRetry\\n    /// https://github.com/Vectorized/solady/src/utils/SafeTransferLib.sol#L325\\n    /// Instead of approving a specific amount, this function approves for uint256(-1) (type(uint256).max).\\n    function approve(IERC20 token, address to) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) // Store the `amount`\\n                // argument (type(uint256).max).\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) // Store\\n                    // type(uint256).max for the `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0, 0x8164f84200000000000000000000000000000000000000000000000000000000)\\n                    // store the selector (error ApprovalFailed())\\n                    revert(0, 4) // revert with error selector\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                PERMIT\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Executes an ERC20 permit and reverts if invalid length is provided\\n    function permit(IERC20 token, bytes calldata data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            // check the permit length\\n            switch data.length\\n            // 32 * 7 = 224 EIP2612 Permit\\n            case 224 {\\n                let x := mload(64) // get the free memory pointer\\n                mstore(x, 0xd505accf00000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // function permit(address owner, address spender, uint256\\n                    // amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                calldatacopy(add(x, 4), data.offset, 224) // store the args\\n                pop(call(gas(), token, 0, x, 228, 0, 32)) // call ERC20 permit, skip checking return data\\n            }\\n            // 32 * 8 = 256 DAI-Style Permit\\n            case 256 {\\n                let x := mload(64) // get the free memory pointer\\n                mstore(x, 0x8fcbaf0c00000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // function permit(address holder, address spender, uint256\\n                    // nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                calldatacopy(add(x, 4), data.offset, 256) // store the args\\n                pop(call(gas(), token, 0, x, 260, 0, 32)) // call ERC20 permit, skip checking return data\\n            }\\n            default {\\n                mstore(0, 0xb78cb0dd00000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // (error PermitFailed())\\n                revert(0, 4)\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ETH\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Returns 1 if the token is ETH, 0 if not ETH\\n    function isETH(IERC20 token, uint256 amount) internal view returns (uint256 fromETH) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            // If token is ETH\\n            if eq(token, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n                // if msg.value is not equal to fromAmount, then revert\\n                if xor(amount, callvalue()) {\\n                    mstore(0, 0x8b6ebb4d00000000000000000000000000000000000000000000000000000000) // store the selector\\n                        // (error IncorrectEthAmount())\\n                    revert(0, 4) // revert with error selector\\n                }\\n                // return 1 if ETH\\n                fromETH := 1\\n            }\\n            // If token is not ETH\\n            if xor(token, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n                // if msg.value is not equal to 0, then revert\\n                if gt(callvalue(), 0) {\\n                    mstore(0, 0x8b6ebb4d00000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // (error IncorrectEthAmount())\\n                    revert(0, 4) // revert with error selector\\n                }\\n            }\\n        }\\n        // return 0 if not ETH\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                TRANSFER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Executes transfer and reverts if it fails, works for both ETH and ERC20 transfers\\n    function safeTransfer(IERC20 token, address recipient, uint256 amount) internal returns (bool success) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            switch eq(token, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\n            // ETH\\n            case 1 {\\n                // transfer ETH\\n                // Cap gas at 10000 to avoid reentrancy\\n                success := call(10000, recipient, amount, 0, 0, 0, 0)\\n            }\\n            // ERC20\\n            default {\\n                let x := mload(64) // get the free memory pointer\\n                mstore(x, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // (function transfer(address recipient, uint256 amount))\\n                mstore(add(x, 4), recipient) // store the recipient\\n                mstore(add(x, 36), amount) // store the amount\\n                success := call(gas(), token, 0, x, 68, 0, 32) // call transfer\\n                if success {\\n                    switch returndatasize()\\n                    // check the return data size\\n                    case 0 { success := gt(extcodesize(token), 0) }\\n                    default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }\\n                }\\n            }\\n            if iszero(success) {\\n                mstore(0, 0x90b8ec1800000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // (error TransferFailed())\\n                revert(0, 4) // revert with error selector\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             TRANSFER FROM\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Executes transferFrom and reverts if it fails\\n    function safeTransferFrom(\\n        IERC20 srcToken,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    )\\n        internal\\n        returns (bool success)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let x := mload(64) // get the free memory pointer\\n            mstore(x, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // store the selector\\n                // (function transferFrom(address sender, address recipient,\\n                // uint256 amount))\\n            mstore(add(x, 4), sender) // store the sender\\n            mstore(add(x, 36), recipient) // store the recipient\\n            mstore(add(x, 68), amount) // store the amount\\n            success := call(gas(), srcToken, 0, x, 100, 0, 32) // call transferFrom\\n            if success {\\n                switch returndatasize()\\n                // check the return data size\\n                case 0 { success := gt(extcodesize(srcToken), 0) }\\n                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }\\n            }\\n            if iszero(success) {\\n                mstore(x, 0x7939f42400000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // (error TransferFromFailed())\\n                revert(x, 4) // revert with error selector\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                BALANCE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Returns the balance of an account, works for both ETH and ERC20 tokens\\n    function getBalance(IERC20 token, address account) internal view returns (uint256 balanceOf) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            switch eq(token, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\n            // ETH\\n            case 1 { balanceOf := balance(account) }\\n            // ERC20\\n            default {\\n                let x := mload(64) // get the free memory pointer\\n                mstore(x, 0x70a0823100000000000000000000000000000000000000000000000000000000) // store the selector\\n                    // (function balanceOf(address account))\\n                mstore(add(x, 4), account) // store the account\\n                let success := staticcall(gas(), token, x, 36, x, 32) // call balanceOf\\n                if success { balanceOf := mload(x) } // load the balance\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/AugustusV6Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// Interfaces\\nimport { IERC20 } from \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/*//////////////////////////////////////////////////////////////\\n                        GENERIC SWAP DATA\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct containg data for generic swapExactAmountIn/swapExactAmountOut\\n/// @param srcToken The token to swap from\\n/// @param destToken The token to swap to\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount of destToken to receive\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param quotedAmount The quoted expected amount of destToken/srcToken\\n/// = quotedAmountOut for swapExactAmountIn and quotedAmountIn for swapExactAmountOut\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiary The address to send the swapped tokens to\\nstruct GenericData {\\n    IERC20 srcToken;\\n    IERC20 destToken;\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 quotedAmount;\\n    bytes32 metadata;\\n    address payable beneficiary;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            UNISWAPV2\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for UniswapV2 swapExactAmountIn/swapExactAmountOut data\\n/// @param srcToken The token to swap from\\n/// @param destToken The token to swap to\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param quotedAmount The quoted expected amount of destToken/srcToken\\n/// = quotedAmountOut for swapExactAmountIn and quotedAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount of destToken to receive\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiary The address to send the swapped tokens to\\n/// @param pools data consisting of concatenated token0 and token1 address for each pool with the direction flag being\\n/// the right most bit of the packed token0-token1 pair bytes used in the path\\nstruct UniswapV2Data {\\n    IERC20 srcToken;\\n    IERC20 destToken;\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 quotedAmount;\\n    bytes32 metadata;\\n    address payable beneficiary;\\n    bytes pools;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            UNISWAPV3\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for UniswapV3 swapExactAmountIn/swapExactAmountOut data\\n/// @param srcToken The token to swap from\\n/// @param destToken The token to swap to\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param quotedAmount The quoted expected amount of destToken/srcToken\\n/// = quotedAmountOut for swapExactAmountIn and quotedAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount of destToken to receive\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiary The address to send the swapped tokens to\\n/// @param pools data consisting of concatenated token0-\\n/// token1-fee bytes for each pool used in the path, with the direction flag being the left most bit of token0 in the\\n/// concatenated bytes\\nstruct UniswapV3Data {\\n    IERC20 srcToken;\\n    IERC20 destToken;\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 quotedAmount;\\n    bytes32 metadata;\\n    address payable beneficiary;\\n    bytes pools;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            CURVE V1\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for CurveV1 swapExactAmountIn data\\n/// @param curveData Packed data for the Curve pool, first 160 bits is the target exchange address,\\n/// the 161st bit is the approve flag, bits from (162 - 163) are used for the wrap flag,\\n//// bits from (164 - 165) are used for the swapType flag and the last 91 bits are unused:\\n/// Approve Flag - a) 0 -> do not approve b) 1 -> approve\\n/// Wrap Flag - a) 0 -> do not wrap b) 1 -> wrap native & srcToken == eth\\n/// c) 2 -> unwrap and destToken == eth d) 3 - >srcToken == eth && do not wrap\\n/// Swap Type Flag -  a) 0 -> EXCHANGE b) 1 -> EXCHANGE_UNDERLYING\\n/// @param curveAssets Packed uint128 index i and uint128 index j of the pool\\n/// The first 128 bits is the index i and the second 128 bits is the index j\\n/// @param srcToken The token to swap from\\n/// @param destToken The token to swap to\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount that must be recieved\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param quotedAmount The expected amount of destToken to be recieved\\n/// = quotedAmountOut for swapExactAmountIn and quotedAmountIn for swapExactAmountOut\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiary The address to send the swapped tokens to\\nstruct CurveV1Data {\\n    uint256 curveData;\\n    uint256 curveAssets;\\n    IERC20 srcToken;\\n    IERC20 destToken;\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 quotedAmount;\\n    bytes32 metadata;\\n    address payable beneficiary;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            CURVE V2\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for CurveV2 swapExactAmountIn data\\n/// @param curveData Packed data for the Curve pool, first 160 bits is the target exchange address,\\n/// the 161st bit is the approve flag, bits from (162 - 163) are used for the wrap flag,\\n//// bits from (164 - 165) are used for the swapType flag and the last 91 bits are unused\\n/// Approve Flag - a) 0 -> do not approve b) 1 -> approve\\n/// Approve Flag - a) 0 -> do not approve b) 1 -> approve\\n/// Wrap Flag - a) 0 -> do not wrap b) 1 -> wrap native & srcToken == eth\\n/// c) 2 -> unwrap and destToken == eth d) 3 - >srcToken == eth && do not wrap\\n/// Swap Type Flag -  a) 0 -> EXCHANGE b) 1 -> EXCHANGE_UNDERLYING c) 2 -> EXCHANGE_UNDERLYING_FACTORY_ZAP\\n/// @param i The index of the srcToken\\n/// @param j The index of the destToken\\n/// The first 128 bits is the index i and the second 128 bits is the index j\\n/// @param poolAddress The address of the CurveV2 pool (only used for EXCHANGE_UNDERLYING_FACTORY_ZAP)\\n/// @param srcToken The token to swap from\\n/// @param destToken The token to swap to\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount that must be recieved\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param quotedAmount The expected amount of destToken to be recieved\\n/// = quotedAmountOut for swapExactAmountIn and quotedAmountIn for swapExactAmountOut\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiary The address to send the swapped tokens to\\nstruct CurveV2Data {\\n    uint256 curveData;\\n    uint256 i;\\n    uint256 j;\\n    address poolAddress;\\n    IERC20 srcToken;\\n    IERC20 destToken;\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 quotedAmount;\\n    bytes32 metadata;\\n    address payable beneficiary;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            BALANCER V2\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for BalancerV2 swapExactAmountIn data\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount of destToken to receive\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param quotedAmount The quoted expected amount of destToken/srcToken\\n/// = quotedAmountOut for swapExactAmountIn and quotedAmountIn for swapExactAmountOut\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiaryAndApproveFlag The beneficiary address and approve flag packed into one uint256,\\n/// the first 20 bytes are the beneficiary address and the left most bit is the approve flag\\nstruct BalancerV2Data {\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 quotedAmount;\\n    bytes32 metadata;\\n    uint256 beneficiaryAndApproveFlag;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            MAKERPSM\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for Maker PSM swapExactAmountIn data\\n/// @param srcToken The token to swap from\\n/// @param destToken The token to swap to\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount of destToken to receive\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param toll Used to calculate gem amount for the swapExactAmountIn\\n/// @param to18ConversionFactor Used to calculate gem amount for the swapExactAmountIn\\n/// @param gemJoinAddress The address of the gemJoin contract\\n/// @param exchange The address of the exchange contract\\n/// @param metadata Packed uuid and additional metadata\\n/// @param beneficiaryDirectionApproveFlag The beneficiary address, swap direction and approve flag packed\\n/// into one uint256, the first 20 bytes are the beneficiary address, the left most bit is the approve flag and the\\n/// second left most bit is the swap direction flag, 0 for swapExactAmountIn and 1 for swapExactAmountOut\\nstruct MakerPSMData {\\n    IERC20 srcToken;\\n    IERC20 destToken;\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint256 toll;\\n    uint256 to18ConversionFactor;\\n    address exchange;\\n    address gemJoinAddress;\\n    bytes32 metadata;\\n    uint256 beneficiaryDirectionApproveFlag;\\n}\\n\\n/*//////////////////////////////////////////////////////////////\\n                            AUGUSTUS RFQ\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Order struct for Augustus RFQ\\n/// @param nonceAndMeta The nonce and meta data packed into one uint256,\\n/// the first 160 bits is the user address and the last 96 bits is the nonce\\n/// @param expiry The expiry of the order\\n/// @param makerAsset The address of the maker asset\\n/// @param takerAsset The address of the taker asset\\n/// @param maker The address of the maker\\n/// @param taker The address of the taker, if the taker is address(0) anyone can take the order\\n/// @param makerAmount The amount of makerAsset\\n/// @param takerAmount The amount of takerAsset\\nstruct Order {\\n    uint256 nonceAndMeta;\\n    uint128 expiry;\\n    address makerAsset;\\n    address takerAsset;\\n    address maker;\\n    address taker;\\n    uint256 makerAmount;\\n    uint256 takerAmount;\\n}\\n\\n/// @notice Struct containing order info for Augustus RFQ\\n/// @param order The order struct\\n/// @param signature The signature for the order\\n/// @param takerTokenFillAmount The amount of takerToken to fill\\n/// @param permitTakerAsset The permit data for the taker asset\\n/// @param permitMakerAsset The permit data for the maker asset\\nstruct OrderInfo {\\n    Order order;\\n    bytes signature;\\n    uint256 takerTokenFillAmount;\\n    bytes permitTakerAsset;\\n    bytes permitMakerAsset;\\n}\\n\\n/// @notice Struct containing common data for executing swaps on Augustus RFQ\\n/// @param fromAmount The amount of srcToken to swap\\n/// = amountIn for swapExactAmountIn and maxAmountIn for swapExactAmountOut\\n/// @param toAmount The minimum amount of destToken to receive\\n/// = minAmountOut for swapExactAmountIn and amountOut for swapExactAmountOut\\n/// @param wrapApproveDirection The wrap, approve and direction flag packed into one uint8,\\n/// the first 2 bits is wrap flag (10 for wrap dest, 01 for wrap src, 00 for no wrap), the next bit is the approve flag\\n/// (1 for approve, 0 for no approve) and the last bit is the direction flag (0 for swapExactAmountIn and 1 for\\n/// swapExactAmountOut)\\n/// @param metadata Packed uuid and additional metadata\\nstruct AugustusRFQData {\\n    uint256 fromAmount;\\n    uint256 toAmount;\\n    uint8 wrapApproveDirection;\\n    bytes32 metadata;\\n    address payable beneficiary;\\n}\\n\"\r\n    },\r\n    \"src/util/MakerPSMUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// Interfaces\\nimport { IMakerPSM } from \\\"../interfaces/IMakerPSM.sol\\\";\\n\\n/// @title MakerPSMUtils\\nabstract contract MakerPSMUtils {\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev DAI Address\\n    address public immutable DAI_MAKER; // solhint-disable-line var-name-mixedcase\\n    /// @dev WAD amount\\n    uint256 private constant WAD = 10 ** 18;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _daiMaker) {\\n        DAI_MAKER = _daiMaker;\\n    }\\n    /*//////////////////////////////////////////////////////////////\\n                                 INTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Execute a swapExactAmountIn on Maker PSM transfering the recieved tokens to the beneficiary\\n    function _executeSwapExactAmountInOnMakerPSM(\\n        address exchange,\\n        uint256 swapType,\\n        uint256 toll,\\n        uint256 to18ConversionFactor,\\n        uint256 fromAmount,\\n        address beneficiary\\n    )\\n        internal\\n    {\\n        // If swapType is 0, then we are calling buyGem\\n        if (swapType == 0) {\\n            // Calculate the amount to buy\\n            uint256 gemAmt = (fromAmount * WAD) / ((WAD + toll) * to18ConversionFactor);\\n            // Call buyGem on exchange\\n            IMakerPSM(exchange).buyGem(beneficiary, gemAmt);\\n        }\\n        // If swapType is 1, then we are calling sellGem\\n        else {\\n            // Call sellGem on exchange\\n            IMakerPSM(exchange).sellGem(beneficiary, fromAmount);\\n        }\\n    }\\n\\n    /// @dev Execute a swapExactAmountOut on Maker PSM transfering the recieved tokens to the beneficiary\\n    function _executeSwapExactAmountOutOnMakerPSM(\\n        address exchange,\\n        uint256 swapType,\\n        uint256 toll,\\n        uint256 to18ConversionFactor,\\n        uint256 toAmount,\\n        address beneficiary\\n    )\\n        internal\\n    {\\n        // If swapType is 0, then we are calling buyGem\\n        if (swapType == 0) {\\n            IMakerPSM(exchange).buyGem(beneficiary, toAmount);\\n        }\\n        // If swapType is 1, then we are calling sellGem\\n        else {\\n            // Calculate the amount to sell\\n            uint256 a = toAmount * WAD;\\n            uint256 b = (WAD - toll) * to18ConversionFactor;\\n            uint256 gemAmt = (a + b - 1) / b;\\n            // Call sellGem\\n            IMakerPSM(exchange).sellGem(beneficiary, gemAmt);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/util/Permit2Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/// @title Permit2Utils\\n/// @notice A contract containing common utilities for Permit2\\nabstract contract Permit2Utils {\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error Permit2Failed();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Permit2 address\\n    address public immutable PERMIT2; // solhint-disable-line var-name-mixedcase\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _permit2) {\\n        PERMIT2 = _permit2;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                INTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Parses data and executes permit2.permitTransferFrom, reverts if it fails\\n    function permit2TransferFrom(bytes calldata data, address recipient, uint256 amount) internal {\\n        address targetAddress = PERMIT2;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Get free memory pointer\\n            let ptr := mload(64)\\n            // Store function selector\\n            mstore(ptr, 0x30f28b7a00000000000000000000000000000000000000000000000000000000) // permitTransferFrom()\\n            // Copy data to memory\\n            calldatacopy(add(ptr, 4), data.offset, data.length)\\n            // Store recipient\\n            mstore(add(ptr, 132), recipient)\\n            // Store amount\\n            mstore(add(ptr, 164), amount)\\n            // Store owner\\n            mstore(add(ptr, 196), caller())\\n            // Call permit2.permitTransferFrom and revert if call failed\\n            if iszero(call(gas(), targetAddress, 0, ptr, add(data.length, 4), 0, 0)) {\\n                mstore(0, 0x6b836e6b00000000000000000000000000000000000000000000000000000000) // Store error selector\\n                    // error Permit2Failed()\\n                revert(0, 4)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/// @title IErrors\\n/// @notice Common interface for errors\\ninterface IErrors {\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when the returned amount is less than the minimum amount\\n    error InsufficientReturnAmount();\\n\\n    /// @notice Emitted when the specified toAmount is less than the minimum amount (2)\\n    error InvalidToAmount();\\n\\n    /// @notice Emmited when the srcToken and destToken are the same\\n    error ArbitrageNotSupported();\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMakerPSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.22;\\n\\ninterface IMakerPSM {\\n    function sellGem(address usr, uint256 gemAmt) external;\\n    function buyGem(address usr, uint256 gemAmt) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"@create3/=lib/create3-factory/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"create3-factory/=lib/create3-factory/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"foundry-huff/=lib/foundry-huff/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\",\r\n      \"solidity-stringutils/=lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"solmate/=lib/create3-factory/lib/solmate/src/\",\r\n      \"stringutils/=lib/foundry-huff/lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daiMaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_permit2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArbitrageNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientReturnAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Permit2Failed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DAI_MAKER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to18ConversionFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gemJoinAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"beneficiaryDirectionApproveFlag\",\"type\":\"uint256\"}],\"internalType\":\"struct MakerPSMData\",\"name\":\"makerPSMData\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"name\":\"swapExactAmountInOutOnMakerPSM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MakerPSMRouterFacet", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba3", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}