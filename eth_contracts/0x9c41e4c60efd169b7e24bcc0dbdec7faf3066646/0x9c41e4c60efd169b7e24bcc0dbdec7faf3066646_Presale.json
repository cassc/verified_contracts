{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.24;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    using SafeMath for uint256;\r\n\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(\r\n        address spender,\r\n        uint256 currentAllowance,\r\n        uint256 requestedDecrease\r\n    );\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeCall(token.transferFrom, (from, to, value))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 requestedDecrease\r\n    ) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance < requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(\r\n                    spender,\r\n                    currentAllowance,\r\n                    requestedDecrease\r\n                );\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        bytes memory approvalCall = abi.encodeCall(\r\n            token.approve,\r\n            (spender, value)\r\n        );\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeCall(token.approve, (spender, 0))\r\n            );\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data)\r\n        private\r\n        returns (bool)\r\n    {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success &&\r\n            (returndata.length == 0 || abi.decode(returndata, (bool))) &&\r\n            address(token).code.length > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\ncontract Presale is Ownable, ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    uint256 public currentStage;\r\n    uint256 public vestingRate;\r\n\r\n    bool public isEnabled;\r\n\r\n    struct VestingInfo {\r\n       uint256 totalAmount;\r\n       uint256 lastClaimAmount;\r\n       uint256 lastClaimTime;\r\n       mapping(uint256 => bool) rateClaimed;\r\n    }\r\n\r\n    struct Stage {\r\n       uint256 usdRate;\r\n       uint256 preSupply;\r\n       uint256 tokenSold;\r\n    }\r\n\r\n    Stage[] public stages;\r\n\r\n    IERC20 public token = IERC20(0xaeA6065786fF1d6DCD7B34AB692426b594406eeb);\r\n    IERC20 public usdtToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 public usdcToken = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n\r\n    AggregatorV3Interface public priceFeedETH = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n    AggregatorV3Interface public priceFeedUSDT = AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\r\n    AggregatorV3Interface public priceFeedUSDC = AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\r\n\r\n\r\n    mapping(address => VestingInfo) public vestingInfo;\r\n\r\n    event TokensPurchased(address indexed buyer, uint256 amount);\r\n    event TokensClaimed(address indexed claimer, uint256 amount);\r\n    event RateSet(uint256 newRate, address indexed owner);\r\n    event SetStage(uint256 stage);\r\n    event TokensRecovered(address indexed sender, address indexed tokenAddress, uint256 amount);\r\n    event ClaimingEnabled(bool enabled);\r\n\r\n    constructor() {\r\n\r\n        stages.push(Stage(0.005 * 10**18, 20000000 * 10**18, 0));\r\n        stages.push(Stage(0.015 * 10**18, 20000000 * 10**18, 0));\r\n        stages.push(Stage(0.03 * 10**18,  30000000 * 10**18, 0));\r\n        stages.push(Stage(0.045 * 10**18, 55555556 * 10**18, 0));\r\n        stages.push(Stage(0.06 * 10**18, 74444444 * 10**18, 0));\r\n    }\r\n\r\n    function buyTokensWithETH() external payable nonReentrant {\r\n        Stage storage current = getStage();\r\n        require(msg.value > 0, \"Amount must be greater than zero\");\r\n\r\n        uint256 ethAmount = msg.value;\r\n        uint256 amount = getTokenAmountETH(ethAmount);\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        uint256 remainingTokens = stages[currentStage].preSupply - stages[currentStage].tokenSold;\r\n        require(amount <= remainingTokens, \"Not enough tokens available in this stage\");\r\n\r\n        VestingInfo storage user = vestingInfo[msg.sender];\r\n\r\n        (bool ethTransferSuccess, ) = payable(owner()).call{value: ethAmount}(\"\");\r\n        require(ethTransferSuccess, \"ETH transfer failed\");\r\n\r\n        user.totalAmount = user.totalAmount.add(amount);\r\n        current.tokenSold = current.tokenSold.add(amount);\r\n\r\n        emit TokensPurchased(msg.sender, amount);\r\n    }\r\n\r\n    function buyTokensWithUSDT(uint256 usdtAmount) external nonReentrant {\r\n        Stage storage current = getStage();\r\n        require(usdtAmount > 0, \"Amount must be greater than zero\");\r\n\r\n        uint256 amount = getTokenAmountUSDT(usdtAmount);\r\n        uint256 tokenAmount = amount.mul(1e18).div(1e6);\r\n\r\n        require(tokenAmount > 0, \"Amount must be greater than zero\");\r\n        uint256 remainingTokens = stages[currentStage].preSupply - stages[currentStage].tokenSold;\r\n        require(tokenAmount <= remainingTokens, \"Not enough tokens available in this stage\");\r\n\r\n        VestingInfo storage user = vestingInfo[msg.sender];\r\n\r\n        usdtToken.safeTransferFrom(msg.sender, owner(), usdtAmount);\r\n\r\n        user.totalAmount = user.totalAmount.add(tokenAmount);\r\n        current.tokenSold = current.tokenSold.add(tokenAmount);\r\n\r\n        emit TokensPurchased(msg.sender, tokenAmount);\r\n    }\r\n\r\n\r\n    function buyTokensWithUSDC(uint256 usdcAmount) external nonReentrant {\r\n        Stage storage current = getStage();\r\n        require(usdcAmount > 0, \"Amount must be greater than zero\");\r\n\r\n        uint256 amount = getTokenAmountUSDC(usdcAmount);\r\n        uint256 tokenAmount = amount.mul(1e18).div(1e6);\r\n\r\n        require(tokenAmount > 0, \"Amount must be greater than zero\");\r\n        uint256 remainingTokens = stages[currentStage].preSupply - stages[currentStage].tokenSold;\r\n        require(tokenAmount <= remainingTokens, \"Not enough tokens available in this stage\");\r\n\r\n        VestingInfo storage user = vestingInfo[msg.sender];\r\n\r\n        usdcToken.safeTransferFrom(msg.sender, owner(), usdcAmount);\r\n\r\n        user.totalAmount = user.totalAmount.add(tokenAmount);\r\n        current.tokenSold = current.tokenSold.add(tokenAmount);\r\n\r\n        emit TokensPurchased(msg.sender, tokenAmount);\r\n    }\r\n\r\n\r\n    function claimReleasedAmount() external {\r\n        require(isEnabled, \"Claiming is currently disabled\");\r\n        VestingInfo storage user = vestingInfo[msg.sender];\r\n\r\n        require(user.totalAmount > 0, \"Nothing to claim\");\r\n\r\n        uint256 remainingAmount = user.totalAmount;\r\n        uint256 claimableAmount = user.totalAmount.mul(vestingRate).div(100);\r\n        require(claimableAmount <= remainingAmount, \"Not enough tokens to claim\");\r\n        require(!user.rateClaimed[vestingRate], \"Tokens already claimed for this rate\");\r\n\r\n        user.lastClaimTime = block.timestamp;\r\n        user.lastClaimAmount = claimableAmount;\r\n        user.rateClaimed[vestingRate] = true;\r\n\r\n        token.safeTransfer(msg.sender, claimableAmount);\r\n\r\n        user.totalAmount = remainingAmount.sub(claimableAmount);\r\n\r\n        emit TokensClaimed(msg.sender, claimableAmount);\r\n    }\r\n\r\n    function getTokenAmountETH(uint256 amountETH) public view returns (uint256) {\r\n        uint256 lastETHPriceByUSD = getLatestPriceETHPerUSD();\r\n        return amountETH.mul(lastETHPriceByUSD).div(getPriceInUSD());\r\n    }\r\n\r\n    function getTokenAmountUSDT(uint256 amountUSDT) public view returns (uint256) {\r\n        uint256 lastUSDTPriceByUSD = getLatestPriceUSDTPerUSD();\r\n        return amountUSDT.mul(lastUSDTPriceByUSD).div(getPriceInUSD());\r\n    }\r\n\r\n    function getTokenAmountUSDC(uint256 amountUSDC) public view returns (uint256) {\r\n        uint256 lastUSDCPriceByUSD = getLatestPriceUSDCPerUSD();\r\n        return amountUSDC.mul(lastUSDCPriceByUSD).div(getPriceInUSD());\r\n    }\r\n\r\n    function getLatestPriceETHPerUSD() public view returns (uint256) {\r\n        (, int256 price, , , ) = priceFeedETH.latestRoundData();\r\n        price = (price * (10**10));\r\n        return uint256(price);\r\n    }\r\n\r\n    function getLatestPriceUSDTPerUSD() public view returns (uint256) {\r\n        (, int256 price, , , ) = priceFeedUSDT.latestRoundData();\r\n        price = (price * (10**10));\r\n        return uint256(price);\r\n    }\r\n\r\n    function getLatestPriceUSDCPerUSD() public view returns (uint256) {\r\n        (, int256 price, , , ) = priceFeedUSDC.latestRoundData();\r\n        price = (price * (10**10));\r\n        return uint256(price);\r\n    }\r\n\r\n    function getPriceInUSD() public view returns (uint256) {\r\n        return stages[currentStage].usdRate;\r\n    }\r\n\r\n\r\n    function updateContractAddresses(address _newPriceFeedETH, address _newPriceFeedUSDT, address _newPriceFeedUSDC) external onlyOwner {\r\n        require(_newPriceFeedETH != address(0), \"ETH price feed address cannot be zero\");\r\n        require(_newPriceFeedUSDT != address(0), \"USDT price feed address cannot be zero\");\r\n        require(_newPriceFeedUSDC != address(0), \"USDC price feed address cannot be zero\");\r\n        priceFeedETH = AggregatorV3Interface(_newPriceFeedETH);\r\n        priceFeedUSDT = AggregatorV3Interface(_newPriceFeedUSDT);\r\n        priceFeedUSDC = AggregatorV3Interface(_newPriceFeedUSDC);\r\n    }\r\n\r\n    function updateUsdRate(uint256 _stage, uint256 usdRate) external onlyOwner {\r\n        require(_stage < stages.length, \"No more stage available\");\r\n        require(usdRate > 0, \"USD rate must be greater than zero\");\r\n        Stage storage currentStageToUpdate = stages[_stage];\r\n        currentStageToUpdate.usdRate = usdRate;\r\n    }\r\n\r\n    function enableClaim(uint256 _newVestingRate) external onlyOwner {\r\n        require(_newVestingRate > 0, \"Vesting rate must be greater than zero\");\r\n        vestingRate = _newVestingRate;\r\n        isEnabled = true;\r\n        emit ClaimingEnabled(true);\r\n    }\r\n\r\n    function disableClaim() external onlyOwner {\r\n        isEnabled = false;\r\n        emit ClaimingEnabled(false);\r\n    }\r\n\r\n    function isClaimEnabled() external view returns (bool) {\r\n        return isEnabled;\r\n    }\r\n\r\n    function setStage(uint256 _newStage) external onlyOwner {\r\n        require(currentStage < stages.length, \"No more stage available\");\r\n        currentStage = _newStage;\r\n        emit SetStage(_newStage);\r\n    }\r\n\r\n    function getStage() internal view returns (Stage storage) {\r\n        require(currentStage < stages.length, \"No more stage available\");\r\n        return stages[currentStage];\r\n    }\r\n\r\n\r\n    function getTotalUSDRaised() external view returns (uint256) {\r\n        uint256 totalUSDRaised = 0;\r\n\r\n        for (uint256 i = 0; i < stages.length; i++) {\r\n           uint256 stageUSD = stages[i].usdRate;\r\n           uint256 stageTokensSold = stages[i].tokenSold;\r\n\r\n           totalUSDRaised = totalUSDRaised.add(stageUSD.mul(stageTokensSold).div(1e18));\r\n        }\r\n\r\n       return totalUSDRaised;\r\n    }\r\n\r\n\r\n    function getTotalSoldTokens() external view returns (uint256) {\r\n        uint256 totalSold = 0;\r\n\r\n        for (uint256 i = 0; i < stages.length; i++) {\r\n           uint256 stageTokensSold = stages[i].tokenSold;\r\n\r\n           totalSold = totalSold.add(stageTokensSold);\r\n        }\r\n\r\n       return totalSold;\r\n    }\r\n\r\n    function withdrawETH() external onlyOwner {\r\n        uint256 ethBalance = address(this).balance;\r\n        (bool success, ) = payable(msg.sender).call{value: ethBalance}(\"\");\r\n        require(success, \"ETH withdrawal failed\");\r\n    }\r\n\r\n    function withdrawLeftToken() external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance > 0, \"No tokens\");\r\n        token.safeTransfer(owner(), balance);\r\n    }\r\n    \r\n    function recoverWrongTokens(address _tokenAddress) external onlyOwner {\r\n        IERC20 wrongToken = IERC20(_tokenAddress);\r\n        uint256 balance = wrongToken.balanceOf(address(this));\r\n        require(balance > 0, \"No tokens to recover\");\r\n\r\n        require(wrongToken.transfer(owner(), balance), \"Token recovery failed\");\r\n\r\n        emit TokensRecovered(msg.sender, _tokenAddress, balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ClaimingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"SetStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensRecovered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"buyTokensWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdcAmount\",\"type\":\"uint256\"}],\"name\":\"buyTokensWithUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"buyTokensWithUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReleasedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newVestingRate\",\"type\":\"uint256\"}],\"name\":\"enableClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceETHPerUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceUSDCPerUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceUSDTPerUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDC\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSoldTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalUSDRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClaimEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedETH\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedUSDC\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedUSDT\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newStage\",\"type\":\"uint256\"}],\"name\":\"setStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPriceFeedETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newPriceFeedUSDT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newPriceFeedUSDC\",\"type\":\"address\"}],\"name\":\"updateContractAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdRate\",\"type\":\"uint256\"}],\"name\":\"updateUsdRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLeftToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Presale", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8c073d69b6a8499ccce5a37fd21352ea8692e7f389bada79ee1fbe44a14eb6cb"}