{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Airdrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IGovernance.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/ISablierAirdrop.sol\\\";\\nimport \\\"./interfaces/IRecipientStorage.sol\\\";\\nimport \\\"./libraries/Types.sol\\\";\\n\\ncontract SablierAirdrop is ISablierAirdrop, ReentrancyGuard {\\n    /*** Storage Properties ***/\\n\\n    /**\\n     * @notice Tornado Governance contract is an owner of airdrop contract and can create or cancel airdrops\\n     */\\n    address public constant tornadoGovernance = 0x5efda50f22d34F262c29268506C5Fa42cB56A1Ce;\\n\\n    /**\\n     * @notice TORN token - token for airdrops\\n     */\\n    IERC20 public constant torn = IERC20(0x77777FeDdddFfC19Ff86DB637967013e6C6A116C);\\n\\n    /**\\n     * @notice Counter for new stream ids.\\n     */\\n    uint256 public nextStreamId;\\n\\n    /**\\n     * @notice The stream objects identifiable by their unsigned integer ids.\\n     */\\n    mapping(uint256 => Types.Stream) private streams;\\n\\n    /*** Modifiers ***/\\n\\n    /**\\n     * @dev Throws if the caller is not the recipient of the stream.\\n     */\\n    modifier onlyRecipient(uint256 streamId) {\\n        require(msg.sender == streams[streamId].recipient, \\\"caller is not the recipient of the stream\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the caller is not Tornado Cash Governance contract\\n     */\\n    modifier onlyGovernance() {\\n        require(msg.sender == tornadoGovernance, \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the provided id does not point to a valid stream.\\n     */\\n    modifier streamExists(uint256 streamId) {\\n        require(streams[streamId].isEntity, \\\"stream does not exist\\\");\\n        _;\\n    }\\n\\n    /*** Contract Logic Starts Here */\\n\\n    constructor() {\\n        nextStreamId = 1;\\n    }\\n\\n    /*** View Functions ***/\\n\\n    /**\\n     * @notice Returns the stream with all its properties.\\n     * @dev Throws if the id does not point to a valid stream.\\n     * @param streamId The id of the stream to query.\\n     */\\n    function getStream(\\n        uint256 streamId\\n    )\\n        external\\n        view\\n        streamExists(streamId)\\n        returns (\\n            address recipient,\\n            uint256 deposit,\\n            uint256 startTime,\\n            uint256 stopTime,\\n            uint256 remainingBalance,\\n            uint256 ratePerSecond\\n        )\\n    {\\n        recipient = streams[streamId].recipient;\\n        deposit = streams[streamId].deposit;\\n        startTime = streams[streamId].startTime;\\n        stopTime = streams[streamId].stopTime;\\n        remainingBalance = streams[streamId].remainingBalance;\\n        ratePerSecond = streams[streamId].ratePerSecond;\\n    }\\n\\n    /**\\n     * @notice Returns either the delta in seconds between `block.timestamp` and `startTime` or\\n     *  between `stopTime` and `startTime, whichever is smaller. If `block.timestamp` is before\\n     *  `startTime`, it returns 0.\\n     * @dev Throws if the id does not point to a valid stream.\\n     * @param streamId The id of the stream for which to query the delta.\\n     * @return delta The time delta in seconds.\\n     */\\n    function deltaOf(uint256 streamId) public view streamExists(streamId) returns (uint256 delta) {\\n        Types.Stream memory stream = streams[streamId];\\n        if (block.timestamp <= stream.startTime) return 0;\\n        if (block.timestamp < stream.stopTime) return block.timestamp - stream.startTime;\\n        return stream.stopTime - stream.startTime;\\n    }\\n\\n    /**\\n     * @notice Returns the available funds for the given stream id and address.\\n     * @dev Throws if the id does not point to a valid stream.\\n     * @param streamId The id of the stream for which to query the balance.\\n     * @param who The address for which to query the balance.\\n     * @return balance The total funds allocated to `who` as uint256.\\n     */\\n    function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {\\n        Types.Stream memory stream = streams[streamId];\\n        uint256 delta = deltaOf(streamId);\\n        uint256 recipientBalance = delta * stream.ratePerSecond;\\n\\n        /*\\n         * If the stream `balance` does not equal `deposit`, it means there have been withdrawals.\\n         * We have to subtract the total amount withdrawn from the amount of money that has been\\n         * streamed until now.\\n         */\\n        if (stream.deposit > stream.remainingBalance) {\\n            uint256 withdrawalAmount = stream.deposit - stream.remainingBalance;\\n            recipientBalance = recipientBalance - withdrawalAmount;\\n        }\\n\\n        if (who == stream.recipient) return recipientBalance;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice To avoid \\\"stack to deep\\\" error\\n     */\\n    struct CreateAirdropLocalVars {\\n        uint256 airdropDuration;\\n        uint256 ratePerSecond;\\n        uint256 firstStream;\\n        Types.Recipient[] airdropRecipients;\\n    }\\n\\n    /*** Public Effects & Interactions Functions ***/\\n    function createAirdrop(\\n        uint256 startTime,\\n        uint256 stopTime,\\n        address recipientStorage\\n    ) external onlyGovernance returns (bool) {\\n        CreateAirdropLocalVars memory vars;\\n        vars.airdropDuration = stopTime - startTime;\\n        vars.airdropRecipients = IRecipientStorage(recipientStorage).getAirdropRecipients();\\n        vars.firstStream = nextStreamId;\\n\\n        require(vars.airdropRecipients.length > 0, \\\"no airdrop recipients\\\");\\n\\n        for (uint256 i = 0; i < vars.airdropRecipients.length; i++) {\\n            uint256 normalizedDeposit = vars.airdropRecipients[i].deposit -\\n                (vars.airdropRecipients[i].deposit % vars.airdropDuration);\\n            address recipientAddr = vars.airdropRecipients[i].addr;\\n            uint256 recipientInitialLockedBalance = vars.airdropRecipients[i].initialLockedBalance;\\n\\n            /* Without this, the rate per second would be zero. */\\n            require(normalizedDeposit >= vars.airdropDuration, \\\"deposit smaller than time delta\\\");\\n\\n            vars.ratePerSecond = normalizedDeposit / vars.airdropDuration;\\n\\n            /* Create and store the stream object. */\\n            uint256 streamId = nextStreamId;\\n            streams[streamId] = Types.Stream({\\n                remainingBalance: normalizedDeposit,\\n                deposit: normalizedDeposit,\\n                initialLockedBalance: recipientInitialLockedBalance,\\n                isEntity: true,\\n                ratePerSecond: vars.ratePerSecond,\\n                recipient: recipientAddr,\\n                startTime: startTime,\\n                stopTime: stopTime\\n            });\\n\\n            /* Increment the next stream id. */\\n            nextStreamId = nextStreamId + 1;\\n\\n            emit CreateStream(\\n                streamId,\\n                recipientAddr,\\n                normalizedDeposit,\\n                recipientInitialLockedBalance,\\n                startTime,\\n                stopTime\\n            );\\n        }\\n\\n        emit CreateAirdrop(startTime, stopTime, vars.airdropRecipients.length, vars.firstStream, nextStreamId - 1);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Withdraws from the contract to the recipient's account all available recipient stream balance.\\n     * @dev Throws if the id does not point to a valid stream.\\n     *  Throws if the caller is not the sender or the recipient of the stream.\\n     *  Throws if the amount exceeds the available balance.\\n     *  Throws if there is a token transfer failure.\\n     * @param streamId The id of the stream to withdraw tokens from.\\n     */\\n    function withdrawFromStream(\\n        uint256 streamId\\n    ) external nonReentrant streamExists(streamId) onlyRecipient(streamId) returns (bool) {\\n        Types.Stream memory stream = streams[streamId];\\n\\n        uint256 balance = balanceOf(streamId, stream.recipient);\\n        require(balance > 0, \\\"amount is zero\\\");\\n\\n        uint256 recipientLockedBalance = IGovernance(tornadoGovernance).lockedBalance(stream.recipient);\\n        require(recipientLockedBalance >= stream.initialLockedBalance, \\\"not enough locked tokens in governance\\\");\\n\\n        /* Remaining balance can not be less than recipient stream balance */\\n        streams[streamId].remainingBalance = stream.remainingBalance - balance;\\n\\n        if (streams[streamId].remainingBalance == 0) delete streams[streamId];\\n\\n        torn.transfer(stream.recipient, balance);\\n        emit WithdrawFromStream(streamId, stream.recipient, balance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Cancels the stream and transfers the tokens back (remaining and unclaimed).\\n     * @dev Throws if the id does not point to a valid stream.\\n     *  Throws if the caller is not the sender of the stream.\\n     *  Throws if there is a token transfer failure.\\n     * @param streamId The id of the stream to cancel.\\n     * @return bool true=success, otherwise false.\\n     */\\n    function cancelStream(uint256 streamId) external streamExists(streamId) onlyGovernance returns (bool) {\\n        Types.Stream memory stream = streams[streamId];\\n        uint256 remainingBalance = stream.remainingBalance;\\n\\n        delete streams[streamId];\\n\\n        if (remainingBalance > 0) torn.transfer(tornadoGovernance, remainingBalance);\\n\\n        emit CancelStream(streamId, stream.recipient, remainingBalance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Cancels all airdrop streams and withdraw all unclaimed tokens back to governance.\\n     * @dev Throws if there is a token transfer failure.\\n     * @return bool true=success, otherwise false.\\n     */\\n    function cancelAirdrop(uint256 firstStreamId, uint256 lastStreamId) external onlyGovernance returns (bool) {\\n        require(lastStreamId < nextStreamId, \\\"last id exceeds stream count\\\");\\n\\n        uint256 airdropRemainingBalance;\\n        for (uint256 streamId = firstStreamId; streamId <= lastStreamId; streamId++) {\\n            Types.Stream memory stream = streams[streamId];\\n            uint256 remainingBalance = stream.remainingBalance;\\n\\n            if (remainingBalance > 0) {\\n                airdropRemainingBalance += stream.remainingBalance;\\n\\n                delete streams[streamId];\\n                emit CancelStream(streamId, stream.recipient, stream.remainingBalance);\\n            }\\n        }\\n\\n        torn.transfer(tornadoGovernance, airdropRemainingBalance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Withdraw all unclaimed tokens back to governance without canceling airdrop streams\\n     * @dev Throws if there is a token transfer failure.\\n     * @return bool true=success, otherwise false.\\n     */\\n    function withdrawFunds() external onlyGovernance returns (bool) {\\n        torn.transfer(tornadoGovernance, torn.balanceOf(address(this)));\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IGovernance {\\n    function lockedBalance(address staker) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRecipientStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/Types.sol\\\";\\n\\ninterface IRecipientStorage {\\n    function getAirdropRecipients() external view returns (Types.Recipient[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISablierAirdrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/Types.sol\\\";\\n\\ninterface ISablierAirdrop {\\n    /**\\n     * @notice Emits when a stream is successfully created.\\n     */\\n    event CreateStream(\\n        uint256 indexed streamId,\\n        address indexed recipient,\\n        uint256 deposit,\\n        uint256 initialLockedBalance,\\n        uint256 startTime,\\n        uint256 stopTime\\n    );\\n\\n    /**\\n     * @notice Emits when full airdrop is successfully created.\\n     */\\n    event CreateAirdrop(\\n        uint256 startTime,\\n        uint256 stopTime,\\n        uint256 recipientsAmount,\\n        uint256 firstStreamId,\\n        uint256 lastStreamId\\n    );\\n\\n    /**\\n     * @notice Emits when the recipient of a stream withdraws a portion or all their pro rata share of the stream.\\n     */\\n    event WithdrawFromStream(uint256 indexed streamId, address indexed recipient, uint256 amount);\\n\\n    /**\\n     * @notice Emits when a stream is successfully cancelled and tokens are transferred back on a pro rata basis.\\n     */\\n    event CancelStream(uint256 indexed streamId, address indexed recipient, uint256 remainingBalance);\\n\\n    function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\\n\\n    function getStream(\\n        uint256 streamId\\n    )\\n        external\\n        view\\n        returns (\\n            address recipient,\\n            uint256 deposit,\\n            uint256 startTime,\\n            uint256 stopTime,\\n            uint256 remainingBalance,\\n            uint256 ratePerSecond\\n        );\\n\\n    function createAirdrop(uint256 startTime, uint256 stopTime, address recipientStorage) external returns (bool);\\n\\n    function withdrawFromStream(uint256 streamId) external returns (bool);\\n\\n    function cancelStream(uint256 streamId) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nlibrary Types {\\n    struct Stream {\\n        uint256 deposit;\\n        uint256 ratePerSecond;\\n        uint256 remainingBalance;\\n        uint256 initialLockedBalance;\\n        uint256 startTime;\\n        uint256 stopTime;\\n        address recipient;\\n        bool isEntity;\\n    }\\n\\n    struct Recipient {\\n        address addr;\\n        uint256 deposit;\\n        uint256 initialLockedBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\n * available, which can be aplied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor() {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"}],\"name\":\"CancelStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stopTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipientsAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstStreamId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastStreamId\",\"type\":\"uint256\"}],\"name\":\"CreateAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialLockedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stopTime\",\"type\":\"uint256\"}],\"name\":\"CreateStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromStream\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"firstStreamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStreamId\",\"type\":\"uint256\"}],\"name\":\"cancelAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"cancelStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipientStorage\",\"type\":\"address\"}],\"name\":\"createAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"deltaOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratePerSecond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextStreamId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"torn\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tornadoGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"withdrawFromStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SablierAirdrop", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}