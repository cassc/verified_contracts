{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CRUDOeth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: none\\n\\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\\n\\n\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\\n// File: buytokenETH.sol\\n\\n\\n\\npragma solidity ^0.8.22;\\n\\n\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint);\\n  function description() external view returns (string memory); \\n  function version() external view returns (uint);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint roundId,\\n      uint answer,\\n      uint startedAt,\\n      uint updatedAt,\\n      uint answeredInRound\\n    );\\n  function latestRoundData() \\n    external \\n    view \\n    returns ( \\n      uint roundId, \\n      uint answer, \\n      uint startedAt, \\n      uint updatedAt,  \\n      uint answeredInRound   \\n    );\\n\\n}\\ncontract PriceConsumerV3 {     \\n \\n    AggregatorV3Interface internal priceFeed;\\n    AggregatorV3Interface internal btcPriceFeed;\\n    AggregatorV3Interface internal ethPriceFeed;\\n\\n constructor() {\\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419); \\n        btcPriceFeed = AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c); \\n\\n    }\\n\\n    function getThePrice() public view returns (uint) {\\n        (\\n            uint roundID, \\n            uint price,  \\n            uint startedAt,\\n            uint timeStamp,\\n            uint answeredInRound\\n        ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n     function getThePriceBtc() public view returns (uint) {\\n        (\\n            uint roundID, \\n            uint price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint answeredInRound\\n        ) = btcPriceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n     function getThePriceEth() public view returns (uint) {\\n        (\\n            uint roundID, \\n            uint price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint answeredInRound\\n        ) = ethPriceFeed.latestRoundData();\\n        return price;\\n    }\\n}\\n\\n\\ninterface BEP20 {\\n    function totalSupply() external view returns (uint theTotalSupply);\\n    function balanceOf(address _owner) external view returns (uint balance);\\n    function transfer(address _to, uint _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\\n    function approve(address _spender, uint _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\\n    event Transfer(address indexed _from, address indexed _to, uint _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\\n}  \\n\\ncontract CRUDO is ReentrancyGuard {  \\n  \\n   PriceConsumerV3 priceConsumerV3 = new PriceConsumerV3(); \\n   uint public priceOfBNB = priceConsumerV3.getThePrice();\\n   uint public priceOfWbtc = priceConsumerV3.getThePriceBtc(); \\n                  \\n                  \\n  struct Tariff {\\n    uint time;  \\n    uint percent;\\n  }\\n  \\n  struct Deposit { \\n    uint tariff;\\n    uint amount;\\n    uint tokenAmount;\\n    uint at;\\n  }\\n  \\n  struct Investor {\\n    bool registered;\\n    Deposit[] deposits;\\n    uint invested;\\n    \\n  } \\n\\n   struct TokenPurchase {\\n        address buyer; \\n        uint amount;\\n        uint timestamp;\\n        uint amountType ;  // 0 = bnb , 1 =token \\n\\n    }  \\n\\n    TokenPurchase[] public allTokenPurchases;\\n \\n    \\n\\n  // mainnet\\n   address public wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;  // WBTC MainNet           \\n   address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;  //USDT Mainnet\\n   address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;  // USDC MainNet \\n\\n  uint public tokenPrice;\\n  uint public tokenPriceDecimal;\\n\\n\\n\\n  event OwnershipTransferred(address);\\n  \\n  address public owner = msg.sender;\\n  address public owner1 = 0x4B16fc61800da83eeFF71e66465cC3c273657dA5 ;\\n  \\n  \\n  uint public totalInvested;\\n   address  payable  public   contractAddr = payable(0x4B16fc61800da83eeFF71e66465cC3c273657dA5);\\n  \\n  mapping (address => Investor) public investors;\\n  mapping(address => TokenPurchase[]) public tokenPurchases;\\n  event DepositAt(address user, uint tariff, uint amount);\\n  event Withdraw(address user, uint amount);\\n  \\n  constructor() {\\n    tokenPrice = 1;\\n    tokenPriceDecimal = 2;\\n\\n\\n  }\\n\\nfunction buyTokenWithETH(address payable _to) external payable { \\n    uint tariff = 0;\\n    require(msg.value >= 0);\\n    priceOfBNB = priceConsumerV3.getThePrice();\\n    uint tokenVal = (msg.value * priceOfBNB * 10**tokenPriceDecimal) / (tokenPrice * 100000000);\\n    \\n    if (isContract(_to)) {\\n        (bool success, ) = _to.call{value: msg.value}(\\\"\\\");\\n        require(success, \\\"Transfer to contract failed\\\");\\n    } else {\\n        _to.transfer(msg.value);\\n    }\\n    \\n    investors[msg.sender].invested += tokenVal;\\n    investors[msg.sender].deposits.push(Deposit(tariff, msg.value, tokenVal, block.timestamp));\\n    allTokenPurchases.push(TokenPurchase(msg.sender, msg.value, block.timestamp, 0));   \\n    emit DepositAt(msg.sender, tariff, tokenVal);\\n}\\n\\n\\n\\nfunction isContract(address addr) internal view returns (bool) {\\n    uint size;\\n    assembly { size := extcodesize(addr) }\\n    return size > 0;\\n}\\n\\n\\n  function buyWithToken(uint amount,uint investToken) external {\\n        require(investToken==1 || investToken==2 || investToken==3  , \\\"invalid Token\\\");\\n\\n        address duductToken = usdt;\\n        uint currencyPrice = 1; \\n        uint currencyPriceDecimal = 0;\\n\\n        if(investToken==1){\\n            duductToken = wbtc;\\n            priceOfWbtc = priceConsumerV3.getThePriceBtc();\\n            currencyPrice = priceOfWbtc;\\n            currencyPriceDecimal = 8;\\n        }\\n\\n        else if(investToken==2){\\n            duductToken = usdt;\\n        }\\n        else {\\n            duductToken = usdc;\\n        }\\n        BEP20 receiveToken = BEP20(duductToken);  \\n           \\n        \\n        \\n        uint tokenVal = (amount* currencyPrice* (10**tokenPriceDecimal)) / (tokenPrice * (10**currencyPriceDecimal)) ; \\n        \\n        require(receiveToken.balanceOf(msg.sender) >= amount, \\\"Insufficient user balance\\\");\\n      \\n       receiveToken.transferFrom(msg.sender, contractAddr, amount);\\n       \\n        investors[msg.sender].invested += tokenVal;\\n        investors[msg.sender].deposits.push(Deposit(investToken,amount,tokenVal,block.timestamp));\\n        allTokenPurchases.push(TokenPurchase(msg.sender, amount, block.timestamp, investToken));   \\n         emit DepositAt(msg.sender, investToken, tokenVal);\\n  \\n  } \\n\\n\\n\\n    // Set buy price  \\n  function setBuyPrice(uint _price, uint _decimal) public {\\n    require(msg.sender == owner || msg.sender == owner1, \\\"Only owner or owner1\\\");\\n    tokenPrice = _price;\\n    tokenPriceDecimal = _decimal;\\n}\\n \\n\\n\\n  function updateOwner1(address _newOwner1) public {\\n      require(msg.sender == owner, \\\"Only owner can update owner1\\\");\\n      owner1 = _newOwner1;\\n}\\n\\n\\nfunction updatecontractadd(address payable _newaddr) public {\\n   require(msg.sender == owner, \\\"only owner can update contractadd\\\");\\n   contractAddr = _newaddr; \\n}\\n\\n\\n\\n          // Owner BNB Withdraw    \\n    // Only owner can withdraw BNB \\n      function withdrawBNB(address payable to, uint amount) public nonReentrant  returns(bool) {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        require(to != address(0), \\\"Cannot send to zero address\\\");\\n        to.transfer(amount);\\n        return true;\\n    }\\n\\n      function usd_price() public view returns (uint) {\\n      return priceOfBNB;\\n  }\\n\\n   function tokenInBNB(uint amount) public view returns (uint) {\\n        uint tokenVal = (amount * priceOfBNB* 10**tokenPriceDecimal) /(tokenPrice*100000000*1000000000000000000) ;\\n        return (tokenVal);    \\n    }\\n  \\n\\n    function tokenInBUSD(uint amount) public view returns (uint) {\\n        uint tokenVal = (amount * 10**tokenPriceDecimal ) /(tokenPrice*1000000000000000000) ;\\n        return (tokenVal);\\n    }\\n\\n     function tokenInWbtc(uint amount) public view returns (uint) {\\n        uint tokenVal = (amount * priceOfWbtc* 10**tokenPriceDecimal) /(tokenPrice*100000000*1000000000000000000) ;\\n        return (tokenVal);\\n    }\\n\\n    // Owner Token Withdraw    \\n    // Only owner can withdraw token \\n\\n    function withdrawToken(address tokenAddress, address to, uint amount) public nonReentrant  returns(bool) {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        require(to != address(0), \\\"Cannot send to zero address\\\");\\n        BEP20 _token = BEP20(tokenAddress);\\n        _token.transfer(to, amount);\\n        return true;\\n    }\\n\\n\\n    // Ownership Transfer\\n    // Only owner can call this function\\n    function transferOwnership(address to) public returns(bool) {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        require(to != address(0), \\\"Cannot transfer ownership to zero address\\\");\\n        owner = to;\\n        emit OwnershipTransferred(to);\\n        return true;\\n    }\\n\\n\\n\\n        // View details\\n    function userDeposits(address indexAddress) public view returns (uint[] memory tariffs,uint[] memory amounts,uint[] memory getTokens, uint[] memory times) {\\n        uint len = investors[indexAddress].deposits.length;\\n        tariffs = new uint[](len);\\n        amounts = new uint[](len);\\n        getTokens = new uint[](len);\\n        times = new uint[](len);\\n        \\n        for(uint i = 0; i <len; i++){\\n            tariffs[i] = investors[indexAddress].deposits[i].tariff;\\n            amounts[i] = investors[indexAddress].deposits[i].amount;\\n            getTokens[i] = investors[indexAddress].deposits[i].tokenAmount;\\n            times[i] = investors[indexAddress].deposits[i].at;\\n            \\n        }\\n        return (tariffs, amounts, getTokens, times);\\n    }\\n\\n    function allPrice() public view returns (uint ,uint ,uint,uint,uint,uint,uint) {\\n       \\n        return (priceOfBNB, tokenPrice, tokenPriceDecimal,priceOfWbtc,8 ,0,0);\\n    }   \\n\\n    function getAllTokenPurchases() public view returns (TokenPurchase[] memory) {\\n           return allTokenPurchases;\\n}\\n\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tariff\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositAt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokenPurchases\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"buyTokenWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investToken\",\"type\":\"uint256\"}],\"name\":\"buyWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractAddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllTokenPurchases\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountType\",\"type\":\"uint256\"}],\"internalType\":\"struct CRUDO.TokenPurchase[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"invested\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOfBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOfWbtc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimal\",\"type\":\"uint256\"}],\"name\":\"setBuyPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenInBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenInBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenInWbtc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPriceDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPurchases\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner1\",\"type\":\"address\"}],\"name\":\"updateOwner1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newaddr\",\"type\":\"address\"}],\"name\":\"updatecontractadd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usd_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"indexAddress\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tariffs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"getTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbtc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CRUDO", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}