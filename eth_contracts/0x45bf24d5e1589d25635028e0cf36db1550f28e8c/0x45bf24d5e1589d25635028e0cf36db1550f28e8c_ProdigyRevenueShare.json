{"SourceCode": "/**\r\n * This is the smart contract that manages the Revenue Sharing for the Prodigy Bot.\r\n *\r\n * https://prodigybot.io/\r\n * https://t.me/ProdigySniper/\r\n * https://t.me/ProdigySniperBot/\r\n * https://twitter.com/Prodigy__Sniper\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nabstract contract Auth {\r\n\taddress private owner;\r\n\tmapping (address => bool) private authorizations;\r\n\r\n\tconstructor(address _owner) {\r\n\t\towner = _owner;\r\n\t\tauthorizations[_owner] = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function modifier to require caller to be contract owner\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(msg.sender), \"!OWNER\"); _;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function modifier to require caller to be authorized\r\n\t*/\r\n\tmodifier authorized() {\r\n\t\trequire(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Authorize address. Owner only\r\n\t*/\r\n\tfunction authorize(address adr) public onlyOwner {\r\n\t\tauthorizations[adr] = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Remove address' authorization. Owner only\r\n\t*/\r\n\tfunction unauthorize(address adr) public onlyOwner {\r\n\t\tauthorizations[adr] = false;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Check if address is owner\r\n\t*/\r\n\tfunction isOwner(address account) public view returns (bool) {\r\n\t\treturn account == owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Return address' authorization status\r\n\t*/\r\n\tfunction isAuthorized(address adr) public view returns (bool) {\r\n\t\treturn authorizations[adr];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n\t*/\r\n\tfunction transferOwnership(address payable adr) public onlyOwner {\r\n\t\towner = adr;\r\n\t\tauthorizations[adr] = true;\r\n\t\temit OwnershipTransferred(adr);\r\n\t}\r\n\r\n\tevent OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IERC20 {\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IRouter {\r\n\tfunction WETH() external pure returns (address);\r\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ncontract ProdigyRevenueShare is Auth {\r\n\r\n\t/**\r\n\t * @notice The entire Prodigy token supply fits in an uint80.\r\n\t * The entire supply of Ethereum fits in uint88.\r\n\t * We are using this to keep track of claimed ether and unclaimable ether for a specific account.\r\n\t * If we were to reach such a number, we'd need a new contract, but that'd be a very nice problem to have.\r\n\t * If you fork this: Keep in mind token supplies may need different uints.\r\n\t */\r\n\tstruct Stake {\r\n\t\tuint80 amount;\r\n\t\tuint88 totalClaimed;\r\n\t\tuint88 totalExcluded;\r\n\t}\r\n\r\n\taddress public immutable prodigyToken;\r\n\tuint256 private _rewardsPerToken;\r\n\tuint256 private constant _accuracyFactor = 1e36;\r\n\tuint256 private _minStake = 20 ether;\r\n\tuint256 private _minPayout = 0.1 ether;\r\n\r\n\tbool public open;\r\n\tuint80 private _totalStaked;\r\n\tuint88 private _revenueShareEther;\r\n\tuint16 private _sharedRevenue = 4;\r\n\tuint16 private _revenueDenominator = 10;\r\n\r\n\taddress public devFeeReceiver;\r\n\tuint96 private _devOwedEther;\r\n\r\n\taddress private _router;\r\n\tuint96 private _revenueSharePaid;\r\n\r\n\tbool public migrating;\r\n\tuint32 public migrationStarts;\r\n\tuint32 public constant migrationLockTime = 7 days;\r\n\taddress public migratingTo;\r\n\r\n\tmapping (address => Stake) private _stakes;\r\n\r\n\tevent Realised(address account, uint256 amount);\r\n\tevent Staked(address account, uint256 amount);\r\n\tevent Unstaked(address account, uint256 amount);\r\n\tevent Compounded(address account, uint256 amount, uint256 tokenAmount);\r\n\r\n\terror ZeroAmount();\r\n\terror InsufficientStake();\r\n\terror StakingTokenRescue();\r\n\terror CouldNotSendEther();\r\n\terror ClaimTooSmall();\r\n\terror AlreadyStaked();\r\n\terror NotAvailable();\r\n\terror CannotMigrate();\r\n\terror FinaliseTooEarly();\r\n\r\n\tmodifier isOpen {\r\n\t\tif (!open) {\r\n\t\t\trevert NotAvailable();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(address token, address router) Auth(msg.sender) {\r\n\t\tprodigyToken = token;\r\n\t\t_router = router;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Bot trading fees and token fees are sent here.\r\n\t * A part is sent to developer wallet to cover for the costs of running the trading suite:\r\n\t * Cloud servers, RPCs, Nodes, full-time development and support.\r\n\t * The rest is shared amongst token holders who stake their position in the contract.\r\n\t * You may link your staking account to your bot account, enjoying the benefits of holding and revenue share.\r\n\t */\r\n\treceive() external payable {\r\n\t\tif (msg.value == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\r\n\t\t// If no positions present, everything is sent to dev.\r\n\t\tuint256 stakedTokens = _totalStaked;\r\n\t\tif (stakedTokens == 0) {\r\n\t\t\t_manageDevShare(msg.value);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Calculate part for revenue share and part for development.\r\n\t\tuint256 toShare = msg.value * _sharedRevenue / _revenueDenominator;\r\n\t\tuint256 toDev = msg.value - toShare;\r\n\t\t_manageDevShare(toDev);\r\n\t\tunchecked {\r\n\t\t\t// If this overflow we are all rich.\r\n\t\t\t_revenueShareEther += uint88(toShare);\r\n\t\t\t// Update total rewards per token staked.\r\n\t\t\tuint256 newRewards = _accuracyFactor * toShare / stakedTokens;\r\n\t\t\t_rewardsPerToken += newRewards;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _manageDevShare(uint256 share) private {\r\n\t\tif (_sendEther(devFeeReceiver, share + _devOwedEther)) {\r\n\t\t\t_devOwedEther = 0;\r\n\t\t} else {\r\n\t\t\tunchecked {\r\n\t\t\t\t_devOwedEther += uint96(share);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _sendEther(address receiver, uint256 amount) private returns (bool success) {\r\n\t\t(success,) = receiver.call{value: amount}(\"\");\r\n\t}\r\n\r\n\tfunction viewPosition(address account) external view returns (Stake memory) {\r\n\t\treturn _stakes[account];\r\n\t}\r\n\r\n\tfunction accountStakedTokens(address account) external view returns (uint256) {\r\n\t\treturn _stakes[account].amount;\r\n\t}\r\n\r\n\tfunction accountsSumStakedTokens(address[] calldata accounts) external view returns (uint256 tokens) {\r\n\t\tfor (uint256 i = 0; i < accounts.length; ++i) {\r\n\t\t\ttokens += _stakes[accounts[i]].amount;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPendingClaim(address account) external view returns (uint256) {\r\n\t\treturn _earnt(_stakes[account], false);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice The operation must be done in uint256 before converting to uint88 for decimal precision.\r\n\t */\r\n\tfunction _getCumulativeRewards(uint256 amount, bool roundUp) private view returns (uint88) {\r\n\t\tuint256 accurate = _rewardsPerToken * amount;\r\n\t\tif (roundUp) {\r\n\t\t\tunchecked {\r\n\t\t\t\taccurate += _accuracyFactor / 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn uint88(accurate / _accuracyFactor);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add a position for revenue share for the first time.\r\n\t * @notice For adding to a position, call the `restake` method.\r\n\t */\r\n\tfunction stake(uint256 amount) external isOpen {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\t_firstStake(msg.sender, uint80(amount));\r\n\t\tIERC20(prodigyToken).transferFrom(msg.sender, address(this), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add to an existing stake plus compounding pending revenue.\r\n\t * @notice Must calculate slippage from UI for expectedTokens!\r\n\t */\r\n\tfunction restake(uint256 amount, uint256 expectedTokens) external isOpen {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\t_stake(msg.sender, uint80(amount), expectedTokens);\r\n\t\tIERC20(prodigyToken).transferFrom(msg.sender, address(this), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add a stake for someone else.\r\n\t * @notice Only available for a first time stake, since re-stake triggers compounding.\r\n\t */\r\n\tfunction stakeFor(address account, uint256 amount) external isOpen {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\r\n\t\t_firstStake(account, uint80(amount));\r\n\t\tIERC20(prodigyToken).transferFrom(msg.sender, address(this), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev To be used for the first time a stake is done.\r\n\t */\r\n\tfunction _firstStake(address account, uint80 amount) private {\r\n\t\tif (amount < _minStake) {\r\n\t\t\trevert InsufficientStake();\r\n\t\t}\r\n\t\tStake storage position = _stakes[account];\r\n\t\tif (position.amount > 0) {\r\n\t\t\trevert AlreadyStaked();\r\n\t\t}\r\n\t\tposition.amount = amount;\r\n\t\tposition.totalExcluded = _getCumulativeRewards(position.amount, true);\r\n\t\tunchecked {\r\n\t\t\t_totalStaked += amount;\r\n\t\t}\r\n\r\n\t\temit Staked(account, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add to an existing position.\r\n\t */\r\n\tfunction _stake(address account, uint80 amount, uint256 expectedTokens) private {\r\n\t\tStake storage position = _stakes[account];\r\n\t\t_compound(account, position, expectedTokens);\r\n\r\n\t\tunchecked {\r\n\t\t\tposition.amount += amount;\r\n\t\t\tposition.totalExcluded = _getCumulativeRewards(position.amount, true);\r\n\t\t\t_totalStaked += amount;\r\n\t\t}\r\n\r\n\t\temit Staked(account, amount);\r\n\t}\r\n\r\n\tfunction unstake(uint256 amount) external {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\r\n\t\t_unstake(msg.sender, uint80(amount));\r\n\t}\r\n\r\n\tfunction _unstake(address account, uint80 amount) private {\r\n\t\tStake storage position = _stakes[account];\r\n\t\t// Revert if amount over actual position or it would lead a position to be under the minimum.\r\n\t\tif (position.amount < amount || (amount < position.amount && position.amount - amount < _minStake)) {\r\n\t\t\trevert InsufficientStake();\r\n\t\t}\r\n\r\n\t\t// Forfeit remainder of revenue.\r\n\t\t_forfeit(position);\r\n\r\n\t\t// Remove the stake amount.\r\n\t\tunchecked {\r\n\t\t\tposition.amount -= amount;\r\n\t\t\t_totalStaked -= amount;\r\n\t\t}\r\n\t\tposition.totalExcluded = _getCumulativeRewards(position.amount, true);\r\n\t\tIERC20(prodigyToken).transfer(account, amount);\r\n\r\n\t\temit Unstaked(account, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Claim your pending share of the revenue.\r\n\t * @notice There's a set minimum revenue one can claim.\r\n\t */\r\n\tfunction claim() external isOpen {\r\n\t\tuint256 realised = _realise(msg.sender, _stakes[msg.sender]);\r\n\t\tif (realised < _minPayout) {\r\n\t\t\trevert ClaimTooSmall();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Use your pending revenue to buy the token tax free and increase your ownership on the revenue share.\r\n\t * @notice Slippage should be checked fron the UI and send the expected tokens to acquire by selling the rewards.\r\n\t */\r\n\tfunction compound(uint256 expectedTokens) external isOpen {\r\n\t\taddress account = msg.sender;\r\n\t\tStake storage position = _stakes[account];\r\n\t\tif (position.amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\r\n\t\t_compound(account, position, expectedTokens);\r\n\t}\r\n\r\n\tfunction _compound(address account, Stake storage position, uint256 expectedTokens) private {\r\n\t\tuint88 amount = uint88(_earnt(position, false));\r\n\t\tif (amount == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Mark ether used for compound as claimed.\r\n\t\tunchecked {\r\n\t\t\tposition.totalClaimed += amount;\r\n\t\t\t_revenueSharePaid += amount;\r\n\t\t}\r\n\r\n\t\t// Buy the tokens to add to stake.\r\n\t\tuint256 tokensBefore = IERC20(prodigyToken).balanceOf(address(this));\r\n\t\tIRouter router = IRouter(_router);\r\n\t\taddress[] memory buyPath = new address[](2);\r\n\t\tbuyPath[0] = router.WETH();\r\n\t\tbuyPath[1] = prodigyToken;\r\n\t\trouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(expectedTokens, buyPath, address(this), block.timestamp);\r\n\t\tuint80 tokensAfter = uint80(IERC20(prodigyToken).balanceOf(address(this)) - tokensBefore);\r\n\r\n\t\t// Update stake and its exclusion value.\r\n\t\tunchecked {\r\n\t\t\tposition.amount += tokensAfter;\r\n\t\t\t_totalStaked += tokensAfter;\r\n\t\t}\r\n\t\tposition.totalExcluded = _getCumulativeRewards(position.amount, true);\r\n\r\n\t\temit Compounded(account, amount, tokensAfter);\r\n\t}\r\n\r\n\tfunction _forfeit(Stake storage position) private {\r\n\t\tuint256 amount = _earnt(position, false);\r\n\t\tif (amount > 0) {\r\n\t\t\t_manageDevShare(amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _realise(address account, Stake storage position) private returns (uint256) {\r\n\t\t// Calculate accrued unclaimed reward.\r\n\t\tuint88 amount = uint88(_earnt(position, false));\r\n\t\tif (amount == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint88 exclude = uint88(_earnt(position, true));\r\n\t\tunchecked {\r\n\t\t\tposition.totalClaimed += amount;\r\n\t\t\tposition.totalExcluded += exclude;\r\n\t\t\t_revenueSharePaid += amount;\r\n\t\t}\r\n\r\n\t\tif (!_sendEther(account, amount)) {\r\n\t\t\trevert CouldNotSendEther();\r\n\t\t}\r\n\r\n\t\temit Realised(account, amount);\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction _earnt(Stake storage position, bool round) private view returns (uint256) {\r\n\t\tuint256 accountTotalRewards = _getCumulativeRewards(position.amount, round);\r\n\t\tuint256 accountTotalExcluded = position.totalExcluded;\r\n\t\tif (accountTotalRewards <= accountTotalExcluded) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn accountTotalRewards - accountTotalExcluded;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Rescue wrongly sent ERC20 tokens.\r\n\t * @notice The staking token may never be taken out unless it's through unstaking.\r\n\t */\r\n\tfunction rescueToken(address token) external authorized {\r\n\t\tif (token == prodigyToken) {\r\n\t\t\trevert StakingTokenRescue();\r\n\t\t}\r\n\t\tIERC20 t = IERC20(token);\r\n\t\tt.transfer(msg.sender, t.balanceOf(address(this)));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Recover any non staked PRO tokens sent directly to contract.\r\n\t */\r\n\tfunction rescueNonStakingProdigy() external authorized {\r\n\t\tIERC20 pro = IERC20(prodigyToken);\r\n\t\tuint256 available = pro.balanceOf(address(this)) - _totalStaked;\r\n\t\tif (available == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\tpro.transfer(msg.sender, available);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get currently configured distribution of revenue.\r\n\t */\r\n\tfunction getRevenueShareSettings() external view returns (uint16 devRevenue, uint16 sharedRevenue, uint16 denominator) {\r\n\t\tsharedRevenue = _sharedRevenue;\r\n\t\tdevRevenue = _revenueDenominator - sharedRevenue;\r\n\t\tdenominator = _revenueDenominator;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Total ether already claimed by participants of revenue share.\r\n\t */\r\n\tfunction totalRevenueClaimed() external view returns (uint256) {\r\n\t\treturn _revenueSharePaid;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Total amount of revenue share ether both claimed and to be claimed.\r\n\t */\r\n\tfunction getTotalRevenue() external view returns (uint256) {\r\n\t\treturn _revenueShareEther;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ether destined for development costs that hasn't been sent yet.\r\n\t */\r\n\tfunction pendingDevEther() external view returns (uint256) {\r\n\t\treturn _devOwedEther;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Total amount of tokens participating in revenue share.\r\n\t */\r\n\tfunction totalPosition() external view returns (uint256) {\r\n\t\treturn _totalStaked;\r\n\t}\r\n\r\n\tfunction setRevenueShareConfig(uint16 shared, uint16 denominator) external authorized {\r\n\t\t// Denominator can never be zero or it would cause reverts.\r\n\t\tif (denominator == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\t_sharedRevenue = shared;\r\n\t\t_revenueDenominator = denominator;\r\n\t}\r\n\r\n\tfunction setDevReceiver(address dev) external authorized {\r\n\t\tdevFeeReceiver = dev;\r\n\t}\r\n\r\n\tfunction setMinStake(uint256 min) external authorized {\r\n\t\t_minStake = min;\r\n\t}\r\n\r\n\tfunction setMinPayout(uint32 min) external authorized {\r\n\t\t_minPayout = min;\r\n\t}\r\n\r\n\tfunction setRouter(address r) external authorized {\r\n\t\t_router = r;\r\n\t}\r\n\r\n\tfunction setIsOpen(bool isIt) external authorized {\r\n\t\topen = isIt;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Two-step migration that gives a week lock before assets can be transferred to a new contract.\r\n\t */\r\n\tfunction startTwoStepMigration(address migrateTo) external authorized {\r\n\t\tif (migrating || migrateTo == address(0)) {\r\n\t\t\trevert CannotMigrate();\r\n\t\t}\r\n\t\topen = false;\r\n\t\tmigrating = true;\r\n\t\tmigrationStarts = uint32(block.timestamp + migrationLockTime);\r\n\t\tmigratingTo = migrateTo;\r\n\t}\r\n\r\n\tfunction finaliseTwoStepMigration() external authorized {\r\n\t\taddress receiver = migratingTo;\r\n\t\tif (!migrating || receiver == address(0)) {\r\n\t\t\trevert CannotMigrate();\r\n\t\t}\r\n\t\tif (block.timestamp < migrationStarts) {\r\n\t\t\trevert FinaliseTooEarly();\r\n\t\t}\r\n\t\t\r\n\t\tmigratingTo = address(0);\r\n\t\tmigrating = false;\r\n\t\tmigrationStarts = 0;\r\n\r\n\t\tIERC20 token = IERC20(prodigyToken);\r\n\t\ttoken.transfer(receiver, token.balanceOf(address(this)));\r\n\r\n\t\tif (!_sendEther(receiver, address(this).balance)) {\r\n\t\t\trevert CouldNotSendEther();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction cancelMigration() external authorized {\r\n\t\tmigrating = false;\r\n\t\tmigrationStarts = 0;\r\n\t\tmigratingTo = address(0);\r\n\t}\r\n\r\n\tfunction getMinStake() external view returns (uint256) {\r\n\t\treturn _minStake;\r\n\t}\r\n\r\n\tfunction getMinPayout() external view returns (uint256) {\r\n\t\treturn _minPayout;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyStaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotMigrate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CouldNotSendEther\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FinaliseTooEarly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientStake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingTokenRescue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Compounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Realised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"accountsSumStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedTokens\",\"type\":\"uint256\"}],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finaliseTwoStepMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRevenueShareSettings\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"devRevenue\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sharedRevenue\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"denominator\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrating\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migratingTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationLockTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationStarts\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDevEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prodigyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueNonStakingProdigy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedTokens\",\"type\":\"uint256\"}],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dev\",\"type\":\"address\"}],\"name\":\"setDevReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isIt\",\"type\":\"bool\"}],\"name\":\"setIsOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"min\",\"type\":\"uint32\"}],\"name\":\"setMinPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"setMinStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"shared\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"denominator\",\"type\":\"uint16\"}],\"name\":\"setRevenueShareConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"migrateTo\",\"type\":\"address\"}],\"name\":\"startTwoStepMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRevenueClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"viewPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"amount\",\"type\":\"uint80\"},{\"internalType\":\"uint88\",\"name\":\"totalClaimed\",\"type\":\"uint88\"},{\"internalType\":\"uint88\",\"name\":\"totalExcluded\",\"type\":\"uint88\"}],\"internalType\":\"struct ProdigyRevenueShare.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ProdigyRevenueShare", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bd7e92cf6f857be8541fca6abfb72aef8e16c3070000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7bab13be4272b8cd0349497d1b5054c3c9b295fb3a1006b4ba667c7617b223b8"}