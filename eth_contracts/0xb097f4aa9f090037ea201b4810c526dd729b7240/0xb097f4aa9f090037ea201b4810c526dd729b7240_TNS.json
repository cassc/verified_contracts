{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"TNS8.sol\": {\r\n      \"content\": \"/// raffy.eth\\n// SPDX-License-Identifier: MIT\\n\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n// \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n//    \u2588\u2588\u2551   \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n//    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n//    \u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n//    \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                           \\n//      Token Name Service\\n\\npragma solidity ^0.8.23;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts@4.8.2/access/Ownable.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol\\\";\\nimport {ENS} from \\\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\\\";\\nimport {IExtendedResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IAddressResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\\\";\\nimport {ITextResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\\\";\\nimport {IPubkeyResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol\\\";\\nimport {IContentHashResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\\\";\\nimport {IMulticallable} from \\\"@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol\\\";\\nimport {BytesUtils} from \\\"@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol\\\";\\n\\nerror OffchainLookup(address sender, string[] urls, bytes request, bytes4 callback, bytes carry);\\n\\ncontract TNS is Ownable, IERC165 {\\n\\tusing BytesUtils for bytes;\\n\\n\\tfunction supportsInterface(bytes4 x) external pure returns (bool) {\\n\\t\\treturn x == type(IERC165).interfaceId || x == this.lookup.selector;\\n\\t}\\n\\n\\taddress constant ENS_REGISTRY = 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;\\n\\n\\t// addTexts([\\n\\t//   \\\"name\\\",\\n\\t//   \\\"symbol\\\",\\n\\t//   \\\"description\\\",\\n\\t//   \\\"avatar\\\",\\n\\t//   \\\"url\\\",\\n\\t//   \\\"notice\\\",\\n\\t//   \\\"decimals\\\",\\n\\t//   \\\"twitter\\\",\\n\\t//   \\\"github\\\",\\n\\t//   \\\"chainID\\\",\\n\\t//   \\\"coinType\\\",\\n\\t//   \\\"version\\\",\\n\\t//   \\\"tokenSupply\\\",\\n\\t//   \\\"circulatingSupply\\\",\\n\\t//   \\\"discord\\\",\\n\\t//   \\\"forum\\\",\\n\\t//   \\\"governance\\\",\\n\\t//   \\\"snapshot\\\",\\n\\t//   \\\"git\\\"\\n\\t// ]);\\n\\n\\t// addCoins(\\n\\t//   [\\n\\t//     \\\".eth\\\",     // Ethereum - \\t\\t\\t\\tChainID: 1\\n\\t//     \\\".op\\\",      // Optimism - \\t\\t\\t\\tChainID: 10\\n\\t//     \\\".arb\\\",     // Arbitrum - \\t\\t\\t\\tChainID: 42161\\n\\t//     \\\".avax\\\",    // Avalanche C-Chain - \\t\\tChainID: 43114\\n\\t//     \\\".bnb\\\",     // BNB Chain (AKA BSC) - \\tChainID: 56\\n\\t//     \\\".base\\\",    // Base (By Coinbase) - \\t\\tChainID: 8453\\n\\t//     \\\".cro\\\",     // Crypto.org Chain - \\t\\tChainID: 25\\n\\t//     \\\".ftm\\\",     // Fantom - \\t\\t\\t\\t\\tChainID: 250\\n\\t//     \\\".gno\\\",     // Gnosis (formerly xDai)\\tChainID: 100\\n\\t//     \\\".matic\\\",   // Polygon (MATIC) - \\t\\tChainID: 137\\n\\t//     \\\".celo\\\",    // Celo - \\t\\t\\t\\t\\tChainID: 42220\\n\\t//     \\\".goerli\\\",  // Goerli Testnet - \\t\\t\\tChainID: 5\\n\\t//     \\\".sepolia\\\", // Sepolia Testnet - \\t\\tChainID: 111551\\n\\t//     \\\".holesky\\\", // Holesky Testnet - \\t\\tChainID: 17000\\n\\t//     \\\".near\\\",    // NEAR - \\t\\t\\t\\t\\tCoinType: 397\\n\\t//     \\\".sol\\\",     // Solana - \\t\\t\\t\\t\\tCoinType: 501\\n\\t//     \\\".trx\\\",     // TRON - \\t\\t\\t\\t\\tCoinType: 195\\n\\t//     \\\".zil\\\"      // Zilliqa - \\t\\t\\t\\tCoinType: 119\\n\\t//   ],\\n\\t//   [\\n\\t//     60,            // ChainID for Ethereum\\n\\t//     2147483658,    // ChainID for Optimism\\n\\t//     2147525809,    // ChainID for Arbitrum\\n\\t//     2147526762,    // ChainID for Avalanche C-Chain\\n\\t//     2147483704,    // ChainID for BNB Chain (AKA BSC)\\n\\t//     2147492101,    // ChainID for Base (By Coinbase)\\n\\t//     2147483673,    // ChainID for Crypto.org Chain (CRO)\\n\\t//     2147483898,    // ChainID for Fantom\\n\\t//     2147483748,    // ChainID for Gnosis (formerly xDai)\\n\\t//     2147483785,    // ChainID for Polygon (MATIC)\\n\\t//     2147525868,    // ChainID for Celo\\n\\t//     2147483643,    // ChainID for Goerli Testnet\\n\\t//     2136328537,    // ChainID for Sepolia Testnet\\n\\t//     2147500648,    // ChainID for Holesky Testnet\\n\\t//     397,           // CoinType for NEAR\\n\\t//     501,           // CoinType for Solana\\n\\t//     195,           // CoinType for TRON\\n\\t//     119            // CoinType for Zilliqa\\n\\t//   ]\\n\\t// )\\n    \\n\\tuint256 constant SLOT_FIELD_COUNT = 1; // skip owner\\n\\tuint256 constant SLOT_BASENAME = 2;\\n\\tuint256 constant SLOT_FIELDS = 3;\\n\\n\\tuint8 constant KIND_FLAG_STRING    = 0x80;\\n\\tuint8 constant KIND_FLAG_NO_DECODE = 0x40;\\n\\tuint8 constant KIND_FLAG_SKIP_4    = 0x20;\\n\\tuint8 constant KIND_FLAG_ENCODED   = 0x10;\\n\\n\\tuint8 constant KIND_TEXT = 0x01 | KIND_FLAG_STRING;\\n\\tuint8 constant KIND_COIN = 0x02 | KIND_FLAG_SKIP_4;\\n\\n\\tstruct KV {string k; string v; }\\n\\n\\terror BadInput();\\n\\terror Modified();\\n\\n\\tevent FieldsChanged();\\n\\tevent BasenameChanged(string indexed name);\\n\\n\\t// setters\\n\\tfunction setBasename(string calldata name) onlyOwner external { \\n\\t\\tsetTiny(SLOT_BASENAME, bytes(name));\\n\\t\\temit BasenameChanged(name);\\n\\t}\\n\\tfunction addFields(bytes[] calldata fields) onlyOwner external {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 n = fields.length;\\n\\t\\t\\tif (n == 0) revert BadInput();\\n\\t\\t\\tuint256 fc;\\n\\t\\t\\tassembly { fc := sload(SLOT_FIELD_COUNT) }\\n\\t\\t\\tuint256 slot = SLOT_FIELDS + fc;\\n\\t\\t\\tfor (uint256 i; i < n; i += 1) {\\n\\t\\t\\t\\tsetTiny(slot + i, fields[i]);\\n\\t\\t\\t}\\n\\t\\t\\tassembly { sstore(SLOT_FIELD_COUNT, add(fc, n)) }\\n\\t\\t\\temit FieldsChanged();\\n\\t\\t}\\n\\t}\\n\\tfunction removeFieldAt(uint256 i) onlyOwner external {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 fc;\\n\\t\\t\\tassembly { fc := sload(SLOT_FIELD_COUNT) }\\n\\t\\t\\tif (i >= fc) revert BadInput();\\n\\t\\t\\tfc -= 1;\\n\\t\\t\\tsetTiny(SLOT_FIELDS + i, getTiny(SLOT_FIELDS + fc));\\n\\t\\t\\tassembly { sstore(SLOT_FIELD_COUNT, fc) }\\n\\t\\t\\temit FieldsChanged();\\n\\t\\t}\\n\\t}\\n\\n\\t// profile\\n\\tfunction fieldNames() public view returns (string[] memory names) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 fc;\\n\\t\\t\\tassembly { fc := sload(SLOT_FIELD_COUNT) }\\n\\t\\t\\tnames = new string[](fc);\\n\\t\\t\\tfor (uint256 i; i < fc; i += 1) {\\n\\t\\t\\t\\tbytes memory v = getTiny(SLOT_FIELDS + i);\\n\\t\\t\\t\\tuint256 kind = uint8(v[0]);\\n\\t\\t\\t\\tuint256 trim = (kind & KIND_FLAG_SKIP_4) != 0 ? 5 : 1;\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tmstore(add(v, trim), sub(mload(v), trim))\\n\\t\\t\\t\\t\\tv := add(v, trim)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ((kind & KIND_FLAG_ENCODED) != 0) {\\n\\t\\t\\t\\t\\tnames[i] = string(abi.decode(v, (string)));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnames[i] = string(v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction makeCalls(bytes32 node) external view returns (bytes[] memory calls) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 fc;\\n\\t\\t\\tassembly { fc := sload(SLOT_FIELD_COUNT) }\\n\\t\\t\\tcalls = new bytes[](fc);\\n\\t\\t\\tfor (uint256 i; i < fc; i += 1) {\\n\\t\\t\\t\\tbytes memory v = getTiny(SLOT_FIELDS + i);\\n\\t\\t\\t\\tuint256 kind = uint8(v[0]);\\n\\t\\t\\t\\tuint256 trim = (kind & KIND_FLAG_SKIP_4) != 0 ? 5 : 1;\\n\\t\\t\\t\\tuint256 arg0;\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\targ0 := and(mload(add(v, 5)), 0xFFFFFFFF)\\n\\t\\t\\t\\t\\tmstore(add(v, trim), sub(mload(v), trim))\\n\\t\\t\\t\\t\\tv := add(v, trim)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (kind == KIND_TEXT) {\\n\\t\\t\\t\\t\\tcalls[i] = abi.encodeCall(ITextResolver.text, (node, string(v)));\\n\\t\\t\\t\\t} else if (kind == KIND_COIN) {\\n\\t\\t\\t\\t\\tcalls[i] = abi.encodeCall(IAddressResolver.addr, (node, arg0));\\n\\t\\t\\t\\t} else if ((kind & KIND_FLAG_SKIP_4) > 0) {\\n\\t\\t\\t\\t\\tcalls[i] = abi.encodeWithSelector(bytes4(uint32(arg0)), node);\\n\\t\\t\\t\\t} else if ((kind & KIND_FLAG_ENCODED) > 0) {\\n\\t\\t\\t\\t\\t(, v) = abi.decode(v, (string, bytes));\\n\\t\\t\\t\\t\\tassembly { mstore(add(v, 36), node) } // replace node\\n\\t\\t\\t\\t\\tcalls[i] = v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// primary api\\n\\tfunction lookup(string calldata tick) external view returns (KV[] memory) {\\n\\t\\tbytes memory name0 = getTiny(SLOT_BASENAME);\\n\\t\\tbytes32 node0 = dns_from_ens(name0).namehash(0);\\n\\t\\taddress resolver0 = ENS(ENS_REGISTRY).resolver(node0);\\n\\t\\tbytes memory name = dns_from_ens(bytes(tick).length > 0 ? abi.encodePacked(tick, '.', name0) : name0);\\n\\t\\tbytes32 node = name.namehash(0);\\n\\t\\t(bool ok, bytes memory v) = resolver0.staticcall(abi.encodeCall(IExtendedResolver.resolve, (\\n\\t\\t\\tname, \\n\\t\\t\\tabi.encodeCall(IMulticallable.multicall, (this.makeCalls(node)))\\n\\t\\t)));\\n\\t\\tif (ok) return lookupOnchain(node, abi.decode(v, (bytes[]))); \\n\\t\\tif (bytes4(v) != OffchainLookup.selector) assembly { revert(add(v, 32), mload(v)) }\\n\\t\\tassembly {\\n\\t\\t\\tmstore(add(v, 4), sub(mload(v), 4)) \\n\\t\\t\\tv := add(v, 4)\\n\\t\\t}\\n\\t\\t(, string[] memory urls, bytes memory request, bytes4 callback, bytes memory carry0) = abi.decode(v, (address, string[], bytes, bytes4, bytes));\\n\\t\\trevert OffchainLookup(address(this), urls, request, this.lookupCallback.selector, abi.encode(resolver0, node, callback, carry0));\\n\\t}\\n\\tfunction lookupCallback(bytes calldata response, bytes calldata carry) external view returns (KV[] memory) {\\n\\t\\t(address resolver0, bytes32 node, bytes4 callback, bytes memory carry0) = abi.decode(carry, (address, bytes32, bytes4, bytes));\\n\\t\\t(bool ok, bytes memory v) = resolver0.staticcall(abi.encodeWithSelector(callback, response, carry0));\\n\\t\\tif (!ok) assembly { revert(add(v, 32), mload(v)) }\\n\\t\\treturn lookupOnchain(node, abi.decode(abi.decode(v, (bytes)), (bytes[])));\\n\\t}\\n\\tfunction lookupOnchain(bytes32 node, bytes[] memory values) internal view returns (KV[] memory kv) {\\n\\t\\tunchecked {\\n\\t\\t\\tstring[] memory names = fieldNames();\\n\\t\\t\\tif (names.length != values.length) revert Modified();\\n\\t\\t\\tbytes[] memory calls = this.makeCalls(node);\\n\\t\\t\\taddress resolver = ENS(ENS_REGISTRY).resolver(node);\\n\\t\\t\\tuint256 n;\\n\\t\\t\\tkv = new KV[](values.length);\\n\\t\\t\\tfor (uint256 i; i < values.length; i += 1) {\\n\\t\\t\\t\\tbytes memory v = getTiny(SLOT_FIELDS + i);\\n\\t\\t\\t\\tuint256 kind = uint8(v[0]);\\n\\t\\t\\t\\tbool ok;\\n\\t\\t\\t\\tif (resolver != address(0)) { // if there is resolver\\n\\t\\t\\t\\t\\t(ok, v) = resolver.staticcall(calls[i]); // read record\\n\\t\\t\\t\\t\\tif (ok) {\\n\\t\\t\\t\\t\\t\\tif (v.length != 0 && (kind & KIND_FLAG_NO_DECODE) == 0) v = abi.decode(v, (bytes));\\n\\t\\t\\t\\t\\t\\tif (isNull(v)) ok = false; // only use if non-null\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!ok) { // no on-chain record, check ccip\\n\\t\\t\\t\\t\\tv = values[i];\\n\\t\\t\\t\\t\\tif (v.length != 0 && (kind & KIND_FLAG_NO_DECODE) == 0) v = abi.decode(v, (bytes));\\n\\t\\t\\t\\t\\tif (isNull(v)) continue; // skip kv if null\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tkv[n] = KV(names[i], (kind & KIND_FLAG_STRING) != 0 ? string(v) : toHex(v));\\n\\t\\t\\t\\tn += 1;\\n\\t\\t\\t}\\n\\t\\t\\tassembly { mstore(kv, n) } \\n\\t\\t}\\n\\t}\\n\\n\\t// utils\\n\\tfunction dns_from_ens(bytes memory ens) internal pure returns (bytes memory dns) {\\n\\t\\tunchecked {\\n\\t\\t\\t// \\\"aaa.bb.c\\\" => \\\"3a2b1c0\\\"\\n\\t\\t\\tuint256 n = ens.length;\\n\\t\\t\\tdns = new bytes(n + 2); // always 2 larger: [a.b  ] => [1a1b0]\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet p := add(ens, 32)\\n\\t\\t\\t\\tlet q := add(dns, 32)\\n\\t\\t\\t\\tlet r := q\\n\\t\\t\\t\\tfunction check(a, b) {\\n\\t\\t\\t\\t\\tlet w := sub(b, a)\\n\\t\\t\\t\\t\\tif or(eq(a, b), gt(w, 255)) { // empty or too long\\n\\t\\t\\t\\t\\t\\tlet x := mload(64)\\n\\t\\t\\t\\t\\t\\tmstore(x, 0x2bb9acf700000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\trevert(x, 4) // revert with BadInput()\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmstore8(a, w) // store length\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tfor { let i := 0 } lt(i, n) { i := add(i, 1) } {\\n\\t\\t\\t\\t\\tlet b := shr(248, mload(add(p, i)))\\n\\t\\t\\t\\t\\tif eq(b, 46) { // found a \\\".\\\"\\n\\t\\t\\t\\t\\t\\tcheck(r, q)\\n\\t\\t\\t\\t\\t\\tr := add(q, 1)\\n\\t\\t\\t\\t\\t} {\\n\\t\\t\\t\\t\\t\\tq := add(q, 1)\\n\\t\\t\\t\\t\\t\\tmstore8(q, b)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcheck(r, q)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction isNull(bytes memory v) internal pure returns (bool ret) {\\n\\t\\tassembly {\\n\\t\\t\\tlet p := add(v, 32)\\n\\t\\t\\tlet e := add(p, mload(v))\\n\\t\\t\\tfor { ret := true } lt(p, e) { p := add(p, 32) } {\\n\\t\\t\\t\\tif gt(mload(p), 0) { // assumes padded\\n\\t\\t\\t\\t\\tret := false\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tbytes32 constant HEX_TABLE = 0x3031323334353637383961626364656600000000000000000000000000000000;\\n\\tfunction toHex(bytes memory v) internal pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tbytes memory u = new bytes(2 + (v.length << 1));\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore8(add(u, 32), 0x30) // 0\\n\\t\\t\\t\\tmstore8(add(u, 33), 0x78) // x\\n\\t\\t\\t\\tlet i := v\\n\\t\\t\\t\\tlet e := add(i, mload(v))\\n\\t\\t\\t\\tlet j := add(u, 34)\\n\\t\\t\\t\\tfor {} lt(i, e) {} {\\n\\t\\t\\t\\t\\ti := add(i, 1) \\n\\t\\t\\t\\t\\tlet b := mload(i)\\n\\t\\t\\t\\t\\tmstore8(j, byte(and(shr(4, b), 15), HEX_TABLE))\\n\\t\\t\\t\\t\\tj := add(j, 1)\\n\\t\\t\\t\\t\\tmstore8(j, byte(and(b, 15), HEX_TABLE))\\n\\t\\t\\t\\t\\tj := add(j, 1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn string(u);\\n\\t\\t}\\n\\t}\\n\\n\\t// ************************************************************\\n\\t// TinyKV.sol: https://github.com/adraffy/TinyKV.sol\\n\\n\\t// header: first 4 bytes\\n\\t// [00000000_00000000000000000000000000000000000000000000000000000000] // null (0 slot)\\n\\t// [00000000_00000000000000000000000000000000000000000000000000000001] // empty (1 slot, hidden)\\n\\t// [00000001_XX000000000000000000000000000000000000000000000000000000] // 1 byte (1 slot)\\n\\t// [0000001C_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] // 28 bytes (1 slot\\n\\t// [0000001D_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX][XX000000...] // 29 bytes (2 slots)\\n\\tfunction tinySlots(uint256 size) internal pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn size != 0 ? (size + 35) >> 5 : 0; // ceil((4 + size) / 32)\\n\\t\\t}\\n\\t}\\n\\tfunction setTiny(uint256 slot, bytes memory v) internal {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 head;\\n\\t\\t\\tassembly { head := sload(slot) }\\n\\t\\t\\tuint256 size;\\n\\t\\t\\tassembly { size := mload(v) }\\n\\t\\t\\tuint256 n0 = tinySlots(head >> 224);\\n\\t\\t\\tuint256 n1 = tinySlots(size);\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\t// overwrite\\n\\t\\t\\t\\tif gt(n1, 0) {\\n\\t\\t\\t\\t\\tsstore(slot, or(shl(224, size), shr(32, mload(add(v, 32)))))\\n\\t\\t\\t\\t\\tlet ptr := add(v, 60)\\n\\t\\t\\t\\t\\tfor { let i := 1 } lt(i, n1) { i := add(i, 1) } {\\n\\t\\t\\t\\t\\t\\tsstore(add(slot, i), mload(ptr))\\n\\t\\t\\t\\t\\t\\tptr := add(ptr, 32)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// clear unused\\n\\t\\t\\t\\tfor { let i := n1 } lt(i, n0) { i := add(i, 1) } {\\n\\t\\t\\t\\t\\tsstore(add(slot, i), 0)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction getTiny(uint256 slot) internal view returns (bytes memory v) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 head;\\n\\t\\t\\tassembly { head := sload(slot) }\\n\\t\\t\\tuint256 size = head >> 224;\\n\\t\\t\\tif (size != 0) {\\n\\t\\t\\t\\tv = new bytes(size);\\n\\t\\t\\t\\tuint256 n = tinySlots(size);\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tmstore(add(v, 32), shl(32, head))\\n\\t\\t\\t\\t\\tlet p := add(v, 60)\\n\\t\\t\\t\\t\\tlet i := 1\\n\\t\\t\\t\\t\\tfor {} lt(i, n) {} {\\n\\t\\t\\t\\t\\t\\tmstore(p, sload(add(slot, i)))\\n\\t\\t\\t\\t\\t\\tp := add(p, 32)\\n\\t\\t\\t\\t\\t\\ti := add(i, 1)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\nlibrary BytesUtils {\\n    /*\\n     * @dev Returns the keccak-256 hash of a byte range.\\n     * @param self The byte string to hash.\\n     * @param offset The position to start hashing at.\\n     * @param len The number of bytes to hash.\\n     * @return The hash of the byte range.\\n     */\\n    function keccak(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the ENS namehash of a DNS-encoded name.\\n     * @param self The DNS-encoded name to hash.\\n     * @param offset The offset at which to start hashing.\\n     * @return The namehash of the name.\\n     */\\n    function namehash(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\n        if (labelhash == bytes32(0)) {\\n            require(offset == self.length - 1, \\\"namehash: Junk at end of name\\\");\\n            return bytes32(0);\\n        }\\n        return\\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\n     * @param self The byte string to read a label from.\\n     * @param idx The index to read a label at.\\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\n     * @return newIdx The index of the start of the next label.\\n     */\\n    function readLabel(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\\n        require(idx < self.length, \\\"readLabel: Index out of bounds\\\");\\n        uint256 len = uint256(uint8(self[idx]));\\n        if (len > 0) {\\n            labelhash = keccak(self, idx + 1, len);\\n        } else {\\n            labelhash = bytes32(0);\\n        }\\n        newIdx = idx + len + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n\\n    function multicallWithNodeCheck(\\n        bytes32,\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IContentHashResolver {\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IPubkeyResolver {\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n    event TextChanged(\\n        bytes32 indexed node,\\n        string indexed indexedKey,\\n        string key,\\n        string value\\n    );\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(\\n        bytes32 node,\\n        string calldata key\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the new (multicoin) addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.8.2/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.8.2/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BadInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Modified\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callback\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"carry\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"BasenameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FieldsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"fields\",\"type\":\"bytes[]\"}],\"name\":\"addFields\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fieldNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"}],\"name\":\"lookup\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"k\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"v\",\"type\":\"string\"}],\"internalType\":\"struct TNS.KV[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"carry\",\"type\":\"bytes\"}],\"name\":\"lookupCallback\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"k\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"v\",\"type\":\"string\"}],\"internalType\":\"struct TNS.KV[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"makeCalls\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"removeFieldAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setBasename\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"x\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TNS", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}