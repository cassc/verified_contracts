{"SourceCode": "// File: @chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n    * @dev Returns true if this contract implements the interface defined by\r\n    * `interfaceId`. See the corresponding\r\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n    * to learn more about how these ids are created.\r\n    *\r\n    * This function call must use less than 30 000 gas.\r\n    */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// End consumer library.\r\nlibrary Client {\r\n  struct EVMTokenAmount {\r\n    address token; // token address on the local chain.\r\n    uint256 amount; // Amount of tokens.\r\n  }\r\n\r\n  struct Any2EVMMessage {\r\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\r\n    uint64 sourceChainSelector; // Source chain selector.\r\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\r\n    bytes data; // payload sent in original message.\r\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\r\n  }\r\n\r\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\r\n  struct EVM2AnyMessage {\r\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\r\n    bytes data; // Data payload\r\n    EVMTokenAmount[] tokenAmounts; // Token transfers\r\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\r\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\r\n  }\r\n\r\n  // extraArgs will evolve to support new features\r\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\r\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\r\n  struct EVMExtraArgsV1 {\r\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\r\n    bool strict; // See strict sequencing details below.\r\n  }\r\n\r\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\r\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/// @notice Application contracts that intend to receive messages from\r\n/// the router should implement this interface.\r\ninterface IAny2EVMMessageReceiver {\r\n  /// @notice Called by the Router to deliver a message.\r\n  /// If this reverts, any token transfers also revert. The message\r\n  /// will move to a FAILED state and become available for manual execution.\r\n  /// @param message CCIP Message\r\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\r\n}\r\n\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\r\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\r\n  address internal immutable i_router;\r\n\r\n  constructor(address router) {\r\n    if (router == address(0)) revert InvalidRouter(address(0));\r\n    i_router = router;\r\n  }\r\n\r\n  /// @notice IERC165 supports an interfaceId\r\n  /// @param interfaceId The interfaceId to check\r\n  /// @return true if the interfaceId is supported\r\n  function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\r\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n  }\r\n\r\n  /// @inheritdoc IAny2EVMMessageReceiver\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\r\n    _ccipReceive(message);\r\n  }\r\n\r\n  /// @notice Override this function in your implementation.\r\n  /// @param message Any2EVMMessage\r\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\r\n\r\n  /////////////////////////////////////////////////////////////////////\r\n  // Plumbing\r\n  /////////////////////////////////////////////////////////////////////\r\n\r\n  /// @notice Return the current router\r\n  /// @return i_router address\r\n  function getRouter() public view returns (address) {\r\n    return address(i_router);\r\n  }\r\n\r\n  error InvalidRouter(address router);\r\n\r\n  /// @dev only calls from the set router are accepted.\r\n  modifier onlyRouter() {\r\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts/CCIP/Receiver.sol\r\n\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n/**\r\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\r\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\r\n * DO NOT USE THIS CODE IN PRODUCTION.\r\n */\r\n\r\n/// @title - A simple contract for receiving string data across chains.\r\ncontract Receiver is CCIPReceiver {\r\n    // Event emitted when a message is received from another chain.\r\n    event MessageReceived(\r\n        bytes32 indexed messageId, // The unique ID of the message.\r\n        uint64 indexed sourceChainSelector, // The chain selector of the source chain.\r\n        address sender, // The address of the sender from the source chain.\r\n        address user,\r\n        uint256 score // The text that was received.\r\n    );\r\n\r\n    bytes32 private lastReceivedMessageId; // Store the last received messageId.\r\n    // string private lastReceivedText; // Store the last received text.\r\n    uint256 private lastReceivedScore; // Store the last received text.\r\n\r\n    mapping(address=>uint256) private userScores;\r\n\r\n    /// @notice Constructor initializes the contract with the router address.\r\n    /// @param router The address of the router contract.\r\n    constructor(address router) CCIPReceiver(router) {}\r\n\r\n    /// handle a received message\r\n    function _ccipReceive(\r\n        Client.Any2EVMMessage memory any2EvmMessage\r\n    ) internal override {\r\n        lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\r\n        // lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text\r\n        \r\n        (address userAddress,uint256 score) = abi.decode(any2EvmMessage.data, (address,uint256));\r\n        // lastReceivedScore = score;\r\n         userScores[userAddress] = score;\r\n\r\n\r\n        emit MessageReceived(\r\n            any2EvmMessage.messageId,\r\n            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)\r\n            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,\r\n            userAddress,\r\n            score\r\n        );\r\n    }\r\n\r\n\r\n    // / @notice Fetches the details of the last received message.\r\n    // / @return messageId The ID of the last received message.\r\n    //// / @return text The last received text.\r\n    // function getLastReceivedMessageDetails()\r\n    //     external\r\n    //     view\r\n    //     returns (bytes32, uint256 )\r\n    // {\r\n    //     return (lastReceivedMessageId, lastReceivedScore);\r\n\r\n    // }\r\n\r\n\r\nfunction getScore(address userAddress) external view returns(uint256){\r\n\r\n        return userScores[userAddress];\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Receiver", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e561d5e02207fb5eb32cca20a699e0d8919a1476", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://00be72fe2c40159a2f8026946d47402754aece133628938e0c30c74429a1c4ce"}