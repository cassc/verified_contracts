{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/common/CommonEventsAndErrors.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (common/CommonEventsAndErrors.sol)\\n\\n/// @notice A collection of common errors thrown within the Temple contracts\\nlibrary CommonEventsAndErrors {\\n    error InsufficientBalance(address token, uint256 required, uint256 balance);\\n    error InvalidParam();\\n    error InvalidAddress();\\n    error InvalidAccess();\\n    error InvalidAmount(address token, uint256 amount);\\n    error ExpectedNonZero();\\n    error Unimplemented();\\n    event TokenRecovered(address indexed to, address indexed token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/v2/access/ITempleElevatedAccess.sol)\\n\\n/**\\n * @notice Inherit to add Executor and Rescuer roles for DAO elevated access.\\n */ \\ninterface ITempleElevatedAccess {\\n    event ExplicitAccessSet(address indexed account, bytes4 indexed fnSelector, bool indexed value);\\n    event RescueModeSet(bool indexed value);\\n\\n    event NewRescuerProposed(address indexed oldRescuer, address indexed oldProposedRescuer, address indexed newProposedRescuer);\\n    event NewRescuerAccepted(address indexed oldRescuer, address indexed newRescuer);\\n\\n    event NewExecutorProposed(address indexed oldExecutor, address indexed oldProposedExecutor, address indexed newProposedExecutor);\\n    event NewExecutorAccepted(address indexed oldExecutor, address indexed newExecutor);\\n\\n    struct ExplicitAccess {\\n        bytes4 fnSelector;\\n        bool allowed;\\n    }\\n\\n    /**\\n     * @notice A set of addresses which are approved to execute emergency operations.\\n     */ \\n    function rescuer() external returns (address);\\n\\n    /**\\n     * @notice A set of addresses which are approved to execute normal operations on behalf of the DAO.\\n     */ \\n    function executor() external returns (address);\\n\\n    /**\\n     * @notice Explicit approval for an address to execute a function.\\n     * allowedCaller => function selector => true/false\\n     */\\n    function explicitFunctionAccess(address contractAddr, bytes4 functionSelector) external returns (bool);\\n\\n    /**\\n     * @notice Under normal circumstances, rescuers don't have access to admin/operational functions.\\n     * However when rescue mode is enabled (by rescuers or executors), they claim the access rights.\\n     */\\n    function inRescueMode() external returns (bool);\\n    \\n    /**\\n     * @notice Set the contract into or out of rescue mode.\\n     * Only the rescuers or executors are allowed to set.\\n     */\\n    function setRescueMode(bool value) external;\\n\\n    /**\\n     * @notice Proposes a new Rescuer.\\n     * Can only be called by the current rescuer.\\n     */\\n    function proposeNewRescuer(address account) external;\\n\\n    /**\\n     * @notice Caller accepts the role as new Rescuer.\\n     * Can only be called by the proposed rescuer\\n     */\\n    function acceptRescuer() external;\\n\\n    /**\\n     * @notice Proposes a new Executor.\\n     * Can only be called by the current executor or resucer (if in resuce mode)\\n     */\\n    function proposeNewExecutor(address account) external;\\n\\n    /**\\n     * @notice Caller accepts the role as new Executor.\\n     * Can only be called by the proposed executor\\n     */\\n    function acceptExecutor() external;\\n\\n    /**\\n     * @notice Grant `allowedCaller` the rights to call the function selectors in the access list.\\n     * @dev fnSelector == bytes4(keccak256(\\\"fn(argType1,argType2,...)\\\"))\\n     */\\n    function setExplicitAccess(address allowedCaller, ExplicitAccess[] calldata access) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v2/circuitBreaker/ITempleCircuitBreaker.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/v2/circuitBreaker/ITempleCircuitBreaker.sol)\\n\\nimport { ITempleElevatedAccess } from \\\"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\\\";\\n\\n/**\\n * @title Temple Circuit Breaker\\n * \\n * @notice A circuit breaker can perform checks and record state for transactions which have\\n * already happened cumulative totals, totals within a rolling period window,\\n * sender specific totals, etc.\\n */\\ninterface ITempleCircuitBreaker is ITempleElevatedAccess {\\n\\n    /**\\n     * @notice Verify the new amount requested for the sender does not breach the\\n     * cap in this rolling period.\\n     */\\n    function preCheck(address onBehalfOf, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v2/access/TempleElevatedAccess.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (v2/access/TempleElevatedAccess.sol)\\n\\nimport { ITempleElevatedAccess } from \\\"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\\\";\\nimport { CommonEventsAndErrors } from \\\"contracts/common/CommonEventsAndErrors.sol\\\";\\n\\n/**\\n * @notice Inherit to add Executor and Rescuer roles for DAO elevated access.\\n */ \\nabstract contract TempleElevatedAccess is ITempleElevatedAccess {\\n    /**\\n     * @notice The address which is approved to execute emergency operations.\\n     */ \\n    address public override rescuer;\\n\\n    /**\\n     * @notice The address which is approved to execute normal operations on behalf of the DAO.\\n     */ \\n    address public override executor;\\n\\n    /**\\n     * @notice Explicit approval for an address to execute a function.\\n     * allowedCaller => function selector => true/false\\n     */\\n    mapping(address => mapping(bytes4 => bool)) public override explicitFunctionAccess;\\n\\n    /**\\n     * @notice Under normal circumstances, rescuers don't have access to admin/operational functions.\\n     * However when rescue mode is enabled (by rescuers or executors), they claim the access rights.\\n     */\\n    bool public override inRescueMode;\\n\\n    /// @dev Track proposed rescuer/executor\\n    address private _proposedNewRescuer;\\n    address private _proposedNewExecutor;\\n\\n    constructor(address initialRescuer, address initialExecutor) {\\n        if (initialRescuer == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        if (initialExecutor == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        if (initialExecutor == initialRescuer) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        rescuer = initialRescuer;\\n        executor = initialExecutor;\\n    }\\n\\n    /**\\n     * @notice Set the contract into or out of rescue mode.\\n     * Only the rescuers are allowed to set.\\n     */\\n    function setRescueMode(bool value) external override {\\n        if (msg.sender != rescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        emit RescueModeSet(value);\\n        inRescueMode = value;\\n    }\\n\\n    /**\\n     * @notice Proposes a new Rescuer.\\n     * Can only be called by the current rescuer.\\n     */\\n    function proposeNewRescuer(address account) external override {\\n        if (msg.sender != rescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        if (account == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        emit NewRescuerProposed(msg.sender, _proposedNewRescuer, account);\\n        _proposedNewRescuer = account;\\n    }\\n\\n    /**\\n     * @notice Caller accepts the role as new Rescuer.\\n     * Can only be called by the proposed rescuer\\n     */\\n    function acceptRescuer() external override {\\n        if (msg.sender != _proposedNewRescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        if (msg.sender == executor) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        emit NewRescuerAccepted(rescuer, msg.sender);\\n        rescuer = msg.sender;\\n        delete _proposedNewRescuer;\\n    }\\n\\n    /**\\n     * @notice Proposes a new Executor.\\n     * Can only be called by the current executor or rescuer (if in resuce mode)\\n     */\\n    function proposeNewExecutor(address account) external override onlyElevatedAccess {\\n        if (account == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        emit NewExecutorProposed(executor, _proposedNewExecutor, account);\\n        _proposedNewExecutor = account;\\n    }\\n\\n    /**\\n     * @notice Caller accepts the role as new Executor.\\n     * Can only be called by the proposed executor\\n     */\\n    function acceptExecutor() external override {\\n        if (msg.sender != _proposedNewExecutor) revert CommonEventsAndErrors.InvalidAccess();\\n        if (msg.sender == rescuer) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        emit NewExecutorAccepted(executor, msg.sender);\\n        executor = msg.sender;\\n        delete _proposedNewExecutor;\\n    }\\n\\n    /**\\n     * @notice Grant `allowedCaller` the rights to call the function selectors in the access list.\\n     * @dev fnSelector == bytes4(keccak256(\\\"fn(argType1,argType2,...)\\\"))\\n     */\\n    function setExplicitAccess(address allowedCaller, ExplicitAccess[] calldata access) external override onlyElevatedAccess {\\n        if (allowedCaller == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        uint256 _length = access.length;\\n        ExplicitAccess memory _access;\\n        for (uint256 i; i < _length; ++i) {\\n            _access = access[i];\\n            emit ExplicitAccessSet(allowedCaller, _access.fnSelector, _access.allowed);\\n            explicitFunctionAccess[allowedCaller][_access.fnSelector] = _access.allowed;\\n        }\\n    }\\n\\n    function isElevatedAccess(address caller, bytes4 fnSelector) internal view returns (bool) {\\n        if (inRescueMode) {\\n            // If we're in rescue mode, then only the rescuers can call\\n            return caller == rescuer;\\n        } else if (caller == executor || explicitFunctionAccess[caller][fnSelector]) {\\n            // If we're not in rescue mode, the executor can call all functions\\n            // or the caller has been given explicit access on this function\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Under normal operations, only the executors are allowed to call.\\n     * If 'rescue mode' has been enabled, then only the rescuers are allowed to call.\\n     * @dev Important: Only for use when called from an *external* contract. \\n     * If a function with this modifier is called internally then the `msg.sig` \\n     * will still refer to the top level externally called function.\\n     */\\n    modifier onlyElevatedAccess() {\\n        if (!isElevatedAccess(msg.sender, msg.sig)) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only the executors or rescuers can call.\\n     */\\n    modifier onlyInRescueMode() {\\n        if (!(inRescueMode && msg.sender == rescuer)) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n\\n    modifier notInRescueMode() {\\n        if (inRescueMode) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/circuitBreaker/TempleCircuitBreakerAllUsersPerPeriod.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (v2/circuitBreaker/TempleCircuitBreakerAllUsersPerPeriod.sol)\\n\\nimport { CommonEventsAndErrors } from \\\"contracts/common/CommonEventsAndErrors.sol\\\";\\nimport { TempleElevatedAccess } from \\\"contracts/v2/access/TempleElevatedAccess.sol\\\";\\nimport { ITempleCircuitBreaker } from \\\"contracts/interfaces/v2/circuitBreaker/ITempleCircuitBreaker.sol\\\";\\n\\n/* solhint-disable not-rely-on-time */\\n\\n/**\\n * @title Temple Circuit Breaker -- total volumes (across all users) in a rolling period window\\n * \\n * @notice No more than the cap can be borrowed within a `periodDuration` window. \\n * A slight nuance is that it will be slightly less than `periodDuration`, it also takes into account\\n * how many internal buckets are used - this is a tradeoff for gas efficiency.\\n * \\n * -- The tracking is split up into hourly buckets, so for a 24 hour window, we define 24 hourly buckets.\\n * -- When a new transaction is checked, it will roll forward by the required buckets (when it gets to 23 it will circle back from 0), cleaning up the buckets which are now > 24hrs in the past.\\n        If it's in the same hr as last time, then nothing to clean up\\n * -- Then adds the new volume into the bucket\\n * -- Then sums the buckets up and checks vs the cap, reverting if over.\\n\\n * This means that we only have to sum up 24 items.\\n\\n * The compromise is that the window we check for is going to be somewhere between 23hrs and 24hrs.\\n */\\ncontract TempleCircuitBreakerAllUsersPerPeriod is ITempleCircuitBreaker, TempleElevatedAccess {\\n    /**\\n     * @notice The duration of the rolling period window\\n     */\\n    uint32 public periodDuration;\\n\\n    /**\\n     * @notice The maximum allowed amount to be transacted within each period\\n     */\\n    uint128 public cap;\\n\\n    /**\\n     * @notice How many buckets to split the periodDuration into. \\n     * @dev A lower number of buckets means less gas will be used, however the rolling\\n     * window will change at the *start* of the bucket time.\\n     *   eg for a 24 hour `periodDuration`, with 24 (hourly) buckets, there could be a transaction\\n     *   for the cap at the 13:45:00, and again the next day 24 hours later at 13:05:00\\n     *   and this would be allowed.\\n     * A higher number of buckets means this wait time is less, however this will use more gas.\\n     * `nBuckets` must not be greater than `MAX_BUCKETS`, and must be a divisor of `periodDuration`\\n     */\\n    uint32 public nBuckets;\\n\\n    /**\\n     * @notice The derived length of time in each bucket\\n     */\\n    uint32 public secondsPerBucket;\\n\\n    /**\\n     * @notice The current bucket index.\\n     * @dev The first bucket starts at 1-1-1970\\n     */\\n    uint32 public bucketIndex;\\n\\n    /**\\n     * @notice The maxiumum number of buckets that can be used\\n     */\\n    uint32 public constant MAX_BUCKETS = 4000;\\n\\n    /**\\n     * @notice The total amount of volume tracked within each bucket\\n     */\\n    uint256[MAX_BUCKETS] public buckets;\\n\\n    event ConfigSet(uint32 periodDuration, uint32 nBuckets, uint128 cap);\\n    event CapSet(uint128 cap);\\n    error CapBreached(uint256 totalRequested, uint128 cap);\\n\\n    constructor(\\n        address _initialRescuer,\\n        address _initialExecutor,\\n        uint32 _periodDuration,\\n        uint32 _nBuckets,\\n        uint128 _cap\\n    ) TempleElevatedAccess(_initialRescuer, _initialExecutor) {\\n        _setConfig(_periodDuration, _nBuckets, _cap);\\n    }\\n\\n    /**\\n     * @notice Verify the new amount requested does not breach the cap in this rolling period.\\n     */\\n    function preCheck(address /*onBehalfOf*/, uint256 amount) external override onlyElevatedAccess {\\n        uint32 _nextBucketIndex = uint32(block.timestamp / secondsPerBucket);\\n        uint32 _currentBucketIndex = bucketIndex;\\n        uint32 _nBuckets = nBuckets;\\n        \\n        // If this time bucket is different to the last one\\n        // then delete any buckets in between first - since that is old data\\n        if (_nextBucketIndex != _currentBucketIndex) {\\n            uint256 _minBucketResetIndex = _getMinBucketResetIndex(_nBuckets, _currentBucketIndex, _nextBucketIndex);\\n\\n            unchecked {\\n                for (; _minBucketResetIndex < _nextBucketIndex; ++_minBucketResetIndex) {\\n                    // Set to dust\\n                    buckets[(_minBucketResetIndex+1) % _nBuckets] = 1;\\n                }\\n            }\\n\\n            bucketIndex = _nextBucketIndex;\\n        }\\n\\n        uint256 _newUtilisation = _currentUtilisation(_nBuckets) + amount;\\n        if (_newUtilisation > cap) revert CapBreached(_newUtilisation, cap);\\n\\n        // Unchecked is safe since we know the total new utilisation is under the cap.\\n        unchecked {\\n            // slither-disable-next-line weak-prng\\n            buckets[_nextBucketIndex % _nBuckets] += amount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the duration, buckets and cap. This will reset the clock for any totals\\n     * added since in the new periodDuration.\\n     * @dev Since this resets the buckets, it should be executed via flashbots protect\\n     * such that it can't be frontrun (where the caps could be filled twice)\\n     */\\n    function setConfig(uint32 _periodDuration, uint32 _nBuckets, uint128 _cap) external onlyElevatedAccess {\\n        _setConfig(_periodDuration, _nBuckets, _cap);\\n    }\\n\\n    /**\\n     * @notice Update the cap for this circuit breaker\\n     */\\n    function updateCap(uint128 newCap) external onlyElevatedAccess {\\n        cap = newCap;\\n        emit CapSet(newCap);\\n    }\\n\\n    /**\\n     * @dev Find the earliest time bucket which needs to be reset, based on the number of buckets per duration.\\n     */\\n    function _getMinBucketResetIndex(uint32 _nBuckets, uint32 _currentBucketIndex, uint32 _nextBucketIndex) internal pure returns (uint256 minBucketResetIndex) {\\n        unchecked {\\n            uint32 _oneperiodDurationAgoIndex = _nextBucketIndex - _nBuckets;\\n            minBucketResetIndex = _currentBucketIndex < _oneperiodDurationAgoIndex ? _oneperiodDurationAgoIndex : _currentBucketIndex;\\n        }\\n    }\\n\\n    /**\\n     * @notice What is the total utilisation so far in this `periodDuration`\\n     */\\n    function currentUtilisation() external view returns (uint256 amount) {\\n        uint32 _nextBucketIndex = uint32(block.timestamp / secondsPerBucket);\\n        uint32 _currentBucketIndex = bucketIndex;\\n        uint32 _nBuckets = nBuckets;\\n        \\n        uint256 utilisation = _currentUtilisation(_nBuckets);\\n\\n        // If the bucket index has moved forward since the last `preCheck()`, \\n        // remove any amounts from buckets which would be otherwise reset\\n        if (_nextBucketIndex != _currentBucketIndex) {\\n            uint256 _minBucketResetIndex = _getMinBucketResetIndex(_nBuckets, _currentBucketIndex, _nextBucketIndex);\\n            unchecked {\\n                for (; _minBucketResetIndex < _nextBucketIndex; ++_minBucketResetIndex) {\\n                    utilisation -= buckets[(_minBucketResetIndex+1) % _nBuckets] - 1;\\n                }\\n            }\\n        }\\n\\n        return utilisation;\\n    }\\n\\n    function _currentUtilisation(uint32 _nBuckets) internal view returns (uint256 amount) {\\n        // Unchecked is safe here because we know previous entries are under the cap.\\n        unchecked {\\n            for (uint256 i; i < _nBuckets; ++i) {\\n                amount += buckets[i];\\n            }\\n\\n            // Remove the dust\\n            amount -= _nBuckets;\\n        }\\n    }\\n\\n    function _setConfig(uint32 _periodDuration, uint32 _nBuckets, uint128 _cap) internal {\\n        if (_periodDuration == 0) revert CommonEventsAndErrors.ExpectedNonZero();\\n        if (_periodDuration % _nBuckets > 0) revert CommonEventsAndErrors.InvalidParam();\\n        if (_nBuckets > MAX_BUCKETS) revert CommonEventsAndErrors.InvalidParam();\\n\\n        nBuckets = _nBuckets;\\n        periodDuration = _periodDuration;\\n        secondsPerBucket = _periodDuration / _nBuckets;\\n        cap = _cap;\\n        bucketIndex = 0;\\n\\n        // No need to clear all buckets - they won't be used until they're required\\n        // at which point they'll too be cleared.\\n        unchecked {\\n            for (uint256 i = 0; i < _nBuckets; ++i) {\\n                // Set to a non-zero dust amount\\n                buckets[i] = 1;\\n            }\\n        }\\n\\n        emit ConfigSet(_periodDuration, _nBuckets, _cap);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialRescuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initialExecutor\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_periodDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nBuckets\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"_cap\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"cap\",\"type\":\"uint128\"}],\"name\":\"CapBreached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedNonZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAccess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"cap\",\"type\":\"uint128\"}],\"name\":\"CapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"periodDuration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nBuckets\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"cap\",\"type\":\"uint128\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"ExplicitAccessSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"NewExecutorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProposedExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposedExecutor\",\"type\":\"address\"}],\"name\":\"NewExecutorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"NewRescuerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProposedRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposedRescuer\",\"type\":\"address\"}],\"name\":\"NewRescuerProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"RescueModeSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_BUCKETS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bucketIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentUtilisation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"explicitFunctionAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inRescueMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nBuckets\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"preCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeNewExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeNewRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescuer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsPerBucket\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_periodDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nBuckets\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"_cap\",\"type\":\"uint128\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allowedCaller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"internalType\":\"struct ITempleElevatedAccess.ExplicitAccess[]\",\"name\":\"access\",\"type\":\"tuple[]\"}],\"name\":\"setExplicitAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setRescueMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newCap\",\"type\":\"uint128\"}],\"name\":\"updateCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TempleCircuitBreakerAllUsersPerPeriod", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000009f90430179d9b67341bfa50559bc7b8e35629f1b000000000000000000000000b1e8ab0a81aadf632a653e46caeda1593d71d1430000000000000000000000000000000000000000000000000000000000016da0000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000013da329b6336471800000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}