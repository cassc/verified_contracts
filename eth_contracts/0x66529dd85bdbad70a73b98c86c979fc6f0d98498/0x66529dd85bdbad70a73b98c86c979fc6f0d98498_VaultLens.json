{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Lens/VaultLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IRewardStreams} from \\\"reward-streams/interfaces/IRewardStreams.sol\\\";\\nimport {IEVault} from \\\"evk/EVault/IEVault.sol\\\";\\nimport {IIRM, IRMLinearKink} from \\\"evk/InterestRateModels/IRMLinearKink.sol\\\";\\nimport {IPriceOracle} from \\\"evk/interfaces/IPriceOracle.sol\\\";\\nimport {OracleLens} from \\\"./OracleLens.sol\\\";\\nimport {Utils} from \\\"./Utils.sol\\\";\\nimport \\\"evk/EVault/shared/types/AmountCap.sol\\\";\\nimport \\\"./LensTypes.sol\\\";\\n\\ncontract VaultLens is Utils {\\n    address internal constant USD = address(840);\\n\\n    OracleLens public immutable oracleLens;\\n\\n    constructor(address _oracleLens) {\\n        oracleLens = OracleLens(_oracleLens);\\n    }\\n\\n    function getVaultInfoSimple(address vault) public view returns (VaultInfoSimple memory) {\\n        VaultInfoSimple memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.vault = vault;\\n        result.vaultName = IEVault(vault).name();\\n        result.vaultSymbol = IEVault(vault).symbol();\\n        result.vaultDecimals = IEVault(vault).decimals();\\n\\n        result.asset = IEVault(vault).asset();\\n        result.assetDecimals = _getDecimals(result.asset);\\n\\n        result.unitOfAccount = IEVault(vault).unitOfAccount();\\n        result.unitOfAccountDecimals = _getDecimals(result.unitOfAccount);\\n\\n        result.totalShares = IEVault(vault).totalSupply();\\n        result.totalCash = IEVault(vault).cash();\\n        result.totalBorrowed = IEVault(vault).totalBorrows();\\n        result.totalAssets = IEVault(vault).totalAssets();\\n\\n        result.oracle = IEVault(vault).oracle();\\n        result.governorAdmin = IEVault(vault).governorAdmin();\\n\\n        uint256[] memory cash = new uint256[](1);\\n        uint256[] memory borrows = new uint256[](1);\\n        cash[0] = result.totalCash;\\n        borrows[0] = result.totalBorrowed;\\n        result.irmInfo = getVaultInterestRateModelInfo(vault, cash, borrows);\\n\\n        result.collateralLTVInfo = getRecognizedCollateralsLTVInfo(vault);\\n\\n        result.liabilityPriceInfo = getControllerAssetPriceInfo(vault, result.asset);\\n\\n        result.collateralPriceInfo = new AssetPriceInfo[](result.collateralLTVInfo.length);\\n\\n        for (uint256 i = 0; i < result.collateralLTVInfo.length; ++i) {\\n            result.collateralPriceInfo[i] = getControllerAssetPriceInfo(vault, result.collateralLTVInfo[i].collateral);\\n        }\\n\\n        address[] memory bases = new address[](result.collateralLTVInfo.length + 1);\\n        bases[0] = result.asset;\\n        for (uint256 i = 0; i < result.collateralLTVInfo.length; ++i) {\\n            bases[i + 1] = result.collateralLTVInfo[i].collateral;\\n            result.collateralPriceInfo[i] = getControllerAssetPriceInfo(vault, result.collateralLTVInfo[i].collateral);\\n        }\\n\\n        result.oracleInfo = oracleLens.getOracleInfo(result.oracle, bases, result.unitOfAccount);\\n\\n        if (result.oracle == address(0)) {\\n            address unitOfAccount = result.unitOfAccount == address(0) ? USD : result.unitOfAccount;\\n            result.backupAssetPriceInfo = getAssetPriceInfo(result.asset, unitOfAccount);\\n\\n            bases = new address[](1);\\n            bases[0] = result.asset;\\n            result.backupAssetOracleInfo =\\n                oracleLens.getOracleInfo(result.backupAssetPriceInfo.oracle, bases, unitOfAccount);\\n        }\\n\\n        return result;\\n    }\\n\\n    function getVaultInfoFull(address vault) public view returns (VaultInfoFull memory) {\\n        VaultInfoFull memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.vault = vault;\\n        result.vaultName = IEVault(vault).name();\\n        result.vaultSymbol = IEVault(vault).symbol();\\n        result.vaultDecimals = IEVault(vault).decimals();\\n\\n        result.asset = IEVault(vault).asset();\\n        result.assetName = _getStringOrBytes32(result.asset, IEVault(vault).name.selector);\\n        result.assetSymbol = _getStringOrBytes32(result.asset, IEVault(vault).symbol.selector);\\n        result.assetDecimals = _getDecimals(result.asset);\\n\\n        result.unitOfAccount = IEVault(vault).unitOfAccount();\\n        result.unitOfAccountName = _getStringOrBytes32(result.unitOfAccount, IEVault(vault).name.selector);\\n        result.unitOfAccountSymbol = _getStringOrBytes32(result.unitOfAccount, IEVault(vault).symbol.selector);\\n        result.unitOfAccountDecimals = _getDecimals(result.unitOfAccount);\\n\\n        result.totalShares = IEVault(vault).totalSupply();\\n        result.totalCash = IEVault(vault).cash();\\n        result.totalBorrowed = IEVault(vault).totalBorrows();\\n        result.totalAssets = IEVault(vault).totalAssets();\\n\\n        result.accumulatedFeesShares = IEVault(vault).accumulatedFees();\\n        result.accumulatedFeesAssets = IEVault(vault).accumulatedFeesAssets();\\n\\n        result.governorFeeReceiver = IEVault(vault).feeReceiver();\\n        result.protocolFeeReceiver = IEVault(vault).protocolFeeReceiver();\\n        result.protocolFeeShare = IEVault(vault).protocolFeeShare();\\n        result.interestFee = IEVault(vault).interestFee();\\n\\n        (result.hookTarget, result.hookedOperations) = IEVault(vault).hookConfig();\\n        result.configFlags = IEVault(vault).configFlags();\\n\\n        result.maxLiquidationDiscount = IEVault(vault).maxLiquidationDiscount();\\n        result.liquidationCoolOffTime = IEVault(vault).liquidationCoolOffTime();\\n\\n        (result.supplyCap, result.borrowCap) = IEVault(vault).caps();\\n        result.supplyCap = AmountCapLib.resolve(AmountCap.wrap(uint16(result.supplyCap)));\\n        result.borrowCap = AmountCapLib.resolve(AmountCap.wrap(uint16(result.borrowCap)));\\n\\n        result.dToken = IEVault(vault).dToken();\\n        result.oracle = IEVault(vault).oracle();\\n        result.interestRateModel = IEVault(vault).interestRateModel();\\n\\n        result.evc = IEVault(vault).EVC();\\n        result.protocolConfig = IEVault(vault).protocolConfigAddress();\\n        result.balanceTracker = IEVault(vault).balanceTrackerAddress();\\n        result.permit2 = IEVault(vault).permit2Address();\\n\\n        result.creator = IEVault(vault).creator();\\n        result.governorAdmin = IEVault(vault).governorAdmin();\\n\\n        uint256[] memory cash = new uint256[](1);\\n        uint256[] memory borrows = new uint256[](1);\\n        cash[0] = result.totalCash;\\n        borrows[0] = result.totalBorrowed;\\n        result.irmInfo = getVaultInterestRateModelInfo(vault, cash, borrows);\\n\\n        result.collateralLTVInfo = getRecognizedCollateralsLTVInfo(vault);\\n\\n        result.liabilityPriceInfo = getControllerAssetPriceInfo(vault, result.asset);\\n\\n        result.collateralPriceInfo = new AssetPriceInfo[](result.collateralLTVInfo.length);\\n\\n        address[] memory bases = new address[](result.collateralLTVInfo.length + 1);\\n        bases[0] = result.asset;\\n        for (uint256 i = 0; i < result.collateralLTVInfo.length; ++i) {\\n            bases[i + 1] = result.collateralLTVInfo[i].collateral;\\n            result.collateralPriceInfo[i] = getControllerAssetPriceInfo(vault, result.collateralLTVInfo[i].collateral);\\n        }\\n\\n        result.oracleInfo = oracleLens.getOracleInfo(result.oracle, bases, result.unitOfAccount);\\n\\n        if (result.oracle == address(0)) {\\n            address unitOfAccount = result.unitOfAccount == address(0) ? USD : result.unitOfAccount;\\n            result.backupAssetPriceInfo = getAssetPriceInfo(result.asset, unitOfAccount);\\n\\n            bases = new address[](1);\\n            bases[0] = result.asset;\\n            result.backupAssetOracleInfo =\\n                oracleLens.getOracleInfo(result.backupAssetPriceInfo.oracle, bases, unitOfAccount);\\n        }\\n\\n        return result;\\n    }\\n\\n    function getRewardVaultInfo(address vault, address reward, uint256 numberOfEpochs)\\n        public\\n        view\\n        returns (VaultRewardInfo memory)\\n    {\\n        VaultRewardInfo memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.vault = vault;\\n        result.reward = reward;\\n        result.rewardName = _getStringOrBytes32(result.reward, IEVault(vault).name.selector);\\n        result.rewardSymbol = _getStringOrBytes32(result.reward, IEVault(vault).symbol.selector);\\n        result.rewardDecimals = _getDecimals(result.reward);\\n        result.balanceTracker = IEVault(vault).balanceTrackerAddress();\\n\\n        if (result.balanceTracker == address(0)) return result;\\n\\n        result.epochDuration = IRewardStreams(result.balanceTracker).EPOCH_DURATION();\\n        result.currentEpoch = IRewardStreams(result.balanceTracker).currentEpoch();\\n        result.totalRewardedEligible = IRewardStreams(result.balanceTracker).totalRewardedEligible(vault, reward);\\n        result.totalRewardRegistered = IRewardStreams(result.balanceTracker).totalRewardRegistered(vault, reward);\\n        result.totalRewardClaimed = IRewardStreams(result.balanceTracker).totalRewardClaimed(vault, reward);\\n\\n        result.epochInfoPrevious = new RewardAmountInfo[](numberOfEpochs);\\n        result.epochInfoUpcoming = new RewardAmountInfo[](numberOfEpochs);\\n\\n        for (uint256 i; i < 2 * numberOfEpochs; ++i) {\\n            uint48 epoch = uint48(result.currentEpoch - numberOfEpochs + i);\\n\\n            if (i < numberOfEpochs) {\\n                uint256 index = i;\\n\\n                result.epochInfoPrevious[index].epoch = epoch;\\n\\n                result.epochInfoPrevious[index].epochStart =\\n                    IRewardStreams(result.balanceTracker).getEpochStartTimestamp(epoch);\\n\\n                result.epochInfoPrevious[index].epochEnd =\\n                    IRewardStreams(result.balanceTracker).getEpochEndTimestamp(epoch);\\n\\n                result.epochInfoPrevious[index].rewardAmount =\\n                    IRewardStreams(result.balanceTracker).rewardAmount(vault, reward, epoch);\\n            } else {\\n                uint256 index = i - numberOfEpochs;\\n\\n                result.epochInfoUpcoming[index].epoch = epoch;\\n\\n                result.epochInfoUpcoming[index].epochStart =\\n                    IRewardStreams(result.balanceTracker).getEpochStartTimestamp(epoch);\\n\\n                result.epochInfoUpcoming[index].epochEnd =\\n                    IRewardStreams(result.balanceTracker).getEpochEndTimestamp(epoch);\\n\\n                result.epochInfoUpcoming[index].rewardAmount =\\n                    IRewardStreams(result.balanceTracker).rewardAmount(vault, reward, epoch);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function getRecognizedCollateralsLTVInfo(address vault) public view returns (LTVInfo[] memory) {\\n        address[] memory collaterals = IEVault(vault).LTVList();\\n        LTVInfo[] memory ltvInfo = new LTVInfo[](collaterals.length);\\n        uint256 numberOfRecognizedCollaterals = 0;\\n\\n        for (uint256 i = 0; i < collaterals.length; ++i) {\\n            ltvInfo[i].collateral = collaterals[i];\\n\\n            (\\n                ltvInfo[i].borrowLTV,\\n                ltvInfo[i].liquidationLTV,\\n                ltvInfo[i].initialLiquidationLTV,\\n                ltvInfo[i].targetTimestamp,\\n                ltvInfo[i].rampDuration\\n            ) = IEVault(vault).LTVFull(collaterals[i]);\\n\\n            if (ltvInfo[i].targetTimestamp != 0) {\\n                ++numberOfRecognizedCollaterals;\\n            }\\n        }\\n\\n        LTVInfo[] memory collateralLTVInfo = new LTVInfo[](numberOfRecognizedCollaterals);\\n\\n        for (uint256 i = 0; i < collaterals.length; ++i) {\\n            if (ltvInfo[i].targetTimestamp != 0) {\\n                collateralLTVInfo[i] = ltvInfo[i];\\n            }\\n        }\\n\\n        return collateralLTVInfo;\\n    }\\n\\n    function getVaultInterestRateModelInfo(address vault, uint256[] memory cash, uint256[] memory borrows)\\n        public\\n        view\\n        returns (VaultInterestRateModelInfo memory)\\n    {\\n        require(cash.length == borrows.length, \\\"EVaultLens: invalid input\\\");\\n\\n        VaultInterestRateModelInfo memory result;\\n\\n        result.vault = vault;\\n        result.interestRateModel = IEVault(vault).interestRateModel();\\n\\n        if (result.interestRateModel == address(0)) {\\n            result.queryFailure = true;\\n            return result;\\n        }\\n\\n        uint256 interestFee = IEVault(vault).interestFee();\\n        result.interestRateInfo = new InterestRateInfo[](cash.length);\\n\\n        for (uint256 i = 0; i < cash.length; ++i) {\\n            (bool success, bytes memory data) = result.interestRateModel.staticcall(\\n                abi.encodeCall(IIRM.computeInterestRateView, (vault, cash[i], borrows[i]))\\n            );\\n\\n            if (!success || data.length < 32) {\\n                result.queryFailure = true;\\n                result.queryFailureReason = data;\\n                break;\\n            }\\n\\n            result.interestRateInfo[i].cash = cash[i];\\n            result.interestRateInfo[i].borrows = borrows[i];\\n            result.interestRateInfo[i].borrowSPY = abi.decode(data, (uint256));\\n\\n            result.interestRateInfo[i].supplySPY =\\n                _computeSupplySPY(result.interestRateInfo[i].borrowSPY, cash[i], borrows[i], interestFee);\\n\\n            (result.interestRateInfo[i].borrowAPY, result.interestRateInfo[i].supplyAPY) =\\n                _computeAPYs(result.interestRateInfo[i].borrowSPY, result.interestRateInfo[i].supplySPY);\\n        }\\n\\n        return result;\\n    }\\n\\n    function getVaultKinkInterestRateModelInfo(address vault)\\n        public\\n        view\\n        returns (VaultInterestRateModelInfo memory, KinkInterestRateModelInfo memory)\\n    {\\n        address interestRateModel = IEVault(vault).interestRateModel();\\n\\n        if (interestRateModel == address(0)) {\\n            VaultInterestRateModelInfo memory result1;\\n            KinkInterestRateModelInfo memory result2;\\n            result1.vault = vault;\\n            return (result1, result2);\\n        }\\n\\n        KinkInterestRateModelInfo memory kinkIRMInfo = KinkInterestRateModelInfo({\\n            interestRateModel: interestRateModel,\\n            baseRate: IRMLinearKink(interestRateModel).baseRate(),\\n            slope1: IRMLinearKink(interestRateModel).slope1(),\\n            slope2: IRMLinearKink(interestRateModel).slope2(),\\n            kink: IRMLinearKink(interestRateModel).kink()\\n        });\\n\\n        uint256[] memory cash = new uint256[](3);\\n        uint256[] memory borrows = new uint256[](3);\\n\\n        cash[0] = type(uint32).max;\\n        cash[1] = type(uint32).max - kinkIRMInfo.kink;\\n        cash[2] = 0;\\n        borrows[0] = 0;\\n        borrows[1] = kinkIRMInfo.kink;\\n        borrows[2] = type(uint32).max;\\n\\n        return (getVaultInterestRateModelInfo(vault, cash, borrows), kinkIRMInfo);\\n    }\\n\\n    function getControllerAssetPriceInfo(address controller, address asset)\\n        public\\n        view\\n        returns (AssetPriceInfo memory)\\n    {\\n        AssetPriceInfo memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.oracle = IEVault(controller).oracle();\\n        result.asset = asset;\\n        result.unitOfAccount = IEVault(controller).unitOfAccount();\\n\\n        result.amountIn = 10 ** _getDecimals(asset);\\n\\n        if (result.oracle == address(0)) {\\n            result.queryFailure = true;\\n            return result;\\n        }\\n\\n        (bool success, bytes memory data) = result.oracle.staticcall(\\n            abi.encodeCall(IPriceOracle.getQuote, (result.amountIn, asset, result.unitOfAccount))\\n        );\\n\\n        if (success && data.length >= 32) {\\n            result.amountOutMid = abi.decode(data, (uint256));\\n        } else {\\n            result.queryFailure = true;\\n            result.queryFailureReason = data;\\n        }\\n\\n        (success, data) = result.oracle.staticcall(\\n            abi.encodeCall(IPriceOracle.getQuotes, (result.amountIn, asset, result.unitOfAccount))\\n        );\\n\\n        if (success && data.length >= 64) {\\n            (result.amountOutBid, result.amountOutAsk) = abi.decode(data, (uint256, uint256));\\n        } else {\\n            result.queryFailure = true;\\n        }\\n\\n        return result;\\n    }\\n\\n    function getAssetPriceInfo(address asset, address unitOfAccount) public view returns (AssetPriceInfo memory) {\\n        AssetPriceInfo memory result;\\n\\n        result.timestamp = block.timestamp;\\n\\n        result.asset = asset;\\n        result.unitOfAccount = unitOfAccount;\\n\\n        result.amountIn = 10 ** _getDecimals(asset);\\n\\n        address[] memory adapters = oracleLens.getValidAdapters(asset, unitOfAccount);\\n\\n        if (adapters.length == 0) {\\n            result.queryFailure = true;\\n            return result;\\n        }\\n\\n        for (uint256 i = 0; i < adapters.length; ++i) {\\n            result.oracle = adapters[i];\\n\\n            (bool success, bytes memory data) =\\n                result.oracle.staticcall(abi.encodeCall(IPriceOracle.getQuote, (result.amountIn, asset, unitOfAccount)));\\n\\n            if (success && data.length >= 32) {\\n                result.amountOutMid = result.amountOutBid = result.amountOutAsk = abi.decode(data, (uint256));\\n            } else {\\n                result.queryFailure = true;\\n                result.queryFailureReason = data;\\n            }\\n\\n            if (!result.queryFailure) break;\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/reward-streams/src/interfaces/IRewardStreams.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IBalanceTracker.sol\\\";\\n\\n/// @title IRewardStreams\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface for Reward Streams distributor contract.\\ninterface IRewardStreams {\\n    function EPOCH_DURATION() external view returns (uint256);\\n    function MAX_EPOCHS_AHEAD() external view returns (uint256);\\n    function MAX_DISTRIBUTION_LENGTH() external view returns (uint256);\\n    function MAX_REWARDS_ENABLED() external view returns (uint256);\\n    function registerReward(address rewarded, address reward, uint48 startEpoch, uint128[] calldata rewardAmounts) external;\\n    function updateReward(address rewarded, address reward, address recipient) external returns (uint256);\\n    function claimReward(address rewarded, address reward, address recipient, bool ignoreRecentReward) external returns (uint256);\\n    function enableReward(address rewarded, address reward) external returns (bool);\\n    function disableReward(address rewarded, address reward, bool forfeitRecentReward) external returns (bool);\\n    function earnedReward(address account, address rewarded, address reward, bool ignoreRecentReward) external view returns (uint256);\\n    function enabledRewards(address account, address rewarded) external view returns (address[] memory);\\n    function isRewardEnabled(address account, address rewarded, address reward) external view returns (bool);\\n    function balanceOf(address account, address rewarded) external view returns (uint256);\\n    function rewardAmount(address rewarded, address reward) external view returns (uint256);\\n    function totalRewardedEligible(address rewarded, address reward) external view returns (uint256);\\n    function totalRewardRegistered(address rewarded, address reward) external view returns (uint256);\\n    function totalRewardClaimed(address rewarded, address reward) external view returns (uint256);\\n    function rewardAmount(address rewarded, address reward, uint48 epoch) external view returns (uint256);\\n    function currentEpoch() external view returns (uint48);\\n    function getEpoch(uint48 timestamp) external view returns (uint48);\\n    function getEpochStartTimestamp(uint48 epoch) external view returns (uint48);\\n    function getEpochEndTimestamp(uint48 epoch) external view returns (uint48);\\n}\\n\\n/// @title ITrackingRewardStreams\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface for Tracking Reward Streams. Extends `IRewardStreams` and `IBalanceTracker`.\\ninterface ITrackingRewardStreams is IRewardStreams, IBalanceTracker {}\\n\\n/// @title IStakingRewardStreams\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface for Staking Reward Streams. Extends `IRewardStreams` with staking functionality.\\ninterface IStakingRewardStreams is IRewardStreams {\\n    function stake(address rewarded, uint256 amount) external;\\n    function unstake(address rewarded, uint256 amount, address recipient, bool forfeitRecentReward) external;\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/IEVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport {IVault as IEVCVault} from \\\"ethereum-vault-connector/interfaces/IVault.sol\\\";\\n\\n// Full interface of EVault and all it's modules\\n\\n/// @title IInitialize\\n/// @notice Interface of the initialization module of EVault\\ninterface IInitialize {\\n    /// @notice Initialization of the newly deployed proxy contract\\n    /// @param proxyCreator Account which created the proxy or should be the initial governor\\n    function initialize(address proxyCreator) external;\\n}\\n\\n/// @title IERC20\\n/// @notice Interface of the EVault's Initialize module\\ninterface IERC20 {\\n    /// @notice Vault share token (eToken) name, ie \\\"Euler Vault: DAI\\\"\\n    /// @return The name of the eToken\\n    function name() external view returns (string memory);\\n\\n    /// @notice Vault share token (eToken) symbol, ie \\\"eDAI\\\"\\n    /// @return The symbol of the eToken\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Decimals, the same as the asset's or 18 if the asset doesn't implement `decimals()`\\n    /// @return The decimals of the eToken\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Sum of all eToken balances\\n    /// @return The total supply of the eToken\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Balance of a particular account, in eTokens\\n    /// @param account Address to query\\n    /// @return The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieve the current allowance\\n    /// @param holder The account holding the eTokens\\n    /// @param spender Trusted address\\n    /// @return The allowance from holder for spender\\n    function allowance(address holder, address spender) external view returns (uint256);\\n\\n    /// @notice Transfer eTokens to another address\\n    /// @param to Recipient account\\n    /// @param amount In shares.\\n    /// @return True if transfer succeeded\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfer eTokens from one address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @param amount In shares\\n    /// @return True if transfer succeeded\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Allow spender to access an amount of your eTokens\\n    /// @param spender Trusted address\\n    /// @param amount Use max uint for \\\"infinite\\\" allowance\\n    /// @return True if approval succeeded\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\n/// @title IToken\\n/// @notice Interface of the EVault's Token module\\ninterface IToken is IERC20 {\\n    /// @notice Transfer the full eToken balance of an address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @return True if transfer succeeded\\n    function transferFromMax(address from, address to) external returns (bool);\\n}\\n\\n/// @title IERC4626\\n/// @notice Interface of an ERC4626 vault\\ninterface IERC4626 {\\n    /// @notice Vault's underlying asset\\n    /// @return The vault's underlying asset\\n    function asset() external view returns (address);\\n\\n    /// @notice Total amount of managed assets, cash and borrows\\n    /// @return The total amount of assets\\n    function totalAssets() external view returns (uint256);\\n\\n    /// @notice Calculate amount of assets corresponding to the requested shares amount\\n    /// @param shares Amount of shares to convert\\n    /// @return The amount of assets\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Calculate amount of shares corresponding to the requested assets amount\\n    /// @param assets Amount of assets to convert\\n    /// @return The amount of shares\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user can deposit\\n    /// @param account Address to query\\n    /// @return The max amount of assets the account can deposit\\n    function maxDeposit(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of shares that would be created by depositing assets\\n    /// @param assets Amount of assets deposited\\n    /// @return Amount of shares received\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user can mint\\n    /// @param account Address to query\\n    /// @return The max amount of shares the account can mint\\n    function maxMint(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of assets that would be required to mint requested amount of shares\\n    /// @param shares Amount of shares to be minted\\n    /// @return Required amount of assets\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user is allowed to withdraw\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of assets the owner is allowed to withdraw\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of shares that will be burned when withdrawing requested amount of assets\\n    /// @param assets Amount of assets withdrawn\\n    /// @return Amount of shares burned\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user is allowed to redeem for assets\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of shares the owner is allowed to redeem\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of assets that will be transferred when redeeming requested amount of shares\\n    /// @param shares Amount of shares redeemed\\n    /// @return Amount of assets transferred\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from sender to the vault pool in return for shares\\n    /// @param amount Amount of assets to deposit (use max uint256 for full underlying token balance)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Deposit will round down the amount of assets that are converted to shares. To prevent losses consider using\\n    /// mint instead.\\n    function deposit(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from sender to the vault pool in return for requested amount of shares\\n    /// @param amount Amount of shares to be minted\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of assets deposited\\n    function mint(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from the vault and decrease account's shares balance\\n    /// @param amount Amount of assets to withdraw\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn\\n    /// @return Amount of shares burned\\n    function withdraw(uint256 amount, address receiver, address owner) external returns (uint256);\\n\\n    /// @notice Burn requested shares and transfer corresponding underlying tokens from the vault to the receiver\\n    /// @param amount Amount of shares to burn (use max uint256 to burn full owner balance)\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn.\\n    /// @return Amount of assets transferred\\n    function redeem(uint256 amount, address receiver, address owner) external returns (uint256);\\n}\\n\\n/// @title IVault\\n/// @notice Interface of the EVault's Vault module\\ninterface IVault is IERC4626 {\\n    /// @notice Balance of the fees accumulator, in shares\\n    /// @return The accumulated fees in shares\\n    function accumulatedFees() external view returns (uint256);\\n\\n    /// @notice Balance of the fees accumulator, in underlying units\\n    /// @return The accumulated fees in asset units\\n    function accumulatedFeesAssets() external view returns (uint256);\\n\\n    /// @notice Address of the original vault creator\\n    /// @return The address of the creator\\n    function creator() external view returns (address);\\n\\n    /// @notice Creates shares for the receiver, from excess asset balances of the vault (not accounted for in `cash`)\\n    /// @param amount Amount of assets to claim (use max uint256 to claim all available assets)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Could be used as an alternative deposit flow in certain scenarios. E.g. swap directly to the vault, call\\n    /// `skim` to claim deposit.\\n    function skim(uint256 amount, address receiver) external returns (uint256);\\n}\\n\\n/// @title IBorrowing\\n/// @notice Interface of the EVault's Borrowing module\\ninterface IBorrowing {\\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\\n    /// @return The total borrows in asset units\\n    function totalBorrows() external view returns (uint256);\\n\\n    /// @notice Sum of all outstanding debts, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @return The total borrows in internal debt precision\\n    function totalBorrowsExact() external view returns (uint256);\\n\\n    /// @notice Balance of vault assets as tracked by deposits/withdrawals and borrows/repays\\n    /// @return The amount of assets the vault tracks as current direct holdings\\n    function cash() external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units\\n    /// @param account Address to query\\n    /// @return The debt of the account in asset units\\n    function debtOf(address account) external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @param account Address to query\\n    /// @return The debt of the account in internal precision\\n    function debtOfExact(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate for an asset\\n    /// @return The interest rate in yield-per-second, scaled by 10**27\\n    function interestRate() external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate accumulator for an asset\\n    /// @return An opaque accumulator that increases as interest is accrued\\n    function interestAccumulator() external view returns (uint256);\\n\\n    /// @notice Returns an address of the sidecar DToken\\n    /// @return The address of the DToken\\n    function dToken() external view returns (address);\\n\\n    /// @notice Transfer underlying tokens from the vault to the sender, and increase sender's debt\\n    /// @param amount Amount of assets to borrow (use max uint256 for all available tokens)\\n    /// @param receiver Account receiving the borrowed tokens\\n    /// @return Amount of assets borrowed\\n    function borrow(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from the sender to the vault, and decrease receiver's debt\\n    /// @param amount Amount of debt to repay in assets (use max uint256 for full debt)\\n    /// @param receiver Account holding the debt to be repaid\\n    /// @return Amount of assets repaid\\n    function repay(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Pay off liability with shares (\\\"self-repay\\\")\\n    /// @param amount In asset units (use max uint256 to repay the debt in full or up to the available deposit)\\n    /// @param receiver Account to remove debt from by burning sender's shares\\n    /// @return shares Amount of shares burned\\n    /// @return debt Amount of debt removed in assets\\n    /// @dev Equivalent to withdrawing and repaying, but no assets are needed to be present in the vault\\n    /// @dev Contrary to a regular `repay`, if account is unhealthy, the repay amount must bring the account back to\\n    /// health, or the operation will revert during account status check\\n    function repayWithShares(uint256 amount, address receiver) external returns (uint256 shares, uint256 debt);\\n\\n    /// @notice Take over debt from another account\\n    /// @param amount Amount of debt in asset units (use max uint256 for all the account's debt)\\n    /// @param from Account to pull the debt from\\n    /// @dev Due to internal debt precision accounting, the liability reported on either or both accounts after\\n    /// calling `pullDebt` may not match the `amount` requested precisely\\n    function pullDebt(uint256 amount, address from) external;\\n\\n    /// @notice Request a flash-loan. A onFlashLoan() callback in msg.sender will be invoked, which must repay the loan\\n    /// to the main Euler address prior to returning.\\n    /// @param amount In asset units\\n    /// @param data Passed through to the onFlashLoan() callback, so contracts don't need to store transient data in\\n    /// storage\\n    function flashLoan(uint256 amount, bytes calldata data) external;\\n\\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs\\n    /// vault status\\n    function touch() external;\\n}\\n\\n/// @title ILiquidation\\n/// @notice Interface of the EVault's Liquidation module\\ninterface ILiquidation {\\n    /// @notice Checks to see if a liquidation would be profitable, without actually doing anything\\n    /// @param liquidator Address that will initiate the liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @return maxRepay Max amount of debt that can be repaid, in asset units\\n    /// @return maxYield Yield in collateral corresponding to max allowed amount of debt to be repaid, in collateral\\n    /// balance (shares for vaults)\\n    function checkLiquidation(address liquidator, address violator, address collateral)\\n        external\\n        view\\n        returns (uint256 maxRepay, uint256 maxYield);\\n\\n    /// @notice Attempts to perform a liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @param repayAssets The amount of underlying debt to be transferred from violator to sender, in asset units (use\\n    /// max uint256 to repay the maximum possible amount). Meant as slippage check together with `minYieldBalance`\\n    /// @param minYieldBalance The minimum acceptable amount of collateral to be transferred from violator to sender, in\\n    /// collateral balance units (shares for vaults).  Meant as slippage check together with `repayAssets`\\n    /// @dev If `repayAssets` is set to max uint256 it is assumed the caller will perform their own slippage checks to\\n    /// make sure they are not taking on too much debt. This option is mainly meant for smart contract liquidators\\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance) external;\\n}\\n\\n/// @title IRiskManager\\n/// @notice Interface of the EVault's RiskManager module\\ninterface IRiskManager is IEVCVault {\\n    /// @notice Retrieve account's total liquidity\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collateralValue Total risk adjusted value of all collaterals in unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidity(address account, bool liquidation)\\n        external\\n        view\\n        returns (uint256 collateralValue, uint256 liabilityValue);\\n\\n    /// @notice Retrieve account's liquidity per collateral\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collaterals Array of collaterals enabled\\n    /// @return collateralValues Array of risk adjusted collateral values corresponding to items in collaterals array.\\n    /// In unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidityFull(address account, bool liquidation)\\n        external\\n        view\\n        returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue);\\n\\n    /// @notice Release control of the account on EVC if no outstanding debt is present\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account and reverts if account is not healthy\\n    /// @param account The address of the account to be checked\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkAccountStatus(address account, address[] calldata collaterals) external view returns (bytes4);\\n\\n    /// @notice Checks the status of the vault and reverts if caps are exceeded\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkVaultStatus() external returns (bytes4);\\n}\\n\\n/// @title IBalanceForwarder\\n/// @notice Interface of the EVault's BalanceForwarder module\\ninterface IBalanceForwarder {\\n    /// @notice Retrieve the address of rewards contract, tracking changes in account's balances\\n    /// @return The balance tracker address\\n    function balanceTrackerAddress() external view returns (address);\\n\\n    /// @notice Retrieves boolean indicating if the account opted in to forward balance changes to the rewards contract\\n    /// @param account Address to query\\n    /// @return True if balance forwarder is enabled\\n    function balanceForwarderEnabled(address account) external view returns (bool);\\n\\n    /// @notice Enables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can enable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the current account's balance\\n    function enableBalanceForwarder() external;\\n\\n    /// @notice Disables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can disable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the account's balance of 0\\n    function disableBalanceForwarder() external;\\n}\\n\\n/// @title IGovernance\\n/// @notice Interface of the EVault's Governance module\\ninterface IGovernance {\\n    /// @notice Retrieves the address of the governor\\n    /// @return The governor address\\n    function governorAdmin() external view returns (address);\\n\\n    /// @notice Retrieves address of the governance fee receiver\\n    /// @return The fee receiver address\\n    function feeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves the interest fee in effect for the vault\\n    /// @return Amount of interest that is redirected as a fee, as a fraction scaled by 1e4\\n    function interestFee() external view returns (uint16);\\n\\n    /// @notice Looks up an asset's currently configured interest rate model\\n    /// @return Address of the interest rate contract or address zero to indicate 0% interest\\n    function interestRateModel() external view returns (address);\\n\\n    /// @notice Retrieves the ProtocolConfig address\\n    /// @return The protocol config address\\n    function protocolConfigAddress() external view returns (address);\\n\\n    /// @notice Retrieves the protocol fee share\\n    /// @return A percentage share of fees accrued belonging to the protocol, in 1e4 scale\\n    function protocolFeeShare() external view returns (uint256);\\n\\n    /// @notice Retrieves the address which will receive protocol's fees\\n    /// @notice The protocol fee receiver address\\n    function protocolFeeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves supply and borrow caps in AmountCap format\\n    /// @return supplyCap The supply cap in AmountCap format\\n    /// @return borrowCap The borrow cap in AmountCap format\\n    function caps() external view returns (uint16 supplyCap, uint16 borrowCap);\\n\\n    /// @notice Retrieves the borrow LTV of the collateral, which is used to determine if the account is healthy during\\n    /// account status checks.\\n    /// @param collateral The address of the collateral to query\\n    /// @return Borrowing LTV in 1e4 scale\\n    function LTVBorrow(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves the current liquidation LTV, which is used to determine if the account is eligible for\\n    /// liquidation\\n    /// @param collateral The address of the collateral to query\\n    /// @return Liquidation LTV in 1e4 scale\\n    function LTVLiquidation(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves LTV configuration for the collateral\\n    /// @param collateral Collateral asset\\n    /// @return borrowLTV The current value of borrow LTV for originating positions\\n    /// @return liquidationLTV The value of fully converged liquidation LTV\\n    /// @return initialLiquidationLTV The initial value of the liquidation LTV, when the ramp began\\n    /// @return targetTimestamp The timestamp when the liquidation LTV is considered fully converged\\n    /// @return rampDuration The time it takes for the liquidation LTV to converge from the initial value to the fully\\n    /// converged value\\n    function LTVFull(address collateral)\\n        external\\n        view\\n        returns (\\n            uint16 borrowLTV,\\n            uint16 liquidationLTV,\\n            uint16 initialLiquidationLTV,\\n            uint48 targetTimestamp,\\n            uint32 rampDuration\\n        );\\n\\n    /// @notice Retrieves a list of collaterals with configured LTVs\\n    /// @return List of asset collaterals\\n    /// @dev Returned assets could have the ltv disabled (set to zero)\\n    function LTVList() external view returns (address[] memory);\\n\\n    /// @notice Retrieves the maximum liquidation discount\\n    /// @return The maximum liquidation discount in 1e4 scale\\n    /// @dev The default value, which is zero, is deliberately bad, as it means there would be no incentive to liquidate\\n    /// unhealthy users. The vault creator must take care to properly select the limit, given the underlying and\\n    /// collaterals used.\\n    function maxLiquidationDiscount() external view returns (uint16);\\n\\n    /// @notice Retrieves liquidation cool-off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @return The liquidation cool off time in seconds\\n    function liquidationCoolOffTime() external view returns (uint16);\\n\\n    /// @notice Retrieves a hook target and a bitmask indicating which operations call the hook target\\n    /// @return hookTarget Address of the hook target contract\\n    /// @return hookedOps Bitmask with operations that should call the hooks. See Constants.sol for a list of operations\\n    function hookConfig() external view returns (address hookTarget, uint32 hookedOps);\\n\\n    /// @notice Retrieves a bitmask indicating enabled config flags\\n    /// @return Bitmask with config flags enabled\\n    function configFlags() external view returns (uint32);\\n\\n    /// @notice Address of EthereumVaultConnector contract\\n    /// @return The EVC address\\n    function EVC() external view returns (address);\\n\\n    /// @notice Retrieves a reference asset used for liquidity calculations\\n    /// @return The address of the reference asset\\n    function unitOfAccount() external view returns (address);\\n\\n    /// @notice Retrieves the address of the oracle contract\\n    /// @return The address of the oracle\\n    function oracle() external view returns (address);\\n\\n    /// @notice Retrieves the Permit2 contract address\\n    /// @return The address of the Permit2 contract\\n    function permit2Address() external view returns (address);\\n\\n    /// @notice Splits accrued fees balance according to protocol fee share and transfers shares to the governor fee\\n    /// receiver and protocol fee receiver\\n    function convertFees() external;\\n\\n    /// @notice Set a new governor address\\n    /// @param newGovernorAdmin The new governor address\\n    /// @dev Set to zero address to renounce privileges and make the vault non-governed\\n    function setGovernorAdmin(address newGovernorAdmin) external;\\n\\n    /// @notice Set a new governor fee receiver address\\n    /// @param newFeeReceiver The new fee receiver address\\n    function setFeeReceiver(address newFeeReceiver) external;\\n\\n    /// @notice Set a new LTV config\\n    /// @param collateral Address of collateral to set LTV for\\n    /// @param borrowLTV New borrow LTV, for assessing account's health during account status checks, in 1e4 scale\\n    /// @param liquidationLTV New liquidation LTV after ramp ends in 1e4 scale\\n    /// @param rampDuration Ramp duration in seconds\\n    function setLTV(address collateral, uint16 borrowLTV, uint16 liquidationLTV, uint32 rampDuration) external;\\n\\n    /// @notice Set a new maximum liquidation discount\\n    /// @param newDiscount New maximum liquidation discount in 1e4 scale\\n    /// @dev If the discount is zero (the default), the liquidators will not be incentivized to liquidate unhealthy\\n    /// accounts\\n    function setMaxLiquidationDiscount(uint16 newDiscount) external;\\n\\n    /// @notice Set a new liquidation cool off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @param newCoolOffTime The new liquidation cool off time in seconds\\n    /// @dev Setting cool off time to zero allows liquidating the account in the same block as the last successful\\n    /// account status check\\n    function setLiquidationCoolOffTime(uint16 newCoolOffTime) external;\\n\\n    /// @notice Set a new interest rate model contract\\n    /// @param newModel The new IRM address\\n    /// @dev If the new model reverts, perhaps due to governor error, the vault will silently use a zero interest\\n    /// rate. Governor should make sure the new interest rates are computed as expected.\\n    function setInterestRateModel(address newModel) external;\\n\\n    /// @notice Set a new hook target and a new bitmap indicating which operations should call the hook target.\\n    /// Operations are defined in Constants.sol.\\n    /// @param newHookTarget The new hook target address. Use address(0) to simply disable hooked operations\\n    /// @param newHookedOps Bitmask with the new hooked operations\\n    /// @dev All operations are initially disabled in a newly created vault. The vault creator must set their\\n    /// own configuration to make the vault usable\\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) external;\\n\\n    /// @notice Set new bitmap indicating which config flags should be enabled. Flags are defined in Constants.sol\\n    /// @param newConfigFlags Bitmask with the new config flags\\n    function setConfigFlags(uint32 newConfigFlags) external;\\n\\n    /// @notice Set new supply and borrow caps in AmountCap format\\n    /// @param supplyCap The new supply cap in AmountCap fromat\\n    /// @param borrowCap The new borrow cap in AmountCap fromat\\n    function setCaps(uint16 supplyCap, uint16 borrowCap) external;\\n\\n    /// @notice Set a new interest fee\\n    /// @param newFee The new interest fee\\n    function setInterestFee(uint16 newFee) external;\\n}\\n\\n/// @title IEVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface of the EVault, an EVC enabled lending vault\\ninterface IEVault is\\n    IInitialize,\\n    IToken,\\n    IVault,\\n    IBorrowing,\\n    ILiquidation,\\n    IRiskManager,\\n    IBalanceForwarder,\\n    IGovernance\\n{\\n    /// @notice Fetch address of the `Initialize` module\\n    function MODULE_INITIALIZE() external view returns (address);\\n    /// @notice Fetch address of the `Token` module\\n    function MODULE_TOKEN() external view returns (address);\\n    /// @notice Fetch address of the `Vault` module\\n    function MODULE_VAULT() external view returns (address);\\n    /// @notice Fetch address of the `Borrowing` module\\n    function MODULE_BORROWING() external view returns (address);\\n    /// @notice Fetch address of the `Liquidation` module\\n    function MODULE_LIQUIDATION() external view returns (address);\\n    /// @notice Fetch address of the `RiskManager` module\\n    function MODULE_RISKMANAGER() external view returns (address);\\n    /// @notice Fetch address of the `BalanceForwarder` module\\n    function MODULE_BALANCE_FORWARDER() external view returns (address);\\n    /// @notice Fetch address of the `Governance` module\\n    function MODULE_GOVERNANCE() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/InterestRateModels/IRMLinearKink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IIRM.sol\\\";\\n\\n/// @title IRMLinearKink\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Implementation of an interest rate model, where interest rate grows linearly with utilization, and spikes\\n/// after reaching kink\\ncontract IRMLinearKink is IIRM {\\n    /// @notice Base interest rate applied when utilization is equal zero\\n    uint256 public immutable baseRate;\\n    /// @notice Slope of the function before the kink\\n    uint256 public immutable slope1;\\n    /// @notice Slope of the function after the kink\\n    uint256 public immutable slope2;\\n    /// @notice Utilization at which the slope of the interest rate function changes. In type(uint32).max scale.\\n    uint256 public immutable kink;\\n\\n    constructor(uint256 baseRate_, uint256 slope1_, uint256 slope2_, uint32 kink_) {\\n        baseRate = baseRate_;\\n        slope1 = slope1_;\\n        slope2 = slope2_;\\n        kink = kink_;\\n    }\\n\\n    /// @inheritdoc IIRM\\n    function computeInterestRate(address vault, uint256 cash, uint256 borrows)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (msg.sender != vault) revert E_IRMUpdateUnauthorized();\\n\\n        return computeInterestRateInternal(vault, cash, borrows);\\n    }\\n\\n    /// @inheritdoc IIRM\\n    function computeInterestRateView(address vault, uint256 cash, uint256 borrows)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return computeInterestRateInternal(vault, cash, borrows);\\n    }\\n\\n    function computeInterestRateInternal(address, uint256 cash, uint256 borrows) internal view returns (uint256) {\\n        uint256 totalAssets = cash + borrows;\\n\\n        uint32 utilization = totalAssets == 0\\n            ? 0 // empty pool arbitrarily given utilization of 0\\n            : uint32(borrows * type(uint32).max / totalAssets);\\n\\n        uint256 ir = baseRate;\\n\\n        if (utilization <= kink) {\\n            ir += utilization * slope1;\\n        } else {\\n            ir += kink * slope1;\\n\\n            uint256 utilizationOverKink;\\n            unchecked {\\n                utilizationOverKink = utilization - kink;\\n            }\\n            ir += slope2 * utilizationOverKink;\\n        }\\n\\n        return ir;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IPriceOracle\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Common PriceOracle interface.\\ninterface IPriceOracle {\\n    /// @notice Get the name of the oracle.\\n    /// @return The name of the oracle.\\n    function name() external view returns (string memory);\\n\\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price\\n    /// spread.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\\n\\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\\n    function getQuotes(uint256 inAmount, address base, address quote)\\n        external\\n        view\\n        returns (uint256 bidOutAmount, uint256 askOutAmount);\\n}\\n\"\r\n    },\r\n    \"src/Lens/OracleLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Utils} from \\\"./Utils.sol\\\";\\nimport {SnapshotRegistry} from \\\"../SnapshotRegistry/SnapshotRegistry.sol\\\";\\nimport {IPriceOracle} from \\\"euler-price-oracle/interfaces/IPriceOracle.sol\\\";\\nimport \\\"./LensTypes.sol\\\";\\n\\ninterface IOracle is IPriceOracle {\\n    function base() external view returns (address);\\n    function quote() external view returns (address);\\n    function cross() external view returns (address);\\n    function oracleBaseCross() external view returns (address);\\n    function oracleCrossQuote() external view returns (address);\\n    function feed() external view returns (address);\\n    function pyth() external view returns (address);\\n    function STETH() external view returns (address);\\n    function WSTETH() external view returns (address);\\n    function tokenA() external view returns (address);\\n    function tokenB() external view returns (address);\\n    function pool() external view returns (address);\\n    function governor() external view returns (address);\\n    function maxStaleness() external view returns (uint256);\\n    function maxConfWidth() external view returns (uint256);\\n    function twapWindow() external view returns (uint32);\\n    function fee() external view returns (uint24);\\n    function feedDecimals() external view returns (uint8);\\n    function feedId() external view returns (bytes32);\\n    function fallbackOracle() external view returns (address);\\n    function resolvedVaults(address) external view returns (address);\\n    function cache() external view returns (uint208, uint48);\\n    function resolveOracle(uint256 inAmount, address base, address quote)\\n        external\\n        view\\n        returns (uint256, address, address, address);\\n    function getConfiguredOracle(address base, address quote) external view returns (address);\\n    function description() external view returns (string memory);\\n}\\n\\ncontract OracleLens is Utils {\\n    SnapshotRegistry public immutable adapterRegistry;\\n\\n    constructor(address _adapterRegistry) {\\n        adapterRegistry = SnapshotRegistry(_adapterRegistry);\\n    }\\n\\n    function getOracleInfo(address oracleAddress, address[] calldata bases, address unitOfAccount)\\n        public\\n        view\\n        returns (OracleDetailedInfo memory)\\n    {\\n        if (oracleAddress == address(0)) {\\n            return OracleDetailedInfo({oracle: address(0), name: \\\"\\\", oracleInfo: \\\"\\\"});\\n        }\\n\\n        IOracle oracle = IOracle(oracleAddress);\\n        string memory name = oracle.name();\\n        bytes memory oracleInfo;\\n\\n        if (_strEq(name, \\\"ChainlinkOracle\\\")) {\\n            oracleInfo = abi.encode(\\n                ChainlinkOracleInfo({\\n                    base: oracle.base(),\\n                    quote: oracle.quote(),\\n                    feed: oracle.feed(),\\n                    feedDescription: IOracle(oracle.feed()).description(),\\n                    maxStaleness: oracle.maxStaleness()\\n                })\\n            );\\n        } else if (_strEq(name, \\\"ChronicleOracle\\\")) {\\n            oracleInfo = abi.encode(\\n                ChronicleOracleInfo({\\n                    base: oracle.base(),\\n                    quote: oracle.quote(),\\n                    feed: oracle.feed(),\\n                    maxStaleness: oracle.maxStaleness()\\n                })\\n            );\\n        } else if (_strEq(name, \\\"LidoOracle\\\")) {\\n            oracleInfo = abi.encode(LidoOracleInfo({base: oracle.WSTETH(), quote: oracle.STETH()}));\\n        } else if (_strEq(name, \\\"PythOracle\\\")) {\\n            oracleInfo = abi.encode(\\n                PythOracleInfo({\\n                    pyth: oracle.pyth(),\\n                    base: oracle.base(),\\n                    quote: oracle.quote(),\\n                    feedId: oracle.feedId(),\\n                    maxStaleness: oracle.maxStaleness(),\\n                    maxConfWidth: oracle.maxConfWidth()\\n                })\\n            );\\n        } else if (_strEq(name, \\\"RedstoneCoreOracle\\\")) {\\n            (uint208 cachePrice, uint48 cachePriceTimestamp) = oracle.cache();\\n            oracleInfo = abi.encode(\\n                RedstoneCoreOracleInfo({\\n                    base: oracle.base(),\\n                    quote: oracle.quote(),\\n                    feedId: oracle.feedId(),\\n                    maxStaleness: oracle.maxStaleness(),\\n                    feedDecimals: oracle.feedDecimals(),\\n                    cachePrice: cachePrice,\\n                    cachePriceTimestamp: cachePriceTimestamp\\n                })\\n            );\\n        } else if (_strEq(name, \\\"UniswapV3Oracle\\\")) {\\n            oracleInfo = abi.encode(\\n                UniswapV3OracleInfo({\\n                    tokenA: oracle.tokenA(),\\n                    tokenB: oracle.tokenB(),\\n                    pool: oracle.pool(),\\n                    fee: oracle.fee(),\\n                    twapWindow: oracle.twapWindow()\\n                })\\n            );\\n        } else if (_strEq(name, \\\"CrossAdapter\\\")) {\\n            address oracleBaseCross = oracle.oracleBaseCross();\\n            address oracleCrossQuote = oracle.oracleCrossQuote();\\n            OracleDetailedInfo memory oracleBaseCrossInfo = getOracleInfo(oracleBaseCross, bases, unitOfAccount);\\n            OracleDetailedInfo memory oracleCrossQuoteInfo = getOracleInfo(oracleCrossQuote, bases, unitOfAccount);\\n            oracleInfo = abi.encode(\\n                CrossAdapterInfo({\\n                    base: oracle.base(),\\n                    cross: oracle.cross(),\\n                    quote: oracle.quote(),\\n                    oracleBaseCross: oracleBaseCross,\\n                    oracleCrossQuote: oracleCrossQuote,\\n                    oracleBaseCrossInfo: oracleBaseCrossInfo,\\n                    oracleCrossQuoteInfo: oracleCrossQuoteInfo\\n                })\\n            );\\n        } else if (_strEq(name, \\\"EulerRouter\\\")) {\\n            address[] memory resolvedOracles = new address[](bases.length);\\n            OracleDetailedInfo[] memory resolvedOraclesInfo = new OracleDetailedInfo[](bases.length);\\n            for (uint256 i = 0; i < bases.length; ++i) {\\n                try oracle.resolveOracle(0, bases[i], unitOfAccount) returns (\\n                    uint256, address, address, address resolvedOracle\\n                ) {\\n                    resolvedOracles[i] = resolvedOracle;\\n                    resolvedOraclesInfo[i] = getOracleInfo(resolvedOracle, bases, unitOfAccount);\\n                } catch {\\n                    resolvedOracles[i] = address(0);\\n                    resolvedOraclesInfo[i] = OracleDetailedInfo({oracle: address(0), name: \\\"\\\", oracleInfo: \\\"\\\"});\\n                }\\n            }\\n\\n            address fallbackOracle = oracle.fallbackOracle();\\n\\n            oracleInfo = abi.encode(\\n                EulerRouterInfo({\\n                    governor: oracle.governor(),\\n                    fallbackOracle: oracle.fallbackOracle(),\\n                    fallbackOracleInfo: getOracleInfo(fallbackOracle, bases, unitOfAccount),\\n                    resolvedOracles: resolvedOracles,\\n                    resolvedOraclesInfo: resolvedOraclesInfo\\n                })\\n            );\\n        }\\n\\n        return OracleDetailedInfo({oracle: oracleAddress, name: name, oracleInfo: oracleInfo});\\n    }\\n\\n    function getValidAdapters(address base, address quote) public view returns (address[] memory) {\\n        return adapterRegistry.getValidAddresses(base, quote, block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Lens/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IEVault} from \\\"evk/EVault/IEVault.sol\\\";\\nimport {RPow} from \\\"evk/EVault/shared/lib/RPow.sol\\\";\\n\\nabstract contract Utils {\\n    uint256 internal constant SECONDS_PER_YEAR = 365.2425 * 86400;\\n    uint256 internal constant ONE = 1e27;\\n    uint256 internal constant CONFIG_SCALE = 1e4;\\n    uint256 internal constant TTL_HS_ACCURACY = ONE / 1e4;\\n    int256 internal constant TTL_COMPUTATION_MIN = 0;\\n    int256 internal constant TTL_COMPUTATION_MAX = 400 * 1 days;\\n    int256 public constant TTL_INFINITY = type(int256).max;\\n    int256 public constant TTL_MORE_THAN_ONE_YEAR = type(int256).max - 1;\\n    int256 public constant TTL_LIQUIDATION = -1;\\n    int256 public constant TTL_ERROR = -2;\\n\\n    function _strEq(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n\\n    /// @dev for tokens like MKR which return bytes32 on name() or symbol()\\n    function _getStringOrBytes32(address contractAddress, bytes4 selector) internal view returns (string memory) {\\n        (bool success, bytes memory result) = contractAddress.staticcall(abi.encodeWithSelector(selector));\\n\\n        return (success && result.length != 0)\\n            ? result.length == 32 ? string(abi.encodePacked(result)) : abi.decode(result, (string))\\n            : \\\"\\\";\\n    }\\n\\n    function _getDecimals(address contractAddress) internal view returns (uint8) {\\n        (bool success, bytes memory data) =\\n            contractAddress.staticcall(abi.encodeCall(IEVault(contractAddress).decimals, ()));\\n\\n        return success && data.length >= 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    function _computeSupplySPY(uint256 borrowSPY, uint256 cash, uint256 borrows, uint256 interestFee)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 totalAssets = cash + borrows;\\n        return totalAssets == 0 ? 0 : borrowSPY * borrows * (CONFIG_SCALE - interestFee) / totalAssets / CONFIG_SCALE;\\n    }\\n\\n    function _computeAPYs(uint256 borrowSPY, uint256 supplySPY)\\n        internal\\n        pure\\n        returns (uint256 borrowAPY, uint256 supplyAPY)\\n    {\\n        bool overflowBorrow;\\n        bool overflowSupply;\\n        (borrowAPY, overflowBorrow) = RPow.rpow(borrowSPY + ONE, SECONDS_PER_YEAR, ONE);\\n        (supplyAPY, overflowSupply) = RPow.rpow(supplySPY + ONE, SECONDS_PER_YEAR, ONE);\\n\\n        if (overflowBorrow || overflowSupply) return (0, 0);\\n\\n        borrowAPY -= ONE;\\n        supplyAPY -= ONE;\\n    }\\n\\n    function _calculateTimeToLiquidation(\\n        address liabilityVault,\\n        uint256 liabilityValue,\\n        address[] memory collaterals,\\n        uint256[] memory collateralValues\\n    ) internal view returns (int256) {\\n        // if there's no liability, time to liquidation is infinite\\n        if (liabilityValue == 0) return TTL_INFINITY;\\n\\n        // get borrow interest rate\\n        uint256 liabilitySPY;\\n        {\\n            (bool success, bytes memory data) =\\n                liabilityVault.staticcall(abi.encodeCall(IEVault(liabilityVault).interestRate, ()));\\n\\n            if (success && data.length >= 32) {\\n                liabilitySPY = abi.decode(data, (uint256));\\n            }\\n        }\\n\\n        // get individual collateral interest rates and total collateral value\\n        uint256[] memory collateralSPYs = new uint256[](collaterals.length);\\n        uint256 collateralValue;\\n        for (uint256 i = 0; i < collaterals.length; ++i) {\\n            address collateral = collaterals[i];\\n\\n            (bool success, bytes memory data) =\\n                collateral.staticcall(abi.encodeCall(IEVault(collateral).interestRate, ()));\\n\\n            uint256 borrowSPY;\\n            if (success && data.length >= 32) {\\n                borrowSPY = abi.decode(data, (uint256));\\n            }\\n\\n            if (borrowSPY > 0) {\\n                collateralSPYs[i] = _computeSupplySPY(\\n                    borrowSPY,\\n                    IEVault(collateral).cash(),\\n                    IEVault(collateral).totalBorrows(),\\n                    IEVault(collateral).interestFee()\\n                );\\n            }\\n\\n            collateralValue += collateralValues[i];\\n        }\\n\\n        // if liability is greater than or equal to collateral, the account is eligible for liquidation right away\\n        if (liabilityValue >= collateralValue) return TTL_LIQUIDATION;\\n\\n        // if there's no borrow interest rate, time to liquidation is infinite\\n        if (liabilitySPY == 0) return TTL_INFINITY;\\n\\n        int256 minTTL = TTL_COMPUTATION_MIN;\\n        int256 maxTTL = TTL_COMPUTATION_MAX;\\n        int256 ttl;\\n\\n        // calculate time to liquidation using binary search\\n        while (true) {\\n            ttl = minTTL + (maxTTL - minTTL) / 2;\\n\\n            // break if the search range is too small\\n            if (maxTTL <= minTTL + 1 days) break;\\n            if (ttl < 1 days) break;\\n\\n            // calculate the liability interest accrued\\n            uint256 liabilityInterest;\\n            {\\n                (uint256 multiplier, bool overflow) = RPow.rpow(liabilitySPY + ONE, uint256(ttl), ONE);\\n\\n                if (overflow) return TTL_ERROR;\\n\\n                liabilityInterest = liabilityValue * multiplier / ONE - liabilityValue;\\n            }\\n\\n            // calculate the collaterals interest accrued\\n            uint256 collateralInterest;\\n            for (uint256 i = 0; i < collaterals.length; ++i) {\\n                (uint256 multiplier, bool overflow) = RPow.rpow(collateralSPYs[i] + ONE, uint256(ttl), ONE);\\n\\n                if (overflow) return TTL_ERROR;\\n\\n                collateralInterest = collateralValues[i] * multiplier / ONE - collateralValues[i];\\n            }\\n\\n            // calculate the health factor\\n            uint256 hs = (collateralValue + collateralInterest) * ONE / (liabilityValue + liabilityInterest);\\n\\n            // if the collateral interest accrues fater than the liability interest, the account should never be\\n            // liquidated\\n            if (collateralInterest >= liabilityInterest) return TTL_INFINITY;\\n\\n            // if the health factor is within the acceptable range, return the time to liquidation\\n            if (hs >= ONE && hs - ONE <= TTL_HS_ACCURACY) break;\\n            if (hs < ONE && ONE - hs <= TTL_HS_ACCURACY) break;\\n\\n            // adjust the search range\\n            if (hs >= ONE) minTTL = ttl + 1 days;\\n            else maxTTL = ttl - 1 days;\\n        }\\n\\n        return ttl > int256(SECONDS_PER_YEAR) ? TTL_MORE_THAN_ONE_YEAR : int256(ttl) / 1 days;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/AmountCap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {AmountCap} from \\\"./Types.sol\\\";\\n\\n/// @title AmountCapLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for `AmountCap` custom type\\n/// @dev AmountCaps are 16-bit decimal floating point values:\\n/// * The least significant 6 bits are the exponent\\n/// * The most significant 10 bits are the mantissa, scaled by 100\\n/// * The special value of 0 means limit is not set\\n///   * This is so that uninitialized storage implies no limit\\n///   * For an actual cap value of 0, use a zero mantissa and non-zero exponent\\nlibrary AmountCapLib {\\n    function resolve(AmountCap self) internal pure returns (uint256) {\\n        uint256 amountCap = AmountCap.unwrap(self);\\n\\n        if (amountCap == 0) return type(uint256).max;\\n\\n        unchecked {\\n            // Cannot overflow because this is less than 2**256:\\n            //   10**(2**6 - 1) * (2**10 - 1) = 1.023e+66\\n            return 10 ** (amountCap & 63) * (amountCap >> 6) / 100;\\n        }\\n    }\\n\\n    function toRawUint16(AmountCap self) internal pure returns (uint16) {\\n        return AmountCap.unwrap(self);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Lens/LensTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nstruct AccountInfo {\\n    EVCAccountInfo evcAccountInfo;\\n    VaultAccountInfo vaultAccountInfo;\\n    AccountRewardInfo accountRewardInfo;\\n}\\n\\nstruct AccountMultipleVaultsInfo {\\n    EVCAccountInfo evcAccountInfo;\\n    VaultAccountInfo[] vaultAccountInfo;\\n    AccountRewardInfo[] accountRewardInfo;\\n}\\n\\nstruct EVCAccountInfo {\\n    uint256 timestamp;\\n    address evc;\\n    address account;\\n    bytes19 addressPrefix;\\n    address owner;\\n    bool isLockdownMode;\\n    bool isPermitDisabledMode;\\n    uint256 lastAccountStatusCheckTimestamp;\\n    address[] enabledControllers;\\n    address[] enabledCollaterals;\\n}\\n\\nstruct VaultAccountInfo {\\n    uint256 timestamp;\\n    address account;\\n    address vault;\\n    address asset;\\n    uint256 assetsAccount;\\n    uint256 shares;\\n    uint256 assets;\\n    uint256 borrowed;\\n    uint256 assetAllowanceVault;\\n    uint256 assetAllowanceVaultPermit2;\\n    uint256 assetAllowanceExpirationVaultPermit2;\\n    uint256 assetAllowancePermit2;\\n    bool balanceForwarderEnabled;\\n    bool isController;\\n    bool isCollateral;\\n    AccountLiquidityInfo liquidityInfo;\\n}\\n\\nstruct AccountLiquidityInfo {\\n    bool queryFailure;\\n    bytes queryFailureReason;\\n    int256 timeToLiquidation;\\n    uint256 liabilityValue;\\n    uint256 collateralValueBorrowing;\\n    uint256 collateralValueLiquidation;\\n    CollateralLiquidityInfo[] collateralLiquidityBorrowingInfo;\\n    CollateralLiquidityInfo[] collateralLiquidityLiquidationInfo;\\n}\\n\\nstruct CollateralLiquidityInfo {\\n    address collateral;\\n    uint256 collateralValue;\\n}\\n\\nstruct VaultInfoSimple {\\n    uint256 timestamp;\\n    address vault;\\n    string vaultName;\\n    string vaultSymbol;\\n    uint256 vaultDecimals;\\n    address asset;\\n    uint256 assetDecimals;\\n    address unitOfAccount;\\n    uint256 unitOfAccountDecimals;\\n    uint256 totalShares;\\n    uint256 totalCash;\\n    uint256 totalBorrowed;\\n    uint256 totalAssets;\\n    address oracle;\\n    address governorAdmin;\\n    VaultInterestRateModelInfo irmInfo;\\n    LTVInfo[] collateralLTVInfo;\\n    AssetPriceInfo liabilityPriceInfo;\\n    AssetPriceInfo[] collateralPriceInfo;\\n    OracleDetailedInfo oracleInfo;\\n    AssetPriceInfo backupAssetPriceInfo;\\n    OracleDetailedInfo backupAssetOracleInfo;\\n}\\n\\nstruct VaultInfoFull {\\n    uint256 timestamp;\\n    address vault;\\n    string vaultName;\\n    string vaultSymbol;\\n    uint256 vaultDecimals;\\n    address asset;\\n    string assetName;\\n    string assetSymbol;\\n    uint256 assetDecimals;\\n    address unitOfAccount;\\n    string unitOfAccountName;\\n    string unitOfAccountSymbol;\\n    uint256 unitOfAccountDecimals;\\n    uint256 totalShares;\\n    uint256 totalCash;\\n    uint256 totalBorrowed;\\n    uint256 totalAssets;\\n    uint256 accumulatedFeesShares;\\n    uint256 accumulatedFeesAssets;\\n    address governorFeeReceiver;\\n    address protocolFeeReceiver;\\n    uint256 protocolFeeShare;\\n    uint256 interestFee;\\n    uint256 hookedOperations;\\n    uint256 configFlags;\\n    uint256 supplyCap;\\n    uint256 borrowCap;\\n    uint256 maxLiquidationDiscount;\\n    uint256 liquidationCoolOffTime;\\n    address dToken;\\n    address oracle;\\n    address interestRateModel;\\n    address hookTarget;\\n    address evc;\\n    address protocolConfig;\\n    address balanceTracker;\\n    address permit2;\\n    address creator;\\n    address governorAdmin;\\n    VaultInterestRateModelInfo irmInfo;\\n    LTVInfo[] collateralLTVInfo;\\n    AssetPriceInfo liabilityPriceInfo;\\n    AssetPriceInfo[] collateralPriceInfo;\\n    OracleDetailedInfo oracleInfo;\\n    AssetPriceInfo backupAssetPriceInfo;\\n    OracleDetailedInfo backupAssetOracleInfo;\\n}\\n\\nstruct LTVInfo {\\n    address collateral;\\n    uint256 borrowLTV;\\n    uint256 liquidationLTV;\\n    uint256 initialLiquidationLTV;\\n    uint256 targetTimestamp;\\n    uint256 rampDuration;\\n}\\n\\nstruct AssetPriceInfo {\\n    bool queryFailure;\\n    bytes queryFailureReason;\\n    uint256 timestamp;\\n    address oracle;\\n    address asset;\\n    address unitOfAccount;\\n    uint256 amountIn;\\n    uint256 amountOutMid;\\n    uint256 amountOutBid;\\n    uint256 amountOutAsk;\\n}\\n\\nstruct VaultInterestRateModelInfo {\\n    bool queryFailure;\\n    bytes queryFailureReason;\\n    address vault;\\n    address interestRateModel;\\n    InterestRateInfo[] interestRateInfo;\\n}\\n\\nstruct InterestRateInfo {\\n    uint256 cash;\\n    uint256 borrows;\\n    uint256 borrowSPY;\\n    uint256 supplySPY;\\n    uint256 borrowAPY;\\n    uint256 supplyAPY;\\n}\\n\\nstruct KinkInterestRateModelInfo {\\n    address interestRateModel;\\n    uint256 baseRate;\\n    uint256 slope1;\\n    uint256 slope2;\\n    uint256 kink;\\n}\\n\\nstruct AccountRewardInfo {\\n    uint256 timestamp;\\n    address account;\\n    address vault;\\n    address balanceTracker;\\n    bool balanceForwarderEnabled;\\n    uint256 balance;\\n    EnabledRewardInfo[] enabledRewardsInfo;\\n}\\n\\nstruct EnabledRewardInfo {\\n    address reward;\\n    uint256 earnedReward;\\n    uint256 earnedRewardRecentIgnored;\\n}\\n\\nstruct VaultRewardInfo {\\n    uint256 timestamp;\\n    address vault;\\n    address reward;\\n    string rewardName;\\n    string rewardSymbol;\\n    uint8 rewardDecimals;\\n    address balanceTracker;\\n    uint256 epochDuration;\\n    uint256 currentEpoch;\\n    uint256 totalRewardedEligible;\\n    uint256 totalRewardRegistered;\\n    uint256 totalRewardClaimed;\\n    RewardAmountInfo[] epochInfoPrevious;\\n    RewardAmountInfo[] epochInfoUpcoming;\\n}\\n\\nstruct RewardAmountInfo {\\n    uint256 epoch;\\n    uint256 epochStart;\\n    uint256 epochEnd;\\n    uint256 rewardAmount;\\n}\\n\\nstruct OracleDetailedInfo {\\n    address oracle;\\n    string name;\\n    bytes oracleInfo;\\n}\\n\\nstruct EulerRouterInfo {\\n    address governor;\\n    address fallbackOracle;\\n    address[] resolvedOracles;\\n    OracleDetailedInfo fallbackOracleInfo;\\n    OracleDetailedInfo[] resolvedOraclesInfo;\\n}\\n\\nstruct ChainlinkOracleInfo {\\n    address base;\\n    address quote;\\n    address feed;\\n    string feedDescription;\\n    uint256 maxStaleness;\\n}\\n\\nstruct ChronicleOracleInfo {\\n    address base;\\n    address quote;\\n    address feed;\\n    uint256 maxStaleness;\\n}\\n\\nstruct LidoOracleInfo {\\n    address base;\\n    address quote;\\n}\\n\\nstruct PythOracleInfo {\\n    address pyth;\\n    address base;\\n    address quote;\\n    bytes32 feedId;\\n    uint256 maxStaleness;\\n    uint256 maxConfWidth;\\n}\\n\\nstruct RedstoneCoreOracleInfo {\\n    address base;\\n    address quote;\\n    bytes32 feedId;\\n    uint8 feedDecimals;\\n    uint256 maxStaleness;\\n    uint208 cachePrice;\\n    uint48 cachePriceTimestamp;\\n}\\n\\nstruct UniswapV3OracleInfo {\\n    address tokenA;\\n    address tokenB;\\n    address pool;\\n    uint24 fee;\\n    uint32 twapWindow;\\n}\\n\\nstruct CrossAdapterInfo {\\n    address base;\\n    address cross;\\n    address quote;\\n    address oracleBaseCross;\\n    address oracleCrossQuote;\\n    OracleDetailedInfo oracleBaseCrossInfo;\\n    OracleDetailedInfo oracleCrossQuoteInfo;\\n}\\n\"\r\n    },\r\n    \"lib/reward-streams/src/interfaces/IBalanceTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IBalanceTracker\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Provides an interface for tracking the balance of accounts.\\ninterface IBalanceTracker {\\n    /// @notice Executes the balance tracking hook for an account.\\n    /// @dev This function must be called with the current balance of the account when enabling the balance forwarding\\n    /// for it. This function must be called with 0 balance of the account when disabling the balance forwarding for it.\\n    /// This function allows to be called on zero balance transfers, when the newAccountBalance is the same as the\\n    /// previous one. To prevent DOS attacks, forfeitRecentReward should be used appropriately.\\n    /// @param account The account address to execute the hook for.\\n    /// @param newAccountBalance The new balance of the account.\\n    /// @param forfeitRecentReward Whether to forfeit the most recent reward and not update the accumulator.\\n    function balanceTrackerHook(address account, uint256 newAccountBalance, bool forfeitRecentReward) external;\\n}\\n\"\r\n    },\r\n    \"lib/ethereum-vault-connector/src/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Vault for the purpose of integration with the Ethereum Vault\\n/// Connector.\\ninterface IVault {\\n    /// @notice Disables a controller (this vault) for the authenticated account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults. User calls this function in order for the vault to disable itself\\n    /// for the account if the conditions are met (i.e. user has repaid debt in full). If the conditions are not met,\\n    /// the function reverts.\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account.\\n    /// @dev This function must only deliberately revert if the account status is invalid. If this function reverts due\\n    /// to any other reason, it may render the account unusable with possibly no way to recover funds.\\n    /// @param account The address of the account to be checked.\\n    /// @param collaterals The array of enabled collateral addresses to be considered for the account status check.\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkAccountStatus(\\n        address account,\\n        address[] calldata collaterals\\n    ) external view returns (bytes4 magicValue);\\n\\n    /// @notice Checks the status of the vault.\\n    /// @dev This function must only deliberately revert if the vault status is invalid. If this function reverts due to\\n    /// any other reason, it may render some accounts unusable with possibly no way to recover funds.\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkVaultStatus() external returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/InterestRateModels/IIRM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IIRM\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface of the interest rate model contracts used by EVault\\ninterface IIRM {\\n    error E_IRMUpdateUnauthorized();\\n\\n    /// @notice Perform potentially state mutating computation of the new interest rate\\n    /// @param vault Address of the vault to compute the new interest rate for\\n    /// @param cash Amount of assets held directly by the vault\\n    /// @param borrows Amount of assets lent out to borrowers by the vault\\n    /// @return Then new interest rate in second percent yield (SPY), scaled by 1e27\\n    function computeInterestRate(address vault, uint256 cash, uint256 borrows) external returns (uint256);\\n\\n    /// @notice Perform computation of the new interest rate without mutating state\\n    /// @param vault Address of the vault to compute the new interest rate for\\n    /// @param cash Amount of assets held directly by the vault\\n    /// @param borrows Amount of assets lent out to borrowers by the vault\\n    /// @return Then new interest rate in second percent yield (SPY), scaled by 1e27\\n    function computeInterestRateView(address vault, uint256 cash, uint256 borrows) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/SnapshotRegistry/SnapshotRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from \\\"openzeppelin-contracts/access/Ownable.sol\\\";\\n\\n/// @title SnapshotRegistry\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Revokeable append-only registry of addresses.\\ncontract SnapshotRegistry is Ownable {\\n    struct Entry {\\n        /// @notice The timestamp when the address was added.\\n        uint128 addedAt;\\n        /// @notice The timestamp when the address was revoked.\\n        uint128 revokedAt;\\n    }\\n\\n    /// @notice List of addresses by their base and quote asset.\\n    /// @dev The keys are lexicographically sorted (asset0 < asset1).\\n    mapping(address asset0 => mapping(address asset1 => address[])) internal map;\\n\\n    /// @notice Addresses added to the registry.\\n    mapping(address => Entry) public entries;\\n\\n    /// @notice An address was added to the registry.\\n    /// @param element The address added.\\n    /// @param asset0 The smaller address out of (base, quote).\\n    /// @param asset1 The larger address out of (base, quote).\\n    /// @param addedAt The timestamp when the address was added.\\n    event Added(address indexed element, address indexed asset0, address indexed asset1, uint256 addedAt);\\n    /// @notice An address was revoked from the registry.\\n    /// @param element The address revoked.\\n    /// @param revokedAt The timestamp when the address was revoked.\\n    event Revoked(address indexed element, uint256 revokedAt);\\n\\n    /// @notice The address cannot be added because it already exists in the registry.\\n    error Registry_AlreadyAdded();\\n    /// @notice The address cannot be revoked because it does not exist in the registry.\\n    error Registry_NotAdded();\\n    /// @notice The address cannot be revoked because it was already revoked from the registry.\\n    error Registry_AlreadyRevoked();\\n\\n    /// @notice Deploy SnapshotRegistry.\\n    /// @param _owner The address of the owner.\\n    constructor(address _owner) Ownable(_owner) {}\\n\\n    /// @notice Adds an address to the registry.\\n    /// @param element The address to add.\\n    /// @param base The corresponding base asset.\\n    /// @param quote The corresponding quote asset.\\n    /// @dev Only callable by the owner.\\n    function add(address element, address base, address quote) external onlyOwner {\\n        Entry storage entry = entries[element];\\n        if (entry.addedAt != 0) revert Registry_AlreadyAdded();\\n        entry.addedAt = uint128(block.timestamp);\\n\\n        (address asset0, address asset1) = _sort(base, quote);\\n        map[asset0][asset1].push(element);\\n\\n        emit Added(element, asset0, asset1, block.timestamp);\\n    }\\n\\n    /// @notice Revokes an address from the registry.\\n    /// @param element The address to revoke.\\n    /// @dev Only callable by the owner.\\n    function revoke(address element) external onlyOwner {\\n        Entry storage entry = entries[element];\\n        if (entry.addedAt == 0) revert Registry_NotAdded();\\n        if (entry.revokedAt != 0) revert Registry_AlreadyRevoked();\\n        entry.revokedAt = uint128(block.timestamp);\\n        emit Revoked(element, block.timestamp);\\n    }\\n\\n    /// @notice Returns the all valid addresses for a given base and quote.\\n    /// @param base The address of the base asset.\\n    /// @param quote The address of the quote asset.\\n    /// @param snapshotTime The timestamp to check.\\n    /// @dev Order of base and quote does not matter.\\n    /// @return All addresses for base and quote valid at `snapshotTime`.\\n    function getValidAddresses(address base, address quote, uint256 snapshotTime)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        (address asset0, address asset1) = _sort(base, quote);\\n        address[] memory elements = map[asset0][asset1];\\n        address[] memory validElements = new address[](elements.length);\\n\\n        uint256 numValid = 0;\\n        for (uint256 i = 0; i < elements.length; ++i) {\\n            address element = elements[i];\\n            if (isValid(element, snapshotTime)) {\\n                validElements[numValid++] = element;\\n            }\\n        }\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // update the length\\n            mstore(validElements, numValid)\\n        }\\n        return validElements;\\n    }\\n\\n    /// @notice Returns whether an address was valid at a point in time.\\n    /// @param element The address to check.\\n    /// @param snapshotTime The timestamp to check.\\n    /// @dev Returns false if:\\n    /// - address was never added,\\n    /// - address was added after the timestamp,\\n    /// - address was revoked before or at the timestamp.\\n    /// @return Whether `element` was valid at `snapshotTime`.\\n    function isValid(address element, uint256 snapshotTime) public view returns (bool) {\\n        uint256 addedAt = entries[element].addedAt;\\n        uint256 revokedAt = entries[element].revokedAt;\\n\\n        if (addedAt == 0 || addedAt > snapshotTime) return false;\\n        if (revokedAt != 0 && revokedAt <= snapshotTime) return false;\\n        return true;\\n    }\\n\\n    /// @notice Lexicographically sort two addresses.\\n    /// @param assetA One of the assets in the pair.\\n    /// @param assetB The other asset in the pair.\\n    /// @return The address first in lexicographic order.\\n    /// @return The address second in lexicographic order.\\n    function _sort(address assetA, address assetB) internal pure returns (address, address) {\\n        return assetA < assetB ? (assetA, assetB) : (assetB, assetA);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-price-oracle/src/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title IPriceOracle\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Common PriceOracle interface.\\ninterface IPriceOracle {\\n    /// @notice Get the name of the oracle.\\n    /// @return The name of the oracle.\\n    function name() external view returns (string memory);\\n\\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price spread.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\\n\\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\\n    function getQuotes(uint256 inAmount, address base, address quote)\\n        external\\n        view\\n        returns (uint256 bidOutAmount, uint256 askOutAmount);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/lib/RPow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @custom:security-contact security@euler.xyz\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\n/// @author Modified by Euler Labs (https://www.eulerlabs.com/) to return an `overflow` bool instead of reverting\\nlibrary RPow {\\n    /// @dev If overflow is true, an overflow occurred and the value of z is undefined\\n    function rpow(uint256 x, uint256 n, uint256 scalar) internal pure returns (uint256 z, bool overflow) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Bail if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        overflow := 1\\n                        break\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Bail if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        overflow := 1\\n                        break\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Bail if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                overflow := 1\\n                                break\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Bail if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            overflow := 1\\n                            break\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../IEVault.sol\\\";\\n\\nimport \\\"./VaultStorage.sol\\\";\\nimport \\\"./Snapshot.sol\\\";\\nimport \\\"./UserStorage.sol\\\";\\n\\nimport \\\"./Shares.sol\\\";\\nimport \\\"./Assets.sol\\\";\\nimport \\\"./Owed.sol\\\";\\nimport \\\"./ConfigAmount.sol\\\";\\nimport \\\"./Flags.sol\\\";\\nimport \\\"./AmountCap.sol\\\";\\n\\n/// @notice In this file, custom types are defined and linked globally with their libraries and operators\\n\\ntype Shares is uint112;\\n\\ntype Assets is uint112;\\n\\ntype Owed is uint144;\\n\\ntype AmountCap is uint16;\\n\\ntype ConfigAmount is uint16;\\n\\ntype Flags is uint32;\\n\\nusing SharesLib for Shares global;\\nusing {\\n    addShares as +, subShares as -, eqShares as ==, neqShares as !=, gtShares as >, ltShares as <\\n} for Shares global;\\n\\nusing AssetsLib for Assets global;\\nusing {\\n    addAssets as +,\\n    subAssets as -,\\n    eqAssets as ==,\\n    neqAssets as !=,\\n    gtAssets as >,\\n    gteAssets as >=,\\n    ltAssets as <,\\n    lteAssets as <=\\n} for Assets global;\\n\\nusing OwedLib for Owed global;\\nusing {addOwed as +, subOwed as -, eqOwed as ==, neqOwed as !=, gtOwed as >, ltOwed as <} for Owed global;\\n\\nusing ConfigAmountLib for ConfigAmount global;\\nusing {\\n    gtConfigAmount as >, gteConfigAmount as >=, ltConfigAmount as <, lteConfigAmount as <=\\n} for ConfigAmount global;\\n\\nusing AmountCapLib for AmountCap global;\\nusing FlagsLib for Flags global;\\n\\n/// @title TypesLib\\n/// @notice Library for casting basic types' amounts into custom types\\nlibrary TypesLib {\\n    function toShares(uint256 amount) internal pure returns (Shares) {\\n        if (amount > MAX_SANE_AMOUNT) revert Errors.E_AmountTooLargeToEncode();\\n        return Shares.wrap(uint112(amount));\\n    }\\n\\n    function toAssets(uint256 amount) internal pure returns (Assets) {\\n        if (amount > MAX_SANE_AMOUNT) revert Errors.E_AmountTooLargeToEncode();\\n        return Assets.wrap(uint112(amount));\\n    }\\n\\n    function toOwed(uint256 amount) internal pure returns (Owed) {\\n        if (amount > MAX_SANE_DEBT_AMOUNT) revert Errors.E_DebtAmountTooLargeToEncode();\\n        return Owed.wrap(uint144(amount));\\n    }\\n\\n    function toConfigAmount(uint16 amount) internal pure returns (ConfigAmount) {\\n        if (amount > CONFIG_SCALE) revert Errors.E_ConfigAmountTooLargeToEncode();\\n        return ConfigAmount.wrap(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/VaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Assets, Shares, Owed, AmountCap, ConfigAmount, Flags} from \\\"./Types.sol\\\";\\nimport {LTVConfig} from \\\"./LTVConfig.sol\\\";\\nimport {UserStorage} from \\\"./UserStorage.sol\\\";\\n\\n/// @title VaultStorage\\n/// @notice This struct is used to hold all of the vault's permanent storage\\n/// @dev Note that snapshots are not a part of this struct, as they might be reimplemented as transient storage\\nstruct VaultStorage {\\n    // Packed slot 6 + 14 + 2 + 2 + 4 + 1 + 1 = 30\\n    // A timestamp of the last interest accumulator update\\n    uint48 lastInterestAccumulatorUpdate;\\n    // The amount of assets held directly by the vault\\n    Assets cash;\\n    // Current supply cap in asset units\\n    AmountCap supplyCap;\\n    // Current borrow cap in asset units\\n    AmountCap borrowCap;\\n    // A bitfield of operations which trigger a hook call\\n    Flags hookedOps;\\n    // A vault global reentrancy protection flag\\n    bool reentrancyLocked;\\n    // A flag indicating if the vault snapshot has already been initialized for the currently executing batch\\n    bool snapshotInitialized;\\n\\n    // Packed slot 14 + 18 = 32\\n    // Sum of all user shares\\n    Shares totalShares;\\n    // Sum of all user debts\\n    Owed totalBorrows;\\n\\n    // Packed slot 14 + 2 + 2 + 4 = 22\\n    // Interest fees accrued since the last fee conversion\\n    Shares accumulatedFees;\\n    // Maximum liquidation discount\\n    ConfigAmount maxLiquidationDiscount;\\n    // Amount of time in seconds that must pass after a successful account status check before liquidation is possible\\n    uint16 liquidationCoolOffTime;\\n    // A bitfield of vault configuration options\\n    Flags configFlags;\\n\\n    // Current interest accumulator\\n    uint256 interestAccumulator;\\n\\n    // Packed slot 20 + 2 + 9 = 31\\n    // Address of the interest rate model contract. If not set, 0% interest is applied\\n    address interestRateModel;\\n    // Percentage of accrued interest that is directed to fees\\n    ConfigAmount interestFee;\\n    // Current interest rate applied to outstanding borrows\\n    uint72 interestRate;\\n\\n    // Name of the shares token (eToken)\\n    string name;\\n    // Symbol of the shares token (eToken)\\n    string symbol;\\n\\n    // Address of the vault's creator\\n    address creator;\\n\\n    // Address of the vault's governor\\n    address governorAdmin;\\n    // Address which receives governor fees\\n    address feeReceiver;\\n    // Address which will be called for enabled hooks\\n    address hookTarget;\\n\\n    // User accounts\\n    mapping(address account => UserStorage) users;\\n\\n    // LTV configuration for collaterals\\n    mapping(address collateral => LTVConfig) ltvLookup;\\n    // List of addresses which were at any point configured as collateral\\n    address[] ltvList;\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/Snapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Assets} from \\\"./Types.sol\\\";\\n\\n/// @title Snapshot\\n/// @notice This struct is used to store a snapshot of the vault's cash and total borrows at the beginning of an\\n/// operation (or a batch thereof)\\nstruct Snapshot {\\n    // Packed slot: 14 + 14 + 4 = 32\\n    // vault's cash holdings\\n    Assets cash;\\n    // vault's total borrows in assets, in regular precision\\n    Assets borrows;\\n    // stamp occupies the rest of the storage slot and makes sure the slot is non-zero for gas savings\\n    uint32 stamp;\\n}\\n\\n/// @title SnapshotLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for working with the `Snapshot` struct\\nlibrary SnapshotLib {\\n    uint32 private constant STAMP = 1; // non zero initial value of the snapshot slot to save gas on SSTORE\\n\\n    function set(Snapshot storage self, Assets cash, Assets borrows) internal {\\n        self.cash = cash;\\n        self.borrows = borrows;\\n        self.stamp = STAMP;\\n    }\\n\\n    function reset(Snapshot storage self) internal {\\n        self.set(Assets.wrap(0), Assets.wrap(0));\\n    }\\n}\\n\\nusing SnapshotLib for Snapshot global;\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/UserStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Shares, Owed} from \\\"./Types.sol\\\";\\n\\n/// @dev Custom type for holding shares and debt balances of an account, packed with balance forwarder opt-in flag\\ntype PackedUserSlot is uint256;\\n\\n/// @title UserStorage\\n/// @notice This struct is used to store user account data\\nstruct UserStorage {\\n    // Shares and debt balances, balance forwarder opt-in\\n    PackedUserSlot data;\\n    // Snapshot of the interest accumulator from the last change to account's liability\\n    uint256 interestAccumulator;\\n    // A mapping with allowances for the vault shares token (eToken)\\n    mapping(address spender => uint256 allowance) eTokenAllowance;\\n}\\n\\n/// @title UserStorageLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for working with the UserStorage struct\\nlibrary UserStorageLib {\\n    uint256 private constant BALANCE_FORWARDER_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant OWED_MASK = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000;\\n    uint256 private constant SHARES_MASK = 0x000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 private constant OWED_OFFSET = 112;\\n\\n    function isBalanceForwarderEnabled(UserStorage storage self) internal view returns (bool) {\\n        return unpackBalanceForwarder(self.data);\\n    }\\n\\n    function getOwed(UserStorage storage self) internal view returns (Owed) {\\n        return Owed.wrap(uint144((PackedUserSlot.unwrap(self.data) & OWED_MASK) >> OWED_OFFSET));\\n    }\\n\\n    function getBalance(UserStorage storage self) internal view returns (Shares) {\\n        return unpackBalance(self.data);\\n    }\\n\\n    function getBalanceAndBalanceForwarder(UserStorage storage self) internal view returns (Shares, bool) {\\n        PackedUserSlot data = self.data; // single SLOAD\\n        return (unpackBalance(data), unpackBalanceForwarder(data));\\n    }\\n\\n    function setBalanceForwarder(UserStorage storage self, bool newValue) internal {\\n        uint256 data = PackedUserSlot.unwrap(self.data);\\n\\n        uint256 newFlag = newValue ? BALANCE_FORWARDER_MASK : 0;\\n        self.data = PackedUserSlot.wrap(newFlag | (data & ~BALANCE_FORWARDER_MASK));\\n    }\\n\\n    function setOwed(UserStorage storage self, Owed owed) internal {\\n        uint256 data = PackedUserSlot.unwrap(self.data);\\n\\n        self.data = PackedUserSlot.wrap((owed.toUint() << OWED_OFFSET) | (data & ~OWED_MASK));\\n    }\\n\\n    function setBalance(UserStorage storage self, Shares balance) internal {\\n        uint256 data = PackedUserSlot.unwrap(self.data);\\n\\n        self.data = PackedUserSlot.wrap(balance.toUint() | (data & ~SHARES_MASK));\\n    }\\n\\n    function unpackBalance(PackedUserSlot data) private pure returns (Shares) {\\n        return Shares.wrap(uint112(PackedUserSlot.unwrap(data) & SHARES_MASK));\\n    }\\n\\n    function unpackBalanceForwarder(PackedUserSlot data) private pure returns (bool) {\\n        return (PackedUserSlot.unwrap(data) & BALANCE_FORWARDER_MASK) > 0;\\n    }\\n}\\n\\nusing UserStorageLib for UserStorage global;\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/Shares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Shares, Assets, TypesLib} from \\\"./Types.sol\\\";\\nimport {VaultCache} from \\\"./VaultCache.sol\\\";\\nimport {ConversionHelpers} from \\\"../lib/ConversionHelpers.sol\\\";\\n\\n/// @title SharesLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for `Shares` custom type, which is used to store vault's shares balances\\nlibrary SharesLib {\\n    function toUint(Shares self) internal pure returns (uint256) {\\n        return Shares.unwrap(self);\\n    }\\n\\n    function isZero(Shares self) internal pure returns (bool) {\\n        return Shares.unwrap(self) == 0;\\n    }\\n\\n    function toAssetsDown(Shares amount, VaultCache memory vaultCache) internal pure returns (Assets) {\\n        (uint256 totalAssets, uint256 totalShares) = ConversionHelpers.conversionTotals(vaultCache);\\n        unchecked {\\n            return TypesLib.toAssets(amount.toUint() * totalAssets / totalShares);\\n        }\\n    }\\n\\n    function toAssetsUp(Shares amount, VaultCache memory vaultCache) internal pure returns (Assets) {\\n        (uint256 totalAssets, uint256 totalShares) = ConversionHelpers.conversionTotals(vaultCache);\\n        unchecked {\\n            // totalShares >= VIRTUAL_DEPOSIT_AMOUNT > 1\\n            return TypesLib.toAssets((amount.toUint() * totalAssets + (totalShares - 1)) / totalShares);\\n        }\\n    }\\n\\n    function mulDiv(Shares self, uint256 multiplier, uint256 divisor) internal pure returns (Shares) {\\n        return TypesLib.toShares(uint256(Shares.unwrap(self)) * multiplier / divisor);\\n    }\\n\\n    function subUnchecked(Shares self, Shares b) internal pure returns (Shares) {\\n        unchecked {\\n            return Shares.wrap(uint112(self.toUint() - b.toUint()));\\n        }\\n    }\\n}\\n\\nfunction addShares(Shares a, Shares b) pure returns (Shares) {\\n    return TypesLib.toShares(uint256(Shares.unwrap(a)) + uint256(Shares.unwrap(b)));\\n}\\n\\nfunction subShares(Shares a, Shares b) pure returns (Shares) {\\n    return Shares.wrap((Shares.unwrap(a) - Shares.unwrap(b)));\\n}\\n\\nfunction eqShares(Shares a, Shares b) pure returns (bool) {\\n    return Shares.unwrap(a) == Shares.unwrap(b);\\n}\\n\\nfunction neqShares(Shares a, Shares b) pure returns (bool) {\\n    return Shares.unwrap(a) != Shares.unwrap(b);\\n}\\n\\nfunction gtShares(Shares a, Shares b) pure returns (bool) {\\n    return Shares.unwrap(a) > Shares.unwrap(b);\\n}\\n\\nfunction ltShares(Shares a, Shares b) pure returns (bool) {\\n    return Shares.unwrap(a) < Shares.unwrap(b);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Assets, Shares, Owed, TypesLib} from \\\"./Types.sol\\\";\\nimport {VaultCache} from \\\"./VaultCache.sol\\\";\\nimport {ConversionHelpers} from \\\"../lib/ConversionHelpers.sol\\\";\\nimport \\\"../Constants.sol\\\";\\n\\n/// @title AssetsLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Custom type `Assets` represents amounts of the vault's underlying asset\\nlibrary AssetsLib {\\n    function toUint(Assets self) internal pure returns (uint256) {\\n        return Assets.unwrap(self);\\n    }\\n\\n    function isZero(Assets self) internal pure returns (bool) {\\n        return Assets.unwrap(self) == 0;\\n    }\\n\\n    function toSharesDown(Assets amount, VaultCache memory vaultCache) internal pure returns (Shares) {\\n        return TypesLib.toShares(toSharesDownUint(amount, vaultCache));\\n    }\\n\\n    function toSharesDownUint(Assets amount, VaultCache memory vaultCache) internal pure returns (uint256) {\\n        (uint256 totalAssets, uint256 totalShares) = ConversionHelpers.conversionTotals(vaultCache);\\n        unchecked {\\n            return amount.toUint() * totalShares / totalAssets;\\n        }\\n    }\\n\\n    function toSharesUp(Assets amount, VaultCache memory vaultCache) internal pure returns (Shares) {\\n        (uint256 totalAssets, uint256 totalShares) = ConversionHelpers.conversionTotals(vaultCache);\\n        unchecked {\\n            // totalAssets >= VIRTUAL_DEPOSIT_AMOUNT > 1\\n            return TypesLib.toShares((amount.toUint() * totalShares + (totalAssets - 1)) / totalAssets);\\n        }\\n    }\\n\\n    function toOwed(Assets self) internal pure returns (Owed) {\\n        unchecked {\\n            return TypesLib.toOwed(self.toUint() << INTERNAL_DEBT_PRECISION_SHIFT);\\n        }\\n    }\\n\\n    function addUnchecked(Assets self, Assets b) internal pure returns (Assets) {\\n        unchecked {\\n            return Assets.wrap(uint112(self.toUint() + b.toUint()));\\n        }\\n    }\\n\\n    function subUnchecked(Assets self, Assets b) internal pure returns (Assets) {\\n        unchecked {\\n            return Assets.wrap(uint112(self.toUint() - b.toUint()));\\n        }\\n    }\\n}\\n\\nfunction addAssets(Assets a, Assets b) pure returns (Assets) {\\n    return TypesLib.toAssets(a.toUint() + b.toUint());\\n}\\n\\nfunction subAssets(Assets a, Assets b) pure returns (Assets) {\\n    return Assets.wrap((Assets.unwrap(a) - Assets.unwrap(b)));\\n}\\n\\nfunction eqAssets(Assets a, Assets b) pure returns (bool) {\\n    return Assets.unwrap(a) == Assets.unwrap(b);\\n}\\n\\nfunction neqAssets(Assets a, Assets b) pure returns (bool) {\\n    return Assets.unwrap(a) != Assets.unwrap(b);\\n}\\n\\nfunction gtAssets(Assets a, Assets b) pure returns (bool) {\\n    return Assets.unwrap(a) > Assets.unwrap(b);\\n}\\n\\nfunction gteAssets(Assets a, Assets b) pure returns (bool) {\\n    return Assets.unwrap(a) >= Assets.unwrap(b);\\n}\\n\\nfunction ltAssets(Assets a, Assets b) pure returns (bool) {\\n    return Assets.unwrap(a) < Assets.unwrap(b);\\n}\\n\\nfunction lteAssets(Assets a, Assets b) pure returns (bool) {\\n    return Assets.unwrap(a) <= Assets.unwrap(b);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/Owed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Owed, Assets, TypesLib} from \\\"./Types.sol\\\";\\nimport \\\"../Constants.sol\\\";\\n\\n/// @title OwedLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for `Owed` custom type\\n/// @dev The owed type tracks borrowed funds in asset units scaled up by shifting left INTERNAL_DEBT_PRECISION_SHIFT\\n/// bits. Increased precision allows for accurate interest accounting.\\nlibrary OwedLib {\\n    function toUint(Owed self) internal pure returns (uint256) {\\n        return Owed.unwrap(self);\\n    }\\n\\n    function toAssetsUp(Owed amount) internal pure returns (Assets) {\\n        if (Owed.unwrap(amount) == 0) return Assets.wrap(0);\\n\\n        return TypesLib.toAssets(toAssetsUpUint(Owed.unwrap(amount)));\\n    }\\n\\n    function toAssetsDown(Owed amount) internal pure returns (Assets) {\\n        if (Owed.unwrap(amount) == 0) return Assets.wrap(0);\\n\\n        return TypesLib.toAssets(Owed.unwrap(amount) >> INTERNAL_DEBT_PRECISION_SHIFT);\\n    }\\n\\n    function isDust(Owed self) internal pure returns (bool) {\\n        // less than a minimum representable internal debt amount\\n        return Owed.unwrap(self) < (1 << INTERNAL_DEBT_PRECISION_SHIFT);\\n    }\\n\\n    function isZero(Owed self) internal pure returns (bool) {\\n        return Owed.unwrap(self) == 0;\\n    }\\n\\n    function mulDiv(Owed self, uint256 multiplier, uint256 divisor) internal pure returns (Owed) {\\n        return TypesLib.toOwed(uint256(Owed.unwrap(self)) * multiplier / divisor);\\n    }\\n\\n    function addUnchecked(Owed self, Owed b) internal pure returns (Owed) {\\n        unchecked {\\n            return Owed.wrap(uint144(self.toUint() + b.toUint()));\\n        }\\n    }\\n\\n    function subUnchecked(Owed self, Owed b) internal pure returns (Owed) {\\n        unchecked {\\n            return Owed.wrap(uint144(self.toUint() - b.toUint()));\\n        }\\n    }\\n\\n    function toAssetsUpUint(uint256 owedExact) internal pure returns (uint256) {\\n        return (owedExact + (1 << INTERNAL_DEBT_PRECISION_SHIFT) - 1) >> INTERNAL_DEBT_PRECISION_SHIFT;\\n    }\\n}\\n\\nfunction addOwed(Owed a, Owed b) pure returns (Owed) {\\n    return TypesLib.toOwed(uint256(Owed.unwrap(a)) + uint256(Owed.unwrap(b)));\\n}\\n\\nfunction subOwed(Owed a, Owed b) pure returns (Owed) {\\n    return Owed.wrap((Owed.unwrap(a) - Owed.unwrap(b)));\\n}\\n\\nfunction eqOwed(Owed a, Owed b) pure returns (bool) {\\n    return Owed.unwrap(a) == Owed.unwrap(b);\\n}\\n\\nfunction neqOwed(Owed a, Owed b) pure returns (bool) {\\n    return Owed.unwrap(a) != Owed.unwrap(b);\\n}\\n\\nfunction gtOwed(Owed a, Owed b) pure returns (bool) {\\n    return Owed.unwrap(a) > Owed.unwrap(b);\\n}\\n\\nfunction ltOwed(Owed a, Owed b) pure returns (bool) {\\n    return Owed.unwrap(a) < Owed.unwrap(b);\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/ConfigAmount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {ConfigAmount} from \\\"./Types.sol\\\";\\nimport {Errors} from \\\"../Errors.sol\\\";\\nimport \\\"../Constants.sol\\\";\\n\\n/// @title ConfigAmountLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for `ConfigAmount` custom type\\n/// @dev ConfigAmounts are fixed point values encoded in 16 bits with a 1e4 precision.\\n/// @dev The type is used to store protocol configuration values.\\nlibrary ConfigAmountLib {\\n    function isZero(ConfigAmount self) internal pure returns (bool) {\\n        return self.toUint16() == 0;\\n    }\\n\\n    function toUint16(ConfigAmount self) internal pure returns (uint16) {\\n        return ConfigAmount.unwrap(self);\\n    }\\n}\\n\\nfunction gtConfigAmount(ConfigAmount a, ConfigAmount b) pure returns (bool) {\\n    return a.toUint16() > b.toUint16();\\n}\\n\\nfunction gteConfigAmount(ConfigAmount a, ConfigAmount b) pure returns (bool) {\\n    return a.toUint16() >= b.toUint16();\\n}\\n\\nfunction ltConfigAmount(ConfigAmount a, ConfigAmount b) pure returns (bool) {\\n    return a.toUint16() < b.toUint16();\\n}\\n\\nfunction lteConfigAmount(ConfigAmount a, ConfigAmount b) pure returns (bool) {\\n    return a.toUint16() <= b.toUint16();\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Flags} from \\\"./Types.sol\\\";\\n\\n/// @title FlagsLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for `Flags` custom type\\nlibrary FlagsLib {\\n    /// @dev Are *all* of the flags in bitMask set?\\n    function isSet(Flags self, uint32 bitMask) internal pure returns (bool) {\\n        return (Flags.unwrap(self) & bitMask) == bitMask;\\n    }\\n\\n    /// @dev Are *none* of the flags in bitMask set?\\n    function isNotSet(Flags self, uint32 bitMask) internal pure returns (bool) {\\n        return (Flags.unwrap(self) & bitMask) == 0;\\n    }\\n\\n    function toUint32(Flags self) internal pure returns (uint32) {\\n        return Flags.unwrap(self);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/LTVConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {ConfigAmount} from \\\"./Types.sol\\\";\\n\\n/// @title LTVConfig\\n/// @notice This packed struct is used to store LTV configuration of a collateral\\nstruct LTVConfig {\\n    // Packed slot: 2 + 2 + 2 + 6 + 4 = 16\\n    // The value of borrow LTV for originating positions\\n    ConfigAmount borrowLTV;\\n    // The value of fully converged liquidation LTV\\n    ConfigAmount liquidationLTV;\\n    // The initial value of liquidation LTV, when the ramp began\\n    ConfigAmount initialLiquidationLTV;\\n    // The timestamp when the liquidation LTV is considered fully converged\\n    uint48 targetTimestamp;\\n    // The time it takes for the liquidation LTV to converge from the initial value to the fully converged value\\n    uint32 rampDuration;\\n}\\n\\n/// @title LTVConfigLib\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Library for getting and setting the LTV configurations\\nlibrary LTVConfigLib {\\n    // Is the collateral considered safe to liquidate\\n    function isRecognizedCollateral(LTVConfig memory self) internal pure returns (bool) {\\n        return self.targetTimestamp != 0;\\n    }\\n\\n    // Get current LTV of the collateral. When liquidation LTV is lowered, it is ramped down to the target value over a\\n    // period of time.\\n    function getLTV(LTVConfig memory self, bool liquidation) internal view returns (ConfigAmount) {\\n        if (!liquidation) {\\n            return self.borrowLTV;\\n        }\\n\\n        if (block.timestamp >= self.targetTimestamp || self.liquidationLTV >= self.initialLiquidationLTV) {\\n            return self.liquidationLTV;\\n        }\\n\\n        uint256 currentLiquidationLTV = self.initialLiquidationLTV.toUint16();\\n\\n        unchecked {\\n            uint256 targetLiquidationLTV = self.liquidationLTV.toUint16();\\n            uint256 timeRemaining = self.targetTimestamp - block.timestamp;\\n\\n            // targetLiquidationLTV < initialLiquidationLTV and timeRemaining <= rampDuration\\n            currentLiquidationLTV = targetLiquidationLTV\\n                + (currentLiquidationLTV - targetLiquidationLTV) * timeRemaining / self.rampDuration;\\n        }\\n\\n        // because ramping happens only when liquidation LTV decreases, it's safe to down-cast the new value\\n        return ConfigAmount.wrap(uint16(currentLiquidationLTV));\\n    }\\n\\n    function setLTV(LTVConfig memory self, ConfigAmount borrowLTV, ConfigAmount liquidationLTV, uint32 rampDuration)\\n        internal\\n        view\\n        returns (LTVConfig memory newLTV)\\n    {\\n        newLTV.borrowLTV = borrowLTV;\\n        newLTV.liquidationLTV = liquidationLTV;\\n        newLTV.initialLiquidationLTV = self.getLTV(true);\\n        newLTV.targetTimestamp = uint48(block.timestamp + rampDuration);\\n        newLTV.rampDuration = rampDuration;\\n    }\\n}\\n\\nusing LTVConfigLib for LTVConfig global;\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/types/VaultCache.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"../../IEVault.sol\\\";\\nimport {IPriceOracle} from \\\"../../../interfaces/IPriceOracle.sol\\\";\\n\\nimport {Assets, Owed, Shares, Flags} from \\\"./Types.sol\\\";\\n\\n/// @title VaultCache\\n/// @notice This struct is used to hold all the most often used vault data in memory\\nstruct VaultCache {\\n    // Proxy immutables\\n\\n    // Vault's asset\\n    IERC20 asset;\\n    // Vault's pricing oracle\\n    IPriceOracle oracle;\\n    // Unit of account is the asset in which collateral and liability values are expressed\\n    address unitOfAccount;\\n\\n    // Vault data\\n\\n    // A timestamp of the last interest accumulator update\\n    uint48 lastInterestAccumulatorUpdate;\\n    // The amount of assets held directly by the vault\\n    Assets cash;\\n    // Sum of all user debts\\n    Owed totalBorrows;\\n    // Sum of all user shares\\n    Shares totalShares;\\n    // Interest fees accrued since the last fee conversion\\n    Shares accumulatedFees;\\n    // Current interest accumulator\\n    uint256 interestAccumulator;\\n\\n    // Vault config\\n\\n    // Current supply cap in asset units\\n    uint256 supplyCap;\\n    // Current borrow cap in asset units\\n    uint256 borrowCap;\\n    // A bitfield of operations which trigger a hook call\\n    Flags hookedOps;\\n    // A bitfield of vault configuration options\\n    Flags configFlags;\\n\\n    // Runtime\\n\\n    // A flag indicating if the vault snapshot has already been initialized for the currently executing batch\\n    bool snapshotInitialized;\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/lib/ConversionHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {VaultCache} from \\\"../types/VaultCache.sol\\\";\\n\\n/// @title ConversionHelpers Library\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice The library provides a helper function for conversions between shares and assets\\nlibrary ConversionHelpers {\\n    // virtual deposit used in conversions between shares and assets, serving as exchange rate manipulation mitigation\\n    uint256 internal constant VIRTUAL_DEPOSIT_AMOUNT = 1e6;\\n\\n    function conversionTotals(VaultCache memory vaultCache)\\n        internal\\n        pure\\n        returns (uint256 totalAssets, uint256 totalShares)\\n    {\\n        unchecked {\\n            totalAssets =\\n                vaultCache.cash.toUint() + vaultCache.totalBorrows.toAssetsUp().toUint() + VIRTUAL_DEPOSIT_AMOUNT;\\n            totalShares = vaultCache.totalShares.toUint() + VIRTUAL_DEPOSIT_AMOUNT;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n// Implementation internals\\n\\n// asset amounts are shifted left by this number of bits for increased precision of debt tracking.\\nuint256 constant INTERNAL_DEBT_PRECISION_SHIFT = 31;\\n// max amount for Assets and Shares custom types based on a uint112.\\nuint256 constant MAX_SANE_AMOUNT = type(uint112).max;\\n// max debt amount fits in uint144 (112 + 31 bits).\\n// Last 31 bits are zeros to ensure max debt rounded up equals max sane amount.\\nuint256 constant MAX_SANE_DEBT_AMOUNT = uint256(MAX_SANE_AMOUNT) << INTERNAL_DEBT_PRECISION_SHIFT;\\n// proxy trailing calldata length in bytes.\\n// Three addresses, 20 bytes each: vault underlying asset, oracle and unit of account + 4 empty bytes.\\nuint256 constant PROXY_METADATA_LENGTH = 64;\\n// gregorian calendar\\nuint256 constant SECONDS_PER_YEAR = 365.2425 * 86400;\\n// max interest rate accepted from IRM. 1,000,000% APY: floor(((1000000 / 100 + 1)**(1/(86400*365.2425)) - 1) * 1e27)\\nuint256 constant MAX_ALLOWED_INTEREST_RATE = 291867278914945094175;\\n// max valid value of the ConfigAmount custom type, signifying 100%\\nuint16 constant CONFIG_SCALE = 1e4;\\n\\n// Account status checks special values\\n\\n// no account status checks should be scheduled\\naddress constant CHECKACCOUNT_NONE = address(0);\\n// account status check should be scheduled for the authenticated account\\naddress constant CHECKACCOUNT_CALLER = address(1);\\n\\n// Operations\\n\\nuint32 constant OP_DEPOSIT = 1 << 0;\\nuint32 constant OP_MINT = 1 << 1;\\nuint32 constant OP_WITHDRAW = 1 << 2;\\nuint32 constant OP_REDEEM = 1 << 3;\\nuint32 constant OP_TRANSFER = 1 << 4;\\nuint32 constant OP_SKIM = 1 << 5;\\nuint32 constant OP_BORROW = 1 << 6;\\nuint32 constant OP_REPAY = 1 << 7;\\nuint32 constant OP_REPAY_WITH_SHARES = 1 << 8;\\nuint32 constant OP_PULL_DEBT = 1 << 9;\\nuint32 constant OP_CONVERT_FEES = 1 << 10;\\nuint32 constant OP_LIQUIDATE = 1 << 11;\\nuint32 constant OP_FLASHLOAN = 1 << 12;\\nuint32 constant OP_TOUCH = 1 << 13;\\nuint32 constant OP_VAULT_STATUS_CHECK = 1 << 14;\\n// Delimiter of possible operations\\nuint32 constant OP_MAX_VALUE = 1 << 15;\\n\\n// Config Flags\\n\\n// When flag is set, debt socialization during liquidation is disabled\\nuint32 constant CFG_DONT_SOCIALIZE_DEBT = 1 << 0;\\n// When flag is set, asset is considered to be compatible with EVC sub-accounts and protections\\n// against sending assets to sub-accounts are disabled\\nuint32 constant CFG_EVC_COMPATIBLE_ASSET = 1 << 1;\\n// Delimiter of possible config flags\\nuint32 constant CFG_MAX_VALUE = 1 << 2;\\n\\n// EVC authentication\\n\\n// in order to perform these operations, the account doesn't need to have the vault installed as a controller\\nuint32 constant CONTROLLER_NEUTRAL_OPS = OP_DEPOSIT | OP_MINT | OP_WITHDRAW | OP_REDEEM | OP_TRANSFER | OP_SKIM\\n    | OP_REPAY | OP_REPAY_WITH_SHARES | OP_CONVERT_FEES | OP_FLASHLOAN | OP_TOUCH | OP_VAULT_STATUS_CHECK;\\n\"\r\n    },\r\n    \"lib/euler-vault-kit/src/EVault/shared/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Errors\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Contract implementing EVault's custom errors\\ncontract Errors {\\n    error E_Initialized();\\n    error E_ProxyMetadata();\\n    error E_SelfTransfer();\\n    error E_InsufficientAllowance();\\n    error E_InsufficientCash();\\n    error E_InsufficientAssets();\\n    error E_InsufficientBalance();\\n    error E_InsufficientDebt();\\n    error E_FlashLoanNotRepaid();\\n    error E_Reentrancy();\\n    error E_OperationDisabled();\\n    error E_OutstandingDebt();\\n    error E_AmountTooLargeToEncode();\\n    error E_DebtAmountTooLargeToEncode();\\n    error E_RepayTooMuch();\\n    error E_TransientState();\\n    error E_SelfLiquidation();\\n    error E_ControllerDisabled();\\n    error E_CollateralDisabled();\\n    error E_ViolatorLiquidityDeferred();\\n    error E_LiquidationCoolOff();\\n    error E_ExcessiveRepayAmount();\\n    error E_MinYield();\\n    error E_BadAddress();\\n    error E_ZeroAssets();\\n    error E_ZeroShares();\\n    error E_Unauthorized();\\n    error E_CheckUnauthorized();\\n    error E_NotSupported();\\n    error E_EmptyError();\\n    error E_BadBorrowCap();\\n    error E_BadSupplyCap();\\n    error E_BadCollateral();\\n    error E_AccountLiquidity();\\n    error E_NoLiability();\\n    error E_NotController();\\n    error E_BadFee();\\n    error E_SupplyCapExceeded();\\n    error E_BorrowCapExceeded();\\n    error E_InvalidLTVAsset();\\n    error E_NoPriceOracle();\\n    error E_ConfigAmountTooLargeToEncode();\\n    error E_BadAssetReceiver();\\n    error E_BadSharesOwner();\\n    error E_BadSharesReceiver();\\n    error E_BadMaxLiquidationDiscount();\\n    error E_LTVBorrow();\\n    error E_LTVLiquidation();\\n    error E_NotHookTarget();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ethereum-vault-connector/=lib/ethereum-vault-connector/src/\",\r\n      \"evc/=lib/ethereum-vault-connector/src/\",\r\n      \"evk/=lib/euler-vault-kit/src/\",\r\n      \"evk-test/=lib/euler-vault-kit/test/\",\r\n      \"euler-price-oracle/=lib/euler-price-oracle/src/\",\r\n      \"euler-price-oracle-test/=lib/euler-price-oracle/test/\",\r\n      \"fee-flow/=lib/fee-flow/src/\",\r\n      \"reward-streams/=lib/reward-streams/src/\",\r\n      \"@openzeppelin/contracts/utils/math/=lib/euler-price-oracle/lib/openzeppelin-contracts/contracts/utils/math/\",\r\n      \"@chainlink/=lib/euler-price-oracle/node_modules/@chainlink/\",\r\n      \"@eth-optimism/=lib/euler-price-oracle/node_modules/@eth-optimism/contracts/\",\r\n      \"@pyth/=lib/euler-price-oracle/lib/pyth-sdk-solidity/\",\r\n      \"@redstone-finance/=lib/euler-price-oracle/node_modules/@redstone-finance/\",\r\n      \"@redstone/evm-connector/=lib/euler-price-oracle/lib/redstone-oracles-monorepo/packages/evm-connector/contracts/\",\r\n      \"@solady/=lib/euler-price-oracle/lib/solady/src/\",\r\n      \"@uniswap/v3-core/=lib/euler-price-oracle/lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/\",\r\n      \"ds-test/=lib/fee-flow/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"euler-vault-kit/=lib/euler-vault-kit/src/\",\r\n      \"forge-gas-snapshot/=lib/euler-vault-kit/lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\r\n      \"openzeppelin/=lib/ethereum-vault-connector/lib/openzeppelin-contracts/contracts/\",\r\n      \"permit2/=lib/euler-vault-kit/lib/permit2/\",\r\n      \"pyth-sdk-solidity/=lib/euler-price-oracle/lib/pyth-sdk-solidity/\",\r\n      \"redstone-oracles-monorepo/=lib/euler-price-oracle/lib/\",\r\n      \"solady/=lib/euler-price-oracle/lib/solady/src/\",\r\n      \"solmate/=lib/fee-flow/lib/solmate/src/\",\r\n      \"v3-core/=lib/euler-price-oracle/lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleLens\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TTL_ERROR\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TTL_INFINITY\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TTL_LIQUIDATION\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TTL_MORE_THAN_ONE_YEAR\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"}],\"name\":\"getAssetPriceInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getControllerAssetPriceInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getRecognizedCollateralsLTVInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLiquidationLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rampDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct LTVInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numberOfEpochs\",\"type\":\"uint256\"}],\"name\":\"getRewardVaultInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"rewardName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"rewardSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"rewardDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"balanceTracker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardedEligible\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardRegistered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardClaimed\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RewardAmountInfo[]\",\"name\":\"epochInfoPrevious\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RewardAmountInfo[]\",\"name\":\"epochInfoUpcoming\",\"type\":\"tuple[]\"}],\"internalType\":\"struct VaultRewardInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getVaultInfoFull\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"vaultName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"vaultSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"vaultDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"assetName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"assetDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"unitOfAccountName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"unitOfAccountSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"unitOfAccountDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedFeesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedFeesAssets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"governorFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hookedOperations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"configFlags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLiquidationDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationCoolOffTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateModel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hookTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"evc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolConfig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balanceTracker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"permit2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governorAdmin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateModel\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowSPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplySPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyAPY\",\"type\":\"uint256\"}],\"internalType\":\"struct InterestRateInfo[]\",\"name\":\"interestRateInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct VaultInterestRateModelInfo\",\"name\":\"irmInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLiquidationLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rampDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct LTVInfo[]\",\"name\":\"collateralLTVInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo\",\"name\":\"liabilityPriceInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo[]\",\"name\":\"collateralPriceInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"oracleInfo\",\"type\":\"bytes\"}],\"internalType\":\"struct OracleDetailedInfo\",\"name\":\"oracleInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo\",\"name\":\"backupAssetPriceInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"oracleInfo\",\"type\":\"bytes\"}],\"internalType\":\"struct OracleDetailedInfo\",\"name\":\"backupAssetOracleInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct VaultInfoFull\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getVaultInfoSimple\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"vaultName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"vaultSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"vaultDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unitOfAccountDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAssets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governorAdmin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateModel\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowSPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplySPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyAPY\",\"type\":\"uint256\"}],\"internalType\":\"struct InterestRateInfo[]\",\"name\":\"interestRateInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct VaultInterestRateModelInfo\",\"name\":\"irmInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLiquidationLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rampDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct LTVInfo[]\",\"name\":\"collateralLTVInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo\",\"name\":\"liabilityPriceInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo[]\",\"name\":\"collateralPriceInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"oracleInfo\",\"type\":\"bytes\"}],\"internalType\":\"struct OracleDetailedInfo\",\"name\":\"oracleInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unitOfAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutAsk\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetPriceInfo\",\"name\":\"backupAssetPriceInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"oracleInfo\",\"type\":\"bytes\"}],\"internalType\":\"struct OracleDetailedInfo\",\"name\":\"backupAssetOracleInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct VaultInfoSimple\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"cash\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrows\",\"type\":\"uint256[]\"}],\"name\":\"getVaultInterestRateModelInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateModel\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowSPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplySPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyAPY\",\"type\":\"uint256\"}],\"internalType\":\"struct InterestRateInfo[]\",\"name\":\"interestRateInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct VaultInterestRateModelInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getVaultKinkInterestRateModelInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"queryFailure\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"queryFailureReason\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateModel\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowSPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplySPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyAPY\",\"type\":\"uint256\"}],\"internalType\":\"struct InterestRateInfo[]\",\"name\":\"interestRateInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct VaultInterestRateModelInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"interestRateModel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kink\",\"type\":\"uint256\"}],\"internalType\":\"struct KinkInterestRateModelInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleLens\",\"outputs\":[{\"internalType\":\"contract OracleLens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultLens", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "0000000000000000000000000f8560f6361051de80cd15dc439c76199c47bd4f", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}