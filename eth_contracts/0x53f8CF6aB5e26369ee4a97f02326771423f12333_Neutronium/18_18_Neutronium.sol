// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "./ERC20Permit.sol";
import "./IGetSigner.sol";

/**
 * @title Neutronium ERC20 token
 * @notice This contract is used for game and market transfers,
 * buy and sell operations, merging Econia NFT's
 */
contract Neutronium is ERC20Permit, ERC20Burnable, AccessControl {
    error InvalidServerSignature();

    /// @dev Address of contract used for signature verification
    address signatureVerifier;
    bytes32 public constant BRIDGE_ROLE = keccak256("BRIDGE_ROLE");

    /// @dev Mapping storing specific nonces for claiming rewards
    mapping(address => uint256) public mintNonces;

    constructor(address _sigVerifier)
        ERC20Permit("Neutronium")
        ERC20("Neutronium", "NEUT")
    {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        signatureVerifier = _sigVerifier;
    }

    /**
     * @dev This function is for bridge contract only
     * @param to Address to mint to
     * @param amount Amount of tokens
     */
    function mintBridge(address to, uint256 amount)
        external
        onlyRole(BRIDGE_ROLE)
    {
        _mint(to, amount);
    }

    /**
     * @dev This function is for bridge contract only
     * @param from Address to burn from
     * @param amount Amount of tokens
     */
    function burnBridge(address from, uint256 amount)
        external
        onlyRole(BRIDGE_ROLE)
    {
        _burn(from, amount);
    }

    /**
     * @notice Use this function to mint tokens
     * @dev Function use signature generated by special wallet
     * @param amount Amount of tokens
     * @param vdeadline Signature verification deadline
     * @param signature Signature from server used as minting permission
     */
    function mint(
        uint256 amount,
        uint256 vdeadline,
        bytes memory signature
    ) external {
        uint256 nonce = useMintNonce(msg.sender);

        if (
            !IGetSigner(signatureVerifier).verify(
                msg.sender,
                amount,
                nonce,
                vdeadline,
                signature
            )
        ) {
            revert InvalidServerSignature();
        }

        _mint(msg.sender, amount);
    }

    /**
     * @dev Autoincrement nonce for signature verifier
     * @param owner Address that use nonce
     * @return current Current nonce
     */
    function useMintNonce(address owner) private returns (uint256 current) {
        current = mintNonces[owner];
        mintNonces[owner] += 1;
    }
}