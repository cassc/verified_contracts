{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in construction,\r\n        // since the code is only stored at the end of the constructor execution.\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ConsensusBridgeDChainSafe {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address private validatorConsensusGovernanceAccountAddress;\r\n    address private validatorConsensusAlgorythmAccountAddress;\r\n\r\n    event Deposit(address indexed sender, address tokenAddress, uint256 amount);\r\n    event Redeem(address indexed user, address tokenAddress, uint256 amount, bytes32 hash);\r\n    event ConstructorDebug(address validatorConsensusGovernanceAccountAddress, address validatorConsensusAlgorythmAccountAddress);\r\n\r\n    constructor(address validatorConsensusAlgorythmAccountAddress_) {\r\n        require(validatorConsensusAlgorythmAccountAddress_ != address(0), \"validatorConsensusAlgorythmAccountAddress_ cannot be zero address\");\r\n\r\n        validatorConsensusGovernanceAccountAddress = msg.sender;\r\n        validatorConsensusAlgorythmAccountAddress = validatorConsensusAlgorythmAccountAddress_;\r\n\r\n        emit ConstructorDebug(validatorConsensusGovernanceAccountAddress, validatorConsensusAlgorythmAccountAddress);\r\n    }\r\n\r\n    mapping (bytes32 => bool) redeemed;\r\n\r\n    receive() external payable {\r\n        revert(\"cannot send eth directly...\");\r\n    }\r\n\r\n    function deposit() external payable {\r\n        emit Deposit(msg.sender, address(0), msg.value);\r\n    }\r\n\r\n    function depositForUser(address user) external payable {\r\n        emit Deposit(user, address(0), msg.value);\r\n    }\r\n\r\n    function depositToken(address tokenAddress, uint256 amount) public {\r\n        require(tokenAddress != address(0), \"Token address cannot be zero\");\r\n\r\n        IERC20(tokenAddress).safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        emit Deposit(msg.sender, tokenAddress, amount);\r\n    }\r\n\r\n    function depositTokenForUser(address tokenAddress, address user, uint256 amount) public {\r\n        require(tokenAddress != address(0), \"Token address cannot be zero\");\r\n\r\n        IERC20(tokenAddress).safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        emit Deposit(user, tokenAddress, amount);\r\n    }\r\n\r\n    function redeem(address user, address tokenAddress, uint256 amount, bytes32 hash) public onlyValidatorConsensusAlgorythmAccountAddress {\r\n        require(!redeemed[hash], \"Redeem hash already used\");\r\n        redeemed[hash] = true;\r\n\r\n        if (tokenAddress == address(0)) {\r\n            payable(user).transfer(amount);\r\n        } else {\r\n            IERC20(tokenAddress).safeTransfer(user, amount);\r\n        }        \r\n\r\n        emit Redeem(user, tokenAddress, amount, hash);\r\n    }\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function setValidatorConsensusAlgorythmAccountAddress(address validatorConsensusAlgorythmAccountAddress_) public onlyValidatorConsensusGovernanceAccountAddress {\r\n        require(validatorConsensusAlgorythmAccountAddress_ != address(0), \"validatorConsensusAlgorythmAccountAddress_ cannot be zero address\");\r\n        validatorConsensusAlgorythmAccountAddress = validatorConsensusAlgorythmAccountAddress_;\r\n    }\r\n\r\n    function transferOwnership(address newGovernanceAccountAddress) public onlyValidatorConsensusGovernanceAccountAddress {\r\n        require(newGovernanceAccountAddress != address(0), \"invalid address\");\r\n        validatorConsensusGovernanceAccountAddress = newGovernanceAccountAddress;\r\n    }\r\n\r\n    modifier onlyValidatorConsensusGovernanceAccountAddress() {\r\n        require(msg.sender == validatorConsensusGovernanceAccountAddress, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidatorConsensusAlgorythmAccountAddress() {\r\n        require(msg.sender == validatorConsensusAlgorythmAccountAddress, \"access denied\");\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validatorConsensusAlgorythmAccountAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"validatorConsensusGovernanceAccountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"validatorConsensusAlgorythmAccountAddress\",\"type\":\"address\"}],\"name\":\"ConstructorDebug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositForUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokenForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validatorConsensusAlgorythmAccountAddress_\",\"type\":\"address\"}],\"name\":\"setValidatorConsensusAlgorythmAccountAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernanceAccountAddress\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ConsensusBridgeDChainSafe", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a606d12df4c107d96c20d6ec93dcf304847ef423", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f480558be2ba27e9501fccd05e0f66c5db71f9d9012b1cb82a9a0c1d89ce7926"}