{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/evm-verifier2/OwnedOPVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport { IEVMVerifier } from \\\"./IEVMVerifier.sol\\\";\\r\\nimport { StateProof, EVMProofHelper } from \\\"./EVMProofHelper.sol\\\";\\r\\n\\r\\nimport { RLPReader } from \\\"@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol\\\";\\r\\nimport { Types } from \\\"@eth-optimism/contracts-bedrock/src/libraries/Types.sol\\\";\\r\\n\\r\\nimport {Hashing} from \\\"../forge-import-bug/Hashing.sol\\\";\\r\\n\\r\\ninterface IL2OutputOracle {\\r\\n\\tfunction latestOutputIndex() external view returns (uint256);\\r\\n\\tfunction getL2Output(uint256 _l2OutputIndex) external view returns (Types.OutputProposal memory);\\r\\n}\\r\\n\\r\\ncontract OwnedOPVerifier is IEVMVerifier, Ownable {\\r\\n\\r\\n\\tevent GatewayConfigChanged(string[] urls, uint256 delay);\\r\\n\\r\\n\\terror OutputRootMismatch(uint256 l2OutputIndex, bytes32 expected, bytes32 actual);\\r\\n\\r\\n\\tIL2OutputOracle immutable oracle;\\r\\n\\r\\n\\tstring[] public gatewayURLs;\\r\\n\\tuint256 public delay;\\r\\n\\r\\n\\tconstructor(IL2OutputOracle _oracle, string[] memory urls, uint256 _delay) Ownable(msg.sender) {\\r\\n\\t\\toracle = _oracle;\\r\\n\\t\\tsetGatewayConfig(urls, _delay);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setGatewayConfig(string[] memory urls, uint256 _delay) onlyOwner public {\\r\\n\\t\\tgatewayURLs = urls;\\r\\n\\t\\tdelay = _delay;\\r\\n\\t\\temit GatewayConfigChanged(urls, _delay);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getStorageContext() external view returns(string[] memory urls, bytes memory context) {\\r\\n\\t\\turls = gatewayURLs;\\r\\n\\t\\tcontext = abi.encode(oracle.latestOutputIndex() - delay);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getStorageValues(bytes memory context, address target, bytes32[] memory commands, bytes[] memory constants, bytes memory proof) external view returns(bytes[] memory values) {\\r\\n\\t\\tuint256 outputIndex = abi.decode(context, (uint256));\\r\\n\\t\\t(Types.OutputRootProof memory outputRootProof, StateProof memory stateProof) = abi.decode(proof, (Types.OutputRootProof, StateProof));\\r\\n\\t\\tTypes.OutputProposal memory l2out = oracle.getL2Output(outputIndex);\\r\\n\\t\\tbytes32 expectedRoot = Hashing.hashOutputRootProof(outputRootProof);\\r\\n\\t\\tif (l2out.outputRoot != expectedRoot) revert OutputRootMismatch(outputIndex, expectedRoot, l2out.outputRoot);\\r\\n\\t\\treturn EVMProofHelper.getStorageValues(target, commands, constants, outputRootProof.stateRoot, stateProof);\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/evm-verifier2/IEVMVerifier.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IEVMVerifier {\\n\\tfunction getStorageContext() external view returns(string[] memory urls, bytes memory context);\\n\\tfunction getStorageValues(bytes memory context, address target, bytes32[] memory commands, bytes[] memory constants, bytes memory proof) external view returns(bytes[] memory values);\\n}\\n\"\r\n    },\r\n    \"contracts/evm-verifier2/EVMProofHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {RLPReader} from \\\"@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol\\\";\\nimport {Bytes} from \\\"@eth-optimism/contracts-bedrock/src/libraries/Bytes.sol\\\";\\n\\n//import {SecureMerkleTrie} from \\\"@eth-optimism/contracts-bedrock/src/libraries/trie/SecureMerkleTrie.sol\\\";\\nimport {SecureMerkleTrie} from \\\"../trie-with-nonexistance/SecureMerkleTrie.sol\\\";\\n\\nstruct StateProof {\\n    bytes[] stateTrieWitness;         // Witness proving the `storageRoot` against a state root.\\n    bytes[][] storageProofs;          // An array of proofs of individual storage elements \\n}\\n\\nuint8 constant FLAG_DYNAMIC = 0x01;\\n\\nlibrary EVMProofHelper {\\n    using Bytes for bytes;\\n\\n    error AccountNotFound(address);\\n    error UnknownOpcode(uint8);\\n    error InvalidSlotSize(uint256 size);\\n\\n    /**\\n     * @notice Get the storage root for the provided merkle proof\\n     * @param stateRoot The state root the witness was generated against\\n     * @param target The address we are fetching a storage root for\\n     * @param witness A witness proving the value of the storage root for `target`.\\n     * @return The storage root retrieved from the provided state root\\n     */\\n    function getStorageRoot(bytes32 stateRoot, address target, bytes[] memory witness) private pure returns (bytes32) {\\n        (bool exists, bytes memory encodedResolverAccount) = SecureMerkleTrie.get(\\n            abi.encodePacked(target),\\n            witness,\\n            stateRoot\\n        );\\n        if(!exists) {\\n            revert AccountNotFound(target);\\n        }\\n        RLPReader.RLPItem[] memory accountState = RLPReader.readList(encodedResolverAccount);\\n        return bytes32(RLPReader.readBytes(accountState[2]));\\n    }\\n\\n    /**\\n     * @notice Prove whether the provided storage slot is part of the storageRoot\\n     * @param storageRoot the storage root for the account that contains the storage slot\\n     * @param slot The storage key we are fetching the value of\\n     * @param witness the StorageProof struct containing the necessary proof data\\n     * @return The retrieved storage proof value or 0x if the storage slot is empty\\n     */\\n    function getSingleStorageProof(bytes32 storageRoot, uint256 slot, bytes[] memory witness) private pure returns (bytes memory) {\\n        (bool exists, bytes memory retrievedValue) = SecureMerkleTrie.get(\\n            abi.encodePacked(slot),\\n            witness,\\n            storageRoot\\n        );\\n        if(!exists) {\\n            // Nonexistent values are treated as zero.\\n            return \\\"\\\";\\n        }\\n        return RLPReader.readBytes(retrievedValue);\\n    }\\n\\n    function getFixedValue(bytes32 storageRoot, uint256 slot, bytes[] memory witness) private pure returns(bytes32) {\\n        bytes memory value = getSingleStorageProof(storageRoot, slot, witness);\\n        // RLP encoded storage slots are stored without leading 0 bytes.\\n        // Casting to bytes32 appends trailing 0 bytes, so we have to bit shift to get the \\n        // original fixed-length representation back.\\n        return bytes32(value) >> (256 - 8 * value.length);\\n    }\\n\\n\\n    function computeFirstSlot(bytes32 command, bytes[] memory constants, bytes[] memory values) private pure returns(bool isDynamic, uint256 slot) {\\n\\t\\tuint8 flags = uint8(command[0]);\\n\\t\\tisDynamic = (flags & FLAG_DYNAMIC) != 0;\\n\\t\\tfor(uint256 j = 1; j < 32; j++) {\\n\\t\\t\\tuint8 op = uint8(command[j]);\\n\\t\\t\\tif (op == 0xFF) break;\\n\\t\\t\\tuint8 operand = op & 0x1F;\\n\\t\\t\\top >>= 5;\\n\\t\\t\\tif (op == 0) {\\n\\t\\t\\t\\tslot = uint256(keccak256(abi.encodePacked(constants[operand], slot)));\\n\\t\\t\\t} else if (op == 1) {\\n \\t\\t\\t\\tslot = uint256(keccak256(abi.encodePacked(values[operand], slot)));\\n\\t\\t\\t} else if (op == 2) {\\n\\t\\t\\t\\tslot += uint256(bytes32(constants[operand]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert UnknownOpcode(op);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    function getDynamicValue(bytes32 storageRoot, uint256 slot, StateProof memory proof, uint256 proofIdx) private pure returns(bytes memory value, uint256 newProofIdx) {\\n        uint256 firstValue = uint256(getFixedValue(storageRoot, slot, proof.storageProofs[proofIdx++]));\\n        if(firstValue & 0x01 == 0x01) {\\n            // Long value: first slot is `length * 2 + 1`, following slots are data.\\n            uint256 length = (firstValue - 1) / 2;\\n            value = \\\"\\\";\\n            slot = uint256(keccak256(abi.encodePacked(slot)));\\n            // This is horribly inefficient - O(n^2). A better approach would be to build an array of words and concatenate them\\n            // all at once, but we're trying to avoid writing new library code.\\n            while(length > 0) {\\n                if(length < 32) {\\n                    value = bytes.concat(value, getSingleStorageProof(storageRoot, slot++, proof.storageProofs[proofIdx++]).slice(0, length));\\n                    length = 0;\\n                } else {\\n                    value = bytes.concat(value, getSingleStorageProof(storageRoot, slot++, proof.storageProofs[proofIdx++]));\\n                    length -= 32;\\n                }\\n            }\\n            return (value, proofIdx);\\n        } else {\\n            // Short value: least significant byte is `length * 2`, other bytes are data.\\n\\t\\t\\tuint256 length = (firstValue & 0xFF) / 2;\\n\\t\\t\\treturn (abi.encode(firstValue).slice(0, length), proofIdx);\\n        }\\n    }\\n\\n    function getStorageValues(address target, bytes32[] memory commands, bytes[] memory constants, bytes32 stateRoot, StateProof memory proof) internal pure returns(bytes[] memory values) {\\n        bytes32 storageRoot = getStorageRoot(stateRoot, target, proof.stateTrieWitness);\\n        uint256 proofIdx = 0;\\n        values = new bytes[](commands.length);\\n        for(uint256 i = 0; i < commands.length; i++) {\\n            bytes32 command = commands[i];\\n            (bool isDynamic, uint256 slot) = computeFirstSlot(command, constants, values);\\n            if(!isDynamic) {\\n                values[i] = abi.encode(getFixedValue(storageRoot, slot, proof.storageProofs[proofIdx++]));\\n                if(values[i].length > 32) {\\n                    revert InvalidSlotSize(values[i].length);\\n                }\\n            } else {\\n                (values[i], proofIdx) = getDynamicValue(storageRoot, slot, proof, proofIdx);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/src/libraries/rlp/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @custom:attribution https://github.com/hamdiallam/Solidity-RLP\\n/// @title RLPReader\\n/// @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\\n///         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\\n///         various tweaks to improve readability.\\nlibrary RLPReader {\\n    /// @notice Custom pointer type to avoid confusion between pointers and uint256s.\\n    type MemoryPointer is uint256;\\n\\n    /// @notice RLP item types.\\n    /// @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\\n    /// @custom:value LIST_ITEM Represents an RLP list item.\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /// @notice Struct representing an RLP item.\\n    /// @custom:field length Length of the RLP item.\\n    /// @custom:field ptr    Pointer to the RLP item in memory.\\n    struct RLPItem {\\n        uint256 length;\\n        MemoryPointer ptr;\\n    }\\n\\n    /// @notice Max list length that this library will accept.\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /// @notice Converts bytes to a reference to memory position and length.\\n    /// @param _in Input bytes to convert.\\n    /// @return out_ Output memory reference.\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {\\n        // Empty arrays are not RLP items.\\n        require(_in.length > 0, \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\");\\n\\n        MemoryPointer ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        out_ = RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {\\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"RLPReader: decoded item type for list is not a list item\\\");\\n\\n        require(listOffset + listLength == _in.length, \\\"RLPReader: list item has an invalid data remainder\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        out_ = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            (uint256 itemOffset, uint256 itemLength,) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset) })\\n            );\\n\\n            // We don't need to check itemCount < out.length explicitly because Solidity already\\n            // handles this check on our behalf, we'd just be wasting gas.\\n            out_[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out_, itemCount)\\n        }\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {\\n        out_ = readList(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"RLPReader: decoded item type for bytes is not a data item\\\");\\n\\n        require(_in.length == itemOffset + itemLength, \\\"RLPReader: bytes value contains an invalid remainder\\\");\\n\\n        out_ = _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        out_ = readBytes(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads the raw bytes of an RLP item.\\n    /// @param _in RLP item to read.\\n    /// @return out_ Raw RLP bytes.\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        out_ = _copy(_in.ptr, 0, _in.length);\\n    }\\n\\n    /// @notice Decodes the length of an RLP item.\\n    /// @param _in RLP item to decode.\\n    /// @return offset_ Offset of the encoded data.\\n    /// @return length_ Length of the encoded data.\\n    /// @return type_ RLP item type (LIST_ITEM or DATA_ITEM).\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (uint256 offset_, uint256 length_, RLPItemType type_)\\n    {\\n        // Short-circuit if there's nothing to decode, note that we perform this check when\\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\\n        // that function and create an RLP item directly. So we need to check this anyway.\\n        require(_in.length > 0, \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\");\\n\\n        MemoryPointer ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen, \\\"RLPReader: length of content must be greater than string length (short string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                strLen != 1 || firstByteOfContent >= 0x80,\\n                \\\"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"RLPReader: length of content must be > than length of string length (long string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00, \\\"RLPReader: length of content must not have any leading zeros (long string)\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(strLen > 55, \\\"RLPReader: length of content must be greater than 55 bytes (long string)\\\");\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"RLPReader: length of content must be greater than total length (long string)\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"RLPReader: length of content must be greater than list length (short list)\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"RLPReader: length of content must be > than length of list length (long list)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00, \\\"RLPReader: length of content must not have any leading zeros (long list)\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(listLen > 55, \\\"RLPReader: length of content must be greater than 55 bytes (long list)\\\");\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"RLPReader: length of content must be greater than total length (long list)\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /// @notice Copies the bytes from a memory location.\\n    /// @param _src    Pointer to the location to read from.\\n    /// @param _offset Offset to start reading from.\\n    /// @param _length Number of bytes to read.\\n    /// @return out_ Copied bytes.\\n    function _copy(MemoryPointer _src, uint256 _offset, uint256 _length) private pure returns (bytes memory out_) {\\n        out_ = new bytes(_length);\\n        if (_length == 0) {\\n            return out_;\\n        }\\n\\n        // Mostly based on Solidity's copy_memory_to_memory:\\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\\n        assembly {\\n            let dest := add(out_, 32)\\n            let i := 0\\n            for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }\\n\\n            if gt(i, _length) { mstore(add(dest, _length), 0) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/src/libraries/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Types\\n/// @notice Contains various types used throughout the Optimism contract system.\\nlibrary Types {\\n    /// @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n    ///         timestamp that the output root is posted. This timestamp is used to verify that the\\n    ///         finalization period has passed since the output root was submitted.\\n    /// @custom:field outputRoot    Hash of the L2 output.\\n    /// @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n    /// @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /// @notice Struct representing the elements that are hashed together to generate an output root\\n    ///         which itself represents a snapshot of the L2 state.\\n    /// @custom:field version                  Version of the output root.\\n    /// @custom:field stateRoot                Root of the state trie at the block of this output.\\n    /// @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n    /// @custom:field latestBlockhash          Hash of the block this output was generated from.\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /// @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n    ///         user (as opposed to a system deposit transaction generated by the system).\\n    /// @custom:field from        Address of the sender of the transaction.\\n    /// @custom:field to          Address of the recipient of the transaction.\\n    /// @custom:field isCreation  True if the transaction is a contract creation.\\n    /// @custom:field value       Value to send to the recipient.\\n    /// @custom:field mint        Amount of ETH to mint.\\n    /// @custom:field gasLimit    Gas limit of the transaction.\\n    /// @custom:field data        Data of the transaction.\\n    /// @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n    /// @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 value;\\n        uint256 mint;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /// @notice Struct representing a withdrawal transaction.\\n    /// @custom:field nonce    Nonce of the withdrawal transaction\\n    /// @custom:field sender   Address of the sender of the transaction.\\n    /// @custom:field target   Address of the recipient of the transaction.\\n    /// @custom:field value    Value to send to the recipient.\\n    /// @custom:field gasLimit Gas limit of the transaction.\\n    /// @custom:field data     Data of the transaction.\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 value;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/forge-import-bug/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n//import { Hashing } from \\\"@eth-optimism/contracts-bedrock/src/libraries/Hashing.sol\\\";\\n\\nimport { Types } from \\\"@eth-optimism/contracts-bedrock/src/libraries/Types.sol\\\";\\n\\n/// @title Hashing\\n/// @notice Hashing handles Optimism's various different hashing schemes.\\nlibrary Hashing {\\n  \\n    /// @notice Hashes the various elements of an output root proof into an output root hash which\\n    ///         can be used to check if the proof is valid.\\n    /// @param _outputRootProof Output root proof which should hash to an output root.\\n    /// @return Hashed output root proof.\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _outputRootProof.version,\\n                _outputRootProof.stateRoot,\\n                _outputRootProof.messagePasserStorageRoot,\\n                _outputRootProof.latestBlockhash\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/src/libraries/Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Bytes\\n/// @notice Bytes is a library for manipulating byte arrays.\\nlibrary Bytes {\\n    /// @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\\n    /// @notice Slices a byte array with a given starting index and length. Returns a new byte array\\n    ///         as opposed to a pointer to the original array. Will throw if trying to slice more\\n    ///         bytes than exist in the array.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @param _length Length of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        unchecked {\\n            require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n            require(_start + _length >= _start, \\\"slice_overflow\\\");\\n            require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } { mstore(mc, mload(cc)) }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// @notice Slices a byte array with a given starting index up to the end of the original byte\\n    ///         array. Returns a new array rathern than a pointer to the original.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    /// @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\\n    ///         Resulting nibble array will be exactly twice as long as the input byte array.\\n    /// @param _bytes Input byte array to convert.\\n    /// @return Resulting nibble array.\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory _nibbles;\\n        assembly {\\n            // Grab a free memory offset for the new array\\n            _nibbles := mload(0x40)\\n\\n            // Load the length of the passed bytes array from memory\\n            let bytesLength := mload(_bytes)\\n\\n            // Calculate the length of the new nibble array\\n            // This is the length of the input array times 2\\n            let nibblesLength := shl(0x01, bytesLength)\\n\\n            // Update the free memory pointer to allocate memory for the new array.\\n            // To do this, we add the length of the new array + 32 bytes for the array length\\n            // rounded up to the nearest 32 byte boundary to the current free memory pointer.\\n            mstore(0x40, add(_nibbles, and(not(0x1F), add(nibblesLength, 0x3F))))\\n\\n            // Store the length of the new array in memory\\n            mstore(_nibbles, nibblesLength)\\n\\n            // Store the memory offset of the _bytes array's contents on the stack\\n            let bytesStart := add(_bytes, 0x20)\\n\\n            // Store the memory offset of the nibbles array's contents on the stack\\n            let nibblesStart := add(_nibbles, 0x20)\\n\\n            // Loop through each byte in the input array\\n            for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {\\n                // Get the starting offset of the next 2 bytes in the nibbles array\\n                let offset := add(nibblesStart, shl(0x01, i))\\n                // Load the byte at the current index within the `_bytes` array\\n                let b := byte(0x00, mload(add(bytesStart, i)))\\n\\n                // Pull out the first nibble and store it in the new array\\n                mstore8(offset, shr(0x04, b))\\n                // Pull out the second nibble and store it in the new array\\n                mstore8(add(offset, 0x01), and(b, 0x0F))\\n            }\\n        }\\n        return _nibbles;\\n    }\\n\\n    /// @notice Compares two byte arrays by comparing their keccak256 hashes.\\n    /// @param _bytes First byte array to compare.\\n    /// @param _other Second byte array to compare.\\n    /// @return True if the two byte arrays are equal, false otherwise.\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/trie-with-nonexistance/SecureMerkleTrie.sol\": {\r\n      \"content\": \"// Pulled from https://github.com/ethereum-optimism/optimism/blob/4d13f0afe8869faf7bba45d8339998525ebc5161/packages/contracts-bedrock/contracts/libraries/trie/MerkleTrie.sol\\n//   as this is the last version of Optimism's Merkle Trie library that supports nonexistence proofs; support was removed\\n//   in the next commit for some version.\\n// Copyright 2020-2021 Optimism\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/* Library Imports */\\nimport { MerkleTrie } from \\\"./MerkleTrie.sol\\\";\\n\\n/**\\n * @title SecureMerkleTrie\\n * @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\\n *         keys. Ethereum's state trie hashes input keys before storing them.\\n */\\nlibrary SecureMerkleTrie {\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\\n     *\\n     * @param _key   Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n     *               nodes that make a path down to the target node.\\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n     *               correctly constructed.\\n     *\\n     * @return Whether or not the proof is valid.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool) {\\n        bytes memory key = _getSecureKey(_key);\\n        return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     *\\n     * @param _key   Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root  Known root of the Merkle trie.\\n     *\\n     * @return Whether or not the key exists.\\n     * @return Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool, bytes memory) {\\n        bytes memory key = _getSecureKey(_key);\\n        return MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Computes the hashed version of the input key.\\n     *\\n     * @param _key Key to hash.\\n     *\\n     * @return Hashed version of the key.\\n     */\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory) {\\n        return abi.encodePacked(keccak256(_key));\\n    }\\n}\"\r\n    },\r\n    \"contracts/trie-with-nonexistance/MerkleTrie.sol\": {\r\n      \"content\": \"// Pulled from https://github.com/ethereum-optimism/optimism/blob/4d13f0afe8869faf7bba45d8339998525ebc5161/packages/contracts-bedrock/contracts/libraries/trie/MerkleTrie.sol\\n//   as this is the last version of Optimism's Merkle Trie library that supports nonexistence proofs; support was removed\\n//   in the next commit for some version.\\n// Copyright 2020-2021 Optimism\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Bytes } from \\\"@eth-optimism/contracts-bedrock/src/libraries/Bytes.sol\\\";\\nimport { RLPReader } from \\\"@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol\\\";\\n\\n\\n/**\\n * @title MerkleTrie\\n * @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\\n *         inclusion proofs. By default, this library assumes a hexary trie. One can change the\\n *         trie radix constant to support other trie radixes.\\n */\\nlibrary MerkleTrie {\\n    /**\\n     * @notice Struct representing a node in the trie.\\n     */\\n    struct TrieNode {\\n        bytes encoded;\\n        RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /**\\n     * @notice Determines the number of elements per branch node.\\n     */\\n    uint256 internal constant TREE_RADIX = 16;\\n\\n    /**\\n     * @notice Branch nodes have TREE_RADIX elements and one value element.\\n     */\\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n\\n    /**\\n     * @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\\n     */\\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    /**\\n     * @notice Prefix for even-nibbled extension node paths.\\n     */\\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\\n\\n    /**\\n     * @notice Prefix for odd-nibbled extension node paths.\\n     */\\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\\n\\n    /**\\n     * @notice Prefix for even-nibbled leaf node paths.\\n     */\\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\\n\\n    /**\\n     * @notice Prefix for odd-nibbled leaf node paths.\\n     */\\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\\n\\n    /**\\n     * @notice RLP representation of `NULL`.\\n     */\\n    bytes internal constant RLP_NULL = hex\\\"80\\\";\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\\n     *\\n     * @param _key   Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n     *               nodes that make a path down to the target node.\\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n     *               correctly constructed.\\n     *\\n     * @return Whether or not the proof is valid.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool) {\\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\\n        return (exists && Bytes.equal(_value, value));\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     *\\n     * @param _key   Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root  Known root of the Merkle trie.\\n     *\\n     * @return Whether or not the key exists.\\n     * @return Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool, bytes memory) {\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\\n            proof,\\n            _key,\\n            _root\\n        );\\n\\n        bool noRemainder = keyRemainder.length == 0;\\n\\n        require(noRemainder || isFinalNode, \\\"MerkleTrie: provided proof is invalid\\\");\\n\\n        bytes memory value = noRemainder ? _getNodeValue(proof[pathLength - 1]) : bytes(\\\"\\\");\\n\\n        return (value.length > 0, value);\\n    }\\n\\n    /**\\n     * @notice Walks through a proof using a provided key.\\n     *\\n     * @param _proof Inclusion proof to walk through.\\n     * @param _key   Key to use for the walk.\\n     * @param _root  Known root of the trie.\\n     *\\n     * @return Length of the final path\\n     * @return Portion of the key remaining after the walk.\\n     * @return Whether or not we've hit a dead end.\\n     */\\n    // solhint-disable-next-line code-complexity\\n    function _walkNodePath(\\n        TrieNode[] memory _proof,\\n        bytes memory _key,\\n        bytes32 _root\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            bytes memory,\\n            bool\\n        )\\n    {\\n        uint256 pathLength = 0;\\n        bytes memory key = Bytes.toNibbles(_key);\\n\\n        bytes memory currentNodeID = abi.encodePacked(_root);\\n        uint256 currentKeyIndex = 0;\\n        uint256 currentKeyIncrement = 0;\\n        TrieNode memory currentNode;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < _proof.length; i++) {\\n            currentNode = _proof[i];\\n            currentKeyIndex += currentKeyIncrement;\\n\\n            // Keep track of the proof elements we actually need.\\n            // It's expensive to resize arrays, so this simply reduces gas costs.\\n            pathLength += 1;\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid root hash\\\"\\n                );\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 32 bytes aren't hashed.\\n                require(\\n                    Bytes.equal(currentNode.encoded, currentNodeID),\\n                    \\\"MerkleTrie: invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // We've hit the end of the key\\n                    // meaning the value should be within this branch node.\\n                    break;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIncrement = 1;\\n                    continue;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Bytes.slice(path, offset);\\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                require(\\n                    keyRemainder.length >= pathRemainder.length,\\n                    \\\"MerkleTrie: invalid key length for leaf or extension node\\\"\\n                );\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    if (\\n                        pathRemainder.length == sharedNibbleLength &&\\n                        keyRemainder.length == sharedNibbleLength\\n                    ) {\\n                        // The key within this leaf matches our key exactly.\\n                        // Increment the key index to reflect that we have no remainder.\\n                        currentKeyIndex += sharedNibbleLength;\\n                    }\\n\\n                    // We've hit a leaf node, so our next node should be NULL.\\n                    currentNodeID = RLP_NULL;\\n                    break;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    if (sharedNibbleLength != pathRemainder.length) {\\n                        // Our extension node is not identical to the remainder.\\n                        // We've hit the end of this path\\n                        // updates will need to modify this extension.\\n                        currentNodeID = RLP_NULL;\\n                        break;\\n                    } else {\\n                        // Our extension shares some nibbles.\\n                        // Carry on to the next node.\\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                        currentKeyIncrement = sharedNibbleLength;\\n                        continue;\\n                    }\\n                } else {\\n                    revert(\\\"MerkleTrie: received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"MerkleTrie: received an unparseable node\\\");\\n            }\\n        }\\n\\n        return (\\n            pathLength,\\n            Bytes.slice(key, currentKeyIndex),\\n            Bytes.equal(currentNodeID, RLP_NULL)\\n        );\\n    }\\n\\n    /**\\n     * @notice Parses an array of proof elements into a new array that contains both the original\\n     *         encoded element and the RLP-decoded element.\\n     *\\n     * @param _proof Array of proof elements to parse.\\n     *\\n     * @return Proof parsed into easily accessible structs.\\n     */\\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory) {\\n        uint256 length = _proof.length;\\n        TrieNode[] memory proof = new TrieNode[](length);\\n        for (uint256 i = 0; i < length; ) {\\n            proof[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return proof;\\n    }\\n\\n    /**\\n     * @notice Picks out the ID for a node. Node ID is referred to as the \\\"hash\\\" within the\\n     *         specification, but nodes < 32 bytes are not actually hashed.\\n     *\\n     * @param _node Node to pull an ID for.\\n     *\\n     * @return ID for the node, depending on the size of its contents.\\n     */\\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory) {\\n        return _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\\n    }\\n\\n    /**\\n     * @notice Gets the path for a leaf or extension node.\\n     *\\n     * @param _node Node to get a path for.\\n     *\\n     * @return Node path, converted to an array of nibbles.\\n     */\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory) {\\n        return Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /**\\n     * @notice Gets the value for a node.\\n     *\\n     * @param _node Node to get a value for.\\n     *\\n     * @return Node value, as hex bytes.\\n     */\\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory) {\\n        return RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\\n    }\\n\\n    /**\\n     * @notice Utility; determines the number of nibbles shared between two nibble arrays.\\n     *\\n     * @param _a First nibble array.\\n     * @param _b Second nibble array.\\n     *\\n     * @return Number of shared nibbles.\\n     */\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 shared;\\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\\n        for (; shared < max && _a[shared] == _b[shared]; ) {\\n            unchecked {\\n                ++shared;\\n            }\\n        }\\n        return shared;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@ensdomains/ens-contracts/=lib/ens-contracts/\",\r\n      \"@eth-optimism/=lib/optimism/packages/\",\r\n      \"clones-with-immutable-args/=lib/optimism/packages/contracts-bedrock/lib/clones-with-immutable-args/src/\",\r\n      \"ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"ens-contracts/=lib/ens-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"kontrol-cheatcodes/=lib/optimism/packages/contracts-bedrock/lib/kontrol-cheatcodes/src/\",\r\n      \"lib-keccak/=lib/optimism/packages/contracts-bedrock/lib/lib-keccak/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/optimism/packages/contracts-bedrock/lib/safe-contracts/contracts/\",\r\n      \"solady/=lib/optimism/packages/contracts-bedrock/lib/solady/\",\r\n      \"solmate/=lib/optimism/packages/contracts-bedrock/lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IL2OutputOracle\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AccountNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"InvalidSlotSize\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"l2OutputIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"expected\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actual\",\"type\":\"bytes32\"}],\"name\":\"OutputRootMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"UnknownOpcode\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"GatewayConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gatewayURLs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStorageContext\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"constants\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"getStorageValues\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"values\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setGatewayConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OwnedOPVerifier", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000056315b90c40730925ec5485cf004d835058518a00000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002d68747470733a2f2f686f6d652e616e74697374757069642e636f6d2f626173652d65766d2d676174657761792f00000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}