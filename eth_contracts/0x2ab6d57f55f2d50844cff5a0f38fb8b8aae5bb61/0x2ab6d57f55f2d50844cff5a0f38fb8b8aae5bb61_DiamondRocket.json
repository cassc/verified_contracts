{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/DiamondRocket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*                                                                       ! \\n                                                                         ! \\n                                                                         ^\\n              ____  _                                 __                / \\\\\\n             / __ \\\\(_)___ _____ ___  ____  ____  ____/ /               /___\\\\ \\n            / / / / / __ `/ __ `__ \\\\/ __ \\\\/ __ \\\\/ __  /               |=   =|\\n           / /_/ / / /_/ / / / / / / /_/ / / / / /_/ /                |     |\\n          /_____/_/\\\\__,_/_/ /_/ /_/\\\\____/_/ /_/\\\\__,_/                 |     |                                                 \\n                                                                      |     |\\n                                                                      |     |\\n                 ____             __        __                        |     |\\n                / __ \\\\____  _____/ /_____  / /_                       |     |\\n               / /_/ / __ \\\\/ ___/ //_/ _ \\\\/ __/                       |##!##| \\n              / _, _/ /_/ / /__/ ,< /  __/ /_                        /|##!##|\\\\       \\n             /_/ |_|\\\\____/\\\\___/_/|_|\\\\___/\\\\__/                      /  |##!##|  \\\\       \\n                                                                  |  / ^ | ^ \\\\  |       \\n                                                                  | /  ( | )  \\\\ |\\n                                                                  |/   ( | )   \\\\|\\n                                                                      ((   ))         \\n                                                                     ((  :  ))                                                \\n                                                                     ((  :  ))                \\n                                                                     ((  :  ))      \\n                                                                      ((   ))                                               \\nWebsite: https://diamondrocketeth.com/                                 (( ))\\n                                                                        ( )\\nTelegram: https://t.me/diamondrocketeth                                  .\\n                                                                   .     '     ,\\nTwitter: https://twitter.com/DiamondRock3t                           _________\\n                                                                  _ /_|_____|_\\\\ _\\n                                                                    '. \\\\   / .'\\n                                                                      '.\\\\ /.'\\n                                                                        '.'                   */                                                                                                                                                                                   \\npragma solidity ^0.8.17;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport \\\"interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"interfaces/IUniswapV2Factory.sol\\\";\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract DiamondRocket is IERC20, Ownable {\\n    string public name = \\\"Diamond Rocket\\\";\\n    string public symbol = \\\"DIAMOND\\\";\\n    uint8 public decimals = 18;\\n    uint256 public totalSupply;\\n\\n    uint256 public maxTax;\\n    uint256 public baseTax;\\n\\n    uint256 maxWallet;\\n    bool public tradingEnabled = false;\\n\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) isExcludedFromTax;\\n    mapping(address => uint256) lastTimeReceived;\\n\\n    address[] holders;\\n    address payable[] public latestWinners;\\n    uint256 public totalJackpotValue;\\n\\n    address payable public jackpotFeeWallet = payable(0x5a0D3cb7ac52A17b36E26E369aFF095a1E54350b);\\n    address payable public buyBackFeeWallet = payable(0xA433b923040Da5DE7a43B10d3849CFee2922fF6B);\\n\\n    IUniswapV2Pair public uniswapV2Pair;\\n    IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    address payable treasury = payable(address(this));\\n\\n    constructor() {\\n        totalSupply = 100_000_000e18;\\n        _balances[msg.sender] = totalSupply;\\n\\n        maxWallet = totalSupply * 3 / 100;\\n\\n        uniswapV2Pair = IUniswapV2Pair(\\n            IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH())\\n        );\\n\\n        maxTax = 2400;\\n        baseTax = 1200;\\n\\n        isExcludedFromTax[msg.sender] = true;\\n        isExcludedFromTax[address(this)] = true;\\n        isExcludedFromTax[address(uniswapV2Pair)] = true;\\n        isExcludedFromTax[address(uniswapV2Router)] = true;\\n    }\\n\\n    function openTrading() public onlyOwner {\\n        tradingEnabled = true;\\n    }\\n\\n    bool inSwap = false;\\n\\n    modifier lockTheSwap() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    receive() external payable {}\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 amount) private {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        uint256 forBuyBack = tokenAmount / 3;\\n        uint256 forJackpot = tokenAmount - forBuyBack;\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            forBuyBack, 0, path, buyBackFeeWallet, block.timestamp\\n        );\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            forJackpot, 0, path, treasury, block.timestamp\\n        );\\n    }\\n\\n    function burnFrom(address account, uint256 amount) private {\\n        _balances[account] -= amount;\\n        totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        emit Transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\n        _spendAllowance(sender, _msgSender(), amount);\\n        _transfer(sender, recipient, amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\n        require(tradingEnabled || (isExcludedFromTax[sender] && isExcludedFromTax[recipient]), \\\"Can't trade yet\\\");\\n\\n        if (sender == address(uniswapV2Pair) && !isExcludedFromTax[recipient]) {\\n            require(amount + _balances[recipient] <= maxWallet, \\\"Transfer amount exceeds the maxWallet\\\");\\n        }\\n        if (recipient == address(uniswapV2Pair) && !isExcludedFromTax[sender]) {\\n            uint256 tax = (amount * viewTax(sender)) / 10000;\\n            uint256 toBurn;\\n            uint256 toEth;\\n            amount -= tax;\\n\\n            if (viewTax(sender) > baseTax) {\\n                toBurn = (amount * (viewTax(sender) - baseTax)) / 10000;\\n                toEth = tax - toBurn;\\n            } else {\\n                toBurn = 0;\\n                toEth = tax;\\n            }\\n            _balances[address(this)] += toEth;\\n            _balances[address(0x000000000000000000000000000000000000dEaD)] += toBurn;\\n            _balances[sender] -= tax;\\n        }\\n\\n        uint256 contractTokenBalance = _balances[address(this)];\\n        bool canSwap = contractTokenBalance > 0;\\n        if (canSwap && !inSwap && sender != address(uniswapV2Pair) && !isExcludedFromTax[sender]) {\\n\\n            swapTokensForEth(contractTokenBalance);\\n        }\\n\\n        if (isAlreadyHolder[recipient] == false && !isExcludedFromTax[recipient]) {\\n            holders.push(recipient);\\n            isAlreadyHolder[recipient] = true;\\n        }\\n\\n        lastTimeReceived[recipient] = block.timestamp;\\n\\n        _balances[sender] -= amount;\\n        _balances[recipient] += amount;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function viewTax(address _user) public view returns (uint256) {\\n        if (lastTimeReceived[_user] + 86400 > block.timestamp) {\\n            return calculateTax(_user);\\n        } else {\\n            return baseTax;\\n        }\\n    }\\n\\n    function calculateTax(address _user) public view returns (uint256) {\\n        if (maxTax == 0) {\\n            return baseTax;\\n        } else {\\n            uint256 secondsLeft = (lastTimeReceived[_user] + 86400) - block.timestamp;\\n            //additional time to create transition between additional and base tax\\n            uint256 secs = (baseTax * 1e36 / ((maxTax * 1e18) / 86400)) / 1e18;\\n            uint256 tax = ((maxTax) * 1e18) / (86400 + secs) * (secondsLeft + secs);\\n            return tax / 1e18;\\n        }\\n    }\\n\\n    function viewHolders() public view returns (address[] memory) {\\n        return holders;\\n    }\\n\\n    function viewLatestWinners() public view returns (address payable[] memory) {\\n        return latestWinners;\\n    }\\n\\n    mapping(address => bool) public isAlreadyHolder;\\n\\n    function LuckyDraw(uint256 numberOfWinners, uint256 perGiveaway) external onlyOwner {\\n        require(holders.length > 0, \\\"No holders available\\\");\\n        require(numberOfWinners > 0 && numberOfWinners <= holders.length, \\\"Invalid number of winners\\\");\\n\\n        uint256[] memory probabilities = new uint256[](holders.length);\\n        uint256 totalProbability = 0;\\n\\n        // Calculate the probability for each eligible holder based on their token holdings\\n        for (uint256 i = 0; i < holders.length; i++) {\\n            address holder = holders[i];\\n            if (!isExcludedFromTax[holder]) {\\n                probabilities[i] = _balances[holder];\\n                totalProbability = totalProbability + probabilities[i];\\n            }\\n        }\\n        address payable[] memory winners = new address payable[](numberOfWinners);\\n        uint256 balance = address(this).balance * perGiveaway / 100;\\n        uint256 remainingBalance = balance;\\n        uint256 seed = balance * totalProbability; //Seed is random since the total balance of non excluded wallets and the final total eth value before transaction are random enough\\n        totalJackpotValue = totalJackpotValue + balance;\\n\\n        for (uint256 i = 0; i < numberOfWinners; i++) {\\n            uint256 winningNumber =\\n                uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, seed, i))) % totalProbability;\\n            uint256 cumulativeProbability = 0;\\n\\n            for (uint256 j = 0; j < holders.length; j++) {\\n                address holder = holders[j];\\n\\n                if (!isExcludedFromTax[holder]) {\\n                    cumulativeProbability += probabilities[j];\\n\\n                    if (winningNumber < cumulativeProbability) {\\n                        winners[i] = payable(holder);\\n                        uint256 share = remainingBalance / 2;\\n                        (bool success,) = winners[i].call{value: share, gas: 100000}(\\\"Winners get their jackpots\\\");\\n                        if (!success) {\\n                            (bool succes,) = payable(jackpotFeeWallet).call{value: share, gas: 100000}(\\n                                \\\"This is just a protection. If you see you wallet in the Winning list but did not receive it. Check if it is send to jackpotFeeWallet. Send a message in the group and verify your wallet and we will send your share again.\\\"\\n                            );\\n                        }\\n                        remainingBalance -= share;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        (bool success,) = winners[0].call{value: remainingBalance, gas: 100000}(\\\"The Jackpot winner gets the rest\\\");\\n        if (!success) {\\n            (bool succes,) = payable(jackpotFeeWallet).call{value: remainingBalance, gas: 100000}(\\n                \\\"This is just a protection. If you see you wallet in the Winning list but did not receive it. Check if it is send to jackpotFeeWallet. Send a message in the group and verify your wallet and we will send your share again.\\\"\\n            );\\n        }\\n\\n        latestWinners = winners;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfWinners\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perGiveaway\",\"type\":\"uint256\"}],\"name\":\"LuckyDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackFeeWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"calculateTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAlreadyHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotFeeWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"latestWinners\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalJackpotValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewHolders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewLatestWinners\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DiamondRocket", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}