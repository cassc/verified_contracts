{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DssVestMintableCloneFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport {DssVestCloneFactory} from \\\"./DssVestCloneFactory.sol\\\";\\nimport {DssVestMintable} from \\\"./DssVest.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\ncontract DssVestMintableCloneFactory is DssVestCloneFactory {\\n\\n    constructor(address _implementation) DssVestCloneFactory(_implementation) {}\\n\\n    /**\\n     * @notice Creates a new DssVestMintable contract and initializes it.\\n     * @dev The trusted forwarder of the implementation is reused, it can not be updated.\\n     * @param salt The salt used to deterministically generate the clone address\\n     * @param gem The address of the ERC-20 token to be vested\\n     * @param ward The address that will be the first ward of the contract\\n     * @return The address of the newly created clone\\n     */\\n    function createMintableVestingClone(bytes32 salt, address gem, address ward, uint256 cap) external returns (address) {\\n        address clone = Clones.cloneDeterministic(implementation, salt);\\n        DssVestMintable(clone).initialize(gem, ward, cap);\\n        emit NewClone(clone);\\n        return clone;\\n    }\\n}\"\r\n    },\r\n    \"src/DssVestCloneFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\nabstract contract  DssVestCloneFactory {\\n    event NewClone(address clone);\\n\\n    /// The address of the implementation to clone\\n    address immutable implementation;\\n\\n    constructor(address _implementation) {\\n        require(_implementation != address(0), \\\"DssVestCloneFactory/null-implementation\\\");\\n        implementation = _implementation;\\n\\n    }\\n\\n    /**\\n     * @notice Predicts the address of a clone that will be created\\n     * @param salt The salt used to deterministically generate the clone address\\n     * @return The address of the clone that will be created\\n     * @dev This function does not check if the clone has already been created\\n     */\\n    function predictCloneAddress(bytes32 salt)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return\\n            Clones.predictDeterministicAddress(\\n                implementation,\\n                salt\\n            );\\n    }\\n}\"\r\n    },\r\n    \"src/DssVest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n// DssVest - Token vesting contract\\n//\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\ninterface MintLike {\\n    function mint(address, uint256) external;\\n}\\n\\ninterface ChainlogLike {\\n    function getAddress(bytes32) external view returns (address);\\n}\\n\\ninterface DaiJoinLike {\\n    function exit(address, uint256) external;\\n}\\n\\ninterface VatLike {\\n    function hope(address) external;\\n    function suck(address, address, uint256) external;\\n    function live() external view returns (uint256);\\n}\\n\\ninterface TokenLike {\\n    function transferFrom(address, address, uint256) external returns (bool);\\n    function transfer(address, uint256) external returns (bool);\\n}\\n\\nabstract contract DssVest is ERC2771Context, Initializable {\\n    // --- Data ---\\n    mapping (address => uint256) public wards;\\n\\n    struct Award {\\n        address usr;   // Vesting recipient\\n        uint48  bgn;   // Start of vesting period  [timestamp]\\n        uint48  clf;   // The cliff date           [timestamp]\\n        uint48  fin;   // End of vesting period    [timestamp]\\n        address mgr;   // A manager address that can yank\\n        uint8   res;   // Restricted\\n        uint128 tot;   // Total reward amount\\n        uint128 rxd;   // Amount of vest claimed\\n    }\\n    mapping (uint256 => Award) public awards;\\n\\n    uint256 public cap; // Maximum per-second issuance token rate\\n\\n    uint256 public ids; // Total vestings\\n\\n    uint256 internal locked;\\n\\n    uint256 public constant  TWENTY_YEARS = 20 * 365 days;\\n\\n    mapping (bytes32 => bool) public commitments; // hashes that can be used to create vesting plans\\n    mapping (bytes32 => uint256) public revocations; // revocations of commitments with revocation timestamp\\n\\n    // --- Events ---\\n    event Rely(address indexed usr);\\n    event Deny(address indexed usr);\\n\\n    event File(bytes32 indexed what, uint256 data);\\n\\n    event Commit(bytes32 indexed hash);\\n    event Revoke(bytes32 indexed hash, uint256 end);\\n    event Claim(bytes32 indexed hash, uint256 indexed id);\\n    event Init(uint256 indexed id, address indexed usr);\\n    event Vest(uint256 indexed id, uint256 amt);\\n    event Restrict(uint256 indexed id);\\n    event Unrestrict(uint256 indexed id);\\n    event Yank(uint256 indexed id, uint256 end);\\n    event Move(uint256 indexed id, address indexed dst);\\n\\n    // Getters to access only to the value desired\\n    function usr(uint256 _id) external view returns (address) {\\n        return awards[_id].usr;\\n    }\\n\\n    function bgn(uint256 _id) external view returns (uint256) {\\n        return awards[_id].bgn;\\n    }\\n\\n    function clf(uint256 _id) external view returns (uint256) {\\n        return awards[_id].clf;\\n    }\\n\\n    function fin(uint256 _id) external view returns (uint256) {\\n        return awards[_id].fin;\\n    }\\n\\n    function mgr(uint256 _id) external view returns (address) {\\n        return awards[_id].mgr;\\n    }\\n\\n    function res(uint256 _id) external view returns (uint256) {\\n        return awards[_id].res;\\n    }\\n\\n    function tot(uint256 _id) external view returns (uint256) {\\n        return awards[_id].tot;\\n    }\\n\\n    function rxd(uint256 _id) external view returns (uint256) {\\n        return awards[_id].rxd;\\n    }\\n\\n    /**\\n        @dev Base vesting logic contract constructor\\n        @param _trustedForwarder The trusted forwarder contract to be used for meta-transactions (see EIP-2771)\\n        @param _cap The maximum per-second issuance token rate\\n    */\\n    constructor (address _trustedForwarder, uint256 _cap) ERC2771Context(_trustedForwarder) initializer {\\n        initialize(_msgSender(), _cap);   \\n    }\\n\\n    /**\\n        @notice Initialize the contract\\n        @dev This function can only be called once. Because the child contracts use the `initializer` modifier,\\n             it can not be used here. Instead, this function is protected manually with the `initialized` flag.\\n             Since this contract is abstract, it should not be possible to call this function directly in the first place.\\n        @dev The forwarder can not be initialized, so it can not be changed for cloned contracts. Instead, it is inherited \\n             from the logic contract (the forwarder address is copied into the bytecode of the logic contract during contract\\n             creation because it is private immutable).\\n        @param _ward The address to be granted admin rights to the contract\\n        @param _cap The maximum per-second issuance token rate\\n     */\\n    function initialize(address _ward, uint256 _cap) public onlyInitializing { \\n        wards[_ward] = 1;\\n        emit Rely(_ward);\\n        cap = _cap;\\n        emit File(\\\"cap\\\", _cap);\\n    }\\n\\n    // --- Mutex ---\\n    modifier lock {\\n        require(locked == 0, \\\"DssVest/system-locked\\\");\\n        locked = 1;\\n        _;\\n        locked = 0;\\n    }\\n\\n    // --- Auth ---\\n    modifier auth {\\n        require(wards[_msgSender()] == 1, \\\"DssVest/not-authorized\\\");\\n        _;\\n    }\\n\\n    function rely(address _usr) external auth {\\n        wards[_usr] = 1;\\n        emit Rely(_usr);\\n    }\\n    function deny(address _usr) external auth {\\n        wards[_usr] = 0;\\n        emit Deny(_usr);\\n    }\\n\\n    /**\\n        @dev (Required) Set the per-second token issuance rate.\\n        @param what  The tag of the value to change (ex. bytes32(\\\"cap\\\"))\\n        @param data  The value to update (ex. cap of 1000 tokens/yr == 1000*WAD/365 days)\\n    */\\n    function file(bytes32 what, uint256 data) external lock auth {\\n        if      (what == \\\"cap\\\")         cap = data;     // The maximum amount of tokens that can be streamed per-second per vest\\n        else revert(\\\"DssVest/file-unrecognized-param\\\");\\n        emit File(what, data);\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? y : x;\\n    }\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"DssVest/add-overflow\\\");\\n    }\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"DssVest/sub-underflow\\\");\\n    }\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"DssVest/mul-overflow\\\");\\n    }\\n    function toUint48(uint256 x) internal pure returns (uint48 z) {\\n        require((z = uint48(x)) == x, \\\"DssVest/uint48-overflow\\\");\\n    }\\n    function toUint128(uint256 x) internal pure returns (uint128 z) {\\n        require((z = uint128(x)) == x, \\\"DssVest/uint128-overflow\\\");\\n    }\\n\\n    /** \\n        @dev commit to the creation of an award without revealing the award's contents yet\\n        @param bch  Blind Commitment Hash - The hash of the award's contents, see hash in `claim` for details\\n    */\\n    function commit(bytes32 bch) external lock auth {\\n        commitments[bch] = true;\\n        emit Commit(bch);\\n    }\\n\\n    /** \\n        @dev Store the timestamp of a commitment revocation. This can be used to prevent a commitment from being claimed if the cliff has not been reached yet.\\n        @notice This function can be called again and will update the timestamp, which could be used to grant more tokens.\\n        @param bch  Blind Commitment Hash - The hash of the award's contents, see hash in `claim` for details\\n        @param end  When to terminate the vesting contract that can be created from the commitment. Any time in the past will be capped to the current timestamp.\\n    */\\n    function revoke(bytes32 bch, uint256 end) external lock auth {\\n        require(commitments[bch], \\\"DssVest/commitment-not-found\\\");\\n        end = block.timestamp > end ? block.timestamp : end; // can not revoke in the past\\n        revocations[bch] = end;\\n        emit Revoke(bch, end);\\n    }\\n\\n    /**\\n        @dev Create a vesting contract from an earlier commitment\\n        @param _bch The hash of the award's contents\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @param _slt The salt used to increase privacy when committing\\n        @return id  The id of the vesting contract\\n    */\\n    function claim(bytes32 _bch, address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr, bytes32 _slt) public lock returns (uint256 id) {\\n        require(_bch == keccak256(abi.encodePacked(_usr, _tot, _bgn, _tau, _eta, _mgr, _slt)), \\\"DssVest/invalid-hash\\\");\\n        require(commitments[_bch], \\\"DssVest/commitment-not-found\\\");\\n        uint48 revocationTime = toUint48(revocations[_bch]);\\n        if ( revocationTime < _bgn + _eta  ) {\\n            // commitment has been revoked before the cliff: vesting plan is cancelled\\n            require(revocationTime == 0, \\\"DssVest/commitment-revoked-before-cliff\\\");\\n        } else if ( revocationTime < _bgn + _tau ) {\\n            // commitment has been revoked after the cliff, but before the end: vesting plan values have to be updated\\n            // goal: behave as if the vesting plan was created when committed, and yanked when revoked\\n            _tot = mul(_tot, sub(revocationTime, _bgn)) / _tau; // newTot as amount accrued if yanked at revocationTime\\n            _tau = sub(revocationTime, _bgn); // new duration as time between bgn and revocationTime\\n        }\\n        // commitment can claimed now. If values needed to be updated, they have been updated above.\\n        commitments[_bch] = false;\\n        id = _create(_usr, _tot, _bgn, _tau, _eta, _mgr);\\n        emit Claim(_bch, id);\\n    }\\n\\n    /**\\n        @dev Governance adds a vesting contract\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @return id  The id of the vesting contract\\n    */\\n    function create(address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr) external lock auth returns (uint256 id) {\\n        return _create(_usr, _tot, _bgn, _tau, _eta, _mgr);\\n    }\\n\\n\\n    /**\\n        @dev Governance adds a vesting contract\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @return id  The id of the vesting contract\\n    */\\n    function _create(address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr) internal returns (uint256 id) {\\n        require(_usr != address(0),                        \\\"DssVest/invalid-user\\\");\\n        require(_tot > 0,                                  \\\"DssVest/no-vest-total-amount\\\");\\n        require(_bgn < add(block.timestamp, TWENTY_YEARS), \\\"DssVest/bgn-too-far\\\");\\n        require(_bgn > sub(block.timestamp, TWENTY_YEARS), \\\"DssVest/bgn-too-long-ago\\\");\\n        require(_tau > 0,                                  \\\"DssVest/tau-zero\\\");\\n        require(_tot / _tau <= cap,                        \\\"DssVest/rate-too-high\\\");\\n        require(_tau <= TWENTY_YEARS,                      \\\"DssVest/tau-too-long\\\");\\n        require(_eta <= _tau,                              \\\"DssVest/eta-too-long\\\");\\n        require(ids < type(uint256).max,                   \\\"DssVest/ids-overflow\\\");\\n\\n        id = ++ids;\\n        awards[id] = Award({\\n            usr: _usr,\\n            bgn: toUint48(_bgn),\\n            clf: toUint48(add(_bgn, _eta)),\\n            fin: toUint48(add(_bgn, _tau)),\\n            tot: toUint128(_tot),\\n            rxd: 0,\\n            mgr: _mgr,\\n            res: 1\\n        });\\n        emit Init(id, _usr);\\n    }\\n\\n    /**\\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim all available rewards\\n        @param _id     The id of the vesting contract\\n    */\\n    function vest(uint256 _id) external {\\n        _vest(_id, type(uint256).max);\\n    }\\n\\n    /**\\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim rewards\\n        @param _id     The id of the vesting contract\\n        @param _maxAmt The maximum amount to vest\\n    */\\n    function vest(uint256 _id, uint256 _maxAmt) external {\\n        _vest(_id, _maxAmt);\\n    }\\n\\n    /**\\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim rewards\\n        @param _id     The id of the vesting contract\\n        @param _maxAmt The maximum amount to vest\\n    */\\n    function _vest(uint256 _id, uint256 _maxAmt) internal lock {\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        require(_award.res == 0 || _award.usr == _msgSender(), \\\"DssVest/only-user-can-claim\\\");\\n        uint256 amt = unpaid(block.timestamp, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd);\\n        amt = min(amt, _maxAmt);\\n        awards[_id].rxd = toUint128(add(_award.rxd, amt));\\n        pay(_award.usr, amt);\\n        emit Vest(_id, amt);\\n    }\\n\\n    /**\\n        @dev claim and vest a commitment in one transaction\\n        @param _bch The hash of the commitment\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @param _slt The salt of the commitment\\n        @param _amt The amount to vest. Use type(uint256).max to vest all.\\n    */\\n    function claimAndVest(bytes32 _bch, address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr, bytes32 _slt, uint256 _amt) external returns (uint256 id) {\\n        id = claim(_bch, _usr, _tot, _bgn, _tau, _eta, _mgr, _slt);\\n        _vest(id, _amt);\\n    }\\n\\n    /**\\n        @dev amount of tokens accrued, not accounting for tokens paid\\n        @param _id  The id of the vesting contract\\n        @return amt The accrued amount\\n    */\\n    function accrued(uint256 _id) external view returns (uint256 amt) {\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        amt = accrued(block.timestamp, _award.bgn, _award.fin, _award.tot);\\n    }\\n\\n    /**\\n        @dev amount of tokens accrued, not accounting for tokens paid\\n        @param _time The timestamp to perform the calculation\\n        @param _bgn  The start time of the contract\\n        @param _fin  The end time of the contract\\n        @param _tot  The total amount of the contract\\n        @return amt  The accrued amount\\n    */\\n    function accrued(uint256 _time, uint48 _bgn, uint48 _fin, uint128 _tot) internal pure returns (uint256 amt) {\\n        if (_time < _bgn) {\\n            amt = 0;\\n        } else if (_time >= _fin) {\\n            amt = _tot;\\n        } else {\\n            amt = mul(_tot, sub(_time, _bgn)) / sub(_fin, _bgn); // 0 <= amt < _award.tot\\n        }\\n    }\\n\\n    /**\\n        @dev return the amount of vested, claimable GEM for a given ID\\n        @param _id  The id of the vesting contract\\n        @return amt The claimable amount\\n    */\\n    function unpaid(uint256 _id) external view returns (uint256 amt) {\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        amt = unpaid(block.timestamp, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd);\\n    }\\n\\n    /**\\n        @dev amount of tokens accrued, but not paid yet\\n        @param _time The timestamp to perform the calculation\\n        @param _bgn  The start time of the contract\\n        @param _clf  The timestamp of the cliff\\n        @param _fin  The end time of the contract\\n        @param _tot  The total amount of the contract\\n        @param _rxd  The number of gems received\\n        @return amt  The claimable amount\\n    */\\n    function unpaid(uint256 _time, uint48 _bgn, uint48 _clf, uint48 _fin, uint128 _tot, uint128 _rxd) internal pure returns (uint256 amt) {\\n        amt = _time < _clf ? 0 : sub(accrued(_time, _bgn, _fin, _tot), _rxd);\\n    }\\n\\n    /**\\n        @dev Allows governance or the owner to restrict vesting to the owner only\\n        @param _id The id of the vesting contract\\n    */\\n    function restrict(uint256 _id) external lock {\\n        address usr_ = awards[_id].usr;\\n        require(usr_ != address(0), \\\"DssVest/invalid-award\\\");\\n        require(wards[_msgSender()] == 1 || usr_ == _msgSender(), \\\"DssVest/not-authorized\\\");\\n        awards[_id].res = 1;\\n        emit Restrict(_id);\\n    }\\n\\n    /**\\n        @dev Allows governance or the owner to enable permissionless vesting\\n        @param _id The id of the vesting contract\\n    */\\n    function unrestrict(uint256 _id) external lock {\\n        address usr_ = awards[_id].usr;\\n        require(usr_ != address(0), \\\"DssVest/invalid-award\\\");\\n        require(wards[_msgSender()] == 1 || usr_ == _msgSender(), \\\"DssVest/not-authorized\\\");\\n        awards[_id].res = 0;\\n        emit Unrestrict(_id);\\n    }\\n\\n    /**\\n        @dev Allows governance or the manager to remove a vesting contract immediately\\n        @param _id The id of the vesting contract\\n    */\\n    function yank(uint256 _id) external {\\n        _yank(_id, block.timestamp);\\n    }\\n\\n    /**\\n        @dev Allows governance or the manager to remove a vesting contract at a future time\\n        @param _id  The id of the vesting contract\\n        @param _end A scheduled time to end the vest\\n    */\\n    function yank(uint256 _id, uint256 _end) external {\\n        _yank(_id, _end);\\n    }\\n\\n    /**\\n        @dev Allows governance or the manager to end pre-maturely a vesting contract\\n        @param _id  The id of the vesting contract\\n        @param _end A scheduled time to end the vest\\n    */\\n    function _yank(uint256 _id, uint256 _end) internal lock {\\n        require(wards[_msgSender()] == 1 || awards[_id].mgr == _msgSender(), \\\"DssVest/not-authorized\\\");\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        if (_end < block.timestamp) {\\n            _end = block.timestamp;\\n        }\\n        if (_end < _award.fin) {\\n            uint48 end = toUint48(_end);\\n            awards[_id].fin = end;\\n            if (end < _award.bgn) {\\n                awards[_id].bgn = end;\\n                awards[_id].clf = end;\\n                awards[_id].tot = 0;\\n            } else if (end < _award.clf) {\\n                awards[_id].clf = end;\\n                awards[_id].tot = 0;\\n            } else {\\n                awards[_id].tot = toUint128(\\n                                    add(\\n                                        unpaid(_end, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd),\\n                                        _award.rxd\\n                                    )\\n                                );\\n            }\\n        }\\n\\n        emit Yank(_id, _end);\\n    }\\n\\n    /**\\n        @dev Allows owner to move a contract to a different address\\n        @param _id  The id of the vesting contract\\n        @param _dst The address to send ownership of the contract to\\n    */\\n    function move(uint256 _id, address _dst) external lock {\\n        require(awards[_id].usr == _msgSender(), \\\"DssVest/only-user-can-move\\\");\\n        require(_dst != address(0), \\\"DssVest/zero-address-invalid\\\");\\n        awards[_id].usr = _dst;\\n        emit Move(_id, _dst);\\n    }\\n\\n    /**\\n        @dev Return true if a contract is valid\\n        @param _id The id of the vesting contract\\n        @return isValid True for valid contract\\n    */\\n    function valid(uint256 _id) external view returns (bool isValid) {\\n        isValid = awards[_id].rxd < awards[_id].tot;\\n    }\\n\\n    /**\\n        @dev Override this to implement payment logic.\\n        @param _guy The payment target.\\n        @param _amt The payment amount. [units are implementation-specific]\\n    */\\n    function pay(address _guy, uint256 _amt) virtual internal;\\n}\\n\\ncontract DssVestMintable is DssVest {\\n\\n    MintLike public gem;\\n\\n    /**\\n        @dev This contract must be authorized to 'mint' on the token\\n        @param _forwarder The address of the trusted forwarder for ERC2771\\n        @param _gem The contract address of the mintable token\\n        @param _cap The maximum amount of token bits that can be released in one plan each second\\n    */\\n    constructor(address _forwarder, address _gem, uint256 _cap) DssVest(_forwarder, _cap) {\\n        initialize(_gem, _msgSender(), _cap);   \\n    }\\n\\n    function initialize(address _gem, address _ward, uint256 _cap) initializer public {\\n        super.initialize(_ward, _cap);\\n        require(_gem != address(0), \\\"DssVestMintable/Invalid-token-address\\\");\\n        gem = MintLike(_gem);\\n    }\\n\\n    /**\\n        @dev Override pay to handle mint logic\\n        @param _guy The recipient of the minted token\\n        @param _amt The amount of token units to send to the _guy\\n    */\\n    function pay(address _guy, uint256 _amt) override internal {\\n        gem.mint(_guy, _amt);\\n    }\\n}\\n\\ncontract DssVestSuckable is DssVest {\\n\\n    uint256 internal constant RAY = 10**27;\\n\\n    ChainlogLike public chainlog;\\n    VatLike      public vat;\\n    DaiJoinLike  public daiJoin;\\n\\n    /**\\n        @dev This contract must be authorized to 'suck' on the vat\\n        @param _forwarder The address of the trusted forwarder for ERC2771\\n        @param _chainlog The contract address of the MCD chainlog\\n        @param _cap The maximum amount of token bits that can be released in one plan each second\\n    */\\n    constructor(address _forwarder, address _chainlog, uint256 _cap) DssVest(_forwarder, _cap) {\\n        initialize(_chainlog, _msgSender(), _cap);\\n    }\\n\\n    function initialize(address _chainlog, address _ward, uint256 _cap) initializer public {\\n        super.initialize(_ward, _cap);\\n        require(_chainlog != address(0), \\\"DssVestSuckable/Invalid-chainlog-address\\\");\\n        ChainlogLike chainlog_ = chainlog = ChainlogLike(_chainlog);\\n        VatLike vat_ = vat = VatLike(chainlog_.getAddress(\\\"MCD_VAT\\\"));\\n        DaiJoinLike daiJoin_ = daiJoin = DaiJoinLike(chainlog_.getAddress(\\\"MCD_JOIN_DAI\\\"));\\n\\n        vat_.hope(address(daiJoin_));\\n    }\\n\\n    /**\\n        @dev Override pay to handle suck logic\\n        @param _guy The recipient of the ERC-20 Dai\\n        @param _amt The amount of Dai to send to the _guy [WAD]\\n    */\\n    function pay(address _guy, uint256 _amt) override internal {\\n        require(vat.live() == 1, \\\"DssVestSuckable/vat-not-live\\\");\\n        vat.suck(chainlog.getAddress(\\\"MCD_VOW\\\"), address(this), mul(_amt, RAY));\\n        daiJoin.exit(_guy, _amt);\\n    }\\n}\\n\\n/*\\n    Transferrable token DssVest. Can be used to enable streaming payments of\\n     any arbitrary token from an address (i.e. CU multisig) to individual\\n     contributors.\\n*/\\ncontract DssVestTransferrable is DssVest {\\n\\n    address   public czar;\\n    TokenLike public gem;\\n\\n    /**\\n        @dev This contract must be approved for transfer of the gem on the czar\\n        @param _forwarder The address of the trusted forwarder for ERC2771\\n        @param _czar The owner of the tokens to be distributed\\n        @param _gem  The token to be distributed\\n        @param _cap The maximum amount of token bits that can be released in one plan each second\\n    */\\n    constructor(address _forwarder, address _czar, address _gem, uint256 _cap) DssVest(_forwarder, _cap) {\\n        initialize(_czar, _gem, _msgSender(), _cap);    \\n    }\\n\\n    function initialize(address _czar, address _gem, address _ward, uint256 _cap) initializer public {\\n        // call parent initializer\\n        super.initialize(_ward, _cap);\\n        require(_czar != address(0), \\\"DssVestTransferrable/Invalid-distributor-address\\\");\\n        require(_gem  != address(0), \\\"DssVestTransferrable/Invalid-token-address\\\");\\n        czar = _czar;\\n        gem = TokenLike(_gem);\\n    }\\n\\n    /**\\n        @dev Override pay to handle transfer logic\\n        @param _guy The recipient of the ERC-20 Dai\\n        @param _amt The amount of gem to send to the _guy (in native token units)\\n    */\\n    function pay(address _guy, uint256 _amt) override internal {\\n        // if this contract is its own czar, call transfer directly \\n        if (czar == address(this))\\n            require(gem.transfer(_guy, _amt), \\\"DssVestTransferrable/failed-transfer\\\"); \\n        else\\n            require(gem.transferFrom(czar, _guy, _amt), \\\"DssVestTransferrable/failed-transfer\\\");\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable _trustedForwarder;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@opengsn/=node_modules/@opengsn/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@tokenize.it/=node_modules/@tokenize.it/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"NewClone\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"gem\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"createMintableVestingClone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"predictCloneAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DssVestMintableCloneFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000de2b84fcae56a0bebc94b1daced90c3b9043161b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}