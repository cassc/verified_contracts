{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/interpreter/arkis/InsuranceFundEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    IDecreasePositionEvaluator,\\n    IExchangeEvaluator\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/adapters/index.sol\\\";\\nimport {IFund} from \\\"contracts/interfaces/liquidityManagement/insuranceFund/IFund.sol\\\";\\nimport {\\n    IFundFactory\\n} from \\\"contracts/interfaces/liquidityManagement/insuranceFund/IFundFactory.sol\\\";\\nimport {\\n    IPoolFactory\\n} from \\\"contracts/interfaces/liquidityManagement/liquidityPool/IPoolFactory.sol\\\";\\n\\nimport {Config} from \\\"contracts/accountAbstraction/interpreter/libraries/Config.sol\\\";\\nimport {Address} from \\\"contracts/libraries/Address.sol\\\";\\nimport {Asset} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\nimport {Command} from \\\"contracts/libraries/CommandLibrary.sol\\\";\\n\\nimport {Path} from \\\"../libraries/Path.sol\\\";\\n\\ncontract InsuranceFundEvaluator is IDecreasePositionEvaluator, IExchangeEvaluator {\\n    using Address for address;\\n    using Path for bytes;\\n\\n    error EthIsForbiddenUseWethInstead();\\n    error InterestAmountMustBeGreaterThanZero();\\n\\n    function evaluate(\\n        address,\\n        DecreasePositionRequest calldata _request\\n    ) external view override returns (Command[] memory) {\\n        Asset calldata total = _request.minOutput[0];\\n        uint256 amount = _request.liquidity;\\n        uint256 reward;\\n        /// @dev NOTE: unchecked is safe because of preceding check\\n        unchecked {\\n            // require(total.amount > amount)\\n            if (total.amount <= amount) {\\n                revert InterestAmountMustBeGreaterThanZero();\\n            }\\n            reward = total.amount - amount;\\n        }\\n\\n        Command memory cmd = Command({\\n            target: getFund(total.token),\\n            value: 0,\\n            payload: abi.encodeCall(IFund.forward, (amount, reward))\\n        });\\n\\n        return cmd.asArray();\\n    }\\n\\n    function evaluate(\\n        address,\\n        ExchangeRequest calldata _request\\n    ) external view override returns (Command[] memory cmds_) {\\n        address token = _request.path.extractTokenIn();\\n        if (token.isEth()) {\\n            revert EthIsForbiddenUseWethInstead();\\n        }\\n        uint256 amount = _request.amountIn;\\n\\n        Command memory cmd = Command({\\n            target: getFund(token),\\n            value: 0,\\n            payload: abi.encodeCall(IFund.supply, (amount))\\n        });\\n\\n        return cmd.populateWithApprove(token, amount);\\n    }\\n\\n    function getFund(address _token) private view returns (address) {\\n        IPoolFactory pf = IPoolFactory(Config.getLiquidityPoolAddress());\\n        IFundFactory ff = IFundFactory(Config.getInsuranceFundAddress());\\n        return ff.getFund(pf.getPool(_token));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/interpreter/libraries/Config.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Address} from \\\"contracts/libraries/Address.sol\\\";\\n\\nlibrary Config {\\n    using Address for bytes32;\\n\\n    struct Storage {\\n        address marginEngine;\\n        address liquidityPool;\\n        address insuranceFund;\\n    }\\n\\n    bytes32 private constant STORAGE_SLOT = keccak256(\\\"AssetmblySandbox's Config Slot V1\\\");\\n\\n    error MarginAccountAddressNotFound();\\n    error LiquidityPoolAddressNotFound();\\n    error InsuranceFundAddressNotFound();\\n\\n    function setModules(\\n        address _marginEngine,\\n        address _liquidityPool,\\n        address _insuranceFund\\n    ) internal returns (bool storageModified_) {\\n        if (_storage().marginEngine != _marginEngine) {\\n            _storage().marginEngine = _marginEngine;\\n            storageModified_ = true;\\n        }\\n        if (_storage().liquidityPool != _liquidityPool) {\\n            _storage().liquidityPool = _liquidityPool;\\n            storageModified_ = true;\\n        }\\n        if (_storage().insuranceFund != _insuranceFund) {\\n            _storage().insuranceFund = _insuranceFund;\\n            storageModified_ = true;\\n        }\\n    }\\n\\n    function getMarginEngineAddress() internal view returns (address result_) {\\n        if ((result_ = _storage().marginEngine) == address(0))\\n            revert MarginAccountAddressNotFound();\\n    }\\n\\n    function getLiquidityPoolAddress() internal view returns (address result_) {\\n        if ((result_ = _storage().liquidityPool) == address(0))\\n            revert LiquidityPoolAddressNotFound();\\n    }\\n\\n    function getInsuranceFundAddress() internal view returns (address result_) {\\n        if ((result_ = _storage().insuranceFund) == address(0))\\n            revert InsuranceFundAddressNotFound();\\n    }\\n\\n    function _storage() private pure returns (Storage storage s_) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            s_.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/interpreter/libraries/Path.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary Path {\\n    using Path for bytes;\\n\\n    uint256 internal constant ADDRESS_LEN = 20;\\n    uint256 internal constant POOL_ID_LEN = 4;\\n    uint256 internal constant NEXT_OFFSET = ADDRESS_LEN + POOL_ID_LEN;\\n\\n    error InvalidPathLength(uint256);\\n\\n    function extractTokenIn(bytes calldata _path) internal pure returns (address tokenIn_) {\\n        _path.ensureValid();\\n        tokenIn_ = _path.extractTokenInUnsafe();\\n    }\\n\\n    function extractTokenInUnsafe(bytes calldata _path) internal pure returns (address tokenIn_) {\\n        tokenIn_ = address(bytes20(_path[0:ADDRESS_LEN]));\\n    }\\n\\n    function extractTokenOut(bytes calldata _path) internal pure returns (address tokenOut_) {\\n        _path.ensureValid();\\n        tokenOut_ = _path.extractTokenOutUnsafe();\\n    }\\n\\n    function extractTokenOutUnsafe(bytes calldata _path) internal pure returns (address tokenOut_) {\\n        uint256 len = _path.length;\\n        tokenOut_ = address(bytes20(_path[len - ADDRESS_LEN:len]));\\n    }\\n\\n    /* solhint-disable var-name-mixedcase */\\n    function extractPool(\\n        bytes calldata _path,\\n        uint256 _poolNumber\\n    ) internal pure returns (address tokenIn__, address tokenOut_, uint32 poolId_____) {\\n        /* solhint-enable var-name-mixedcase */\\n        _path.ensureValid();\\n        uint256 ptr = _poolNumber * NEXT_OFFSET;\\n\\n        tokenIn__ = address(bytes20(_path[ptr:(ptr = ptr + ADDRESS_LEN)]));\\n        poolId_____ = uint32(bytes4(_path[ptr:(ptr = ptr + POOL_ID_LEN)]));\\n        tokenOut_ = address(bytes20(_path[ptr:(ptr = ptr + ADDRESS_LEN)]));\\n    }\\n\\n    function getNumberOfPools(bytes calldata _path) internal pure returns (uint256) {\\n        _path.ensureValid();\\n        return (_path.length - ADDRESS_LEN) / NEXT_OFFSET;\\n    }\\n\\n    function ensureValid(bytes calldata _path) internal pure {\\n        if (!isValid(_path)) revert InvalidPathLength(_path.length);\\n    }\\n\\n    function isValid(bytes calldata _path) private pure returns (bool) {\\n        if (_path.length < ADDRESS_LEN) return false;\\n        return (_path.length - ADDRESS_LEN) % NEXT_OFFSET == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/compliance/Asset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {AssetLibrary} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\n\\n/**\\n * @title Asset\\n * @dev Represents an asset with its token address and the amount.\\n * @param token The address of the asset's token.\\n * @param amount The amount of the asset.\\n */\\nstruct Asset {\\n    address token;\\n    uint256 amount;\\n}\\n\\nusing AssetLibrary for Asset global;\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @title Status\\n * @notice Enum representing status of a record (e.g., token, protocol, operator)\\n *  used for operation validation.\\n * @notice Validators must adhere to the following rules for different operations and contexts:\\n *  1) For exchanges: `operator`, `pool`, and `input token` *MAY* be either supported or suspended, but the `output token` *MUST* be supported.\\n *  2) For deposits: `operator`, `pool`, and every `token` in the `pool` *MUST* be supported.\\n *  3) For withdrawals: `operator`, `pool`, and each `token` *MAY* be either supported or suspended.\\n *\\n * @dev **Note** that deposit denotes **all** ways of aquiring liquidity such\\n * as token deposit, LP tokens stake, NFT mint etc.\\n */\\nenum Status {\\n    Undefined,\\n    Supported,\\n    Suspended\\n}\\n\\n/**\\n * @title WhitelistingAddressRecord\\n * @notice A struct to store an address and its support status.\\n * @dev This struct stores an address and its support status.\\n * @dev `source`: The address to be stored.\\n * @dev `supported`: Indicates whether the address is supported or not.\\n */\\nstruct WhitelistingAddressRecord {\\n    address source;\\n    bool supported;\\n}\\n\\n/**\\n * @title TokenPermission\\n * @notice This enum represents different levels of permission for a token, including trading, collateral, leverage, and full access.\\n * @dev `None`: Represents no permissions granted for the token.\\n * @dev `TradeOnly`: Represents the lowest permission level where you can only trade the token.\\n * @dev `Collateral`: Allows you to use the token as collateral.\\n * @dev `Leverage`: Allows you to leverage the token.\\n * @dev `FullAccess`: Represents the highest permission level where you have full access to trade, use as collateral, and leverage the token.\\n */\\nenum TokenPermission {\\n    None,\\n    TradeOnly,\\n    Collateral,\\n    Leverage,\\n    FullAccess\\n}\\n\\n/**\\n * @title WhitelistingTokenRecord\\n * @notice This struct stores an address and its support status for whitelisting, collateral and leverage.\\n * @dev `source`: The address of the token.\\n * @dev `supported`: Whether the token can be received from a protocol trades.\\n * @dev `permission`: Level of [`TokenPermission`](./enum.TokenPermission.html).\\n */\\nstruct WhitelistingTokenRecord {\\n    address source;\\n    bool supported;\\n    TokenPermission permission;\\n}\\n\\n/**\\n * @notice An error indicating that a token is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported token is used.\\n * @dev `token`: The address of the unsupported token.\\n */\\nerror TokenIsNotSupported(address token);\\n\\n/**\\n * @notice An error indicating that a token is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended token is used.\\n * @dev `token`: The address of the suspended token.\\n */\\nerror TokenIsSuspended(address token);\\n\\n/**\\n * @notice An error indicating that the token's permission level is insufficient for the requested action.\\n * @dev This can be thrown at [`IWhitelistingController.enforceTokenHasPermission()`](./interface.IWhitelistingController.html#enforcetokenhaspermission)\\n * @param token The address of the token that has insufficient permissions.\\n * @param required The required permission level for the action.\\n * @param actual The actual permission level of the token.\\n */\\nerror TokenLevelInsufficient(address token, TokenPermission required, TokenPermission actual);\\n\\n/**\\n * @notice An error indicating that an operator is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported operator is used.\\n * @dev `operator`: The address of the unsupported operator.\\n */\\nerror OperatorIsNotSupported(address operator);\\n\\n/**\\n * @notice An error indicating that an operator is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended operator is used.\\n * @dev `operator`: The address of the suspended operator.\\n */\\nerror OperatorIsSuspended(address operator);\\n\\n/**\\n * @notice An error indicating that a protocol is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported protocol is used.\\n * @dev `protocol`: The identification string of the unsupported protocol.\\n */\\nerror ProtocolIsNotSupported(string protocol);\\n\\n/**\\n * @notice An error indicating that a protocol is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended protocol is used.\\n * @dev `protocol`: The identification string of the unsupported protocol.\\n */\\nerror ProtocolIsSuspended(string protocol);\\n\\n/**\\n * @title IWhitelistingController\\n * @notice Interface for managing whitelisting of tokens, protocols, and operators.\\n */\\ninterface IWhitelistingController {\\n    /**\\n     * @dev Emitted when the support status of a protocol changes.\\n     * @dev `protocol`: The identification string of the protocol.\\n     * @dev `supported`: Whether the protocol is supported or not.\\n     */\\n    event ProtocolSupportChanged(string indexed protocol, bool supported);\\n\\n    /**\\n     * @dev Emitted when the support status of a token changes.\\n     * @dev `token`: The address of the token.\\n     * @dev `supported`: Whether the token is supported or not.\\n     * @dev `permission`: Level of [`TokenPermission`](./enum.TokenPermission.html).\\n     */\\n    event TokenSupportChanged(address indexed token, bool supported, TokenPermission permission);\\n\\n    /**\\n     * @dev Emitted when the support status of an operator changes for a specific protocol.\\n     * @dev `protocol`: The identification string of the protocol.\\n     * @dev `operator`: The address of the operator.\\n     * @dev `supported`: Whether the operator is supported or not.\\n     */\\n    event OperatorSupportChanged(string indexed protocol, address indexed operator, bool supported);\\n\\n    /**\\n     * @notice Update the support status of multiple tokens.\\n     * @dev Emits a [`TokenSupportChanged()`](#tokensupportchanged) event for each token whose status changed.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if no token status changed.\\n     * @param _tokens An array of [`WhitelistingTokenRecord`](./struct.WhitelistingTokenRecord.html)\\n     * structs containing token addresses, support statuses and permissions.\\n     */\\n    function updateTokensSupport(WhitelistingTokenRecord[] calldata _tokens) external;\\n\\n    /**\\n     * @notice Update the support status of a protocol.\\n     * @dev Emits a [`ProtocolSupportChanged()`](#protocolsupportchanged) event.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if protocol status is up to date.\\n     * @param _protocol The identification string of the protocol.\\n     * @param _adapterEvaluator The address of the adapter evaluator for the protocol.\\n     * @param _supported Whether the protocol is supported or not.\\n     */\\n    function updateProtocolSupport(\\n        string calldata _protocol,\\n        address _adapterEvaluator,\\n        bool _supported\\n    ) external;\\n\\n    /**\\n     * @notice Update the support status of multiple operators for a specific protocol.\\n     * @dev Emits a [`OperatorSupportChanged()`](#operatorsupportchanged) event for each token whose status changed.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if no operator status changed.\\n     * @param _protocol The identification string of the protocol.\\n     * @param _operators An array of `WhitelistingAddressRecord` structs containing operator addresses and support statuses.\\n     */\\n    function updateOperatorsSupport(\\n        string calldata _protocol,\\n        WhitelistingAddressRecord[] calldata _operators\\n    ) external;\\n\\n    /**\\n     * @notice Ensures that a token has the specified permission level.\\n     * @dev This check does not enforce exact match, but only that level is sufficient.\\n     *  So if `permission` is TokenPermission.TradeOnly and the token has TokenPermission.Collateral\\n     *  then it assumes that level is sufficient since Collateral level includes both\\n     *  TradeOnly and Collateral levels.\\n     * @param token The address of the token to check for permission.\\n     * @param permission The required [`TokenPermission`](TokenPermission) to be enforced.\\n     */\\n    function enforceTokenHasPermission(address token, TokenPermission permission) external view;\\n\\n    /**\\n     * @notice Returns the support status of a token as well as it's permissions.\\n     * @param _token The address of the token.\\n     * @return The [`Status`](./enum.Status.html)\\n     * of the token.\\n     * @return The [`TokenPermission`](./enum.TokenPermission.html)\\n     * of the token.\\n     */\\n    function getTokenSupport(address _token) external view returns (Status, TokenPermission);\\n\\n    /**\\n     * @notice Returns the support status of a protocol.\\n     * @param _protocol The identification string of the protocol.\\n     * @return The [`Status`](./enum.Status.html)\\n     *  of the protocol.\\n     */\\n    function getProtocolStatus(string calldata _protocol) external view returns (Status);\\n\\n    /**\\n     * @notice Returns the address of the adapter evaluator for a protocol.\\n     * @param _protocol The identification string of the protocol.\\n     * @return The address of the adapter evaluator for the protocol.\\n     */\\n    function getProtocolEvaluator(string calldata _protocol) external view returns (address);\\n\\n    /**\\n     * @notice Returns the support status of an operator for a specific protocol.\\n     * @param _operator The address of the operator.\\n     * @return operatorStatus_ The [`Status`](./enum.Status.html)\\n     *  of the operator.\\n     * @return protocolStatus_ The [`Status`](./enum.Status.html)\\n     *  of the protocol.\\n     */\\n    function getOperatorStatus(\\n        address _operator\\n    ) external view returns (Status operatorStatus_, Status protocolStatus_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/IDecreasePositionEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Asset} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\nimport {Command} from \\\"../Command.sol\\\";\\nimport {PositionDescriptor} from \\\"./PositionDescriptor.sol\\\";\\n\\ninterface IDecreasePositionEvaluator {\\n    /**\\n     * @notice Request structure for decreasing a position.\\n     * @dev `descriptor`: The [`PositionDescriptor`](/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol/struct.PositionDescriptor.html)\\n     *  struct.\\n     * @dev `liquidity`: Abstract amount that can be interpreted differently in different protocols (e.g., amount of LP tokens to burn).\\n     * @dev `minOutput`: [`Asset`](/interfaces/accountAbstraction/compliance/Asset.sol/struct.Asset.html) array with minimum amounts that must be retrieved from the position.\\n     */\\n    struct DecreasePositionRequest {\\n        PositionDescriptor descriptor;\\n        uint256 liquidity;\\n        Asset[] minOutput;\\n    }\\n\\n    /**\\n     * @notice Evaluate a decrease position request.\\n     * @param _operator Address which initiated the request\\n     * @param _request The [`DecreasePositionRequest`](#decreasepositionrequest) struct containing decrease position details.\\n     * @return cmds_ An array of [`Command`](../../Command.sol/struct.Command.html) to execute the request.\\n     */\\n    function evaluate(\\n        address _operator,\\n        DecreasePositionRequest calldata _request\\n    ) external returns (Command[] memory cmds_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/IExchangeEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Command} from \\\"../Command.sol\\\";\\n\\n/**\\n * @title IExchangeEvaluator\\n * @notice Interface for compiling commands for token exchanges for different protocols.\\n */\\ninterface IExchangeEvaluator {\\n    /**\\n     * @notice Structure for an exchange token request.\\n     * @dev `path`: Encoded path of tokens to follow in the exchange, including pool identifiers.\\n     * 20 bytes(tokenA) + 4 byte(poolId_A_B) + 20 bytes(tokenB) + ...\\n     * ... + 4 byte(poolId_N-1_N) + 20 bytes(tokenN).\\n     * @dev `extraData`: Additional data specific to a particular protocol, such as the response from a 1Inch Exchange API.\\n     * @dev `amountIn`: The amount of tokenA to spend.\\n     * @dev `minAmountOut`: The minimum amount of tokenN to receive.\\n     * @dev `recipient`: The recipient of tokenN.\\n     */\\n    struct ExchangeRequest {\\n        bytes path;\\n        bytes extraData;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        address recipient;\\n    }\\n\\n    /**\\n     * @notice Constructs an exchange token request.\\n     * @param _operator Address which initiated the request\\n     * @param _request The [`ExchangeRequest`](#exchangerequest) struct containing exchange token details.\\n     * @return cmds_ An array of [`Command`](../../Command.sol/struct.Command.html) to execute the request.\\n     */\\n    function evaluate(\\n        address _operator,\\n        ExchangeRequest calldata _request\\n    ) external view returns (Command[] memory cmds_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/IIncreasePositionEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Asset} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\nimport {Command} from \\\"../Command.sol\\\";\\nimport {PositionDescriptor} from \\\"./PositionDescriptor.sol\\\";\\n\\ninterface IIncreasePositionEvaluator {\\n    /**\\n     * @notice Structure for an increase position request.\\n     * @dev `descriptor`: The [`PositionDescriptor`](/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol/struct.PositionDescriptor.html)\\n     *  struct.\\n     * @dev `input`: An array of [`Asset`](/interfaces/accountAbstraction/compliance/Asset.sol/struct.Asset.html) representing the token-amounts that will be added to the position.\\n     * @dev `minLiquidityOut`: An abstract amount that can be interpreted differently in different protocols (e.g., minimum amount of LP tokens to receive).\\n     */\\n    struct IncreasePositionRequest {\\n        PositionDescriptor descriptor;\\n        Asset[] input;\\n        uint256 minLiquidityOut;\\n    }\\n\\n    /**\\n     * @notice Evaluate a increase position request.\\n     * @param _operator Address which initiated the request\\n     * @param _request The [`IncreasePositionRequest`](#increasepositionrequest) struct containing increase position details.\\n     * @return cmds_ An array of [`Command`](../../Command.sol/struct.Command.html) to execute the request.\\n     */\\n    function evaluate(\\n        address _operator,\\n        IncreasePositionRequest calldata _request\\n    ) external returns (Command[] memory cmds_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/ILiquidityPoolsRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/* solhint-disable no-unused-import */\\nimport {\\n    Status,\\n    TokenIsNotSupported\\n} from \\\"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\\\";\\nimport {AlreadyUpToDate} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\n/* solhint-enable no-unused-import */\\n\\n/**\\n * @notice Error indicating that the pool ID was not found.\\n * @param encodedPool The encoded pool data that was searched for.\\n */\\nerror PoolIdNotFound(bytes encodedPool);\\n\\n/**\\n * @notice Error indicating that the pool does not exist.\\n * @param poolId The unique identifier of the pool that was searched for.\\n */\\nerror PoolIsNotSupported(uint256 poolId);\\n\\n/**\\n * @notice Error indicating that the pool is suspended.\\n * @param poolId The unique identifier of the pool that is suspended.\\n */\\nerror PoolIsSuspended(uint256 poolId);\\n\\n/**\\n * @title ILiquidityPoolsRepository\\n * @notice Interface for managing liquidity pools and their support status.\\n */\\ninterface ILiquidityPoolsRepository {\\n    /**\\n     * @notice Update the support status of a liquidity pool.\\n     * @param _encodedPool The encoded pool data.\\n     * @param _supported Whether the pool is supported or not.\\n     * @return poolId_ The unique identifier of the pool.\\n     * @dev Reverts with a [`PoolIdNotFound()`](/interfaces/accountAbstraction/interpreter/adapters/ILiquidityPoolsRepository.sol/error.PoolIdNotFound.html)\\n     *  error if the pool does not exist.\\n     */\\n    function updatePoolSupport(\\n        bytes calldata _encodedPool,\\n        bool _supported\\n    ) external returns (uint256 poolId_);\\n\\n    /**\\n     * @notice Get the status of a specific pool.\\n     * @param _poolId The unique identifier of the pool.\\n     * @return status The status of the pool.\\n     * @dev Reverts with a [`PoolIsNotSupported()`](/interfaces/accountAbstraction/interpreter/adapters/ILiquidityPoolsRepository.sol/error.PoolIsNotSupported.html)\\n     *  error if the pool does not exist.\\n     */\\n    function getPoolStatus(uint256 _poolId) external returns (Status status);\\n\\n    /**\\n     * @notice Get the unique identifier (pool ID) of a specific pool.\\n     * @param _encodedPool The encoded pool data.\\n     * @return poolId_ The unique identifier of the pool.\\n     * @dev Reverts with a [`PoolIsNotSupported()`](/interfaces/accountAbstraction/interpreter/adapters/ILiquidityPoolsRepository.sol/error.PoolIsNotSupported.html)\\n     *  error if the pool does not exist.\\n     */\\n    function getPoolId(bytes calldata _encodedPool) external view returns (uint256 poolId_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/index.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    IDecreasePositionEvaluator\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/adapters/IDecreasePositionEvaluator.sol\\\";\\nimport {\\n    IExchangeEvaluator\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/adapters/IExchangeEvaluator.sol\\\";\\nimport {\\n    IIncreasePositionEvaluator\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/adapters/IIncreasePositionEvaluator.sol\\\";\\nimport {\\n    AlreadyUpToDate,\\n    ILiquidityPoolsRepository,\\n    PoolIdNotFound,\\n    PoolIsNotSupported,\\n    PoolIsSuspended,\\n    Status,\\n    TokenIsNotSupported\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/adapters/ILiquidityPoolsRepository.sol\\\";\\nimport {\\n    PositionDescriptor\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol\\\";\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// TODO CRYPTO-145: Possibly move into appropriate interface?\\n/**\\n * @notice Used to determine the required position for an operation.\\n * @dev `poolId`: An identifier that is unique within a single protocol.\\n * @dev `extraData`: Additional data used to specify the position, for example\\n * this is used in OneInchV5Evaluator to pass swap tx generated via 1inch API.\\n */\\nstruct PositionDescriptor {\\n    uint256 poolId;\\n    bytes extraData;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/Command.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {CommandLibrary} from \\\"contracts/libraries/CommandLibrary.sol\\\";\\n\\n/**\\n * @title Command\\n * @notice Contains arguments for a low-level call.\\n * @dev This struct allows deferring the call's execution, suspending it by passing it to another function or contract.\\n * @dev `target` The address to be called.\\n * @dev `value` Value to send in the call.\\n * @dev `payload` Encoded call with function selector and arguments.\\n */\\nstruct Command {\\n    address target;\\n    uint256 value;\\n    bytes payload;\\n}\\n\\nusing CommandLibrary for Command global;\\n\"\r\n    },\r\n    \"contracts/interfaces/base/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @notice An error indicating that the amount for the specified token is zero.\\n * @param token The address of the token with a zero amount.\\n */\\nerror AmountMustNotBeZero(address token);\\n\\n/**\\n * @notice An error indicating that an address must not be zero.\\n */\\nerror AddressMustNotBeZero();\\n\\n/**\\n * @notice An error indicating that an array must not be empty.\\n */\\nerror ArrayMustNotBeEmpty();\\n\\n/**\\n * @notice An error indicating storage is already up to date and doesn't need further processing.\\n * @dev This error is thrown when attempting to update an entity(s) that is(are) already up to date.\\n */\\nerror AlreadyUpToDate();\\n\\n/**\\n * @notice An error indicating that an action is unauthorized for the specified account.\\n * @param account The address of the unauthorized account.\\n */\\nerror UnauthorizedAccount(address account);\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityManagement/insuranceFund/Debt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @title FundDebt\\n * @notice This type of debt is created following an uncovered liquidation due to rapid changes in the market.\\n * @notice Authorization for this debt can be granted by the account having `DEBT_AUTHORITY` role in Insurance Fund.\\n * Funds to cover such debts are accumulated from all liquidations with a surplus in tokens.\\n * @dev `amount` The debt amount allocated to the Pool.\\n * @dev `reward` The amount designated as a reward for Liquidity Providers in the Pool.\\n */\\nstruct FundDebt {\\n    uint128 amount;\\n    uint128 reward;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityManagement/insuranceFund/IFund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IPool} from \\\"contracts/interfaces/liquidityManagement/liquidityPool/IPool.sol\\\";\\nimport {FundDebt} from \\\"./Debt.sol\\\";\\n\\ninterface IFund {\\n    /**\\n     * @notice Emitted when tokens are supplied to the insurance fund.\\n     * @dev Emitted from [`supply()`](#supply).\\n     * @param amount The amount of tokens supplied.\\n     */\\n    event Supplied(uint256 indexed amount);\\n\\n    /**\\n     * @notice Emitted when tokens are forwarded to the liquidity pool.\\n     * @dev Emitted from [`forward()`](#forward).\\n     * @param amount The amount of tokens forwarded.\\n     */\\n    event Forwarded(uint256 indexed amount);\\n\\n    /**\\n     * @notice Emitted when a debt is successfully authorized and forwarded.\\n     * @dev Emitted from [`authorize()`](#authorize).\\n     * @param id The identifier of the authorized debt.\\n     */\\n    event DebtPaid(bytes32 indexed id);\\n\\n    /**\\n     * @notice Error indicating that a debt with the specified ID does not exist.\\n     * @dev Fired from [`authorize()`](#authorize).\\n     */\\n    error DebtDoesNotExists(bytes32 id);\\n\\n    /**\\n     * @notice Error indicating that the sum of the debt amount and rewards exceeds the contract's token balance.\\n     * @dev Fired from [`authorize()`](#authorize).\\n     */\\n    error DebtAmountExceedsBalance(bytes32 id);\\n\\n    /**\\n     * @notice Allows authorized addresses to supply tokens in Insurance Fund.\\n     * @dev Requires `msg.sender` to have the `keccak256('FORWARDER_ROLE')` role within the fund contract,\\n     *      otherwise, it throws an `\\\"AccessControl: account msg.sender is missing role keccak256('FORWARDER_ROLE')\\\"` error.\\n     * @dev Emits a [`Supplied()`](#supplied) event on successful supply.\\n     * @param amount of tokens to supply.\\n     */\\n    function supply(uint256 amount) external;\\n\\n    /**\\n     * @notice Allows authorized addresses to forward tokens in Liquidity Pool\\n     *      (see [`IPool.returnAndDistribute()`](/interfaces/liquidityManagement/liquidityPool/IPool.sol/interface.IPool.html#returnanddistribute)).\\n     * @dev Requires `msg.sender` to have the `keccak256('FORWARDER_ROLE')` role within the fund contract,\\n     *      otherwise, it throws an `\\\"AccessControl: account msg.sender is missing role keccak256('FORWARDER_ROLE')\\\"` error.\\n     * @dev Emits a [`Forwarded()`](#forwarded) event on success.\\n     * @param amount of token to return to liquidity pool.\\n     * @param rewards amount of rewards to add to liquidity pool.\\n     */\\n    function forward(uint256 amount, uint256 rewards) external;\\n\\n    /**\\n     * @notice Allows authorized addresses to approve a debt and potentially [`forward()`](#forward) it.\\n     * @dev Throws a [`DebtDoesNotExists()`](#debtdoesnotexists) error if the corresponding `amount` and `reward` are zero.\\n     * @dev Throws a [`DebtAmountExceedsBalance()`](#debtamountexceedsbalance) error if the sum of `amount` and `reward` exceeds the contract's token balance.\\n     * @dev Emits a [`DebtPaid()`](#debtpaid) event on success.\\n     * @param id Identifier of the debt to authorize.\\n     */\\n    function authorize(bytes32 id) external;\\n\\n    /**\\n     * @notice Returns the details of a debt.\\n     * @param id Identifier of the debt.\\n     * @return A [`FundDebt`](../Debt.sol/struct.FundDebt.html) struct containing information about the debt.\\n     */\\n    function getDebt(bytes32 id) external view returns (FundDebt memory);\\n\\n    /**\\n     * @notice Liquidity pool associated with this insurance fund.\\n     */\\n    function pool() external view returns (IPool);\\n\\n    /**\\n     * @notice ERC20 token associated with the pool associated with this fund.\\n     */\\n    function token() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityManagement/insuranceFund/IFundFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\ninterface IFundFactory {\\n    /**\\n     * @notice Deploys an insurance fund for the liquidity pool.\\n     * @dev It can only be called by the owner; otherwise, it will throw an [`UnauthorizedAccount()`](#unauthorizedaccount) error.\\n     * @dev Throws an [`AddressAlreadyRegistered()`](#anchor) error if a fund for the specified pool is already exists (see [`isFundExists()`](#isfundexists)).\\n     * @param pool address of the liquidity pool.\\n     * @param debtAdmin address of the debt admin.\\n     */\\n    function createFund(address pool, address debtAdmin) external returns (address);\\n\\n    /**\\n     * @notice Retrieves the insurance fund associated with a specific liquidity pool.\\n     * @dev Throws a [`AddressIsNotRegisteredUnderKey()`](#anchor) error if the fund doesn't exist.\\n     * @param liquidityPool The address of the liquidity pool.\\n     * @return fund The address of the insurance fund.\\n     */\\n    function getFund(address liquidityPool) external view returns (address fund);\\n\\n    /**\\n     * @notice Checks whether an insurance fund exists for the given liquidity pool.\\n     * @param liquidityPool The address of the liquidity pool.\\n     * @return True if an insurance fund exists, otherwise false.\\n     */\\n    function isFundExists(address liquidityPool) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityManagement/liquidityPool/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @title IPool\\n * @notice Interface for a liquidity pool.\\n */\\ninterface IPool {\\n    /**\\n     * @notice Emitted when tokens are borrowed from the pool.\\n     * @param amount The amount of tokens borrowed.\\n     * @dev Emitted from [`borrow()`](#borrow).\\n     */\\n    event Borrowed(uint256 amount);\\n\\n    /**\\n     * @notice Emitted when tokens are claimed.\\n     * @param recipient The address of the recipient.\\n     * @param amount The amount of rewards claimed.\\n     * @dev Emitted from [`claim()`](#claim).\\n     */\\n    event Claimed(address indexed recipient, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when tokens are deposited into a liquidity pool.\\n     * @param depositor The address of the depositor.\\n     * @param amount The amount of tokens deposited.\\n     * @dev Emitted from [`deposit()`](#deposit).\\n     */\\n    event Deposited(address indexed depositor, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when tokens are returned to the pool, repaying debts, and triggering an epoch switch.\\n     * @param distributed The amount of tokens distributed as rewards in the current epoch.\\n     * @param returned The amount of tokens used to repay debts.\\n     * @dev Emitted from [`returnAndDistribute()`](#returnanddistribute).\\n     */\\n    event Returned(uint256 returned, uint256 distributed);\\n\\n    /**\\n     * @notice Emitted when tokens are withdrawn from the pool.\\n     * @param amount The amount of tokens withdrawn.\\n     * @param recipient The address of the recipient.\\n     * @dev Emitted from [`withdraw()`](#withdraw).\\n     */\\n    event Withdrawn(address indexed recipient, uint256 amount);\\n\\n    /**\\n     * @notice Fired from [`borrow()`](#borrow).\\n     * @dev Error indicating that the borrower's requested amount exceeds the available balance in the pool.\\n     */\\n    error BorrowAmountExceedsBalance();\\n\\n    /**\\n     * @notice Error indicating that the Merkle tree verification failed.\\n     * @dev Fired from [`deposit()`](#deposit).\\n     */\\n    error MerkleTreeVerificationFailed();\\n\\n    /**\\n     * @notice Error indicating that the total deposit threshold has been exceeded by the user's deposit.\\n     * @dev Fired from [`deposit()`](#deposit).\\n     */\\n    error TotalDepositThresholdExceeded();\\n\\n    /**\\n     * @notice Error indicating that there are no pending rewards for the user.\\n     * @dev Fired from [`claim()`](#claim).\\n     */\\n    error NoPendingRewards();\\n\\n    /**\\n     * @notice Error indicating that the user is trying to withdraw an amount greater than their position's value.\\n     * @dev Fired from [`withdraw()`](#withdraw).\\n     */\\n    error WithdrawAmountExceedsBalance();\\n\\n    /**\\n     * @notice Allows whitelisted addresses to deposit tokens into the liquidity pool.\\n     * @dev If verification is not disabled (see [`IMerkleTreeWhitelist.setRoot()`](/interfaces/liquidityManagement/liquidityPool/IMerkleTreeWhitelist.sol/interface.IMerkleTreeWhitelist.html#setroot)),\\n     *      it requires a valid Merkle Proof for `msg.sender` to confirm deposit authorization.\\n     * @dev Throws a [`TotalDepositThresholdExceeded()`](#totaldepositthresholdexceeded) error if `amount` + `token.balanceOf(pool)` exceeds [`thresholdOnTotalDeposit()`](#thresholdontotaldeposit).\\n     * @dev Emits a [`Deposited()`](#deposited) event on successful deposit.\\n     * @param amount The amount of tokens to deposit.\\n     * @param permission Merkle Proof for `msg.sender`, confirming deposit authorization.\\n     */\\n    function deposit(uint128 amount, bytes32[] calldata permission) external;\\n\\n    /**\\n     * @notice Allows a user to withdraw tokens from the liquidity pool.\\n     * @dev If the pool has a sufficient token balance, tokens will be sent immediately to the specified `recipient`.\\n     *      Otherwise, the withdrawal amount will be added to the debt queue for processing during [`returnAndDistribute()`](#returnanddistribute).\\n     * @dev If `recipient` is `address(0)`, it will be changed to `msg.sender`.\\n     * @dev Throws a [`WithdrawAmountExceedsBalance()`](#withdrawamountexceedsbalance) error if the user has an insufficient balance.\\n     * @dev Emits a [`Withdrawn()`](#withdrawn) event on successful withdrawal.\\n     * @param amount The amount of tokens to withdraw.\\n     * @param recipient The address that will receive the withdrawn tokens. If `address(0)` is passed, it will be changed to `msg.sender`.\\n     */\\n    function withdraw(uint128 amount, address recipient) external;\\n\\n    /**\\n     * @notice Allows a user to claim rewards earned in the liquidity pool.\\n     * @dev If the pool has a sufficient token balance, rewards will be sent immediately to the `recipient`.\\n     *      Otherwise, the rewards will be added to the debt queue for processing during [`returnAndDistribute()`](#returnanddistribute).\\n     * @dev If `recipient` is `address(0)`, it will be changed to `msg.sender`.\\n     * @dev Throws a [`NoPendingRewards()`](#nopendingrewards) error if the user has no pending rewards (see [`getPendingRewards()`](#getpendingrewards)).\\n     * @dev Emits a [`Claimed()`](#claimed) event on successful claim.\\n     * @param recipient The address to receive the claimed rewards. If `address(0)` is passed, it will be changed to `msg.sender`.\\n     */\\n    function claim(address recipient) external;\\n\\n    /**\\n     * @notice Allows authorized addresses to borrow tokens from the pool.\\n     * @dev Requires `msg.sender` to have the `keccak256('BORROWER_ROLE')` role within the pool contract,\\n     *      otherwise, it throws an `\\\"AccessControl: account msg.sender is missing role keccak256('BORROWER_ROLE')\\\"` error.\\n     * @dev Throws a [`BorrowAmountExceedsBalance()`](#borrowamountexceedsbalance) error if the pool's token balance is less than the requested amount.\\n     * @dev Emits a [`Borrowed()`](#borrowed) event on successful borrow.\\n     * @param amount The amount of tokens to borrow.\\n     */\\n    function borrow(uint256 amount) external;\\n\\n    /**\\n     * @notice Allows authorized addresses to deposit tokens into the liquidity pool, pay off as many debts as possible,\\n     * distribute rewards for the current epoch, and start a new epoch.\\n     * @dev Requires `msg.sender` to have the `keccak256('REPAYER_ROLE')` role within the pool contract;\\n     *      otherwise, it throws an `\\\"AccessControl: account msg.sender is missing role keccak256('REPAYER_ROLE')\\\"` error.\\n     * @dev Emits a [`Returned()`](#returned) event upon successful return.\\n     * @param amount Amount of tokens used for debt payment.\\n     * @param rewards Amount of tokens to distribute as rewards for the current epoch.\\n     */\\n    function returnAndDistribute(uint256 amount, uint256 rewards) external;\\n\\n    /**\\n     * @notice Returns the token address associated with the pool.\\n     * @return Token address.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @notice Returns the current threshold on the total deposit value. The pool's token balance cannot exceed this threshold.\\n     * @return Current threshold value.\\n     */\\n    function thresholdOnTotalDeposit() external view returns (uint256);\\n\\n    /**\\n     * @notice Calculates the pending rewards that a user can claim.\\n     * @param user address for which to calculate rewards.\\n     * @return rewards amount of tokens that the user can claim right now.\\n     */\\n    function getPendingRewards(address user) external view returns (uint256 rewards);\\n\\n    /**\\n     * @notice Retrieves the amount of tokens owned by a user in the pool.\\n     * @param user address.\\n     * @return balance amount of tokens.\\n     */\\n    function getPositionInfo(address user) external view returns (uint256 balance);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityManagement/liquidityPool/IPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @title IPoolFactory\\n * @notice A factory contract for managing liquidity pools.\\n */\\ninterface IPoolFactory {\\n    /**\\n     * @notice Emitted from [`createPool()`](#createpool) when a pool is successfully created.\\n     * @dev `token` The address of the token associated with the pool.\\n     * @dev `pool` The address of the registered pool.\\n     */\\n    event PoolCreated(address indexed token, address indexed pool);\\n\\n    /**\\n     * @notice Deploys a liquidity pool for the token.\\n     * @dev This function creates a new pool contract for the specified token with a given threshold and registers it's address.\\n     * @dev It can only be called by the owner; otherwise, it will throw an [`UnauthorizedAccount()`](#unauthorizedaccount) error.\\n     * @dev Throws a [`AddressAlreadyRegistered()`](#anchor) error, if a pool for the specified token is already exists.\\n     * @dev Emits a [`PoolCreated()`](#poolcreated) event on success.\\n     * @param borrower The address allowed to borrow from Pool\\n     * @param token The token address.\\n     * @param threshold The limit on the total amount of tokens that can be deposited into this pool.\\n     * @return pool The address of the newly created pool.\\n     */\\n    function createPool(\\n        address borrower,\\n        address token,\\n        uint256 threshold\\n    ) external returns (address pool);\\n\\n    /**\\n     * @notice Sets the insurance fund for a specific liquidity pool.\\n     * @dev Allows setting once the address which will have repayer role in the pool.\\n     * If fund is already set, will revert with [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html) custom error.\\n     * @param pool The address of the pool.\\n     * @param fund The address to set as the fund for the pool.\\n     */\\n    function setFund(address pool, address fund) external;\\n\\n    /**\\n     * @notice Triggers the suspended state for a pool when deposits are disabled.\\n     * @dev This function can only be called by the owner; otherwise, it reverts with an [`UnauthorizedAccount()`](#unauthorizedaccount) error.\\n     * @dev Throws a [`\\\"Pausable: paused\\\"`](#arcor) error if the pool is already in suspended mode (see [`isSuspended()`](#issuspended)).\\n     * @dev Emits a [`Paused(address account)`](#anchor) event on succes.\\n     * @param pool The address of the pool.\\n     */\\n    function suspendPool(address pool) external;\\n\\n    /**\\n     * @notice Triggers the normal mode for a pool.\\n     * @dev This function can only be called by the owner; otherwise, it reverts with an [`UnauthorizedAccount()`](#unauthorizedaccount) error.\\n     * @dev Throws a [`\\\"Pausable: not paused\\\"`](#arcor) error if the pool is already not suspended mode (see [`isSuspended()`](#issuspended)).\\n     * @dev Emits a [`Unpaused(address account)`](#anchor) event on succes.\\n     * @param pool The address of the pool.\\n     */\\n    function unsuspendPool(address pool) external;\\n\\n    /**\\n     * @notice Retrieves the pool address for the given token.\\n     * @dev Throws a [`AddressIsNotRegisteredUnderKey()`](#anchor) error if the fund doesn't exist.\\n     * @param token The address of the token.\\n     * @return pool The address of the pool.\\n     */\\n    function getPool(address token) external view returns (address pool);\\n\\n    /**\\n     * @notice Checks whether a pool exists for the given token.\\n     * @param token The address of the token.\\n     * @return True if a pool exists, otherwise false.\\n     */\\n    function isPoolExist(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Checks whether a pool is in a suspended mode.\\n     * @param pool The address of the pool.\\n     * @return True if the pool is suspended, otherwise false.\\n     */\\n    function isSuspended(address pool) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary Address {\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    function set(bytes32 _slot, address _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    function get(bytes32 _slot) internal view returns (address result_) {\\n        assembly {\\n            result_ := sload(_slot)\\n        }\\n    }\\n\\n    function isEth(address _token) internal pure returns (bool) {\\n        return _token == ETH || _token == address(0);\\n    }\\n\\n    function sort(address _a, address _b) internal pure returns (address, address) {\\n        return _a < _b ? (_a, _b) : (_b, _a);\\n    }\\n\\n    function sort(address[4] memory _array) internal pure returns (address[4] memory _sorted) {\\n        // Sorting network for the array of length 4\\n        (_sorted[0], _sorted[1]) = sort(_array[0], _array[1]);\\n        (_sorted[2], _sorted[3]) = sort(_array[2], _array[3]);\\n\\n        (_sorted[0], _sorted[2]) = sort(_sorted[0], _sorted[2]);\\n        (_sorted[1], _sorted[3]) = sort(_sorted[1], _sorted[3]);\\n        (_sorted[1], _sorted[2]) = sort(_sorted[1], _sorted[2]);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AssetLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {SafeTransferLib} from \\\"solady/src/utils/SafeTransferLib.sol\\\";\\n\\nimport {Asset} from \\\"contracts/interfaces/accountAbstraction/compliance/Asset.sol\\\";\\nimport {AmountMustNotBeZero} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\n\\nimport {Address} from \\\"./Address.sol\\\";\\n\\nlibrary AssetLibrary {\\n    using SafeTransferLib for address;\\n    using Address for address;\\n\\n    error NotEnoughReceived(address token, uint256 expected, uint256 received);\\n\\n    function forward(Asset calldata _self, address _to) internal {\\n        if (_self.amount == 0) revert AmountMustNotBeZero(_self.token);\\n\\n        if (_self.token.isEth()) _to.safeTransferETH(_self.amount);\\n        else _self.token.safeTransferFrom(msg.sender, _to, _self.amount);\\n    }\\n\\n    function enforceReceived(Asset calldata _self) internal view {\\n        if (_self.amount == 0) revert AmountMustNotBeZero(_self.token);\\n\\n        uint256 balance = _self.token.isEth()\\n            ? address(this).balance\\n            : _self.token.balanceOf(address(this));\\n\\n        if (balance < _self.amount) revert NotEnoughReceived(_self.token, _self.amount, balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/CommandLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Command} from \\\"contracts/interfaces/accountAbstraction/interpreter/Command.sol\\\";\\nimport {SafeCall} from \\\"contracts/libraries/SafeCall.sol\\\";\\n\\n/**\\n * @notice Utility to convert often-used methods into a Command object\\n */\\nlibrary CommandPresets {\\n    function approve(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal pure returns (Command memory cmd_) {\\n        cmd_.target = _token;\\n        cmd_.payload = abi.encodeCall(IERC20.approve, (_to, _amount));\\n    }\\n\\n    function transfer(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal pure returns (Command memory cmd_) {\\n        cmd_.target = _token;\\n        cmd_.payload = abi.encodeCall(IERC20.transfer, (_to, _amount));\\n    }\\n}\\n\\nlibrary CommandExecutor {\\n    using SafeCall for Command[];\\n\\n    function execute(Command[] calldata _cmds) external {\\n        _cmds.safeCallAll();\\n    }\\n}\\n\\nlibrary CommandLibrary {\\n    using CommandLibrary for Command[];\\n\\n    function last(Command[] memory _self) internal pure returns (Command memory) {\\n        return _self[_self.length - 1];\\n    }\\n\\n    function asArray(Command memory _self) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](1);\\n        result_[0] = _self;\\n    }\\n\\n    function concat(\\n        Command memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](2);\\n        result_[0] = _self;\\n        result_[1] = _cmd;\\n    }\\n\\n    function concat(\\n        Command memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_cmds.length + 1);\\n        result_[0] = _self;\\n        for (uint256 i = 1; i < result_.length; i++) {\\n            result_[i] = _cmds[i - 1];\\n        }\\n    }\\n\\n    function append(\\n        Command[] memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_self.length + _cmds.length);\\n        uint256 i;\\n        for (; i < _self.length; i++) {\\n            result_[i] = _self[i];\\n        }\\n        for (; i < result_.length; i++) {\\n            result_[i] = _cmds[i - _self.length];\\n        }\\n    }\\n\\n    function push(\\n        Command[] memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_self.length + 1);\\n        for (uint256 i; i < _self.length; i++) {\\n            result_[i] = _self[i];\\n        }\\n        result_[_self.length] = _cmd;\\n    }\\n\\n    function unshift(\\n        Command[] memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](1 + _self.length);\\n        result_[0] = _cmd;\\n        for (uint256 i = 1; i < result_.length; i++) {\\n            result_[i] = _self[i - 1];\\n        }\\n    }\\n\\n    function unshift(\\n        Command[] memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_cmds.length + _self.length);\\n        uint256 i;\\n        for (; i < _cmds.length; i++) {\\n            result_[i] = _cmds[i];\\n        }\\n        for (; i < result_.length; i++) {\\n            result_[i] = _self[i - _cmds.length];\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amount != 0) {\\n            result_ = CommandPresets.approve(_token, _self.target, _amount).concat(_self);\\n        } else {\\n            result_ = _self.asArray();\\n        }\\n    }\\n\\n    function populateWithRevokeAndApprove(\\n        Command memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        return\\n            CommandPresets.approve(_token, _self.target, 0).concat(\\n                _self.populateWithApprove(_token, _amount)\\n            );\\n    }\\n\\n    function populateWithApprove(\\n        Command[] memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amount != 0) {\\n            result_ = _self.unshift(\\n                CommandPresets.approve(_token, _self[_self.length - 1].target, _amount)\\n            );\\n        } else {\\n            result_ = _self;\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[2] memory _tokens,\\n        uint256[2] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] != 0) {\\n                result_ = populateWithApprove(_self, _tokens[0], _amounts[0]);\\n            } else {\\n                result_ = populateWithApprove(_self, _tokens[1], _amounts[1]);\\n            }\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[3] memory _tokens,\\n        uint256[3] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0 && _amounts[2] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(CommandPresets.approve(_tokens[2], _self.target, _amounts[2]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[1], _tokens[2]],\\n                    [_amounts[1], _amounts[2]]\\n                );\\n            } else if (_amounts[1] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[2]],\\n                    [_amounts[0], _amounts[2]]\\n                );\\n            } else {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1]],\\n                    [_amounts[0], _amounts[1]]\\n                );\\n            }\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[4] memory _tokens,\\n        uint256[4] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0 && _amounts[2] != 0 && _amounts[3] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(CommandPresets.approve(_tokens[2], _self.target, _amounts[2]))\\n                .push(CommandPresets.approve(_tokens[3], _self.target, _amounts[3]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[1], _tokens[2], _tokens[3]],\\n                    [_amounts[1], _amounts[2], _amounts[3]]\\n                );\\n            } else if (_amounts[1] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[2], _tokens[3]],\\n                    [_amounts[0], _amounts[2], _amounts[3]]\\n                );\\n            } else if (_amounts[2] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1], _tokens[3]],\\n                    [_amounts[0], _amounts[1], _amounts[3]]\\n                );\\n            } else {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1], _tokens[2]],\\n                    [_amounts[0], _amounts[1], _amounts[2]]\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Command} from \\\"contracts/interfaces/accountAbstraction/interpreter/Command.sol\\\";\\n\\n/**\\n * @notice Safe methods performing a low-level calls that revert\\n * if the call was not successful\\n */\\nlibrary SafeCall {\\n    using Address for address;\\n\\n    function safeCallAll(Command[] memory _cmds) internal {\\n        for (uint256 i; i < _cmds.length; i++) {\\n            safeCall(_cmds[i]);\\n        }\\n    }\\n\\n    function safeCall(Command memory _cmd) internal returns (bytes memory result_) {\\n        result_ = safeCall(_cmd.target, _cmd.value, _cmd.payload);\\n    }\\n\\n    function safeCall(address _target, bytes memory _data) internal returns (bytes memory result_) {\\n        result_ = safeCall(_target, 0, _data);\\n    }\\n\\n    function safeCall(\\n        address _target,\\n        uint256 _value,\\n        bytes memory _data\\n    ) internal returns (bytes memory result_) {\\n        result_ = _target.functionCallWithValue(_data, _value);\\n    }\\n\\n    function safeDelegateCall(\\n        address _target,\\n        bytes memory _data\\n    ) internal returns (bytes memory result_) {\\n        result_ = _target.functionDelegateCall(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"EthIsForbiddenUseWethInstead\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsuranceFundAddressNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterestAmountMustBeGreaterThanZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"InvalidPathLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolAddressNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct PositionDescriptor\",\"name\":\"descriptor\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Asset[]\",\"name\":\"minOutput\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IDecreasePositionEvaluator.DecreasePositionRequest\",\"name\":\"_request\",\"type\":\"tuple\"}],\"name\":\"evaluate\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct IExchangeEvaluator.ExchangeRequest\",\"name\":\"_request\",\"type\":\"tuple\"}],\"name\":\"evaluate\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"cmds_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InsuranceFundEvaluator", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}