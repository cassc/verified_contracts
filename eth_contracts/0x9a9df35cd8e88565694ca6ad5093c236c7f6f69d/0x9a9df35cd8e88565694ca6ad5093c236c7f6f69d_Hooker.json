{"SourceCode": "# pragma version 0.3.10\r\n\"\"\"\r\n@title Hooker\r\n@license MIT\r\n@author Curve Finance\r\n@notice Support hooks\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface FeeCollector:\r\n    def target() -> ERC20: view\r\n    def owner() -> address: view\r\n    def emergency_owner() -> address: view\r\n    def epoch_time_frame(_epoch: Epoch, _ts: uint256=block.timestamp) -> (uint256, uint256): view\r\n\r\n\r\nenum Epoch:\r\n    SLEEP  # 1\r\n    COLLECT  # 2\r\n    EXCHANGE  # 4\r\n    FORWARD  # 8\r\n\r\n\r\nevent DutyAct:\r\n    pass\r\n\r\nevent Act:\r\n    receiver: indexed(address)\r\n    compensation: uint256\r\n\r\nevent HookShot:\r\n    hook_id: indexed(uint8)\r\n    compensation: uint256\r\n\r\n\r\nstruct CompensationCooldown:\r\n    duty_counter: uint64  # last compensation epoch\r\n    used: uint64\r\n    limit: uint64  # Maximum number of compensations between duty acts (week)\r\n\r\nstruct CompensationStrategy:\r\n    amount: uint256  # In case of Dutch auction max amount\r\n    cooldown: CompensationCooldown\r\n    start: uint256\r\n    end: uint256\r\n    dutch: bool\r\n\r\n\r\nstruct Hook:\r\n    to: address\r\n    foreplay: Bytes[1024]  # including method_id\r\n    compensation_strategy: CompensationStrategy\r\n    duty: bool  # Hooks mandatory to act after fee_collector transfer\r\n\r\n\r\n# Property: no future changes in FeeCollector\r\nstruct HookInput:\r\n    hook_id: uint8\r\n    value: uint256\r\n    data: Bytes[8192]\r\n\r\n\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nSUPPORTED_INTERFACES: constant(bytes4[2]) = [\r\n    # ERC165: method_id(\"supportsInterface(bytes4)\") == 0x01ffc9a7\r\n    0x01ffc9a7,\r\n    # Hooker:\r\n    #   method_id(\"duty_act((uint8,uint256,bytes)[],address)\") == 0x8c88eb86\r\n    #   method_id(\"buffer_amount()\") == 0x69e15fcb\r\n    0xe569b44d,\r\n]\r\n\r\nSTART_TIME: constant(uint256) = 1600300800  # ts of distribution start\r\nWEEK: constant(uint256) = 7 * 24 * 3600\r\nMAX_LEN: constant(uint256) = 64\r\nMAX_HOOKS_LEN: constant(uint256) = 32\r\nfee_collector: public(immutable(FeeCollector))\r\n\r\nhooks: public(DynArray[Hook, MAX_HOOKS_LEN])\r\nduties_checklist: uint256  # mask of hooks with `duty` flag\r\nbuffer_amount: public(uint256)\r\n\r\nduty_counter: public(uint64)\r\n\r\n\r\n@external\r\ndef __init__(_fee_collector: FeeCollector,\r\n             _initial_oth: DynArray[Hook, MAX_HOOKS_LEN], _initial_oth_inputs: DynArray[HookInput, MAX_HOOKS_LEN],\r\n             _initial_hooks: DynArray[Hook, MAX_HOOKS_LEN]):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _fee_collector Hooker is _hooked_ to fee_collector contract with no update possibility\r\n    @param _initial_oth One time hooks at initialization\r\n    @param _initial_oth_inputs One time hooks input at initialization\r\n    @param _initial_hooks Hooks to set at initialization\r\n    \"\"\"\r\n    fee_collector = _fee_collector\r\n\r\n    self._one_time_hooks(_initial_oth, _initial_oth_inputs)\r\n    self._set_hooks(_initial_hooks)\r\n\r\n\r\n@internal\r\ndef _shot(hook: Hook, hook_input: HookInput):\r\n    \"\"\"\r\n    @notice Hook run implementation\r\n    \"\"\"\r\n    raw_call(\r\n        hook.to,\r\n        concat(hook.foreplay, hook_input.data),\r\n        value=hook_input.value,\r\n    )\r\n\r\n\r\n@internal\r\n@view\r\ndef _compensate(hook: Hook, ts: uint256=block.timestamp, _num: uint64=1) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate compensation of calling hook at timestamp\r\n    @dev Does not update compensation strategy to keep view mutability\r\n    @param hook Hook to act\r\n    @param ts Timestamp to calculate at (current by default)\r\n    @param _num Number of executions, needed for view function to track (used/limit)\r\n    @return Amount to compensate according to strategy\r\n    \"\"\"\r\n    strategy: CompensationStrategy = hook.compensation_strategy\r\n    # duty hook or not compensating yet or\r\n    if strategy.amount == 0 or self.duty_counter < strategy.cooldown.duty_counter or\\\r\n        strategy.cooldown.used + _num > strategy.cooldown.limit:  # limit on number of compensations\r\n        return 0\r\n\r\n    ts = (ts - START_TIME) % WEEK\r\n    if ts < strategy.start:\r\n        ts += WEEK\r\n    end: uint256 = strategy.end\r\n    if end <= strategy.start:\r\n        end += WEEK\r\n    if end <= ts:  # out of bound\r\n        return 0\r\n\r\n    compensation: uint256 = strategy.amount\r\n    if strategy.dutch:\r\n        compensation = strategy.amount * (ts - strategy.start) / (end - strategy.start)\r\n    return compensation\r\n\r\n\r\n@view\r\n@external\r\ndef calc_compensation(_hook_inputs: DynArray[HookInput, MAX_HOOKS_LEN],\r\n                      _duty: bool=False, _ts: uint256=block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate compensation for acting hooks. Checks input according to execution rules.\r\n        Older timestamps might work incorrectly.\r\n    @param _hook_inputs HookInput of hooks to act, only ids are used\r\n    @param _duty Bool whether act is through fee_collector (False by default).\r\n        If True, assuming calling from fee_collector if possible\r\n    @param _ts Timestamp at which to calculate compensations (current by default)\r\n    @return Amount of target coin to receive as compensation\r\n    \"\"\"\r\n    current_duty_counter: uint64 = self.duty_counter\r\n    if _duty:\r\n        hook_mask: uint256 = 0\r\n        for solicitation in _hook_inputs:\r\n            hook_mask |= 1 << solicitation.hook_id\r\n        duties_checklist: uint256 = self.duties_checklist\r\n        assert hook_mask & duties_checklist == duties_checklist, \"Not all duties\"\r\n\r\n        time_frame: (uint256, uint256) = fee_collector.epoch_time_frame(Epoch.FORWARD, _ts)\r\n        if time_frame[0] <= _ts and _ts < time_frame[1]:\r\n            current_duty_counter = convert((_ts - START_TIME) / WEEK, uint64)\r\n\r\n    compensation: uint256 = 0\r\n    prev_idx: uint8 = 0\r\n    num: uint64 = 0\r\n    for solicitation in _hook_inputs:\r\n        if prev_idx > solicitation.hook_id:\r\n            raise \"Hooks not sorted\"\r\n        else:\r\n            num = num + 1 if prev_idx == solicitation.hook_id else 1\r\n\r\n        hook: Hook = self.hooks[solicitation.hook_id]\r\n        if hook.compensation_strategy.cooldown.duty_counter < current_duty_counter:\r\n            hook.compensation_strategy.cooldown.used = 0\r\n        compensation += self._compensate(hook, _ts, num)\r\n        prev_idx = solicitation.hook_id\r\n\r\n    return compensation\r\n\r\n\r\n@internal\r\ndef _act(_hook_inputs: DynArray[HookInput, MAX_HOOKS_LEN], _receiver: address) -> uint256:\r\n    current_duty_counter: uint64 = self.duty_counter\r\n\r\n    compensation: uint256 = 0\r\n    prev_idx: uint8 = 0\r\n    for solicitation in _hook_inputs:\r\n        hook: Hook = self.hooks[solicitation.hook_id]\r\n        self._shot(hook, solicitation)\r\n\r\n        if hook.compensation_strategy.cooldown.duty_counter < current_duty_counter:\r\n            hook.compensation_strategy.cooldown.used = 0\r\n            hook.compensation_strategy.cooldown.duty_counter = current_duty_counter\r\n        hook_compensation: uint256 = self._compensate(hook)\r\n\r\n        if hook_compensation > 0:\r\n            compensation += hook_compensation\r\n            hook.compensation_strategy.cooldown.used += 1\r\n            self.hooks[solicitation.hook_id].compensation_strategy.cooldown = hook.compensation_strategy.cooldown\r\n\r\n        if prev_idx > solicitation.hook_id:\r\n            raise \"Hooks not sorted\"\r\n        prev_idx = solicitation.hook_id\r\n        log HookShot(prev_idx, hook_compensation)\r\n\r\n    log Act(_receiver, compensation)\r\n\r\n    # happy ending\r\n    if compensation > 0:\r\n        coin: ERC20 = fee_collector.target()\r\n        coin.transferFrom(fee_collector.address, _receiver, compensation)\r\n    return compensation\r\n\r\n\r\n@external\r\n@payable\r\ndef duty_act(_hook_inputs: DynArray[HookInput, MAX_HOOKS_LEN], _receiver: address=msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Entry point to run hooks for FeeCollector\r\n    @param _hook_inputs Inputs assembled by keepers\r\n    @param _receiver Receiver of compensation (sender by default)\r\n    @return Compensation received\r\n    \"\"\"\r\n    if msg.sender == fee_collector.address:\r\n        self.duty_counter = convert((block.timestamp - START_TIME) / WEEK, uint64)  # assuming time frames are divided weekly\r\n\r\n    hook_mask: uint256 = 0\r\n    for solicitation in _hook_inputs:\r\n        hook_mask |= 1 << solicitation.hook_id\r\n    duties_checklist: uint256 = self.duties_checklist\r\n    assert hook_mask & duties_checklist == duties_checklist, \"Not all duties\"\r\n\r\n    log DutyAct()\r\n\r\n    return self._act(_hook_inputs, _receiver)\r\n\r\n\r\n@external\r\n@payable\r\ndef act(_hook_inputs: DynArray[HookInput, MAX_HOOKS_LEN], _receiver: address=msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Entry point to run hooks and receive compensation\r\n    @param _hook_inputs Inputs assembled by keepers\r\n    @param _receiver Receiver of compensation (sender by default)\r\n    @return Compensation received\r\n    \"\"\"\r\n    return self._act(_hook_inputs, _receiver)\r\n\r\n\r\n@internal\r\ndef _one_time_hooks(hooks: DynArray[Hook, MAX_HOOKS_LEN], inputs: DynArray[HookInput, MAX_HOOKS_LEN]):\r\n    for i in range(len(hooks), bound=MAX_HOOKS_LEN):\r\n        self._shot(hooks[i], inputs[i])\r\n\r\n\r\n@external\r\n@payable\r\ndef one_time_hooks(_hooks: DynArray[Hook, MAX_HOOKS_LEN], _inputs: DynArray[HookInput, MAX_HOOKS_LEN]):\r\n    \"\"\"\r\n    @notice Coin approvals, any settings that need to be executed once\r\n    @dev Callable only by owner\r\n    @param _hooks Hook input\r\n    @param _inputs May be used to include native coin\r\n    \"\"\"\r\n    assert msg.sender == fee_collector.owner(), \"Only owner\"\r\n\r\n    self._one_time_hooks(_hooks, _inputs)\r\n\r\n\r\n@internal\r\ndef _set_hooks(new_hooks: DynArray[Hook, MAX_HOOKS_LEN]):\r\n    self.hooks = new_hooks\r\n\r\n    buffer_amount: uint256 = 0\r\n    mask: uint256 = 0\r\n    for i in range(len(new_hooks), bound=MAX_HOOKS_LEN):\r\n        assert new_hooks[i].compensation_strategy.start < WEEK\r\n        assert new_hooks[i].compensation_strategy.end < WEEK\r\n\r\n        buffer_amount += new_hooks[i].compensation_strategy.amount *\\\r\n                            convert(new_hooks[i].compensation_strategy.cooldown.limit, uint256)\r\n        if new_hooks[i].duty:\r\n            mask |= 1 << i\r\n    self.buffer_amount = buffer_amount\r\n    self.duties_checklist = mask\r\n\r\n\r\n@external\r\ndef set_hooks(_new_hooks: DynArray[Hook, MAX_HOOKS_LEN]):\r\n    \"\"\"\r\n    @notice Set new hooks\r\n    @dev Callable only by owner\r\n    @param _new_hooks New list of hooks\r\n    \"\"\"\r\n    assert msg.sender == fee_collector.owner(), \"Only owner\"\r\n\r\n    self._set_hooks(_new_hooks)\r\n\r\n\r\n@pure\r\n@external\r\ndef supportsInterface(_interface_id: bytes4) -> bool:\r\n    \"\"\"\r\n    @dev Interface identification is specified in ERC-165.\r\n    @param _interface_id Id of the interface\r\n    @return True if contract supports given interface\r\n    \"\"\"\r\n    return _interface_id in SUPPORTED_INTERFACES\r\n\r\n\r\n@external\r\ndef recover(_coins: DynArray[ERC20, MAX_LEN]):\r\n    \"\"\"\r\n    @notice Recover ERC20 tokens or Ether from this contract\r\n    @dev Callable only by owner and emergency owner\r\n    @param _coins Token addresses\r\n    \"\"\"\r\n    assert msg.sender in [fee_collector.owner(), fee_collector.emergency_owner()], \"Only owner\"\r\n\r\n    for coin in _coins:\r\n        if coin.address == ETH_ADDRESS:\r\n            raw_call(fee_collector.address, b\"\", value=self.balance)\r\n        else:\r\n            coin.transfer(fee_collector.address, coin.balanceOf(self))  # do not need safe transfer", "ABI": "[{\"name\":\"DutyAct\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Act\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"compensation\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"HookShot\",\"inputs\":[{\"name\":\"hook_id\",\"type\":\"uint8\",\"indexed\":true},{\"name\":\"compensation\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_fee_collector\",\"type\":\"address\"},{\"name\":\"_initial_oth\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"foreplay\",\"type\":\"bytes\"},{\"name\":\"compensation_strategy\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"tuple\",\"components\":[{\"name\":\"duty_counter\",\"type\":\"uint64\"},{\"name\":\"used\",\"type\":\"uint64\"},{\"name\":\"limit\",\"type\":\"uint64\"}]},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"dutch\",\"type\":\"bool\"}]},{\"name\":\"duty\",\"type\":\"bool\"}]},{\"name\":\"_initial_oth_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]},{\"name\":\"_initial_hooks\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"foreplay\",\"type\":\"bytes\"},{\"name\":\"compensation_strategy\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"tuple\",\"components\":[{\"name\":\"duty_counter\",\"type\":\"uint64\"},{\"name\":\"used\",\"type\":\"uint64\"},{\"name\":\"limit\",\"type\":\"uint64\"}]},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"dutch\",\"type\":\"bool\"}]},{\"name\":\"duty\",\"type\":\"bool\"}]}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_compensation\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_compensation\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]},{\"name\":\"_duty\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_compensation\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]},{\"name\":\"_duty\",\"type\":\"bool\"},{\"name\":\"_ts\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"duty_act\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"duty_act\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"act\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"act\",\"inputs\":[{\"name\":\"_hook_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"one_time_hooks\",\"inputs\":[{\"name\":\"_hooks\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"foreplay\",\"type\":\"bytes\"},{\"name\":\"compensation_strategy\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"tuple\",\"components\":[{\"name\":\"duty_counter\",\"type\":\"uint64\"},{\"name\":\"used\",\"type\":\"uint64\"},{\"name\":\"limit\",\"type\":\"uint64\"}]},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"dutch\",\"type\":\"bool\"}]},{\"name\":\"duty\",\"type\":\"bool\"}]},{\"name\":\"_inputs\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"hook_id\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_hooks\",\"inputs\":[{\"name\":\"_new_hooks\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"foreplay\",\"type\":\"bytes\"},{\"name\":\"compensation_strategy\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"tuple\",\"components\":[{\"name\":\"duty_counter\",\"type\":\"uint64\"},{\"name\":\"used\",\"type\":\"uint64\"},{\"name\":\"limit\",\"type\":\"uint64\"}]},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"dutch\",\"type\":\"bool\"}]},{\"name\":\"duty\",\"type\":\"bool\"}]}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"_interface_id\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover\",\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_collector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"hooks\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"foreplay\",\"type\":\"bytes\"},{\"name\":\"compensation_strategy\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"tuple\",\"components\":[{\"name\":\"duty_counter\",\"type\":\"uint64\"},{\"name\":\"used\",\"type\":\"uint64\"},{\"name\":\"limit\",\"type\":\"uint64\"}]},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"dutch\",\"type\":\"bool\"}]},{\"name\":\"duty\",\"type\":\"bool\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"buffer_amount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"duty_counter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}]}]", "ContractName": "Hooker", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000a2bcd1a4efbd04b63cd03f5aff2561106ebcce0000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000f939e0a03fb07f59a73314e73794be0e57ac1b4e0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b3000000000000000000000000d16d5ec345dd86fb63c6a9c43c517210f1027914ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000d16d5ec345dd86fb63c6a9c43c517210f1027914000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002489afcb44000000000000000000000000f939e0a03fb07f59a73314e73794be0e57ac1b4e00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}