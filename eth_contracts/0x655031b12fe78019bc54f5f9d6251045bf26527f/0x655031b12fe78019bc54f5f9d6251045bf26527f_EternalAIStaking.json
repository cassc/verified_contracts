{"SourceCode": "/**\r\n * \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588\r\n * \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588     \u2588\u2588  \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588\r\n * \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588\r\n * \u2588\u2588   \u2588\u2588 \u2588\u2588       \u2588\u2588  \u2588\u2588  \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588  \u2588\u2588     \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\r\n * \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588\r\n * \r\n * @title EternalAI\r\n * \r\n * @notice This is a smart contract developed by Revoluzion for EternalAI.\r\n * \r\n * @dev This smart contract was developed based on the general\r\n * OpenZeppelin Contracts guidelines where functions revert instead of\r\n * returning `false` on failure. \r\n * \r\n * @author Revoluzion Ecosystem\r\n * @custom:email support@revoluzion.io\r\n * @custom:website https://revoluzion.io\r\n * @custom:dapp https://revoluzion.app\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\n/********************************************************************************************\r\n  LIBRARY\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title Address Library\r\n *\r\n * @notice Collection of functions providing utility for interacting with addresses.\r\n */\r\nlibrary Address {\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating insufficient balance while performing an operation.\r\n     *\r\n     * @param account Address where the balance is insufficient.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @notice Error indicating an attempt to interact with a contract having empty code.\r\n     *\r\n     * @param target Address of the contract with empty code.\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @notice Error indicating a failed internal call.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Calls a function on a specified address without transferring value.\r\n     *\r\n     * @param target Address on which the function will be called.\r\n     * @param data Encoded data of the function call.\r\n     *\r\n     * @return returndata Result of the function call.\r\n     *\r\n     * @dev The `target` must be a contract address and this function must be calling\r\n     * `target` with `data` not reverting.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Calls a function on a specified address with a specified value.\r\n     *\r\n     * @param target Address on which the function will be called.\r\n     * @param data Encoded data of the function call.\r\n     * @param value Value to be sent in the call.\r\n     *\r\n     * @return returndata Result of the function call.\r\n     *\r\n     * @dev This function ensure that the calling contract actually have Ether balance\r\n     * of at least `value` and that the called Solidity function is a `payable`. Should\r\n     * throw if caller does have insufficient balance.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @notice Verifies the result of a function call and handles errors if any.\r\n     *\r\n     * @param target Address on which the function was called.\r\n     * @param success Boolean indicating the success of the function call.\r\n     * @param returndata Result data of the function call.\r\n     *\r\n     * @return Result of the function call or reverts with an appropriate error.\r\n     *\r\n     * @dev This help to verify that a low level call to smart-contract was successful\r\n     * and will reverts if the target was not a contract. For unsuccessful call, this\r\n     * will bubble up the revert reason (falling back to {FailedInnerCall}). Should\r\n     * throw if both the returndata and target.code length are 0 when `success` is true.\r\n     */\r\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts with decoded revert data or FailedInnerCall if no revert\r\n     * data is available.\r\n     *\r\n     * @param returndata Result data of a failed function call.\r\n     *\r\n     * @dev Should throw if returndata length is 0.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20 Library\r\n *\r\n * @notice Collection of functions providing utility for safe operations with\r\n * ERC20 tokens.\r\n *\r\n * @dev This is mainly for the usage of token that throw on failure (when the\r\n * token contract returns false). Tokens that return no value (and instead revert\r\n * or throw on failure) are also supported where non-reverting calls are assumed\r\n * to be a successful transaction.\r\n */\r\nlibrary SafeERC20 {\r\n    \r\n    // LIBRARY\r\n\r\n    using Address for address;\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating a failed operation during an ERC-20 token transfer.\r\n     *\r\n     * @param token Address of the token contract.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Safely transfers tokens.\r\n     *\r\n     * @param token ERC20 token interface.\r\n     * @param to Address to which the tokens will be transferred.\r\n     * @param value Amount of tokens to be transferred.\r\n     *\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to` where\r\n     * non-reverting calls are assumed to be successful if `token` returns no value.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @notice Calls a function on a token contract and reverts if the operation fails.\r\n     *\r\n     * @param token ERC20 token interface.\r\n     * @param data Encoded data of the function call.\r\n     *\r\n     * @dev This imitates a Solidity high-level call such as a regular function call to\r\n     * a contract while relaxing the requirement on the return value.\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  INTERFACE\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title ERC20 Token Standard Interface\r\n * \r\n * @notice Interface of the ERC-20 standard token as defined in the ERC.\r\n * \r\n * @dev See https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    \r\n    // EVENT\r\n    \r\n    /**\r\n     * @notice Emitted when `value` tokens are transferred from\r\n     * one account (`from`) to another (`to`).\r\n     * \r\n     * @param from The address tokens are transferred from.\r\n     * @param to The address tokens are transferred to.\r\n     * @param value The amount of tokens transferred.\r\n     * \r\n     * @dev The `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @notice Emitted when the allowance of a `spender` for an `owner`\r\n     * is set by a call to {approve}.\r\n     * \r\n     * @param owner The address allowing `spender` to spend on their behalf.\r\n     * @param spender The address allowed to spend tokens on behalf of `owner`.\r\n     * @param value The allowance amount set for `spender`.\r\n     * \r\n     * @dev The `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Returns the value of tokens in existence.\r\n     * \r\n     * @return The value of the total supply of tokens.\r\n     * \r\n     * @dev This should get the total token supply.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the value of tokens owned by `account`.\r\n     * \r\n     * @param account The address to query the balance for.\r\n     * \r\n     * @return The token balance of `account`.\r\n     * \r\n     * @dev This should get the token balance of a specific account.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Moves a `value` amount of tokens from the caller's account to `to`.\r\n     * \r\n     * @param to The address to transfer tokens to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * \r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     * \r\n     * @dev This should transfer tokens to a specified address and emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}.\r\n     * \r\n     * @param owner The address allowing `spender` to spend on their behalf.\r\n     * @param spender The address allowed to spend tokens on behalf of `owner`.\r\n     * \r\n     * @return The allowance amount for `spender`.\r\n     * \r\n     * @dev The return value should be zero by default and\r\n     * changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     * \r\n     * @param spender The address allowed to spend tokens on behalf of the sender.\r\n     * @param value The allowance amount for `spender`.\r\n     * \r\n     * @return A boolean indicating whether the approval was successful or not.\r\n     * \r\n     * @dev This should approve `spender` to spend a specified amount of tokens\r\n     * on behalf of the sender and emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's allowance.\r\n     * \r\n     * @param from The address to transfer tokens from.\r\n     * @param to The address to transfer tokens to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * \r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     * \r\n     * @dev This should transfer tokens from one address to another after\r\n     * spending caller's allowance and emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC20 Token Metadata Interface\r\n * \r\n * @notice Interface for the optional metadata functions of the ERC-20 standard as defined in the ERC.\r\n * \r\n * @dev It extends the IERC20 interface. See https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n\r\n    // FUNCTION\r\n    \r\n    /**\r\n     * @notice Returns the name of the token.\r\n     * \r\n     * @return The name of the token as a string.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the symbol of the token.\r\n     * \r\n     * @return The symbol of the token as a string.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the number of decimals used to display the token.\r\n     * \r\n     * @return The number of decimals as a uint8.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @title ERC20 Token Standard Error Interface\r\n * \r\n * @notice Interface of the ERC-6093 custom errors that defined common errors\r\n * related to the ERC-20 standard token functionalities.\r\n * \r\n * @dev See https://eips.ethereum.org/EIPS/eip-6093\r\n */\r\ninterface IERC20Errors {\r\n    \r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the `sender` has inssufficient `balance` for the operation.\r\n     * \r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     *\r\n     * @dev The `needed` value is required to inform user on the needed amount.\r\n     */\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n\r\n    /**\r\n     * @notice Error indicating that the `sender` is invalid for the operation.\r\n     * \r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC20InvalidSender(address sender);\r\n    \r\n    /**\r\n     * @notice Error indicating that the `receiver` is invalid for the operation.\r\n     * \r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC20InvalidReceiver(address receiver);\r\n    \r\n    /**\r\n     * @notice Error indicating that the `spender` does not have enough `allowance` for the operation.\r\n     * \r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     * \r\n     * @dev The `needed` value is required to inform user on the needed amount.\r\n     */\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n    \r\n    /**\r\n     * @notice Error indicating that the `approver` is invalid for the approval operation.\r\n     * \r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC20InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @notice Error indicating that the `spender` is invalid for the allowance operation.\r\n     * \r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @title Common Error Interface\r\n * \r\n * @notice Interface of the common errors not specific to ERC-20 functionalities.\r\n */\r\ninterface ICommonErrors {\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the `current` address cannot be used in this context.\r\n     * \r\n     * @param current Address used in the context.\r\n     */\r\n    error CannotUseCurrentAddress(address current);\r\n\r\n    /**\r\n     * @notice Error indicating that the `current` state cannot be used in this context.\r\n     * \r\n     * @param current Boolean state used in the context.\r\n     */\r\n    error CannotUseCurrentState(bool current);\r\n\r\n    /**\r\n     * @notice Error indicating that the `current` value cannot be used in this context.\r\n     * \r\n     * @param current Value used in the context.\r\n     */\r\n    error CannotUseCurrentValue(uint256 current);\r\n\r\n    /**\r\n     * @notice Error indicating that the `invalid` address provided is not a valid address for this context.\r\n     * \r\n     * @param invalid Address used in the context.\r\n     */\r\n    error InvalidAddress(address invalid);\r\n\r\n    /**\r\n     * @notice Error indicating that the `invalid` value provided is not a valid value for this context.\r\n     * \r\n     * @param invalid Value used in the context.\r\n     */\r\n    error InvalidValue(uint256 invalid);\r\n}\r\n\r\n/********************************************************************************************\r\n  ACCESS\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title Ownable Contract\r\n * \r\n * @notice Abstract contract module implementing ownership functionality through\r\n * inheritance as a basic access control mechanism, where there is an owner account\r\n * that can be granted exclusive access to specific functions.\r\n * \r\n * @dev The initial owner is set to the address provided by the deployer and can\r\n * later be changed with {transferOwnership}.\r\n */\r\nabstract contract Ownable {\r\n\r\n    // DATA\r\n\r\n    address private _owner;\r\n\r\n    // MODIFIER\r\n\r\n    /**\r\n     * @notice Modifier that allows access only to the contract owner.\r\n     *\r\n     * @dev Should throw if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the `account` is not authorized to perform an operation.\r\n     * \r\n     * @param account Address used to perform the operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @notice Error indicating that the provided `owner` address is invalid.\r\n     * \r\n     * @param owner Address used to perform the operation.\r\n     * \r\n     * @dev Should throw if called by an invalid owner account such as address(0) as an example.\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /**\r\n     * @notice Initializes the contract setting the `initialOwner` address provided by\r\n     * the deployer as the initial owner.\r\n     * \r\n     * @param initialOwner The address to set as the initial owner.\r\n     *\r\n     * @dev Should throw an error if called with address(0) as the `initialOwner`.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n    \r\n    // EVENT\r\n    \r\n    /**\r\n     * @notice Emitted when ownership of the contract is transferred.\r\n     * \r\n     * @param previousOwner The address of the previous owner.\r\n     * @param newOwner The address of the new owner.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Get the address of the smart contract owner.\r\n     * \r\n     * @return The address of the current owner.\r\n     *\r\n     * @dev Should return the address of the current smart contract owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if the caller is the owner and reverts if not.\r\n     * \r\n     * @dev Should throw if the sender is not the current owner of the smart contract.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != msg.sender) {\r\n            revert OwnableUnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Allows the current owner to renounce ownership and make the\r\n     * smart contract ownerless.\r\n     * \r\n     * @dev This function can only be called by the current owner and will\r\n     * render all `onlyOwner` functions inoperable.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    \r\n    /**\r\n     * @notice Allows the current owner to transfer ownership of the smart contract\r\n     * to `newOwner` address.\r\n     * \r\n     * @param newOwner The address to transfer ownership to.\r\n     *\r\n     * @dev This function can only be called by the current owner and will render\r\n     * all `onlyOwner` functions inoperable to him/her. Should throw if called with\r\n     * address(0) as the `newOwner`.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n    \r\n    /**\r\n     * @notice Internal function to transfer ownership of the smart contract\r\n     * to `newOwner` address.\r\n     * \r\n     * @param newOwner The address to transfer ownership to.\r\n     *\r\n     * @dev This function replace current owner address stored as _owner with \r\n     * the address of the `newOwner`.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Auth Contract\r\n * \r\n * @notice Abstract contract module for managing authorization.\r\n *\r\n * @dev This contract provides functionality for authorizing and unauthorizing accounts.\r\n */\r\nabstract contract Auth is Ownable {\r\n    \r\n    // MAPPING\r\n\r\n    mapping(address => bool) public authorization;\r\n\r\n    // MODIFIER\r\n\r\n    modifier authorized() {\r\n        _checkAuthorized();\r\n        _;\r\n    }\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the account is not authorized.\r\n     * \r\n     * @dev Should throw if called when the account was not authorized.\r\n     */\r\n    error InvalidAuthorizedAccount(address account);\r\n\r\n    /**\r\n     * @notice Error indicating that current state is being used.\r\n     * \r\n     * @dev Should throw if called when the current state is being used.\r\n     */\r\n    error CurrentAuthorizedState(address account, bool state);\r\n    \r\n    // CONSTRUCTOR\r\n\r\n    constructor(\r\n        address initialOwner\r\n    ) Ownable(initialOwner) {\r\n        authorize(initialOwner);\r\n        if (initialOwner != msg.sender) {\r\n            authorize(msg.sender);\r\n        }\r\n    }\r\n\r\n    // EVENT\r\n    \r\n    /**\r\n     * @notice Emitted when the account's authorization status was updated.\r\n     * \r\n     * @param state The new state being used for the account.\r\n     * @param authorizedAccount The address of the account being updated.\r\n     * @param caller The address of the caller who update the account.\r\n     * @param timestamp The timestamp when the account was updated.\r\n     */\r\n    event UpdateAuthorizedAccount(address authorizedAccount, address caller, bool state, uint256 timestamp);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Checks if the caller is authorized.\r\n     * \r\n     * @dev This function checks whether the caller is authorized by verifying their\r\n     * presence in the authorization mapping. If the caller is not authorized, the\r\n     * function reverts with an appropriate error message.\r\n     */\r\n    function _checkAuthorized() internal view virtual {\r\n        if (!authorization[msg.sender]) {\r\n            revert OwnableUnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Authorizes an account.\r\n     * \r\n     * @param account The address of the account to be authorized.\r\n     * \r\n     * @dev This function authorizes the specified account by updating the authorization mapping.\r\n     * It checks if the account address is valid and not equal to address(0) or address(0xdead).\r\n     */\r\n    function authorize(address account) public virtual onlyOwner {\r\n        if (account == address(0) || account == address(0xdead)) {\r\n            revert InvalidAuthorizedAccount(account);\r\n        }\r\n        _authorization(account, msg.sender, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Unauthorizes an account.\r\n     * \r\n     * @param account The address of the account to be unauthorized.\r\n     * \r\n     * @dev This function unauthorizes the specified account by updating the authorization mapping.\r\n     * It checks if the account address is valid and not equal to address(0) or address(0xdead).\r\n     */\r\n    function unauthorize(address account) public virtual onlyOwner {\r\n        if (account == address(0) || account == address(0xdead)) {\r\n            revert InvalidAuthorizedAccount(account);\r\n        }\r\n        _authorization(account, msg.sender, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for managing authorization status.\r\n     * \r\n     * @param account The address of the account to be authorized or unauthorized.\r\n     * @param caller The address of the caller authorizing or unauthorizing the account.\r\n     * @param state The desired authorization state (true for authorized, false for unauthorized).\r\n     * \r\n     * @dev This function updates the authorization mapping for the specified account and emits an\r\n     * `UpdateAuthorizedAccount` event. It checks if the current authorization state matches the\r\n     * desired state before updating.\r\n     */\r\n    function _authorization(address account, address caller, bool state) internal virtual {\r\n        if (authorization[account] == state) {\r\n            revert CurrentAuthorizedState(account, state);\r\n        }\r\n        authorization[account] = state;\r\n        emit UpdateAuthorizedAccount(account, caller, state, block.timestamp);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  SECURITY\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title Pausable Contract\r\n * \r\n * @notice Abstract contract module implementing pause functionality through\r\n * inheritance as a basic security mechanism, where there certain functions\r\n * that can be paused and unpaused.\r\n */\r\nabstract contract Pausable {\r\n\r\n    // DATA\r\n\r\n    bool private _paused;\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error thrown when an action is attempted in an enforced pause.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @notice Error thrown when an action is attempted without the expected pause.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    // MODIFIER\r\n\r\n    /**\r\n     * @notice Modifier ensure functions are called when the contract is\r\n     * not paused.\r\n     * \r\n     * @dev Should throw if called when the contract is paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier ensure functions are called when the contract is\r\n     * paused.\r\n     * \r\n     * @dev Should throw if called when the contract is not paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /**\r\n     * @notice Initializes the contract setting the `_paused` state as false.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    // EVENT\r\n    \r\n    /**\r\n     * @notice Emitted when the contract is paused.\r\n     * \r\n     * @param account The address that initiate the function.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @notice Emitted when the contract is unpaused.\r\n     * \r\n     * @param account The address that initiate the function.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Returns the current paused state of the contract.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to pause the contract.\r\n     * \r\n     * @dev This function is accessible externally when not paused.\r\n     */\r\n    function pause() public virtual whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Function to unpause the contract.\r\n     * \r\n     * @dev This function is accessible externally when paused.\r\n     */\r\n    function unpause() public virtual whenPaused {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to revert if the contract is not paused.\r\n     * \r\n     * @dev Throws when smart contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to revert if the contract is paused.\r\n     * \r\n     * @dev Throws when smart contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to pause the contract.\r\n     * \r\n     * @dev This function emits {Paused} event.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to unpause the contract.\r\n     * \r\n     * @dev This function emits {Unpaused} event.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  STAKING\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title EternalAI Staking Contract\r\n * \r\n * @notice Eternal AI Staking contract allows users to stake tokens, earn rewards, and manage\r\n * staking pools.\r\n * \r\n * @dev This contract implements staking functionalities such as creating staking pools,\r\n * staking tokens, earning rewards, and managing the staking settings.\r\n */\r\ncontract EternalAIStaking is Auth, Pausable, ICommonErrors {\r\n\r\n    // LIBRARY\r\n\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    // DATA\r\n\r\n    struct Leaderboard {\r\n        uint256 amountStaked;\r\n        uint256 totalStaking;\r\n        uint256 activeStaking;\r\n        uint256 inactiveStaking;\r\n        address user;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint256 locked;\r\n        uint256 claimed;\r\n    }\r\n\r\n    struct RewardInfo {\r\n        address rewardToken;\r\n        address stakeToken;\r\n        address creator;\r\n        uint256 totalStaker;\r\n        uint256 createTime;\r\n        uint256 stakeDuration;\r\n        uint256 amountAdded;\r\n        uint256 amountClaimed;\r\n        uint256 amountAllocated;\r\n        uint256 rewardsPerStake;\r\n        uint256 rewardsPerStakeAccuracyFactor;\r\n        bool status;\r\n    }\r\n\r\n    struct StakingInfo {\r\n        uint256 amountStaked;\r\n        uint256 totalStaking;\r\n        uint256 activeStaking;\r\n        uint256 inactiveStaking;\r\n    }\r\n\r\n    struct StakeInfo {\r\n        bool stakeActive;\r\n        address stakeToken;\r\n        uint256 stakeTime;\r\n        uint256 unstakeTime;\r\n        uint256 totalEarned;\r\n        uint256 stakeAmount;\r\n        uint256 rewardAmount;\r\n    }\r\n\r\n    address public projectOwner;\r\n    address public penaltyReceiver;\r\n    address public currentStakeToken;\r\n    address public currentRewardToken;\r\n\r\n    uint256 public constant DENOMINATOR = 100_000;\r\n\r\n    uint256 public penaltyPercentage = 20_000;\r\n    uint256 public rewardsPerStakeAccuracyFactor = 0;\r\n    uint256 public totalRewardPool = 0;\r\n    uint256 public totalStaking = 0;\r\n    uint256 public totalStaked = 0;\r\n\r\n    bool public isFailsafeLocked = false;\r\n    bool public emergencyWithdraw = false;\r\n    bool public takePenalty = false;\r\n    bool public wTokenLocked = false;\r\n\r\n    // MAPPING\r\n\r\n    mapping(address tokenAddress => bool) public isStakeToken;\r\n    mapping(address rewardAddress => bool) public isRewardToken;\r\n    mapping(address tokenAddress => TokenInfo) public infoStakeToken;\r\n    mapping(address rewardAddress => TokenInfo) public infoRewardToken;\r\n    mapping(uint256 poolId => RewardInfo) public rewardPool;\r\n    mapping(uint256 poolId => bool) public poolClosed;\r\n    mapping(uint256 poolId => uint256) public maxStakeAllowed;\r\n    mapping(uint256 poolId => uint256) public currentStakeAmount;\r\n    mapping(uint256 poolId => mapping(address account => uint256)) public poolStakerIndex;\r\n    mapping(uint256 poolId => mapping(uint256 stakerId => address)) public poolStakerAtIndex;\r\n    mapping(uint256 poolId => mapping(address account => StakingInfo)) public poolUserStakingInfo;\r\n    mapping(uint256 poolId => mapping(address account => mapping(uint256 stakeId => StakeInfo))) public poolUserStakes;\r\n    mapping(uint256 poolId => mapping(address account => mapping(address tokenAddress => uint256))) public poolUserStakeAmount;\r\n    mapping(uint256 poolId => mapping(address account => mapping(address rewardAddress => uint256))) public poolUserRewardAmount;\r\n    mapping(uint256 poolId => mapping(address account => mapping(uint256 stakeId => bool))) public poolUserClaimStatus;\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the stake is invalid.\r\n     * \r\n     * @dev Should throw if called when the stake was closed or paused.\r\n     */\r\n    error InactiveStake();\r\n\r\n    /**\r\n     * @notice Error indicating that the stucked fund can no longer be rescued.\r\n     * \r\n     * @dev Should throw if called wTokens are already locked.\r\n     */\r\n    error CanNoLongerRescueFund();\r\n\r\n    /**\r\n     * @notice Error indicating that the project owner cannot initiate transfer of Ether.\r\n     * \r\n     * @dev Should throw if called by `projectOwner` address.\r\n     */\r\n    error ProjectOwnerCannotInitiateTransferEther();\r\n\r\n    /**\r\n     * @notice Error indicating that the cannot initiate with all current address.\r\n     * \r\n     * @dev Should throw if called with all current addresses.\r\n     */\r\n    error CannotUseAllCurrentAddress();\r\n\r\n    /**\r\n     * @notice Error indicating that lock is active for given state and cannot be modified.\r\n     * \r\n     * @param lockType The name of the lock.\r\n     */\r\n    error Locked(string lockType);\r\n\r\n    /**\r\n     * @notice Error indicating that stake id provided is invalid.\r\n     * \r\n     * @param poolId The pool id that the stake was created for.\r\n     * @param stakeId The stake id that trigger the error.\r\n     * @param minId The minimum value that's valid for stake id.\r\n     * @param maxId The maximum value that's valud for stake id.\r\n     */\r\n    error InvalidStakeId(uint256 poolId, uint256 stakeId, uint256 minId, uint256 maxId);\r\n\r\n    /**\r\n     * @notice Error indicating that pool id provided is invalid.\r\n     * \r\n     * @param poolId The pool id that trigger the error.\r\n     * @param minId The minimum value that's valid for pool id.\r\n     * @param maxId The maximum value that's valud for pool id.\r\n     */\r\n    error InvalidPoolId(uint256 poolId, uint256 minId, uint256 maxId);\r\n\r\n    /**\r\n     * @notice Error indicating that it is not the time to unstake.\r\n     * \r\n     * @param current The current timestamp.\r\n     * @param unstakeTime The timestamp for the unstake.\r\n     */\r\n    error NotTimeToUnstake(uint256 current, uint256 unstakeTime);\r\n\r\n    /**\r\n     * @notice Error indicating that the users has no staking for the given pool id.\r\n     * \r\n     * @param poolId The pool id being checked for user staking availability.\r\n     */\r\n    error UserHasNoStaking(uint256 poolId);\r\n\r\n    /**\r\n     * @notice Error indicating that the given pool id is inactive.\r\n     * \r\n     * @param poolId The pool id being checked for inactiveness.\r\n     */\r\n    error PoolNotActive(uint256 poolId);\r\n\r\n    /**\r\n     * @notice Error indicating the current status.\r\n     * \r\n     * @param status The current status.\r\n     */\r\n    error Status(string status);\r\n\r\n    /**\r\n     * @notice Error indicating that the amount exceed max allowed stake amount for given pool id.\r\n     * \r\n     * @param poolId The pool id that the user want to stake for.\r\n     * @param current The current amount that the user want to stake.\r\n     * @param max The max amount allowed that the user can stake.\r\n     */\r\n    error AmountExceedMaxStakeAllowedForPool(uint256 poolId, uint256 current, uint256 max);\r\n\r\n    // MODIFIER\r\n\r\n    /**\r\n     * @notice Modifier that allows access only to the project owner or current\r\n     * smart contract owner.\r\n     *\r\n     * @dev Should throw if called by any account other than the project owner or\r\n     * smart contract owner.\r\n     */\r\n    modifier onlyOwnerFailsafe() {\r\n        checkOwnerFailsafe();\r\n        _;\r\n    }\r\n    \r\n    // CONSTRUCTOR\r\n\r\n    constructor(\r\n        address stakeToken,\r\n        address rewardToken,\r\n        address penaltyReceiverAddress\r\n    ) Auth (msg.sender) {\r\n        if (penaltyReceiverAddress == address(0) || penaltyReceiverAddress == address(0xdead)) {\r\n            revert InvalidAddress(penaltyReceiverAddress);\r\n        }\r\n        penaltyReceiver = penaltyReceiverAddress;\r\n        projectOwner = msg.sender;\r\n\r\n        currentStakeToken = stakeToken;\r\n        currentRewardToken = rewardToken;\r\n\r\n        uint8 stakeDecimals = IERC20Metadata(stakeToken).decimals();\r\n        uint8 rewardDecimals = IERC20Metadata(rewardToken).decimals();\r\n        rewardsPerStakeAccuracyFactor = (1 * 10**stakeDecimals) * (1 * 10**rewardDecimals);\r\n\r\n        isStakeToken[stakeToken] = true;\r\n        isRewardToken[rewardToken] = true;\r\n    }\r\n\r\n    // EVENT\r\n\r\n    /**\r\n     * @notice Emitted when a lock is applied.\r\n     * \r\n     * @param lockType The type of lock applied.\r\n     * @param caller The address of the caller who applied the lock.\r\n     * @param timestamp The timestamp when the lock was applied.\r\n     */\r\n    event Lock(string lockType, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the value is updated.\r\n     * \r\n     * @param oldValue The old value before the update.\r\n     * @param newValue The new value after the update.\r\n     * @param caller The address of the caller who updated the value.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event UpdateValue(string valueType, uint256 oldValue, uint256 newValue, address caller, uint256 timestamp);\r\n    \r\n    /**\r\n     * @notice Emitted when the state is updated.\r\n     * \r\n     * @param oldState The old state before the update.\r\n     * @param newState The new state after the update.\r\n     * @param caller The address of the caller who updated the state.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event UpdateState(string stateType, bool oldState, bool newState, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the address is updated.\r\n     * \r\n     * @param oldAddress The old address before the update.\r\n     * @param newAddress The new address after the update.\r\n     * @param caller The address of the caller who updated the address.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event UpdateAddress(string addressType, address oldAddress, address newAddress, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the staking rule is updated.\r\n     * \r\n     * @param oldStakeToken The old stake token address before the update.\r\n     * @param newStakeToken The new stake token address after the update.\r\n     * @param oldRewardToken The old reward token address before the update.\r\n     * @param newRewardToken The new reward token address after the update.\r\n     * @param caller The address of the caller who updated the address.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event UpdateStakingRule(address oldStakeToken, address oldRewardToken, address newStakeToken, address newRewardToken, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when a user stake token.\r\n     * \r\n     * @param poolId The pool id for the stake that user staked for.\r\n     * @param stakeId The stake id of the current stake by the user.\r\n     * @param amount The amount of token being staked by the user.\r\n     * @param stakeToken The address of the stake token being staked by the user.\r\n     * @param caller The address of the user who stake the token.\r\n     * @param timestamp The timestamp when the user staked the token.\r\n     */\r\n    event Stake(uint256 poolId, uint256 stakeId, uint256 amount, address stakeToken, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when a user unstake token.\r\n     * \r\n     * @param poolId The pool id for the unstake that user unstaked from.\r\n     * @param stakeId The stake id of the stake being unstaked by the user.\r\n     * @param amount The amount of token being unstaked by the user.\r\n     * @param stakeToken The address of the stake token being unstaked by the user.\r\n     * @param caller The address of the user who unstake the token.\r\n     * @param timestamp The timestamp when the user unstaked the token.\r\n     */\r\n    event Unstake(uint256 poolId, uint256 stakeId, uint256 amount, address stakeToken, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the reward is being ditributed to the user.\r\n     * \r\n     * @param poolId The pool id for the reward being taken from.\r\n     * @param stakeId The stake id of the stake that the reward being ditributed for.\r\n     * @param amount The amount of token being distributed for the reward to the user.\r\n     * @param rewardToken The address of the reward token being distributed to the user.\r\n     * @param staker The address of the staker receiving the reward being distributed.\r\n     * @param caller The address of the caller who initiated the reward distribution.\r\n     * @param timestamp The timestamp when the reward being distributed.\r\n     */\r\n    event RewardDistribute(uint256 poolId, uint256 stakeId, uint256 amount, address rewardToken, address staker, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the pool is being closed.\r\n     * \r\n     * @param poolId The pool id that is being closed.\r\n     * @param rewardToReturn The amount of reward to be returned to the pool creator.\r\n     * @param caller The address of the caller who initiated the closure of the pool.\r\n     * @param timestamp The timestamp when the pool closed.\r\n     */\r\n    event PoolClosed(uint256 poolId, uint256 rewardToReturn, address caller, uint256 timestamp);\r\n\r\n    // FUNCTION\r\n\r\n    /* General */\r\n    \r\n    /**\r\n     * @notice Allows the contract to receive Ether.\r\n     * \r\n     * @dev This is a required feature to have in order to allow the smart contract\r\n     * to be able to receive ether.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Withdraws tokens or Ether from the contract to a specified address.\r\n     * \r\n     * @param tokenAddress The address of the token to withdraw.\r\n     * @param amount The amount of tokens or Ether to withdraw.\r\n     * \r\n     * @dev You need to use address(0) as `tokenAddress` to withdraw Ether and\r\n     * use 0 as `amount` to withdraw the whole available amount in the smart contract.\r\n     * Anyone can trigger this function to send the fund to the `projectOwner`.\r\n     * Only `projectOwner` address will not be able to trigger this function to\r\n     * withdraw Ether from the smart contract by himself/herself.\r\n     */\r\n    function wTokens(address tokenAddress, uint256 amount) external {\r\n        if (wTokenLocked) {\r\n            revert CanNoLongerRescueFund();\r\n        }\r\n        uint256 toTransfer = amount;\r\n        \r\n        if (tokenAddress == address(0)) {\r\n            if (amount == 0) {\r\n                toTransfer = address(this).balance;\r\n            }\r\n            if (msg.sender == projectOwner) {\r\n                revert ProjectOwnerCannotInitiateTransferEther();\r\n            }\r\n            payable(projectOwner).transfer(toTransfer);\r\n        } else if (isStakeToken[tokenAddress]) {\r\n            uint256 remaining = infoStakeToken[tokenAddress].locked - infoStakeToken[tokenAddress].claimed;\r\n            uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\r\n            uint256 available = balance - remaining;\r\n            if (available == 0 || amount > available) {\r\n                revert IERC20Errors.ERC20InsufficientBalance(msg.sender, available, amount);\r\n            }\r\n            if (amount == 0) {\r\n                toTransfer = available;\r\n            }\r\n            IERC20(tokenAddress).safeTransfer(projectOwner, toTransfer);\r\n        } else if (isRewardToken[tokenAddress]) {\r\n            uint256 remaining = infoRewardToken[tokenAddress].locked - infoRewardToken[tokenAddress].claimed;\r\n            uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\r\n            uint256 available = balance - remaining;\r\n            if (available == 0 || amount > available) {\r\n                revert IERC20Errors.ERC20InsufficientBalance(msg.sender, available, amount);\r\n            }\r\n            if (amount == 0) {\r\n                toTransfer = available;\r\n            }\r\n            IERC20(tokenAddress).safeTransfer(projectOwner, toTransfer);\r\n        } else {\r\n            if (amount == 0) {\r\n                toTransfer = IERC20(tokenAddress).balanceOf(address(this));\r\n            }\r\n            IERC20(tokenAddress).safeTransfer(projectOwner, toTransfer);\r\n        }\r\n    }\r\n\r\n    /* Check */\r\n    \r\n    /**\r\n     * @notice Checks if the caller is the project owner and reverts if not.\r\n     * \r\n     * @dev Should throw if the sender is not the current project owner.\r\n     */\r\n    function checkOwnerFailsafe() internal view {\r\n        checkFailsafeLock();\r\n        if (projectOwner != msg.sender && owner() != msg.sender) {\r\n            revert OwnableUnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the failsafe is already locked.\r\n     * \r\n     * @dev Should throw if the failsafe locked.\r\n     */\r\n    function checkFailsafeLock() internal view {\r\n        if (isFailsafeLocked) {\r\n            revert Locked(\"Failsafe\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if using current value.\r\n     * \r\n     * @dev Should throw if using current value.\r\n     */\r\n    function checkCurrentValue(uint256 newValue, uint256 current) internal pure {\r\n        if (newValue == current) {\r\n            revert CannotUseCurrentValue(newValue);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if using current state.\r\n     * \r\n     * @dev Should throw if using current state.\r\n     */\r\n    function checkCurrentState(bool newState, bool current) internal pure {\r\n        if (newState == current) {\r\n            revert CannotUseCurrentState(newState);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if using current address.\r\n     * \r\n     * @dev Should throw if using current address.\r\n     */\r\n    function checkCurrentAddress(address newAddress, address current) internal pure {\r\n        if (newAddress == current) {\r\n            revert CannotUseCurrentAddress(newAddress);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if using invalid address.\r\n     * \r\n     * @dev Should throw if using invalid address.\r\n     */\r\n    function checkInvalidAddress(address newAddress, address invalid) internal pure {\r\n        if (newAddress == invalid) {\r\n            revert CannotUseCurrentAddress(newAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if using valid pool id.\r\n     * \r\n     * @dev Should throw if using invalid id.\r\n     */\r\n    function checkPoolId(uint256 poolId) internal view {\r\n        if (poolId < 1 || poolId > totalRewardPool) {\r\n            revert InvalidPoolId(poolId, 1, totalRewardPool);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if using valid stake id.\r\n     * \r\n     * @dev Should throw if using invalid id.\r\n     */\r\n    function checkStakeId(uint256 poolId, uint256 stakeId, address staker) internal view {\r\n        if (stakeId < 1 || stakeId > poolUserStakingInfo[poolId][staker].totalStaking) {\r\n            revert InvalidStakeId(poolId, stakeId, 1, poolUserStakingInfo[poolId][msg.sender].totalStaking);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the pending reward for a specific staking position of a staker in a specified\r\n     * reward pool.\r\n     * \r\n     * @param poolId The ID of the reward pool for which the pending reward is being calculated.\r\n     * @param stakeId The ID of the staking position for which the pending reward is being calculated.\r\n     * @param staker The address of the staker for whom the pending reward is being calculated.\r\n     * \r\n     * @return The pending reward for the specified staking position of the specified staker in the\r\n     * specified reward pool.\r\n     * \r\n     * @dev This function calculates and returns the pending reward for the specified staking position\r\n     * identified by the `stakeId` of the specified staker in the specified reward pool identified by\r\n     * the `poolId`. It checks if the reward for the staking position has already been claimed. If the\r\n     * reward has not been claimed, it calculates the pending reward based on the stake amount, rewards\r\n     * per stake, and rewards per stake accuracy  factor of the reward pool, and returns the result. If\r\n     * the reward has been claimed, it returns 0 as the pending reward.\r\n     */\r\n    function checkReward(uint256 poolId, uint256 stakeId, address staker) public view returns (uint256) {\r\n        uint256 amount = poolUserStakes[poolId][staker][stakeId].stakeAmount;\r\n        uint256 reward = 0;\r\n        if (!poolUserClaimStatus[poolId][staker][stakeId]) {\r\n            reward = amount * rewardPool[stakeId].rewardsPerStake / rewardPool[stakeId].rewardsPerStakeAccuracyFactor;\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the total pending rewards for a staker in a specified reward pool.\r\n     * \r\n     * @param poolId The ID of the reward pool for which pending rewards are being retrieved.\r\n     * @param staker The address of the staker for whom pending rewards are being retrieved.\r\n     * \r\n     * @return The total pending rewards for the specified staker in the specified reward pool.\r\n     * \r\n     * @dev This function calculates and returns the total pending rewards for a staker in the specified\r\n     * reward pool identified by the `poolId`. It iterates through all the staking positions of the staker\r\n     * within the pool and accumulates the pending rewards using the `checkReward` function. If the staker\r\n     * has no staking positions or all staking positions are inactive, the function reverts with an error\r\n     * message indicating that the user has no staking positions in the specified pool.\r\n    */\r\n    function getAllPendingReward(uint256 poolId, address staker) public view returns (uint256) {\r\n        uint256 poolUserTotalStaking = poolUserStakingInfo[poolId][staker].totalStaking;\r\n        uint256 pending = 0;\r\n        if (poolUserTotalStaking < 1 || poolUserStakingInfo[poolId][staker].activeStaking < 1) {\r\n            revert UserHasNoStaking(poolId);\r\n        }\r\n        for (uint256 i = 1; i <= poolUserTotalStaking; i++) {\r\n            pending += checkReward(poolId, i, staker);\r\n        }\r\n        return pending;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the pending rewards for a specific staking position of a staker in a specified\r\n     * reward pool.\r\n     * \r\n     * @param poolId The ID of the reward pool for which pending rewards are being retrieved.\r\n     * @param stakeId The ID of the staking position for which pending rewards are being retrieved.\r\n     * @param staker The address of the staker for whom pending rewards are being retrieved.\r\n     * \r\n     * @return The pending rewards for the specified staking position of the specified staker in the\r\n     * specified reward pool.\r\n     * \r\n     * @dev This function calculates and returns the pending rewards for the specified staking position\r\n     * identified by the `stakeId` of the specified staker in the specified reward pool identified by the\r\n     * `poolId`. It checks if the staking position is active using the `checkStakeId` function. If the\r\n     * staking position is inactive, the function reverts with an error message indicating that the stake\r\n     * is inactive. Otherwise, it calculates the pending reward using the `checkReward` function and returns\r\n     * the result.\r\n     */\r\n    function getPendingReward(uint256 poolId, uint256 stakeId, address staker) public view returns (uint256) {\r\n        checkStakeId(poolId, stakeId, staker);\r\n        if (!poolUserStakes[poolId][staker][stakeId].stakeActive) {\r\n            revert InactiveStake();\r\n        }\r\n        return checkReward(poolId, stakeId, staker);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the leaderboard for the specified pool.\r\n     * \r\n     * @param poolId The ID of the pool for which the leaderboard is being retrieved.\r\n     * \r\n     * @return An array of Leaderboard structs containing staking information for the pool.\r\n     * \r\n     * @dev This function is publicly accessible and returns an array of Leaderboard structs\r\n     * representing staking information.\r\n     */\r\n    function getLeaderboard(uint256 poolId) external view returns (Leaderboard[] memory) {\r\n        Leaderboard[] memory board = new Leaderboard[](rewardPool[poolId].totalStaker);\r\n        for (uint256 i = 0; i < rewardPool[poolId].totalStaker; i++) {\r\n            address user = poolStakerAtIndex[poolId][i + 1];\r\n            \r\n            Leaderboard memory item = Leaderboard({\r\n                amountStaked: poolUserStakingInfo[poolId][user].amountStaked,\r\n                totalStaking: poolUserStakingInfo[poolId][user].totalStaking,\r\n                activeStaking: poolUserStakingInfo[poolId][user].activeStaking,\r\n                inactiveStaking: poolUserStakingInfo[poolId][user].inactiveStaking,\r\n                user: user\r\n            });\r\n            board[i]= item;\r\n        }\r\n\r\n        for (uint256 i = 0; i < board.length - 1; i++) {\r\n            for (uint256 j = 0; j < board.length - i - 1; j++) {\r\n                if (board[j].amountStaked <= board[j + 1].amountStaked) {\r\n                    Leaderboard memory temp = board[j];\r\n                    board[j] = board[j + 1];\r\n                    board[j + 1] = temp;\r\n                }\r\n            }\r\n        }\r\n        return board;\r\n    }\r\n\r\n    /* Update */\r\n\r\n    /**\r\n     * @notice Locks the failsafe feature, preventing access control once locked.\r\n     * \r\n     * @dev This function will emits the Lock event.\r\n     */\r\n    function lockFailsafe() external onlyOwnerFailsafe {\r\n        checkFailsafeLock();\r\n        isFailsafeLocked = true;\r\n        emit Lock(\"isFailsafeLocked\", msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Locks the wToken feature, preventing stucked fund from being rescued.\r\n     * \r\n     * @dev This function will emits the Lock event.\r\n     */\r\n    function lockWToken() external onlyOwner {\r\n        if (wTokenLocked) {\r\n            revert CanNoLongerRescueFund();\r\n        }\r\n        wTokenLocked = true;\r\n        emit Lock(\"wToken\", msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the penalty receiver address.\r\n     * \r\n     * @param newReceiver The new address to set as the penalty receiver.\r\n     * \r\n     * @dev This function can only be called by the owner of the contract and when in failsafe mode.\r\n     * It checks if the new receiver address is valid by calling the `checkCurrentAddress` function.\r\n     * It also checks if the new receiver address is not the zero address or the `0xdead` address.\r\n     * If any of these checks fail, the function reverts with an error message. Otherwise, it updates\r\n     * the penalty receiver address and emits an `UpdateAddress` event.\r\n     */\r\n    function updatePenaltyReceiver(address newReceiver) external onlyOwnerFailsafe {\r\n        checkCurrentAddress(newReceiver, penaltyReceiver);\r\n        checkInvalidAddress(newReceiver, address(0));\r\n        checkInvalidAddress(newReceiver, address(0xdead));\r\n        address oldReceiver = penaltyReceiver;\r\n        penaltyReceiver = newReceiver;\r\n        emit UpdateAddress(\"penaltyReceiver\", oldReceiver, newReceiver, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the penalty percentage.\r\n     * \r\n     * @param newPenalty The new penalty percentage to be set.\r\n     * \r\n     * @dev This function can only be called by the owner of the contract and when in failsafe mode.\r\n     * It checks if the new penalty percentage is valid by calling the `checkCurrentValue` function.\r\n     * If the penalty percentage exceeds 20%, the function reverts with an error message. Otherwise,\r\n     * it updates the penalty percentage and emits an `UpdateValue` event.\r\n     */\r\n    function updatePenalty(uint256 newPenalty) external onlyOwnerFailsafe {\r\n        checkCurrentValue(newPenalty, penaltyPercentage);\r\n        if (penaltyPercentage > 2_000) {\r\n            revert InvalidValue(newPenalty);\r\n        }\r\n        uint256 oldPenalty = penaltyPercentage;\r\n        penaltyPercentage = newPenalty;\r\n        emit UpdateValue(\"penaltyPercentage\", oldPenalty, newPenalty, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the take penalty state.\r\n     * \r\n     * @param newState The new take penalty state to be set.\r\n     * \r\n     * @dev This function can only be called by the owner of the contract and when in failsafe mode.\r\n     * It updates the take penalty state to the specified new state. If the new state is the same as\r\n     * the current state, the function reverts with an error message. Otherwise, it updates the take\r\n     * penalty state and emits an `UpdateState` event.\r\n     */\r\n    function updateTakePenalty(bool newState) external onlyOwnerFailsafe {\r\n        checkCurrentState(newState, takePenalty);\r\n        bool oldState = takePenalty;\r\n        takePenalty = newState;\r\n        emit UpdateState(\"takePenalty\", oldState, newState, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the emergency withdrawal state.\r\n     * \r\n     * @param newState The new emergency withdrawal state to be set.\r\n     * \r\n     * @dev This function can only be called by the owner of the contract and when in failsafe mode.\r\n     * It updates the emergency withdrawal state to the specified new state. If the new state is the\r\n     * same as the current state, the function reverts with an error message. Otherwise, it updates\r\n     * the emergency withdrawal state and emits an `UpdateState` event.\r\n     */\r\n    function updateEmergencyWithdraw(bool newState) external onlyOwnerFailsafe {\r\n        checkCurrentState(newState, emergencyWithdraw);\r\n        bool oldState = emergencyWithdraw;\r\n        emergencyWithdraw = newState;\r\n        emit UpdateState(\"emergencyWithdraw\", oldState, newState, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /*\r\n     * @notice Updates the staking rule by changing the stake token and reward token addresses.\r\n     * \r\n     * @param newStakeToken The address of the new stake token.\r\n     * @param newRewardToken The address of the new reward token.\r\n     * \r\n     * @dev This function can only be called by the owner of the contract. It updates the staking\r\n     * rule by changing the stake token and reward token addresses. If the new stake token and reward\r\n     * token addresses are the same as the current ones, the function reverts with an error message.\r\n     * This function will emits the UpdateStakingRule event.\r\n     */\r\n    function updateStakingRule(address newStakeToken, address newRewardToken) external onlyOwner {\r\n        if (newStakeToken == currentStakeToken && newRewardToken == currentRewardToken) {\r\n            revert CannotUseAllCurrentAddress();\r\n        }\r\n        address oldStakeToken = currentStakeToken;\r\n        address oldRewardToken = currentRewardToken;\r\n        currentStakeToken = newStakeToken;\r\n        currentRewardToken = newRewardToken;\r\n\r\n        uint8 stakeDecimals = IERC20Metadata(newStakeToken).decimals();\r\n        uint8 rewardDecimals = IERC20Metadata(newRewardToken).decimals();\r\n        rewardsPerStakeAccuracyFactor = (1 * 10**stakeDecimals) * (1 * 10**rewardDecimals);\r\n\r\n        if (!isStakeToken[newStakeToken]) {\r\n            isStakeToken[newStakeToken] = true;\r\n        }\r\n        if (!isRewardToken[newRewardToken]) {\r\n            isRewardToken[newRewardToken] = true;\r\n        }\r\n\r\n        emit UpdateStakingRule(oldStakeToken, oldRewardToken, newStakeToken, newRewardToken, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /* Override */\r\n    \r\n    /**\r\n     * @notice Overrides the {transferOwnership} function to update project owner.\r\n     * \r\n     * @param newOwner The address of the new owner.\r\n     * \r\n     * @dev Should throw if the `newOwner` is set to the current owner address or address(0xdead).\r\n     * This overrides function is just an extended version of the original {transferOwnership}\r\n     * function. See {Ownable-transferOwnership} for more information.\r\n     */\r\n    function transferOwnership(address newOwner) public override onlyOwner {\r\n        checkCurrentAddress(newOwner, owner());\r\n        checkInvalidAddress(newOwner, address(0xdead));\r\n        projectOwner = newOwner;\r\n        super.transferOwnership(newOwner);\r\n    }\r\n    \r\n    /**\r\n     * @notice Function to pause the contract.\r\n     * \r\n     * @dev This function is accessible externally when not paused only by authorized account.\r\n     */\r\n    function pause() public override whenNotPaused authorized {\r\n        super.pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Function to unpause the contract.\r\n     * \r\n     * @dev This function is accessible externally when paused only by authorized account.\r\n     */\r\n    function unpause() public override whenPaused authorized {\r\n        super.unpause();\r\n    }\r\n\r\n    /* Reward */\r\n    \r\n    /**\r\n     * @notice Creates a new reward pool.\r\n     * \r\n     * @param stakeDuration The duration for which stakes are locked in the reward pool.\r\n     * @param rewardToAdd The amount of reward tokens to add to the reward pool.\r\n     * @param maxTokenStake The maximum amount of tokens allowed to be staked in the pool.\r\n     * \r\n     * @dev This function allows an authorized account to create a new reward pool. If multiple\r\n     * reward pools are created sequentially, the previous pool is closed automatically to\r\n     * prevent overlapping pools. This function will transfer the reward tokens from the caller\r\n     * to the contract, hence it is important to first approve an allowance for this contract.\r\n     */\r\n    function createRewardPool(uint256 stakeDuration, uint256 rewardToAdd, uint256 maxTokenStake) external whenNotPaused authorized {\r\n        uint256 allowance = IERC20(currentRewardToken).allowance(msg.sender, address(this));\r\n        uint256 balance = IERC20(currentRewardToken).balanceOf(msg.sender);\r\n        \r\n        if (rewardToAdd < 1) {\r\n            revert InvalidValue(rewardToAdd);\r\n        }\r\n        if (maxTokenStake < 1) {\r\n            revert InvalidValue(maxTokenStake);\r\n        }\r\n        if (allowance < rewardToAdd) {\r\n            revert IERC20Errors.ERC20InsufficientAllowance(address(this), allowance, rewardToAdd);\r\n        }\r\n        if (balance < rewardToAdd) {\r\n            revert IERC20Errors.ERC20InsufficientBalance(msg.sender, balance, rewardToAdd);\r\n        }\r\n\r\n        totalRewardPool += 1;\r\n        infoRewardToken[currentRewardToken].locked += rewardToAdd;\r\n        rewardPool[totalRewardPool].stakeToken = currentStakeToken;\r\n        rewardPool[totalRewardPool].rewardToken = currentRewardToken;\r\n        rewardPool[totalRewardPool].creator = msg.sender;\r\n        rewardPool[totalRewardPool].createTime = block.timestamp;\r\n        rewardPool[totalRewardPool].stakeDuration = stakeDuration;\r\n        rewardPool[totalRewardPool].amountAdded += rewardToAdd;\r\n        rewardPool[totalRewardPool].rewardsPerStake = rewardsPerStakeAccuracyFactor * rewardToAdd / maxTokenStake;\r\n        rewardPool[totalRewardPool].rewardsPerStakeAccuracyFactor = rewardsPerStakeAccuracyFactor;\r\n        rewardPool[totalRewardPool].status = true;\r\n        maxStakeAllowed[totalRewardPool] = maxTokenStake;\r\n        if (totalRewardPool > 1 && !poolClosed[totalRewardPool - 1]) {\r\n            poolClosed[totalRewardPool - 1] = true;\r\n            closePool(totalRewardPool - 1);\r\n        }\r\n        IERC20(currentRewardToken).transferFrom(msg.sender, address(this), rewardToAdd);\r\n    }\r\n\r\n    /**\r\n     * @notice Pauses the currently active reward pool.\r\n     * \r\n     * @dev This function is externally accessible and can only be called by an authorized\r\n     * address when the contract is not paused.\r\n     */\r\n    function pauseRewardPool() external whenNotPaused authorized {\r\n        if (!rewardPool[totalRewardPool].status && !poolClosed[totalRewardPool]) {\r\n            revert Status(\"Already Paused\");\r\n        }\r\n        rewardPool[totalRewardPool].status = false;\r\n        emit UpdateState(\"rewardPoolStatus\", true, false, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Unpauses the currently paused reward pool, allowing it to resume operation.\r\n     * \r\n     * @dev This function is externally accessible and can only be called by an authorized\r\n     * address when the contract is not paused.\r\n     */\r\n    function unpauseRewardPool() external whenNotPaused authorized {\r\n        if (rewardPool[totalRewardPool].status && !poolClosed[totalRewardPool]) {\r\n            revert Status(\"Already Running\");\r\n        }\r\n        rewardPool[totalRewardPool].status = true;\r\n        emit UpdateState(\"rewardPoolStatus\", false, true, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Closes the currently active reward pool, preventing further staking and rewards distribution.\r\n     * \r\n     * @dev This function is externally accessible and can only be called by an authorized address when the\r\n     * contract is not paused. Once closed, the pool's status is updated and additional actions may be\r\n     * triggered internally.\r\n     */\r\n    function closeRewardPool() external whenNotPaused authorized {\r\n        if (poolClosed[totalRewardPool]) {\r\n            revert Status(\"Already Closed\");\r\n        }\r\n        poolClosed[totalRewardPool] = true;\r\n        closePool(totalRewardPool);\r\n    }\r\n\r\n    /**\r\n     * @notice Closes the specified reward pool, finalizing its operation and returning any \r\n     * unallocated rewards to the creator.\r\n     * \r\n     * @param poolId The ID of the reward pool to be closed.\r\n     * \r\n     * @dev This function is internally used and should not be called directly from external\r\n     * contracts or accounts.\r\n     */\r\n    function closePool(uint256 poolId) internal {\r\n        if (rewardPool[poolId].status) {\r\n            rewardPool[poolId].status = false;\r\n        }\r\n\r\n        uint256 balance = IERC20(rewardPool[poolId].rewardToken).balanceOf(msg.sender);\r\n        uint256 rewardToReturn = rewardPool[poolId].amountAdded - rewardPool[poolId].amountAllocated;\r\n\r\n        infoRewardToken[rewardPool[poolId].rewardToken].claimed += rewardToReturn;\r\n        uint256 available = infoRewardToken[rewardPool[poolId].rewardToken].locked - infoRewardToken[rewardPool[poolId].rewardToken].claimed;\r\n        if (available < rewardToReturn) {\r\n            revert IERC20Errors.ERC20InsufficientBalance(msg.sender, balance, rewardToReturn);\r\n        }\r\n        emit PoolClosed(poolId, rewardToReturn, msg.sender, block.timestamp);\r\n        IERC20(rewardPool[poolId].rewardToken).transfer(rewardPool[poolId].creator, rewardToReturn);\r\n    }\r\n\r\n    /* Staking */\r\n    \r\n    /**\r\n     * @notice Allows a user to stake tokens into a specific pool.\r\n     * \r\n     * @param poolId The ID of the pool in which the tokens will be staked.\r\n     * @param amount The amount of tokens to be staked.\r\n     * \r\n     * @dev This function can only be called when the contract is not paused.\r\n     * It checks various conditions including the validity of the pool ID, the amount of tokens being staked,\r\n     * the allowance of tokens to be spent by the contract, and the balance of tokens in the user's account.\r\n     * If any of these conditions fail, the function reverts with an appropriate error message.\r\n     * Otherwise, it updates the staking information for the user and the pool, calculates rewards,\r\n     * transfers the staked tokens to the contract, and emits a `Stake` event.\r\n     */\r\n    function stake(uint256 poolId, uint256 amount) external whenNotPaused {\r\n        uint256 allowance = IERC20(rewardPool[poolId].stakeToken).allowance(msg.sender, address(this));\r\n        uint256 balance = IERC20(rewardPool[poolId].stakeToken).balanceOf(msg.sender);\r\n        uint256 allowed = maxStakeAllowed[poolId] - currentStakeAmount[poolId];\r\n        \r\n        checkPoolId(poolId);\r\n        \r\n        if (amount < 1) {\r\n            revert InvalidValue(amount);\r\n        }\r\n        if (allowance < amount) {\r\n            revert IERC20Errors.ERC20InsufficientAllowance(address(this), allowance, amount);\r\n        }\r\n        if (balance < amount) {\r\n            revert IERC20Errors.ERC20InsufficientBalance(msg.sender, balance, amount);\r\n        }\r\n        if (!rewardPool[poolId].status || poolClosed[poolId]) {\r\n            revert PoolNotActive(poolId);\r\n        }\r\n        if (allowed < amount) {\r\n            revert AmountExceedMaxStakeAllowedForPool(poolId, amount, allowed);\r\n        }\r\n\r\n        if (poolUserStakingInfo[poolId][msg.sender].amountStaked == 0) {\r\n            addStaker(poolId, msg.sender);\r\n        }\r\n        \r\n        poolUserStakingInfo[poolId][msg.sender].totalStaking += 1;\r\n        poolUserStakingInfo[poolId][msg.sender].activeStaking += 1;\r\n        poolUserStakingInfo[poolId][msg.sender].amountStaked += amount;\r\n\r\n        uint256 reward = amount * rewardPool[poolId].rewardsPerStake / rewardPool[poolId].rewardsPerStakeAccuracyFactor;\r\n        rewardPool[poolId].amountAllocated += reward;\r\n        \r\n        poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].stakeActive = true;\r\n        poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].stakeTime = block.timestamp;\r\n        poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].unstakeTime = block.timestamp + rewardPool[poolId].stakeDuration;\r\n        poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].stakeAmount = amount;\r\n        poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].stakeToken = rewardPool[poolId].stakeToken;\r\n        poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].rewardAmount = reward;\r\n        \r\n        currentStakeAmount[poolId] += amount;\r\n\r\n        poolUserStakeAmount[poolId][msg.sender][rewardPool[poolId].stakeToken] += amount;\r\n\r\n        infoStakeToken[rewardPool[poolId].stakeToken].locked += amount;\r\n    \r\n        totalStaking += 1;\r\n        totalStaked += amount;\r\n        \r\n        IERC20(rewardPool[poolId].stakeToken).transferFrom(msg.sender, address(this), amount);\r\n\r\n        emit Stake(poolId, poolUserStakingInfo[poolId][msg.sender].totalStaking, amount, rewardPool[poolId].stakeToken, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes tokens from a specified pool and stake ID.\r\n     * \r\n     * @param poolId The ID of the reward pool from which tokens are being unstaked.\r\n     * @param stakeId The ID of the stake from which tokens are being unstaked.\r\n     * \r\n     * @dev This function allows users to unstake tokens from a specified pool and stake ID.\r\n     * If the unstake time has not yet been reached and emergency withdrawal is not enabled, the\r\n     * function reverts with an appropriate error message. Otherwise, it distributes any accrued\r\n     * rewards, updates the user's staking information, decrements the total staking count, and\r\n     * transfers the unstaked amount of tokens back to the user. If emergency withdrawal and\r\n     * penalty are enabled, it calculates and transfers the penalty amount to the penalty receiver\r\n     * before transferring the remaining unstaked tokens to the user. Finally, it emits an Unstake\r\n     * event to notify external observers of the unstaking action.\r\n     */\r\n    function unstake(uint256 poolId, uint256 stakeId) external {\r\n        uint256 amount = poolUserStakes[poolId][msg.sender][stakeId].stakeAmount;\r\n        \r\n        checkStakeId(poolId, stakeId, msg.sender);\r\n        checkPoolId(poolId);\r\n        if (!poolUserStakes[poolId][msg.sender][stakeId].stakeActive) {\r\n            revert InactiveStake();\r\n        }\r\n        if (\r\n            amount < 1 ||\r\n            amount > poolUserStakingInfo[poolId][msg.sender].amountStaked ||\r\n            amount > poolUserStakes[poolId][msg.sender][stakeId].stakeAmount\r\n        ) {\r\n            revert InvalidValue(amount);\r\n        }\r\n        if (\r\n            block.timestamp < poolUserStakes[poolId][msg.sender][stakeId].unstakeTime &&\r\n            !emergencyWithdraw\r\n        ) {\r\n            revert NotTimeToUnstake(block.timestamp, poolUserStakes[poolId][msg.sender][stakeId].unstakeTime);\r\n        }\r\n\r\n        distributeReward(poolId, stakeId, msg.sender);\r\n\r\n        poolUserStakingInfo[poolId][msg.sender].amountStaked -= amount;\r\n        poolUserStakes[poolId][msg.sender][stakeId].stakeAmount -= amount;\r\n        if (poolUserStakes[poolId][msg.sender][stakeId].stakeAmount < 1) {\r\n            poolUserStakingInfo[poolId][msg.sender].inactiveStaking += 1;\r\n            poolUserStakingInfo[poolId][msg.sender].activeStaking -= 1;\r\n            poolUserStakes[poolId][msg.sender][stakeId].stakeActive = false;\r\n            totalStaking -= 1;\r\n        }\r\n\r\n        address stakeTokenAddress = poolUserStakes[poolId][msg.sender][stakeId].stakeToken;\r\n        poolUserStakeAmount[poolId][msg.sender][stakeTokenAddress] -= amount;\r\n        infoStakeToken[stakeTokenAddress].claimed += amount;\r\n        totalStaked -= amount;\r\n\r\n        if (poolUserStakingInfo[poolId][msg.sender].activeStaking < 1) {\r\n            removeStaker(poolId, msg.sender);\r\n        }\r\n\r\n        uint256 newAmount = amount;\r\n        if (\r\n            block.timestamp < poolUserStakes[poolId][msg.sender][stakeId].unstakeTime &&\r\n            emergencyWithdraw && \r\n            takePenalty\r\n        ) {\r\n            uint256 penaltyAmount = newAmount * penaltyPercentage / DENOMINATOR;\r\n            IERC20(stakeTokenAddress).transfer(penaltyReceiver, penaltyAmount);\r\n            newAmount -= penaltyAmount;\r\n        }\r\n        IERC20(stakeTokenAddress).transfer(msg.sender, newAmount);\r\n        emit Unstake(poolId, stakeId, amount, currentStakeToken, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Distributes rewards to a staker.\r\n     * \r\n     * @param poolId The ID of the reward pool.\r\n     * @param stakeId The ID of the stake within the reward pool.\r\n     * @param staker The address of the staker to whom rewards are distributed.\r\n     * \r\n     * @dev This internal function distributes rewards to the specified staker for a particular stake\r\n     * in a reward pool. Rewards are distributed only if the staker has not yet claimed rewards for\r\n     * the stake, and the current timestamp exceeds the unstake time for the stake. Once rewards are\r\n     * distributed, the reward amount is added to the staker's total earned rewards, and the claim\r\n     * status for the stake is updated. If it is trigger during emergency withdraw, the tracker for\r\n     * reward token will be reset. The function transfers the reward tokens from the reward pool\r\n     * to the staker and emits a `RewardDistribute` event to signal the distribution of rewards.\r\n     */\r\n    function distributeReward(uint256 poolId, uint256 stakeId, address staker) internal {\r\n        uint256 amount = poolUserStakes[poolId][staker][stakeId].stakeAmount;\r\n        address rewardTokenAddress = rewardPool[poolId].rewardToken;\r\n        uint256 reward = amount * rewardPool[poolId].rewardsPerStake / rewardPool[poolId].rewardsPerStakeAccuracyFactor;\r\n        if (\r\n            !poolUserClaimStatus[poolId][staker][stakeId] &&\r\n            block.timestamp > poolUserStakes[poolId][staker][stakeId].unstakeTime\r\n        ) {\r\n            rewardPool[poolId].amountClaimed += reward;\r\n            infoRewardToken[rewardTokenAddress].claimed += reward;\r\n            poolUserStakes[poolId][staker][stakeId].totalEarned += reward;\r\n            poolUserRewardAmount[poolId][staker][rewardTokenAddress] += reward;\r\n            poolUserClaimStatus[poolId][staker][stakeId] = true;\r\n            IERC20(rewardTokenAddress).transfer(staker, reward);\r\n            emit RewardDistribute(poolId, stakeId, reward, rewardTokenAddress, staker, msg.sender, block.timestamp);\r\n        }\r\n        if (\r\n            !poolUserClaimStatus[poolId][staker][stakeId] &&\r\n            block.timestamp <= poolUserStakes[poolId][msg.sender][stakeId].unstakeTime &&\r\n            emergencyWithdraw\r\n        ) {\r\n            rewardPool[poolId].amountAllocated -= reward;\r\n            poolUserClaimStatus[poolId][staker][stakeId] = true;\r\n            poolUserStakes[poolId][msg.sender][poolUserStakingInfo[poolId][msg.sender].totalStaking].rewardAmount = 0;\r\n        }\r\n\r\n    }\r\n\r\n    /* Stakers */\r\n\r\n    /*\r\n     * @notice Adds a staker to the specified pool.\r\n     * \r\n     * @param poolId The ID of the pool to which the staker is being added.\r\n     * @param staker The address of the staker being added.\r\n     * \r\n     * @dev This function is internal and should only be called within the contract.\r\n     */\r\n    function addStaker(uint256 poolId, address staker) internal {\r\n        rewardPool[poolId].totalStaker += 1;\r\n        poolStakerIndex[poolId][staker] = rewardPool[poolId].totalStaker;\r\n        poolStakerAtIndex[poolId][rewardPool[poolId].totalStaker] = staker;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a staker from the specified pool.\r\n     * \r\n     * @param poolId The ID of the pool from which the staker is being removed.\r\n     * @param staker The address of the staker being removed.\r\n     * \r\n     * @dev This function is internal and should only be called within the contract.\r\n    */\r\n    function removeStaker(uint256 poolId, address staker) internal {\r\n        uint256 currentIndex = poolStakerIndex[poolId][staker];\r\n        address lastStaker = poolStakerAtIndex[poolId][rewardPool[poolId].totalStaker];\r\n        \r\n        poolStakerIndex[poolId][lastStaker] = currentIndex;\r\n        poolStakerAtIndex[poolId][currentIndex] = lastStaker;\r\n        poolStakerIndex[poolId][staker] = 0;\r\n        poolStakerAtIndex[poolId][rewardPool[poolId].totalStaker] = address(0);\r\n\r\n        rewardPool[poolId].totalStaker -= 1;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"penaltyReceiverAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"AmountExceedMaxStakeAllowedForPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CanNoLongerRescueFund\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotUseAllCurrentAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"CannotUseCurrentAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"current\",\"type\":\"bool\"}],\"name\":\"CannotUseCurrentState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"CannotUseCurrentValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"CurrentAuthorizedState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InactiveStake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invalid\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidAuthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxId\",\"type\":\"uint256\"}],\"name\":\"InvalidPoolId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxId\",\"type\":\"uint256\"}],\"name\":\"InvalidStakeId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"invalid\",\"type\":\"uint256\"}],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"lockType\",\"type\":\"string\"}],\"name\":\"Locked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"}],\"name\":\"NotTimeToUnstake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"PoolNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProjectOwnerCannotInitiateTransferEther\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"Status\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"UserHasNoStaking\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lockType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardToReturn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PoolClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"addressType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authorizedAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateAuthorizedAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldStakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateStakingRule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"stateType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"valueType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateValue\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"checkReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenStake\",\"type\":\"uint256\"}],\"name\":\"createRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"currentStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAllPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getLeaderboard\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inactiveStaking\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct EternalAIStaking.Leaderboard[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"}],\"name\":\"infoRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"infoStakeToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFailsafeLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"}],\"name\":\"isRewardToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isStakeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockFailsafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockWToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"maxStakeAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"poolClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakerId\",\"type\":\"uint256\"}],\"name\":\"poolStakerAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"poolStakerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"poolUserClaimStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"}],\"name\":\"poolUserRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"poolUserStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"poolUserStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"stakeActive\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"poolUserStakingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inactiveStaking\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"rewardPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalStaker\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAllocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerStakeAccuracyFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerStakeAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takePenalty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"updateEmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPenalty\",\"type\":\"uint256\"}],\"name\":\"updatePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"updatePenaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"}],\"name\":\"updateStakingRule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"updateTakePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wTokenLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EternalAIStaking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000060927b83ddd2096f38f22a8a2d84cf863402d1a100000000000000000000000060927b83ddd2096f38f22a8a2d84cf863402d1a1000000000000000000000000e17e01eaa9a6eca41dbd87161736a0d76f21995a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58602ad17f645e57268abf20b85a2057c7faba7fbf739c719ceaa56bdd662307"}