{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Memswap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract Memswap is ReentrancyGuard {\\n    // --- Structs ---\\n\\n    struct Intent {\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        address maker;\\n        // The address allowed to solve or authorize others to solve\\n        address matchmaker;\\n        address source;\\n        uint16 feeBps;\\n        uint16 surplusBps;\\n        uint32 deadline;\\n        bool isPartiallyFillable;\\n        uint128 amountIn;\\n        uint128 endAmountOut;\\n        uint16 startAmountBps;\\n        uint16 expectedAmountBps;\\n        bytes signature;\\n    }\\n\\n    struct IntentStatus {\\n        bool isValidated;\\n        bool isCancelled;\\n        uint128 amountFilled;\\n    }\\n\\n    struct Authorization {\\n        uint128 maxAmountIn;\\n        uint128 minAmountOut;\\n        uint32 blockDeadline;\\n        bool isPartiallyFillable;\\n    }\\n\\n    struct Solution {\\n        address to;\\n        bytes data;\\n        uint128 amount;\\n    }\\n\\n    // --- Events ---\\n\\n    event IntentCancelled(bytes32 indexed intentHash);\\n    event IntentPosted();\\n    event IntentSolved(\\n        bytes32 indexed intentHash,\\n        address tokenIn,\\n        address tokenOut,\\n        address maker,\\n        address solver,\\n        uint128 amountIn,\\n        uint128 amountOut\\n    );\\n    event IntentValidated(bytes32 indexed intentHash);\\n\\n    // --- Errors ---\\n\\n    error AuthorizationIsExpired();\\n    error AuthorizationIsInsufficient();\\n    error AuthorizationIsNotPartiallyFillable();\\n    error IntentIsCancelled();\\n    error IntentIsExpired();\\n    error IntentIsFilled();\\n    error IntentIsNotPartiallyFillable();\\n    error InvalidSignature();\\n    error InvalidSolution();\\n    error MerkleTreeTooLarge();\\n    error Unauthorized();\\n    error UnsuccessfullCall();\\n\\n    // --- Fields ---\\n\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n    bytes32 public immutable AUTHORIZATION_TYPEHASH;\\n    bytes32 public immutable INTENT_TYPEHASH;\\n\\n    mapping(bytes32 => IntentStatus) public intentStatus;\\n    mapping(bytes32 => Authorization) public authorization;\\n\\n    // --- Constructor ---\\n\\n    constructor() {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(\\\"\\n                    \\\"string name,\\\"\\n                    \\\"string version,\\\"\\n                    \\\"uint256 chainId,\\\"\\n                    \\\"address verifyingContract\\\"\\n                    \\\")\\\"\\n                ),\\n                keccak256(\\\"Memswap\\\"),\\n                keccak256(\\\"1.0\\\"),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n\\n        AUTHORIZATION_TYPEHASH = keccak256(\\n            abi.encodePacked(\\n                \\\"Authorization(\\\",\\n                \\\"bytes32 intentHash,\\\",\\n                \\\"address authorizedSolver,\\\",\\n                \\\"uint128 maxAmountIn,\\\",\\n                \\\"uint128 minAmountOut,\\\",\\n                \\\"uint32 blockDeadline,\\\",\\n                \\\"bool isPartiallyFillable\\\",\\n                \\\")\\\"\\n            )\\n        );\\n\\n        INTENT_TYPEHASH = keccak256(\\n            abi.encodePacked(\\n                \\\"Intent(\\\",\\n                \\\"address tokenIn,\\\",\\n                \\\"address tokenOut,\\\",\\n                \\\"address maker,\\\",\\n                \\\"address matchmaker,\\\",\\n                \\\"address source,\\\",\\n                \\\"uint16 feeBps,\\\",\\n                \\\"uint16 surplusBps,\\\",\\n                \\\"uint32 deadline,\\\",\\n                \\\"bool isPartiallyFillable,\\\",\\n                \\\"uint128 amountIn,\\\",\\n                \\\"uint128 endAmountOut,\\\",\\n                \\\"uint16 startAmountBps,\\\",\\n                \\\"uint16 expectedAmountBps\\\",\\n                \\\")\\\"\\n            )\\n        );\\n    }\\n\\n    // Fallback\\n\\n    receive() external payable {}\\n\\n    // Public methods\\n\\n    /**\\n     * @notice Authorize an address to solve a particular intent\\n     *\\n     * @param intent Intent which is being solved\\n     * @param authorizedSolver The address authorized to solve the intent\\n     * @param auth Authorization details and conditions\\n     */\\n    function authorize(\\n        Intent calldata intent,\\n        address authorizedSolver,\\n        Authorization calldata auth\\n    ) external {\\n        if (intent.matchmaker != msg.sender) {\\n            revert Unauthorized();\\n        }\\n\\n        bytes32 intentHash = getIntentHash(intent);\\n        bytes32 authId = keccak256(\\n            abi.encodePacked(intentHash, authorizedSolver)\\n        );\\n        authorization[authId] = auth;\\n    }\\n\\n    /**\\n     * @notice Make an intent available on-chain (this method doesn't do\\n     *         anything useful, it's only used as a mechanism for intent\\n     *         distribution)\\n     *\\n     * @custom:param intent Intent being made available\\n     */\\n    function post(\\n        /**\\n         * @custom:name intent\\n         */\\n        Intent calldata\\n    ) external {\\n        emit IntentPosted();\\n    }\\n\\n    /**\\n     * @notice Validate an arbitrary number of intents (the signature of each\\n     *         intent will be checked thus resulting in skipping verification\\n     *         on further attempts to solve the intent)\\n     *\\n     * @param intents Intents to validate\\n     */\\n    function validate(Intent[] calldata intents) external {\\n        uint256 length = intents.length;\\n        for (uint256 i; i < length; ) {\\n            Intent calldata intent = intents[i];\\n\\n            bytes32 intentHash = getIntentHash(intent);\\n\\n            _validateIntent(intentHash, intent.maker, intent.signature);\\n            emit IntentValidated(intentHash);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Cancel an arbitrary number of intents\\n     *\\n     * @param intents Intents to cancel\\n     */\\n    function cancel(Intent[] calldata intents) external nonReentrant {\\n        uint256 length = intents.length;\\n        for (uint256 i; i < length; ) {\\n            Intent calldata intent = intents[i];\\n            if (intent.maker != msg.sender) {\\n                revert Unauthorized();\\n            }\\n\\n            bytes32 intentHash = getIntentHash(intent);\\n            IntentStatus memory status = intentStatus[intentHash];\\n            status.isValidated = false;\\n            status.isCancelled = true;\\n\\n            intentStatus[intentHash] = status;\\n            emit IntentCancelled(intentHash);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Solve an intent\\n     *\\n     * @param intent Intent to solve\\n     * @param solution Solution for the intent\\n     */\\n    function solve(\\n        Intent calldata intent,\\n        Solution calldata solution\\n    ) external nonReentrant {\\n        // The intent must be open or tied to the current solver\\n        if (\\n            intent.matchmaker != address(0) && intent.matchmaker != msg.sender\\n        ) {\\n            revert Unauthorized();\\n        }\\n\\n        // Solve (no minimum amount out restrictions when filling without authorization)\\n        _solve(intent, solution, 0);\\n    }\\n\\n    /**\\n     * @notice Solve an intent with authorization (compared to the regular `solve`\\n     *         this method allows filling intents of a matchmaker as long as there\\n     *         is a valid authorization in-place for the current solver). The auth\\n     *         will be done on-chain (via a transaction from the matchmaker).\\n     *\\n     * @param intent Intent to solve\\n     * @param solution Solution for the intent\\n     */\\n    function solveWithOnChainAuthorizationCheck(\\n        Intent calldata intent,\\n        Solution calldata solution\\n    ) external nonReentrant {\\n        bytes32 intentHash = getIntentHash(intent);\\n\\n        // Fetch the authorization\\n        bytes32 authId = keccak256(abi.encodePacked(intentHash, msg.sender));\\n        Authorization memory auth = authorization[authId];\\n\\n        // Check the authorization and solve\\n        _checkAuthorization(auth, solution.amount);\\n        _solve(intent, solution, auth.minAmountOut);\\n    }\\n\\n    /**\\n     * @notice Solve an intent with authorization (compared to the regular `solve`\\n     *         this method allows filling intents of a matchmaker as long as there\\n     *         is a valid authorization in-place for the current solver). The auth\\n     *         will be done off-chain (via a signature from the matchmaker).\\n     *\\n     * @param intent Intent to solve\\n     * @param solution Solution for the intent\\n     * @param auth Authorization details/conditions\\n     * @param signature Authorization signature\\n     */\\n    function solveWithSignatureAuthorizationCheck(\\n        Intent calldata intent,\\n        Solution calldata solution,\\n        Authorization calldata auth,\\n        bytes calldata signature\\n    ) external nonReentrant {\\n        bytes32 intentHash = getIntentHash(intent);\\n        bytes32 authorizationHash = getAuthorizationHash(\\n            intentHash,\\n            msg.sender,\\n            auth\\n        );\\n\\n        // Verify the authorization\\n        bytes32 digest = _getEIP712Hash(authorizationHash);\\n        _assertValidSignature(\\n            intent.matchmaker,\\n            digest,\\n            digest,\\n            signature.length,\\n            signature\\n        );\\n\\n        // Check the authorization and solve\\n        _checkAuthorization(auth, solution.amount);\\n        _solve(intent, solution, auth.minAmountOut);\\n    }\\n\\n    // View methods\\n\\n    /**\\n     * @notice Get the EIP712 struct hash for an authorization\\n     *\\n     * @param intentHash Intent EIP712 struct hash to authorize\\n     * @param authorizedSolver Solver to authorize\\n     * @param auth Authorization details/conditions\\n     *\\n     * @return authorizationHash The EIP712 struct hash of the authorization\\n     */\\n    function getAuthorizationHash(\\n        bytes32 intentHash,\\n        address authorizedSolver,\\n        Authorization memory auth\\n    ) public view returns (bytes32 authorizationHash) {\\n        authorizationHash = keccak256(\\n            abi.encode(\\n                AUTHORIZATION_TYPEHASH,\\n                intentHash,\\n                authorizedSolver,\\n                auth.maxAmountIn,\\n                auth.minAmountOut,\\n                auth.blockDeadline,\\n                auth.isPartiallyFillable\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Get the EIP712 struct hash for an intent\\n     *\\n     * @param intent Intent to compute the hash for\\n     *\\n     * @return intentHash The EIP712 struct hash of the intent\\n     */\\n    function getIntentHash(\\n        Intent memory intent\\n    ) public view returns (bytes32 intentHash) {\\n        intentHash = keccak256(\\n            abi.encode(\\n                INTENT_TYPEHASH,\\n                intent.tokenIn,\\n                intent.tokenOut,\\n                intent.maker,\\n                intent.matchmaker,\\n                intent.source,\\n                intent.feeBps,\\n                intent.surplusBps,\\n                intent.deadline,\\n                intent.isPartiallyFillable,\\n                intent.amountIn,\\n                intent.endAmountOut,\\n                intent.startAmountBps,\\n                intent.expectedAmountBps\\n            )\\n        );\\n    }\\n\\n    // Internal methods\\n\\n    /**\\n     * @dev Solve an intent\\n     *\\n     * @param intent Intent to solve\\n     * @param solution Solution for the intent\\n     * @param minAmountOut The minimum amount out the solution is required to fulfill\\n     */\\n    function _solve(\\n        Intent calldata intent,\\n        Solution calldata solution,\\n        uint128 minAmountOut\\n    ) internal {\\n        bytes32 intentHash = getIntentHash(intent);\\n\\n        // Verify deadline\\n        if (intent.deadline < block.timestamp) {\\n            revert IntentIsExpired();\\n        }\\n\\n        IntentStatus memory status = intentStatus[intentHash];\\n\\n        // Verify cancellation status\\n        if (status.isCancelled) {\\n            revert IntentIsCancelled();\\n        }\\n\\n        // Verify signature\\n        if (!status.isValidated) {\\n            _validateIntent(intentHash, intent.maker, intent.signature);\\n        }\\n\\n        uint128 amountToFill;\\n        // Avoid \\\"Stack too deep\\\" errors by wrapping inside a block\\n        {\\n            // Ensure there's still some amount left to be filled\\n            uint128 amountAvailable = intent.amountIn - status.amountFilled;\\n            if (amountAvailable == 0) {\\n                revert IntentIsFilled();\\n            }\\n\\n            // Ensure non-partially-fillable intents are fully filled\\n            if (\\n                !intent.isPartiallyFillable && solution.amount < amountAvailable\\n            ) {\\n                revert IntentIsNotPartiallyFillable();\\n            }\\n\\n            // Compute the amount available to fill\\n            amountToFill = solution.amount > amountAvailable\\n                ? amountAvailable\\n                : solution.amount;\\n            intentStatus[intentHash].amountFilled += amountToFill;\\n        }\\n\\n        // Transfer inputs to fill contract\\n        if (amountToFill > 0) {\\n            _transferToken(\\n                intent.maker,\\n                solution.to,\\n                intent.tokenIn,\\n                amountToFill\\n            );\\n        }\\n\\n        // Execute solution\\n        // Avoid \\\"Stack too deep\\\" errors by wrapping inside a block\\n        {\\n            (bool result, ) = solution.to.call(solution.data);\\n            if (!result) {\\n                revert UnsuccessfullCall();\\n            }\\n        }\\n\\n        // Check\\n\\n        uint128 endAmountOut = intent.endAmountOut;\\n        uint128 startAmountOut = endAmountOut +\\n            (endAmountOut * intent.startAmountBps) /\\n            10000;\\n        uint128 expectedAmountOut = endAmountOut +\\n            (endAmountOut * intent.expectedAmountBps) /\\n            10000;\\n\\n        //                                (startAmount - endAmount)\\n        // requiredAmount = startAmount - -------------------------\\n        //                                   (deadline - now())\\n\\n        uint128 requiredAmountOut = startAmountOut -\\n            (startAmountOut - endAmountOut) /\\n            (\\n                intent.deadline > uint32(block.timestamp)\\n                    ? intent.deadline - uint32(block.timestamp)\\n                    : 1\\n            );\\n\\n        if (requiredAmountOut < minAmountOut) {\\n            revert InvalidSolution();\\n        }\\n\\n        uint256 tokenOutBalance = address(intent.tokenOut) == address(0)\\n            ? address(this).balance\\n            : intent.tokenOut.allowance(solution.to, address(this));\\n\\n        // Ensure the maker got at least what he intended\\n        if (tokenOutBalance < requiredAmountOut) {\\n            revert InvalidSolution();\\n        }\\n\\n        if (intent.source != address(0)) {\\n            uint256 amount;\\n\\n            // Charge fee\\n            if (intent.feeBps > 0) {\\n                amount += (requiredAmountOut * intent.feeBps) / 10000;\\n            }\\n\\n            // Charge surplus fee\\n            if (\\n                intent.surplusBps > 0 &&\\n                tokenOutBalance > expectedAmountOut &&\\n                expectedAmountOut > requiredAmountOut\\n            ) {\\n                amount +=\\n                    ((tokenOutBalance - expectedAmountOut) *\\n                        intent.surplusBps) /\\n                    10000;\\n            }\\n\\n            // Transfer fees\\n            if (amount > 0) {\\n                _transferToken(\\n                    solution.to,\\n                    intent.source,\\n                    intent.tokenOut,\\n                    amount\\n                );\\n\\n                tokenOutBalance -= amount;\\n            }\\n        }\\n\\n        // Transfer ouputs to maker\\n        if (tokenOutBalance > 0) {\\n            _transferToken(\\n                solution.to,\\n                intent.maker,\\n                intent.tokenOut,\\n                tokenOutBalance\\n            );\\n        }\\n\\n        emit IntentSolved(\\n            intentHash,\\n            address(intent.tokenIn),\\n            address(intent.tokenOut),\\n            intent.maker,\\n            msg.sender,\\n            amountToFill,\\n            uint128(tokenOutBalance)\\n        );\\n    }\\n\\n    /**\\n     * @dev Check an authorization\\n     *\\n     * @param auth Authorization to check\\n     * @param amount Amount to check the authorization against\\n     */\\n    function _checkAuthorization(\\n        Authorization memory auth,\\n        uint128 amount\\n    ) internal view {\\n        // Ensure the authorization is not expired\\n        if (auth.blockDeadline < block.number) {\\n            revert AuthorizationIsExpired();\\n        }\\n\\n        // Ensure the amount doesn't exceed the maximum authorized amount\\n        if (auth.maxAmountIn < amount) {\\n            revert AuthorizationIsInsufficient();\\n        }\\n\\n        // Ensure non-partially-fillable authorizations are fully filled\\n        if (!auth.isPartiallyFillable && auth.maxAmountIn != amount) {\\n            revert AuthorizationIsNotPartiallyFillable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the EIP712 hash of a struct hash\\n     *\\n     * @param structHash Struct hash to get the EIP712 hash for\\n     *\\n     * @return eip712Hash The resulting EIP712 hash\\n     */\\n    function _getEIP712Hash(\\n        bytes32 structHash\\n    ) internal view returns (bytes32 eip712Hash) {\\n        eip712Hash = keccak256(\\n            abi.encodePacked(hex\\\"1901\\\", DOMAIN_SEPARATOR, structHash)\\n        );\\n    }\\n\\n    /**\\n     * @dev Validate an intent by checking its signature\\n     *\\n     * @param intentHash EIP712 intent struct hash to verify\\n     * @param maker The maker of the intent\\n     * @param signature The signature of the intent\\n     */\\n    function _validateIntent(\\n        bytes32 intentHash,\\n        address maker,\\n        bytes calldata signature\\n    ) internal {\\n        _verifySignature(intentHash, maker, signature);\\n\\n        // Mark the intent as validated\\n        intentStatus[intentHash].isValidated = true;\\n    }\\n\\n    /**\\n     * @dev Helper method for transferring native and ERC20 tokens\\n     *\\n     * @param from Transfer from this address\\n     * @param to Transfer to this address\\n     * @param token Token to transfer\\n     * @param amount Amonut to transfer\\n     */\\n    function _transferToken(\\n        address from,\\n        address to,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        // Represent native tokens as `address(0)`\\n        if (address(token) == address(0)) {\\n            (success, ) = to.call{value: amount}(\\\"\\\");\\n        } else {\\n            success = token.transferFrom(from, to, amount);\\n        }\\n\\n        if (!success) {\\n            revert UnsuccessfullCall();\\n        }\\n    }\\n\\n    // Copied from Seaport's source code\\n\\n    function _verifySignature(\\n        bytes32 intentHash,\\n        address signer,\\n        bytes memory signature\\n    ) internal view {\\n        // Skip signature verification if the signer is the caller\\n        if (signer == msg.sender) {\\n            return;\\n        }\\n\\n        bytes32 originalDigest = _getEIP712Hash(intentHash);\\n\\n        // Read the length of the signature from memory and place on the stack\\n        uint256 originalSignatureLength = signature.length;\\n\\n        // Determine effective digest if signature has a valid bulk order size\\n        bytes32 digest;\\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\\n            // Rederive order hash and digest using bulk order proof\\n            (intentHash) = _computeBulkOrderProof(signature, intentHash);\\n            digest = _getEIP712Hash(intentHash);\\n        } else {\\n            // Supply the original digest as the effective digest\\n            digest = originalDigest;\\n        }\\n\\n        // Ensure that the signature for the digest is valid for the signer\\n        _assertValidSignature(\\n            signer,\\n            digest,\\n            originalDigest,\\n            originalSignatureLength,\\n            signature\\n        );\\n    }\\n\\n    function _isValidBulkOrderSize(\\n        uint256 signatureLength\\n    ) internal pure returns (bool validLength) {\\n        // Utilize assembly to validate the length:\\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24)\\n        assembly {\\n            validLength := and(\\n                lt(sub(signatureLength, 0x63), 0x2e2),\\n                lt(and(add(signatureLength, 0x1d), 0x1f), 0x2)\\n            )\\n        }\\n    }\\n\\n    function _computeBulkOrderProof(\\n        bytes memory proofAndSignature,\\n        bytes32 leaf\\n    ) internal pure returns (bytes32 bulkOrderHash) {\\n        // Declare arguments for the root hash and the height of the proof\\n        bytes32 root;\\n        uint256 height;\\n\\n        // Utilize assembly to efficiently derive the root hash using the proof\\n        assembly {\\n            // Retrieve the length of the proof, key, and signature combined\\n            let fullLength := mload(proofAndSignature)\\n\\n            // If proofAndSignature has odd length, it is a compact signature with 64 bytes\\n            let signatureLength := sub(65, and(fullLength, 1))\\n\\n            // Derive height (or depth of tree) with signature and proof length\\n            height := shr(0x5, sub(fullLength, signatureLength))\\n\\n            // Update the length in memory to only include the signature\\n            mstore(proofAndSignature, signatureLength)\\n\\n            // Derive the pointer for the key using the signature length\\n            let keyPtr := add(proofAndSignature, add(0x20, signatureLength))\\n\\n            // Retrieve the three-byte key using the derived pointer\\n            let key := shr(0xe8, mload(keyPtr))\\n\\n            // Retrieve pointer to first proof element by applying a constant for the key size to the derived key pointer\\n            let proof := add(keyPtr, 0x3)\\n\\n            // Compute level 1\\n            let scratchPtr1 := shl(0x5, and(key, 1))\\n            mstore(scratchPtr1, leaf)\\n            mstore(xor(scratchPtr1, 0x20), mload(proof))\\n\\n            // Compute remaining proofs\\n            for {\\n                let i := 1\\n            } lt(i, height) {\\n                i := add(i, 1)\\n            } {\\n                proof := add(proof, 0x20)\\n                let scratchPtr := shl(0x5, and(shr(i, key), 1))\\n                mstore(scratchPtr, keccak256(0, 0x40))\\n                mstore(xor(scratchPtr, 0x20), mload(proof))\\n            }\\n\\n            // Compute root hash\\n            root := keccak256(0, 0x40)\\n        }\\n\\n        // Retrieve appropriate typehash constant based on height.\\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\\n\\n        // Use the typehash and the root hash to derive final bulk order hash\\n        assembly {\\n            mstore(0, rootTypeHash)\\n            mstore(0x20, root)\\n            bulkOrderHash := keccak256(0, 0x40)\\n        }\\n    }\\n\\n    function _lookupBulkOrderTypehash(\\n        uint256 treeHeight\\n    ) internal pure returns (bytes32 typeHash) {\\n        // kecca256(\\\"BatchIntent(Intent[2] tree)Intent(address tokenIn,address tokenOut,address maker,address matchmaker,address source,uint16 feeBps,uint16 surplusBps,uint32 deadline,bool isPartiallyFillable,uint128 amountIn,uint128 endAmountOut,uint16 startAmountBps,uint16 expectedAmountBps)\\\")\\n        if (treeHeight == 1) {\\n            typeHash = 0xa09b55b2b0f1611c4db0b312fc7063c8438a51497adc137310360981267db3ef;\\n        } else if (treeHeight == 2) {\\n            typeHash = 0x04440a5b85b1ac9a5931adc223455ce5ee3db7c8a2779030b9b8db54e2b85799;\\n        } else if (treeHeight == 3) {\\n            typeHash = 0x3201a8c99184de74eeba60a0f95ba5677e2d05308248224cff5d53314a25b768;\\n        } else if (treeHeight == 4) {\\n            typeHash = 0x5f9c3a9757945e640a0e6f0fa11269b3d05f3516b8377caf06a22bcd47f19a0c;\\n        } else if (treeHeight == 5) {\\n            typeHash = 0x49b5887b13176700800be2e1ec7eece8e4683eba84310a7a49f8acda23a84cc9;\\n        } else if (treeHeight == 6) {\\n            typeHash = 0x5aba5e52e068d52122f8220dda000664baf304f522ceface6940df335ca128fb;\\n        } else if (treeHeight == 7) {\\n            typeHash = 0xa004a0ff682c47acac1378afc7985f7c43efbd1adea9248e30d6afad0b0211e8;\\n        } else if (treeHeight == 8) {\\n            typeHash = 0x0745413a2bfe7693ff806398f8d59424166d165d7c16591bcfa1d4ce7cc168f5;\\n        } else {\\n            revert MerkleTreeTooLarge();\\n        }\\n    }\\n\\n    function _assertValidSignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes32 originalDigest,\\n        uint256 originalSignatureLength,\\n        bytes memory signature\\n    ) internal view {\\n        // Declare value for ecrecover equality or 1271 call success status\\n        bool success;\\n\\n        // Utilize assembly to perform optimized signature verification check\\n        assembly {\\n            // Ensure that first word of scratch space is empty\\n            mstore(0, 0)\\n\\n            // Get the length of the signature.\\n            let signatureLength := mload(signature)\\n\\n            // Get the pointer to the value preceding the signature length\\n            // This will be used for temporary memory overrides - either the signature head for isValidSignature or the digest for ecrecover\\n            let wordBeforeSignaturePtr := sub(signature, 0x20)\\n\\n            // Cache the current value behind the signature to restore it later\\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\\n\\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure\\n            {\\n                // Take the difference between the max ECDSA signature length and the actual signature length (overflow desired for any values > 65)\\n                // If the diff is not 0 or 1, it is not a valid ECDSA signature - move on to EIP1271 check\\n                let lenDiff := sub(65, signatureLength)\\n\\n                // Declare variable for recovered signer\\n                let recoveredSigner\\n\\n                // If diff is 0 or 1, it may be an ECDSA signature\\n                // Try to recover signer\\n                if iszero(gt(lenDiff, 1)) {\\n                    // Read the signature `s` value\\n                    let originalSignatureS := mload(add(signature, 0x40))\\n\\n                    // Read the first byte of the word after `s`\\n                    // If the signature is 65 bytes, this will be the real `v` value\\n                    // If not, it will need to be modified - doing it this way saves an extra condition.\\n                    let v := byte(0, mload(add(signature, 0x60)))\\n\\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA\\n                    if lenDiff {\\n                        // Extract yParity from highest bit of vs and add 27 to get v\\n                        v := add(shr(0xff, originalSignatureS), 27)\\n\\n                        // Extract canonical s from vs, all but the highest bit\\n                        // Temporarily overwrite the original `s` value in the signature\\n                        mstore(\\n                            add(signature, 0x40),\\n                            and(\\n                                originalSignatureS,\\n                                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n                            )\\n                        )\\n                    }\\n                    // Temporarily overwrite the signature length with `v` to conform to the expected input for ecrecover\\n                    mstore(signature, v)\\n\\n                    // Temporarily overwrite the word before the length with `digest` to conform to the expected input for ecrecover\\n                    mstore(wordBeforeSignaturePtr, digest)\\n\\n                    // Attempt to recover the signer for the given signature\\n                    // Do not check the call status as ecrecover will return a null address if the signature is invalid\\n                    pop(\\n                        staticcall(\\n                            gas(),\\n                            0x1, // Call ecrecover precompile\\n                            wordBeforeSignaturePtr, // Use data memory location\\n                            0x80, // Size of digest, v, r, and s\\n                            0, // Write result to scratch space\\n                            0x20 // Provide size of returned result\\n                        )\\n                    )\\n\\n                    // Restore cached word before signature\\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\\n\\n                    // Restore cached signature length\\n                    mstore(signature, signatureLength)\\n\\n                    // Restore cached signature `s` value\\n                    mstore(add(signature, 0x40), originalSignatureS)\\n\\n                    // Read the recovered signer from the buffer given as return space for ecrecover\\n                    recoveredSigner := mload(0)\\n                }\\n\\n                // Set success to true if the signature provided was a valid\\n                // ECDSA signature and the signer is not the null address\\n                // Use gt instead of direct as success is used outside of assembly\\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\\n            }\\n\\n            // If the signature was not verified with ecrecover, try EIP1271\\n            if iszero(success) {\\n                // Reset the original signature length\\n                mstore(signature, originalSignatureLength)\\n\\n                // Temporarily overwrite the word before the signature length and use it as the\\n                // head of the signature input to `isValidSignature`, which has a value of 64\\n                mstore(wordBeforeSignaturePtr, 0x40)\\n\\n                // Get pointer to use for the selector of `isValidSignature`\\n                let selectorPtr := sub(signature, 0x44)\\n\\n                // Cache the value currently stored at the selector pointer\\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\\n\\n                // Cache the value currently stored at the digest pointer\\n                let cachedWordOverwrittenByDigest := mload(sub(signature, 0x40))\\n\\n                // Write the selector first, since it overlaps the digest\\n                mstore(selectorPtr, 0x44)\\n\\n                // Next, write the original digest\\n                mstore(sub(signature, 0x40), originalDigest)\\n\\n                // Call signer with `isValidSignature` to validate signature\\n                success := staticcall(\\n                    gas(),\\n                    signer,\\n                    selectorPtr,\\n                    add(originalSignatureLength, 0x64),\\n                    0,\\n                    0x20\\n                )\\n\\n                // Determine if the signature is valid on successful calls\\n                if success {\\n                    // If first word of scratch space does not contain EIP-1271 signature selector, revert\\n                    if iszero(\\n                        eq(\\n                            mload(0),\\n                            0x1626ba7e00000000000000000000000000000000000000000000000000000000\\n                        )\\n                    ) {\\n                        success := 0\\n                    }\\n                }\\n\\n                // Restore the cached values overwritten by selector, digest and signature head\\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\\n                mstore(sub(signature, 0x40), cachedWordOverwrittenByDigest)\\n            }\\n        }\\n\\n        if (!success) {\\n            revert InvalidSignature();\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AuthorizationIsExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuthorizationIsInsufficient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuthorizationIsNotPartiallyFillable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntentIsCancelled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntentIsExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntentIsFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntentIsNotPartiallyFillable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSolution\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MerkleTreeTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsuccessfullCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"intentHash\",\"type\":\"bytes32\"}],\"name\":\"IntentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IntentPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"intentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amountOut\",\"type\":\"uint128\"}],\"name\":\"IntentSolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"intentHash\",\"type\":\"bytes32\"}],\"name\":\"IntentValidated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTENT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"authorization\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"maxAmountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"blockDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"authorizedSolver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"maxAmountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"blockDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"}],\"internalType\":\"struct Memswap.Authorization\",\"name\":\"auth\",\"type\":\"tuple\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent[]\",\"name\":\"intents\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"intentHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"authorizedSolver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"maxAmountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"blockDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"}],\"internalType\":\"struct Memswap.Authorization\",\"name\":\"auth\",\"type\":\"tuple\"}],\"name\":\"getAuthorizationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"authorizationHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent\",\"name\":\"intent\",\"type\":\"tuple\"}],\"name\":\"getIntentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"intentHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"intentStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountFilled\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"post\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct Memswap.Solution\",\"name\":\"solution\",\"type\":\"tuple\"}],\"name\":\"solve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct Memswap.Solution\",\"name\":\"solution\",\"type\":\"tuple\"}],\"name\":\"solveWithOnChainAuthorizationCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct Memswap.Solution\",\"name\":\"solution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"maxAmountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"blockDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"}],\"internalType\":\"struct Memswap.Authorization\",\"name\":\"auth\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"solveWithSignatureAuthorizationCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matchmaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surplusBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"deadline\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPartiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endAmountOut\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"startAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expectedAmountBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Memswap.Intent[]\",\"name\":\"intents\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Memswap", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}