{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SpreadSheet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport { Ownable } from \\\"@openzeppelin/access/Ownable.sol\\\";\\nimport { Pausable } from \\\"@openzeppelin/security/Pausable.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/token/ERC721/IERC721.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/utils/cryptography/MerkleProof.sol\\\";\\n\\n/**\\n *\\n *     _____                          _ _____ _               _\\n *    /  ___|                        | /  ___| |             | |\\n *    \\\\ `--. _ __  _ __ ___  __ _  __| \\\\ `--.| |__   ___  ___| |_\\n *     `--. \\\\ '_ \\\\| '__/ _ \\\\/ _` |/ _` |`--. \\\\ '_ \\\\ / _ \\\\/ _ \\\\ __|\\n *    /\\\\__/ / |_) | | |  __/ (_| | (_| /\\\\__/ / | | |  __/  __/ |_\\n *    \\\\____/| .__/|_|  \\\\___|\\\\__,_|\\\\__,_\\\\____/|_| |_|\\\\___|\\\\___|\\\\__|\\n *          | |\\n *          |_|\\n */\\n\\n/// @title SpreadSheet\\n/// @notice Handles the claim and distribution of SHEETs.\\ncontract SpreadSheet is Ownable, Pausable {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when the number of SHEETs an allocatee is trying to claim exceeds their allocation amount.\\n    ///\\n    /// @param allocatee The account that is trying to claim SHEETs.\\n    /// @param allocation The total number of SHEETs allocated to the allocatee.\\n    /// @param totalClaimedAfter The total number of SHEETs the allocatee is trying to have after claiming.\\n    error SpreadSheet__AllocationExceeded(address allocatee, uint256 allocation, uint256 totalClaimedAfter);\\n\\n    /// @notice Thrown when the provided transition Merkle proof is invalid.\\n    ///\\n    /// @param sheetId The ID of the SHEET linked with the provided proof.\\n    /// @param botsId The ID of the BOT linked with the provided proof.\\n    error SpreadSheet__InvalidTransitionProof(uint256 sheetId, uint256 botsId);\\n\\n    /// @notice Thrown when the provided allocation Merkle proof is invalid.\\n    ///\\n    /// @param allocatee The allocatee account linked with the provided proof.\\n    /// @param allocation The allocation amount linked with the provided proof.\\n    error SpreadSheet__InvalidAllocationProof(address allocatee, uint256 allocation);\\n\\n    /// @notice Thrown when the provided allocation sheet ID is invalid.\\n    ///\\n    /// @param sheetId The provided allocation sheet ID.\\n    error SpreadSheet__InvalidAllocationSheetId(uint256 sheetId);\\n\\n    /// @notice Thrown when the provided inputs are not of the same length.\\n    error SpreadSheet__MismatchedInputs();\\n\\n    /// @notice Thrown when the caller is trying to claim 0 SHEETs.\\n    error SpreadSheet__ZeroClaim();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when claiming SHEETs in exchange for burning BOTS.\\n    /// @param claimer The account that claimed the SHEETs.\\n    /// @param sheetIds The IDs of the SHEETs that were claimed.\\n    /// @param botsIds The IDs of the BOTS that were burned.\\n    event ClaimSheetsViaTransition(address indexed claimer, uint256[] sheetIds, uint256[] botsIds);\\n\\n    /// @notice Emitted when claiming SHEETs that were allocated to the caller account.\\n    /// @param claimer The account that claimed the SHEETs.\\n    /// @param sheetIds The IDs of the SHEETs that were claimed.\\n    /// @param allocation The total number of SHEETs allocated to the caller.\\n    event ClaimSheetsViaAllocation(address indexed claimer, uint256[] sheetIds, uint256 allocation);\\n\\n    /// @notice Emitted when the owner withdraws SHEETs from the contract.\\n    /// @param recipient The account that received the SHEETs.\\n    /// @param sheetIds The IDs of the SHEETs that were withdrawn.\\n    event AdminWithdraw(address indexed recipient, uint256[] sheetIds);\\n\\n    /// @notice Emitted when the owner pauses the claim process.\\n    event PauseClaims();\\n\\n    /// @notice Emitted when the owner unpauses the claim process.\\n    event UnpauseClaims();\\n\\n    /// @notice Emitted when the transition Merkle root is set.\\n    /// @param newTransitionMerkleRoot The new transition Merkle root.\\n    event SetTransitionMerkleRoot(bytes32 newTransitionMerkleRoot);\\n\\n    /// @notice Emitted when the allocation Merkle root is set.\\n    /// @param newAllocationMerkleRoot The new allocation Merkle root.\\n    event SetAllocationMerkleRoot(bytes32 newAllocationMerkleRoot);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                   PUBLIC STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The Sheetheads NFT contract whose tokens are to be distributed.\\n    IERC721 public immutable sheetNFT;\\n\\n    /// @notice The Pawn Bots NFT contract whose tokens are to be burned.\\n    IERC721 public immutable botsNFT;\\n\\n    /// @notice The ID of the first SHEET to be allocated.\\n    /// @dev Allocated IDs are contiguous.\\n    uint256 public immutable allocationSheetIdStart;\\n\\n    /// @notice The Merkle root of the BOTS -> SHEET transition Merkle tree.\\n    bytes32 public transitionMerkleRoot;\\n\\n    /// @notice The Merkle root of the SHEET allocation Merkle tree.\\n    bytes32 public allocationMerkleRoot;\\n\\n    /// @notice The total number of SHEETs claimed by an allocatee.\\n    mapping(address => uint256) public totalClaimed;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @param sheetNFT_ The Sheetheads NFT contract whose tokens are to be distributed.\\n    /// @param botsNFT_ The Pawn Bots NFT contract whose tokens are to be burned.\\n    /// @param allocationSheetIdStart_ The ID of the first SHEET to be allocated.\\n    constructor(IERC721 sheetNFT_, IERC721 botsNFT_, uint256 allocationSheetIdStart_) {\\n        sheetNFT = sheetNFT_;\\n        botsNFT = botsNFT_;\\n        allocationSheetIdStart = allocationSheetIdStart_;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                               NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Claim SHEETs in exchange for burning BOTS and/or claiming SHEETs that were allocated to the caller.\\n    ///\\n    /// @param sheetIdsToClaimViaTransition The IDs of the SHEETs to claim via transition.\\n    /// @param sheetIdsToClaimViaAllocation The IDs of the SHEETs to claim via allocation.\\n    /// @param botsIdsToBurnViaTransition The IDs of the BOTS to burn via transition.\\n    /// @param allocationAmount The total number of SHEETs allocated to the caller.\\n    /// @param transitionProofs The Merkle proofs for verifying transition claims.\\n    /// @param allocationProof The Merkle proof for verifying the allocation claim.\\n    function claimSheets(\\n        uint256[] calldata sheetIdsToClaimViaTransition,\\n        uint256[] calldata sheetIdsToClaimViaAllocation,\\n        uint256[] calldata botsIdsToBurnViaTransition,\\n        uint256 allocationAmount,\\n        bytes32[][] calldata transitionProofs,\\n        bytes32[] calldata allocationProof\\n    )\\n        external\\n    {\\n        if (sheetIdsToClaimViaTransition.length > 0) {\\n            claimSheetsViaTransition({\\n                sheetIdsToClaim: sheetIdsToClaimViaTransition,\\n                botsIdsToBurn: botsIdsToBurnViaTransition,\\n                transitionProofs: transitionProofs\\n            });\\n        }\\n        if (sheetIdsToClaimViaAllocation.length > 0) {\\n            claimSheetsViaAllocation({\\n                sheetIdsToClaim: sheetIdsToClaimViaAllocation,\\n                allocation: allocationAmount,\\n                allocationProof: allocationProof\\n            });\\n        }\\n    }\\n\\n    /// @notice Claim SHEETs in exchange for burning BOTS.\\n    ///\\n    /// @dev Emits a {ClaimSheetsViaTransition} event.\\n    ///\\n    /// Requirements:\\n    /// - All provided inputs must be the same length.\\n    /// - The number of SHEETs to claim must be greater than 0.\\n    /// - Each provided transition Merkle proof must be valid.\\n    /// - The caller must own all of the BOTS IDs to burn.\\n    ///\\n    /// @param sheetIdsToClaim The IDs of the SHEETs to claim.\\n    /// @param botsIdsToBurn The IDs of the BOTS to burn.\\n    /// @param transitionProofs The Merkle proofs for verifying transition claims.\\n    function claimSheetsViaTransition(\\n        uint256[] calldata sheetIdsToClaim,\\n        uint256[] calldata botsIdsToBurn,\\n        bytes32[][] calldata transitionProofs\\n    )\\n        public\\n        whenNotPaused\\n    {\\n        if (sheetIdsToClaim.length != botsIdsToBurn.length || sheetIdsToClaim.length != transitionProofs.length) {\\n            revert SpreadSheet__MismatchedInputs();\\n        }\\n        if (sheetIdsToClaim.length == 0) {\\n            revert SpreadSheet__ZeroClaim();\\n        }\\n        for (uint256 i = 0; i < sheetIdsToClaim.length; i++) {\\n            if (\\n                !MerkleProof.verify({\\n                    proof: transitionProofs[i],\\n                    root: transitionMerkleRoot,\\n                    leaf: keccak256(abi.encodePacked(botsIdsToBurn[i], sheetIdsToClaim[i]))\\n                })\\n            ) {\\n                revert SpreadSheet__InvalidTransitionProof({ sheetId: sheetIdsToClaim[i], botsId: botsIdsToBurn[i] });\\n            }\\n            botsNFT.transferFrom({ from: msg.sender, to: address(0xdead), tokenId: botsIdsToBurn[i] });\\n            sheetNFT.transferFrom({ from: address(this), to: msg.sender, tokenId: sheetIdsToClaim[i] });\\n        }\\n        emit ClaimSheetsViaTransition({ claimer: msg.sender, sheetIds: sheetIdsToClaim, botsIds: botsIdsToBurn });\\n    }\\n\\n    /// @notice Claim SHEETs that were allocated to the caller account.\\n    ///\\n    /// @dev Emits a {ClaimSheetsViaAllocation} event.\\n    ///\\n    /// Requirements:\\n    /// - All provided inputs must be the same length.\\n    /// - The number of SHEETs to claim must be greater than 0.\\n    /// - The provided allocation Merkle proof must be valid.\\n    /// - The number of SHEETs to claim must not exceed the number of SHEETs allocated to the caller account.\\n    /// - Each provided allocation reserve Merkle proof must be valid.\\n    ///\\n    /// @param sheetIdsToClaim The IDs of the SHEETs to claim.\\n    /// @param allocation The total number of SHEETs allocated to the caller.\\n    /// @param allocationProof The Merkle proof for verifying the allocation claim.\\n    function claimSheetsViaAllocation(\\n        uint256[] calldata sheetIdsToClaim,\\n        uint256 allocation,\\n        bytes32[] calldata allocationProof\\n    )\\n        public\\n        whenNotPaused\\n    {\\n        if (sheetIdsToClaim.length == 0) {\\n            revert SpreadSheet__ZeroClaim();\\n        }\\n        if (\\n            !MerkleProof.verify({\\n                proof: allocationProof,\\n                root: allocationMerkleRoot,\\n                leaf: keccak256(abi.encodePacked(msg.sender, allocation))\\n            })\\n        ) {\\n            revert SpreadSheet__InvalidAllocationProof({ allocatee: msg.sender, allocation: allocation });\\n        }\\n        uint256 totalClaimedAfter = sheetIdsToClaim.length + totalClaimed[msg.sender];\\n        if (totalClaimedAfter > allocation) {\\n            revert SpreadSheet__AllocationExceeded({\\n                allocatee: msg.sender,\\n                allocation: allocation,\\n                totalClaimedAfter: totalClaimedAfter\\n            });\\n        }\\n        totalClaimed[msg.sender] = totalClaimedAfter;\\n        for (uint256 i = 0; i < sheetIdsToClaim.length; i++) {\\n            if (sheetIdsToClaim[i] < allocationSheetIdStart) {\\n                revert SpreadSheet__InvalidAllocationSheetId(sheetIdsToClaim[i]);\\n            }\\n            sheetNFT.transferFrom({ from: address(this), to: msg.sender, tokenId: sheetIdsToClaim[i] });\\n        }\\n        emit ClaimSheetsViaAllocation({ claimer: msg.sender, sheetIds: sheetIdsToClaim, allocation: allocation });\\n    }\\n\\n    /// @notice Withdraw SHEETs from the contract.\\n    ///\\n    /// @dev Emits a {AdminWithdraw} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be the owner.\\n    ///\\n    /// @param recipient The address to withdraw to.\\n    /// @param sheetIds The IDs of the SHEETs to withdraw.\\n    function adminWithdraw(address recipient, uint256[] calldata sheetIds) external onlyOwner whenPaused {\\n        for (uint256 i = 0; i < sheetIds.length; i++) {\\n            sheetNFT.transferFrom({ from: address(this), to: recipient, tokenId: sheetIds[i] });\\n        }\\n        emit AdminWithdraw({ recipient: recipient, sheetIds: sheetIds });\\n    }\\n\\n    /// @notice Pause the claim process.\\n    ///\\n    /// @dev Emits a {PauseClaims} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be the owner.\\n    ///\\n    function pauseClaims() external onlyOwner {\\n        _pause();\\n        emit PauseClaims();\\n    }\\n\\n    /// @notice Unpause the claim process.\\n    ///\\n    /// @dev Emits an {UnpauseClaims} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be the owner.\\n    ///\\n    function unpauseClaims() external onlyOwner {\\n        _unpause();\\n        emit UnpauseClaims();\\n    }\\n\\n    /// @notice Set the Merkle root of the BOTS -> SHEET transition Merkle tree.\\n    ///\\n    /// @dev Emits a {SetTransitionMerkleRoot} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be the owner.\\n    ///\\n    /// @param newTransitionMerkleRoot The new transition Merkle root.\\n    function setTransitionMerkleRoot(bytes32 newTransitionMerkleRoot) external onlyOwner {\\n        transitionMerkleRoot = newTransitionMerkleRoot;\\n        emit SetTransitionMerkleRoot(newTransitionMerkleRoot);\\n    }\\n\\n    /// @notice Set the Merkle root of the SHEET allocation Merkle tree.\\n    ///\\n    /// @dev Emits a {SetAllocationMerkleRoot} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be the owner.\\n    ///\\n    /// @param newAllocationMerkleRoot The new allocation Merkle root.\\n    function setAllocationMerkleRoot(bytes32 newAllocationMerkleRoot) external onlyOwner {\\n        allocationMerkleRoot = newAllocationMerkleRoot;\\n        emit SetAllocationMerkleRoot(newAllocationMerkleRoot);\\n    }\\n}\\n\"\r\n    },\r\n    \"modules/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"modules/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"modules/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"modules/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"modules/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"modules/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=modules/openzeppelin-contracts/contracts/\",\r\n      \"ERC721A/=modules/ERC721A/contracts/\",\r\n      \"ds-test/=modules/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=modules/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a/=modules/ERC721A/contracts/\",\r\n      \"forge-std/=modules/forge-std/src/\",\r\n      \"murky/=modules/murky/src/\",\r\n      \"openzeppelin-contracts/=modules/openzeppelin-contracts/\",\r\n      \"openzeppelin/=modules/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"sheetNFT_\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"botsNFT_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocationSheetIdStart_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allocatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedAfter\",\"type\":\"uint256\"}],\"name\":\"SpreadSheet__AllocationExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allocatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"SpreadSheet__InvalidAllocationProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheetId\",\"type\":\"uint256\"}],\"name\":\"SpreadSheet__InvalidAllocationSheetId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"botsId\",\"type\":\"uint256\"}],\"name\":\"SpreadSheet__InvalidTransitionProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SpreadSheet__MismatchedInputs\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SpreadSheet__ZeroClaim\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"sheetIds\",\"type\":\"uint256[]\"}],\"name\":\"AdminWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"sheetIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"ClaimSheetsViaAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"sheetIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"botsIds\",\"type\":\"uint256[]\"}],\"name\":\"ClaimSheetsViaTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseClaims\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newAllocationMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"SetAllocationMerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newTransitionMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"SetTransitionMerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpauseClaims\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"sheetIds\",\"type\":\"uint256[]\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationSheetIdStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botsNFT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sheetIdsToClaimViaTransition\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sheetIdsToClaimViaAllocation\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"botsIdsToBurnViaTransition\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"allocationAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[][]\",\"name\":\"transitionProofs\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bytes32[]\",\"name\":\"allocationProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimSheets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sheetIdsToClaim\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"allocationProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimSheetsViaAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sheetIdsToClaim\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"botsIdsToBurn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"transitionProofs\",\"type\":\"bytes32[][]\"}],\"name\":\"claimSheetsViaTransition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseClaims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newAllocationMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setAllocationMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newTransitionMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setTransitionMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sheetNFT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transitionMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseClaims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SpreadSheet", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000aa14657d3a563c679dfd807150edcce0833b29ba00000000000000000000000028f0521c77923f107e29a5502a5a1152517f90000000000000000000000000000000000000000000000000000000000000001ba7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}